00001                                           ! 1 
00002                                           ! 1 # 1 "_rombios_.c"
00003                                           ! 1 #asm
00004                                           !BCC_ASM
00005 0000                                      .rom
00006 0000                                      .org 0x0000
00007                                           use16 386
00008                                           MACRO HALT
00009                                             ;; the HALT macro is called with the line number of the HALT call.
00010                                             ;; The line number is then sent to the 0x400, causing Bochs/Plex
00011                                             ;; to print a BX_PANIC message. This will normally halt the simulation
00012                                             ;; with a message such as "BIOS panic at rombios.c, line 4091".
00013                                             ;; However, users can choose to make panics non-fatal and continue.
00014                                             mov dx,#0x400
00015                                             mov ax,#?1
00016                                             out dx,ax
00017                                           MEND
00018                                           MACRO JMP_AP
00019                                             db 0xea
00020                                             dw ?2
00021                                             dw ?1
00022                                           MEND
00023                                           MACRO SET_INT_VECTOR
00024                                             mov ax, ?3
00025                                             mov ?1*4, ax
00026                                             mov ax, ?2
00027                                             mov ?1*4+2, ax
00028                                           MEND
00029                                           ! 26 endasm
00030                                           !BCC_ENDASM
00031                                           ! 27 typedef unsigned char Bit8u;
00032                                           !BCC_EOS
00033                                           ! 28 typedef unsigned short Bit16u;
00034                                           !BCC_EOS
00035                                           ! 29 typedef unsigned short bx_bool;
00036                                           !BCC_EOS
00037                                           ! 30 typedef unsigned long Bit32u;
00038                                           !BCC_EOS
00039                                           ! 31   void _memsetb(value,offset,seg,count);
00040                                           !BCC_EOS
00041                                           ! 32   void _memcpyb(doffset,dseg,soffset,sseg,count);
00042                                           !BCC_EOS
00043                                           ! 33   void _memcpyd(doffset,dseg,soffset,sseg,count);
00044                                           !BCC_EOS
00045                                           ! 34     void
00046                                           ! 35   _memsetb(value,offset,seg,count)
00047                                           ! 36     Bit16u value;
00048                                           export	__memsetb
00049                       00000000            __memsetb:
00050                                           !BCC_EOS
00051                                           ! 37     Bit16u offset;
00052                                           !BCC_EOS
00053                                           ! 38     Bit16u seg;
00054                                           !BCC_EOS
00055                                           ! 39     Bit16u count;
00056                                           !BCC_EOS
00057                                           ! 40   {
00058                                           ! 41 #asm
00059                                           !BCC_ASM
00060                       00000008            __memsetb.count	set	8
00061                       00000006            __memsetb.seg	set	6
00062                       00000002            __memsetb.value	set	2
00063                       00000004            __memsetb.offset	set	4
00064 0000           55                             push bp
00065 0001           89E5                           mov bp, sp
00066 0003           50                               push ax
00067 0004           51                               push cx
00068 0005           06                               push es
00069 0006           57                               push di
00070 0007           8B4E         0A                  mov cx, 10[bp] ; count
00071 000A           E3           09                  jcxz memsetb_end
00072 000C           C47E         06                  les di, 6[bp] ; segment & offset
00073 000F           8A46         04                  mov al, 4[bp] ; value
00074 0012           FC                               cld
00075 0013           F3                               rep
00076 0014           AA                                stosb
00077                       00000015              memsetb_end:
00078 0015           5F                               pop di
00079 0016           07                               pop es
00080 0017           59                               pop cx
00081 0018           58                               pop ax
00082 0019           5D                             pop bp
00083                                           ! 61 endasm
00084                                           !BCC_ENDASM
00085                                           ! 62   }
00086 001A           C3                         ret
00087                                           ! 63     void
00088                                           ! 64   _memcpyb(doffset,dseg,soffset,sseg,count)
00089                                           ! 65     Bit16u doffset;
00090                                           export	__memcpyb
00091                       0000001B            __memcpyb:
00092                                           !BCC_EOS
00093                                           ! 66     Bit16u dseg;
00094                                           !BCC_EOS
00095                                           ! 67     Bit16u soffset;
00096                                           !BCC_EOS
00097                                           ! 68     Bit16u sseg;
00098                                           !BCC_EOS
00099                                           ! 69     Bit16u count;
00100                                           !BCC_EOS
00101                                           ! 70   {
00102                                           ! 71 #asm
00103                                           !BCC_ASM
00104                       0000000A            __memcpyb.count	set	$A
00105                       00000008            __memcpyb.sseg	set	8
00106                       00000006            __memcpyb.soffset	set	6
00107                       00000004            __memcpyb.dseg	set	4
00108                       00000002            __memcpyb.doffset	set	2
00109 001B           55                             push bp
00110 001C           89E5                           mov bp, sp
00111 001E           51                               push cx
00112 001F           06                               push es
00113 0020           57                               push di
00114 0021           1E                               push ds
00115 0022           56                               push si
00116 0023           8B4E         0C                  mov cx, 12[bp] ; count
00117 0026           E3           09                  jcxz memcpyb_end
00118 0028           C47E         04                  les di, 4[bp] ; dsegment & doffset
00119 002B           C576         08                  lds si, 8[bp] ; ssegment & soffset
00120 002E           FC                               cld
00121 002F           F3                               rep
00122 0030           A4                                movsb
00123                       00000031              memcpyb_end:
00124 0031           5E                               pop si
00125 0032           1F                               pop ds
00126 0033           5F                               pop di
00127 0034           07                               pop es
00128 0035           59                               pop cx
00129 0036           5D                             pop bp
00130                                           ! 93 endasm
00131                                           !BCC_ENDASM
00132                                           ! 94   }
00133 0037           C3                         ret
00134                                           ! 95     void
00135                                           ! 96   _memcpyd(doffset,dseg,soffset,sseg,count)
00136                                           ! 97     Bit16u doffset;
00137                                           export	__memcpyd
00138                       00000038            __memcpyd:
00139                                           !BCC_EOS
00140                                           ! 98     Bit16u dseg;
00141                                           !BCC_EOS
00142                                           ! 99     Bit16u soffset;
00143                                           !BCC_EOS
00144                                           ! 100     Bit16u sseg;
00145                                           !BCC_EOS
00146                                           ! 101     Bit16u count;
00147                                           !BCC_EOS
00148                                           ! 102   {
00149                                           ! 103 #asm
00150                                           !BCC_ASM
00151                       0000000A            __memcpyd.count	set	$A
00152                       00000008            __memcpyd.sseg	set	8
00153                       00000006            __memcpyd.soffset	set	6
00154                       00000004            __memcpyd.dseg	set	4
00155                       00000002            __memcpyd.doffset	set	2
00156 0038           55                             push bp
00157 0039           89E5                           mov bp, sp
00158 003B           51                               push cx
00159 003C           06                               push es
00160 003D           57                               push di
00161 003E           1E                               push ds
00162 003F           56                               push si
00163 0040           8B4E         0C                  mov cx, 12[bp] ; count
00164 0043           E3           0A                  jcxz memcpyd_end
00165 0045           C47E         04                  les di, 4[bp] ; dsegment & doffset
00166 0048           C576         08                  lds si, 8[bp] ; ssegment & soffset
00167 004B           FC                               cld
00168 004C           F3                               rep
00169 004D     66    A5                                movsd
00170                       0000004F              memcpyd_end:
00171 004F           5E                               pop si
00172 0050           1F                               pop ds
00173 0051           5F                               pop di
00174 0052           07                               pop es
00175 0053           59                               pop cx
00176 0054           5D                             pop bp
00177                                           ! 125 endasm
00178                                           !BCC_ENDASM
00179                                           ! 126   }
00180 0055           C3                         ret
00181                                           ! 127   static Bit32u _read_dword();
00182                                           !BCC_EOS
00183                                           ! 128   static void _write_dword();
00184                                           !BCC_EOS
00185                                           ! 129   static Bit32u read_dword_SS();
00186                                           !BCC_EOS
00187                                           ! 130     Bit32u
00188                                           ! 131   _read_dword(offset, seg)
00189                                           ! 132     Bit16u seg;
00190                                           export	__read_dword
00191                       00000056            __read_dword:
00192                                           !BCC_EOS
00193                                           ! 133     Bit16u offset;
00194                                           !BCC_EOS
00195                                           ! 134   {
00196                                           ! 135 #asm
00197                                           !BCC_ASM
00198                       00000004            __read_dword.seg	set	4
00199                       00000002            __read_dword.offset	set	2
00200 0056           55                             push bp
00201 0057           89E5                           mov bp, sp
00202 0059           53                               push bx
00203 005A           1E                               push ds
00204 005B           C55E         04                  lds bx, 4[bp] ; segment & offset
00205 005E           8B07                             mov ax, [bx]
00206 0060           8B57         02                  mov dx, 2[bx]
00207                                                 ;; ax = return value (word)
00208                                                 ;; dx = return value (word)
00209 0063           1F                               pop ds
00210 0064           5B                               pop bx
00211 0065           5D                             pop bp
00212                                           ! 148 endasm
00213                                           !BCC_ENDASM
00214                                           ! 149   }
00215 0066           C3                         ret
00216                                           ! 150     void
00217                                           ! 151   _write_dword(data, offset, seg)
00218                                           ! 152     Bit32u data;
00219                                           export	__write_dword
00220                       00000067            __write_dword:
00221                                           !BCC_EOS
00222                                           ! 153     Bit16u offset;
00223                                           !BCC_EOS
00224                                           ! 154     Bit16u seg;
00225                                           !BCC_EOS
00226                                           ! 155   {
00227                                           ! 156 #asm
00228                                           !BCC_ASM
00229                       00000008            __write_dword.seg	set	8
00230                       00000002            __write_dword.data	set	2
00231                       00000006            __write_dword.offset	set	6
00232 0067           55                             push bp
00233 0068           89E5                           mov bp, sp
00234 006A     66    50                               push eax
00235 006C           53                               push bx
00236 006D           1E                               push ds
00237 006E           C55E         08                  lds bx, 8[bp] ; segment & offset
00238 0071     66    8B46         04                  mov eax, 4[bp] ; data dword
00239 0075     66    8907                             mov [bx], eax ; write data dword
00240 0078           1F                               pop ds
00241 0079           5B                               pop bx
00242 007A     66    58                               pop eax
00243 007C           5D                             pop bp
00244                                           ! 169 endasm
00245                                           !BCC_ENDASM
00246                                           ! 170   }
00247 007D           C3                         ret
00248                                           ! 171     Bit32u
00249                                           ! 172   read_dword_SS(offset)
00250                                           ! 173     Bit16u offset;
00251                                           export	_read_dword_SS
00252                       0000007E            _read_dword_SS:
00253                                           !BCC_EOS
00254                                           ! 174   {
00255                                           ! 175 #asm
00256                                           !BCC_ASM
00257                       00000002            _read_dword_SS.offset	set	2
00258 007E           55                             push bp
00259 007F           89E5                           mov bp, sp
00260 0081           8B6E         04                mov bp, 4[bp] ; offset
00261 0084           8B46         00                mov ax, [bp]
00262 0087           8B56         02                mov dx, 2[bp]
00263                                               ;; ax = return value (word)
00264                                               ;; dx = return value (word)
00265 008A           5D                             pop bp
00266                                           ! 184 endasm
00267                                           !BCC_ENDASM
00268                                           ! 185   }
00269 008B           C3                         ret
00270                                           ! 186 #asm
00271                                           !BCC_ASM
00272                       00000002            _read_dword_SS.offset	set	2
00273                                             ;; and function
00274                       0000008C              landl:
00275                       0000008C              landul:
00276 008C           36                             SEG SS
00277 008D           2305                             and ax,[di]
00278 008F           36                             SEG SS
00279 0090           235D         02                  and bx,2[di]
00280 0093           C3                             ret
00281                                             ;; add function
00282                       00000094              laddl:
00283                       00000094              laddul:
00284 0094           36                             SEG SS
00285 0095           0305                             add ax,[di]
00286 0097           36                             SEG SS
00287 0098           135D         02                  adc bx,2[di]
00288 009B           C3                             ret
00289                                             ;; cmp function
00290                       0000009C              lcmpl:
00291                       0000009C              lcmpul:
00292 009C     66    25               0000FFFF      and eax, #0x0000FFFF
00293 00A2     66    C1E3                   10      shl ebx, #16
00294 00A6     66    09D8                           or eax, ebx
00295 00A9     66    C1EB                   10      shr ebx, #16
00296 00AD           36                             SEG SS
00297 00AE     66    3B05                             cmp eax, dword ptr [di]
00298 00B1           C3                             ret
00299                                             ;; sub function
00300                       000000B2              lsubl:
00301                       000000B2              lsubul:
00302 00B2           36                             SEG SS
00303 00B3           2B05                           sub ax,[di]
00304 00B5           36                             SEG SS
00305 00B6           1B5D         02                sbb bx,2[di]
00306 00B9           C3                             ret
00307                                             ;; mul function
00308                       000000BA              lmull:
00309                       000000BA              lmulul:
00310 00BA     66    25               0000FFFF      and eax, #0x0000FFFF
00311 00C0     66    C1E3                   10      shl ebx, #16
00312 00C4     66    09D8                           or eax, ebx
00313 00C7           36                             SEG SS
00314 00C8     66    F725                           mul eax, dword ptr [di]
00315 00CB     66    89C3                           mov ebx, eax
00316 00CE     66    C1EB                   10      shr ebx, #16
00317 00D2           C3                             ret
00318                                             ;; dec function
00319                       000000D3              ldecl:
00320                       000000D3              ldecul:
00321 00D3           36                             SEG SS
00322 00D4     66    FF0F                           dec dword ptr [bx]
00323 00D7           C3                             ret
00324                                             ;; or function
00325                       000000D8              lorl:
00326                       000000D8              lorul:
00327 00D8           36                             SEG SS
00328 00D9           0B05                           or ax,[di]
00329 00DB           36                             SEG SS
00330 00DC           0B5D         02                or bx,2[di]
00331 00DF           C3                             ret
00332                                             ;; inc function
00333                       000000E0              lincl:
00334                       000000E0              lincul:
00335 00E0           36                             SEG SS
00336 00E1     66    FF07                           inc dword ptr [bx]
00337 00E4           C3                             ret
00338                                             ;; tst function
00339                       000000E5              ltstl:
00340                       000000E5              ltstul:
00341 00E5     66    25               0000FFFF      and eax, #0x0000FFFF
00342 00EB     66    C1E3                   10      shl ebx, #16
00343 00EF     66    09D8                           or eax, ebx
00344 00F2     66    C1EB                   10      shr ebx, #16
00345 00F6     66    85C0                           test eax, eax
00346 00F9           C3                             ret
00347                                             ;; sr function
00348                       000000FA              lsrul:
00349 00FA           89F9                           mov cx,di
00350 00FC           E3           19                jcxz lsr_exit
00351 00FE     66    25               0000FFFF      and eax, #0x0000FFFF
00352 0104     66    C1E3                   10      shl ebx, #16
00353 0108     66    09D8                           or eax, ebx
00354                       0000010B              lsr_loop:
00355 010B     66    D1E8                           shr eax, #1
00356 010E           E2           FB                loop lsr_loop
00357 0110     66    89C3                           mov ebx, eax
00358 0113     66    C1EB                   10      shr ebx, #16
00359                       00000117              lsr_exit:
00360 0117           C3                             ret
00361                                             ;; sl function
00362                       00000118              lsll:
00363                       00000118              lslul:
00364 0118           89F9                           mov cx,di
00365 011A           E3           19                jcxz lsl_exit
00366 011C     66    25               0000FFFF      and eax, #0x0000FFFF
00367 0122     66    C1E3                   10      shl ebx, #16
00368 0126     66    09D8                           or eax, ebx
00369                       00000129              lsl_loop:
00370 0129     66    D1E0                           shl eax, #1
00371 012C           E2           FB                loop lsl_loop
00372 012E     66    89C3                           mov ebx, eax
00373 0131     66    C1EB                   10      shr ebx, #16
00374                       00000135              lsl_exit:
00375 0135           C3                             ret
00376                       00000136              idiv_:
00377 0136           99                             cwd
00378 0137           F7FB                           idiv bx
00379 0139           C3                             ret
00380                       0000013A              idiv_u:
00381 013A           31D2                           xor dx,dx
00382 013C           F7F3                           div bx
00383 013E           C3                             ret
00384                       0000013F              ldivul:
00385 013F     66    25               0000FFFF      and eax, #0x0000FFFF
00386 0145     66    C1E3                   10      shl ebx, #16
00387 0149     66    09D8                           or eax, ebx
00388 014C     66    31D2                           xor edx, edx
00389 014F           36                             SEG SS
00390 0150           8B5D         02                mov bx, 2[di]
00391 0153     66    C1E3                   10      shl ebx, #16
00392 0157           36                             SEG SS
00393 0158           8B1D                           mov bx, [di]
00394 015A     66    F7F3                           div ebx
00395 015D     66    89C3                           mov ebx, eax
00396 0160     66    C1EB                   10      shr ebx, #16
00397 0164           C3                             ret
00398                       00000165              imodu:
00399 0165           F6F3                           div bl
00400 0167           88E0                           mov al, ah
00401 0169           30E4                           xor ah, ah
00402 016B           C3                             ret
00403                                           ! 317 endasm
00404                                           !BCC_ENDASM
00405                                           ! 318 typedef struct {
00406                                           ! 319   unsigned char filler1[0x400];
00407                                           !BCC_EOS
00408                                           ! 320   unsigned char filler2[0x6c];
00409                                           !BCC_EOS
00410                                           ! 321   Bit16u ticks_low;
00411                                           !BCC_EOS
00412                                           ! 322   Bit16u ticks_high;
00413                                           !BCC_EOS
00414                                           ! 323   Bit8u midnight_flag;
00415                                           !BCC_EOS
00416                                           ! 324 } bios_data_t;
00417                                           !BCC_EOS
00418                                           ! 325   typedef struct {
00419                                           ! 326     Bit16u heads;
00420                                           !BCC_EOS
00421                                           ! 327     Bit16u cylinders;
00422                                           !BCC_EOS
00423                                           ! 328     Bit16u spt;
00424                                           !BCC_EOS
00425                                           ! 329   } chs_t;
00426                                           !BCC_EOS
00427                                           ! 330   typedef struct {
00428                                           ! 331     Bit16u iobase1;
00429                                           !BCC_EOS
00430                                           ! 332     Bit16u iobase2;
00431                                           !BCC_EOS
00432                                           ! 333     Bit8u prefix;
00433                                           !BCC_EOS
00434                                           ! 334     Bit8u unused;
00435                                           !BCC_EOS
00436                                           ! 335     Bit8u irq;
00437                                           !BCC_EOS
00438                                           ! 336     Bit8u blkcount;
00439                                           !BCC_EOS
00440                                           ! 337     Bit8u dma;
00441                                           !BCC_EOS
00442                                           ! 338     Bit8u pio;
00443                                           !BCC_EOS
00444                                           ! 339     Bit16u options;
00445                                           !BCC_EOS
00446                                           ! 340     Bit16u reserved;
00447                                           !BCC_EOS
00448                                           ! 341     Bit8u revision;
00449                                           !BCC_EOS
00450                                           ! 342     Bit8u checksum;
00451                                           !BCC_EOS
00452                                           ! 343   } dpte_t;
00453                                           !BCC_EOS
00454                                           ! 344   typedef struct {
00455                                           ! 345     Bit8u iface;
00456                                           !BCC_EOS
00457                                           ! 346     Bit16u iobase1;
00458                                           !BCC_EOS
00459                                           ! 347     Bit16u iobase2;
00460                                           !BCC_EOS
00461                                           ! 348     Bit8u irq;
00462                                           !BCC_EOS
00463                                           ! 349   } ata_channel_t;
00464                                           !BCC_EOS
00465                                           ! 350   typedef struct {
00466                                           ! 351     Bit8u type;
00467                                           !BCC_EOS
00468                                           ! 352     Bit8u device;
00469                                           !BCC_EOS
00470                                           ! 353     Bit8u removable;
00471                                           !BCC_EOS
00472                                           ! 354     Bit8u lock;
00473                                           !BCC_EOS
00474                                           ! 355     Bit8u mode;
00475                                           !BCC_EOS
00476                                           ! 356     Bit16u blksize;
00477                                           !BCC_EOS
00478                                           ! 357     Bit8u translation;
00479                                           !BCC_EOS
00480                                           ! 358     chs_t lchs;
00481                                           !BCC_EOS
00482                                           ! 359     chs_t pchs;
00483                                           !BCC_EOS
00484                                           ! 360     Bit32u sectors_low;
00485                                           !BCC_EOS
00486                                           ! 361     Bit32u sectors_high;
00487                                           !BCC_EOS
00488                                           ! 362   } ata_device_t;
00489                                           !BCC_EOS
00490                                           ! 363   typedef struct {
00491                                           ! 364     ata_channel_t channels[4];
00492                                           !BCC_EOS
00493                                           ! 365     ata_device_t devices[(4*2)];
00494                                           !BCC_EOS
00495                                           ! 366     Bit8u
00496                                           ! 366  hdcount, hdidmap[(4*2)];
00497                                           !BCC_EOS
00498                                           ! 367     Bit8u cdcount, cdidmap[(4*2)];
00499                                           !BCC_EOS
00500                                           ! 368     dpte_t dpte;
00501                                           !BCC_EOS
00502                                           ! 369     Bit16u trsfsectors;
00503                                           !BCC_EOS
00504                                           ! 370     Bit32u trsfbytes;
00505                                           !BCC_EOS
00506                                           ! 371   } ata_t;
00507                                           !BCC_EOS
00508                                           ! 372   typedef struct {
00509                                           ! 373     Bit8u active;
00510                                           !BCC_EOS
00511                                           ! 374     Bit8u media;
00512                                           !BCC_EOS
00513                                           ! 375     Bit8u emulated_drive;
00514                                           !BCC_EOS
00515                                           ! 376     Bit8u controller_index;
00516                                           !BCC_EOS
00517                                           ! 377     Bit16u device_spec;
00518                                           !BCC_EOS
00519                                           ! 378     Bit32u ilba;
00520                                           !BCC_EOS
00521                                           ! 379     Bit16u buffer_segment;
00522                                           !BCC_EOS
00523                                           ! 380     Bit16u load_segment;
00524                                           !BCC_EOS
00525                                           ! 381     Bit16u sector_count;
00526                                           !BCC_EOS
00527                                           ! 382     chs_t vdevice;
00528                                           !BCC_EOS
00529                                           ! 383   } cdemu_t;
00530                                           !BCC_EOS
00531                                           ! 384   typedef struct {
00532                                           ! 385     Bit8u size;
00533                                           !BCC_EOS
00534                                           ! 386     unsigned char filler0[0x21];
00535                                           !BCC_EOS
00536                                           ! 387     Bit16u mouse_driver_offset;
00537                                           !BCC_EOS
00538                                           ! 388     Bit16u mouse_driver_seg;
00539                                           !BCC_EOS
00540                                           ! 389     Bit8u mouse_flag1;
00541                                           !BCC_EOS
00542                                           ! 390     Bit8u mouse_flag2;
00543                                           !BCC_EOS
00544                                           ! 391     Bit8u mouse_data[0x08];
00545                                           !BCC_EOS
00546                                           ! 392     unsigned char filler1[0x0D];
00547                                           !BCC_EOS
00548                                           ! 393     unsigned char fdpt0[0x10];
00549                                           !BCC_EOS
00550                                           ! 394     unsigned char fdpt1[0x10];
00551                                           !BCC_EOS
00552                                           ! 395     unsigned char filler2[0xC4];
00553                                           !BCC_EOS
00554                                           ! 396     ata_t ata;
00555                                           !BCC_EOS
00556                                           ! 397     cdemu_t cdemu;
00557                                           !BCC_EOS
00558                                           ! 398   } ebda_data_t;
00559                                           !BCC_EOS
00560                                           ! 399   typedef struct {
00561                                           ! 400     Bit8u size;
00562                                           !BCC_EOS
00563                                           ! 401     Bit8u reserved;
00564                                           !BCC_EOS
00565                                           ! 402     Bit16u count;
00566                                           !BCC_EOS
00567                                           ! 403     Bit16u offset;
00568                                           !BCC_EOS
00569                                           ! 404     Bit16u segment;
00570                                           !BCC_EOS
00571                                           ! 405     Bit32u lba1;
00572                                           !BCC_EOS
00573                                           ! 406     Bit32u lba2;
00574                                           !BCC_EOS
00575                                           ! 407   } int13ext_t;
00576                                           !BCC_EOS
00577                                           ! 408   typedef struct {
00578                                           ! 409     Bit16u size;
00579                                           !BCC_EOS
00580                                           ! 410     Bit16u infos;
00581                                           !BCC_EOS
00582                                           ! 411     Bit32u cylinders;
00583                                           !BCC_EOS
00584                                           ! 412     Bit32u heads;
00585                                           !BCC_EOS
00586                                           ! 413     Bit32u spt;
00587                                           !BCC_EOS
00588                                           ! 414     Bit32u sector_count1;
00589                                           !BCC_EOS
00590                                           ! 415     Bit32u sector_count2;
00591                                           !BCC_EOS
00592                                           ! 416     Bit16u blksize;
00593                                           !BCC_EOS
00594                                           ! 417     Bit16u dpte_offset;
00595                                           !BCC_EOS
00596                                           ! 418     Bit16u dpte_segment;
00597                                           !BCC_EOS
00598                                           ! 419     union {
00599                                           ! 420       struct {
00600                                           ! 421         Bit16u key;
00601                                           !BCC_EOS
00602                                           ! 422         Bit8u dpi_length;
00603                                           !BCC_EOS
00604                                           ! 423         Bit8u reserved1;
00605                                           !BCC_EOS
00606                                           ! 424         Bit16u reserved2;
00607                                           !BCC_EOS
00608                                           ! 425         Bit8u host_bus[4];
00609                                           !BCC_EOS
00610                                           ! 426         Bit8u iface_type[8];
00611                                           !BCC_EOS
00612                                           ! 427         Bit8u iface_path[8];
00613                                           !BCC_EOS
00614                                           ! 428         Bit8u device_path[8];
00615                                           !BCC_EOS
00616                                           ! 429         Bit8u reserved3;
00617                                           !BCC_EOS
00618                                           ! 430         Bit8u checksum;
00619                                           !BCC_EOS
00620                                           ! 431       } phoenix;
00621                                           !BCC_EOS
00622                                           ! 432       struct {
00623                                           ! 433         Bit16u key;
00624                                           !BCC_EOS
00625                                           ! 434         Bit8u dpi_length;
00626                                           !BCC_EOS
00627                                           ! 435         Bit8u reserved1;
00628                                           !BCC_EOS
00629                                           ! 436         Bit16u reserved2;
00630                                           !BCC_EOS
00631                                           ! 437         Bit8u host_bus[4];
00632                                           !BCC_EOS
00633                                           ! 438         Bit8u iface_type[8];
00634                                           !BCC_EOS
00635                                           ! 439         Bit8u iface_path[8];
00636                                           !BCC_EOS
00637                                           ! 440         Bit8u device_path[16];
00638                                           !BCC_EOS
00639                                           ! 441         Bit8u reserved3;
00640                                           !BCC_EOS
00641                                           ! 442         Bit8u checksum;
00642                                           !BCC_EOS
00643                                           ! 443       } t13;
00644                                           !BCC_EOS
00645                                           ! 444     } dpi;
00646                                           !BCC_EOS
00647                                           ! 445   } dpt_t;
00648                                           !BCC_EOS
00649                                           ! 446 typedef struct {
00650                                           ! 447   union {
00651                                           ! 448     struct {
00652                                           ! 449       Bit16u di, si, bp, sp;
00653                                           !BCC_EOS
00654                                           ! 450       Bit16u bx, dx, cx, ax;
00655                                           !BCC_EOS
00656                                           ! 451     } r16;
00657                                           !BCC_EOS
00658                                           ! 452     struct {
00659                                           ! 453       Bit16u filler[4];
00660                                           !BCC_EOS
00661                                           ! 454       Bit8u bl, bh, dl, dh, cl, ch, al, ah;
00662                                           !BCC_EOS
00663                                           ! 455     } r8;
00664                                           !BCC_EOS
00665                                           ! 456   } u;
00666                                           !BCC_EOS
00667                                           ! 457 } pusha_regs_t;
00668                                           !BCC_EOS
00669                                           ! 458 typedef struct {
00670                                           ! 459  union {
00671                                           ! 460   struct {
00672                                           ! 461    
00673                                           ! 461  Bit32u edi, esi, ebp, esp;
00674                                           !BCC_EOS
00675                                           ! 462     Bit32u ebx, edx, ecx, eax;
00676                                           !BCC_EOS
00677                                           ! 463   } r32;
00678                                           !BCC_EOS
00679                                           ! 464   struct {
00680                                           ! 465     Bit16u di, filler1, si, filler2, bp, filler3, sp, filler4;
00681                                           !BCC_EOS
00682                                           ! 466     Bit16u bx, filler5, dx, filler6, cx, filler7, ax, filler8;
00683                                           !BCC_EOS
00684                                           ! 467   } r16;
00685                                           !BCC_EOS
00686                                           ! 468   struct {
00687                                           ! 469     Bit32u filler[4];
00688                                           !BCC_EOS
00689                                           ! 470     Bit8u bl, bh;
00690                                           !BCC_EOS
00691                                           ! 471     Bit16u filler1;
00692                                           !BCC_EOS
00693                                           ! 472     Bit8u dl, dh;
00694                                           !BCC_EOS
00695                                           ! 473     Bit16u filler2;
00696                                           !BCC_EOS
00697                                           ! 474     Bit8u cl, ch;
00698                                           !BCC_EOS
00699                                           ! 475     Bit16u filler3;
00700                                           !BCC_EOS
00701                                           ! 476     Bit8u al, ah;
00702                                           !BCC_EOS
00703                                           ! 477     Bit16u filler4;
00704                                           !BCC_EOS
00705                                           ! 478   } r8;
00706                                           !BCC_EOS
00707                                           ! 479  } u;
00708                                           !BCC_EOS
00709                                           ! 480 } pushad_regs_t;
00710                                           !BCC_EOS
00711                                           ! 481 typedef struct {
00712                                           ! 482   union {
00713                                           ! 483     struct {
00714                                           ! 484       Bit16u flags;
00715                                           !BCC_EOS
00716                                           ! 485     } r16;
00717                                           !BCC_EOS
00718                                           ! 486     struct {
00719                                           ! 487       Bit8u flagsl;
00720                                           !BCC_EOS
00721                                           ! 488       Bit8u flagsh;
00722                                           !BCC_EOS
00723                                           ! 489     } r8;
00724                                           !BCC_EOS
00725                                           ! 490   } u;
00726                                           !BCC_EOS
00727                                           ! 491 } flags_t;
00728                                           !BCC_EOS
00729                                           ! 492 typedef struct {
00730                                           ! 493   Bit16u ip;
00731                                           !BCC_EOS
00732                                           ! 494   Bit16u cs;
00733                                           !BCC_EOS
00734                                           ! 495   flags_t flags;
00735                                           !BCC_EOS
00736                                           ! 496 } iret_addr_t;
00737                                           !BCC_EOS
00738                                           ! 497 typedef struct {
00739                                           ! 498   Bit16u type;
00740                                           !BCC_EOS
00741                                           ! 499   Bit16u flags;
00742                                           !BCC_EOS
00743                                           ! 500   Bit32u vector;
00744                                           !BCC_EOS
00745                                           ! 501   Bit32u description;
00746                                           !BCC_EOS
00747                                           ! 502   Bit32u reserved;
00748                                           !BCC_EOS
00749                                           ! 503 } ipl_entry_t;
00750                                           !BCC_EOS
00751                                           ! 504 static Bit8u inb();
00752                                           !BCC_EOS
00753                                           ! 505 static Bit8u inb_cmos();
00754                                           !BCC_EOS
00755                                           ! 506 static void outb();
00756                                           !BCC_EOS
00757                                           ! 507 static void outb_cmos();
00758                                           !BCC_EOS
00759                                           ! 508 static Bit16u inw();
00760                                           !BCC_EOS
00761                                           ! 509 static void outw();
00762                                           !BCC_EOS
00763                                           ! 510 static void init_rtc();
00764                                           !BCC_EOS
00765                                           ! 511 static bx_bool rtc_updating();
00766                                           !BCC_EOS
00767                                           ! 512 static Bit8u bin2bcd();
00768                                           !BCC_EOS
00769                                           ! 513 static Bit8u bcd2bin();
00770                                           !BCC_EOS
00771                                           ! 514 static Bit8u _read_byte();
00772                                           !BCC_EOS
00773                                           ! 515 static Bit16u _read_word();
00774                                           !BCC_EOS
00775                                           ! 516 static void _write_byte();
00776                                           !BCC_EOS
00777                                           ! 517 static void _write_word();
00778                                           !BCC_EOS
00779                                           ! 518 static Bit8u read_byte_SS();
00780                                           !BCC_EOS
00781                                           ! 519 static Bit16u read_word_SS();
00782                                           !BCC_EOS
00783                                           ! 520 static void _write_byte_SS();
00784                                           !BCC_EOS
00785                                           ! 521 static void _write_word_SS();
00786                                           !BCC_EOS
00787                                           ! 522 static void bios_printf();
00788                                           !BCC_EOS
00789                                           ! 523 static Bit8u inhibit_mouse_int_and_events();
00790                                           !BCC_EOS
00791                                           ! 524 static void enable_mouse_int_and_events();
00792                                           !BCC_EOS
00793                                           ! 525 static Bit8u send_to_mouse_ctrl();
00794                                           !BCC_EOS
00795                                           ! 526 static Bit8u get_mouse_data();
00796                                           !BCC_EOS
00797                                           ! 527 static void set_kbd_command_byte();
00798                                           !BCC_EOS
00799                                           ! 528 static void int09_function();
00800                                           !BCC_EOS
00801                                           ! 529 static void int13_harddisk();
00802                                           !BCC_EOS
00803                                           ! 530 static void int13_cdrom();
00804                                           !BCC_EOS
00805                                           ! 531 static void int13_cdemu();
00806                                           !BCC_EOS
00807                                           ! 532 static void int13_eltorito();
00808                                           !BCC_EOS
00809                                           ! 533 static void int13_diskette_function();
00810                                           !BCC_EOS
00811                                           ! 534 static void int14_function();
00812                                           !BCC_EOS
00813                                           ! 535 static void int15_function();
00814                                           !BCC_EOS
00815                                           ! 536 static void int16_function();
00816                                           !BCC_EOS
00817                                           ! 537 static void int17_function();
00818                                           !BCC_EOS
00819                                           ! 538 static void int19_function();
00820                                           !BCC_EOS
00821                                           ! 539 static void int1a_function();
00822                                           !BCC_EOS
00823                                           ! 540 static void int70_function();
00824                                           !BCC_EOS
00825                                           ! 541 static void int74_function();
00826                                           !BCC_EOS
00827                                           ! 542 static Bit16u get_CS();
00828                                           !BCC_EOS
00829                                           ! 543 static Bit16u get_SS();
00830                                           !BCC_EOS
00831                                           ! 544 static Bit16u set_DS();
00832                                           !BCC_EOS
00833                                           ! 545 static unsigned int enqueue_key();
00834                                           !BCC_EOS
00835                                           ! 546 static unsigned int dequeue_key();
00836                                           !BCC_EOS
00837                                           ! 547 static void get_hd_geometr
00838                                           ! 547 y();
00839                                           !BCC_EOS
00840                                           ! 548 static void set_diskette_ret_status();
00841                                           !BCC_EOS
00842                                           ! 549 static void set_diskette_current_cyl();
00843                                           !BCC_EOS
00844                                           ! 550 static void determine_floppy_media();
00845                                           !BCC_EOS
00846                                           ! 551 static bx_bool floppy_drive_exists();
00847                                           !BCC_EOS
00848                                           ! 552 static bx_bool floppy_drive_recal();
00849                                           !BCC_EOS
00850                                           ! 553 static bx_bool floppy_media_known();
00851                                           !BCC_EOS
00852                                           ! 554 static bx_bool floppy_media_sense();
00853                                           !BCC_EOS
00854                                           ! 555 static bx_bool set_enable_a20();
00855                                           !BCC_EOS
00856                                           ! 556 static void debugger_on();
00857                                           !BCC_EOS
00858                                           ! 557 static void debugger_off();
00859                                           !BCC_EOS
00860                                           ! 558 static void keyboard_init();
00861                                           !BCC_EOS
00862                                           ! 559 static void keyboard_panic();
00863                                           !BCC_EOS
00864                                           ! 560 static void shutdown_status_panic();
00865                                           !BCC_EOS
00866                                           ! 561 static void nmi_handler_msg();
00867                                           !BCC_EOS
00868                                           ! 562 static void delay_ticks();
00869                                           !BCC_EOS
00870                                           ! 563 static void delay_ticks_and_check_for_keystroke();
00871                                           !BCC_EOS
00872                                           ! 564 static void interactive_bootkey();
00873                                           !BCC_EOS
00874                                           ! 565 static void print_bios_banner();
00875                                           !BCC_EOS
00876                                           ! 566 static void print_boot_device();
00877                                           !BCC_EOS
00878                                           ! 567 static void print_boot_failure();
00879                                           !BCC_EOS
00880                                           ! 568 static void print_cdromboot_failure();
00881                                           !BCC_EOS
00882                                           ! 569 void ata_init();
00883                                           !BCC_EOS
00884                                           ! 570 void ata_detect();
00885                                           !BCC_EOS
00886                                           ! 571 void ata_reset();
00887                                           !BCC_EOS
00888                                           ! 572 Bit16u ata_cmd_non_data();
00889                                           !BCC_EOS
00890                                           ! 573 Bit16u ata_cmd_data_io();
00891                                           !BCC_EOS
00892                                           ! 574 Bit16u ata_cmd_packet();
00893                                           !BCC_EOS
00894                                           ! 575 Bit16u atapi_get_sense();
00895                                           !BCC_EOS
00896                                           ! 576 Bit16u atapi_is_ready();
00897                                           !BCC_EOS
00898                                           ! 577 Bit16u atapi_is_cdrom();
00899                                           !BCC_EOS
00900                                           ! 578 void cdemu_init();
00901                                           !BCC_EOS
00902                                           ! 579 Bit8u cdemu_isactive();
00903                                           !BCC_EOS
00904                                           ! 580 Bit8u cdemu_emulated_drive();
00905                                           !BCC_EOS
00906                                           ! 581 Bit16u cdrom_boot();
00907                                           !BCC_EOS
00908                                           ! 582 static char bios_svn_version_string[] = "$Revision$ $Date$";
00909                                           
00910                       0000016C            _bios_svn_version_string:
00911                       0000016C            .1:
00912 016C                        24            .ascii	"$Revision$ $Date$"
00913 017D                        00            .byte	0
00914                                           !BCC_EOS
00915                                           ! 583 static struct {
00916                                           ! 584   Bit16u normal;
00917                                           !BCC_EOS
00918                                           ! 585   Bit16u shift;
00919                                           !BCC_EOS
00920                                           ! 586   Bit16u control;
00921                                           !BCC_EOS
00922                                           ! 587   Bit16u alt;
00923                                           !BCC_EOS
00924                                           ! 588   Bit8u lock_flags;
00925                                           !BCC_EOS
00926                                           ! 589   } scan_to_scanascii[0x58 + 1] = {
00927                       0000017E            _scan_to_scanascii:
00928                                           ! 590       { 0, 0, 0, 0, 0 },
00929 017E                      0000            .word	0
00930 0180                      0000            .word	0
00931 0182                      0000            .word	0
00932 0184                      0000            .word	0
00933 0186                        00            .byte	0
00934 0187                  00000001            .blkb	1
00935                                           ! 591       { 0x011b, 0x011b, 0x011b, 0x0100, 0 },
00936 0188                      011B            .word	$11B
00937 018A                      011B            .word	$11B
00938 018C                      011B            .word	$11B
00939 018E                      0100            .word	$100
00940 0190                        00            .byte	0
00941 0191                  00000001            .blkb	1
00942                                           ! 592       { 0x0231, 0x0221, 0, 0x7800, 0 },
00943 0192                      0231            .word	$231
00944 0194                      0221            .word	$221
00945 0196                      0000            .word	0
00946 0198                      7800            .word	$7800
00947 019A                        00            .byte	0
00948 019B                  00000001            .blkb	1
00949                                           ! 593       { 0x0332, 0x0340, 0x0300, 0x7900, 0 },
00950 019C                      0332            .word	$332
00951 019E                      0340            .word	$340
00952 01A0                      0300            .word	$300
00953 01A2                      7900            .word	$7900
00954 01A4                        00            .byte	0
00955 01A5                  00000001            .blkb	1
00956                                           ! 594       { 0x0433, 0x0423, 0, 0x7a00, 0 },
00957 01A6                      0433            .word	$433
00958 01A8                      0423            .word	$423
00959 01AA                      0000            .word	0
00960 01AC                      7A00            .word	$7A00
00961 01AE                        00            .byte	0
00962 01AF                  00000001            .blkb	1
00963                                           ! 595       { 0x0534, 0x0524, 0, 0x7b00, 0 },
00964 01B0                      0534            .word	$534
00965 01B2                      0524            .word	$524
00966 01B4                      0000            .word	0
00967 01B6                      7B00            .word	$7B00
00968 01B8                        00            .byte	0
00969 01B9                  00000001            .blkb	1
00970                                           ! 596       { 0x0635, 0x0625, 0, 0x7c00, 0 },
00971 01BA                      0635            .word	$635
00972 01BC                      0625            .word	$625
00973 01BE                      0000            .word	0
00974 01C0                      7C00            .word	$7C00
00975 01C2                        00            .byte	0
00976 01C3                  00000001            .blkb	1
00977                                           ! 597       { 0x0736, 0x075e, 0x071e, 0x7d00, 0 },
00978 01C4                      0736            .word	$736
00979 01C6                      075E            .word	$75E
00980 01C8                      071E            .word	$71E
00981 01CA                      7D00            .word	$7D00
00982 01CC                        00            .byte	0
00983 01CD                  00000001            .blkb	1
00984                                           ! 598       { 0x0837, 0x0826, 0, 0x7e00, 0 },
00985 01CE                      0837            .word	$837
00986 01D0                      0826            .word	$826
00987 01D2                      0000            .word	0
00988 01D4                      7E00            .word	$7E00
00989 01D6                        00            .byte	0
00990 01D7                  00000001            .blkb	1
00991                                           ! 599       { 0x0938, 0x092a, 0, 0x7f00, 0 },
00992 01D8                      0938            .word	$938
00993 01DA                      092A            .word	$92A
00994 01DC                      0000            .word	0
00995 01DE                      7F00            .word	$7F00
00996 01E0                        00            .byte	0
00997 01E1                  00000001            .blkb	1
00998                                           ! 600       { 0x0a39, 0x0a28, 0, 0x8000, 0 },
00999 01E2                      0A39            .word	$A39
01000 01E4                      0A28            .word	$A28
01001 01E6                      0000            .word	0
01002 01E8                      8000            .word	$8000
01003 01EA                        00            .byte	0
01004 01EB                  00000001            .blkb	1
01005                                           ! 601       { 0x0b30, 0x0b29, 0, 0x8100, 0 },
01006 01EC                      0B30            .word	$B30
01007 01EE                      0B29            .word	$B29
01008 01F0                      0000            .word	0
01009 01F2                      8100            .word	$8100
01010 01F4                        00            .byte	0
01011 01F5                  00000001            .blkb	1
01012                                           ! 602       { 0x0c2d, 0x0c5f, 0x0c1f, 0x8200, 0 },
01013 01F6                      0C2D            .word	$C2D
01014 01F8                      0C5F            .word	$C5F
01015 01FA                      0C1F            .word	$C1F
01016 01FC                      8200            .word	$8200
01017 01FE                        00            .byte	0
01018 01FF                  00000001            .blkb	1
01019                                           ! 603       { 0x0d3d, 0x0d2b, 0, 0x8300, 0 },
01020 0200                      0D3D            .word	$D3D
01021 0202                      0D2B            .word	$D2B
01022 0204                      0000            .word	0
01023 0206                      8300            .word	$8300
01024 0208                        00            .byte	0
01025 0209                  00000001            .blkb	1
01026                                           ! 604       { 0x0e08, 0x0e08, 0x0e7f, 0, 0 },
01027 020A                      0E08            .word	$E08
01028 020C                      0E08            .word	$E08
01029 020E                      0E7F            .word	$E7F
01030 0210                      0000            .word	0
01031 0212                        00            .byte	0
01032 0213                  00000001            .blkb	1
01033                                           ! 605       { 0x0f09, 0x0f00, 0, 0, 0 },
01034 0214                      0F09            .word	$F09
01035 0216                      0F00            .word	$F00
01036 0218                      0000            .word	0
01037 021A                      0000            .word	0
01038 021C                        00            .byte	0
01039 021D                  00000001            .blkb	1
01040                                           ! 606       { 0x1071, 0x1051, 0x1011, 0x1000, 0x40 },
01041 021E                      1071            .word	$1071
01042 0220                      1051            .word	$1051
01043 0222                      1011            .word	$1011
01044 0224                      1000            .word	$1000
01045 0226                        40            .byte	$40
01046 0227                  00000001            .blkb	1
01047                                           ! 607       { 0x1177, 0x1157, 0x1117, 0x1100, 0x40 },
01048 0228                      1177            .word	$1177
01049 022A                      1157            .word	$1157
01050 022C                      1117            .word	$1117
01051 022E                      1100            .word	$1100
01052 0230                        40            .byte	$40
01053 0231                  00000001            .blkb	1
01054                                           ! 608       { 0x1265, 0x1245, 0x1205, 0x1200, 0x40 },
01055 0232                      1265            .word	$1265
01056 0234                      1245            .word	$1245
01057 0236                      1205            .word	$1205
01058 0238                      1200            .word	$1200
01059 023A                        40            .byte	$40
01060 023B                  00000001            .blkb	1
01061                                           ! 609       { 0x1372, 0x1352, 0x
01062 023C                      1372            .word	$1372
01063 023E                      1352            .word	$1352
01064                                           ! 609 1312, 0x1300, 0x40 },
01065 0240                      1312            .word	$1312
01066 0242                      1300            .word	$1300
01067 0244                        40            .byte	$40
01068 0245                  00000001            .blkb	1
01069                                           ! 610       { 0x1474, 0x1454, 0x1414, 0x1400, 0x40 },
01070 0246                      1474            .word	$1474
01071 0248                      1454            .word	$1454
01072 024A                      1414            .word	$1414
01073 024C                      1400            .word	$1400
01074 024E                        40            .byte	$40
01075 024F                  00000001            .blkb	1
01076                                           ! 611       { 0x1579, 0x1559, 0x1519, 0x1500, 0x40 },
01077 0250                      1579            .word	$1579
01078 0252                      1559            .word	$1559
01079 0254                      1519            .word	$1519
01080 0256                      1500            .word	$1500
01081 0258                        40            .byte	$40
01082 0259                  00000001            .blkb	1
01083                                           ! 612       { 0x1675, 0x1655, 0x1615, 0x1600, 0x40 },
01084 025A                      1675            .word	$1675
01085 025C                      1655            .word	$1655
01086 025E                      1615            .word	$1615
01087 0260                      1600            .word	$1600
01088 0262                        40            .byte	$40
01089 0263                  00000001            .blkb	1
01090                                           ! 613       { 0x1769, 0x1749, 0x1709, 0x1700, 0x40 },
01091 0264                      1769            .word	$1769
01092 0266                      1749            .word	$1749
01093 0268                      1709            .word	$1709
01094 026A                      1700            .word	$1700
01095 026C                        40            .byte	$40
01096 026D                  00000001            .blkb	1
01097                                           ! 614       { 0x186f, 0x184f, 0x180f, 0x1800, 0x40 },
01098 026E                      186F            .word	$186F
01099 0270                      184F            .word	$184F
01100 0272                      180F            .word	$180F
01101 0274                      1800            .word	$1800
01102 0276                        40            .byte	$40
01103 0277                  00000001            .blkb	1
01104                                           ! 615       { 0x1970, 0x1950, 0x1910, 0x1900, 0x40 },
01105 0278                      1970            .word	$1970
01106 027A                      1950            .word	$1950
01107 027C                      1910            .word	$1910
01108 027E                      1900            .word	$1900
01109 0280                        40            .byte	$40
01110 0281                  00000001            .blkb	1
01111                                           ! 616       { 0x1a5b, 0x1a7b, 0x1a1b, 0, 0 },
01112 0282                      1A5B            .word	$1A5B
01113 0284                      1A7B            .word	$1A7B
01114 0286                      1A1B            .word	$1A1B
01115 0288                      0000            .word	0
01116 028A                        00            .byte	0
01117 028B                  00000001            .blkb	1
01118                                           ! 617       { 0x1b5d, 0x1b7d, 0x1b1d, 0, 0 },
01119 028C                      1B5D            .word	$1B5D
01120 028E                      1B7D            .word	$1B7D
01121 0290                      1B1D            .word	$1B1D
01122 0292                      0000            .word	0
01123 0294                        00            .byte	0
01124 0295                  00000001            .blkb	1
01125                                           ! 618       { 0x1c0d, 0x1c0d, 0x1c0a, 0, 0 },
01126 0296                      1C0D            .word	$1C0D
01127 0298                      1C0D            .word	$1C0D
01128 029A                      1C0A            .word	$1C0A
01129 029C                      0000            .word	0
01130 029E                        00            .byte	0
01131 029F                  00000001            .blkb	1
01132                                           ! 619       { 0, 0, 0, 0, 0 },
01133 02A0                      0000            .word	0
01134 02A2                      0000            .word	0
01135 02A4                      0000            .word	0
01136 02A6                      0000            .word	0
01137 02A8                        00            .byte	0
01138 02A9                  00000001            .blkb	1
01139                                           ! 620       { 0x1e61, 0x1e41, 0x1e01, 0x1e00, 0x40 },
01140 02AA                      1E61            .word	$1E61
01141 02AC                      1E41            .word	$1E41
01142 02AE                      1E01            .word	$1E01
01143 02B0                      1E00            .word	$1E00
01144 02B2                        40            .byte	$40
01145 02B3                  00000001            .blkb	1
01146                                           ! 621       { 0x1f73, 0x1f53, 0x1f13, 0x1f00, 0x40 },
01147 02B4                      1F73            .word	$1F73
01148 02B6                      1F53            .word	$1F53
01149 02B8                      1F13            .word	$1F13
01150 02BA                      1F00            .word	$1F00
01151 02BC                        40            .byte	$40
01152 02BD                  00000001            .blkb	1
01153                                           ! 622       { 0x2064, 0x2044, 0x2004, 0x2000, 0x40 },
01154 02BE                      2064            .word	$2064
01155 02C0                      2044            .word	$2044
01156 02C2                      2004            .word	$2004
01157 02C4                      2000            .word	$2000
01158 02C6                        40            .byte	$40
01159 02C7                  00000001            .blkb	1
01160                                           ! 623       { 0x2166, 0x2146, 0x2106, 0x2100, 0x40 },
01161 02C8                      2166            .word	$2166
01162 02CA                      2146            .word	$2146
01163 02CC                      2106            .word	$2106
01164 02CE                      2100            .word	$2100
01165 02D0                        40            .byte	$40
01166 02D1                  00000001            .blkb	1
01167                                           ! 624       { 0x2267, 0x2247, 0x2207, 0x2200, 0x40 },
01168 02D2                      2267            .word	$2267
01169 02D4                      2247            .word	$2247
01170 02D6                      2207            .word	$2207
01171 02D8                      2200            .word	$2200
01172 02DA                        40            .byte	$40
01173 02DB                  00000001            .blkb	1
01174                                           ! 625       { 0x2368, 0x2348, 0x2308, 0x2300, 0x40 },
01175 02DC                      2368            .word	$2368
01176 02DE                      2348            .word	$2348
01177 02E0                      2308            .word	$2308
01178 02E2                      2300            .word	$2300
01179 02E4                        40            .byte	$40
01180 02E5                  00000001            .blkb	1
01181                                           ! 626       { 0x246a, 0x244a, 0x240a, 0x2400, 0x40 },
01182 02E6                      246A            .word	$246A
01183 02E8                      244A            .word	$244A
01184 02EA                      240A            .word	$240A
01185 02EC                      2400            .word	$2400
01186 02EE                        40            .byte	$40
01187 02EF                  00000001            .blkb	1
01188                                           ! 627       { 0x256b, 0x254b, 0x250b, 0x2500, 0x40 },
01189 02F0                      256B            .word	$256B
01190 02F2                      254B            .word	$254B
01191 02F4                      250B            .word	$250B
01192 02F6                      2500            .word	$2500
01193 02F8                        40            .byte	$40
01194 02F9                  00000001            .blkb	1
01195                                           ! 628       { 0x266c, 0x264c, 0x260c, 0x2600, 0x40 },
01196 02FA                      266C            .word	$266C
01197 02FC                      264C            .word	$264C
01198 02FE                      260C            .word	$260C
01199 0300                      2600            .word	$2600
01200 0302                        40            .byte	$40
01201 0303                  00000001            .blkb	1
01202                                           ! 629       { 0x273b, 0x273a, 0, 0, 0 },
01203 0304                      273B            .word	$273B
01204 0306                      273A            .word	$273A
01205 0308                      0000            .word	0
01206 030A                      0000            .word	0
01207 030C                        00            .byte	0
01208 030D                  00000001            .blkb	1
01209                                           ! 630       { 0x2827, 0x2822, 0, 0, 0 },
01210 030E                      2827            .word	$2827
01211 0310                      2822            .word	$2822
01212 0312                      0000            .word	0
01213 0314                      0000            .word	0
01214 0316                        00            .byte	0
01215 0317                  00000001            .blkb	1
01216                                           ! 631       { 0x2960, 0x297e, 0, 0, 0 },
01217 0318                      2960            .word	$2960
01218 031A                      297E            .word	$297E
01219 031C                      0000            .word	0
01220 031E                      0000            .word	0
01221 0320                        00            .byte	0
01222 0321                  00000001            .blkb	1
01223                                           ! 632       { 0, 0, 0, 0, 0 },
01224 0322                      0000            .word	0
01225 0324                      0000            .word	0
01226 0326                      0000            .word	0
01227 0328                      0000            .word	0
01228 032A                        00            .byte	0
01229 032B                  00000001            .blkb	1
01230                                           ! 633       { 0x2b5c, 0x2b7c, 0x2b1c, 0, 0 },
01231 032C                      2B5C            .word	$2B5C
01232 032E                      2B7C            .word	$2B7C
01233 0330                      2B1C            .word	$2B1C
01234 0332                      0000            .word	0
01235 0334                        00            .byte	0
01236 0335                  00000001            .blkb	1
01237                                           ! 634       { 0x2c7a, 0x2c5a, 0x2c1a, 0x2c00, 0x40 },
01238 0336                      2C7A            .word	$2C7A
01239 0338                      2C5A            .word	$2C5A
01240 033A                      2C1A            .word	$2C1A
01241 033C                      2C00            .word	$2C00
01242 033E                        40            .byte	$40
01243 033F                  00000001            .blkb	1
01244                                           ! 635       { 0x2d78, 0x2d58, 0x2d18, 0x2d00, 0x40 },
01245 0340                      2D78            .word	$2D78
01246 0342                      2D58            .word	$2D58
01247 0344                      2D18            .word	$2D18
01248 0346                      2D00            .word	$2D00
01249 0348                        40            .byte	$40
01250 0349                  00000001            .blkb	1
01251                                           ! 636       { 0x2e63, 0x2e43, 0x2e03, 0x2e00, 0x40 },
01252 034A                      2E63            .word	$2E63
01253 034C                      2E43            .word	$2E43
01254 034E                      2E03            .word	$2E03
01255 0350                      2E00            .word	$2E00
01256 0352                        40            .byte	$40
01257 0353                  00000001            .blkb	1
01258                                           ! 637       { 0x2f76, 0x2f56, 0x2f16, 0x2f00, 0x40 },
01259 0354                      2F76            .word	$2F76
01260 0356                      2F56            .word	$2F56
01261 0358                      2F16            .word	$2F16
01262 035A                      2F00            .word	$2F00
01263 035C                        40            .byte	$40
01264 035D                  00000001            .blkb	1
01265                                           ! 638       { 0x3062, 0x3042, 0x3002, 0x3000, 0x40 },
01266 035E                      3062            .word	$3062
01267 0360                      3042            .word	$3042
01268 0362                      3002            .word	$3002
01269 0364                      3000            .word	$3000
01270 0366                        40            .byte	$40
01271 0367                  00000001            .blkb	1
01272                                           ! 639       { 0x316e, 0x314e, 0x310e, 0x3100, 0x40 },
01273 0368                      316E            .word	$316E
01274 036A                      314E            .word	$314E
01275 036C                      310E            .word	$310E
01276 036E                      3100            .word	$3100
01277 0370                        40            .byte	$40
01278 0371                  00000001            .blkb	1
01279                                           ! 640       { 0x326d, 0x324d, 0x320d, 0x3200, 0x40 },
01280 0372                      326D            .word	$326D
01281 0374                      324D            .word	$324D
01282 0376                      320D            .word	$320D
01283 0378                      3200            .word	$3200
01284 037A                        40            .byte	$40
01285 037B                  00000001            .blkb	1
01286                                           ! 641       { 0x332c, 0x333c, 0, 0, 0 },
01287 037C                      332C            .word	$332C
01288 037E                      333C            .word	$333C
01289 0380                      0000            .word	0
01290 0382                      0000            .word	0
01291 0384                        00            .byte	0
01292 0385                  00000001            .blkb	1
01293                                           ! 642       { 0x342e, 0x343e, 0, 0, 0 },
01294 0386                      342E            .word	$342E
01295 0388                      343E            .word	$343E
01296 038A                      0000            .word	0
01297 038C                      0000            .word	0
01298 038E                        00            .byte	0
01299 038F                  00000001            .blkb	1
01300                                           ! 643       { 0x352f, 0x353f, 0, 0, 0 },
01301 0390                      352F            .word	$352F
01302 0392                      353F            .word	$353F
01303 0394                      0000            .word	0
01304 0396                      0000            .word	0
01305 0398                        00            .byte	0
01306 0399                  00000001            .blkb	1
01307                                           ! 644       { 0, 0, 0, 0, 0 },
01308 039A                      0000            .word	0
01309 039C                      0000            .word	0
01310 039E                      0000            .word	0
01311 03A0                      0000            .word	0
01312 03A2                        00            .byte	0
01313 03A3                  00000001            .blkb	1
01314                                           ! 645       { 0x372a, 0x372a, 0, 0, 0 },
01315 03A4                      372A            .word	$372A
01316 03A6                      372A            .word	$372A
01317 03A8                      0000            .word	0
01318 03AA                      0000            .word	0
01319 03AC                        00            .byte	0
01320 03AD                  00000001            .blkb	1
01321                                           ! 646       { 0, 0, 0, 0, 0 },
01322 03AE                      0000            .word	0
01323 03B0                      0000            .word	0
01324 03B2                      0000            .word	0
01325 03B4                      0000            .word	0
01326 03B6                        00            .byte	0
01327 03B7                  00000001            .blkb	1
01328                                           ! 647       { 0x3920, 0x3920, 0x3920, 0x3920, 0 },
01329 03B8                      3920            .word	$3920
01330 03BA                      3920            .word	$3920
01331 03BC                      3920            .word	$3920
01332 03BE                      3920            .word	$3920
01333 03C0                        00            .byte	0
01334 03C1                  00000001            .blkb	1
01335                                           ! 648       { 0, 0, 0, 0, 0 },
01336 03C2                      0000            .word	0
01337 03C4                      0000            .word	0
01338 03C6                      0000            .word	0
01339 03C8                      0000            .word	0
01340 03CA                        00            .byte	0
01341 03CB                  00000001            .blkb	1
01342                                           ! 649       { 0x3b00, 0x5400, 0x5e00, 0x6800, 0 },
01343 03CC                      3B00            .word	$3B00
01344 03CE                      5400            .word	$5400
01345 03D0                      5E00            .word	$5E00
01346 03D2                      6800            .word	$6800
01347 03D4                        00            .byte	0
01348 03D5                  00000001            .blkb	1
01349                                           ! 650       { 0x3c00, 0x5500, 0x5f00, 0x6900, 0 },
01350 03D6                      3C00            .word	$3C00
01351 03D8                      5500            .word	$5500
01352 03DA                      5F00            .word	$5F00
01353 03DC                      6900            .word	$6900
01354 03DE                        00            .byte	0
01355 03DF                  00000001            .blkb	1
01356                                           ! 651       { 0x3d00, 0x5600, 0x6000, 0x6a00, 0 },
01357 03E0                      3D00            .word	$3D00
01358 03E2                      5600            .word	$5600
01359 03E4                      6000            .word	$6000
01360 03E6                      6A00            .word	$6A00
01361 03E8                        00            .byte	0
01362 03E9                  00000001            .blkb	1
01363                                           ! 652       { 0x3e00, 0x5700, 0x6100, 0x6b00, 0 },
01364 03EA                      3E00            .word	$3E00
01365 03EC                      5700            .word	$5700
01366 03EE                      6100            .word	$6100
01367 03F0                      6B00            .word	$6B00
01368 03F2                        00            .byte	0
01369 03F3                  00000001            .blkb	1
01370                                           ! 653       { 0x3f00, 0x5800, 0x6200, 0x6c00, 0 },
01371 03F4                      3F00            .word	$3F00
01372 03F6                      5800            .word	$5800
01373 03F8                      6200            .word	$6200
01374 03FA                      6C00            .word	$6C00
01375 03FC                        00            .byte	0
01376 03FD                  00000001            .blkb	1
01377                                           ! 654       { 0x4000, 0x5900, 0x6300, 0x6d00, 0 },
01378 03FE                      4000            .word	$4000
01379 0400                      5900            .word	$5900
01380 0402                      6300            .word	$6300
01381 0404                      6D00            .word	$6D00
01382 0406                        00            .byte	0
01383 0407                  00000001            .blkb	1
01384                                           ! 655       { 0x4100, 0x5a00, 0x6400, 0x6e00, 0 },
01385 0408                      4100            .word	$4100
01386 040A                      5A00            .word	$5A00
01387 040C                      6400            .word	$6400
01388 040E                      6E00            .word	$6E00
01389 0410                        00            .byte	0
01390 0411                  00000001            .blkb	1
01391                                           ! 656       { 0x4200, 0x5b00, 0x6500, 0x6f00, 0 },
01392 0412                      4200            .word	$4200
01393 0414                      5B00            .word	$5B00
01394 0416                      6500            .word	$6500
01395 0418                      6F00            .word	$6F00
01396 041A                        00            .byte	0
01397 041B                  00000001            .blkb	1
01398                                           ! 657       { 0x4300, 0x5c00, 0x6600, 0x7
01399 041C                      4300            .word	$4300
01400 041E                      5C00            .word	$5C00
01401 0420                      6600            .word	$6600
01402                                           ! 657 000, 0 },
01403 0422                      7000            .word	$7000
01404 0424                        00            .byte	0
01405 0425                  00000001            .blkb	1
01406                                           ! 658       { 0x4400, 0x5d00, 0x6700, 0x7100, 0 },
01407 0426                      4400            .word	$4400
01408 0428                      5D00            .word	$5D00
01409 042A                      6700            .word	$6700
01410 042C                      7100            .word	$7100
01411 042E                        00            .byte	0
01412 042F                  00000001            .blkb	1
01413                                           ! 659       { 0, 0, 0, 0, 0 },
01414 0430                      0000            .word	0
01415 0432                      0000            .word	0
01416 0434                      0000            .word	0
01417 0436                      0000            .word	0
01418 0438                        00            .byte	0
01419 0439                  00000001            .blkb	1
01420                                           ! 660       { 0, 0, 0, 0, 0 },
01421 043A                      0000            .word	0
01422 043C                      0000            .word	0
01423 043E                      0000            .word	0
01424 0440                      0000            .word	0
01425 0442                        00            .byte	0
01426 0443                  00000001            .blkb	1
01427                                           ! 661       { 0x4700, 0x4737, 0x7700, 0, 0x20 },
01428 0444                      4700            .word	$4700
01429 0446                      4737            .word	$4737
01430 0448                      7700            .word	$7700
01431 044A                      0000            .word	0
01432 044C                        20            .byte	$20
01433 044D                  00000001            .blkb	1
01434                                           ! 662       { 0x4800, 0x4838, 0, 0, 0x20 },
01435 044E                      4800            .word	$4800
01436 0450                      4838            .word	$4838
01437 0452                      0000            .word	0
01438 0454                      0000            .word	0
01439 0456                        20            .byte	$20
01440 0457                  00000001            .blkb	1
01441                                           ! 663       { 0x4900, 0x4939, 0x8400, 0, 0x20 },
01442 0458                      4900            .word	$4900
01443 045A                      4939            .word	$4939
01444 045C                      8400            .word	$8400
01445 045E                      0000            .word	0
01446 0460                        20            .byte	$20
01447 0461                  00000001            .blkb	1
01448                                           ! 664       { 0x4a2d, 0x4a2d, 0, 0, 0 },
01449 0462                      4A2D            .word	$4A2D
01450 0464                      4A2D            .word	$4A2D
01451 0466                      0000            .word	0
01452 0468                      0000            .word	0
01453 046A                        00            .byte	0
01454 046B                  00000001            .blkb	1
01455                                           ! 665       { 0x4b00, 0x4b34, 0x7300, 0, 0x20 },
01456 046C                      4B00            .word	$4B00
01457 046E                      4B34            .word	$4B34
01458 0470                      7300            .word	$7300
01459 0472                      0000            .word	0
01460 0474                        20            .byte	$20
01461 0475                  00000001            .blkb	1
01462                                           ! 666       { 0x4c00, 0x4c35, 0, 0, 0x20 },
01463 0476                      4C00            .word	$4C00
01464 0478                      4C35            .word	$4C35
01465 047A                      0000            .word	0
01466 047C                      0000            .word	0
01467 047E                        20            .byte	$20
01468 047F                  00000001            .blkb	1
01469                                           ! 667       { 0x4d00, 0x4d36, 0x7400, 0, 0x20 },
01470 0480                      4D00            .word	$4D00
01471 0482                      4D36            .word	$4D36
01472 0484                      7400            .word	$7400
01473 0486                      0000            .word	0
01474 0488                        20            .byte	$20
01475 0489                  00000001            .blkb	1
01476                                           ! 668       { 0x4e2b, 0x4e2b, 0, 0, 0 },
01477 048A                      4E2B            .word	$4E2B
01478 048C                      4E2B            .word	$4E2B
01479 048E                      0000            .word	0
01480 0490                      0000            .word	0
01481 0492                        00            .byte	0
01482 0493                  00000001            .blkb	1
01483                                           ! 669       { 0x4f00, 0x4f31, 0x7500, 0, 0x20 },
01484 0494                      4F00            .word	$4F00
01485 0496                      4F31            .word	$4F31
01486 0498                      7500            .word	$7500
01487 049A                      0000            .word	0
01488 049C                        20            .byte	$20
01489 049D                  00000001            .blkb	1
01490                                           ! 670       { 0x5000, 0x5032, 0, 0, 0x20 },
01491 049E                      5000            .word	$5000
01492 04A0                      5032            .word	$5032
01493 04A2                      0000            .word	0
01494 04A4                      0000            .word	0
01495 04A6                        20            .byte	$20
01496 04A7                  00000001            .blkb	1
01497                                           ! 671       { 0x5100, 0x5133, 0x7600, 0, 0x20 },
01498 04A8                      5100            .word	$5100
01499 04AA                      5133            .word	$5133
01500 04AC                      7600            .word	$7600
01501 04AE                      0000            .word	0
01502 04B0                        20            .byte	$20
01503 04B1                  00000001            .blkb	1
01504                                           ! 672       { 0x5200, 0x5230, 0, 0, 0x20 },
01505 04B2                      5200            .word	$5200
01506 04B4                      5230            .word	$5230
01507 04B6                      0000            .word	0
01508 04B8                      0000            .word	0
01509 04BA                        20            .byte	$20
01510 04BB                  00000001            .blkb	1
01511                                           ! 673       { 0x5300, 0x532e, 0, 0, 0x20 },
01512 04BC                      5300            .word	$5300
01513 04BE                      532E            .word	$532E
01514 04C0                      0000            .word	0
01515 04C2                      0000            .word	0
01516 04C4                        20            .byte	$20
01517 04C5                  00000001            .blkb	1
01518                                           ! 674       { 0, 0, 0, 0, 0 },
01519 04C6                      0000            .word	0
01520 04C8                      0000            .word	0
01521 04CA                      0000            .word	0
01522 04CC                      0000            .word	0
01523 04CE                        00            .byte	0
01524 04CF                  00000001            .blkb	1
01525                                           ! 675       { 0, 0, 0, 0, 0 },
01526 04D0                      0000            .word	0
01527 04D2                      0000            .word	0
01528 04D4                      0000            .word	0
01529 04D6                      0000            .word	0
01530 04D8                        00            .byte	0
01531 04D9                  00000001            .blkb	1
01532                                           ! 676       { 0x565c, 0x567c, 0, 0, 0 },
01533 04DA                      565C            .word	$565C
01534 04DC                      567C            .word	$567C
01535 04DE                      0000            .word	0
01536 04E0                      0000            .word	0
01537 04E2                        00            .byte	0
01538 04E3                  00000001            .blkb	1
01539                                           ! 677       { 0x8500, 0x8700, 0x8900, 0x8b00, 0 },
01540 04E4                      8500            .word	$8500
01541 04E6                      8700            .word	$8700
01542 04E8                      8900            .word	$8900
01543 04EA                      8B00            .word	$8B00
01544 04EC                        00            .byte	0
01545 04ED                  00000001            .blkb	1
01546                                           ! 678       { 0x8600, 0x8800, 0x8a00, 0x8c00, 0 },
01547 04EE                      8600            .word	$8600
01548 04F0                      8800            .word	$8800
01549 04F2                      8A00            .word	$8A00
01550 04F4                      8C00            .word	$8C00
01551 04F6                        00            .byte	0
01552 04F7                  00000001            .blkb	1
01553                                           ! 679       };
01554                                           !BCC_EOS
01555                                           ! 680   Bit8u
01556                                           ! 681 inb(port)
01557                                           ! 682   Bit16u port;
01558                                           
01559                                           export	_inb
01560                       000004F8            _inb:
01561                                           !BCC_EOS
01562                                           ! 683 {
01563                                           ! 684 #asm
01564                                           !BCC_ASM
01565                       00000002            _inb.port	set	2
01566 04F8           55                           push bp
01567 04F9           89E5                         mov bp, sp
01568 04FB           52                             push dx
01569 04FC           8B56         04                mov dx, 4[bp]
01570 04FF           EC                             in al, dx
01571 0500           5A                             pop dx
01572 0501           5D                           pop bp
01573                                           ! 692 endasm
01574                                           !BCC_ENDASM
01575                                           ! 693 }
01576 0502           C3                         ret
01577                                           ! 694   Bit16u
01578                                           ! 695 inw(port)
01579                                           ! 696   Bit16u port;
01580                                           export	_inw
01581                       00000503            _inw:
01582                                           !BCC_EOS
01583                                           ! 697 {
01584                                           ! 698 #asm
01585                                           !BCC_ASM
01586                       00000002            _inw.port	set	2
01587 0503           55                           push bp
01588 0504           89E5                         mov bp, sp
01589 0506           52                             push dx
01590 0507           8B56         04                mov dx, 4[bp]
01591 050A           ED                             in ax, dx
01592 050B           5A                             pop dx
01593 050C           5D                           pop bp
01594                                           ! 706 endasm
01595                                           !BCC_ENDASM
01596                                           ! 707 }
01597 050D           C3                         ret
01598                                           ! 708   void
01599                                           ! 709 outb(port, val)
01600                                           ! 710   Bit16u port;
01601                                           export	_outb
01602                       0000050E            _outb:
01603                                           !BCC_EOS
01604                                           ! 711   Bit8u val;
01605                                           !BCC_EOS
01606                                           ! 712 {
01607                                           ! 713 #asm
01608                                           !BCC_ASM
01609                       00000004            _outb.val	set	4
01610                       00000002            _outb.port	set	2
01611 050E           55                           push bp
01612 050F           89E5                         mov bp, sp
01613 0511           50                             push ax
01614 0512           52                             push dx
01615 0513           8B56         04                mov dx, 4[bp]
01616 0516           8A46         06                mov al, 6[bp]
01617 0519           EE                             out dx, al
01618 051A           5A                             pop dx
01619 051B           58                             pop ax
01620 051C           5D                           pop bp
01621                                           ! 724 endasm
01622                                           !BCC_ENDASM
01623                                           ! 725 }
01624 051D           C3                         ret
01625                                           ! 726   void
01626                                           ! 727 outw(port, val)
01627                                           ! 728   Bit16u port;
01628                                           export	_outw
01629                       0000051E            _outw:
01630                                           !BCC_EOS
01631                                           ! 729   Bit16u val;
01632                                           !BCC_EOS
01633                                           ! 730 {
01634                                           ! 731 #asm
01635                                           !BCC_ASM
01636                       00000004            _outw.val	set	4
01637                       00000002            _outw.port	set	2
01638 051E           55                           push bp
01639 051F           89E5                         mov bp, sp
01640 0521           50                             push ax
01641 0522           52                             push dx
01642 0523           8B56         04                mov dx, 4[bp]
01643 0526           8B46         06                mov ax, 6[bp]
01644 0529           EF                             out dx, ax
01645 052A           5A                             pop dx
01646 052B           58                             pop ax
01647 052C           5D                           pop bp
01648                                           ! 742 endasm
01649                                           !BCC_ENDASM
01650                                           ! 743 }
01651 052D           C3                         ret
01652                                           ! 744   void
01653                                           ! 745 outb_cmos(cmos_reg, val)
01654                                           ! 746   Bit8u cmos_reg;
01655                                           export	_outb_cmos
01656                       0000052E            _outb_cmos:
01657                                           !BCC_EOS
01658                                           ! 747   Bit8u val;
01659                                           !BCC_EOS
01660                                           ! 748 {
01661                                           ! 749 #asm
01662                                           !BCC_ASM
01663                       00000002            _outb_cmos.cmos_reg	set	2
01664                       00000004            _outb_cmos.val	set	4
01665 052E           55                           push bp
01666 052F           89E5                         mov bp, sp
01667 0531           8A46         04                mov al, 4[bp] ;; cmos_reg
01668 0534           E6                     70      out 0x0070, al
01669 0536           8A46         06                mov al, 6[bp] ;; val
01670 0539           E6                     71      out 0x0071, al
01671 053B           5D                           pop bp
01672                                           ! 757 endasm
01673                                           !BCC_ENDASM
01674                                           ! 758 }
01675 053C           C3                         ret
01676                                           ! 759   Bit8u
01677                                           ! 760 inb_cmos(cmos_reg)
01678                                           ! 761   Bit8u cmos_reg;
01679                                           export	_inb_cmos
01680                       0000053D            _inb_cmos:
01681                                           !BCC_EOS
01682                                           ! 762 {
01683                                           ! 763 #asm
01684                                           !BCC_ASM
01685                       00000002            _inb_cmos.cmos_reg	set	2
01686 053D           55                           push bp
01687 053E           89E5                         mov bp, sp
01688 0540           8A46         04                mov al, 4[bp] ;; cmos_reg
01689 0543           E6                     70      out 0x0070, al
01690 0545           E4                     71      in al, 0x0071
01691 0547           5D                           pop bp
01692                                           ! 770 endasm
01693                                           !BCC_ENDASM
01694                                           ! 771 }
01695 0548           C3                         ret
01696                                           ! 772   void
01697                                           ! 773 init_rtc()
01698                                           ! 774 {
01699                                           export	_init_rtc
01700                       00000549            _init_rtc:
01701                                           ! 775   outb_cmos(0x0a, 0x26);
01702 0549           55                         push	bp
01703 054A           89E5                       mov	bp,sp
01704                                           ! Debug: list int = const $26 (used reg = )
01705 054C           B8                   0026  mov	ax,*$26
01706 054F           50                         push	ax
01707                                           ! Debug: list int = const $A (used reg = )
01708 0550           B8                   000A  mov	ax,*$A
01709 0553           50                         push	ax
01710                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01711 0554           E8         FFD7            call	_outb_cmos
01712 0557           89EC                       mov	sp,bp
01713                                           !BCC_EOS
01714                                           ! 776   outb_cmos(0x0b, 0x02);
01715                                           ! Debug: list int = const 2 (used reg = )
01716 0559           B8                   0002  mov	ax,*2
01717 055C           50                         push	ax
01718                                           ! Debug: list int = const $B (used reg = )
01719 055D           B8                   000B  mov	ax,*$B
01720 0560           50                         push	ax
01721                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01722 0561           E8         FFCA            call	_outb_cmos
01723 0564           89EC                       mov	sp,bp
01724                                           !BCC_EOS
01725                                           ! 777   inb_cmos(0x0c);
01726                                           ! Debug: list int = const $C (used reg = )
01727 0566           B8                   000C  mov	ax,*$C
01728 0569           50                         push	ax
01729                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01730 056A           E8         FFD0            call	_inb_cmos
01731 056D           89EC                       mov	sp,bp
01732                                           !BCC_EOS
01733                                           ! 778   inb_cmos(0x0d);
01734                                           ! Debug: list int = const $D (used reg = )
01735 056F           B8                   000D  mov	ax,*$D
01736 0572           50                         push	ax
01737                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01738 0573           E8         FFC7            call	_inb_cmos
01739 0576           89EC                       mov	sp,bp
01740                                           !BCC_EOS
01741                                           ! 779 }
01742 0578           5D                         pop	bp
01743 0579           C3                         ret
01744                                           ! 780   bx_bool
01745                                           ! 781 rtc_updating()
01746                                           ! 782 {
01747                                           export	_rtc_updating
01748                       0000057A            _rtc_updating:
01749                                           ! 783   Bit16u count;
01750                                           !BCC_EOS
01751                                           ! 784   count = 25000;
01752 057A           55                         push	bp
01753 057B           89E5                       mov	bp,sp
01754 057D           4C                         dec	sp
01755 057E           4C                         dec	sp
01756                                           ! Debug: eq int = const $61A8 to unsigned short count = [S+4-4] (used reg = )
01757 057F           B8                   61A8  mov	ax,#$61A8
01758 0582           8946         FE            mov	-2[bp],ax
01759                                           !BCC_EOS
01760                                           ! 785   while (--count != 0) {
01761 0585           EB           15            jmp .3
01762                       00000587            .4:
01763                                           ! 786     if ( (in
01764                                           ! 786 b_cmos(0x0a) & 0x80) == 0 )
01765                                           ! Debug: list int = const $A (used reg = )
01766 0587           B8                   000A  mov	ax,*$A
01767 058A           50                         push	ax
01768                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01769 058B           E8         FFAF            call	_inb_cmos
01770 058E           44                         inc	sp
01771 058F           44                         inc	sp
01772                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
01773 0590           24                     80  and	al,#$80
01774                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
01775 0592           84C0                       test	al,al
01776 0594           75           06            jne 	.5
01777                       00000596            .6:
01778                                           ! 787       return(0);
01779 0596           31C0                       xor	ax,ax
01780 0598           89EC                       mov	sp,bp
01781 059A           5D                         pop	bp
01782 059B           C3                         ret
01783                                           !BCC_EOS
01784                                           ! 788     }
01785                       0000059C            .5:
01786                                           ! 789   return(1);
01787                       0000059C            .3:
01788                                           ! Debug: predec unsigned short count = [S+4-4] (used reg = )
01789 059C           8B46         FE            mov	ax,-2[bp]
01790 059F           48                         dec	ax
01791 05A0           8946         FE            mov	-2[bp],ax
01792                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
01793 05A3           85C0                       test	ax,ax
01794 05A5           75           E0            jne	.4
01795                       000005A7            .7:
01796                       000005A7            .2:
01797 05A7           B8                   0001  mov	ax,*1
01798 05AA           89EC                       mov	sp,bp
01799 05AC           5D                         pop	bp
01800 05AD           C3                         ret
01801                                           !BCC_EOS
01802                                           ! 790 }
01803                                           ! 791   Bit8u
01804                                           ! 792 bin2bcd(value)
01805                                           ! 793   Bit8u value;
01806                                           export	_bin2bcd
01807                       000005AE            _bin2bcd:
01808                                           !BCC_EOS
01809                                           ! 794 {
01810                                           ! 795 #asm
01811                                           !BCC_ASM
01812                       00000002            _bin2bcd.value	set	2
01813 05AE           55                           push bp
01814 05AF           89E5                         mov bp, sp
01815 05B1           52                             push dx
01816 05B2           88E6                           mov dh,ah
01817 05B4           8A26       0000                mov ah, 0
01818 05B8           8A46         04                mov al, 4[bp]
01819 05BB           8A16       000A                mov dl, 10
01820 05BF           F6F2                           div dl
01821 05C1           C0E0                   04      shl al, 4
01822 05C4           00E0                           add al, ah
01823 05C6           88F4                           mov ah, dh
01824 05C8           5A                             pop dx
01825 05C9           5D                           pop bp
01826                                           ! 809 endasm
01827                                           !BCC_ENDASM
01828                                           ! 810 }
01829 05CA           C3                         ret
01830                                           ! 811   Bit8u
01831                                           ! 812 bcd2bin(value)
01832                                           ! 813   Bit8u value;
01833                                           export	_bcd2bin
01834                       000005CB            _bcd2bin:
01835                                           !BCC_EOS
01836                                           ! 814 {
01837                                           ! 815 #asm
01838                                           !BCC_ASM
01839                       00000002            _bcd2bin.value	set	2
01840 05CB           55                           push bp
01841 05CC           89E5                         mov bp, sp
01842 05CE           52                             push dx
01843 05CF           88E6                           mov dh,ah
01844 05D1           8A66         04                mov ah, 4[bp]
01845 05D4           88E0                           mov al, ah
01846 05D6           2206       000F                and al,0x0f
01847 05DA           C0EC                   04      shr ah, 4
01848 05DD           00E0                           add al, ah
01849 05DF           88F4                           mov ah,dh
01850 05E1           5A                             pop dx
01851 05E2           5D                           pop bp
01852                                           ! 828 endasm
01853                                           !BCC_ENDASM
01854                                           ! 829 }
01855 05E3           C3                         ret
01856                                           ! 830   Bit8u
01857                                           ! 831 _read_byte(offset, seg)
01858                                           ! 832   Bit16u offset;
01859                                           export	__read_byte
01860                       000005E4            __read_byte:
01861                                           !BCC_EOS
01862                                           ! 833   Bit16u seg;
01863                                           !BCC_EOS
01864                                           ! 834 {
01865                                           ! 835 #asm
01866                                           !BCC_ASM
01867                       00000004            __read_byte.seg	set	4
01868                       00000002            __read_byte.offset	set	2
01869 05E4           55                           push bp
01870 05E5           89E5                         mov bp, sp
01871 05E7           53                             push bx
01872 05E8           1E                             push ds
01873 05E9           C55E         04                lds bx, 4[bp] ; segment & offset
01874 05EC           8A07                           mov al, [bx]
01875                                               ;; al = return value (byte)
01876 05EE           1F                             pop ds
01877 05EF           5B                             pop bx
01878 05F0           5D                           pop bp
01879                                           ! 846 endasm
01880                                           !BCC_ENDASM
01881                                           ! 847 }
01882 05F1           C3                         ret
01883                                           ! 848   Bit16u
01884                                           ! 849 _read_word(offset, seg)
01885                                           ! 850   Bit16u offset;
01886                                           export	__read_word
01887                       000005F2            __read_word:
01888                                           !BCC_EOS
01889                                           ! 851   Bit16u seg;
01890                                           !BCC_EOS
01891                                           ! 852 {
01892                                           ! 853 #asm
01893                                           !BCC_ASM
01894                       00000004            __read_word.seg	set	4
01895                       00000002            __read_word.offset	set	2
01896 05F2           55                           push bp
01897 05F3           89E5                         mov bp, sp
01898 05F5           53                             push bx
01899 05F6           1E                             push ds
01900 05F7           C55E         04                lds bx, 4[bp] ; segment & offset
01901 05FA           8B07                           mov ax, [bx]
01902                                               ;; ax = return value (word)
01903 05FC           1F                             pop ds
01904 05FD           5B                             pop bx
01905 05FE           5D                           pop bp
01906                                           ! 864 endasm
01907                                           !BCC_ENDASM
01908                                           ! 865 }
01909 05FF           C3                         ret
01910                                           ! 866   void
01911                                           ! 867 _write_byte(data, offset, seg)
01912                                           ! 868   Bit8u data;
01913                                           export	__write_byte
01914                       00000600            __write_byte:
01915                                           !BCC_EOS
01916                                           ! 869   Bit16u offset;
01917                                           !BCC_EOS
01918                                           ! 870   Bit16u seg;
01919                                           !BCC_EOS
01920                                           ! 871 {
01921                                           ! 872 #asm
01922                                           !BCC_ASM
01923                       00000006            __write_byte.seg	set	6
01924                       00000002            __write_byte.data	set	2
01925                       00000004            __write_byte.offset	set	4
01926 0600           55                           push bp
01927 0601           89E5                         mov bp, sp
01928 0603           50                             push ax
01929 0604           53                             push bx
01930 0605           1E                             push ds
01931 0606           C55E         06                lds bx, 6[bp] ; segment & offset
01932 0609           8A46         04                mov al, 4[bp] ; data byte
01933 060C           8807                           mov [bx], al ; write data byte
01934 060E           1F                             pop ds
01935 060F           5B                             pop bx
01936 0610           58                             pop ax
01937 0611           5D                           pop bp
01938                                           ! 885 endasm
01939                                           !BCC_ENDASM
01940                                           ! 886 }
01941 0612           C3                         ret
01942                                           ! 887   void
01943                                           ! 888 _write_word(data, offset, seg)
01944                                           ! 889   Bit16u data;
01945                                           export	__write_word
01946                       00000613            __write_word:
01947                                           !BCC_EOS
01948                                           ! 890   Bit16u offset;
01949                                           !BCC_EOS
01950                                           ! 891   Bit16u seg;
01951                                           !BCC_EOS
01952                                           ! 892 {
01953                                           ! 893 #asm
01954                                           !BCC_ASM
01955                       00000006            __write_word.seg	set	6
01956                       00000002            __write_word.data	set	2
01957                       00000004            __write_word.offset	set	4
01958 0613           55                           push bp
01959 0614           89E5                         mov bp, sp
01960 0616           50                             push ax
01961 0617           53                             push bx
01962 0618           1E                             push ds
01963 0619           C55E         06                lds bx, 6[bp] ; segment & offset
01964 061C           8B46         04                mov ax, 4[bp] ; data word
01965 061F           8907                           mov [bx], ax ; write data word
01966 0621           1F                             pop ds
01967 0622           5B                             pop bx
01968 0623           58                             pop ax
01969 0624           5D                           pop bp
01970                                           ! 906 endasm
01971                                           !BCC_ENDASM
01972                                           ! 907 }
01973 0625           C3                         ret
01974                                           ! 908   Bit8u
01975                                           ! 909 read_byte_SS(offset)
01976                                           ! 910   Bit16u offset;
01977                                           export	_read_byte_SS
01978                       00000626            _read_byte_SS:
01979                                           !BCC_EOS
01980                                           ! 911 {
01981                                           ! 912 #asm
01982                                           !BCC_ASM
01983                       00000002            _read_byte_SS.offset	set	2
01984 0626           55                           push bp
01985 0627           89E5                         mov bp, sp
01986 0629           8B6E         04              mov bp, 4[bp] ; offset
01987 062C           8A46         00              mov al, [bp]
01988                                             ;; al = return value (byte)
01989 062F           5D                           pop bp
01990                                           ! 919 endasm
01991                                           !BCC_ENDASM
01992                                           ! 920 }
01993 0630           C3                         ret
01994                                           ! 921   Bit16u
01995                                           ! 922 read_word_SS(offset)
01996                                           ! 923   Bit16u offset;
01997                                           export	_read_word_SS
01998                       00000631            _read_word_SS:
01999                                           !BCC_EOS
02000                                           ! 924 {
02001                                           ! 925 #asm
02002                                           !BCC_ASM
02003                       00000002            _read_word_SS.offset	set	2
02004 0631           55                           push bp
02005 0632           89E5                         mov bp, sp
02006 0634           8B6E         04              mov bp, 4[bp] ; offset
02007 0637           8B46         00              mov ax, [bp]
02008                                             ;; ax = return value (word)
02009 063A           5D                           pop bp
02010                                           ! 932 endasm
02011                                           !BCC_ENDASM
02012                                           ! 933 }
02013 063B           C3                         ret
02014                                           ! 934   void
02015                                           ! 935 _write_byte_SS(data, offset)
02016                                           ! 936   Bit8u data;
02017                                           export	__write_byte_SS
02018                       0000063C            __write_byte_SS:
02019                                           !BCC_EOS
02020                                           ! 937   Bit16u offset;
02021                                           !BCC_EOS
02022                                           ! 938 {
02023                                           ! 939 #asm
02024                                           !BCC_ASM
02025                       00000002            __write_byte_SS.data	set	2
02026                       00000004            __write_byte_SS.offset	set	4
02027 063C           55                           push bp
02028 063D           89E5                         mov bp, sp
02029 063F           50                           push ax
02030 0640           8A46         04              mov al, 4[bp] ; data byte
02031 0643           8B6E         06              mov bp, 6[bp] ; offset
02032 0646           8846         00              mov [bp], al ; write data byte
02033 0649           58                           pop ax
02034 064A           5D                           pop bp
02035                                           ! 948 endasm
02036                                           !BCC_ENDASM
02037                                           ! 949 }
02038 064B           C3                         ret
02039                                           ! 950   void
02040                                           ! 951 _write_word_SS(data, offset)
02041                                           ! 952   Bit16u data;
02042                                           export	__write_word_SS
02043                       0000064C            __write_word_SS:
02044                                           !BCC_EOS
02045                                           ! 953   Bit16u offset;
02046                                           !BCC_EOS
02047                                           ! 954 {
02048                                           ! 955 #asm
02049                                           !BCC_ASM
02050                       00000002            __write_word_SS.data	set	2
02051                       00000004            __write_word_SS.offset	set	4
02052 064C           55                           push bp
02053 064D           89E5                         mov bp, sp
02054 064F           50                           push ax
02055 0650           8B46         04              mov ax, 4[bp] ; data word
02056 0653           8B6E         06              mov bp, 6[bp] ; offset
02057 0656           8946         00              mov [bp], ax ; write data word
02058 0659           58                           pop ax
02059 065A           5D                           pop bp
02060                                           ! 964 endasm
02061                                           !BCC_ENDASM
02062                                           ! 965 }
02063 065B           C3                         ret
02064                                           ! 966   Bit16u
02065                                           ! 967 get_CS()
02066                                           ! 968 {
02067                                           export	_get_CS
02068                       0000065C            _get_CS:
02069                                           ! 969 #asm
02070                                           !BCC_ASM
02071 065C           8CC8                         mov ax, cs
02072                                           ! 971 endasm
02073                                           !BCC_ENDASM
02074                                           ! 972 }
02075 065E           C3                         ret
02076                                           ! 973   Bit16u
02077                                           ! 974 get_SS()
02078                                           ! 975 {
02079                                           export	_get_SS
02080                       0000065F            _get_SS:
02081                                           ! 976 #asm
02082                                           !BCC_ASM
02083 065F           8CD0                         mov ax, ss
02084                                           ! 978 endasm
02085                                           !BCC_ENDASM
02086                                           ! 979 }
02087 0661           C3                         ret
02088                                           ! 980   Bit16u
02089                                           ! 981 set_DS(seg)
02090                                           ! 982   Bit16u seg;
02091                                           export	_set_DS
02092                       00000662            _set_DS:
02093                                           !BCC_EOS
02094                                           ! 983 {
02095                                           ! 984 #asm
02096                                           !BCC_ASM
02097                       00000002            _set_DS.seg	set	2
02098 0662           55                           push bp
02099 0663           89E5                         mov bp, sp
02100 0665           1E                           push ds
02101 0666           8E5E         04              mov ds, 4[bp] ;; seg
02102 0669           58                           pop ax
02103 066A           5D                           pop bp
02104                                           ! 991 endasm
02105                                           !BCC_ENDASM
02106                                           ! 992 }
02107 066B           C3                         ret
02108                                           ! 993   Bit16u
02109                                           ! 994 get_ebda_seg()
02110                                           ! 995 {
02111                                           export	_get_ebda_seg
02112                       0000066C            _get_ebda_seg:
02113                                           ! 996 #asm
02114                                           !BCC_ASM
02115 066C           53                           push bx
02116 066D           1E                           push ds
02117 066E           B8                   0040    mov ax, #0x0040
02118 0671           8ED8                         mov ds, ax
02119 0673           BB                   000E    mov bx, #0x000e
02120 0676           8B07                         mov ax, [bx]
02121                                             ;; ax = return value (word)
02122 0678           1F                           pop ds
02123 0679           5B                           pop bx
02124                                           ! 1006 endasm
02125                                           !BCC_ENDASM
02126                                           ! 1007 }
02127 067A           C3                         ret
02128                                           ! 1008   void
02129                                           ! 1009 wrch(c)
02130                                           ! 1010   Bit8u c;
02131                                           export	_wrch
02132                       0000067B            _wrch:
02133                                           !BCC_EOS
02134                                           ! 1011 {
02135                                           ! 1012 #asm
02136                                           !BCC_ASM
02137                       00000002            _wrch.c	set	2
02138 067B           55                           push bp
02139 067C           89E5                         mov bp, sp
02140 067E           53                           push bx
02141 067F           B4                     0E    mov ah, #0x0e
02142 0681           8A46         04              mov al, 4[bp]
02143 0684           31DB                         xor bx,bx
02144 0686           CD                     10    int #0x10
02145 0688           5B                           pop bx
02146 0689           5D                           pop bp
02147                                           ! 1022 endasm
02148                                           !BCC_ENDASM
02149                                           ! 1023 }
02150 068A           C3                         ret
02151                                           ! 1024   void
02152                                           ! 1025 send(action, c)
02153                                           ! 1026   Bit16u action;
02154                                           export	_send
02155                       0000068B            _send:
02156                                           !BCC_EOS
02157                                           ! 1027   Bit8u c;
02158                                           !BCC_EOS
02159                                           ! 1028 {
02160                                           ! 1029   if (action & 8) outb(0x403, c);
02161 068B           55                         push	bp
02162 068C           89E5                       mov	bp,sp
02163                                           ! Debug: and int = const 8 to unsigned short action = [S+2+2] (used reg = )
02164 068E           8A46         04            mov	al,4[bp]
02165 0691           24                     08  and	al,*8
02166 0693           84C0                       test	al,al
02167 0695           74           0F            je  	.8
02168                       00000697            .9:
02169                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02170 0697           8A46         06            mov	al,6[bp]
02171 069A           30E4                       xor	ah,ah
02172 069C           50                         push	ax
02173                                           ! Debug: list int = const $403 (used reg = )
02174 069D           B8                   0403  mov	ax,#$403
02175 06A0           50                         push	ax
02176                                           ! Debug: func () void = outb+0 (used reg = )
02177 06A1           E8         FE6A            call	_outb
02178 06A4           89EC                       mov	sp,bp
02179                                           !BCC_EOS
02180                                           ! 1030   if (action & 4) outb(0x402, c);
02181                       000006A6            .8:
02182                                           ! Debug: and int = const 4 to unsigned short action = [S+2+2] (used reg = )
02183 06A6           8A46         04            mov	al,4[bp]
02184 06A9           24                     04  and	al,*4
02185 06AB           84C0                       test	al,al
02186 06AD           74           0F            je  	.A
02187                       000006AF            .B:
02188                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02189 06AF           8A46         06            mov	al,6[bp]
02190 06B2           30E4                       xor	ah,ah
02191 06B4           50                         push	ax
02192                                           ! Debug: list int = const $402 (used reg = )
02193 06B5           B8                   0402  mov	ax,#$402
02194 06B8           50                         push	ax
02195                                           ! Debug: func () void = outb+0 (used reg = )
02196 06B9           E8         FE52            call	_outb
02197 06BC           89EC                       mov	sp,bp
02198                                           !BCC_EOS
02199                                           ! 1031   if (action & 2) {
02200                       000006BE            .A:
02201                                           ! Debug: and int = const 2 to unsigned short action = [S+2+2] (used reg = )
02202 06BE           8A46         04            mov	al,4[bp]
02203 06C1           24                     02  and	al,*2
02204 06C3           84C0                       test	al,al
02205 06C5           74           1B            je  	.C
02206                       000006C7            .D:
02207                                           ! 1032     if (c == '\n') wrch('\r');
02208                                           ! Debug: logeq int = const $A to unsigned char c = [S+2+4] (used reg = )
02209 06C7           8A46         06            mov	al,6[bp]
02210 06CA           3C                     0A  cmp	al,*$A
02211 06CC           75           09            jne 	.E
02212                       000006CE            .F:
02213                                           ! Debug: list int = const $D (used reg = )
02214 06CE           B8                   000D  mov	ax,*$D
02215 06D1           50                         push	ax
02216                                           ! Debug: func () void = wrch+0 (used reg = )
02217 06D2           E8         FFA6            call	_wrch
02218 06D5           89EC                       mov	sp,bp
02219                                           !BCC_EOS
02220                                           ! 1033     wrch(c);
02221                       000006D7            .E:
02222                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02223 06D7           8A46         06            mov	al,6[bp]
02224 06DA           30E4                       xor	ah,ah
02225 06DC           50                         push	ax
02226                                           ! Debug: func () void = wrch+0 (used reg = )
02227 06DD           E8         FF9B            call	_wrch
02228 06E0           89EC                       mov	sp,bp
02229                                           !BCC_EOS
02230                                           ! 1034   }
02231                                           ! 1035 }
02232                       000006E2            .C:
02233 06E2           5D                         pop	bp
02234 06E3           C3                         ret
02235                                           ! 1036   void
02236                                           ! 1037 put_uint(action, val, width, neg)
02237                                           ! 1038   Bit16u action;
02238                                           export	_put_uint
02239                       000006E4            _put_uint:
02240                                           !BCC_EOS
02241                                           ! 1039   unsigned short val;
02242                                           !BCC_EOS
02243                                           ! 1040   short width;
02244                                           !BCC_EOS
02245                                           ! 1041   bx_bool neg;
02246                                           !BCC_EOS
02247                                           ! 1042 {
02248                                           ! 1043   unsigned short nval = val / 10;
02249 06E4           55                         push	bp
02250 06E5           89E5                       mov	bp,sp
02251 06E7           4C                         dec	sp
02252 06E8           4C                         dec	sp
02253                                           ! Debug: div int = const $A to unsigned short val = [S+4+4] (used reg = )
02254 06E9           8B46         06            mov	ax,6[bp]
02255 06EC           BB                   000A  mov	bx,*$A
02256 06EF           E8         FA48            call	idiv_u
02257                                           ! Debug: eq unsigned int = ax+0 to unsigned short nval = [S+4-4] (used reg = )
02258 06F2           8946         FE            mov	-2[bp],ax
02259                                           !BCC_EOS
02260                                           ! 1044   if (nval)
02261 06F5           8B46         FE            mov	ax,-2[bp]
02262 06F8           85C0                       test	ax,ax
02263 06FA           74           16            je  	.10
02264                       000006FC            .11:
02265                                           ! 1045     put_uint(action, nval, width - 1, neg);
02266                                           ! Debug: list unsigned short neg = [S+4+8] (used reg = )
02267 06FC           FF76         0A            push	$A[bp]
02268                                           ! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
02269 06FF           8B46         08            mov	ax,8[bp]
02270                                           ! Debug: list int = ax-1 (used reg = )
02271 0702           48                         dec	ax
02272 0703           50                         push	ax
02273                                           ! Debug: list unsigned short nval = [S+8-4] (used reg = )
02274 0704           FF76         FE            push	-2[bp]
02275                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02276 0707           FF76         04            push	4[bp]
02277                                           ! Debug: func () void = put_uint+0 (used reg = )
02278 070A           E8         FFD7            call	_put_uint
02279 070D           83C4                   08  add	sp,*8
02280                                           !BCC_EOS
02281                                           ! 1046   else {
02282 0710           EB           2E            jmp .12
02283                       00000712            .10:
02284                                           ! 1047     while (--width > 0) send(action, ' ');
02285 0712           EB           0D            jmp .14
02286                       00000714            .15:
02287                                           ! Debug: list int = const $20 (used reg = )
02288 0714           B8                   0020  mov	ax,*$20
02289 0717           50                         push	ax
02290                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02291 0718           FF76         04            push	4[bp]
02292                                           ! Debug: func () void = send+0 (used reg = )
02293 071B           E8         FF6D            call	_send
02294 071E           83C4                   04  add	sp,*4
02295                                           !BCC_EOS
02296                                           ! 1048     if (neg) send(action, '-');
02297                       00000721            .14:
02298                                           ! Debug: predec short width = [S+4+6] (used reg = )
02299 0721           8B46         08            mov	ax,8[bp]
02300 0724           48                         dec	ax
02301 0725           8946         08            mov	8[bp],ax
02302                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02303 0728           85C0                       test	ax,ax
02304 072A           7F           E8            jg 	.15
02305                       0000072C            .16:
02306                       0000072C            .13:
02307 072C           8B46         0A            mov	ax,$A[bp]
02308 072F           85C0                       test	ax,ax
02309 0731           74           0D            je  	.17
02310                       00000733            .18:
02311                                           ! Debug: list int = const $2D (used reg = )
02312 0733           B8                   002D  mov	ax,*$2D
02313 0736           50                         push	ax
02314                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02315 0737           FF76         04            push	4[bp]
02316                                           ! Debug: func () void = send+0 (used reg = )
02317 073A           E8         FF4E            call	_send
02318 073D           83C4                   04  add	sp,*4
02319                                           !BCC_EOS
02320                                           ! 1049   }
02321                       00000740            .17:
02322                                           ! 1050   send(action, val - (nval * 10) + '0');
02323                       00000740            .12:
02324                                           ! Debug: mul int = const $A to unsigned short nval = [S+4-4] (used reg = )
02325 0740           8B46         FE            mov	ax,-2[bp]
02326 0743           89C2                       mov	dx,ax
02327 0745           D1E0                       shl	ax,*1
02328 0747           D1E0                       shl	ax,*1
02329 0749           01D0                       add	ax,dx
02330 074B           D1E0                       shl	ax,*1
02331                                           ! Debug: sub unsigned int = ax+0 to unsigned short val = [S+4+4] (used reg = )
02332 074D           50                         push	ax
02333 074E           8B46         06            mov	ax,6[bp]
02334 0751           2B46         FC            sub	ax,-4[bp]
02335 0754           44                         inc	sp
02336 0755           44                         inc	sp
02337                                           ! Debug: add int = const $30 to unsigned int = ax+0 (used reg = )
02338                                           ! Debug: list unsigned int = ax+$30 (used reg = )
02339 0756           05                   0030  add	ax,*$30
02340 0759           50                         push	ax
02341                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02342 075A           FF76         04            push	4[bp]
02343                                           ! Debug: func () void = send+0 (used reg = )
02344 075D           E8         FF2B            call	_send
02345 0760           83C4                   04  add	sp,*4
02346                                           !BCC_EOS
02347                                           ! 1051 }
02348 0763           89EC                       mov	sp,bp
02349 0765           5D                         pop	bp
02350 0766           C3                         ret
02351                                           ! 1052   void
02352                                           ! Register BX used in function put_uint
02353                                           ! 1053 put_luint(action, val, width, neg)
02354                                           ! 1054   Bit16u action;
02355                                           export	_put_luint
02356                       00000767            _put_luint:
02357                                           !BCC_EOS
02358                                           ! 1055   unsigned long val;
02359                                           !BCC_EOS
02360                                           ! 1056   short width;
02361                                           !BCC_EOS
02362                                           ! 1057   bx_bool neg;
02363                                           !BCC_EOS
02364                                           ! 1058 {
02365                                           ! 1059   unsigned long nval = val / 10;
02366 0767           55                         push	bp
02367 0768           89E5                       mov	bp,sp
02368 076A           83C4                   FC  add	sp,*-4
02369                                           ! Debug: div unsigned long = const $A to unsigned long val = [S+6+4] (used reg = )
02370 076D           B8                   000A  mov	ax,*$A
02371 0770           31DB                       xor	bx,bx
02372 0772           53                         push	bx
02373 0773           50                         push	ax
02374 0774           8B46         06            mov	ax,6[bp]
02375 0777           8B5E         08            mov	bx,8[bp]
02376 077A           8D7E         F8            lea	di,-8[bp]
02377 077D           E8         F9BF            call	ldivul
02378 0780           83C4                   04  add	sp,*4
02379                                           ! Debug: eq unsigned long = bx+0 to unsigned long nval = [S+6-6] (used reg = )
02380 0783           8946         FC            mov	-4[bp],ax
02381 0786           895E         FE            mov	-2[bp],bx
02382                                           !BCC_EOS
02383                                           ! 1060   if (nval)
02384 0789           8B46         FC            mov	ax,-4[bp]
02385 078C           8B5E         FE            mov	bx,-2[bp]
02386 078F           E8         F953            call	ltstl
02387 0792           74           19            je  	.19
02388                       00000794            .1A:
02389                                           ! 1061     put_luint(action, nval, width - 1, neg);
02390                                           ! Debug: list unsigned short neg = [S+6+$A] (used reg = )
02391 0794           FF76         0C            push	$C[bp]
02392                                           ! Debug: sub int = const 1 to short width = [S+8+8] (used reg = )
02393 0797           8B46         0A            mov	ax,$A[bp]
02394                                           ! Debug: list int = ax-1 (used reg = )
02395 079A           48                         dec	ax
02396 079B           50                         push	ax
02397                                           ! Debug: list unsigned long nval = [S+$A-6] (used reg = )
02398 079C           FF76         FE            push	-2[bp]
02399 079F           FF76         FC            push	-4[bp]
02400                                           ! Debug: list unsigned short action = [S+$E+2] (used reg = )
02401 07A2           FF76         04            push	4[bp]
02402                                           ! Debug: func () void = put_luint+0 (used reg = )
02403 07A5           E8         FFBF            call	_put_luint
02404 07A8           83C4                   0A  add	sp,*$A
02405                                           !BCC_EOS
02406                                           ! 1062   else {
02407 07AB           EB           2E            jmp .1B
02408                       000007AD            .19:
02409                                           ! 1063     while (--width > 0) send(action, ' ');
02410 07AD           EB           0D            jmp .1D
02411                       000007AF            .1E:
02412                                           ! Debug: list int = const $20 (used reg = )
02413 07AF           B8                   0020  mov	ax,*$20
02414 07B2           50                         push	ax
02415                                           ! Debug: list unsigned short action = [S+8+2] (used reg = )
02416 07B3           FF76         04            push	4[bp]
02417                                           ! Debug: func () void = send+0 (used reg = )
02418 07B6           E8         FED2            call	_send
02419 07B9           83C4                   04  add	sp,*4
02420                                           !BCC_EOS
02421                                           ! 1064     if (neg) send(action, '-');
02422                       000007BC            .1D:
02423                                           ! Debug: predec short width = [S+6+8] (used reg = )
02424 07BC           8B46         0A            mov	ax,$A[bp]
02425 07BF           48                         dec	ax
02426 07C0           8946         0A            mov	$A[bp],ax
02427                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02428 07C3           85C0                       test	ax,ax
02429 07C5           7F           E8            jg 	.1E
02430                       000007C7            .1F:
02431                       000007C7            .1C:
02432 07C7           8B46         0C            mov	ax,$C[bp]
02433 07CA           85C0                       test	ax,ax
02434 07CC           74           0D            je  	.20
02435                       000007CE            .21:
02436                                           ! Debug: list int = const $2D (used reg = )
02437 07CE           B8                   002D  mov	ax,*$2D
02438 07D1           50                         push	ax
02439                                           ! Debug: list unsigned short action = [S+8+2] (used reg = )
02440 07D2           FF76         04            push	4[bp]
02441                                           ! Debug: func () void = send+0 (used reg = )
02442 07D5           E8         FEB3            call	_send
02443 07D8           83C4                   04  add	sp,*4
02444                                           !BCC_EOS
02445                                           ! 1065   }
02446                       000007DB            .20:
02447                                           ! 1066   send(action, val - (nval * 10) + '0');
02448                       000007DB            .1B:
02449                                           ! Debug: mul unsigned long = const $A to unsigned long nval = [S+6-6] (used reg = )
02450                                           ! Debug: expression subtree swapping
02451 07DB           B8                   000A  mov	ax,*$A
02452 07DE           31DB                       xor	bx,bx
02453 07E0           8D7E         FC            lea	di,-4[bp]
02454 07E3           E8         F8D4            call	lmulul
02455                                           ! Debug: sub unsigned long = bx+0 to unsigned long val = [S+6+4] (used reg = )
02456 07E6           53                         push	bx
02457 07E7           50                         push	ax
02458 07E8           8B46         06            mov	ax,6[bp]
02459 07EB           8B5E         08            mov	bx,8[bp]
02460 07EE           8D7E         F8            lea	di,-8[bp]
02461 07F1           E8         F8BE            call	lsubul
02462 07F4           83C4                   04  add	sp,*4
02463                                           ! Debug: add unsigned long = const $30 to unsigned long = bx+0 (used reg = )
02464 07F7           53                         push	bx
02465 07F8           50                         push	ax
02466 07F9           B8                   0030  mov	ax,*$30
02467 07FC           31DB                       xor	bx,bx
02468 07FE           53                         push	bx
02469 07FF           50                         push	ax
02470 0800           8B46         F8            mov	ax,-8[bp]
02471 0803           8B5E         FA            mov	bx,-6[bp]
02472 0806           8D7E         F4            lea	di,-$C[bp]
02473 0809           E8         F888            call	laddul
02474 080C           83C4                   08  add	sp,*8
02475                                           ! Debug: list unsigned long = bx+0 (used reg = )
02476 080F           53                         push	bx
02477 0810           50                         push	ax
02478                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02479 0811           FF76         04            push	4[bp]
02480                                           ! Debug: func () void = send+0 (used reg = )
02481 0814           E8         FE74            call	_send
02482 0817           83C4                   06  add	sp,*6
02483                                           !BCC_EOS
02484                                           ! 1067 }
02485 081A           89EC                       mov	sp,bp
02486 081C           5D                         pop	bp
02487 081D           C3                         ret
02488                                           ! 1068 void put_str(action, segment, offset)
02489                                           ! Register BX used in function put_luint
02490                                           ! 1069   Bit16u action;
02491                                           export	_put_str
02492                       0000081E            _put_str:
02493                                           !BCC_EOS
02494                                           ! 1070   Bit16u segment;
02495                                           !BCC_EOS
02496                                           ! 1071   Bit16u offset;
02497                                           !BCC_EOS
02498                                           ! 1072 {
02499                                           ! 1073   Bit8u c;
02500                                           !BCC_EOS
02501                                           ! 1074   while (c = _read_byte(offset, segment)) {
02502 081E           55                         push	bp
02503 081F           89E5                       mov	bp,sp
02504 0821           4C                         dec	sp
02505 0822           4C                         dec	sp
02506 0823           EB           16            jmp .23
02507                       00000825            .24:
02508                                           ! 1075     send(action, c);
02509                                           ! Debug: list unsigned char c = [S+4-3] (used reg = )
02510 0825           8A46         FF            mov	al,-1[bp]
02511 0828           30E4                       xor	ah,ah
02512 082A           50                         push	ax
02513                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02514 082B           FF76         04            push	4[bp]
02515                                           ! Debug: func () void = send+0 (used reg = )
02516 082E           E8         FE5A            call	_send
02517 0831           83C4                   04  add	sp,*4
02518                                           !BCC_EOS
02519                                           ! 1076     offset++;
02520                                           ! Debug: postinc unsigned short offset = [S+4+6] (used reg = )
02521 0834           8B46         08            mov	ax,8[bp]
02522 0837           40                         inc	ax
02523 0838           8946         08            mov	8[bp],ax
02524                                           !BCC_EOS
02525                                           ! 1077   }
02526                                           ! 1078 }
02527                       0000083B            .23:
02528                                           ! Debug: list unsigned short segment = [S+4+4] (used reg = )
02529 083B           FF76         06            push	6[bp]
02530                                           ! Debug: list unsigned short offset = [S+6+6] (used reg = )
02531 083E           FF76         08            push	8[bp]
02532                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
02533 0841           E8         FDA0            call	__read_byte
02534 0844           83C4                   04  add	sp,*4
02535                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+4-3] (used reg = )
02536 0847           8846         FF            mov	-1[bp],al
02537 084A           84C0                       test	al,al
02538 084C           75           D7            jne	.24
02539                       0000084E            .25:
02540                       0000084E            .22:
02541 084E           89EC                       mov	sp,bp
02542 0850           5D                         pop	bp
02543 0851           C3                         ret
02544                                           ! 1079   void
02545                                           ! 1080 delay_ticks(ticks)
02546                                           ! 1081   Bit16u ticks;
02547                                           export	_delay_ticks
02548                       00000852            _delay_ticks:
02549                                           !BCC_EOS
02550                                           ! 1082 {
02551                                           ! 1083   long ticks_to_wait, delta;
02552                                           !BCC_EOS
02553                                           ! 1084   Bit32u prev_ticks, t;
02554                                           !BCC_EOS
02555                                           ! 1085 #asm
02556 0852           55                         push	bp
02557 0853           89E5                       mov	bp,sp
02558 0855           83C4                   F0  add	sp,*-$10
02559                                           !BCC_EOS
02560                                           !BCC_ASM
02561                       00000014            _delay_ticks.ticks	set	$14
02562                       00000004            .delay_ticks.ticks	set	4
02563                       00000000            _delay_ticks.t	set	0
02564                       FFFFFFF0            .delay_ticks.t	set	-$10
02565                       00000004            _delay_ticks.prev_ticks	set	4
02566                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02567                       00000008            _delay_ticks.delta	set	8
02568                       FFFFFFF8            .delay_ticks.delta	set	-8
02569                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02570                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02571 0858           9C                           pushf
02572 0859           1E                           push ds
02573 085A           6A                     00    push #0x00
02574 085C           1F                           pop ds
02575 085D           FB                           sti
02576                                           ! 1091 endasm
02577                                           !BCC_ENDASM
02578                                           !BCC_EOS
02579                                           ! 1092   ticks_to_wait = ticks;
02580                                           ! Debug: eq unsigned short ticks = [S+$12+2] to long ticks_to_wait = [S+$12-6] (used reg = )
02581 085E           8B46         04            mov	ax,4[bp]
02582 0861           31DB                       xor	bx,bx
02583 0863           8946         FC            mov	-4[bp],ax
02584 0866           895E         FE            mov	-2[bp],bx
02585                                           !BCC_EOS
02586                                           ! 1093   prev_ticks = *((Bit32u *)(0x46c));
02587                                           ! Debug: eq unsigned long = [+$46C] to unsigned long prev_ticks = [S+$12-$E] (used reg = )
02588 0869           A1         046C            mov	ax,[$46C]
02589 086C           8B1E       046E            mov	bx,[$46E]
02590 0870           8946         F4            mov	-$C[bp],ax
02591 0873           895E         F6            mov	-$A[bp],bx
02592                                           !BCC_EOS
02593                                           ! 1094   do
02594                                           ! 1095   {
02595                       00000876            .28:
02596                                           ! 1096 #asm
02597                                           !BCC_EOS
02598                                           !BCC_ASM
02599                       00000014            _delay_ticks.ticks	set	$14
02600                       00000004            .delay_ticks.ticks	set	4
02601                       00000000            _delay_ticks.t	set	0
02602                       FFFFFFF0            .delay_ticks.t	set	-$10
02603                       00000004            _delay_ticks.prev_ticks	set	4
02604                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02605                       00000008            _delay_ticks.delta	set	8
02606                       FFFFFFF8            .delay_ticks.delta	set	-8
02607                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02608                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02609 0876           F4                             hlt
02610                                           ! 1098 endasm
02611                                           !BCC_ENDASM
02612                                           !BCC_EOS
02613                                           ! 1099     t = *((Bit32u *)(0x46c));
02614                                           ! Debug: eq unsigned long = [+$46C] to unsigned long t = [S+$12-$12] (used reg = )
02615 0877           A1         046C            mov	ax,[$46C]
02616 087A           8B1E       046E            mov	bx,[$46E]
02617 087E           8946         F0            mov	-$10[bp],ax
02618 0881           895E         F2            mov	-$E[bp],bx
02619                                           !BCC_EOS
02620                                           ! 1100     if (t > prev_ticks)
02621                                           ! Debug: gt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02622 0884           8B46         F4            mov	ax,-$C[bp]
02623 0887           8B5E         F6            mov	bx,-$A[bp]
02624 088A           8D7E         F0            lea	di,-$10[bp]
02625 088D           E8         F80C            call	lcmpul
02626 0890           73           26            jae 	.29
02627                       00000892            .2A:
02628                                           ! 1101     {
02629                                           ! 1102       delta = t - prev_ticks;
02630                                           ! Debug: sub unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02631 0892           8B46         F0            mov	ax,-$10[bp]
02632 0895           8B5E         F2            mov	bx,-$E[bp]
02633 0898           8D7E         F4            lea	di,-$C[bp]
02634 089B           E8         F814            call	lsubul
02635                                           ! Debug: eq unsigned long = bx+0 to long delta = [S+$12-$A] (used reg = )
02636 089E           8946         F8            mov	-8[bp],ax
02637 08A1           895E         FA            mov	-6[bp],bx
02638                                           !BCC_EOS
02639                                           ! 1103       ticks_to_wait -= delta;
02640                                           ! Debug: subab long delta = [S+$12-$A] to long ticks_to_wait = [S+$12-6] (used reg = )
02641 08A4           8B46         FC            mov	ax,-4[bp]
02642 08A7           8B5E         FE            mov	bx,-2[bp]
02643 08AA           8D7E         F8            lea	di,-8[bp]
02644 08AD           E8         F802            call	lsubl
02645 08B0           8946         FC            mov	-4[bp],ax
02646 08B3           895E         FE            mov	-2[bp],bx
02647                                           !BCC_EOS
02648                                           ! 1104     }
02649                                           ! 1105     else if (t < prev_ticks)
02650 08B6           EB           20            jmp .2B
02651                       000008B8            .29:
02652                                           ! Debug: lt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02653 08B8           8B46         F4            mov	ax,-$C[bp]
02654 08BB           8B5E         F6            mov	bx,-$A[bp]
02655 08BE           8D7E         F0            lea	di,-$10[bp]
02656 08C1           E8         F7D8            call	lcmpul
02657 08C4           76           12            jbe 	.2C
02658                       000008C6            .2D:
02659                                           ! 1106     {
02660                                           ! 1107       ticks_to_wait -= t;
02661                                           ! Debug: subab unsigned long t = [S+$12-$12] to long ticks_to_wait = [S+$12-6] (used reg = )
02662 08C6           8B46         FC            mov	ax,-4[bp]
02663 08C9           8B5E         FE            mov	bx,-2[bp]
02664 08CC           8D7E         F0            lea	di,-$10[bp]
02665 08CF           E8         F7E0            call	lsubul
02666 08D2           8946         FC            mov	-4[bp],ax
02667 08D5           895E         FE            mov	-2[bp],bx
02668                                           !BCC_EOS
02669                                           ! 1108     }
02670                                           ! 1109     prev_ticks = t;
02671                       000008D8            .2C:
02672                       000008D8            .2B:
02673                                           ! Debug: eq unsigned long t = [S+$12-$12] to unsigned long prev_ticks = [S+$12-$E] (used reg = )
02674 08D8           8B46         F0            mov	ax,-$10[bp]
02675 08DB           8B5E         F2            mov	bx,-$E[bp]
02676 08DE           8946         F4            mov	-$C[bp],ax
02677 08E1           895E         F6            mov	-$A[bp],bx
02678                                           !BCC_EOS
02679                                           ! 1110   } while (ticks_to_wait > 0);
02680                       000008E4            .27:
02681                                           ! Debug: gt long = const 0 to long ticks_to_wait = [S+$12-6] (used reg = )
02682 08E4           31C0                       xor	ax,ax
02683 08E6           31DB                       xor	bx,bx
02684 08E8           8D7E         FC            lea	di,-4[bp]
02685 08EB           E8         F7AE            call	lcmpl
02686 08EE           7C           86            jl 	.28
02687                       000008F0            .2E:
02688                                           !BCC_EOS
02689                                           ! 1111 #asm
02690                       000008F0            .26:
02691                                           !BCC_EOS
02692                                           !BCC_ASM
02693                       00000014            _delay_ticks.ticks	set	$14
02694                       00000004            .delay_ticks.ticks	set	4
02695                       00000000            _delay_ticks.t	set	0
02696                       FFFFFFF0            .delay_ticks.t	set	-$10
02697                       00000004            _delay_ticks.prev_ticks	set	4
02698                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02699                       00000008            _delay_ticks.delta	set	8
02700                       FFFFFFF8            .delay_ticks.delta	set	-8
02701                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02702                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02703 08F0           FA                           cli
02704 08F1           1F                           pop ds
02705 08F2           9D                           popf
02706                                           ! 1115 endasm
02707                                           !BCC_ENDASM
02708                                           !BCC_EOS
02709                                           ! 1116 }
02710 08F3           89EC                       mov	sp,bp
02711 08F5           5D                         pop	bp
02712 08F6           C3                         ret
02713                                           ! 1117   Bit8u
02714                                           ! Register BX used in function delay_ticks
02715                                           ! 1118 check_for_keystroke()
02716                                           ! 1119 {
02717                                           export	_check_for_keystroke
02718                       000008F7            _check_for_keystroke:
02719                                           ! 1120 #asm
02720                                           !BCC_ASM
02721 08F7           B8                   0100    mov ax, #0x100
02722 08FA           CD                     16    int #0x16
02723 08FC           74           04              jz no_key
02724 08FE           B0                     01    mov al, #1
02725 0900           EB           02              jmp done
02726                       00000902            no_key:
02727 0902           30C0                         xor al, al
02728                       00000904            done:
02729                                           ! 1129 endasm
02730                                           !BCC_ENDASM
02731                                           ! 1130 }
02732 0904           C3                         ret
02733                                           ! 1131   Bit8u
02734                                           ! 1132 get_keystroke()
02735                                           ! 1133 {
02736                                           export	_get_keystroke
02737                       00000905            _get_keystroke:
02738                                           ! 1134 #asm
02739                                           !BCC_ASM
02740 0905           B8                   0000    mov ax, #0x0
02741 0908           CD                     16    int #0x16
02742 090A           86C4                         xchg ah, al
02743                                           ! 1138 endasm
02744                                           !BCC_ENDASM
02745                                           ! 1139 }
02746 090C           C3                         ret
02747                                           ! 1140   void
02748                                           ! 1141 delay_ticks_and_check_for_keystroke(ticks, count)
02749                                           ! 1142   Bit16u ticks, count;
02750                                           export	_delay_ticks_and_check_for_keystroke
02751                       0000090D            _delay_ticks_and_check_for_keystroke:
02752                                           !BCC_EOS
02753                                           ! 1143 {
02754                                           ! 1144   Bit16u i;
02755                                           !BCC_EOS
02756                                           ! 1145   for (i = 1; i <= count; i++) {
02757 090D           55                         push	bp
02758 090E           89E5                       mov	bp,sp
02759 0910           4C                         dec	sp
02760 0911           4C                         dec	sp
02761                                           ! Debug: eq int = const 1 to unsigned short i = [S+4-4] (used reg = )
02762 0912           B8                   0001  mov	ax,*1
02763 0915           8946         FE            mov	-2[bp],ax
02764                                           !BCC_EOS
02765                                           !BCC_EOS
02766 0918           EB           18            jmp .31
02767                       0000091A            .32:
02768                                           ! 1146     delay_ticks(ticks);
02769                                           ! Debug: list unsigned short ticks = [S+4+2] (used reg = )
02770 091A           FF76         04            push	4[bp]
02771                                           ! Debug: func () void = delay_ticks+0 (used reg = )
02772 091D           E8         FF32            call	_delay_ticks
02773 0920           44                         inc	sp
02774 0921           44                         inc	sp
02775                                           !BCC_EOS
02776                                           ! 1147     if (check_for_keystroke())
02777                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
02778 0922           E8         FFD2            call	_check_for_keystroke
02779 0925           84C0                       test	al,al
02780 0927           74           02            je  	.33
02781                       00000929            .34:
02782                                           ! 1148       break;
02783 0929           EB           0F            jmp .2F
02784                                           !BCC_EOS
02785                                           ! 1149   }
02786                       0000092B            .33:
02787                                           ! 1150 }
02788                       0000092B            .30:
02789                                           ! Debug: postinc unsigned short i = [S+4-4] (used reg = )
02790 092B           8B46         FE            mov	ax,-2[bp]
02791 092E           40                         inc	ax
02792 092F           8946         FE            mov	-2[bp],ax
02793                       00000932            .31:
02794                                           ! Debug: le unsigned short count = [S+4+4] to unsigned short i = [S+4-4] (used reg = )
02795 0932           8B46         FE            mov	ax,-2[bp]
02796 0935           3B46         06            cmp	ax,6[bp]
02797 0938           76           E0            jbe	.32
02798                       0000093A            .35:
02799                       0000093A            .2F:
02800 093A           89EC                       mov	sp,bp
02801 093C           5D                         pop	bp
02802 093D           C3                         ret
02803                                           ! 1151   void
02804                                           ! 1152 bios_printf(action, s)
02805                                           ! 1153   Bit16u action;
02806                                           export	_bios_printf
02807                       0000093E            _bios_printf:
02808                                           !BCC_EOS
02809                                           ! 1154   Bit8u *s;
02810                                           !BCC_EOS
02811                                           ! 1155 {
02812                                           ! 1156   Bit8u c, format_char;
02813                                           !BCC_EOS
02814                                           ! 1157   bx_bool in_format;
02815                                           !BCC_EOS
02816                                           ! 1158   short i;
02817                                           !BCC_EOS
02818                                           ! 1159   Bit16u *arg_ptr;
02819                                           !BCC_EOS
02820                                           ! 1160   Bit16u arg, nibble, shift_count, format_width;
02821                                           !BCC_EOS
02822                                           ! 1161   Bit16u old_ds = set_DS(get_CS());
02823 093E           55                         push	bp
02824 093F           89E5                       mov	bp,sp
02825 0941           83C4                   EE  add	sp,*-$12
02826                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
02827 0944           E8         FD15            call	_get_CS
02828                                           ! Debug: list unsigned short = ax+0 (used reg = )
02829 0947           50                         push	ax
02830                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
02831 0948           E8         FD17            call	_set_DS
02832 094B           44                         inc	sp
02833 094C           44                         inc	sp
02834                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+$14-$14] (used reg = )
02835 094D           8946         EE            mov	-$12[bp],ax
02836                                           !BCC_EOS
02837                                           ! 1162   Bit32u lval;
02838                                           !BCC_EOS
02839                                           ! 1163   arg_ptr = &s;
02840 0950           83C4                   FC  add	sp,*-4
02841                                           ! Debug: eq * * unsigned char s = S+$18+4 to * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02842 0953           8D5E         06            lea	bx,6[bp]
02843 0956           895E         F8            mov	-8[bp],bx
02844                                           !BCC_EOS
02845                                           ! 1164   in_format = 0;
02846                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
02847 0959           31C0                       xor	ax,ax
02848 095B           8946         FC            mov	-4[bp],ax
02849                                           !BCC_EOS
02850                                           ! 1165   format_width = 0;
02851                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$12] (used reg = )
02852 095E           31C0                       xor	ax,ax
02853 0960           8946         F0            mov	-$10[bp],ax
02854                                           !BCC_EOS
02855                                           ! 1166   if ((action & (2 | 4 | 1)) == (2 | 4 | 1)) {
02856                                           ! Debug: and int = const 7 to unsigned short action = [S+$18+2] (used reg = )
02857 0963           8A46         04            mov	al,4[bp]
02858 0966           24                     07  and	al,*7
02859                                           ! Debug: logeq int = const 7 to unsigned char = al+0 (used reg = )
02860 0968           3C                     07  cmp	al,*7
02861 096A           75           1B            jne 	.36
02862                       0000096C            .37:
02863                                           ! 1167     outb(0x401, 0x00);
02864                                           ! Debug: list int = const 0 (used reg = )
02865 096C           31C0                       xor	ax,ax
02866 096E           50                         push	ax
02867                                           ! Debug: list int = const $401 (used reg = )
02868 096F           B8                   0401  mov	ax,#$401
02869 0972           50                         push	ax
02870                                           ! Debug: func () void = outb+0 (used reg = )
02871 0973           E8         FB98            call	_outb
02872 0976           83C4                   04  add	sp,*4
02873                                           !BCC_EOS
02874                                           ! 1168     bios_printf (2, "FATAL: ");
02875                                           ! Debug: list * char = .38+0 (used reg = )
02876 0979           BB                   DA10  mov	bx,#.38
02877 097C           53                         push	bx
02878                                           ! Debug: list int = const 2 (used reg = )
02879 097D           B8                   0002  mov	ax,*2
02880 0980           50                         push	ax
02881                                           ! Debug: func () void = bios_printf+0 (used reg = )
02882 0981           E8         FFBA            call	_bios_printf
02883 0984           83C4                   04  add	sp,*4
02884                                           !BCC_EOS
02885                                           ! 1169   }
02886                                           ! 1170   while (c = *((Bit8u *)(s))) {
02887                       00000987            .36:
02888 0987           E9         02B2            br 	.3A
02889                       0000098A            .3B:
02890                                           ! 1171     if ( c == '%' ) {
02891                                           ! Debug: logeq int = const $25 to unsigned char c = [S+$18-3] (used reg = )
02892 098A           8A46         FF            mov	al,-1[bp]
02893 098D           3C                     25  cmp	al,*$25
02894 098F           75           0E            jne 	.3C
02895                       00000991            .3D:
02896                                           ! 1172       in_format = 1;
02897                                           ! Debug: eq int = const 1 to unsigned short in_format = [S+$18-6] (used reg = )
02898 0991           B8                   0001  mov	ax,*1
02899 0994           8946         FC            mov	-4[bp],ax
02900                                           !BCC_EOS
02901                                           ! 1173       format_width = 0;
02902                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$12] (used reg = )
02903 0997           31C0                       xor	ax,ax
02904 0999           8946         F0            mov	-$10[bp],ax
02905                                           !BCC_EOS
02906                                           ! 1174     }
02907                                           ! 1175     else if (in_format) {
02908 099C           E9         0296            br 	.3E
02909                       0000099F            .3C:
02910 099F           8B46         FC            mov	ax,-4[bp]
02911 09A2           85C0                       test	ax,ax
02912 09A4         0F84         027E            beq 	.3F
02913                       000009A8            .40:
02914                                           ! 1176       if ( (c>='0') && (c<='9') ) {
02915                                           ! Debug: ge int = const $30 to unsigned char c = [S+$18-3] (used reg = )
02916 09A8           8A46         FF            mov	al,-1[bp]
02917 09AB           3C                     30  cmp	al,*$30
02918 09AD           72           28            jb  	.41
02919                       000009AF            .43:
02920                                           ! Debug: le int = const $39 to unsigned char c = [S+$18-3] (used reg = )
02921 09AF           8A46         FF            mov	al,-1[bp]
02922 09B2           3C                     39  cmp	al,*$39
02923 09B4           77           21            ja  	.41
02924                       000009B6            .42:
02925                                           ! 1177         format_width = (format_width * 10) + (c - '0');
02926                                           ! Debug: sub int = const $30 to unsigned char c = [S+$18-3] (used reg = )
02927 09B6           8A46         FF            mov	al,-1[bp]
02928 09B9           30E4                       xor	ah,ah
02929 09BB           05                   FFD0  add	ax,*-$30
02930 09BE           50                         push	ax
02931                                           ! Debug: mul int = const $A to unsigned short format_width = [S+$1A-$12] (used reg = )
02932 09BF           8B46         F0            mov	ax,-$10[bp]
02933 09C2           89C2                       mov	dx,ax
02934 09C4           D1E0                       shl	ax,*1
02935 09C6           D1E0                       shl	ax,*1
02936 09C8           01D0                       add	ax,dx
02937 09CA           D1E0                       shl	ax,*1
02938                                           ! Debug: add unsigned int (temp) = [S+$1A-$1A] to unsigned int = ax+0 (used reg = )
02939 09CC           0346         E8            add	ax,-$18[bp]
02940 09CF           44                         inc	sp
02941 09D0           44                         inc	sp
02942                                           ! Debug: eq unsigned int = ax+0 to unsigned short format_width = [S+$18-$12] (used reg = )
02943 09D1           8946         F0            mov	-$10[bp],ax
02944                                           !BCC_EOS
02945                                           ! 1178       }
02946                                           ! 1179       else {
02947 09D4           E9         024D            br 	.44
02948                       000009D7            .41:
02949                                           ! 1180         arg_ptr++;
02950                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02951 09D7           8B5E         F8            mov	bx,-8[bp]
02952 09DA           43                         inc	bx
02953 09DB           43                         inc	bx
02954 09DC           895E         F8            mov	-8[bp],bx
02955                                           !BCC_EOS
02956                                           ! 1181         arg = read_word_SS(arg_ptr);
02957                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02958 09DF           FF76         F8            push	-8[bp]
02959                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
02960 09E2           E8         FC4C            call	_read_word_SS
02961 09E5           44                         inc	sp
02962 09E6           44                         inc	sp
02963                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$C] (used reg = )
02964 09E7           8946         F6            mov	-$A[bp],ax
02965                                           !BCC_EOS
02966                                           ! 1182         if ((c & 0xdf) == 'X') {
02967                                           ! Debug: and int = const $DF to unsigned char c = [S+$18-3] (used reg = )
02968 09EA           8A46         FF            mov	al,-1[bp]
02969 09ED           24                     DF  and	al,#$DF
02970                                           ! Debug: logeq int = const $58 to unsigned char = al+0 (used reg = )
02971 09EF           3C                     58  cmp	al,*$58
02972 09F1           75           64            jne 	.45
02973                       000009F3            .46:
02974                                           ! 1183           if (format_width == 0)
02975                                           ! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$12] (used reg = )
02976 09F3           8B46         F0            mov	ax,-$10[bp]
02977 09F6           85C0                       test	ax,ax
02978 09F8           75           06            jne 	.47
02979                       000009FA            .48:
02980                                           ! 1184             format_width = 4;
02981                                           ! Debug: eq int = const 4 to unsigned short format_width = [S+$18-$12] (used reg = )
02982 09FA           B8                   0004  mov	ax,*4
02983 09FD           8946         F0            mov	-$10[bp],ax
02984                                           !BCC_EOS
02985                                           ! 1185           for (i=format_width-1; i>=0; i--) {
02986                       00000A00            .47:
02987                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$12] (used reg = )
02988 0A00           8B46         F0            mov	ax,-$10[bp]
02989                                           ! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
02990 0A03           48                         dec	ax
02991 0A04           8946         FA            mov	-6[bp],ax
02992                                           !BCC_EOS
02993                                           !BCC_EOS
02994 0A07           EB           44            jmp .4B
02995                       00000A09            .4C:
02996                                           ! 1186             nibble = (arg >> (4 * i)) & 0x000f;
02997                                           ! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
02998                                           ! Debug: expression subtree swapping
02999 0A09           8B46         FA            mov	ax,-6[bp]
03000 0A0C           D1E0                       shl	ax,*1
03001 0A0E           D1E0                       shl	ax,*1
03002                                           ! Debug: sr int = ax+0 to unsigned short arg = [S+$18-$C] (used reg = )
03003 0A10           89C3                       mov	bx,ax
03004 0A12           8B46         F6            mov	ax,-$A[bp]
03005 0A15           89D9                       mov	cx,bx
03006 0A17           D3E8                       shr	ax,cl
03007                                           ! Debug: and int = const $F to unsigned int = ax+0 (used reg = )
03008 0A19           24                     0F  and	al,*$F
03009                                           ! Debug: eq unsigned char = al+0 to unsigned short nibble = [S+$18-$E] (used reg = )
03010 0A1B           30E4                       xor	ah,ah
03011 0A1D           8946         F4            mov	-$C[bp],ax
03012                                           !BCC_EOS
03013                                           ! 1187             send (action, (nibble<=9)? (nibble+'0') : (nibble+c-33));
03014                                           ! Debug: le int = const 9 to unsigned short nibble = [S+$18-$E] (used reg = )
03015 0A20           8B46         F4            mov	ax,-$C[bp]
03016 0A23           3D                   0009  cmp	ax,*9
03017 0A26           77           08            ja  	.4D
03018                       00000A28            .4E:
03019                                           ! Debug: add int = const $30 to unsigned short nibble = [S+$18-$E] (used reg = )
03020 0A28           8B46         F4            mov	ax,-$C[bp]
03021 0A2B           05                   0030  add	ax,*$30
03022 0A2E           EB           0C            jmp .4F
03023                       00000A30            .4D:
03024                                           ! Debug: add unsigned char c = [S+$18-3] to unsigned short nibble = [S+$18-$E] (used reg = )
03025 0A30           8B46         F4            mov	ax,-$C[bp]
03026 0A33           0246         FF            add	al,-1[bp]
03027 0A36           80D4                   00  adc	ah,*0
03028                                           ! Debug: sub int = const $21 to unsigned int = ax+0 (used reg = )
03029 0A39           05                   FFDF  add	ax,*-$21
03030                       00000A3C            .4F:
03031                                           ! Debug: list unsigned int = ax+0 (used reg = )
03032 0A3C           50                         push	ax
03033                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03034 0A3D           FF76         04            push	4[bp]
03035                                           ! Debug: func () void = send+0 (used reg = )
03036 0A40           E8         FC48            call	_send
03037 0A43           83C4                   04  add	sp,*4
03038                                           !BCC_EOS
03039                                           ! 1188           }
03040                                           ! 1189         }
03041                       00000A46            .4A:
03042                                           ! Debug: postdec short i = [S+$18-8] (used reg = )
03043 0A46           8B46         FA            mov	ax,-6[bp]
03044 0A49           48                         dec	ax
03045 0A4A           8946         FA            mov	-6[bp],ax
03046                       00000A4D            .4B:
03047                                           ! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
03048 0A4D           8B46         FA            mov	ax,-6[bp]
03049 0A50           85C0                       test	ax,ax
03050 0A52           7D           B5            jge	.4C
03051                       00000A54            .50:
03052                       00000A54            .49:
03053                                           ! 1190         else if (c == 'u') {
03054 0A54           E9         01C8            br 	.51
03055                       00000A57            .45:
03056                                           ! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
03057 0A57           8A46         FF            mov	al,-1[bp]
03058 0A5A           3C                     75  cmp	al,*$75
03059 0A5C           75           15            jne 	.52
03060                       00000A5E            .53:
03061                                           ! 1191           put_uint(action, arg, format_width, 0);
03062                                           ! Debug: list int = const 0 (used reg = )
03063 0A5E           31C0                       xor	ax,ax
03064 0A60           50                         push	ax
03065                                           ! Debug: list unsigned short format_width = [S+$1A-$12] (used reg = )
03066 0A61           FF76         F0            push	-$10[bp]
03067                                           ! Debug: list unsigned short arg = [S+$1C-$C] (used reg = )
03068 0A64           FF76         F6            push	-$A[bp]
03069                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03070 0A67           FF76         04            push	4[bp]
03071                                           ! Debug: func () void = put_uint+0 (used reg = )
03072 0A6A           E8         FC77            call	_put_uint
03073 0A6D           83C4                   08  add	sp,*8
03074                                           !BCC_EOS
03075                                           ! 1192         }
03076                                           ! 1193         else if (c == 'l') {
03077 0A70           E9         01AC            br 	.54
03078                       00000A73            .52:
03079                                           ! Debug: logeq int = const $6C to unsigned char c = [S+$18-3] (used reg = )
03080 0A73           8A46         FF            mov	al,-1[bp]
03081 0A76           3C                     6C  cmp	al,*$6C
03082 0A78         0F85         0102            bne 	.55
03083                       00000A7C            .56:
03084                                           ! 1194           s++;
03085                                           ! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
03086 0A7C           8B5E         06            mov	bx,6[bp]
03087 0A7F           43                         inc	bx
03088 0A80           895E         06            mov	6[bp],bx
03089                                           !BCC_EOS
03090                                           ! 1195           c = *((Bit8u *)(s));
03091 0A83           8B5E         06            mov	bx,6[bp]
03092                                           ! Debug: eq unsigned char = [bx+0] to unsigned char c = [S+$18-3] (used reg = )
03093 0A86           8A07                       mov	al,[bx]
03094 0A88           8846         FF            mov	-1[bp],al
03095                                           !BCC_EOS
03096                                           ! 1196           arg_ptr++;
03097                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03098 0A8B           8B5E         F8            mov	bx,-8[bp]
03099 0A8E           43                         inc	bx
03100 0A8F           43                         inc	bx
03101 0A90           895E         F8            mov	-8[bp],bx
03102                                           !BCC_EOS
03103                                           ! 1197           *(((Bit16u *)&lval)+1) = read_word_SS(arg_ptr);
03104                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03105 0A93           FF76         F8            push	-8[bp]
03106                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
03107 0A96           E8         FB98            call	_read_word_SS
03108 0A99           44                         inc	sp
03109 0A9A           44                         inc	sp
03110                                           ! Debug: eq unsigned short = ax+0 to unsigned short lval = [S+$18-$16] (used reg = )
03111 0A9B           8946         EC            mov	-$14[bp],ax
03112                                           !BCC_EOS
03113                                           ! 1198      
03114                                           ! 1198      *((Bit16u *)&lval) = arg;
03115                                           ! Debug: eq unsigned short arg = [S+$18-$C] to unsigned short lval = [S+$18-$18] (used reg = )
03116 0A9E           8B46         F6            mov	ax,-$A[bp]
03117 0AA1           8946         EA            mov	-$16[bp],ax
03118                                           !BCC_EOS
03119                                           ! 1199           if (c == 'd') {
03120                                           ! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
03121 0AA4           8A46         FF            mov	al,-1[bp]
03122 0AA7           3C                     64  cmp	al,*$64
03123 0AA9           75           42            jne 	.57
03124                       00000AAB            .58:
03125                                           ! 1200             if (*(((Bit16u *)&lval)+1) & 0x8000)
03126                                           ! Debug: and unsigned int = const $8000 to unsigned short lval = [S+$18-$16] (used reg = )
03127 0AAB           8B46         EC            mov	ax,-$14[bp]
03128 0AAE           25                   8000  and	ax,#$8000
03129 0AB1           85C0                       test	ax,ax
03130 0AB3           74           20            je  	.59
03131                       00000AB5            .5A:
03132                                           ! 1201               put_luint(action, 0L-lval, format_width-1, 1);
03133                                           ! Debug: list int = const 1 (used reg = )
03134 0AB5           B8                   0001  mov	ax,*1
03135 0AB8           50                         push	ax
03136                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$12] (used reg = )
03137 0AB9           8B46         F0            mov	ax,-$10[bp]
03138                                           ! Debug: list unsigned int = ax-1 (used reg = )
03139 0ABC           48                         dec	ax
03140 0ABD           50                         push	ax
03141                                           ! Debug: sub unsigned long lval = [S+$1C-$18] to long = const 0 (used reg = )
03142 0ABE           31C0                       xor	ax,ax
03143 0AC0           31DB                       xor	bx,bx
03144 0AC2           8D7E         EA            lea	di,-$16[bp]
03145 0AC5           E8         F5EA            call	lsubul
03146                                           ! Debug: list unsigned long = bx+0 (used reg = )
03147 0AC8           53                         push	bx
03148 0AC9           50                         push	ax
03149                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03150 0ACA           FF76         04            push	4[bp]
03151                                           ! Debug: func () void = put_luint+0 (used reg = )
03152 0ACD           E8         FC97            call	_put_luint
03153 0AD0           83C4                   0A  add	sp,*$A
03154                                           !BCC_EOS
03155                                           ! 1202             else
03156                                           ! 1203               put_luint(action, lval, format_width, 0);
03157 0AD3           EB           15            jmp .5B
03158                       00000AD5            .59:
03159                                           ! Debug: list int = const 0 (used reg = )
03160 0AD5           31C0                       xor	ax,ax
03161 0AD7           50                         push	ax
03162                                           ! Debug: list unsigned short format_width = [S+$1A-$12] (used reg = )
03163 0AD8           FF76         F0            push	-$10[bp]
03164                                           ! Debug: list unsigned long lval = [S+$1C-$18] (used reg = )
03165 0ADB           FF76         EC            push	-$14[bp]
03166 0ADE           FF76         EA            push	-$16[bp]
03167                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03168 0AE1           FF76         04            push	4[bp]
03169                                           ! Debug: func () void = put_luint+0 (used reg = )
03170 0AE4           E8         FC80            call	_put_luint
03171 0AE7           83C4                   0A  add	sp,*$A
03172                                           !BCC_EOS
03173                                           ! 1204           }
03174                       00000AEA            .5B:
03175                                           ! 1205           else if (c == 'u') {
03176 0AEA           E9         008E            br 	.5C
03177                       00000AED            .57:
03178                                           ! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
03179 0AED           8A46         FF            mov	al,-1[bp]
03180 0AF0           3C                     75  cmp	al,*$75
03181 0AF2           75           17            jne 	.5D
03182                       00000AF4            .5E:
03183                                           ! 1206             put_luint(action, lval, format_width, 0);
03184                                           ! Debug: list int = const 0 (used reg = )
03185 0AF4           31C0                       xor	ax,ax
03186 0AF6           50                         push	ax
03187                                           ! Debug: list unsigned short format_width = [S+$1A-$12] (used reg = )
03188 0AF7           FF76         F0            push	-$10[bp]
03189                                           ! Debug: list unsigned long lval = [S+$1C-$18] (used reg = )
03190 0AFA           FF76         EC            push	-$14[bp]
03191 0AFD           FF76         EA            push	-$16[bp]
03192                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03193 0B00           FF76         04            push	4[bp]
03194                                           ! Debug: func () void = put_luint+0 (used reg = )
03195 0B03           E8         FC61            call	_put_luint
03196 0B06           83C4                   0A  add	sp,*$A
03197                                           !BCC_EOS
03198                                           ! 1207           }
03199                                           ! 1208           else if ((c & 0xdf) == 'X')
03200 0B09           EB           70            jmp .5F
03201                       00000B0B            .5D:
03202                                           ! Debug: and int = const $DF to unsigned char c = [S+$18-3] (used reg = )
03203 0B0B           8A46         FF            mov	al,-1[bp]
03204 0B0E           24                     DF  and	al,#$DF
03205                                           ! Debug: logeq int = const $58 to unsigned char = al+0 (used reg = )
03206 0B10           3C                     58  cmp	al,*$58
03207 0B12           75           67            jne 	.60
03208                       00000B14            .61:
03209                                           ! 1209           {
03210                                           ! 1210             if (format_width == 0)
03211                                           ! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$12] (used reg = )
03212 0B14           8B46         F0            mov	ax,-$10[bp]
03213 0B17           85C0                       test	ax,ax
03214 0B19           75           06            jne 	.62
03215                       00000B1B            .63:
03216                                           ! 1211               format_width = 8;
03217                                           ! Debug: eq int = const 8 to unsigned short format_width = [S+$18-$12] (used reg = )
03218 0B1B           B8                   0008  mov	ax,*8
03219 0B1E           8946         F0            mov	-$10[bp],ax
03220                                           !BCC_EOS
03221                                           ! 1212             for (i=format_width-1; i>=0; i--) {
03222                       00000B21            .62:
03223                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$12] (used reg = )
03224 0B21           8B46         F0            mov	ax,-$10[bp]
03225                                           ! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
03226 0B24           48                         dec	ax
03227 0B25           8946         FA            mov	-6[bp],ax
03228                                           !BCC_EOS
03229                                           !BCC_EOS
03230 0B28           EB           4A            jmp .66
03231                       00000B2A            .67:
03232                                           ! 1213               nibble = ((Bit16u)(lval >> (4 * i))) & 0x000f;
03233                                           ! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
03234                                           ! Debug: expression subtree swapping
03235 0B2A           8B46         FA            mov	ax,-6[bp]
03236 0B2D           D1E0                       shl	ax,*1
03237 0B2F           D1E0                       shl	ax,*1
03238                                           ! Debug: sr int = ax+0 to unsigned long lval = [S+$18-$18] (used reg = )
03239 0B31           50                         push	ax
03240 0B32           8B46         EA            mov	ax,-$16[bp]
03241 0B35           8B5E         EC            mov	bx,-$14[bp]
03242 0B38           8B7E         E8            mov	di,-$18[bp]
03243 0B3B           E8         F5BC            call	lsrul
03244 0B3E           44                         inc	sp
03245 0B3F           44                         inc	sp
03246                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
03247                                           ! Debug: and int = const $F to unsigned short = ax+0 (used reg = )
03248 0B40           24                     0F  and	al,*$F
03249                                           ! Debug: eq unsigned char = al+0 to unsigned short nibble = [S+$18-$E] (used reg = )
03250 0B42           30E4                       xor	ah,ah
03251 0B44           8946         F4            mov	-$C[bp],ax
03252                                           !BCC_EOS
03253                                           ! 1214               send (action, (nibble<=9)? (nibble+'0') : (nibble+c-33));
03254                                           ! Debug: le int = const 9 to unsigned short nibble = [S+$18-$E] (used reg = )
03255 0B47           8B46         F4            mov	ax,-$C[bp]
03256 0B4A           3D                   0009  cmp	ax,*9
03257 0B4D           77           08            ja  	.68
03258                       00000B4F            .69:
03259                                           ! Debug: add int = const $30 to unsigned short nibble = [S+$18-$E] (used reg = )
03260 0B4F           8B46         F4            mov	ax,-$C[bp]
03261 0B52           05                   0030  add	ax,*$30
03262 0B55           EB           0C            jmp .6A
03263                       00000B57            .68:
03264                                           ! Debug: add unsigned char c = [S+$18-3] to unsigned short nibble = [S+$18-$E] (used reg = )
03265 0B57           8B46         F4            mov	ax,-$C[bp]
03266 0B5A           0246         FF            add	al,-1[bp]
03267 0B5D           80D4                   00  adc	ah,*0
03268                                           ! Debug: sub int = const $21 to unsigned int = ax+0 (used reg = )
03269 0B60           05                   FFDF  add	ax,*-$21
03270                       00000B63            .6A:
03271                                           ! Debug: list unsigned int = ax+0 (used reg = )
03272 0B63           50                         push	ax
03273                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03274 0B64           FF76         04            push	4[bp]
03275                                           ! Debug: func () void = send+0 (used reg = )
03276 0B67           E8         FB21            call	_send
03277 0B6A           83C4                   04  add	sp,*4
03278                                           !BCC_EOS
03279                                           ! 1215             }
03280                                           ! 1216           }
03281                       00000B6D            .65:
03282                                           ! Debug: postdec short i = [S+$18-8] (used reg = )
03283 0B6D           8B46         FA            mov	ax,-6[bp]
03284 0B70           48                         dec	ax
03285 0B71           8946         FA            mov	-6[bp],ax
03286                       00000B74            .66:
03287                                           ! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
03288 0B74           8B46         FA            mov	ax,-6[bp]
03289 0B77           85C0                       test	ax,ax
03290 0B79           7D           AF            jge	.67
03291                       00000B7B            .6B:
03292                       00000B7B            .64:
03293                                           ! 1217         }
03294                       00000B7B            .60:
03295                       00000B7B            .5F:
03296                       00000B7B            .5C:
03297                                           ! 1218         else if (c == 'd') {
03298 0B7B           E9         00A1            br 	.6C
03299                       00000B7E            .55:
03300                                           ! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
03301 0B7E           8A46         FF            mov	al,-1[bp]
03302 0B81           3C                     64  cmp	al,*$64
03303 0B83           75           38            jne 	.6D
03304                       00000B85            .6E:
03305                                           ! 1219           if (arg & 0x8000)
03306                                           ! Debug: and unsigned int = const $8000 to unsigned short arg = [S+$18-$C] (used reg = )
03307 0B85           8B46         F6            mov	ax,-$A[bp]
03308 0B88           25                   8000  and	ax,#$8000
03309 0B8B           85C0                       test	ax,ax
03310 0B8D           74           1A            je  	.6F
03311                       00000B8F            .70:
03312                                           ! 1220             put_uint(action, -arg, format_width - 1, 1);
03313                                           ! Debug: list int = const 1 (used reg = )
03314 0B8F           B8                   0001  mov	ax,*1
03315 0B92           50                         push	ax
03316                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$12] (used reg = )
03317 0B93           8B46         F0            mov	ax,-$10[bp]
03318                                           ! Debug: list unsigned int = ax-1 (used reg = )
03319 0B96           48                         dec	ax
03320 0B97           50                         push	ax
03321                                           ! Debug: neg unsigned short arg = [S+$1C-$C] (used reg = )
03322 0B98           31C0                       xor	ax,ax
03323 0B9A           2B46         F6            sub	ax,-$A[bp]
03324                                           ! Debug: list unsigned int = ax+0 (used reg = )
03325 0B9D           50                         push	ax
03326                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03327 0B9E           FF76         04            push	4[bp]
03328                                           ! Debug: func () void = put_uint+0 (used reg = )
03329 0BA1           E8         FB40            call	_put_uint
03330 0BA4           83C4                   08  add	sp,*8
03331                                           !BCC_EOS
03332                                           ! 1221           else
03333                                           ! 1222             put_uint(action, arg, format_width, 0);
03334 0BA7           EB           12            jmp .71
03335                       00000BA9            .6F:
03336                                           ! Debug: list int = const 0 (used reg = )
03337 0BA9           31C0                       xor	ax,ax
03338 0BAB           50                         push	ax
03339                                           ! Debug: list unsigned short format_width = [S+$1A-$12] (used reg = )
03340 0BAC           FF76         F0            push	-$10[bp]
03341                                           ! Debug: list unsigned short arg = [S+$1C-$C] (used reg = )
03342 0BAF           FF76         F6            push	-$A[bp]
03343                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03344 0BB2           FF76         04            push	4[bp]
03345                                           ! Debug: func () void = put_uint+0 (used reg = )
03346 0BB5           E8         FB2C            call	_put_uint
03347 0BB8           83C4                   08  add	sp,*8
03348                                           !BCC_EOS
03349                                           ! 1223         }
03350                       00000BBB            .71:
03351                                           ! 1224         else if (c == 's') {
03352 0BBB           EB           62            jmp .72
03353                       00000BBD            .6D:
03354                                           ! Debug: logeq int = const $73 to unsigned char c = [S+$18-3] (used reg = )
03355 0BBD           8A46         FF            mov	al,-1[bp]
03356 0BC0           3C                     73  cmp	al,*$73
03357 0BC2           75           12            jne 	.73
03358                       00000BC4            .74:
03359                                           ! 1225           put_str(action, get_CS(), arg);
03360                                           ! Debug: list unsigned short arg = [S+$18-$C] (used reg = )
03361 0BC4           FF76         F6            push	-$A[bp]
03362                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03363 0BC7           E8         FA92            call	_get_CS
03364                                           ! Debug: list unsigned short = ax+0 (used reg = )
03365 0BCA           50                         push	ax
03366                                           ! Debug: list unsigned short action = [S+$1C+2] (used reg = )
03367 0BCB           FF76         04            push	4[bp]
03368                                           ! Debug: func () void = put_str+0 (used reg = )
03369 0BCE           E8         FC4D            call	_put_str
03370 0BD1           83C4                   06  add	sp,*6
03371                                           !BCC_EOS
03372                                           ! 1226         }
03373                                           ! 1227         else if (c == 'S') {
03374 0BD4           EB           49            jmp .75
03375                       00000BD6            .73:
03376                                           ! Debug: logeq int = const $53 to unsigned char c = [S+$18-3] (used reg = )
03377 0BD6           8A46         FF            mov	al,-1[bp]
03378 0BD9           3C                     53  cmp	al,*$53
03379 0BDB           75           1F            jne 	.76
03380                       00000BDD            .77:
03381                                           ! 1228           arg_ptr++;
03382                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03383 0BDD           8B5E         F8            mov	bx,-8[bp]
03384 0BE0           43                         inc	bx
03385 0BE1           43                         inc	bx
03386 0BE2           895E         F8            mov	-8[bp],bx
03387                                           !BCC_EOS
03388                                           ! 1229           put_str(action, arg, read_word_SS(arg_ptr));
03389                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03390 0BE5           FF76         F8            push	-8[bp]
03391                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
03392 0BE8           E8         FA46            call	_read_word_SS
03393 0BEB           44                         inc	sp
03394 0BEC           44                         inc	sp
03395                                           ! Debug: list unsigned short = ax+0 (used reg = )
03396 0BED           50                         push	ax
03397                                           ! Debug: list unsigned short arg = [S+$1A-$C] (used reg = )
03398 0BEE           FF76         F6            push	-$A[bp]
03399                                           ! Debug: list unsigned short action = [S+$1C+2] (used reg = )
03400 0BF1           FF76         04            push	4[bp]
03401                                           ! Debug: func () void = put_str+0 (used reg = )
03402 0BF4           E8         FC27            call	_put_str
03403 0BF7           83C4                   06  add	sp,*6
03404                                           !BCC_EOS
03405                                           ! 1230         }
03406                                           ! 1231         else if (c == 'c') {
03407 0BFA           EB           23            jmp .78
03408                       00000BFC            .76:
03409                                           ! Debug: logeq int = const $63 to unsigned char c = [S+$18-3] (used reg = )
03410 0BFC           8A46         FF            mov	al,-1[bp]
03411 0BFF           3C                     63  cmp	al,*$63
03412 0C01           75           0E            jne 	.79
03413                       00000C03            .7A:
03414                                           ! 1232           send(action, arg);
03415                                           ! Debug: list unsigned short arg = [S+$18-$C] (used reg = )
03416 0C03           FF76         F6            push	-$A[bp]
03417                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03418 0C06           FF76         04            push	4[bp]
03419                                           ! Debug: func () void = send+0 (used reg = )
03420 0C09           E8         FA7F            call	_send
03421 0C0C           83C4                   04  add	sp,*4
03422                                           !BCC_EOS
03423                                           ! 1233         }
03424                                           ! 1234         else
03425                                           ! 1235           bios_printf((2 | 4 | 1), "bios_printf: unknown format\n");
03426 0C0F           EB           0E            jmp .7B
03427                       00000C11            .79:
03428                                           ! Debug: list * char = .7C+0 (used reg = )
03429 0C11           BB                   D9F3  mov	bx,#.7C
03430 0C14           53                         push	bx
03431                                           ! Debug: list int = const 7 (used reg = )
03432 0C15           B8                   0007  mov	ax,*7
03433 0C18           50                         push	ax
03434                                           ! Debug: func () void = bios_printf+0 (used reg = )
03435 0C19           E8         FD22            call	_bios_printf
03436 0C1C           83C4                   04  add	sp,*4
03437                                           !BCC_EOS
03438                                           ! 1236           in_format = 0;
03439                       00000C1F            .7B:
03440                       00000C1F            .78:
03441                       00000C1F            .75:
03442                       00000C1F            .72:
03443                       00000C1F            .6C:
03444                       00000C1F            .54:
03445                       00000C1F            .51:
03446                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
03447 0C1F           31C0                       xor	ax,ax
03448 0C21           8946         FC            mov	-4[bp],ax
03449                                           !BCC_EOS
03450                                           ! 1237       }
03451                                           ! 1238     }
03452                       00000C24            .44:
03453                                           ! 1239     else {
03454 0C24           EB           0F            jmp .7D
03455                       00000C26            .3F:
03456                                           ! 1240       send(action, c);
03457                                           ! Debug: list unsigned char c = [S+$18-3] (used reg = )
03458 0C26           8A46         FF            mov	al,-1[bp]
03459 0C29           30E4                       xor	ah,ah
03460 0C2B           50                         push	ax
03461                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03462 0C2C           FF76         04            push	4[bp]
03463                                           ! Debug: func () void = send+0 (used reg = )
03464 0C2F           E8         FA59            call	_send
03465 0C32           83C4                   04  add	sp,*4
03466                                           !BCC_EOS
03467                                           ! 1241     }
03468                                           ! 1242     s ++;
03469                       00000C35            .7D:
03470                       00000C35            .3E:
03471                                           ! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
03472 0C35           8B5E         06            mov	bx,6[bp]
03473 0C38           43                         inc	bx
03474 0C39           895E         06            mov	6[bp],bx
03475                                           !BCC_EOS
03476                                           ! 1243   }
03477                                           ! 1244   if (action & 1) {
03478                       00000C3C            .3A:
03479 0C3C           8B5E         06            mov	bx,6[bp]
03480                                           ! Debug: eq unsigned char = [bx+0] to unsigned char c = [S+$18-3] (used reg = )
03481 0C3F           8A07                       mov	al,[bx]
03482 0C41           8846         FF            mov	-1[bp],al
03483 0C44           84C0                       test	al,al
03484 0C46         0F85         FD40            bne 	.3B
03485                       00000C4A            .7E:
03486                       00000C4A            .39:
03487                                           ! Debug: and int = const 1 to unsigned short action = [S+$18+2] (used reg = )
03488 0C4A           8A46         04            mov	al,4[bp]
03489 0C4D           24                     01  and	al,*1
03490 0C4F           84C0                       test	al,al
03491 0C51           74           04            je  	.7F
03492                       00000C53            .80:
03493                                           ! 1245 #asm
03494                                           !BCC_EOS
03495                                           !BCC_ASM
03496                       00000006            _bios_printf.format_width	set	6
03497                       FFFFFFF0            .bios_printf.format_width	set	-$10
03498                       00000014            _bios_printf.format_char	set	$14
03499                       FFFFFFFE            .bios_printf.format_char	set	-2
03500                       0000000E            _bios_printf.arg_ptr	set	$E
03501                       FFFFFFF8            .bios_printf.arg_ptr	set	-8
03502                       0000001A            _bios_printf.action	set	$1A
03503                       00000004            .bios_printf.action	set	4
03504                       00000010            _bios_printf.i	set	$10
03505                       FFFFFFFA            .bios_printf.i	set	-6
03506                       00000008            _bios_printf.shift_count	set	8
03507                       FFFFFFF2            .bios_printf.shift_count	set	-$E
03508                       00000012            _bios_printf.in_format	set	$12
03509                       FFFFFFFC            .bios_printf.in_format	set	-4
03510                       0000001C            _bios_printf.s	set	$1C
03511                       00000006            .bios_printf.s	set	6
03512                       00000000            _bios_printf.lval	set	0
03513                       FFFFFFEA            .bios_printf.lval	set	-$16
03514                       0000000A            _bios_printf.nibble	set	$A
03515                       FFFFFFF4            .bios_printf.nibble	set	-$C
03516                       00000015            _bios_printf.c	set	$15
03517                       FFFFFFFF            .bios_printf.c	set	-1
03518                       0000000C            _bios_printf.arg	set	$C
03519                       FFFFFFF6            .bios_printf.arg	set	-$A
03520                       00000004            _bios_printf.old_ds	set	4
03521                       FFFFFFEE            .bios_printf.old_ds	set	-$12
03522 0C53           FA                             cli
03523                       00000C54             halt2_loop:
03524 0C54           F4                             hlt
03525 0C55           EB           FD                jmp halt2_loop
03526                                           ! 1250 endasm
03527                                           !BCC_ENDASM
03528                                           !BCC_EOS
03529                                           ! 1251   }
03530                                           ! 1252   set_DS(old_ds);
03531                       00000C57            .7F:
03532                                           ! Debug: list unsigned short old_ds = [S+$18-$14] (used reg = )
03533 0C57           FF76         EE            push	-$12[bp]
03534                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
03535 0C5A           E8         FA05            call	_set_DS
03536 0C5D           44                         inc	sp
03537 0C5E           44                         inc	sp
03538                                           !BCC_EOS
03539                                           ! 1253 }
03540 0C5F           89EC                       mov	sp,bp
03541 0C61           5D                         pop	bp
03542 0C62           C3                         ret
03543                                           ! 1254   void
03544                                           ! Register BX used in function bios_printf
03545                                           ! 1255 keyboard_init()
03546                                           ! 1256 {
03547                                           export	_keyboard_init
03548                       00000C63            _keyboard_init:
03549                                           ! 1257     Bit16u max;
03550                                           !BCC_EOS
03551                                           ! 1258     max=0xffff;
03552 0C63           55                         push	bp
03553 0C64           89E5                       mov	bp,sp
03554 0C66           4C                         dec	sp
03555 0C67           4C                         dec	sp
03556                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03557 0C68           B8                   FFFF  mov	ax,#$FFFF
03558 0C6B           8946         FE            mov	-2[bp],ax
03559                                           !BCC_EOS
03560                                           ! 1259     while ( (inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x00);
03561 0C6E           EB           0D            jmp .82
03562                       00000C70            .83:
03563                                           ! Debug: list int = const 0 (used reg = )
03564 0C70           31C0                       xor	ax,ax
03565 0C72           50                         push	ax
03566                                           ! Debug: list int = const $80 (used reg = )
03567 0C73           B8                   0080  mov	ax,#$80
03568 0C76           50                         push	ax
03569                                           ! Debug: func () void = outb+0 (used reg = )
03570 0C77           E8         F894            call	_outb
03571 0C7A           83C4                   04  add	sp,*4
03572                                           !BCC_EOS
03573                                           ! 1260     max=0x2000;
03574                       00000C7D            .82:
03575                                           ! Debug: list int = const $64 (used reg = )
03576 0C7D           B8                   0064  mov	ax,*$64
03577 0C80           50                         push	ax
03578                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03579 0C81           E8         F874            call	_inb
03580 0C84           44                         inc	sp
03581 0C85           44                         inc	sp
03582                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03583 0C86           24                     02  and	al,*2
03584 0C88           84C0                       test	al,al
03585 0C8A           74           0B            je  	.84
03586                       00000C8C            .85:
03587                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03588 0C8C           8B46         FE            mov	ax,-2[bp]
03589 0C8F           48                         dec	ax
03590 0C90           8946         FE            mov	-2[bp],ax
03591                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03592 0C93           85C0                       test	ax,ax
03593 0C95           75           D9            jne	.83
03594                       00000C97            .84:
03595                       00000C97            .81:
03596                                           ! Debug: eq int = const $2000 to unsigned short max = [S+4-4] (used reg = )
03597 0C97           B8                   2000  mov	ax,#$2000
03598 0C9A           8946         FE            mov	-2[bp],ax
03599                                           !BCC_EOS
03600                                           ! 1261     while (--max > 0) {
03601 0C9D           EB           2B            jmp .87
03602                       00000C9F            .88:
03603                                           ! 1262         outb(0x0080, 0x00);
03604                                           ! Debug: list int = const 0 (used reg = )
03605 0C9F           31C0                       xor	ax,ax
03606 0CA1           50                         push	ax
03607                                           ! Debug: list int = const $80 (used reg = )
03608 0CA2           B8                   0080  mov	ax,#$80
03609 0CA5           50                         push	ax
03610                                           ! Debug: func () void = outb+0 (used reg = )
03611 0CA6           E8         F865            call	_outb
03612 0CA9           83C4                   04  add	sp,*4
03613                                           !BCC_EOS
03614                                           ! 1263         if (inb(0x0064) & 0x01) {
03615                                           ! Debug: list int = const $64 (used reg = )
03616 0CAC           B8                   0064  mov	ax,*$64
03617 0CAF           50                         push	ax
03618                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03619 0CB0           E8         F845            call	_inb
03620 0CB3           44                         inc	sp
03621 0CB4           44                         inc	sp
03622                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03623 0CB5           24                     01  and	al,*1
03624 0CB7           84C0                       test	al,al
03625 0CB9           74           0F            je  	.89
03626                       00000CBB            .8A:
03627                                           ! 1264             inb(0x0060);
03628                                           ! Debug: list int = const $60 (used reg = )
03629 0CBB           B8                   0060  mov	ax,*$60
03630 0CBE           50                         push	ax
03631                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03632 0CBF           E8         F836            call	_inb
03633 0CC2           44                         inc	sp
03634 0CC3           44                         inc	sp
03635                                           !BCC_EOS
03636                                           ! 1265             max = 0x2000;
03637                                           ! Debug: eq int = const $2000 to unsigned short max = [S+4-4] (used reg = )
03638 0CC4           B8                   2000  mov	ax,#$2000
03639 0CC7           8946         FE            mov	-2[bp],ax
03640                                           !BCC_EOS
03641                                           ! 1266         }
03642                                           ! 1267     }
03643                       00000CCA            .89:
03644                                           ! 1268     outb(0x0064, 0xaa);
03645                       00000CCA            .87:
03646                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03647 0CCA           8B46         FE            mov	ax,-2[bp]
03648 0CCD           48                         dec	ax
03649 0CCE           8946         FE            mov	-2[bp],ax
03650                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03651 0CD1           85C0                       test	ax,ax
03652 0CD3           75           CA            jne	.88
03653                       00000CD5            .8B:
03654                       00000CD5            .86:
03655                                           ! Debug: list int = const $AA (used reg = )
03656 0CD5           B8                   00AA  mov	ax,#$AA
03657 0CD8           50                         push	ax
03658                                           ! Debug: list int = const $64 (used reg = )
03659 0CD9           B8                   0064  mov	ax,*$64
03660 0CDC           50                         push	ax
03661                                           ! Debug: func () void = outb+0 (used reg = )
03662 0CDD           E8         F82E            call	_outb
03663 0CE0           83C4                   04  add	sp,*4
03664                                           !BCC_EOS
03665                                           ! 1269     max=0xffff;
03666                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03667 0CE3           B8                   FFFF  mov	ax,#$FFFF
03668 0CE6           8946         FE            mov	-2[bp],ax
03669                                           !BCC_EOS
03670                                           ! 1270     while ( (inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x00);
03671 0CE9           EB           0D            jmp .8D
03672                       00000CEB            .8E:
03673                                           ! Debug: list int = const 0 (used reg = )
03674 0CEB           31C0                       xor	ax,ax
03675 0CED           50                         push	ax
03676                                           ! Debug: list int = const $80 (used reg = )
03677 0CEE           B8                   0080  mov	ax,#$80
03678 0CF1           50                         push	ax
03679                                           ! Debug: func () void = outb+0 (used reg = )
03680 0CF2           E8         F819            call	_outb
03681 0CF5           83C4                   04  add	sp,*4
03682                                           !BCC_EOS
03683                                           ! 1271     if (max==0x0) keyboard_panic(00);
03684                       00000CF8            .8D:
03685                                           ! Debug: list int = const $64 (used reg = )
03686 0CF8           B8                   0064  mov	ax,*$64
03687 0CFB           50                         push	ax
03688                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03689 0CFC           E8         F7F9            call	_inb
03690 0CFF           44                         inc	sp
03691 0D00           44                         inc	sp
03692                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03693 0D01           24                     02  and	al,*2
03694 0D03           84C0                       test	al,al
03695 0D05           74           0B            je  	.8F
03696                       00000D07            .90:
03697                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03698 0D07           8B46         FE            mov	ax,-2[bp]
03699 0D0A           48                         dec	ax
03700 0D0B           8946         FE            mov	-2[bp],ax
03701                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03702 0D0E           85C0                       test	ax,ax
03703 0D10           75           D9            jne	.8E
03704                       00000D12            .8F:
03705                       00000D12            .8C:
03706                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03707 0D12           8B46         FE            mov	ax,-2[bp]
03708 0D15           85C0                       test	ax,ax
03709 0D17           75           08            jne 	.91
03710                       00000D19            .92:
03711                                           ! Debug: list int = const 0 (used reg = )
03712 0D19           31C0                       xor	ax,ax
03713 0D1B           50                         push	ax
03714                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03715 0D1C           E8         048A            call	_keyboard_panic
03716 0D1F           44                         inc	sp
03717 0D20           44                         inc	sp
03718                                           !BCC_EOS
03719                                           ! 1272     max=0xffff;
03720                       00000D21            .91:
03721                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03722 0D21           B8                   FFFF  mov	ax,#$FFFF
03723 0D24           8946         FE            mov	-2[bp],ax
03724                                           !BCC_EOS
03725                                           ! 1273     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x01);
03726 0D27           EB           0E            jmp .94
03727                       00000D29            .95:
03728                                           ! Debug: list int = const 1 (used reg = )
03729 0D29           B8                   0001  mov	ax,*1
03730 0D2C           50                         push	ax
03731                                           ! Debug: list int = const $80 (used reg = )
03732 0D2D           B8                   0080  mov	ax,#$80
03733 0D30           50                         push	ax
03734                                           ! Debug: func () void = outb+0 (used reg = )
03735 0D31           E8         F7DA            call	_outb
03736 0D34           83C4                   04  add	sp,*4
03737                                           !BCC_EOS
03738                                           ! 1274     if (max==0x0) keyboard_panic(01);
03739                       00000D37            .94:
03740                                           ! Debug: list int = const $64 (used reg = )
03741 0D37           B8                   0064  mov	ax,*$64
03742 0D3A           50                         push	ax
03743                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03744 0D3B           E8         F7BA            call	_inb
03745 0D3E           44                         inc	sp
03746 0D3F           44                         inc	sp
03747                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03748 0D40           24                     01  and	al,*1
03749                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03750 0D42           84C0                       test	al,al
03751 0D44           75           0B            jne 	.96
03752                       00000D46            .97:
03753                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03754 0D46           8B46         FE            mov	ax,-2[bp]
03755 0D49           48                         dec	ax
03756 0D4A           8946         FE            mov	-2[bp],ax
03757                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03758 0D4D           85C0                       test	ax,ax
03759 0D4F           75           D8            jne	.95
03760                       00000D51            .96:
03761                       00000D51            .93:
03762                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03763 0D51           8B46         FE            mov	ax,-2[bp]
03764 0D54           85C0                       test	ax,ax
03765 0D56           75           09            jne 	.98
03766                       00000D58            .99:
03767                                           ! Debug: list int = const 1 (used reg = )
03768 0D58           B8                   0001  mov	ax,*1
03769 0D5B           50                         push	ax
03770                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03771 0D5C           E8         044A            call	_keyboard_panic
03772 0D5F           44                         inc	sp
03773 0D60           44                         inc	sp
03774                                           !BCC_EOS
03775                                           ! 1275     if ((inb(0x0060) != 0x55)){
03776                       00000D61            .98:
03777                                           ! Debug: list int = const $60 (used reg = )
03778 0D61           B8                   0060  mov	ax,*$60
03779 0D64           50                         push	ax
03780                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03781 0D65           E8         F790            call	_inb
03782 0D68           44                         inc	sp
03783 0D69           44                         inc	sp
03784                                           ! Debug: ne int = const $55 to unsigned char = al+0 (used reg = )
03785 0D6A           3C                     55  cmp	al,*$55
03786 0D6C           74           09            je  	.9A
03787                       00000D6E            .9B:
03788                                           ! 1276         keyboard_panic(991);
03789                                           ! Debug: list int = const $3DF (used reg = )
03790 0D6E           B8                   03DF  mov	ax,#$3DF
03791 0D71           50                         push	ax
03792                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03793 0D72           E8         0434            call	_keyboard_panic
03794 0D75           44                         inc	sp
03795 0D76           44                         inc	sp
03796                                           !BCC_EOS
03797                                           ! 1277   
03798                                           ! 1277   }
03799                                           ! 1278     outb(0x0064,0xab);
03800                       00000D77            .9A:
03801                                           ! Debug: list int = const $AB (used reg = )
03802 0D77           B8                   00AB  mov	ax,#$AB
03803 0D7A           50                         push	ax
03804                                           ! Debug: list int = const $64 (used reg = )
03805 0D7B           B8                   0064  mov	ax,*$64
03806 0D7E           50                         push	ax
03807                                           ! Debug: func () void = outb+0 (used reg = )
03808 0D7F           E8         F78C            call	_outb
03809 0D82           83C4                   04  add	sp,*4
03810                                           !BCC_EOS
03811                                           ! 1279     max=0xffff;
03812                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03813 0D85           B8                   FFFF  mov	ax,#$FFFF
03814 0D88           8946         FE            mov	-2[bp],ax
03815                                           !BCC_EOS
03816                                           ! 1280     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x10);
03817 0D8B           EB           0E            jmp .9D
03818                       00000D8D            .9E:
03819                                           ! Debug: list int = const $10 (used reg = )
03820 0D8D           B8                   0010  mov	ax,*$10
03821 0D90           50                         push	ax
03822                                           ! Debug: list int = const $80 (used reg = )
03823 0D91           B8                   0080  mov	ax,#$80
03824 0D94           50                         push	ax
03825                                           ! Debug: func () void = outb+0 (used reg = )
03826 0D95           E8         F776            call	_outb
03827 0D98           83C4                   04  add	sp,*4
03828                                           !BCC_EOS
03829                                           ! 1281     if (max==0x0) keyboard_panic(10);
03830                       00000D9B            .9D:
03831                                           ! Debug: list int = const $64 (used reg = )
03832 0D9B           B8                   0064  mov	ax,*$64
03833 0D9E           50                         push	ax
03834                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03835 0D9F           E8         F756            call	_inb
03836 0DA2           44                         inc	sp
03837 0DA3           44                         inc	sp
03838                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03839 0DA4           24                     02  and	al,*2
03840 0DA6           84C0                       test	al,al
03841 0DA8           74           0B            je  	.9F
03842                       00000DAA            .A0:
03843                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03844 0DAA           8B46         FE            mov	ax,-2[bp]
03845 0DAD           48                         dec	ax
03846 0DAE           8946         FE            mov	-2[bp],ax
03847                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03848 0DB1           85C0                       test	ax,ax
03849 0DB3           75           D8            jne	.9E
03850                       00000DB5            .9F:
03851                       00000DB5            .9C:
03852                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03853 0DB5           8B46         FE            mov	ax,-2[bp]
03854 0DB8           85C0                       test	ax,ax
03855 0DBA           75           09            jne 	.A1
03856                       00000DBC            .A2:
03857                                           ! Debug: list int = const $A (used reg = )
03858 0DBC           B8                   000A  mov	ax,*$A
03859 0DBF           50                         push	ax
03860                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03861 0DC0           E8         03E6            call	_keyboard_panic
03862 0DC3           44                         inc	sp
03863 0DC4           44                         inc	sp
03864                                           !BCC_EOS
03865                                           ! 1282     max=0xffff;
03866                       00000DC5            .A1:
03867                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03868 0DC5           B8                   FFFF  mov	ax,#$FFFF
03869 0DC8           8946         FE            mov	-2[bp],ax
03870                                           !BCC_EOS
03871                                           ! 1283     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x11);
03872 0DCB           EB           0E            jmp .A4
03873                       00000DCD            .A5:
03874                                           ! Debug: list int = const $11 (used reg = )
03875 0DCD           B8                   0011  mov	ax,*$11
03876 0DD0           50                         push	ax
03877                                           ! Debug: list int = const $80 (used reg = )
03878 0DD1           B8                   0080  mov	ax,#$80
03879 0DD4           50                         push	ax
03880                                           ! Debug: func () void = outb+0 (used reg = )
03881 0DD5           E8         F736            call	_outb
03882 0DD8           83C4                   04  add	sp,*4
03883                                           !BCC_EOS
03884                                           ! 1284     if (max==0x0) keyboard_panic(11);
03885                       00000DDB            .A4:
03886                                           ! Debug: list int = const $64 (used reg = )
03887 0DDB           B8                   0064  mov	ax,*$64
03888 0DDE           50                         push	ax
03889                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03890 0DDF           E8         F716            call	_inb
03891 0DE2           44                         inc	sp
03892 0DE3           44                         inc	sp
03893                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03894 0DE4           24                     01  and	al,*1
03895                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03896 0DE6           84C0                       test	al,al
03897 0DE8           75           0B            jne 	.A6
03898                       00000DEA            .A7:
03899                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03900 0DEA           8B46         FE            mov	ax,-2[bp]
03901 0DED           48                         dec	ax
03902 0DEE           8946         FE            mov	-2[bp],ax
03903                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03904 0DF1           85C0                       test	ax,ax
03905 0DF3           75           D8            jne	.A5
03906                       00000DF5            .A6:
03907                       00000DF5            .A3:
03908                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03909 0DF5           8B46         FE            mov	ax,-2[bp]
03910 0DF8           85C0                       test	ax,ax
03911 0DFA           75           09            jne 	.A8
03912                       00000DFC            .A9:
03913                                           ! Debug: list int = const $B (used reg = )
03914 0DFC           B8                   000B  mov	ax,*$B
03915 0DFF           50                         push	ax
03916                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03917 0E00           E8         03A6            call	_keyboard_panic
03918 0E03           44                         inc	sp
03919 0E04           44                         inc	sp
03920                                           !BCC_EOS
03921                                           ! 1285     if ((inb(0x0060) != 0x00)) {
03922                       00000E05            .A8:
03923                                           ! Debug: list int = const $60 (used reg = )
03924 0E05           B8                   0060  mov	ax,*$60
03925 0E08           50                         push	ax
03926                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03927 0E09           E8         F6EC            call	_inb
03928 0E0C           44                         inc	sp
03929 0E0D           44                         inc	sp
03930                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
03931 0E0E           84C0                       test	al,al
03932 0E10           74           09            je  	.AA
03933                       00000E12            .AB:
03934                                           ! 1286         keyboard_panic(992);
03935                                           ! Debug: list int = const $3E0 (used reg = )
03936 0E12           B8                   03E0  mov	ax,#$3E0
03937 0E15           50                         push	ax
03938                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03939 0E16           E8         0390            call	_keyboard_panic
03940 0E19           44                         inc	sp
03941 0E1A           44                         inc	sp
03942                                           !BCC_EOS
03943                                           ! 1287     }
03944                                           ! 1288     outb(0x0064,0xae);
03945                       00000E1B            .AA:
03946                                           ! Debug: list int = const $AE (used reg = )
03947 0E1B           B8                   00AE  mov	ax,#$AE
03948 0E1E           50                         push	ax
03949                                           ! Debug: list int = const $64 (used reg = )
03950 0E1F           B8                   0064  mov	ax,*$64
03951 0E22           50                         push	ax
03952                                           ! Debug: func () void = outb+0 (used reg = )
03953 0E23           E8         F6E8            call	_outb
03954 0E26           83C4                   04  add	sp,*4
03955                                           !BCC_EOS
03956                                           ! 1289     max=0xffff;
03957                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03958 0E29           B8                   FFFF  mov	ax,#$FFFF
03959 0E2C           8946         FE            mov	-2[bp],ax
03960                                           !BCC_EOS
03961                                           ! 1290     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x10);
03962 0E2F           EB           0E            jmp .AD
03963                       00000E31            .AE:
03964                                           ! Debug: list int = const $10 (used reg = )
03965 0E31           B8                   0010  mov	ax,*$10
03966 0E34           50                         push	ax
03967                                           ! Debug: list int = const $80 (used reg = )
03968 0E35           B8                   0080  mov	ax,#$80
03969 0E38           50                         push	ax
03970                                           ! Debug: func () void = outb+0 (used reg = )
03971 0E39           E8         F6D2            call	_outb
03972 0E3C           83C4                   04  add	sp,*4
03973                                           !BCC_EOS
03974                                           ! 1291     if (max==0x0) keyboard_panic(10);
03975                       00000E3F            .AD:
03976                                           ! Debug: list int = const $64 (used reg = )
03977 0E3F           B8                   0064  mov	ax,*$64
03978 0E42           50                         push	ax
03979                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03980 0E43           E8         F6B2            call	_inb
03981 0E46           44                         inc	sp
03982 0E47           44                         inc	sp
03983                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03984 0E48           24                     02  and	al,*2
03985 0E4A           84C0                       test	al,al
03986 0E4C           74           0B            je  	.AF
03987                       00000E4E            .B0:
03988                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03989 0E4E           8B46         FE            mov	ax,-2[bp]
03990 0E51           48                         dec	ax
03991 0E52           8946         FE            mov	-2[bp],ax
03992                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03993 0E55           85C0                       test	ax,ax
03994 0E57           75           D8            jne	.AE
03995                       00000E59            .AF:
03996                       00000E59            .AC:
03997                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03998 0E59           8B46         FE            mov	ax,-2[bp]
03999 0E5C           85C0                       test	ax,ax
04000 0E5E           75           09            jne 	.B1
04001                       00000E60            .B2:
04002                                           ! Debug: list int = const $A (used reg = )
04003 0E60           B8                   000A  mov	ax,*$A
04004 0E63           50                         push	ax
04005                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04006 0E64           E8         0342            call	_keyboard_panic
04007 0E67           44                         inc	sp
04008 0E68           44                         inc	sp
04009                                           !BCC_EOS
04010                                           ! 1292     outb(0x0064,0xa8);
04011                       00000E69            .B1:
04012                                           ! Debug: list int = const $A8 (used reg = )
04013 0E69           B8                   00A8  mov	ax,#$A8
04014 0E6C           50                         push	ax
04015                                           ! Debug: list int = const $64 (used reg = )
04016 0E6D           B8                   0064  mov	ax,*$64
04017 0E70           50                         push	ax
04018                                           ! Debug: func () void = outb+0 (used reg = )
04019 0E71           E8         F69A            call	_outb
04020 0E74           83C4                   04  add	sp,*4
04021                                           !BCC_EOS
04022                                           ! 1293     max=0xffff;
04023                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04024 0E77           B8                   FFFF  mov	ax,#$FFFF
04025 0E7A           8946         FE            mov	-2[bp],ax
04026                                           !BCC_EOS
04027                                           ! 1294     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x10);
04028 0E7D           EB           0E            jmp .B4
04029                       00000E7F            .B5:
04030                                           ! Debug: list int = const $10 (used reg = )
04031 0E7F           B8                   0010  mov	ax,*$10
04032 0E82           50                         push	ax
04033                                           ! Debug: list int = const $80 (used reg = )
04034 0E83           B8                   0080  mov	ax,#$80
04035 0E86           50                         push	ax
04036                                           ! Debug: func () void = outb+0 (used reg = )
04037 0E87           E8         F684            call	_outb
04038 0E8A           83C4                   04  add	sp,*4
04039                                           !BCC_EOS
04040                                           ! 1295     if (max==0x0) keyboard_panic(10);
04041                       00000E8D            .B4:
04042                                           ! Debug: list int = const $64 (used reg = )
04043 0E8D           B8                   0064  mov	ax,*$64
04044 0E90           50                         push	ax
04045                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04046 0E91           E8         F664            call	_inb
04047 0E94           44                         inc	sp
04048 0E95           44                         inc	sp
04049                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04050 0E96           24                     02  and	al,*2
04051 0E98           84C0                       test	al,al
04052 0E9A         0F84         000B            beq 	.B6
04053                       00000E9E            .B7:
04054                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04055 0E9E           8B46         FE            mov	ax,-2[bp]
04056 0EA1           48                         dec	ax
04057 0EA2           8946         FE            mov	-2[bp],ax
04058                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04059 0EA5           85C0                       test	ax,ax
04060 0EA7           75           D6            jne	.B5
04061                       00000EA9            .B6:
04062                       00000EA9            .B3:
04063                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04064 0EA9           8B46         FE            mov	ax,-2[bp]
04065 0EAC           85C0                       test	ax,ax
04066 0EAE           75           09            jne 	.B8
04067                       00000EB0            .B9:
04068                                           ! Debug: list int = const $A (used reg = )
04069 0EB0           B8                   000A  mov	ax,*$A
04070 0EB3           50                         push	ax
04071                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04072 0EB4           E8         02F2            call	_keyboard_panic
04073 0EB7           44                         inc	sp
04074 0EB8           44                         inc	sp
04075                                           !BCC_EOS
04076                                           ! 1296     outb(0x0060, 0xff);
04077                       00000EB9            .B8:
04078                                           ! Debug: list int = const $FF (used reg = )
04079 0EB9           B8                   00FF  mov	ax,#$FF
04080 0EBC           50                         push	ax
04081                                           ! Debug: list int = const $60 (used reg = )
04082 0EBD           B8                   0060  mov	ax,*$60
04083 0EC0           50                         push	ax
04084                                           ! Debug: func () void = outb+0 (used reg = )
04085 0EC1           E8         F64A            call	_outb
04086 0EC4           83C4                   04  add	sp,*4
04087                                           !BCC_EOS
04088                                           ! 1297     max=0xffff;
04089                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04090 0EC7           B8                   FFFF  mov	ax,#$FFFF
04091 0ECA           8946         FE            mov	-2[bp],ax
04092                                           !BCC_EOS
04093                                           ! 1298     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x20);
04094 0ECD           EB           0E            jmp .BB
04095                       00000ECF            .BC:
04096                                           ! Debug: list int = const $20 (used reg = )
04097 0ECF           B8                   0020  mov	ax,*$20
04098 0ED2           50                         push	ax
04099                                           ! Debug: list int = const $80 (used reg = )
04100 0ED3           B8                   0080  mov	ax,#$80
04101 0ED6           50                         push	ax
04102                                           ! Debug: func () void = outb+0 (used reg = )
04103 0ED7           E8         F634            call	_outb
04104 0EDA           83C4                   04  add	sp,*4
04105                                           !BCC_EOS
04106                                           ! 1299     if (max==0x0) keyboard_panic(20);
04107                       00000EDD            .BB:
04108                                           ! Debug: list int = const $64 (used reg = )
04109 0EDD           B8                   0064  mov	ax,*$64
04110 0EE0           50                         push	ax
04111                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04112 0EE1           E8         F614            call	_inb
04113 0EE4           44                         inc	sp
04114 0EE5           44                         inc	sp
04115                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04116 0EE6           24                     02  and	al,*2
04117 0EE8           84C0                       test	al,al
04118 0EEA           74           0B            je  	.BD
04119                       00000EEC            .BE:
04120                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04121 0EEC           8B46         FE            mov	ax,-2[bp]
04122 0EEF           48                         dec	ax
04123 0EF0           8946         FE            mov	-2[bp],ax
04124                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04125 0EF3           85C0                       test	ax,ax
04126 0EF5           75           D8            jne	.BC
04127                       00000EF7            .BD:
04128                       00000EF7            .BA:
04129                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04130 0EF7           8B46         FE            mov	ax,-2[bp]
04131 0EFA           85C0                       test	ax,ax
04132 0EFC           75           09            jne 	.BF
04133                       00000EFE            .C0:
04134                                           ! Debug: list int = const $14 (used reg = )
04135 0EFE           B8                   0014  mov	ax,*$14
04136 0F01           50                         push	ax
04137                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04138 0F02           E8         02A4            call	_keyboard_panic
04139 0F05           44                         inc	sp
04140 0F06           44                         inc	sp
04141                                           !BCC_EOS
04142                                           ! 1300     max=0xffff;
04143                       00000F07            .BF:
04144                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04145 0F07           B8                   FFFF  mov	ax,#$FFFF
04146 0F0A           8946         FE            mov	-2[bp],ax
04147                                           !BCC_EOS
04148                                           ! 1301     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x21);
04149 0F0D           EB           0E            jmp .C2
04150                       00000F0F            .C3:
04151                                           ! Debug: list int = const $21 (used reg = )
04152 0F0F           B8                   0021  mov	ax,*$21
04153 0F12           50                         push	ax
04154                                           ! Debug: list int = const $80 (used reg = )
04155 0F13           B8                   0080  mov	ax,#$80
04156 0F16           50                         push	ax
04157                                           ! Debug: func () void = outb+0 (used reg = )
04158 0F17           E8         F5F4            call	_outb
04159 0F1A           83C4                   04  add	sp,*4
04160                                           !BCC_EOS
04161                                           ! 1302     if (max==0x0) keyboard_panic(21);
04162                       00000F1D            .C2:
04163                                           ! Debug: list int = const $64 (used reg = )
04164 0F1D           B8                   0064  mov	ax,*$64
04165 0F20           50                         push	ax
04166                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04167 0F21           E8         F5D4            call	_inb
04168 0F24           44                         inc	sp
04169 0F25           44                         inc	sp
04170                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04171 0F26           24                     01  and	al,*1
04172                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04173 0F28           84C0                       test	al,al
04174 0F2A           75           0B            jne 	.C4
04175                       00000F2C            .C5:
04176                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04177 0F2C           8B46         FE            mov	ax,-2[bp]
04178 0F2F           48                         dec	ax
04179 0F30           8946         FE            mov	-2[bp],ax
04180                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04181 0F33           85C0                       test	ax,ax
04182 0F35           75           D8            jne	.C3
04183                       00000F37            .C4:
04184                       00000F37            .C1:
04185                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04186 0F37           8B46         FE            mov	ax,-2[bp]
04187 0F3A           85C0                       test	ax,ax
04188 0F3C           75           09            jne 	.C6
04189                       00000F3E            .C7:
04190                                           ! Debug: list int = const $15 (used reg = )
04191 0F3E           B8                   0015  mov	ax,*$15
04192 0F41           50                         push	ax
04193                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04194 0F42           E8         0264            call	_keyboard_panic
04195 0F45           44                         inc	sp
04196 0F46           44                         inc	sp
04197                                           !BCC_EOS
04198                                           ! 1303     if ((inb(0x0060) != 0xfa)) {
04199                       00000F47            .C6:
04200                                           ! Debug: list int = const $60 (used reg = )
04201 0F47           B8                   0060  mov	ax,*$60
04202 0F4A           50                         push	ax
04203                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04204 0F4B           E8         F5AA            call	_inb
04205 0F4E           44                         inc	sp
04206 0F4F           44                         inc	sp
04207                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04208 0F50           3C                     FA  cmp	al,#$FA
04209 0F52           74           09            je  	.C8
04210                       00000F54            .C9:
04211                                           ! 1304         keyboard_panic(993);
04212                                           ! Debug: list int = const $3E1 (used reg = )
04213 0F54           B8                   03E1  mov	ax,#$3E1
04214 0F57           50                         push	ax
04215                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04216 0F58           E8         024E            call	_keyboard_panic
04217 0F5B           44                         inc	sp
04218 0F5C           44                         inc	sp
04219                                           !BCC_EOS
04220                                           ! 1305     }
04221                                           ! 1306     max=0xffff;
04222                       00000F5D            .C8:
04223                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04224 0F5D           B8                   FFFF  mov	ax,#$FFFF
04225 0F60           8946         FE            mov	-2[bp],ax
04226                                           !BCC_EOS
04227                                           ! 1307     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x31);
04228 0F63           EB           0E            jmp .CB
04229                       00000F65            .CC:
04230                                           ! Debug: list int = const $31 (used reg = )
04231 0F65           B8                   0031  mov	ax,*$31
04232 0F68           50                         push	ax
04233                                           ! Debug: list int = const $80 (used reg = )
04234 0F69           B8                   0080  mov	ax,#$80
04235 0F6C           50                         push	ax
04236                                           ! Debug: func () void = outb+0 (used reg = )
04237 0F6D           E8         F59E            call	_outb
04238 0F70           83C4                   04  add	sp,*4
04239                                           !BCC_EOS
04240                                           ! 1308     if (max==0x0) keyboard_panic(31);
04241                       00000F73            .CB:
04242                                           ! Debug: list int = const $64 (used reg = )
04243 0F73           B8                   0064  mov	ax,*$64
04244 0F76           50                         push	ax
04245                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04246 0F77           E8         F57E            call	_inb
04247 0F7A           44                         inc	sp
04248 0F7B           44                         inc	sp
04249                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04250 0F7C           24                     01  and	al,*1
04251                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04252 0F7E           84C0                       test	al,al
04253 0F80           75           0B            jne 	.CD
04254                       00000F82            .CE:
04255                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04256 0F82           8B46         FE            mov	ax,-2[bp]
04257 0F85           48                         dec	ax
04258 0F86           8946         FE            mov	-2[bp],ax
04259                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04260 0F89           85C0                       test	ax,ax
04261 0F8B           75           D8            jne	.CC
04262                       00000F8D            .CD:
04263                       00000F8D            .CA:
04264                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04265 0F8D           8B46         FE            mov	ax,-2[bp]
04266 0F90           85C0                       test	ax,ax
04267 0F92           75           09            jne 	.CF
04268                       00000F94            .D0:
04269                                           ! Debug: list int = const $1F (used reg = )
04270 0F94           B8                   001F  mov	ax,*$1F
04271 0F97           50                         push	ax
04272                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04273 0F98           E8         020E            call	_keyboard_panic
04274 0F9B           44                         inc	sp
04275 0F9C           44                         inc	sp
04276                                           !BCC_EOS
04277                                           ! 1309     if ((inb(0x0060) != 0xaa)) {
04278                       00000F9D            .CF:
04279                                           ! Debug: list int = const $60 (used reg = )
04280 0F9D           B8                   0060  mov	ax,*$60
04281 0FA0           50                         push	ax
04282                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04283 0FA1           E8         F554            call	_inb
04284 0FA4           44                         inc	sp
04285 0FA5           44                         inc	sp
04286                                           ! Debug: ne int = const $AA to unsigned char = al+0 (used reg = )
04287 0FA6           3C                     AA  cmp	al,#$AA
04288 0FA8           74           09            je  	.D1
04289                       00000FAA            .D2:
04290                                           ! 1310         keyboard_panic(994);
04291                                           ! Debug: list int = const $3E2 (used reg = )
04292 0FAA           B8                   03E2  mov	ax,#$3E2
04293 0FAD           50                         push	ax
04294                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04295 0FAE           E8         01F8            call	_keyboard_panic
04296 0FB1           44                         inc	sp
04297 0FB2           44                         inc	sp
04298                                           !BCC_EOS
04299                                           ! 1311     }
04300                                           ! 1312     outb(0x0060, 0xf5);
04301                       00000FB3            .D1:
04302                                           ! Debug: list int = const $F5 (used reg = )
04303 0FB3           B8                   00F5  mov	ax,#$F5
04304 0FB6           50                         push	ax
04305                                           ! Debug: list int = const $60 (used reg = )
04306 0FB7           B8                   0060  mov	ax,*$60
04307 0FBA           50                         push	ax
04308                                           ! Debug: func () void = outb+0 (used reg = )
04309 0FBB           E8         F550            call	_outb
04310 0FBE           83C4                   04  add	sp,*4
04311                                           !BCC_EOS
04312                                           ! 1313     max=0xffff;
04313                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04314 0FC1           B8                   FFFF  mov	ax,#$FFFF
04315 0FC4           8946         FE            mov	-2[bp],ax
04316                                           !BCC_EOS
04317                                           ! 1314     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x40);
04318 0FC7           EB           0E            jmp .D4
04319                       00000FC9            .D5:
04320                                           ! Debug: list int = const $40 (used reg = )
04321 0FC9           B8                   0040  mov	ax,*$40
04322 0FCC           50                         push	ax
04323                                           ! Debug: list int = const $80 (used reg = )
04324 0FCD           B8                   0080  mov	ax,#$80
04325 0FD0           50                         push	ax
04326                                           ! Debug: func () void = outb+0 (used reg = )
04327 0FD1           E8         F53A            call	_outb
04328 0FD4           83C4                   04  add	sp,*4
04329                                           !BCC_EOS
04330                                           ! 1315     if (max==0x0) keyboard_panic(40);
04331                       00000FD7            .D4:
04332                                           ! Debug: list int = const $64 (used reg = )
04333 0FD7           B8                   0064  mov	ax,*$64
04334 0FDA           50                         push	ax
04335                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04336 0FDB           E8         F51A            call	_inb
04337 0FDE           44                         inc	sp
04338 0FDF           44                         inc	sp
04339                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04340 0FE0           24                     02  and	al,*2
04341 0FE2           84C0                       test	al,al
04342 0FE4           74           0B            je  	.D6
04343                       00000FE6            .D7:
04344                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04345 0FE6           8B46         FE            mov	ax,-2[bp]
04346 0FE9           48                         dec	ax
04347 0FEA           8946         FE            mov	-2[bp],ax
04348                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04349 0FED           85C0                       test	ax,ax
04350 0FEF           75           D8            jne	.D5
04351                       00000FF1            .D6:
04352                       00000FF1            .D3:
04353                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04354 0FF1           8B46         FE            mov	ax,-2[bp]
04355 0FF4           85C0                       test	ax,ax
04356 0FF6           75           09            jne 	.D8
04357                       00000FF8            .D9:
04358                                           ! Debug: list int = const $28 (used reg = )
04359 0FF8           B8                   0028  mov	ax,*$28
04360 0FFB           50                         push	ax
04361                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04362 0FFC           E8         01AA            call	_keyboard_panic
04363 0FFF           44                         inc	sp
04364 1000           44                         inc	sp
04365                                           !BCC_EOS
04366                                           ! 1316     max=0xffff;
04367                       00001001            .D8:
04368                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04369 1001           B8                   FFFF  mov	ax,#$FFFF
04370 1004           8946         FE            mov	-2[bp],ax
04371                                           !BCC_EOS
04372                                           ! 1317     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x41);
04373 1007           EB           0E            jmp .DB
04374                       00001009            .DC:
04375                                           ! Debug: list int = const $41 (used reg = )
04376 1009           B8                   0041  mov	ax,*$41
04377 100C           50                         push	ax
04378                                           ! Debug: list int = const $80 (used reg = )
04379 100D           B8                   0080  mov	ax,#$80
04380 1010           50                         push	ax
04381                                           ! Debug: func () void = outb+0 (used reg = )
04382 1011           E8         F4FA            call	_outb
04383 1014           83C4                   04  add	sp,*4
04384                                           !BCC_EOS
04385                                           ! 1318     if (max==0x0) keyboard_panic(41);
04386                       00001017            .DB:
04387                                           ! Debug: list int = const $64 (used reg = )
04388 1017           B8                   0064  mov	ax,*$64
04389 101A           50                         push	ax
04390                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04391 101B           E8         F4DA            call	_inb
04392 101E           44                         inc	sp
04393 101F           44                         inc	sp
04394                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04395 1020           24                     01  and	al,*1
04396                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04397 1022           84C0                       test	al,al
04398 1024           75           0B            jne 	.DD
04399                       00001026            .DE:
04400                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04401 1026           8B46         FE            mov	ax,-2[bp]
04402 1029           48                         dec	ax
04403 102A           8946         FE            mov	-2[bp],ax
04404                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04405 102D           85C0                       test	ax,ax
04406 102F           75           D8            jne	.DC
04407                       00001031            .DD:
04408                       00001031            .DA:
04409                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04410 1031           8B46         FE            mov	ax,-2[bp]
04411 1034           85C0                       test	ax,ax
04412 1036           75           09            jne 	.DF
04413                       00001038            .E0:
04414                                           ! Debug: list int = const $29 (used reg = )
04415 1038           B8                   0029  mov	ax,*$29
04416 103B           50                         push	ax
04417                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04418 103C           E8         016A            call	_keyboard_panic
04419 103F           44                         inc	sp
04420 1040           44                         inc	sp
04421                                           !BCC_EOS
04422                                           ! 1319     if ((inb(0x0060) != 0xfa)) {
04423                       00001041            .DF:
04424                                           ! Debug: list int = const $60 (used reg = )
04425 1041           B8                   0060  mov	ax,*$60
04426 1044           50                         push	ax
04427                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04428 1045           E8         F4B0            call	_inb
04429 1048           44                         inc	sp
04430 1049           44                         inc	sp
04431                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04432 104A           3C                     FA  cmp	al,#$FA
04433 104C           74           09            je  	.E1
04434                       0000104E            .E2:
04435                                           ! 1320         keyboard_panic(995);
04436                                           ! Debug: list int = const $3E3 (used reg = )
04437 104E           B8                   03E3  mov	ax,#$3E3
04438 1051           50                         push	ax
04439                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04440 1052           E8         0154            call	_keyboard_panic
04441 1055           44                         inc	sp
04442 1056           44                         inc	sp
04443                                           !BCC_EOS
04444                                           ! 1321     }
04445                                           ! 1322     outb(0x0064, 0x60);
04446                       00001057            .E1:
04447                                           ! Debug: list int = const $60 (used reg = )
04448 1057           B8                   0060  mov	ax,*$60
04449 105A           50                         push	ax
04450                                           ! Debug: list int = const $64 (used reg = )
04451 105B           B8                   0064  mov	ax,*$64
04452 105E           50                         push	ax
04453                                           ! Debug: func () void = outb+0 (used reg = )
04454 105F           E8         F4AC            call	_outb
04455 1062           83C4                   04  add	sp,*4
04456                                           !BCC_EOS
04457                                           ! 1323     max=0xffff;
04458                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04459 1065           B8                   FFFF  mov	ax,#$FFFF
04460 1068           8946         FE            mov	-2[bp],ax
04461                                           !BCC_EOS
04462                                           ! 1324     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x50);
04463 106B           EB           0E            jmp .E4
04464                       0000106D            .E5:
04465                                           ! Debug: list int = const $50 (used reg = )
04466 106D           B8                   0050  mov	ax,*$50
04467 1070           50                         push	ax
04468                                           ! Debug: list int = const $80 (used reg = )
04469 1071           B8                   0080  mov	ax,#$80
04470 1074           50                         push	ax
04471                                           ! Debug: func () void = outb+0 (used reg = )
04472 1075           E8         F496            call	_outb
04473 1078           83C4                   04  add	sp,*4
04474                                           !BCC_EOS
04475                                           ! 1325     if (max==0x0) keyboard_panic(50);
04476                       0000107B            .E4:
04477                                           ! Debug: list int = const $64 (used reg = )
04478 107B           B8                   0064  mov	ax,*$64
04479 107E           50                         push	ax
04480                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04481 107F           E8         F476            call	_inb
04482 1082           44                         inc	sp
04483 1083           44                         inc	sp
04484                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04485 1084           24                     02  and	al,*2
04486 1086           84C0                       test	al,al
04487 1088           74           0B            je  	.E6
04488                       0000108A            .E7:
04489                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04490 108A           8B46         FE            mov	ax,-2[bp]
04491 108D           48                         dec	ax
04492 108E           8946         FE            mov	-2[bp],ax
04493                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04494 1091           85C0                       test	ax,ax
04495 1093           75           D8            jne	.E5
04496                       00001095            .E6:
04497                       00001095            .E3:
04498                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04499 1095           8B46         FE            mov	ax,-2[bp]
04500 1098           85C0                       test	ax,ax
04501 109A           75           09            jne 	.E8
04502                       0000109C            .E9:
04503                                           ! Debug: list int = const $32 (used reg = )
04504 109C           B8                   0032  mov	ax,*$32
04505 109F           50                         push	ax
04506                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04507 10A0           E8         0106            call	_keyboard_panic
04508 10A3           44                         inc	sp
04509 10A4           44                         inc	sp
04510                                           !BCC_EOS
04511                                           ! 1326     outb(0x0060, 0x61);
04512                       000010A5            .E8:
04513                                           ! Debug: list int = const $61 (used reg = )
04514 10A5           B8                   0061  mov	ax,*$61
04515 10A8           50                         push	ax
04516                                           ! Debug: list int = const $60 (used reg = )
04517 10A9           B8                   0060  mov	ax,*$60
04518 10AC           50                         push	ax
04519                                           ! Debug: func () void = outb+0 (used reg = )
04520 10AD           E8         F45E            call	_outb
04521 10B0           83C4                   04  add	sp,*4
04522                                           !BCC_EOS
04523                                           ! 1327     max=0xffff;
04524                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04525 10B3           B8                   FFFF  mov	ax,#$FFFF
04526 10B6           8946         FE            mov	-2[bp],ax
04527                                           !BCC_EOS
04528                                           ! 1328     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x60);
04529 10B9           EB           0E            jmp .EB
04530                       000010BB            .EC:
04531                                           ! Debug: list int = const $60 (used reg = )
04532 10BB           B8                   0060  mov	ax,*$60
04533 10BE           50                         push	ax
04534                                           ! Debug: list int = const $80 (used reg = )
04535 10BF           B8                   0080  mov	ax,#$80
04536 10C2           50                         push	ax
04537                                           ! Debug: func () void = outb+0 (used reg = )
04538 10C3           E8         F448            call	_outb
04539 10C6           83C4                   04  add	sp,*4
04540                                           !BCC_EOS
04541                                           ! 1329     if (max==0x0) keyboard_panic(60);
04542                       000010C9            .EB:
04543                                           ! Debug: list int = const $64 (used reg = )
04544 10C9           B8                   0064  mov	ax,*$64
04545 10CC           50                         push	ax
04546                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04547 10CD           E8         F428            call	_inb
04548 10D0           44                         inc	sp
04549 10D1           44                         inc	sp
04550                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04551 10D2           24                     02  and	al,*2
04552 10D4           84C0                       test	al,al
04553 10D6           74           0B            je  	.ED
04554                       000010D8            .EE:
04555                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04556 10D8           8B46         FE            mov	ax,-2[bp]
04557 10DB           48                         dec	ax
04558 10DC           8946         FE            mov	-2[bp],ax
04559                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04560 10DF           85C0                       test	ax,ax
04561 10E1           75           D8            jne	.EC
04562                       000010E3            .ED:
04563                       000010E3            .EA:
04564                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04565 10E3           8B46         FE            mov	ax,-2[bp]
04566 10E6           85C0                       test	ax,ax
04567 10E8           75           09            jne 	.EF
04568                       000010EA            .F0:
04569                                           ! Debug: list int = const $3C (used reg = )
04570 10EA           B8                   003C  mov	ax,*$3C
04571 10ED           50                         push	ax
04572                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04573 10EE           E8         00B8            call	_keyboard_panic
04574 10F1           44                         inc	sp
04575 10F2           44                         inc	sp
04576                                           !BCC_EOS
04577                                           ! 1330     outb(0x0060, 0xf4);
04578                       000010F3            .EF:
04579                                           ! Debug: list int = const $F4 (used reg = )
04580 10F3           B8                   00F4  mov	ax,#$F4
04581 10F6           50                         push	ax
04582                                           ! Debug: list int = const $60 (used reg = )
04583 10F7           B8                   0060  mov	ax,*$60
04584 10FA           50                         push	ax
04585                                           ! Debug: func () void = outb+0 (used reg = )
04586 10FB           E8         F410            call	_outb
04587 10FE           83C4                   04  add	sp,*4
04588                                           !BCC_EOS
04589                                           ! 1331     max=0xffff;
04590                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04591 1101           B8                   FFFF  mov	ax,#$FFFF
04592 1104           8946         FE            mov	-2[bp],ax
04593                                           !BCC_EOS
04594                                           ! 1332     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x70);
04595 1107           EB           0E            jmp .F2
04596                       00001109            .F3:
04597                                           ! Debug: list int = const $70 (used reg = )
04598 1109           B8                   0070  mov	ax,*$70
04599 110C           50                         push	ax
04600                                           ! Debug: list int = const $80 (used reg = )
04601 110D           B8                   0080  mov	ax,#$80
04602 1110           50                         push	ax
04603                                           ! Debug: func () void = outb+0 (used reg = )
04604 1111           E8         F3FA            call	_outb
04605 1114           83C4                   04  add	sp,*4
04606                                           !BCC_EOS
04607                                           ! 1333     if (max==0x0) keyboard_panic(70);
04608                       00001117            .F2:
04609                                           ! Debug: list int = const $64 (used reg = )
04610 1117           B8                   0064  mov	ax,*$64
04611 111A           50                         push	ax
04612                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04613 111B           E8         F3DA            call	_inb
04614 111E           44                         inc	sp
04615 111F           44                         inc	sp
04616                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04617 1120           24                     02  and	al,*2
04618 1122           84C0                       test	al,al
04619 1124           74           0B            je  	.F4
04620                       00001126            .F5:
04621                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04622 1126           8B46         FE            mov	ax,-2[bp]
04623 1129           48                         dec	ax
04624 112A           8946         FE            mov	-2[bp],ax
04625                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04626 112D           85C0                       test	ax,ax
04627 112F           75           D8            jne	.F3
04628                       00001131            .F4:
04629                       00001131            .F1:
04630                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04631 1131           8B46         FE            mov	ax,-2[bp]
04632 1134           85C0                       test	ax,ax
04633 1136           75           09            jne 	.F6
04634                       00001138            .F7:
04635                                           ! Debug: list int = const $46 (used reg = )
04636 1138           B8                   0046  mov	ax,*$46
04637 113B           50                         push	ax
04638                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04639 113C           E8         006A            call	_keyboard_panic
04640 113F           44                         inc	sp
04641 1140           44                         inc	sp
04642                                           !BCC_EOS
04643                                           ! 1334     max=0xffff;
04644                       00001141            .F6:
04645                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04646 1141           B8                   FFFF  mov	ax,#$FFFF
04647 1144           8946         FE            mov	-2[bp],ax
04648                                           !BCC_EOS
04649                                           ! 1335     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x71);
04650 1147           EB           0E            jmp .F9
04651                       00001149            .FA:
04652                                           ! Debug: list int = const $71 (used reg = )
04653 1149           B8                   0071  mov	ax,*$71
04654 114C           50                         push	ax
04655                                           ! Debug: list int = const $80 (used reg = )
04656 114D           B8                   0080  mov	ax,#$80
04657 1150           50                         push	ax
04658                                           ! Debug: func () void = outb+0 (used reg = )
04659 1151           E8         F3BA            call	_outb
04660 1154           83C4                   04  add	sp,*4
04661                                           !BCC_EOS
04662                                           ! 1336     if (max==0x0
04663                       00001157            .F9:
04664                                           ! Debug: list int = const $64 (used reg = )
04665 1157           B8                   0064  mov	ax,*$64
04666 115A           50                         push	ax
04667                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04668 115B           E8         F39A            call	_inb
04669 115E           44                         inc	sp
04670 115F           44                         inc	sp
04671                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04672 1160           24                     01  and	al,*1
04673                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04674 1162           84C0                       test	al,al
04675 1164           75           0B            jne 	.FB
04676                       00001166            .FC:
04677                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04678 1166           8B46         FE            mov	ax,-2[bp]
04679 1169           48                         dec	ax
04680 116A           8946         FE            mov	-2[bp],ax
04681                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04682 116D           85C0                       test	ax,ax
04683 116F           75           D8            jne	.FA
04684                       00001171            .FB:
04685                       00001171            .F8:
04686                                           ! 1336 ) keyboard_panic(70);
04687                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04688 1171           8B46         FE            mov	ax,-2[bp]
04689 1174           85C0                       test	ax,ax
04690 1176           75           09            jne 	.FD
04691                       00001178            .FE:
04692                                           ! Debug: list int = const $46 (used reg = )
04693 1178           B8                   0046  mov	ax,*$46
04694 117B           50                         push	ax
04695                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04696 117C           E8         002A            call	_keyboard_panic
04697 117F           44                         inc	sp
04698 1180           44                         inc	sp
04699                                           !BCC_EOS
04700                                           ! 1337     if ((inb(0x0060) != 0xfa)) {
04701                       00001181            .FD:
04702                                           ! Debug: list int = const $60 (used reg = )
04703 1181           B8                   0060  mov	ax,*$60
04704 1184           50                         push	ax
04705                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04706 1185           E8         F370            call	_inb
04707 1188           44                         inc	sp
04708 1189           44                         inc	sp
04709                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04710 118A           3C                     FA  cmp	al,#$FA
04711 118C           74           09            je  	.FF
04712                       0000118E            .100:
04713                                           ! 1338         keyboard_panic(996);
04714                                           ! Debug: list int = const $3E4 (used reg = )
04715 118E           B8                   03E4  mov	ax,#$3E4
04716 1191           50                         push	ax
04717                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04718 1192           E8         0014            call	_keyboard_panic
04719 1195           44                         inc	sp
04720 1196           44                         inc	sp
04721                                           !BCC_EOS
04722                                           ! 1339     }
04723                                           ! 1340     outb(0x0080, 0x77);
04724                       00001197            .FF:
04725                                           ! Debug: list int = const $77 (used reg = )
04726 1197           B8                   0077  mov	ax,*$77
04727 119A           50                         push	ax
04728                                           ! Debug: list int = const $80 (used reg = )
04729 119B           B8                   0080  mov	ax,#$80
04730 119E           50                         push	ax
04731                                           ! Debug: func () void = outb+0 (used reg = )
04732 119F           E8         F36C            call	_outb
04733 11A2           83C4                   04  add	sp,*4
04734                                           !BCC_EOS
04735                                           ! 1341 }
04736 11A5           89EC                       mov	sp,bp
04737 11A7           5D                         pop	bp
04738 11A8           C3                         ret
04739                                           ! 1342   void
04740                                           ! 1343 keyboard_panic(status)
04741                                           ! 1344   Bit16u status;
04742                                           export	_keyboard_panic
04743                       000011A9            _keyboard_panic:
04744                                           !BCC_EOS
04745                                           ! 1345 {
04746                                           ! 1346   bios_printf((2 | 4 | 1), "Keyboard error:%u\n",status);
04747 11A9           55                         push	bp
04748 11AA           89E5                       mov	bp,sp
04749                                           ! Debug: list unsigned short status = [S+2+2] (used reg = )
04750 11AC           FF76         04            push	4[bp]
04751                                           ! Debug: list * char = .101+0 (used reg = )
04752 11AF           BB                   D9E0  mov	bx,#.101
04753 11B2           53                         push	bx
04754                                           ! Debug: list int = const 7 (used reg = )
04755 11B3           B8                   0007  mov	ax,*7
04756 11B6           50                         push	ax
04757                                           ! Debug: func () void = bios_printf+0 (used reg = )
04758 11B7           E8         F784            call	_bios_printf
04759 11BA           89EC                       mov	sp,bp
04760                                           !BCC_EOS
04761                                           ! 1347 }
04762 11BC           5D                         pop	bp
04763 11BD           C3                         ret
04764                                           ! 1348   void
04765                                           ! Register BX used in function keyboard_panic
04766                                           ! 1349 shutdown_status_panic(status)
04767                                           ! 1350   Bit16u status;
04768                                           export	_shutdown_status_panic
04769                       000011BE            _shutdown_status_panic:
04770                                           !BCC_EOS
04771                                           ! 1351 {
04772                                           ! 1352   bios_printf((2 | 4 | 1), "Unimplemented shutdown status: %02x\n",(Bit8u)status);
04773 11BE           55                         push	bp
04774 11BF           89E5                       mov	bp,sp
04775                                           ! Debug: list unsigned char status = [S+2+2] (used reg = )
04776 11C1           8A46         04            mov	al,4[bp]
04777 11C4           30E4                       xor	ah,ah
04778 11C6           50                         push	ax
04779                                           ! Debug: list * char = .102+0 (used reg = )
04780 11C7           BB                   D9BB  mov	bx,#.102
04781 11CA           53                         push	bx
04782                                           ! Debug: list int = const 7 (used reg = )
04783 11CB           B8                   0007  mov	ax,*7
04784 11CE           50                         push	ax
04785                                           ! Debug: func () void = bios_printf+0 (used reg = )
04786 11CF           E8         F76C            call	_bios_printf
04787 11D2           89EC                       mov	sp,bp
04788                                           !BCC_EOS
04789                                           ! 1353 }
04790 11D4           5D                         pop	bp
04791 11D5           C3                         ret
04792                                           ! 1354 void s3_resume_panic()
04793                                           ! Register BX used in function shutdown_status_panic
04794                                           ! 1355 {
04795                                           export	_s3_resume_panic
04796                       000011D6            _s3_resume_panic:
04797                                           ! 1356   bios_printf((2 | 4 | 1), "Returned from s3_resume.\n");
04798 11D6           55                         push	bp
04799 11D7           89E5                       mov	bp,sp
04800                                           ! Debug: list * char = .103+0 (used reg = )
04801 11D9           BB                   D9A1  mov	bx,#.103
04802 11DC           53                         push	bx
04803                                           ! Debug: list int = const 7 (used reg = )
04804 11DD           B8                   0007  mov	ax,*7
04805 11E0           50                         push	ax
04806                                           ! Debug: func () void = bios_printf+0 (used reg = )
04807 11E1           E8         F75A            call	_bios_printf
04808 11E4           89EC                       mov	sp,bp
04809                                           !BCC_EOS
04810                                           ! 1357 }
04811 11E6           5D                         pop	bp
04812 11E7           C3                         ret
04813                                           ! 1358 void
04814                                           ! Register BX used in function s3_resume_panic
04815                                           ! 1359 print_bios_banner()
04816                                           ! 1360 {
04817                                           export	_print_bios_banner
04818                       000011E8            _print_bios_banner:
04819                                           ! 1361   bios_printf(2, "Bochs ""2.7.svn"" BIOS - build: %s\n%s\nOptions: ", "08/01/21", bios_svn_version_string);
04820 11E8           55                         push	bp
04821 11E9           89E5                       mov	bp,sp
04822                                           ! Debug: list * char = bios_svn_version_string+0 (used reg = )
04823 11EB           BB                   016C  mov	bx,#_bios_svn_version_string
04824 11EE           53                         push	bx
04825                                           ! Debug: list * char = .105+0 (used reg = )
04826 11EF           BB                   D96C  mov	bx,#.105
04827 11F2           53                         push	bx
04828                                           ! Debug: list * char = .104+0 (used reg = )
04829 11F3           BB                   D975  mov	bx,#.104
04830 11F6           53                         push	bx
04831                                           ! Debug: list int = const 2 (used reg = )
04832 11F7           B8                   0002  mov	ax,*2
04833 11FA           50                         push	ax
04834                                           ! Debug: func () void = bios_printf+0 (used reg = )
04835 11FB           E8         F740            call	_bios_printf
04836 11FE           89EC                       mov	sp,bp
04837                                           !BCC_EOS
04838                                           ! 1362   bios_printf(2, "apmbios " "pcibios " "pnpbios " "eltorito " "rombios32 " "\n\n");
04839                                           ! Debug: list * char = .106+0 (used reg = )
04840 1200           BB                   D93E  mov	bx,#.106
04841 1203           53                         push	bx
04842                                           ! Debug: list int = const 2 (used reg = )
04843 1204           B8                   0002  mov	ax,*2
04844 1207           50                         push	ax
04845                                           ! Debug: func () void = bios_printf+0 (used reg = )
04846 1208           E8         F733            call	_bios_printf
04847 120B           89EC                       mov	sp,bp
04848                                           !BCC_EOS
04849                                           ! 1363 }
04850 120D           5D                         pop	bp
04851 120E           C3                         ret
04852                                           ! 1364 static char drivetypes[][10]={"", "Floppy","Hard Disk","CD-Rom", "Network"};
04853                                           ! Register BX used in function print_bios_banner
04854                                           
04855                       0000120F            _drivetypes:
04856                       0000120F            .107:
04857 120F                        00            .byte	0
04858 1210                  00000009            .blkb	9
04859                       00001219            .108:
04860 1219                        46            .ascii	"Floppy"
04861 121F                        00            .byte	0
04862 1220                  00000003            .blkb	3
04863                       00001223            .109:
04864 1223                        48            .ascii	"Hard Disk"
04865 122C                        00            .byte	0
04866                       0000122D            .10A:
04867 122D                        43            .ascii	"CD-Rom"
04868 1233                        00            .byte	0
04869 1234                  00000003            .blkb	3
04870                       00001237            .10B:
04871 1237                        4E            .ascii	"Network"
04872 123E                        00            .byte	0
04873 123F                  00000002            .blkb	2
04874                                           !BCC_EOS
04875                                           ! 1365 static void
04876                                           ! 1366 init_boot_vectors()
04877                                           ! 1367 {
04878                                           
04879                       00001241            _init_boot_vectors:
04880                                           ! 1368   ipl_entry_t e;
04881                                           !BCC_EOS
04882                                           ! 1369   Bit16u count = 0;
04883 1241           55                         push	bp
04884 1242           89E5                       mov	bp,sp
04885 1244           83C4                   EE  add	sp,*-$12
04886                                           ! Debug: eq int = const 0 to unsigned short count = [S+$14-$14] (used reg = )
04887 1247           31C0                       xor	ax,ax
04888 1249           8946         EE            mov	-$12[bp],ax
04889                                           !BCC_EOS
04890                                           ! 1370   Bit16u ss = get_SS();
04891 124C           4C                         dec	sp
04892 124D           4C                         dec	sp
04893                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
04894 124E           E8         F40E            call	_get_SS
04895                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$16] (used reg = )
04896 1251           8946         EC            mov	-$14[bp],ax
04897                                           !BCC_EOS
04898                                           ! 1371 #asm
04899                                           !BCC_EOS
04900                                           !BCC_ASM
04901                       00000002            _init_boot_vectors.count	set	2
04902                       FFFFFFEE            .init_boot_vectors.count	set	-$12
04903                       00000000            _init_boot_vectors.ss	set	0
04904                       FFFFFFEC            .init_boot_vectors.ss	set	-$14
04905                       00000004            _init_boot_vectors.e	set	4
04906                       FFFFFFF0            .init_boot_vectors.e	set	-$10
04907 1254           1E                           push ds
04908                                           ! 1373 endasm
04909                                           !BCC_ENDASM
04910                                           !BCC_EOS
04911                                           ! 1374   set_DS(0x9ff0);
04912                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04913 1255           B8                   9FF0  mov	ax,#$9FF0
04914 1258           50                         push	ax
04915                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
04916 1259           E8         F406            call	_set_DS
04917 125C           44                         inc	sp
04918 125D           44                         inc	sp
04919                                           !BCC_EOS
04920                                           ! 1375   _memsetb(0,0x0000,0x9ff0,0x86);
04921                                           ! Debug: list int = const $86 (used reg = )
04922 125E           B8                   0086  mov	ax,#$86
04923 1261           50                         push	ax
04924                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04925 1262           B8                   9FF0  mov	ax,#$9FF0
04926 1265           50                         push	ax
04927                                           ! Debug: list int = const 0 (used reg = )
04928 1266           31C0                       xor	ax,ax
04929 1268           50                         push	ax
04930                                           ! Debug: list int = const 0 (used reg = )
04931 1269           31C0                       xor	ax,ax
04932 126B           50                         push	ax
04933                                           ! Debug: func () void = _memsetb+0 (used reg = )
04934 126C           E8         ED91            call	__memsetb
04935 126F           83C4                   08  add	sp,*8
04936                                           !BCC_EOS
04937                                           ! 1376   *((Bit16u *)(0x0084)) = (0xFFFF);
04938                                           ! Debug: eq unsigned int = const $FFFF to unsigned short = [+$84] (used reg = )
04939 1272           B8                   FFFF  mov	ax,#$FFFF
04940 1275           A3         0084            mov	[$84],ax
04941                                           !BCC_EOS
04942                                           ! 1377   e.type = 0x01; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
04943                                           ! Debug: eq int = const 1 to unsigned short e = [S+$16-$12] (used reg = )
04944 1278           B8                   0001  mov	ax,*1
04945 127B           8946         F0            mov	-$10[bp],ax
04946                                           !BCC_EOS
04947                                           ! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
04948 127E           31C0                       xor	ax,ax
04949 1280           8946         F2            mov	-$E[bp],ax
04950                                           !BCC_EOS
04951                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
04952 1283           31C0                       xor	ax,ax
04953 1285           31DB                       xor	bx,bx
04954 1287           8946         F4            mov	-$C[bp],ax
04955 128A           895E         F6            mov	-$A[bp],bx
04956                                           !BCC_EOS
04957                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
04958 128D           31C0                       xor	ax,ax
04959 128F           31DB                       xor	bx,bx
04960 1291           8946         F8            mov	-8[bp],ax
04961 1294           895E         FA            mov	-6[bp],bx
04962                                           !BCC_EOS
04963                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
04964 1297           31C0                       xor	ax,ax
04965 1299           31DB                       xor	bx,bx
04966 129B           8946         FC            mov	-4[bp],ax
04967 129E           895E         FE            mov	-2[bp],bx
04968                                           !BCC_EOS
04969                                           ! 1378   _memcpyb(0x0000 + count * sizeof (e),0x9ff0,&e,ss,sizeof (e));
04970                                           ! Debug: list int = const $10 (used reg = )
04971 12A1           B8                   0010  mov	ax,*$10
04972 12A4           50                         push	ax
04973                                           ! Debug: list unsigned short ss = [S+$18-$16] (used reg = )
04974 12A5           FF76         EC            push	-$14[bp]
04975                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
04976 12A8           8D5E         F0            lea	bx,-$10[bp]
04977 12AB           53                         push	bx
04978                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04979 12AC           B8                   9FF0  mov	ax,#$9FF0
04980 12AF           50                         push	ax
04981                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
04982 12B0           8B46         EE            mov	ax,-$12[bp]
04983 12B3           B1                     04  mov	cl,*4
04984 12B5           D3E0                       shl	ax,cl
04985                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
04986                                           ! Debug: expression subtree swapping
04987                                           ! Debug: list unsigned int = ax+0 (used reg = )
04988 12B7           50                         push	ax
04989                                           ! Debug: func () void = _memcpyb+0 (used reg = )
04990 12B8           E8         ED60            call	__memcpyb
04991 12BB           83C4                   0A  add	sp,*$A
04992                                           !BCC_EOS
04993                                           ! 1379   count++;
04994                                           ! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
04995 12BE           8B46         EE            mov	ax,-$12[bp]
04996 12C1           40                         inc	ax
04997 12C2           8946         EE            mov	-$12[bp],ax
04998                                           !BCC_EOS
04999                                           ! 1380   e.type = 0x02; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
05000                                           ! Debug: eq int = const 2 to unsigned short e = [S+$16-$12] (used reg = )
05001 12C5           B8                   0002  mov	ax,*2
05002 12C8           8946         F0            mov	-$10[bp],ax
05003                                           !BCC_EOS
05004                                           ! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
05005 12CB           31C0                       xor	ax,ax
05006 12CD           8946         F2            mov	-$E[bp],ax
05007                                           !BCC_EOS
05008                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
05009 12D0           31C0                       xor	ax,ax
05010 12D2           31DB                       xor	bx,bx
05011 12D4           8946         F4            mov	-$C[bp],ax
05012 12D7           895E         F6            mov	-$A[bp],bx
05013                                           !BCC_EOS
05014                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
05015 12DA           31C0                       xor	ax,ax
05016 12DC           31DB                       xor	bx,bx
05017 12DE           8946         F8            mov	-8[bp],ax
05018 12E1           895E         FA            mov	-6[bp],bx
05019                                           !BCC_EOS
05020                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
05021 12E4           31C0                       xor	ax,ax
05022 12E6           31DB                       xor	bx,bx
05023 12E8           8946         FC            mov	-4[bp],ax
05024 12EB           895E         FE            mov	-2[bp],bx
05025                                           !BCC_EOS
05026                                           ! 1381   _memcpyb(0x0000 + count * sizeof (e),0x9ff0,&e,ss,sizeof (e));
05027                                           ! Debug: list int = const $10 (used reg = )
05028 12EE           B8                   0010  mov	ax,*$10
05029 12F1           50                         push	ax
05030                                           ! Debug: list unsigned short ss = [S+$18-$16] (used reg = )
05031 12F2           FF76         EC            push	-$14[bp]
05032                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
05033 12F5           8D5E         F0            lea	bx,-$10[bp]
05034 12F8           53                         push	bx
05035                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05036 12F9           B8                   9FF0  mov	ax,#$9FF0
05037 12FC           50                         push	ax
05038                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
05039 12FD           8B46         EE            mov	ax,-$12[bp]
05040 1300           B1                     04  mov	cl,*4
05041 1302           D3E0                       shl	ax,cl
05042                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
05043                                           ! Debug: expression subtree swapping
05044                                           ! Debug: list unsigned int = ax+0 (used reg = )
05045 1304           50                         push	ax
05046                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05047 1305           E8         ED13            call	__memcpyb
05048 1308           83C4                   0A  add	sp,*$A
05049                                           !BCC_EOS
05050                                           ! 1382   count++;
05051                                           ! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
05052 130B           8B46         EE            mov	ax,-$12[bp]
05053 130E           40                         inc	ax
05054 130F           8946         EE            mov	-$12[bp],ax
05055                                           !BCC_EOS
05056                                           ! 1383   e.type = 0x03; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
05057                                           ! Debug: eq int = const 3 to unsigned short e = [S+$16-$12] (used reg = )
05058 1312           B8                   0003  mov	ax,*3
05059 1315           8946         F0            mov	-$10[bp],ax
05060                                           !BCC_EOS
05061                                           ! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
05062 1318           31C0                       xor	ax,ax
05063 131A           8946         F2            mov	-$E[bp],ax
05064                                           !BCC_EOS
05065                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
05066 131D           31C0                       xor	ax,ax
05067 131F           31DB                       xor	bx,bx
05068 1321           8946         F4            mov	-$C[bp],ax
05069 1324           895E         F6            mov	-$A[bp],bx
05070                                           !BCC_EOS
05071                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
05072 1327           31C0                       xor	ax,ax
05073 1329           31DB                       xor	bx,bx
05074 132B           8946         F8            mov	-8[bp],ax
05075 132E           895E         FA            mov	-6[bp],bx
05076                                           !BCC_EOS
05077                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
05078 1331           31C0                       xor	ax,ax
05079 1333           31DB                       xor	bx,bx
05080 1335           8946         FC            mov	-4[bp],ax
05081 1338           895E         FE            mov	-2[bp],bx
05082                                           !BCC_EOS
05083                                           ! 1384   _memcpyb(0x0000 + count * sizeof (e),0x9ff0,&e,ss,sizeof (e));
05084                                           ! Debug: list int = const $10 (used reg = )
05085 133B           B8                   0010  mov	ax,*$10
05086 133E           50                         push	ax
05087                                           ! Debug: list unsigned short ss = [S+$18-$16] (used reg = )
05088 133F           FF76         EC            push	-$14[bp]
05089                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
05090 1342           8D5E         F0            lea	bx,-$10[bp]
05091 1345           53                         push	bx
05092                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05093 1346           B8                   9FF0  mov	ax,#$9FF0
05094 1349           50                         push	ax
05095                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
05096 134A           8B46         EE            mov	ax,-$12[bp]
05097 134D           B1                     04  mov	cl,*4
05098 134F           D3E0                       shl	ax,cl
05099                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
05100                                           ! Debug: expression subtree swapping
05101                                           ! Debug: list unsigned int = ax+0 (used reg = )
05102 1351           50                         push	ax
05103                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05104 1352           E8         ECC6            call	__memcpyb
05105 1355           83C4                   0A  add	sp,*$A
05106                                           !BCC_EOS
05107                                           ! 1385   count++;
05108                                           ! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
05109 1358           8B46         EE            mov	ax,-$12[bp]
05110 135B           40                         inc	ax
05111 135C           8946         EE            mov	-$12[bp],ax
05112                                           !BCC_EOS
05113                                           ! 1386   *((Bit16u *)(0x0080)) = (count);
05114                                           ! Debug: eq unsigned short count = [S+$16-$14] to unsigned short = [+$80] (used reg = )
05115 135F           8B46         EE            mov	ax,-$12[bp]
05116 1362           A3         0080            mov	[$80],ax
05117                                           !BCC_EOS
05118                                           ! 1387   *((Bit16u *)(0x0082)) = (0xffff);
05119                                           ! Debug: eq unsigned int = const $FFFF to unsigned short = [+$82] (used reg = )
05120 1365           B8                   FFFF  mov	ax,#$FFFF
05121 1368           A3         0082            mov	[$82],ax
05122                                           !BCC_EOS
05123                                           ! 1388 #asm
05124                                           !BCC_EOS
05125                                           !BCC_ASM
05126                       00000002            _init_boot_vectors.count	set	2
05127                       FFFFFFEE            .init_boot_vectors.count	set	-$12
05128                       00000000            _init_boot_vectors.ss	set	0
05129                       FFFFFFEC            .init_boot_vectors.ss	set	-$14
05130                       00000004            _init_boot_vectors.e	set	4
05131                       FFFFFFF0            .init_boot_vectors.e	set	-$10
05132 136B           1F                           pop ds
05133                                           ! 1390 endasm
05134                                           !BCC_ENDASM
05135                                           !BCC_EOS
05136                                           ! 1391 }
05137 136C           89EC                       mov	sp,bp
05138 136E           5D                         pop	bp
05139 136F           C3                         ret
05140                                           ! 1392 static Bit8u
05141                                           ! Register BX used in function init_boot_vectors
05142                                           ! 1393 get_boot_vector(i, e)
05143                                           ! 1394 Bit16u i; ipl_entry_t *e;
05144                       00001370            _get_boot_vector:
05145                                           !BCC_EOS
05146                                           !BCC_EOS
05147                                           ! 1395 {
05148                                           ! 1396   Bit16u count;
05149                                           !BCC_EOS
05150                                           ! 1397   Bit16u ss = get_SS();
05151 1370           55                         push	bp
05152 1371           89E5                       mov	bp,sp
05153 1373           83C4                   FC  add	sp,*-4
05154                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05155 1376           E8         F2E6            call	_get_SS
05156                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
05157 1379           8946         FC            mov	-4[bp],ax
05158                                           !BCC_EOS
05159                                           ! 1398   count = _read_word(0x0080, 0x9ff0);
05160                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05161 137C           B8                   9FF0  mov	ax,#$9FF0
05162 137F           50                         push	ax
05163                                           ! Debug: list int = const $80 (used reg = )
05164 1380           B8                   0080  mov	ax,#$80
05165 1383           50                         push	ax
05166                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
05167 1384           E8         F26B            call	__read_word
05168 1387           83C4                   04  add	sp,*4
05169                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+6-4] (used reg = )
05170 138A           8946         FE            mov	-2[bp],ax
05171                                           !BCC_EOS
05172                                           ! 1399   if (i >= count) return 0;
05173                                           ! Debug: ge unsigned short count = [S+6-4] to unsigned short i = [S+6+2] (used reg = )
05174 138D           8B46         04            mov	ax,4[bp]
05175 1390           3B46         FE            cmp	ax,-2[bp]
05176 1393           72           06            jb  	.10C
05177                       00001395            .10D:
05178 1395           30C0                       xor	al,al
05179 1397           89EC                       mov	sp,bp
05180 1399           5D                         pop	bp
05181 139A           C3                         ret
05182                                           !BCC_EOS
05183                                           ! 1400   _memcpyb(e,ss,0x0000 + i * sizeof (*e),0x9ff0,sizeof (*e));
05184                       0000139B            .10C:
05185                                           ! Debug: list int = const $10 (used reg = )
05186 139B           B8                   0010  mov	ax,*$10
05187 139E           50                         push	ax
05188                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05189 139F           B8                   9FF0  mov	ax,#$9FF0
05190 13A2           50                         push	ax
05191                                           ! Debug: mul int = const $10 to unsigned short i = [S+$A+2] (used reg = )
05192 13A3           8B46         04            mov	ax,4[bp]
05193 13A6           B1                     04  mov	cl,*4
05194 13A8           D3E0                       shl	ax,cl
05195                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
05196                                           ! Debug: expression subtree swapping
05197                                           ! Debug: list unsigned int = ax+0 (used reg = )
05198 13AA           50                         push	ax
05199                                           ! Debug: list unsigned short ss = [S+$C-6] (used reg = )
05200 13AB           FF76         FC            push	-4[bp]
05201                                           ! Debug: list * struct  e = [S+$E+4] (used reg = )
05202 13AE           FF76         06            push	6[bp]
05203                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05204 13B1           E8         EC67            call	__memcpyb
05205 13B4           83C4                   0A  add	sp,*$A
05206                                           !BCC_EOS
05207                                           ! 1401   return 1;
05208 13B7           B0                     01  mov	al,*1
05209 13B9           89EC                       mov	sp,bp
05210 13BB           5D                         pop	bp
05211 13BC           C3                         ret
05212                                           !BCC_EOS
05213                                           ! 1402 }
05214                                           ! 1403   void
05215                                           ! 1404 interactive_bootkey()
05216                                           ! 1405 {
05217                                           export	_interactive_bootkey
05218                       000013BD            _interactive_bootkey:
05219                                           ! 1406   ipl_entry_t e;
05220                                           !BCC_EOS
05221                                           ! 1407   Bit16u count;
05222                                           !BCC_EOS
05223                                           ! 1408   char description[33];
05224                                           !BCC_EOS
05225                                           ! 1409   Bit8u scan_code;
05226                                           !BCC_EOS
05227                                           ! 1410   Bit8u i;
05228                                           !BCC_EOS
05229                                           ! 1411   Bit16u ss = get_SS();
05230 13BD           55                         push	bp
05231 13BE           89E5                       mov	bp,sp
05232 13C0           83C4                   C8  add	sp,*-$38
05233                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05234 13C3           E8         F299            call	_get_SS
05235                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$3A-$3A] (used reg = )
05236 13C6           8946         C8            mov	-$38[bp],ax
05237                                           !BCC_EOS
05238                                           ! 1412   Bit16u valid_choice = 0;
05239 13C9           4C                         dec	sp
05240 13CA           4C                         dec	sp
05241                                           ! Debug: eq int = const 0 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05242 13CB           31C0                       xor	ax,ax
05243 13CD           8946         C6            mov	-$3A[bp],ax
05244                                           !BCC_EOS
05245                                           ! 1413   while (check_for_keystroke())
05246                                           ! 1414     get_keystroke();
05247 13D0           EB           03            jmp .10F
05248                       000013D2            .110:
05249                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05250 13D2           E8         F530            call	_get_keystroke
05251                                           !BCC_EOS
05252                                           ! 1415   if ((inb_cmos(0x3f) & 0x01) == 0x01)
05253                       000013D5            .10F:
05254                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05255 13D5           E8         F51F            call	_check_for_keystroke
05256 13D8           84C0                       test	al,al
05257 13DA           75           F6            jne	.110
05258                       000013DC            .111:
05259                       000013DC            .10E:
05260                                           ! Debug: list int = const $3F (used reg = )
05261 13DC           B8                   003F  mov	ax,*$3F
05262 13DF           50                         push	ax
05263                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
05264 13E0           E8         F15A            call	_inb_cmos
05265 13E3           44                         inc	sp
05266 13E4           44                         inc	sp
05267                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
05268 13E5           24                     01  and	al,*1
05269                                           ! Debug: logeq int = const 1 to unsigned char = al+0 (used reg = )
05270 13E7           3C                     01  cmp	al,*1
05271 13E9           75           04            jne 	.112
05272                       000013EB            .113:
05273                                           ! 1416     return;
05274 13EB           89EC                       mov	sp,bp
05275 13ED           5D                         pop	bp
05276 13EE           C3                         ret
05277                                           !BCC_EOS
05278                                           ! 1417   bios_printf(2
05279                       000013EF            .112:
05280                                           ! 1417 , "Press F12 for boot menu.\n\n");
05281                                           ! Debug: list * char = .114+0 (used reg = )
05282 13EF           BB                   D923  mov	bx,#.114
05283 13F2           53                         push	bx
05284                                           ! Debug: list int = const 2 (used reg = )
05285 13F3           B8                   0002  mov	ax,*2
05286 13F6           50                         push	ax
05287                                           ! Debug: func () void = bios_printf+0 (used reg = )
05288 13F7           E8         F544            call	_bios_printf
05289 13FA           83C4                   04  add	sp,*4
05290                                           !BCC_EOS
05291                                           ! 1418   delay_ticks_and_check_for_keystroke(11, 5);
05292                                           ! Debug: list int = const 5 (used reg = )
05293 13FD           B8                   0005  mov	ax,*5
05294 1400           50                         push	ax
05295                                           ! Debug: list int = const $B (used reg = )
05296 1401           B8                   000B  mov	ax,*$B
05297 1404           50                         push	ax
05298                                           ! Debug: func () void = delay_ticks_and_check_for_keystroke+0 (used reg = )
05299 1405           E8         F505            call	_delay_ticks_and_check_for_keystroke
05300 1408           83C4                   04  add	sp,*4
05301                                           !BCC_EOS
05302                                           ! 1419   if (check_for_keystroke())
05303                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05304 140B           E8         F4E9            call	_check_for_keystroke
05305 140E           84C0                       test	al,al
05306 1410         0F84         01A1            beq 	.115
05307                       00001414            .116:
05308                                           ! 1420   {
05309                                           ! 1421     scan_code = get_keystroke();
05310                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05311 1414           E8         F4EE            call	_get_keystroke
05312                                           ! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05313 1417           8846         CC            mov	-$34[bp],al
05314                                           !BCC_EOS
05315                                           ! 1422     if (scan_code == 0x86)
05316                                           ! Debug: logeq int = const $86 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05317 141A           8A46         CC            mov	al,-$34[bp]
05318 141D           3C                     86  cmp	al,#$86
05319 141F         0F85         0192            bne 	.117
05320                       00001423            .118:
05321                                           ! 1423     {
05322                                           ! 1424       while (check_for_keystroke())
05323                                           ! 1425         get_keystroke();
05324 1423           EB           03            jmp .11A
05325                       00001425            .11B:
05326                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05327 1425           E8         F4DD            call	_get_keystroke
05328                                           !BCC_EOS
05329                                           ! 1426       bios_printf(2, "Select boot device:\n\n");
05330                       00001428            .11A:
05331                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05332 1428           E8         F4CC            call	_check_for_keystroke
05333 142B           84C0                       test	al,al
05334 142D           75           F6            jne	.11B
05335                       0000142F            .11C:
05336                       0000142F            .119:
05337                                           ! Debug: list * char = .11D+0 (used reg = )
05338 142F           BB                   D90D  mov	bx,#.11D
05339 1432           53                         push	bx
05340                                           ! Debug: list int = const 2 (used reg = )
05341 1433           B8                   0002  mov	ax,*2
05342 1436           50                         push	ax
05343                                           ! Debug: func () void = bios_printf+0 (used reg = )
05344 1437           E8         F504            call	_bios_printf
05345 143A           83C4                   04  add	sp,*4
05346                                           !BCC_EOS
05347                                           ! 1427       count = _read_word(0x0080, 0x9ff0);
05348                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05349 143D           B8                   9FF0  mov	ax,#$9FF0
05350 1440           50                         push	ax
05351                                           ! Debug: list int = const $80 (used reg = )
05352 1441           B8                   0080  mov	ax,#$80
05353 1444           50                         push	ax
05354                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
05355 1445           E8         F1AA            call	__read_word
05356 1448           83C4                   04  add	sp,*4
05357                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$3C-$14] (used reg = )
05358 144B           8946         EE            mov	-$12[bp],ax
05359                                           !BCC_EOS
05360                                           ! 1428       for (i = 0; i < count; i++)
05361                                           ! Debug: eq int = const 0 to unsigned char i = [S+$3C-$37] (used reg = )
05362 144E           30C0                       xor	al,al
05363 1450           8846         CB            mov	-$35[bp],al
05364                                           !BCC_EOS
05365                                           !BCC_EOS
05366                                           ! 1429       {
05367 1453           E9         00EC            br 	.120
05368                       00001456            .121:
05369                                           ! 1430         _memcpyb(&e,ss,0x0000 + i * sizeof (e),0x9ff0,sizeof (e));
05370                                           ! Debug: list int = const $10 (used reg = )
05371 1456           B8                   0010  mov	ax,*$10
05372 1459           50                         push	ax
05373                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05374 145A           B8                   9FF0  mov	ax,#$9FF0
05375 145D           50                         push	ax
05376                                           ! Debug: mul int = const $10 to unsigned char i = [S+$40-$37] (used reg = )
05377 145E           8A46         CB            mov	al,-$35[bp]
05378 1461           30E4                       xor	ah,ah
05379 1463           B1                     04  mov	cl,*4
05380 1465           D3E0                       shl	ax,cl
05381                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
05382                                           ! Debug: expression subtree swapping
05383                                           ! Debug: list unsigned int = ax+0 (used reg = )
05384 1467           50                         push	ax
05385                                           ! Debug: list unsigned short ss = [S+$42-$3A] (used reg = )
05386 1468           FF76         C8            push	-$38[bp]
05387                                           ! Debug: list * struct  e = S+$44-$12 (used reg = )
05388 146B           8D5E         F0            lea	bx,-$10[bp]
05389 146E           53                         push	bx
05390                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05391 146F           E8         EBA9            call	__memcpyb
05392 1472           83C4                   0A  add	sp,*$A
05393                                           !BCC_EOS
05394                                           ! 1431         bios_printf(2, "%d. ", i+1);
05395                                           ! Debug: add int = const 1 to unsigned char i = [S+$3C-$37] (used reg = )
05396 1475           8A46         CB            mov	al,-$35[bp]
05397 1478           30E4                       xor	ah,ah
05398                                           ! Debug: list unsigned int = ax+1 (used reg = )
05399 147A           40                         inc	ax
05400 147B           50                         push	ax
05401                                           ! Debug: list * char = .122+0 (used reg = )
05402 147C           BB                   D908  mov	bx,#.122
05403 147F           53                         push	bx
05404                                           ! Debug: list int = const 2 (used reg = )
05405 1480           B8                   0002  mov	ax,*2
05406 1483           50                         push	ax
05407                                           ! Debug: func () void = bios_printf+0 (used reg = )
05408 1484           E8         F4B7            call	_bios_printf
05409 1487           83C4                   06  add	sp,*6
05410                                           !BCC_EOS
05411                                           ! 1432         switch(e.type)
05412 148A           8B46         F0            mov	ax,-$10[bp]
05413                                           ! 1433         {
05414 148D           E9         008F            br 	.125
05415                                           ! 1434           case 0x01:
05416                                           ! 1435           case 0x02:
05417                       00001490            .126:
05418                                           ! 1436           case 0x03:
05419                       00001490            .127:
05420                                           ! 1437             bios_printf(2, "%s\n", drivetypes[e.type]);
05421                       00001490            .128:
05422                                           ! Debug: ptradd unsigned short e = [S+$3C-$12] to [5] [$A] char = drivetypes+0 (used reg = )
05423 1490           8B5E         F0            mov	bx,-$10[bp]
05424 1493           89DA                       mov	dx,bx
05425 1495           D1E3                       shl	bx,*1
05426 1497           D1E3                       shl	bx,*1
05427 1499           01D3                       add	bx,dx
05428 149B           D1E3                       shl	bx,*1
05429                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
05430                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
05431 149D           81C3                 120F  add	bx,#_drivetypes
05432 14A1           53                         push	bx
05433                                           ! Debug: list * char = .129+0 (used reg = )
05434 14A2           BB                   D904  mov	bx,#.129
05435 14A5           53                         push	bx
05436                                           ! Debug: list int = const 2 (used reg = )
05437 14A6           B8                   0002  mov	ax,*2
05438 14A9           50                         push	ax
05439                                           ! Debug: func () void = bios_printf+0 (used reg = )
05440 14AA           E8         F491            call	_bios_printf
05441 14AD           83C4                   06  add	sp,*6
05442                                           !BCC_EOS
05443                                           ! 1438             break;
05444 14B0           E9         0088            br 	.123
05445                                           !BCC_EOS
05446                                           ! 1439           case 0x80:
05447                                           ! 1440             bios_printf(2, "%s", drivetypes[4]);
05448                       000014B3            .12A:
05449                                           ! Debug: list * char = drivetypes+$28 (used reg = )
05450 14B3           BB                   1237  mov	bx,#_drivetypes+$28
05451 14B6           53                         push	bx
05452                                           ! Debug: list * char = .12B+0 (used reg = )
05453 14B7           BB                   D901  mov	bx,#.12B
05454 14BA           53                         push	bx
05455                                           ! Debug: list int = const 2 (used reg = )
05456 14BB           B8                   0002  mov	ax,*2
05457 14BE           50                         push	ax
05458                                           ! Debug: func () void = bios_printf+0 (used reg = )
05459 14BF           E8         F47C            call	_bios_printf
05460 14C2           83C4                   06  add	sp,*6
05461                                           !BCC_EOS
05462                                           ! 1441             if (e.description != 0)
05463                                           ! Debug: ne unsigned long = const 0 to unsigned long e = [S+$3C-$A] (used reg = )
05464                                           ! Debug: expression subtree swapping
05465 14C5           31C0                       xor	ax,ax
05466 14C7           31DB                       xor	bx,bx
05467 14C9           53                         push	bx
05468 14CA           50                         push	ax
05469 14CB           8B46         F8            mov	ax,-8[bp]
05470 14CE           8B5E         FA            mov	bx,-6[bp]
05471 14D1           8D7E         C2            lea	di,-2+..FFFF[bp]
05472 14D4           E8         EBC5            call	lcmpul
05473 14D7           8D66         C6            lea	sp,2+..FFFF[bp]
05474 14DA           74           31            je  	.12C
05475                       000014DC            .12D:
05476                                           ! 1442             {
05477                                           ! 1443               _memcpyb(&description,ss,*((Bit16u *)&e.description),*(((Bit16u *)&e.description)+1),32);
05478                                           ! Debug: list int = const $20 (used reg = )
05479 14DC           B8                   0020  mov	ax,*$20
05480 14DF           50                         push	ax
05481                                           ! Debug: list unsigned short e = [S+$3E-8] (used reg = )
05482 14E0           FF76         FA            push	-6[bp]
05483                                           ! Debug: list unsigned short e = [S+$40-$A] (used reg = )
05484 14E3           FF76         F8            push	-8[bp]
05485                                           ! Debug: list unsigned short ss = [S+$42-$3A] (used reg = )
05486 14E6           FF76         C8            push	-$38[bp]
05487                                           ! Debug: list * [$21] char description = S+$44-$35 (used reg = )
05488 14E9           8D5E         CD            lea	bx,-$33[bp]
05489 14EC           53                         push	bx
05490                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05491 14ED           E8         EB2B            call	__memcpyb
05492 14F0           83C4                   0A  add	sp,*$A
05493                                           !BCC_EOS
05494                                           ! 1444               description[32] = 0;
05495                                           ! Debug: eq int = const 0 to char description = [S+$3C-$15] (used reg = )
05496 14F3           30C0                       xor	al,al
05497 14F5           8846         ED            mov	-$13[bp],al
05498                                           !BCC_EOS
05499                                           ! 1445               bios_printf(2, " [%S]", ss, description);
05500                                           ! Debug: list * char description = S+$3C-$35 (used reg = )
05501 14F8           8D5E         CD            lea	bx,-$33[bp]
05502 14FB           53                         push	bx
05503                                           ! Debug: list unsigned short ss = [S+$3E-$3A] (used reg = )
05504 14FC           FF76         C8            push	-$38[bp]
05505                                           ! Debug: list * char = .12E+0 (used reg = )
05506 14FF           BB                   D8FB  mov	bx,#.12E
05507 1502           53                         push	bx
05508                                           ! Debug: list int = const 2 (used reg = )
05509 1503           B8                   0002  mov	ax,*2
05510 1506           50                         push	ax
05511                                           ! Debug: func () void = bios_printf+0 (used reg = )
05512 1507           E8         F434            call	_bios_printf
05513 150A           83C4                   08  add	sp,*8
05514                                           !BCC_EOS
05515                                           ! 1446            }
05516                                           ! 1447            bios_printf(2, "\n");
05517                       0000150D            .12C:
05518                                           ! Debug: list * char = .12F+0 (used reg = )
05519 150D           BB                   D8F9  mov	bx,#.12F
05520 1510           53                         push	bx
05521                                           ! Debug: list int = const 2 (used reg = )
05522 1511           B8                   0002  mov	ax,*2
05523 1514           50                         push	ax
05524                                           ! Debug: func () void = bios_printf+0 (used reg = )
05525 1515           E8         F426            call	_bios_printf
05526 1518           83C4                   04  add	sp,*4
05527                                           !BCC_EOS
05528                                           ! 1448            break;
05529 151B           EB           1E            jmp .123
05530                                           !BCC_EOS
05531                                           ! 1449         }
05532                                           ! 1450       }
05533 151D           EB           1C            jmp .123
05534                       0000151F            .125:
05535 151F           2D                   0001  sub	ax,*1
05536 1522         0F84         FF6A            beq 	.126
05537 1526           2D                   0001  sub	ax,*1
05538 1529         0F84         FF63            beq 	.127
05539 152D           2D                   0001  sub	ax,*1
05540 1530         0F84         FF5C            beq 	.128
05541 1534           2D                   007D  sub	ax,*$7D
05542 1537         0F84         FF78            beq 	.12A
05543                       0000153B            .123:
05544                       FFFFFFC4            ..FFFF	=	-$3C
05545                                           ! 1451       count++;
05546                       0000153B            .11F:
05547                                           ! Debug: postinc unsigned char i = [S+$3C-$37] (used reg = )
05548 153B           8A46         CB            mov	al,-$35[bp]
05549 153E           40                         inc	ax
05550 153F           8846         CB            mov	-$35[bp],al
05551                       00001542            .120:
05552                                           ! Debug: lt unsigned short count = [S+$3C-$14] to unsigned char i = [S+$3C-$37] (used reg = )
05553 1542           8A46         CB            mov	al,-$35[bp]
05554 1545           30E4                       xor	ah,ah
05555 1547           3B46         EE            cmp	ax,-$12[bp]
05556 154A         0F82         FF08            blo 	.121
05557                       0000154E            .130:
05558                       0000154E            .11E:
05559                                           ! Debug: postinc unsigned short count = [S+$3C-$14] (used reg = )
05560 154E           8B46         EE            mov	ax,-$12[bp]
05561 1551           40                         inc	ax
05562 1552           8946         EE            mov	-$12[bp],ax
05563                                           !BCC_EOS
05564                                           ! 1452       while (!valid_choice) {
05565 1555           EB           49            jmp .132
05566                       00001557            .133:
05567                                           ! 1453         scan_code = get_keystroke();
05568                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05569 1557           E8         F3AB            call	_get_keystroke
05570                                           ! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05571 155A           8846         CC            mov	-$34[bp],al
05572                                           !BCC_EOS
05573                                           ! 1454         if (scan_code == 0x01 || scan_code == 0x58)
05574                                           ! Debug: logeq int = const 1 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05575 155D           8A46         CC            mov	al,-$34[bp]
05576 1560           3C                     01  cmp	al,*1
05577 1562           74           07            je  	.135
05578                       00001564            .136:
05579                                           ! Debug: logeq int = const $58 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05580 1564           8A46         CC            mov	al,-$34[bp]
05581 1567           3C                     58  cmp	al,*$58
05582 1569           75           08            jne 	.134
05583                       0000156B            .135:
05584                                           ! 1455         {
05585                                           ! 1456           valid_choice = 1;
05586                                           ! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05587 156B           B8                   0001  mov	ax,*1
05588 156E           8946         C6            mov	-$3A[bp],ax
05589                                           !BCC_EOS
05590                                           ! 1457         }
05591                                           ! 1458         else if (scan_code <= count)
05592 1571           EB           2D            jmp .137
05593                       00001573            .134:
05594                                           ! Debug: le unsigned short count = [S+$3C-$14] to unsigned char scan_code = [S+$3C-$36] (used reg = )
05595 1573           8A46         CC            mov	al,-$34[bp]
05596 1576           30E4                       xor	ah,ah
05597 1578           3B46         EE            cmp	ax,-$12[bp]
05598 157B           77           23            ja  	.138
05599                       0000157D            .139:
05600                                           ! 1459         {
05601                                           ! 1460           valid_choice = 1;
05602                                           ! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05603 157D           B8                   0001  mov	ax,*1
05604 1580           8946         C6            mov	-$3A[bp],ax
05605                                           !BCC_EOS
05606                                           ! 1461           scan_code -= 1;
05607                                           ! Debug: subab int = const 1 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05608 1583           8A46         CC            mov	al,-$34[bp]
05609 1586           30E4                       xor	ah,ah
05610 1588           48                         dec	ax
05611 1589           8846         CC            mov	-$34[bp],al
05612                                           !BCC_EOS
05613                                           ! 1462           _write_word(scan_code, 0x0084, 0x9ff0);
05614                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05615 158C           B8                   9FF0  mov	ax,#$9FF0
05616 158F           50                         push	ax
05617                                           ! Debug: list int = const $84 (used reg = )
05618 1590           B8                   0084  mov	ax,#$84
05619 1593           50                         push	ax
05620                                           ! Debug: list unsigned char scan_code = [S+$40-$36] (used reg = )
05621 1594           8A46         CC            mov	al,-$34[bp]
05622 1597           30E4                       xor	ah,ah
05623 1599           50                         push	ax
05624                                           ! Debug: func () void = _write_word+0 (used reg = )
05625 159A           E8         F076            call	__write_word
05626 159D           83C4                   06  add	sp,*6
05627                                           !BCC_EOS
05628                                           ! 1463         }
05629                                           ! 1464       }
05630                       000015A0            .138:
05631                       000015A0            .137:
05632                                           ! 1465       bios_printf(2, "\n");
05633                       000015A0            .132:
05634 15A0           8B46         C6            mov	ax,-$3A[bp]
05635 15A3           85C0                       test	ax,ax
05636 15A5           74           B0            je 	.133
05637                       000015A7            .13A:
05638                       000015A7            .131:
05639                                           ! Debug: list * char = .13B+0 (used reg = )
05640 15A7           BB                   D8F7  mov	bx,#.13B
05641 15AA           53                         push	bx
05642                                           ! Debug: list int = const 2 (used reg = )
05643 15AB           B8                   0002  mov	ax,*2
05644 15AE           50                         push	ax
05645                                           ! Debug: func () void = bios_printf+0 (used reg = )
05646 15AF           E8         F38C            call	_bios_printf
05647 15B2           83C4                   04  add	sp,*4
05648                                           !BCC_EOS
05649                                           ! 1466     }
05650                                           ! 1467   }
05651                       000015B5            .117:
05652                                           ! 1468 }
05653                       000015B5            .115:
05654 15B5           89EC                       mov	sp,bp
05655 15B7           5D                         pop	bp
05656 15B8           C3                         ret
05657                                           ! 1469 void
05658                                           ! Register BX used in function interactive_bootkey
05659                                           ! 1470 print_boot_device(e)
05660                                           ! 1471   ipl_entry_t *e;
05661                                           export	_print_boot_device
05662                       000015B9            _print_boot_device:
05663                                           !BCC_EOS
05664                                           ! 1472 {
05665                                           ! 1473   Bit16u type;
05666                                           !BCC_EOS
05667                                           ! 1474   char description[33];
05668                                           !BCC_EOS
05669                                           ! 1475   Bit16u ss = get_SS();
05670 15B9           55                         push	bp
05671 15BA           89E5                       mov	bp,sp
05672 15BC           83C4                   DA  add	sp,*-$26
05673                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05674 15BF           E8         F09D            call	_get_SS
05675                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$28-$28] (used reg = )
05676 15C2           8946         DA            mov	-$26[bp],ax
05677                                           !BCC_EOS
05678                                           ! 1476   type = e->type;
05679 15C5           8B5E         04            mov	bx,4[bp]
05680                                           ! Debug: eq unsigned short = [bx+0] to unsigned short type = [S+$28-4] (used reg = )
05681 15C8           8B1F                       mov	bx,[bx]
05682 15CA           895E         FE            mov	-2[bp],bx
05683                                           !BCC_EOS
05684                                           ! 1477   if (type == 0x80) type = 0x4;
05685                                           ! Debug: logeq int = const $80 to unsigned short type = [S+$28-4] (used reg = )
05686 15CD           8B46         FE            mov	ax,-2[bp]
05687 15D0           3D                   0080  cmp	ax,#$80
05688 15D3           75           06            jne 	.13C
05689                       000015D5            .13D:
05690                                           ! Debug: eq int = const 4 to unsigned short type = [S+$28-4] (used reg = )
05691 15D5           B8                   0004  mov	ax,*4
05692 15D8           8946         FE            mov	-2[bp],ax
05693                                           !BCC_EOS
05694                                           ! 1478   if (type == 0 || type > 0x4) bios_printf((2 | 4 | 1), "Bad drive type\n");
05695                       000015DB            .13C:
05696                                           ! Debug: logeq int = const 0 to unsigned short type = [S+$28-4] (used reg = )
05697 15DB           8B46         FE            mov	ax,-2[bp]
05698 15DE           85C0                       test	ax,ax
05699 15E0           74           08            je  	.13F
05700                       000015E2            .140:
05701                                           ! Debug: gt int = const 4 to unsigned short type = [S+$28-4] (used reg = )
05702 15E2           8B46         FE            mov	ax,-2[bp]
05703 15E5           3D                   0004  cmp	ax,*4
05704 15E8           76           0E            jbe 	.13E
05705                       000015EA            .13F:
05706                                           ! Debug: list * char = .141+0 (used reg = )
05707 15EA           BB                   D8E7  mov	bx,#.141
05708 15ED           53                         push	bx
05709                                           ! Debug: list int = const 7 (used reg = )
05710 15EE           B8                   0007  mov	ax,*7
05711 15F1           50                         push	ax
05712                                           ! Debug: func () void = bios_printf+0 (used reg = )
05713 15F2           E8         F349            call	_bios_printf
05714 15F5           83C4                   04  add	sp,*4
05715                                           !BCC_EOS
05716                                           ! 1479   bios_printf(2, "Booting from %s", drivetypes[type]);
05717                       000015F8            .13E:
05718                                           ! Debug: ptradd unsigned short type = [S+$28-4] to [5] [$A] char = drivetypes+0 (used reg = )
05719 15F8           8B5E         FE            mov	bx,-2[bp]
05720 15FB           89DA                       mov	dx,bx
05721 15FD           D1E3                       shl	bx,*1
05722 15FF           D1E3                       shl	bx,*1
05723 1601           01D3                       add	bx,dx
05724 1603           D1E3                       shl	bx,*1
05725                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
05726                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
05727 1605           81C3                 120F  add	bx,#_drivetypes
05728 1609           53                         push	bx
05729                                           ! Debug: list * char = .142+0 (used reg = )
05730 160A           BB                   D8D7  mov	bx,#.142
05731 160D           53                         push	bx
05732                                           ! Debug: list int = const 2 (used reg = )
05733 160E           B8                   0002  mov	ax,*2
05734 1611           50                         push	ax
05735                                           ! Debug: func () void = bios_printf+0 (used reg = )
05736 1612           E8         F329            call	_bios_printf
05737 1615           83C4                   06  add	sp,*6
05738                                           !BCC_EOS
05739                                           ! 1480   if (type == 4 && e->description != 0) {
05740                                           ! Debug: logeq int = const 4 to unsigned short type = [S+$28-4] (used reg = )
05741 1618           8B46         FE            mov	ax,-2[bp]
05742 161B           3D                   0004  cmp	ax,*4
05743 161E           75           51            jne 	.143
05744                       00001620            .145:
05745 1620           8B5E         04            mov	bx,4[bp]
05746                                           ! Debug: ne unsigned long = const 0 to unsigned long = [bx+8] (used reg = )
05747                                           ! Debug: expression subtree swapping
05748 1623           31C0                       xor	ax,ax
05749 1625           31F6                       xor	si,si
05750 1627           56                         push	si
05751 1628           50                         push	ax
05752 1629           8B47         08            mov	ax,8[bx]
05753 162C           8B5F         0A            mov	bx,$A[bx]
05754 162F           8D7E         D6            lea	di,-$2A[bp]
05755 1632           E8         EA67            call	lcmpul
05756 1635           8D66         DA            lea	sp,-$26[bp]
05757 1638           74           37            je  	.143
05758                       0000163A            .144:
05759                                           ! 1481     _memcpyb(&description,ss,*((Bit16u *)&e->description),*(((Bit16u *)&e->description)+1),32);
05760                                           ! Debug: list int = const $20 (used reg = )
05761 163A           B8                   0020  mov	ax,*$20
05762 163D           50                         push	ax
05763 163E           8B5E         04            mov	bx,4[bp]
05764                                           ! Debug: address unsigned long = [bx+8] (used reg = )
05765                                           ! Debug: cast * unsigned short = const 0 to * unsigned long = bx+8 (used reg = )
05766                                           ! Debug: ptradd int = const 1 to * unsigned short = bx+8 (used reg = )
05767                                           ! Debug: list unsigned short = [bx+$A] (used reg = )
05768 1641           FF77         0A            push	$A[bx]
05769 1644           8B5E         04            mov	bx,4[bp]
05770                                           ! Debug: address unsigned long = [bx+8] (used reg = )
05771                                           ! Debug: cast * unsigned short = const 0 to * unsigned long = bx+8 (used reg = )
05772                                           ! Debug: list unsigned short = [bx+8] (used reg = )
05773 1647           FF77         08            push	8[bx]
05774                                           ! Debug: list unsigned short ss = [S+$2E-$28] (used reg = )
05775 164A           FF76         DA            push	-$26[bp]
05776                                           ! Debug: list * [$21] char description = S+$30-$25 (used reg = )
05777 164D           8D5E         DD            lea	bx,-$23[bp]
05778 1650           53                         push	bx
05779                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05780 1651           E8         E9C7            call	__memcpyb
05781 1654           83C4                   0A  add	sp,*$A
05782                                           !BCC_EOS
05783                                           ! 1482     description[32] = 0;
05784                                           ! Debug: eq int = const 0 to char description = [S+$28-5] (used reg = )
05785 1657           30C0                       xor	al,al
05786 1659           8846         FD            mov	-3[bp],al
05787                                           !BCC_EOS
05788                                           ! 1483     bios_printf(2, " [%S]", ss, description);
05789                                           ! Debug: list * char description = S+$28-$25 (used reg = )
05790 165C           8D5E         DD            lea	bx,-$23[bp]
05791 165F           53                         push	bx
05792                                           ! Debug: list unsigned short ss = [S+$2A-$28] (used reg = )
05793 1660           FF76         DA            push	-$26[bp]
05794                                           ! Debug: list * char = .146+0 (used reg = )
05795 1663           BB                   D8D1  mov	bx,#.146
05796 1666           53                         push	bx
05797                                           ! Debug: list int = const 2 (used reg = )
05798 1667           B8                   0002  mov	ax,*2
05799 166A           50                         push	ax
05800                                           ! Debug: func () void = bios_printf+0 (used reg = )
05801 166B           E8         F2D0            call	_bios_printf
05802 166E           83C4                   08  add	sp,*8
05803                                           !BCC_EOS
05804                                           ! 1484   }
05805                                           ! 1485   bios_printf(2, "...\n");
05806                       00001671            .143:
05807                                           ! Debug: list * char = .147+0 (used reg = )
05808 1671           BB                   D8CC  mov	bx,#.147
05809 1674           53                         push	bx
05810                                           ! Debug: list int = const 2 (used reg = )
05811 1675           B8                   0002  mov	ax,*2
05812 1678           50                         push	ax
05813                                           ! Debug: func () void = bios_printf+0 (used reg = )
05814 1679           E8         F2C2            call	_bios_printf
05815 167C           83C4                   04  add	sp,*4
05816                                           !BCC_EOS
05817                                           ! 1486 }
05818 167F           89EC                       mov	sp,bp
05819 1681           5D                         pop	bp
05820 1682           C3                         ret
05821                                           ! 1487   void
05822                                           ! Register BX used in function print_boot_device
05823                                           ! 1488 print_boot_failure(type, reason)
05824                                           ! 1489   Bit16u type; Bit8u reason;
05825                                           export	_print_boot_failure
05826                       00001683            _print_boot_failure:
05827                                           !BCC_EOS
05828                                           !BCC_EOS
05829                                           ! 1490 {
05830                                           ! 1491   if (t
05831 1683           55                         push	bp
05832 1684           89E5                       mov	bp,sp
05833                                           ! 1491 ype == 0 || type > 0x3) bios_printf((2 | 4 | 1), "Bad drive type\n");
05834                                           ! Debug: logeq int = const 0 to unsigned short type = [S+2+2] (used reg = )
05835 1686           8B46         04            mov	ax,4[bp]
05836 1689           85C0                       test	ax,ax
05837 168B           74           08            je  	.149
05838                       0000168D            .14A:
05839                                           ! Debug: gt int = const 3 to unsigned short type = [S+2+2] (used reg = )
05840 168D           8B46         04            mov	ax,4[bp]
05841 1690           3D                   0003  cmp	ax,*3
05842 1693           76           0D            jbe 	.148
05843                       00001695            .149:
05844                                           ! Debug: list * char = .14B+0 (used reg = )
05845 1695           BB                   D8BC  mov	bx,#.14B
05846 1698           53                         push	bx
05847                                           ! Debug: list int = const 7 (used reg = )
05848 1699           B8                   0007  mov	ax,*7
05849 169C           50                         push	ax
05850                                           ! Debug: func () void = bios_printf+0 (used reg = )
05851 169D           E8         F29E            call	_bios_printf
05852 16A0           89EC                       mov	sp,bp
05853                                           !BCC_EOS
05854                                           ! 1492   bios_printf(2, "Boot failed");
05855                       000016A2            .148:
05856                                           ! Debug: list * char = .14C+0 (used reg = )
05857 16A2           BB                   D8B0  mov	bx,#.14C
05858 16A5           53                         push	bx
05859                                           ! Debug: list int = const 2 (used reg = )
05860 16A6           B8                   0002  mov	ax,*2
05861 16A9           50                         push	ax
05862                                           ! Debug: func () void = bios_printf+0 (used reg = )
05863 16AA           E8         F291            call	_bios_printf
05864 16AD           89EC                       mov	sp,bp
05865                                           !BCC_EOS
05866                                           ! 1493   if (type < 4) {
05867                                           ! Debug: lt int = const 4 to unsigned short type = [S+2+2] (used reg = )
05868 16AF           8B46         04            mov	ax,4[bp]
05869 16B2           3D                   0004  cmp	ax,*4
05870 16B5           73           23            jae 	.14D
05871                       000016B7            .14E:
05872                                           ! 1494     if (reason==0)
05873                                           ! Debug: logeq int = const 0 to unsigned char reason = [S+2+4] (used reg = )
05874 16B7           8A46         06            mov	al,6[bp]
05875 16BA           84C0                       test	al,al
05876 16BC           75           0F            jne 	.14F
05877                       000016BE            .150:
05878                                           ! 1495       bios_printf(2, ": not a bootable disk");
05879                                           ! Debug: list * char = .151+0 (used reg = )
05880 16BE           BB                   D89A  mov	bx,#.151
05881 16C1           53                         push	bx
05882                                           ! Debug: list int = const 2 (used reg = )
05883 16C2           B8                   0002  mov	ax,*2
05884 16C5           50                         push	ax
05885                                           ! Debug: func () void = bios_printf+0 (used reg = )
05886 16C6           E8         F275            call	_bios_printf
05887 16C9           89EC                       mov	sp,bp
05888                                           !BCC_EOS
05889                                           ! 1496     else
05890                                           ! 1497       bios_printf(2, ": could not read the boot disk");
05891 16CB           EB           0D            jmp .152
05892                       000016CD            .14F:
05893                                           ! Debug: list * char = .153+0 (used reg = )
05894 16CD           BB                   D87B  mov	bx,#.153
05895 16D0           53                         push	bx
05896                                           ! Debug: list int = const 2 (used reg = )
05897 16D1           B8                   0002  mov	ax,*2
05898 16D4           50                         push	ax
05899                                           ! Debug: func () void = bios_printf+0 (used reg = )
05900 16D5           E8         F266            call	_bios_printf
05901 16D8           89EC                       mov	sp,bp
05902                                           !BCC_EOS
05903                                           ! 1498   }
05904                       000016DA            .152:
05905                                           ! 1499   bios_printf(2, "\n\n");
05906                       000016DA            .14D:
05907                                           ! Debug: list * char = .154+0 (used reg = )
05908 16DA           BB                   D878  mov	bx,#.154
05909 16DD           53                         push	bx
05910                                           ! Debug: list int = const 2 (used reg = )
05911 16DE           B8                   0002  mov	ax,*2
05912 16E1           50                         push	ax
05913                                           ! Debug: func () void = bios_printf+0 (used reg = )
05914 16E2           E8         F259            call	_bios_printf
05915 16E5           89EC                       mov	sp,bp
05916                                           !BCC_EOS
05917                                           ! 1500 }
05918 16E7           5D                         pop	bp
05919 16E8           C3                         ret
05920                                           ! 1501   void
05921                                           ! Register BX used in function print_boot_failure
05922                                           ! 1502 print_cdromboot_failure( code )
05923                                           ! 1503   Bit16u code;
05924                                           export	_print_cdromboot_failure
05925                       000016E9            _print_cdromboot_failure:
05926                                           !BCC_EOS
05927                                           ! 1504 {
05928                                           ! 1505   bios_printf(2 | 4, "CDROM boot failure code : %04x\n",code);
05929 16E9           55                         push	bp
05930 16EA           89E5                       mov	bp,sp
05931                                           ! Debug: list unsigned short code = [S+2+2] (used reg = )
05932 16EC           FF76         04            push	4[bp]
05933                                           ! Debug: list * char = .155+0 (used reg = )
05934 16EF           BB                   D858  mov	bx,#.155
05935 16F2           53                         push	bx
05936                                           ! Debug: list int = const 6 (used reg = )
05937 16F3           B8                   0006  mov	ax,*6
05938 16F6           50                         push	ax
05939                                           ! Debug: func () void = bios_printf+0 (used reg = )
05940 16F7           E8         F244            call	_bios_printf
05941 16FA           89EC                       mov	sp,bp
05942                                           !BCC_EOS
05943                                           ! 1506   return;
05944 16FC           5D                         pop	bp
05945 16FD           C3                         ret
05946                                           !BCC_EOS
05947                                           ! 1507 }
05948                                           ! 1508 void
05949                                           ! Register BX used in function print_cdromboot_failure
05950                                           ! 1509 nmi_handler_msg()
05951                                           ! 1510 {
05952                                           export	_nmi_handler_msg
05953                       000016FE            _nmi_handler_msg:
05954                                           ! 1511   bios_printf((2 | 4 | 1), "NMI Handler called\n");
05955 16FE           55                         push	bp
05956 16FF           89E5                       mov	bp,sp
05957                                           ! Debug: list * char = .156+0 (used reg = )
05958 1701           BB                   D844  mov	bx,#.156
05959 1704           53                         push	bx
05960                                           ! Debug: list int = const 7 (used reg = )
05961 1705           B8                   0007  mov	ax,*7
05962 1708           50                         push	ax
05963                                           ! Debug: func () void = bios_printf+0 (used reg = )
05964 1709           E8         F232            call	_bios_printf
05965 170C           89EC                       mov	sp,bp
05966                                           !BCC_EOS
05967                                           ! 1512 }
05968 170E           5D                         pop	bp
05969 170F           C3                         ret
05970                                           ! 1513 void
05971                                           ! Register BX used in function nmi_handler_msg
05972                                           ! 1514 int18_panic_msg()
05973                                           ! 1515 {
05974                                           export	_int18_panic_msg
05975                       00001710            _int18_panic_msg:
05976                                           ! 1516   bios_printf((2 | 4 | 1), "INT18: BOOT FAILURE\n");
05977 1710           55                         push	bp
05978 1711           89E5                       mov	bp,sp
05979                                           ! Debug: list * char = .157+0 (used reg = )
05980 1713           BB                   D82F  mov	bx,#.157
05981 1716           53                         push	bx
05982                                           ! Debug: list int = const 7 (used reg = )
05983 1717           B8                   0007  mov	ax,*7
05984 171A           50                         push	ax
05985                                           ! Debug: func () void = bios_printf+0 (used reg = )
05986 171B           E8         F220            call	_bios_printf
05987 171E           89EC                       mov	sp,bp
05988                                           !BCC_EOS
05989                                           ! 1517 }
05990 1720           5D                         pop	bp
05991 1721           C3                         ret
05992                                           ! 1518 void
05993                                           ! Register BX used in function int18_panic_msg
05994                                           ! 1519 log_bios_start()
05995                                           ! 1520 {
05996                                           export	_log_bios_start
05997                       00001722            _log_bios_start:
05998                                           ! 1521   bios_printf(4, "%s\n", bios_svn_version_string);
05999 1722           55                         push	bp
06000 1723           89E5                       mov	bp,sp
06001                                           ! Debug: list * char = bios_svn_version_string+0 (used reg = )
06002 1725           BB                   016C  mov	bx,#_bios_svn_version_string
06003 1728           53                         push	bx
06004                                           ! Debug: list * char = .158+0 (used reg = )
06005 1729           BB                   D82B  mov	bx,#.158
06006 172C           53                         push	bx
06007                                           ! Debug: list int = const 4 (used reg = )
06008 172D           B8                   0004  mov	ax,*4
06009 1730           50                         push	ax
06010                                           ! Debug: func () void = bios_printf+0 (used reg = )
06011 1731           E8         F20A            call	_bios_printf
06012 1734           89EC                       mov	sp,bp
06013                                           !BCC_EOS
06014                                           ! 1522 }
06015 1736           5D                         pop	bp
06016 1737           C3                         ret
06017                                           ! 1523   bx_bool
06018                                           ! Register BX used in function log_bios_start
06019                                           ! 1524 set_enable_a20(val)
06020                                           ! 1525   bx_bool val;
06021                                           export	_set_enable_a20
06022                       00001738            _set_enable_a20:
06023                                           !BCC_EOS
06024                                           ! 1526 {
06025                                           ! 1527   Bit8u oldval;
06026                                           !BCC_EOS
06027                                           ! 1528   oldval = inb(0x0092);
06028 1738           55                         push	bp
06029 1739           89E5                       mov	bp,sp
06030 173B           4C                         dec	sp
06031 173C           4C                         dec	sp
06032                                           ! Debug: list int = const $92 (used reg = )
06033 173D           B8                   0092  mov	ax,#$92
06034 1740           50                         push	ax
06035                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06036 1741           E8         EDB4            call	_inb
06037 1744           44                         inc	sp
06038 1745           44                         inc	sp
06039                                           ! Debug: eq unsigned char = al+0 to unsigned char oldval = [S+4-3] (used reg = )
06040 1746           8846         FF            mov	-1[bp],al
06041                                           !BCC_EOS
06042                                           ! 1529   if (val)
06043 1749           8B46         04            mov	ax,4[bp]
06044 174C           85C0                       test	ax,ax
06045 174E           74           14            je  	.159
06046                       00001750            .15A:
06047                                           ! 1530     outb(0x0092, oldval | 0x02);
06048                                           ! Debug: or int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
06049 1750           8A46         FF            mov	al,-1[bp]
06050 1753           0C                     02  or	al,*2
06051                                           ! Debug: list unsigned char = al+0 (used reg = )
06052 1755           30E4                       xor	ah,ah
06053 1757           50                         push	ax
06054                                           ! Debug: list int = const $92 (used reg = )
06055 1758           B8                   0092  mov	ax,#$92
06056 175B           50                         push	ax
06057                                           ! Debug: func () void = outb+0 (used reg = )
06058 175C           E8         EDAF            call	_outb
06059 175F           83C4                   04  add	sp,*4
06060                                           !BCC_EOS
06061                                           ! 1531   else
06062                                           ! 1532     outb(0x0092, oldval & 0xfd);
06063 1762           EB           12            jmp .15B
06064                       00001764            .159:
06065                                           ! Debug: and int = const $FD to unsigned char oldval = [S+4-3] (used reg = )
06066 1764           8A46         FF            mov	al,-1[bp]
06067 1767           24                     FD  and	al,#$FD
06068                                           ! Debug: list unsigned char = al+0 (used reg = )
06069 1769           30E4                       xor	ah,ah
06070 176B           50                         push	ax
06071                                           ! Debug: list int = const $92 (used reg = )
06072 176C           B8                   0092  mov	ax,#$92
06073 176F           50                         push	ax
06074                                           ! Debug: func () void = outb+0 (used reg = )
06075 1770           E8         ED9B            call	_outb
06076 1773           83C4                   04  add	sp,*4
06077                                           !BCC_EOS
06078                                           ! 1533   return((oldval & 0x02) != 0);
06079                       00001776            .15B:
06080                                           ! Debug: and int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
06081 1776           8A46         FF            mov	al,-1[bp]
06082 1779           24                     02  and	al,*2
06083                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
06084 177B           84C0                       test	al,al
06085 177D           74           04            je 	.15C
06086 177F           B0                     01  mov	al,*1
06087 1781           EB           02            jmp	.15D
06088                       00001783            .15C:
06089 1783           30C0                       xor	al,al
06090                       00001785            .15D:
06091                                           ! Debug: cast unsigned short = const 0 to char = al+0 (used reg = )
06092 1785           30E4                       xor	ah,ah
06093 1787           89EC                       mov	sp,bp
06094 1789           5D                         pop	bp
06095 178A           C3                         ret
06096                                           !BCC_EOS
06097                                           ! 1534 }
06098                                           ! 1535   void
06099                                           ! 1536 debugger_on()
06100                                           ! 1537 {
06101                                           export	_debugger_on
06102                       0000178B            _debugger_on:
06103                                           ! 1538   outb(0xfedc, 0x01);
06104 178B           55                         push	bp
06105 178C           89E5                       mov	bp,sp
06106                                           ! Debug: list int = const 1 (used reg = )
06107 178E           B8                   0001  mov	ax,*1
06108 1791           50                         push	ax
06109                                           ! Debug: list unsigned int = const $FEDC (used reg = )
06110 1792           B8                   FEDC  mov	ax,#$FEDC
06111 1795           50                         push	ax
06112                                           ! Debug: func () void = outb+0 (used reg = )
06113 1796           E8         ED75            call	_outb
06114 1799           89EC                       mov	sp,bp
06115                                           !BCC_EOS
06116                                           ! 1539 }
06117 179B           5D                         pop	bp
06118 179C           C3                         ret
06119                                           ! 1540   void
06120                                           ! 1541 debugger_off()
06121                                           ! 1542 {
06122                                           export	_debugger_off
06123                       0000179D            _debugger_off:
06124                                           ! 1543   outb(0xfedc, 0x00);
06125 179D           55                         push	bp
06126 179E           89E5                       mov	bp,sp
06127                                           ! Debug: list int = const 0 (used reg = )
06128 17A0           31C0                       xor	ax,ax
06129 17A2           50                         push	ax
06130                                           ! Debug: list unsigned int = const $FEDC (used reg = )
06131 17A3           B8                   FEDC  mov	ax,#$FEDC
06132 17A6           50                         push	ax
06133                                           ! Debug: func () void = outb+0 (used reg = )
06134 17A7           E8         ED64            call	_outb
06135 17AA           89EC                       mov	sp,bp
06136                                           !BCC_EOS
06137                                           ! 1544 }
06138 17AC           5D                         pop	bp
06139 17AD           C3                         ret
06140                                           ! 1545 int
06141                                           ! 1546 s3_resume()
06142                                           ! 1547 {
06143                                           export	_s3_resume
06144                       000017AE            _s3_resume:
06145                                           ! 1548     Bit32u s3_wakeup_vector;
06146                                           !BCC_EOS
06147                                           ! 1549     Bit8u s3_resume_flag;
06148                                           !BCC_EOS
06149                                           ! 1550     s3_resume_flag = *((Bit8u *)(0x04b0));
06150 17AE           55                         push	bp
06151 17AF           89E5                       mov	bp,sp
06152 17B1           83C4                   FA  add	sp,*-6
06153                                           ! Debug: eq unsigned char = [+$4B0] to unsigned char s3_resume_flag = [S+8-7] (used reg = )
06154 17B4           A0         04B0            mov	al,[$4B0]
06155 17B7           8846         FB            mov	-5[bp],al
06156                                           !BCC_EOS
06157                                           ! 1551     s3_wakeup_vector = *((Bit32u *)(0x04b2));
06158                                           ! Debug: eq unsigned long = [+$4B2] to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06159 17BA           A1         04B2            mov	ax,[$4B2]
06160 17BD           8B1E       04B4            mov	bx,[$4B4]
06161 17C1           8946         FC            mov	-4[bp],ax
06162 17C4           895E         FE            mov	-2[bp],bx
06163                                           !BCC_EOS
06164                                           ! 1552     bios_printf(4, "S3 resume called %x 0x%lx\n", s3_resume_flag, s3_wakeup_vector);
06165                                           ! Debug: list unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06166 17C7           FF76         FE            push	-2[bp]
06167 17CA           FF76         FC            push	-4[bp]
06168                                           ! Debug: list unsigned char s3_resume_flag = [S+$C-7] (used reg = )
06169 17CD           8A46         FB            mov	al,-5[bp]
06170 17D0           30E4                       xor	ah,ah
06171 17D2           50                         push	ax
06172                                           ! Debug: list * char = .15E+0 (used reg = )
06173 17D3           BB                   D810  mov	bx,#.15E
06174 17D6           53                         push	bx
06175                                           ! Debug: list int = const 4 (used reg = )
06176 17D7           B8                   0004  mov	ax,*4
06177 17DA           50                         push	ax
06178                                           ! Debug: func () void = bios_printf+0 (used reg = )
06179 17DB           E8         F160            call	_bios_printf
06180 17DE           83C4                   0A  add	sp,*$A
06181                                           !BCC_EOS
06182                                           ! 1553     if (s3_resume_flag != 0xFE || !s3_wakeup_vector)
06183                                           ! Debug: ne int = const $FE to unsigned char s3_resume_flag = [S+8-7] (used reg = )
06184 17E1           8A46         FB            mov	al,-5[bp]
06185 17E4           3C                     FE  cmp	al,#$FE
06186 17E6           75           0D            jne 	.160
06187                       000017E8            .161:
06188 17E8           8B46         FC            mov	ax,-4[bp]
06189 17EB           8B5E         FE            mov	bx,-2[bp]
06190 17EE           E8         E8F4            call	ltstl
06191 17F1         0F85         0006            bne 	.15F
06192                       000017F5            .160:
06193                                           ! 1554      return 0;
06194 17F5           31C0                       xor	ax,ax
06195 17F7           89EC                       mov	sp,bp
06196 17F9           5D                         pop	bp
06197 17FA           C3                         ret
06198                                           !BCC_EOS
06199                                           ! 1555     *((Bit8u *)(0x04b0)) = (0);
06200                       000017FB            .15F:
06201                                           ! Debug: eq int = const 0 to unsigned char = [+$4B0] (used reg = )
06202 17FB           30C0                       xor	al,al
06203 17FD           A2         04B0            mov	[$4B0],al
06204                                           !BCC_EOS
06205                                           ! 1556     *((Bit16u *)(0x04b6)) = ((s3_wakeup_vector & 0xF));
06206                                           ! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06207                                           ! Debug: expression subtree swapping
06208 1800           B8                   000F  mov	ax,*$F
06209 1803           31DB                       xor	bx,bx
06210 1805           8D7E         FC            lea	di,-4[bp]
06211 1808           E8         E881            call	landul
06212                                           ! Debug: eq unsigned long = bx+0 to unsigned short = [+$4B6] (used reg = )
06213 180B           A3         04B6            mov	[$4B6],ax
06214                                           !BCC_EOS
06215                                           ! 1557     *((Bit16u *)(0x04b8)) = ((s3_wakeup_vector >> 4));
06216                                           ! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06217 180E           8B46         FC            mov	ax,-4[bp]
06218 1811           8B5E         FE            mov	bx,-2[bp]
06219 1814           BF                   0004  mov	di,*4
06220 1817           E8         E8E0            call	lsrul
06221                                           ! Debug: eq unsigned long = bx+0 to unsigned short = [+$4B8] (used reg = )
06222 181A           A3         04B8            mov	[$4B8],ax
06223                                           !BCC_EOS
06224                                           ! 1558     bios_printf(4, "S3 resume jump to %x:%x\n", (s3_wakeup_vector >> 4), (s3_wakeup_vector & 0xF));
06225                                           ! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06226                                           ! Debug: expression subtree swapping
06227 181D           B8                   000F  mov	ax,*$F
06228 1820           31DB                       xor	bx,bx
06229 1822           8D7E         FC            lea	di,-4[bp]
06230 1825           E8         E864            call	landul
06231                                           ! Debug: list unsigned long = bx+0 (used reg = )
06232 1828           53                         push	bx
06233 1829           50                         push	ax
06234                                           ! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+$C-6] (used reg = )
06235 182A           8B46         FC            mov	ax,-4[bp]
06236 182D           8B5E         FE            mov	bx,-2[bp]
06237 1830           BF                   0004  mov	di,*4
06238 1833           E8         E8C4            call	lsrul
06239                                           ! Debug: list unsigned long = bx+0 (used reg = )
06240 1836           53                         push	bx
06241 1837           50                         push	ax
06242                                           ! Debug: list * char = .162+0 (used reg = )
06243 1838           BB                   D7F7  mov	bx,#.162
06244 183B           53                         push	bx
06245                                           ! Debug: list int = const 4 (used reg = )
06246 183C           B8                   0004  mov	ax,*4
06247 183F           50                         push	ax
06248                                           ! Debug: func () void = bios_printf+0 (used reg = )
06249 1840           E8         F0FB            call	_bios_printf
06250 1843           83C4                   0C  add	sp,*$C
06251                                           !BCC_EOS
06252                                           ! 1559 #asm
06253                                           !BCC_EOS
06254                                           !BCC_ASM
06255                       00000001            _s3_resume.s3_resume_flag	set	1
06256                       FFFFFFFB            .s3_resume.s3_resume_flag	set	-5
06257                       00000002            _s3_resume.s3_wakeup_vector	set	2
06258                       FFFFFFFC            .s3_resume.s3_wakeup_vector	set	-4
06259 1846           FF2E       04B6                jmpf [0x04b6]
06260                                           ! 1561 endasm
06261                                           !BCC_ENDASM
06262                                           !BCC_EOS
06263                                           ! 1562     return 1;
06264 184A           B8                   0001  mov	ax,*1
06265 184D           89EC                       mov	sp,bp
06266 184F           5D                         pop	bp
06267 1850           C3                         ret
06268                                           !BCC_EOS
06269                                           ! 1563 }
06270                                           ! 1564 void ata_init( )
06271                                           ! Register BX used in function s3_resume
06272                                           ! 1565 {
06273                                           export	_ata_init
06274                       00001851            _ata_init:
06275                                           ! 1566   Bit8u channel, device;
06276                                           !BCC_EOS
06277                                           ! 1567   Bit16u old_ds = set_DS(get_ebda_seg());
06278 1851           55                         push	bp
06279 1852           89E5                       mov	bp,sp
06280 1854           83C4                   FC  add	sp,*-4
06281                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
06282 1857           E8         EE12            call	_get_ebda_seg
06283                                           ! Debug: list unsigned short = ax+0 (used reg = )
06284 185A           50                         push	ax
06285                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
06286 185B           E8         EE04            call	_set_DS
06287 185E           44                         inc	sp
06288 185F           44                         inc	sp
06289                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+6-6] (used reg = )
06290 1860           8946         FC            mov	-4[bp],ax
06291                                           !BCC_EOS
06292                                           ! 1568   for (channel=0; channel<4; channel++) {
06293                                           ! Debug: eq int = const 0 to unsigned char channel = [S+6-3] (used reg = )
06294 1863           30C0                       xor	al,al
06295 1865           8846         FF            mov	-1[bp],al
06296                                           !BCC_EOS
06297                                           !BCC_EOS
06298 1868           EB           4B            jmp .165
06299                       0000186A            .166:
06300                                           ! 1569     *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[channel].iface)) = (0x00);
06301                                           ! Debug: ptradd unsigned char channel = [S+6-3] to [4] struct  = const $122 (used reg = )
06302 186A           8A46         FF            mov	al,-1[bp]
06303 186D           30E4                       xor	ah,ah
06304 186F           B1                     03  mov	cl,*3
06305 1871           D3E0                       shl	ax,cl
06306 1873           89C3                       mov	bx,ax
06307                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
06308                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$122 (used reg = )
06309                                           ! Debug: eq int = const 0 to unsigned char = [bx+$122] (used reg = )
06310 1875           30C0                       xor	al,al
06311 1877           8887       0122            mov	$122[bx],al
06312                                           !BCC_EOS
06313                                           ! 1570     *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1)) = (0x0);
06314                                           ! Debug: ptradd unsigned char channel = [S+6-3] to [4] struct  = const $122 (used reg = )
06315 187B           8A46         FF            mov	al,-1[bp]
06316 187E           30E4                       xor	ah,ah
06317 1880           B1                     03  mov	cl,*3
06318 1882           D3E0                       shl	ax,cl
06319 1884           89C3                       mov	bx,ax
06320                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
06321                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
06322                                           ! Debug: eq int = const 0 to unsigned short = [bx+$124] (used reg = )
06323 1886           31C0                       xor	ax,ax
06324 1888           8987       0124            mov	$124[bx],ax
06325                                           !BCC_EOS
06326                                           ! 1571     *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2)) = (0x0);
06327                                           ! Debug: ptradd unsigned char channel = [S+6-3] to [4] struct  = const $122 (used reg = )
06328 188C           8A46         FF            mov	al,-1[bp]
06329 188F           30E4                       xor	ah,ah
06330 1891           B1                     03  mov	cl,*3
06331 1893           D3E0                       shl	ax,cl
06332 1895           89C3                       mov	bx,ax
06333                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
06334                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
06335                                           ! Debug: eq int = const 0 to unsigned short = [bx+$126] (used reg = )
06336 1897           31C0                       xor	ax,ax
06337 1899           8987       0126            mov	$126[bx],ax
06338                                           !BCC_EOS
06339                                           ! 1572     *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[channel].irq)) = (0);
06340                                           ! Debug: ptradd unsigned char channel = [S+6-3] to [4] struct  = const $122 (used reg = )
06341 189D           8A46         FF            mov	al,-1[bp]
06342 18A0           30E4                       xor	ah,ah
06343 18A2           B1                     03  mov	cl,*3
06344 18A4           D3E0                       shl	ax,cl
06345 18A6           89C3                       mov	bx,ax
06346                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
06347                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$128 (used reg = )
06348                                           ! Debug: eq int = const 0 to unsigned char = [bx+$128] (used reg = )
06349 18A8           30C0                       xor	al,al
06350 18AA           8887       0128            mov	$128[bx],al
06351                                           !BCC_EOS
06352                                           ! 1573   }
06353                                           ! 1574   for (device=0; device<(4*2); device++) {
06354                       000018AE            .164:
06355                                           ! Debug: postinc unsigned char channel = [S+6-3] (used reg = )
06356 18AE           8A46         FF            mov	al,-1[bp]
06357 18B1           40                         inc	ax
06358 18B2           8846         FF            mov	-1[bp],al
06359                       000018B5            .165:
06360                                           ! Debug: lt int = const 4 to unsigned char channel = [S+6-3] (used reg = )
06361 18B5           8A46         FF            mov	al,-1[bp]
06362 18B8           3C                     04  cmp	al,*4
06363 18BA           72           AE            jb 	.166
06364                       000018BC            .167:
06365                       000018BC            .163:
06366                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-4] (used reg = )
06367 18BC           30C0                       xor	al,al
06368 18BE           8846         FE            mov	-2[bp],al
06369                                           !BCC_EOS
06370                                           !BCC_EOS
06371 18C1           E9         0121            br 	.16A
06372                       000018C4            .16B:
06373                                           ! 1575     *(
06374                                           ! 1575 (Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type)) = (0x00);
06375                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06376 18C4           8A46         FE            mov	al,-2[bp]
06377 18C7           30E4                       xor	ah,ah
06378 18C9           B9                   001E  mov	cx,*$1E
06379 18CC           F7E9                       imul	cx
06380 18CE           89C3                       mov	bx,ax
06381                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
06382                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
06383                                           ! Debug: eq int = const 0 to unsigned char = [bx+$142] (used reg = )
06384 18D0           30C0                       xor	al,al
06385 18D2           8887       0142            mov	$142[bx],al
06386                                           !BCC_EOS
06387                                           ! 1576     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device)) = (0x00);
06388                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06389 18D6           8A46         FE            mov	al,-2[bp]
06390 18D9           30E4                       xor	ah,ah
06391 18DB           B9                   001E  mov	cx,*$1E
06392 18DE           F7E9                       imul	cx
06393 18E0           89C3                       mov	bx,ax
06394                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
06395                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
06396                                           ! Debug: eq int = const 0 to unsigned char = [bx+$143] (used reg = )
06397 18E2           30C0                       xor	al,al
06398 18E4           8887       0143            mov	$143[bx],al
06399                                           !BCC_EOS
06400                                           ! 1577     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].removable)) = (0);
06401                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06402 18E8           8A46         FE            mov	al,-2[bp]
06403 18EB           30E4                       xor	ah,ah
06404 18ED           B9                   001E  mov	cx,*$1E
06405 18F0           F7E9                       imul	cx
06406 18F2           89C3                       mov	bx,ax
06407                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
06408                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$144 (used reg = )
06409                                           ! Debug: eq int = const 0 to unsigned char = [bx+$144] (used reg = )
06410 18F4           30C0                       xor	al,al
06411 18F6           8887       0144            mov	$144[bx],al
06412                                           !BCC_EOS
06413                                           ! 1578     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].lock)) = (0);
06414                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06415 18FA           8A46         FE            mov	al,-2[bp]
06416 18FD           30E4                       xor	ah,ah
06417 18FF           B9                   001E  mov	cx,*$1E
06418 1902           F7E9                       imul	cx
06419 1904           89C3                       mov	bx,ax
06420                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
06421                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$145 (used reg = )
06422                                           ! Debug: eq int = const 0 to unsigned char = [bx+$145] (used reg = )
06423 1906           30C0                       xor	al,al
06424 1908           8887       0145            mov	$145[bx],al
06425                                           !BCC_EOS
06426                                           ! 1579     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode)) = (0x00);
06427                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06428 190C           8A46         FE            mov	al,-2[bp]
06429 190F           30E4                       xor	ah,ah
06430 1911           B9                   001E  mov	cx,*$1E
06431 1914           F7E9                       imul	cx
06432 1916           89C3                       mov	bx,ax
06433                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
06434                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
06435                                           ! Debug: eq int = const 0 to unsigned char = [bx+$146] (used reg = )
06436 1918           30C0                       xor	al,al
06437 191A           8887       0146            mov	$146[bx],al
06438                                           !BCC_EOS
06439                                           ! 1580     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].blksize)) = (0);
06440                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06441 191E           8A46         FE            mov	al,-2[bp]
06442 1921           30E4                       xor	ah,ah
06443 1923           B9                   001E  mov	cx,*$1E
06444 1926           F7E9                       imul	cx
06445 1928           89C3                       mov	bx,ax
06446                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
06447                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$148 (used reg = )
06448                                           ! Debug: eq int = const 0 to unsigned short = [bx+$148] (used reg = )
06449 192A           31C0                       xor	ax,ax
06450 192C           8987       0148            mov	$148[bx],ax
06451                                           !BCC_EOS
06452                                           ! 1581     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].translation)) = (0);
06453                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06454 1930           8A46         FE            mov	al,-2[bp]
06455 1933           30E4                       xor	ah,ah
06456 1935           B9                   001E  mov	cx,*$1E
06457 1938           F7E9                       imul	cx
06458 193A           89C3                       mov	bx,ax
06459                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
06460                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$14A (used reg = )
06461                                           ! Debug: eq int = const 0 to unsigned char = [bx+$14A] (used reg = )
06462 193C           30C0                       xor	al,al
06463 193E           8887       014A            mov	$14A[bx],al
06464                                           !BCC_EOS
06465                                           ! 1582     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.heads)) = (0);
06466                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06467 1942           8A46         FE            mov	al,-2[bp]
06468 1945           30E4                       xor	ah,ah
06469 1947           B9                   001E  mov	cx,*$1E
06470 194A           F7E9                       imul	cx
06471 194C           89C3                       mov	bx,ax
06472                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
06473                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14C (used reg = )
06474                                           ! Debug: eq int = const 0 to unsigned short = [bx+$14C] (used reg = )
06475 194E           31C0                       xor	ax,ax
06476 1950           8987       014C            mov	$14C[bx],ax
06477                                           !BCC_EOS
06478                                           ! 1583     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders)) = (0);
06479                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06480 1954           8A46         FE            mov	al,-2[bp]
06481 1957           30E4                       xor	ah,ah
06482 1959           B9                   001E  mov	cx,*$1E
06483 195C           F7E9                       imul	cx
06484 195E           89C3                       mov	bx,ax
06485                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
06486                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14E (used reg = )
06487                                           ! Debug: eq int = const 0 to unsigned short = [bx+$14E] (used reg = )
06488 1960           31C0                       xor	ax,ax
06489 1962           8987       014E            mov	$14E[bx],ax
06490                                           !BCC_EOS
06491                                           ! 1584     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.spt)) = (0);
06492                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06493 1966           8A46         FE            mov	al,-2[bp]
06494 1969           30E4                       xor	ah,ah
06495 196B           B9                   001E  mov	cx,*$1E
06496 196E           F7E9                       imul	cx
06497 1970           89C3                       mov	bx,ax
06498                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
06499                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$150 (used reg = )
06500                                           ! Debug: eq int = const 0 to unsigned short = [bx+$150] (used reg = )
06501 1972           31C0                       xor	ax,ax
06502 1974           8987       0150            mov	$150[bx],ax
06503                                           !BCC_EOS
06504                                           ! 1585     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.heads)) = (0);
06505                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06506 1978           8A46         FE            mov	al,-2[bp]
06507 197B           30E4                       xor	ah,ah
06508 197D           B9                   001E  mov	cx,*$1E
06509 1980           F7E9                       imul	cx
06510 1982           89C3                       mov	bx,ax
06511                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
06512                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$152 (used reg = )
06513                                           ! Debug: eq int = const 0 to unsigned short = [bx+$152] (used reg = )
06514 1984           31C0                       xor	ax,ax
06515 1986           8987       0152            mov	$152[bx],ax
06516                                           !BCC_EOS
06517                                           ! 1586     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders)) = (0);
06518                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06519 198A           8A46         FE            mov	al,-2[bp]
06520 198D           30E4                       xor	ah,ah
06521 198F           B9                   001E  mov	cx,*$1E
06522 1992           F7E9                       imul	cx
06523 1994           89C3                       mov	bx,ax
06524                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
06525                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$154 (used reg = )
06526                                           ! Debug: eq int = const 0 to unsigned short = [bx+$154] (used reg = )
06527 1996           31C0                       xor	ax,ax
06528 1998           8987       0154            mov	$154[bx],ax
06529                                           !BCC_EOS
06530                                           ! 1587     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.spt)) = (0);
06531                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06532 199C           8A46         FE            mov	al,-2[bp]
06533 199F           30E4                       xor	ah,ah
06534 19A1           B9                   001E  mov	cx,*$1E
06535 19A4           F7E9                       imul	cx
06536 19A6           89C3                       mov	bx,ax
06537                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
06538                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$156 (used reg = )
06539                                           ! Debug: eq int = const 0 to unsigned short = [bx+$156] (used reg = )
06540 19A8           31C0                       xor	ax,ax
06541 19AA           8987       0156            mov	$156[bx],ax
06542                                           !BCC_EOS
06543                                           ! 1588     *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_low)) = (0L);
06544                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06545 19AE           8A46         FE            mov	al,-2[bp]
06546 19B1           30E4                       xor	ah,ah
06547 19B3           B9                   001E  mov	cx,*$1E
06548 19B6           F7E9                       imul	cx
06549 19B8           89C3                       mov	bx,ax
06550                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
06551                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$158 (used reg = )
06552                                           ! Debug: eq long = const 0 to unsigned long = [bx+$158] (used reg = )
06553 19BA           31C0                       xor	ax,ax
06554 19BC           31F6                       xor	si,si
06555 19BE           8987       0158            mov	$158[bx],ax
06556 19C2           89B7       015A            mov	$15A[bx],si
06557                                           !BCC_EOS
06558                                           ! 1589     *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high)) = (0L);
06559                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06560 19C6           8A46         FE            mov	al,-2[bp]
06561 19C9           30E4                       xor	ah,ah
06562 19CB           B9                   001E  mov	cx,*$1E
06563 19CE           F7E9                       imul	cx
06564 19D0           89C3                       mov	bx,ax
06565                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
06566                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
06567                                           ! Debug: eq long = const 0 to unsigned long = [bx+$15C] (used reg = )
06568 19D2           31C0                       xor	ax,ax
06569 19D4           31F6                       xor	si,si
06570 19D6           8987       015C            mov	$15C[bx],ax
06571 19DA           89B7       015E            mov	$15E[bx],si
06572                                           !BCC_EOS
06573                                           ! 1590   }
06574                                           ! 1591   for (device=0; device<(4*2); device++) {
06575                       000019DE            .169:
06576                                           ! Debug: postinc unsigned char device = [S+6-4] (used reg = )
06577 19DE           8A46         FE            mov	al,-2[bp]
06578 19E1           40                         inc	ax
06579 19E2           8846         FE            mov	-2[bp],al
06580                       000019E5            .16A:
06581                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-4] (used reg = )
06582 19E5           8A46         FE            mov	al,-2[bp]
06583 19E8           3C                     08  cmp	al,*8
06584 19EA         0F82         FED6            blo 	.16B
06585                       000019EE            .16C:
06586                       000019EE            .168:
06587                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-4] (used reg = )
06588 19EE           30C0                       xor	al,al
06589 19F0           8846         FE            mov	-2[bp],al
06590                                           !BCC_EOS
06591                                           !BCC_EOS
06592 19F3           EB           21            jmp .16F
06593                       000019F5            .170:
06594                                           ! 1592     *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdidmap[device])) = ((4*2));
06595                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] unsigned char = const $233 (used reg = )
06596 19F5           8A46         FE            mov	al,-2[bp]
06597 19F8           30E4                       xor	ah,ah
06598 19FA           89C3                       mov	bx,ax
06599                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
06600                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$233 (used reg = )
06601                                           ! Debug: eq int = const 8 to unsigned char = [bx+$233] (used reg = )
06602 19FC           B0                     08  mov	al,*8
06603 19FE           8887       0233            mov	$233[bx],al
06604                                           !BCC_EOS
06605                                           ! 1593     *((Bit8u *)(&((ebda_data_t *) 0)->ata.cdidmap[device])) = ((4*2));
06606                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] unsigned char = const $23C (used reg = )
06607 1A02           8A46         FE            mov	al,-2[bp]
06608 1A05           30E4                       xor	ah,ah
06609 1A07           89C3                       mov	bx,ax
06610                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
06611                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$23C (used reg = )
06612                                           ! Debug: eq int = const 8 to unsigned char = [bx+$23C] (used reg = )
06613 1A09           B0                     08  mov	al,*8
06614 1A0B           8887       023C            mov	$23C[bx],al
06615                                           !BCC_EOS
06616                                           ! 1594   }
06617                                           ! 1595   *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdcount)) = (0);
06618                       00001A0F            .16E:
06619                                           ! Debug: postinc unsigned char device = [S+6-4] (used reg = )
06620 1A0F           8A46         FE            mov	al,-2[bp]
06621 1A12           40                         inc	ax
06622 1A13           8846         FE            mov	-2[bp],al
06623                       00001A16            .16F:
06624                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-4] (used reg = )
06625 1A16           8A46         FE            mov	al,-2[bp]
06626 1A19           3C                     08  cmp	al,*8
06627 1A1B           72           D8            jb 	.170
06628                       00001A1D            .171:
06629                       00001A1D            .16D:
06630                                           ! Debug: eq int = const 0 to unsigned char = [+$232] (used reg = )
06631 1A1D           30C0                       xor	al,al
06632 1A1F           A2         0232            mov	[$232],al
06633                                           !BCC_EOS
06634                                           ! 1596   *((Bit8u *)(&((ebda_data_t *) 0)->ata.cdcount)) = (0);
06635                                           ! Debug: eq int = const 0 to unsigned char = [+$23B] (used reg = )
06636 1A22           30C0                       xor	al,al
06637 1A24           A2         023B            mov	[$23B],al
06638                                           !BCC_EOS
06639                                           ! 1597   set_DS(old_ds);
06640                                           ! Debug: list unsigned short old_ds = [S+6-6] (used reg = )
06641 1A27           FF76         FC            push	-4[bp]
06642                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
06643 1A2A           E8         EC35            call	_set_DS
06644 1A2D           44                         inc	sp
06645 1A2E           44                         inc	sp
06646                                           !BCC_EOS
06647                                           ! 1598 }
06648 1A2F           89EC                       mov	sp,bp
06649 1A31           5D                         pop	bp
06650 1A32           C3                         ret
06651                                           ! 1599 int await_ide();
06652                                           ! Register BX used in function ata_init
06653                                           !BCC_EOS
06654                                           ! 1600 static int await_ide(when_done,base,timeout)
06655                                           ! 1601   Bit8u when_done;
06656                       00001A33            _await_ide:
06657                                           !BCC_EOS
06658                                           ! 1602   Bit16u base;
06659                                           !BCC_EOS
06660                                           ! 1603   Bit16u timeout;
06661                                           !BCC_EOS
06662                                           ! 1604 {
06663                                           ! 1605   Bit32u time=0;
06664 1A33           55                         push	bp
06665 1A34           89E5                       mov	bp,sp
06666 1A36           83C4                   FC  add	sp,*-4
06667                                           ! Debug: eq int = const 0 to unsigned long time = [S+6-6] (used reg = )
06668 1A39           31C0                       xor	ax,ax
06669 1A3B           31DB                       xor	bx,bx
06670 1A3D           8946         FC            mov	-4[bp],ax
06671 1A40           895E         FE            mov	-2[bp],bx
06672                                           !BCC_EOS
06673                                           ! 1606   Bit16u status,last=0;
06674 1A43           83C4                   FC  add	sp,*-4
06675                                           ! Debug: eq int = const 0 to unsigned short last = [S+$A-$A] (used reg = )
06676 1A46           31C0                       xor	ax,ax
06677 1A48           8946         F8            mov	-8[bp],ax
06678                                           !BCC_EOS
06679                                           ! 1607   Bit8u result;
06680                                           !BCC_EOS
06681                                           ! 1608   status = inb(base + 7);
06682 1A4B           4C                         dec	sp
06683 1A4C           4C                         dec	sp
06684                                           ! Debug: add int = const 7 to unsigned short base = [S+$C+4] (used reg = )
06685 1A4D           8B46         06            mov	ax,6[bp]
06686                                           ! Debug: list unsigned int = ax+7 (used reg = )
06687 1A50           05                   0007  add	ax,*7
06688 1A53           50                         push	ax
06689                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06690 1A54           E8         EAA1            call	_inb
06691 1A57           44                         inc	sp
06692 1A58           44                         inc	sp
06693                                           ! Debug: eq unsigned char = al+0 to unsigned short status = [S+$C-8] (used reg = )
06694 1A59           30E4                       xor	ah,ah
06695 1A5B           8946         FA            mov	-6[bp],ax
06696                                           !BCC_EOS
06697                                           ! 1609   for(;;) {
06698                                           !BCC_EOS
06699                                           !BCC_EOS
06700                       00001A5E            .174:
06701                                           ! 1610     status = inb(base+7);
06702                                           ! Debug: add int = const 7 to unsigned short base = [S+$C+4] (used reg = )
06703 1A5E           8B46         06            mov	ax,6[bp]
06704                                           ! Debug: list unsigned int = ax+7 (used reg = )
06705 1A61           05                   0007  add	ax,*7
06706 1A64           50                         push	ax
06707                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06708 1A65           E8         EA90            call	_inb
06709 1A68           44                         inc	sp
06710 1A69           44                         inc	sp
06711                                           ! Debug: eq unsigned char = al+0 to unsigned short status = [S+$C-8] (used reg = )
06712 1A6A           30E4                       xor	ah,ah
06713 1A6C           8946         FA            mov	-6[bp],ax
06714                                           !BCC_EOS
06715                                           ! 1611     time++;
06716                                           ! Debug: postinc unsigned long time = [S+$C-6] (used reg = )
06717 1A6F           8B46         FC            mov	ax,-4[bp]
06718 1A72           8B76         FE            mov	si,-2[bp]
06719 1A75           8D5E         FC            lea	bx,-4[bp]
06720 1A78           E8         E665            call	lincl
06721                                           !BCC_EOS
06722                                           ! 1612     if (when_done == 1)
06723                                           ! Debug: logeq int = const 1 to unsigned char when_done = [S+$C+2] (used reg = )
06724 1A7B           8A46         04            mov	al,4[bp]
06725 1A7E           3C                     01  cmp	al,*1
06726 1A80           75           0B            jne 	.175
06727                       00001A82            .176:
06728                                           ! 1613       result = status & 0x80;
06729                                           ! Debug: and int = const $80 to unsigned short status = [S+$C-8] (used reg = )
06730 1A82           8A46         FA            mov	al,-6[bp]
06731 1A85           24                     80  and	al,#$80
06732                                           ! Debug: eq unsigned char = al+0 to unsigned char result = [S+$C-$B] (used reg = )
06733 1A87           8846         F7            mov	-9[bp],al
06734                                           !BCC_EOS
06735                                           ! 1614     else if (when_done == 2)
06736 1A8A           E9         0094            br 	.177
06737                       00001A8D            .175:
06738                                           ! Debug: logeq int = const 2 to unsigned char when_done = [S+$C+2] (used reg = )
06739 1A8D           8A46         04            mov	al,4[bp]
06740 1A90           3C                     02  cmp	al,*2
06741 1A92           75           15            jne 	.178
06742                       00001A94            .179:
06743                                           ! 1615       result = !(status & 0x80);
06744                                           ! Debug: and int = const $80 to unsigned short status = [S+$C-8] (used reg = )
06745 1A94           8A46         FA            mov	al,-6[bp]
06746 1A97           24                     80  and	al,#$80
06747 1A99           84C0                       test	al,al
06748 1A9B           75           04            jne 	.17A
06749                       00001A9D            .17B:
06750 1A9D           B0                     01  mov	al,*1
06751 1A9F           EB           02            jmp	.17C
06752                       00001AA1            .17A:
06753 1AA1           30C0                       xor	al,al
06754                       00001AA3            .17C:
06755                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$B] (used reg = )
06756 1AA3           8846         F7            mov	-9[bp],al
06757                                           !BCC_EOS
06758                                           ! 1616     else if (when_done == 3)
06759 1AA6           E9         0078            br 	.17D
06760                       00001AA9            .178:
06761                                           ! Debug: logeq int = const 3 to unsigned char when_done = [S+$C+2] (used reg = )
06762 1AA9           8A46         04            mov	al,4[bp]
06763 1AAC           3C                     03  cmp	al,*3
06764 1AAE           75           1D            jne 	.17E
06765                       00001AB0            .17F:
06766                                           ! 1617       result = !(status & 0x80) && (status & 0x08);
06767                                           ! Debug: and int = const $80 to unsigned short status = [S+$C-8] (used reg = )
06768 1AB0           8A46         FA            mov	al,-6[bp]
06769 1AB3           24                     80  and	al,#$80
06770 1AB5           84C0                       test	al,al
06771 1AB7           75           0D            jne 	.180
06772                       00001AB9            .182:
06773                                           ! Debug: and int = const 8 to unsigned short status = [S+$C-8] (used reg = )
06774 1AB9           8A46         FA            mov	al,-6[bp]
06775 1ABC           24                     08  and	al,*8
06776 1ABE           84C0                       test	al,al
06777 1AC0           74           04            je  	.180
06778                       00001AC2            .181:
06779 1AC2           B0                     01  mov	al,*1
06780 1AC4           EB           02            jmp	.183
06781                       00001AC6            .180:
06782 1AC6           30C0                       xor	al,al
06783                       00001AC8            .183:
06784                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$B] (used reg = )
06785 1AC8           8846         F7            mov	-9[bp],al
06786                                           !BCC_EOS
06787                                           ! 1618     else if (when_done == 4)
06788 1ACB           EB           54            jmp .184
06789                       00001ACD            .17E:
06790                                           ! Debug: logeq int = const 4 to unsigned char when_done = [S+$C+2] (used reg = )
06791 1ACD           8A46         04            mov	al,4[bp]
06792 1AD0           3C                     04  cmp	al,*4
06793 1AD2           75           1D            jne 	.185
06794                       00001AD4            .186:
06795                                           ! 1619       result = !(status & 0x80) && !(status & 0x08);
06796                                           ! Debug: and int = const $80 to unsigned short status = [S+$C-8] (used reg = )
06797 1AD4           8A46         FA            mov	al,-6[bp]
06798 1AD7           24                     80  and	al,#$80
06799 1AD9           84C0                       test	al,al
06800 1ADB           75           0D            jne 	.187
06801                       00001ADD            .189:
06802                                           ! Debug: and int = const 8 to unsigned short status = [S+$C-8] (used reg = )
06803 1ADD           8A46         FA            mov	al,-6[bp]
06804 1AE0           24                     08  and	al,*8
06805 1AE2           84C0                       test	al,al
06806 1AE4           75           04            jne 	.187
06807                       00001AE6            .188:
06808 1AE6           B0                     01  mov	al,*1
06809 1AE8           EB           02            jmp	.18A
06810                       00001AEA            .187:
06811 1AEA           30C0                       xor	al,al
06812                       00001AEC            .18A:
06813                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$B] (used reg = )
06814 1AEC           8846         F7            mov	-9[bp],al
06815                                           !BCC_EOS
06816                                           ! 1620     else if (when_done == 5
06817 1AEF           EB           30            jmp .18B
06818                       00001AF1            .185:
06819                                           ! 1620 )
06820                                           ! Debug: logeq int = const 5 to unsigned char when_done = [S+$C+2] (used reg = )
06821 1AF1           8A46         04            mov	al,4[bp]
06822 1AF4           3C                     05  cmp	al,*5
06823 1AF6           75           1D            jne 	.18C
06824                       00001AF8            .18D:
06825                                           ! 1621       result = !(status & 0x80) && (status & 0x40);
06826                                           ! Debug: and int = const $80 to unsigned short status = [S+$C-8] (used reg = )
06827 1AF8           8A46         FA            mov	al,-6[bp]
06828 1AFB           24                     80  and	al,#$80
06829 1AFD           84C0                       test	al,al
06830 1AFF           75           0D            jne 	.18E
06831                       00001B01            .190:
06832                                           ! Debug: and int = const $40 to unsigned short status = [S+$C-8] (used reg = )
06833 1B01           8A46         FA            mov	al,-6[bp]
06834 1B04           24                     40  and	al,*$40
06835 1B06           84C0                       test	al,al
06836 1B08           74           04            je  	.18E
06837                       00001B0A            .18F:
06838 1B0A           B0                     01  mov	al,*1
06839 1B0C           EB           02            jmp	.191
06840                       00001B0E            .18E:
06841 1B0E           30C0                       xor	al,al
06842                       00001B10            .191:
06843                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$B] (used reg = )
06844 1B10           8846         F7            mov	-9[bp],al
06845                                           !BCC_EOS
06846                                           ! 1622     else if (when_done == 0)
06847 1B13           EB           0C            jmp .192
06848                       00001B15            .18C:
06849                                           ! Debug: logeq int = const 0 to unsigned char when_done = [S+$C+2] (used reg = )
06850 1B15           8A46         04            mov	al,4[bp]
06851 1B18           84C0                       test	al,al
06852 1B1A           75           05            jne 	.193
06853                       00001B1C            .194:
06854                                           ! 1623       result = 0;
06855                                           ! Debug: eq int = const 0 to unsigned char result = [S+$C-$B] (used reg = )
06856 1B1C           30C0                       xor	al,al
06857 1B1E           8846         F7            mov	-9[bp],al
06858                                           !BCC_EOS
06859                                           ! 1624     if (result) return 0;
06860                       00001B21            .193:
06861                       00001B21            .192:
06862                       00001B21            .18B:
06863                       00001B21            .184:
06864                       00001B21            .17D:
06865                       00001B21            .177:
06866 1B21           8A46         F7            mov	al,-9[bp]
06867 1B24           84C0                       test	al,al
06868 1B26           74           06            je  	.195
06869                       00001B28            .196:
06870 1B28           31C0                       xor	ax,ax
06871 1B2A           89EC                       mov	sp,bp
06872 1B2C           5D                         pop	bp
06873 1B2D           C3                         ret
06874                                           !BCC_EOS
06875                                           ! 1625     if (*(((Bit16u *)&time)+1) != last)
06876                       00001B2E            .195:
06877                                           ! Debug: ne unsigned short last = [S+$C-$A] to unsigned short time = [S+$C-4] (used reg = )
06878 1B2E           8B46         FE            mov	ax,-2[bp]
06879 1B31           3B46         F8            cmp	ax,-8[bp]
06880 1B34           74           06            je  	.197
06881                       00001B36            .198:
06882                                           ! 1626     {
06883                                           ! 1627       last = *(((Bit16u *)&time)+1);
06884                                           ! Debug: eq unsigned short time = [S+$C-4] to unsigned short last = [S+$C-$A] (used reg = )
06885 1B36           8B46         FE            mov	ax,-2[bp]
06886 1B39           8946         F8            mov	-8[bp],ax
06887                                           !BCC_EOS
06888                                           ! 1628       ;
06889                                           !BCC_EOS
06890                                           ! 1629     }
06891                                           ! 1630     if (status & 0x01)
06892                       00001B3C            .197:
06893                                           ! Debug: and int = const 1 to unsigned short status = [S+$C-8] (used reg = )
06894 1B3C           8A46         FA            mov	al,-6[bp]
06895 1B3F           24                     01  and	al,*1
06896 1B41           84C0                       test	al,al
06897 1B43           74           07            je  	.199
06898                       00001B45            .19A:
06899                                           ! 1631     {
06900                                           ! 1632       ;
06901                                           !BCC_EOS
06902                                           ! 1633       return -1;
06903 1B45           B8                   FFFF  mov	ax,*-1
06904 1B48           89EC                       mov	sp,bp
06905 1B4A           5D                         pop	bp
06906 1B4B           C3                         ret
06907                                           !BCC_EOS
06908                                           ! 1634     }
06909                                           ! 1635     if ((timeout == 0) || ((time>>11) > timeout)) break;
06910                       00001B4C            .199:
06911                                           ! Debug: logeq int = const 0 to unsigned short timeout = [S+$C+6] (used reg = )
06912 1B4C           8B46         08            mov	ax,8[bp]
06913 1B4F           85C0                       test	ax,ax
06914 1B51           74           26            je  	.19C
06915                       00001B53            .19D:
06916                                           ! Debug: cast unsigned long = const 0 to unsigned short timeout = [S+$C+6] (used reg = )
06917 1B53           8B46         08            mov	ax,8[bp]
06918 1B56           31DB                       xor	bx,bx
06919 1B58           53                         push	bx
06920 1B59           50                         push	ax
06921                                           ! Debug: sr int = const $B to unsigned long time = [S+$10-6] (used reg = )
06922 1B5A           8B46         FC            mov	ax,-4[bp]
06923 1B5D           8B5E         FE            mov	bx,-2[bp]
06924 1B60           88E0                       mov	al,ah
06925 1B62           88DC                       mov	ah,bl
06926 1B64           88FB                       mov	bl,bh
06927 1B66           28FF                       sub	bh,bh
06928 1B68           BF                   0003  mov	di,*3
06929 1B6B           E8         E58C            call	lsrul
06930                                           ! Debug: gt unsigned long (temp) = [S+$10-$10] to unsigned long = bx+0 (used reg = )
06931 1B6E           8D7E         F2            lea	di,-$E[bp]
06932 1B71           E8         E528            call	lcmpul
06933 1B74           8D66         F6            lea	sp,-$A[bp]
06934 1B77           76           02            jbe 	.19B
06935                       00001B79            .19C:
06936 1B79           EB           03            jmp .172
06937                                           !BCC_EOS
06938                                           ! 1636   }
06939                       00001B7B            .19B:
06940                                           ! 1637   bios_printf(4, "IDE time out\n");
06941                       00001B7B            .173:
06942 1B7B           E9         FEE0            br 	.174
06943                       00001B7E            .172:
06944                                           ! Debug: list * char = .19E+0 (used reg = )
06945 1B7E           BB                   D7E9  mov	bx,#.19E
06946 1B81           53                         push	bx
06947                                           ! Debug: list int = const 4 (used reg = )
06948 1B82           B8                   0004  mov	ax,*4
06949 1B85           50                         push	ax
06950                                           ! Debug: func () void = bios_printf+0 (used reg = )
06951 1B86           E8         EDB5            call	_bios_printf
06952 1B89           83C4                   04  add	sp,*4
06953                                           !BCC_EOS
06954                                           ! 1638   return -1;
06955 1B8C           B8                   FFFF  mov	ax,*-1
06956 1B8F           89EC                       mov	sp,bp
06957 1B91           5D                         pop	bp
06958 1B92           C3                         ret
06959                                           !BCC_EOS
06960                                           ! 1639 }
06961                                           ! 1640 void ata_detect( )
06962                                           ! Register BX used in function await_ide
06963                                           ! 1641 {
06964                                           export	_ata_detect
06965                       00001B93            _ata_detect:
06966                                           ! 1642   Bit8u hdcount, cdcount, device, type;
06967                                           !BCC_EOS
06968                                           ! 1643   Bit8u buffer[0x0200];
06969                                           !BCC_EOS
06970                                           ! 1644   Bit16u old_ds = set_DS(get_ebda_seg());
06971 1B93           55                         push	bp
06972 1B94           89E5                       mov	bp,sp
06973 1B96           81C4                 FDFA  add	sp,#-$206
06974                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
06975 1B9A           E8         EACF            call	_get_ebda_seg
06976                                           ! Debug: list unsigned short = ax+0 (used reg = )
06977 1B9D           50                         push	ax
06978                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
06979 1B9E           E8         EAC1            call	_set_DS
06980 1BA1           44                         inc	sp
06981 1BA2           44                         inc	sp
06982                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+$208-$208] (used reg = )
06983 1BA3           8986       FDFA            mov	-$206[bp],ax
06984                                           !BCC_EOS
06985                                           ! 1645   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[0].iface)) = (0x00);
06986                                           ! Debug: eq int = const 0 to unsigned char = [+$122] (used reg = )
06987 1BA7           30C0                       xor	al,al
06988 1BA9           A2         0122            mov	[$122],al
06989                                           !BCC_EOS
06990                                           ! 1646   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[0].iobase1)) = (0x01f0);
06991                                           ! Debug: eq int = const $1F0 to unsigned short = [+$124] (used reg = )
06992 1BAC           B8                   01F0  mov	ax,#$1F0
06993 1BAF           A3         0124            mov	[$124],ax
06994                                           !BCC_EOS
06995                                           ! 1647   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[0].iobase2)) = (0x3f0);
06996                                           ! Debug: eq int = const $3F0 to unsigned short = [+$126] (used reg = )
06997 1BB2           B8                   03F0  mov	ax,#$3F0
06998 1BB5           A3         0126            mov	[$126],ax
06999                                           !BCC_EOS
07000                                           ! 1648   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[0].irq)) = (14);
07001                                           ! Debug: eq int = const $E to unsigned char = [+$128] (used reg = )
07002 1BB8           B0                     0E  mov	al,*$E
07003 1BBA           A2         0128            mov	[$128],al
07004                                           !BCC_EOS
07005                                           ! 1649   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[1].iface)) = (0x00);
07006                                           ! Debug: eq int = const 0 to unsigned char = [+$12A] (used reg = )
07007 1BBD           30C0                       xor	al,al
07008 1BBF           A2         012A            mov	[$12A],al
07009                                           !BCC_EOS
07010                                           ! 1650   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[1].iobase1)) = (0x0170);
07011                                           ! Debug: eq int = const $170 to unsigned short = [+$12C] (used reg = )
07012 1BC2           B8                   0170  mov	ax,#$170
07013 1BC5           A3         012C            mov	[$12C],ax
07014                                           !BCC_EOS
07015                                           ! 1651   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[1].iobase2)) = (0x370);
07016                                           ! Debug: eq int = const $370 to unsigned short = [+$12E] (used reg = )
07017 1BC8           B8                   0370  mov	ax,#$370
07018 1BCB           A3         012E            mov	[$12E],ax
07019                                           !BCC_EOS
07020                                           ! 1652   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[1].irq)) = (15);
07021                                           ! Debug: eq int = const $F to unsigned char = [+$130] (used reg = )
07022 1BCE           B0                     0F  mov	al,*$F
07023 1BD0           A2         0130            mov	[$130],al
07024                                           !BCC_EOS
07025                                           ! 1653   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[2].iface)) = (0x00);
07026                                           ! Debug: eq int = const 0 to unsigned char = [+$132] (used reg = )
07027 1BD3           30C0                       xor	al,al
07028 1BD5           A2         0132            mov	[$132],al
07029                                           !BCC_EOS
07030                                           ! 1654   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[2].iobase1)) = (0x1e8);
07031                                           ! Debug: eq int = const $1E8 to unsigned short = [+$134] (used reg = )
07032 1BD8           B8                   01E8  mov	ax,#$1E8
07033 1BDB           A3         0134            mov	[$134],ax
07034                                           !BCC_EOS
07035                                           ! 1655   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[2].iobase2)) = (0x3e0);
07036                                           ! Debug: eq int = const $3E0 to unsigned short = [+$136] (used reg = )
07037 1BDE           B8                   03E0  mov	ax,#$3E0
07038 1BE1           A3         0136            mov	[$136],ax
07039                                           !BCC_EOS
07040                                           ! 1656   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[2].irq)) = (12);
07041                                           ! Debug: eq int = const $C to unsigned char = [+$138] (used reg = )
07042 1BE4           B0                     0C  mov	al,*$C
07043 1BE6           A2         0138            mov	[$138],al
07044                                           !BCC_EOS
07045                                           ! 1657   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[3].iface)) = (0x00);
07046                                           ! Debug: eq int = const 0 to unsigned char = [+$13A] (used reg = )
07047 1BE9           30C0                       xor	al,al
07048 1BEB           A2         013A            mov	[$13A],al
07049                                           !BCC_EOS
07050                                           ! 1658   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[3].iobase1)) = (0x168);
07051                                           ! Debug: eq int = const $168 to unsigned short = [+$13C] (used reg = )
07052 1BEE           B8                   0168  mov	ax,#$168
07053 1BF1           A3         013C            mov	[$13C],ax
07054                                           !BCC_EOS
07055                                           ! 1659   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[3].iobase2)) = (0x360);
07056                                           ! Debug: eq int = const $360 to unsigned short = [+$13E] (used reg = )
07057 1BF4           B8                   0360  mov	ax,#$360
07058 1BF7           A3         013E            mov	[$13E],ax
07059                                           !BCC_EOS
07060                                           ! 1660   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[3].irq)) = (11);
07061                                           ! Debug: eq int = const $B to unsigned char = [+$140] (used reg = )
07062 1BFA           B0                     0B  mov	al,*$B
07063 1BFC           A2         0140            mov	[$140],al
07064                                           !BCC_EOS
07065                                           ! 1661   hdcount=cdcount=0;
07066                                           ! Debug: eq int = const 0 to unsigned char cdcount = [S+$208-4] (used reg = )
07067 1BFF           30C0                       xor	al,al
07068 1C01           8846         FE            mov	-2[bp],al
07069                                           ! Debug: eq unsigned char = al+0 to unsigned char hdcount = [S+$208-3] (used reg = )
07070 1C04           8846         FF            mov	-1[bp],al
07071                                           !BCC_EOS
07072                                           ! 1662   for(device=0; device<(4*2); device++) {
07073                                           ! Debug: eq int = const 0 to unsigned char device = [S+$208-5] (used reg = )
07074 1C07           30C0                       xor	al,al
07075 1C09           8846         FD            mov	-3[bp],al
07076                                           !BCC_EOS
07077                                           !BCC_EOS
07078 1C0C           E9         0C0F            br 	.1A1
07079                       00001C0F            .1A2:
07080                                           ! 1663     Bit16u iobase1, iobase2, blksize;
07081                                           !BCC_EOS
07082                                           ! 1664     Bit8u channel, slave, shift;
07083                                           !BCC_EOS
07084                                           ! 1665     Bit8u sc, sn, cl, ch, st;
07085                                           !BCC_EOS
07086                                           ! 1666     channel = device / 2;
07087 1C0F           83C4                   F2  add	sp,*-$E
07088                                           ! Debug: div int = const 2 to unsigned char device = [S+$216-5] (used reg = )
07089 1C12           8A46         FD            mov	al,-3[bp]
07090 1C15           30E4                       xor	ah,ah
07091 1C17           D1E8                       shr	ax,*1
07092                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$216-$20F] (used reg = )
07093 1C19           8886       FDF3            mov	-$20D[bp],al
07094                                           !BCC_EOS
07095                                           ! 1667     slave = device % 2;
07096                                           ! Debug: mod int = const 2 to unsigned char device = [S+$216-5] (used reg = )
07097 1C1D           8A46         FD            mov	al,-3[bp]
07098 1C20           30E4                       xor	ah,ah
07099 1C22           24                     01  and	al,*1
07100                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$216-$210] (used reg = )
07101 1C24           8886       FDF2            mov	-$20E[bp],al
07102                                           !BCC_EOS
07103                                           ! 1668     iobase1 =*((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1));
07104                                           ! Debug: ptradd unsigned char channel = [S+$216-$20F] to [4] struct  = const $122 (used reg = )
07105 1C28           8A86       FDF3            mov	al,-$20D[bp]
07106 1C2C           30E4                       xor	ah,ah
07107 1C2E           B1                     03  mov	cl,*3
07108 1C30           D3E0                       shl	ax,cl
07109 1C32           89C3                       mov	bx,ax
07110                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
07111                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
07112                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07113 1C34           8B9F       0124            mov	bx,$124[bx]
07114 1C38           899E       FDF8            mov	-$208[bp],bx
07115                                           !BCC_EOS
07116                                           ! 1669     iobase2 =*((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2));
07117                                           ! Debug: ptradd unsigned char channel = [S+$216-$20F] to [4] struct  = const $122 (used reg = )
07118 1C3C           8A86       FDF3            mov	al,-$20D[bp]
07119 1C40           30E4                       xor	ah,ah
07120 1C42           B1                     03  mov	cl,*3
07121 1C44           D3E0                       shl	ax,cl
07122 1C46           89C3                       mov	bx,ax
07123                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
07124                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
07125                                           ! Debug: eq unsigned short = [bx+$126] to unsigned short iobase2 = [S+$216-$20C] (used reg = )
07126 1C48           8B9F       0126            mov	bx,$126[bx]
07127 1C4C           899E       FDF6            mov	-$20A[bp],bx
07128                                           !BCC_EOS
07129                                           ! 1670     outb(io
07130                                           ! 1670 base2+6, 0x08 | 0x02);
07131                                           ! Debug: list int = const $A (used reg = )
07132 1C50           B8                   000A  mov	ax,*$A
07133 1C53           50                         push	ax
07134                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$218-$20C] (used reg = )
07135 1C54           8B86       FDF6            mov	ax,-$20A[bp]
07136                                           ! Debug: list unsigned int = ax+6 (used reg = )
07137 1C58           05                   0006  add	ax,*6
07138 1C5B           50                         push	ax
07139                                           ! Debug: func () void = outb+0 (used reg = )
07140 1C5C           E8         E8AF            call	_outb
07141 1C5F           83C4                   04  add	sp,*4
07142                                           !BCC_EOS
07143                                           ! 1671     outb(iobase1+6, slave ? 0xb0 : 0xa0);
07144 1C62           8A86       FDF2            mov	al,-$20E[bp]
07145 1C66           84C0                       test	al,al
07146 1C68           74           04            je  	.1A3
07147                       00001C6A            .1A4:
07148 1C6A           B0                     B0  mov	al,#$B0
07149 1C6C           EB           02            jmp .1A5
07150                       00001C6E            .1A3:
07151 1C6E           B0                     A0  mov	al,#$A0
07152                       00001C70            .1A5:
07153                                           ! Debug: list char = al+0 (used reg = )
07154 1C70           30E4                       xor	ah,ah
07155 1C72           50                         push	ax
07156                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07157 1C73           8B86       FDF8            mov	ax,-$208[bp]
07158                                           ! Debug: list unsigned int = ax+6 (used reg = )
07159 1C77           05                   0006  add	ax,*6
07160 1C7A           50                         push	ax
07161                                           ! Debug: func () void = outb+0 (used reg = )
07162 1C7B           E8         E890            call	_outb
07163 1C7E           83C4                   04  add	sp,*4
07164                                           !BCC_EOS
07165                                           ! 1672     outb(iobase1+2, 0x55);
07166                                           ! Debug: list int = const $55 (used reg = )
07167 1C81           B8                   0055  mov	ax,*$55
07168 1C84           50                         push	ax
07169                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07170 1C85           8B86       FDF8            mov	ax,-$208[bp]
07171                                           ! Debug: list unsigned int = ax+2 (used reg = )
07172 1C89           40                         inc	ax
07173 1C8A           40                         inc	ax
07174 1C8B           50                         push	ax
07175                                           ! Debug: func () void = outb+0 (used reg = )
07176 1C8C           E8         E87F            call	_outb
07177 1C8F           83C4                   04  add	sp,*4
07178                                           !BCC_EOS
07179                                           ! 1673     outb(iobase1+3, 0xaa);
07180                                           ! Debug: list int = const $AA (used reg = )
07181 1C92           B8                   00AA  mov	ax,#$AA
07182 1C95           50                         push	ax
07183                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07184 1C96           8B86       FDF8            mov	ax,-$208[bp]
07185                                           ! Debug: list unsigned int = ax+3 (used reg = )
07186 1C9A           05                   0003  add	ax,*3
07187 1C9D           50                         push	ax
07188                                           ! Debug: func () void = outb+0 (used reg = )
07189 1C9E           E8         E86D            call	_outb
07190 1CA1           83C4                   04  add	sp,*4
07191                                           !BCC_EOS
07192                                           ! 1674     outb(iobase1+2, 0xaa);
07193                                           ! Debug: list int = const $AA (used reg = )
07194 1CA4           B8                   00AA  mov	ax,#$AA
07195 1CA7           50                         push	ax
07196                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07197 1CA8           8B86       FDF8            mov	ax,-$208[bp]
07198                                           ! Debug: list unsigned int = ax+2 (used reg = )
07199 1CAC           40                         inc	ax
07200 1CAD           40                         inc	ax
07201 1CAE           50                         push	ax
07202                                           ! Debug: func () void = outb+0 (used reg = )
07203 1CAF           E8         E85C            call	_outb
07204 1CB2           83C4                   04  add	sp,*4
07205                                           !BCC_EOS
07206                                           ! 1675     outb(iobase1+3, 0x55);
07207                                           ! Debug: list int = const $55 (used reg = )
07208 1CB5           B8                   0055  mov	ax,*$55
07209 1CB8           50                         push	ax
07210                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07211 1CB9           8B86       FDF8            mov	ax,-$208[bp]
07212                                           ! Debug: list unsigned int = ax+3 (used reg = )
07213 1CBD           05                   0003  add	ax,*3
07214 1CC0           50                         push	ax
07215                                           ! Debug: func () void = outb+0 (used reg = )
07216 1CC1           E8         E84A            call	_outb
07217 1CC4           83C4                   04  add	sp,*4
07218                                           !BCC_EOS
07219                                           ! 1676     outb(iobase1+2, 0x55);
07220                                           ! Debug: list int = const $55 (used reg = )
07221 1CC7           B8                   0055  mov	ax,*$55
07222 1CCA           50                         push	ax
07223                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07224 1CCB           8B86       FDF8            mov	ax,-$208[bp]
07225                                           ! Debug: list unsigned int = ax+2 (used reg = )
07226 1CCF           40                         inc	ax
07227 1CD0           40                         inc	ax
07228 1CD1           50                         push	ax
07229                                           ! Debug: func () void = outb+0 (used reg = )
07230 1CD2           E8         E839            call	_outb
07231 1CD5           83C4                   04  add	sp,*4
07232                                           !BCC_EOS
07233                                           ! 1677     outb(iobase1+3, 0xaa);
07234                                           ! Debug: list int = const $AA (used reg = )
07235 1CD8           B8                   00AA  mov	ax,#$AA
07236 1CDB           50                         push	ax
07237                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07238 1CDC           8B86       FDF8            mov	ax,-$208[bp]
07239                                           ! Debug: list unsigned int = ax+3 (used reg = )
07240 1CE0           05                   0003  add	ax,*3
07241 1CE3           50                         push	ax
07242                                           ! Debug: func () void = outb+0 (used reg = )
07243 1CE4           E8         E827            call	_outb
07244 1CE7           83C4                   04  add	sp,*4
07245                                           !BCC_EOS
07246                                           ! 1678     sc = inb(iobase1+2);
07247                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07248 1CEA           8B86       FDF8            mov	ax,-$208[bp]
07249                                           ! Debug: list unsigned int = ax+2 (used reg = )
07250 1CEE           40                         inc	ax
07251 1CEF           40                         inc	ax
07252 1CF0           50                         push	ax
07253                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07254 1CF1           E8         E804            call	_inb
07255 1CF4           44                         inc	sp
07256 1CF5           44                         inc	sp
07257                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$216-$212] (used reg = )
07258 1CF6           8886       FDF0            mov	-$210[bp],al
07259                                           !BCC_EOS
07260                                           ! 1679     sn = inb(iobase1+3);
07261                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07262 1CFA           8B86       FDF8            mov	ax,-$208[bp]
07263                                           ! Debug: list unsigned int = ax+3 (used reg = )
07264 1CFE           05                   0003  add	ax,*3
07265 1D01           50                         push	ax
07266                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07267 1D02           E8         E7F3            call	_inb
07268 1D05           44                         inc	sp
07269 1D06           44                         inc	sp
07270                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$216-$213] (used reg = )
07271 1D07           8886       FDEF            mov	-$211[bp],al
07272                                           !BCC_EOS
07273                                           ! 1680     if ( (sc == 0x55) && (sn == 0xaa) ) {
07274                                           ! Debug: logeq int = const $55 to unsigned char sc = [S+$216-$212] (used reg = )
07275 1D0B           8A86       FDF0            mov	al,-$210[bp]
07276 1D0F           3C                     55  cmp	al,*$55
07277 1D11         0F85         0120            bne 	.1A6
07278                       00001D15            .1A8:
07279                                           ! Debug: logeq int = const $AA to unsigned char sn = [S+$216-$213] (used reg = )
07280 1D15           8A86       FDEF            mov	al,-$211[bp]
07281 1D19           3C                     AA  cmp	al,#$AA
07282 1D1B         0F85         0116            bne 	.1A6
07283                       00001D1F            .1A7:
07284                                           ! 1681       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type)) = (0x01);
07285                                           ! Debug: ptradd unsigned char device = [S+$216-5] to [8] struct  = const $142 (used reg = )
07286 1D1F           8A46         FD            mov	al,-3[bp]
07287 1D22           30E4                       xor	ah,ah
07288 1D24           B9                   001E  mov	cx,*$1E
07289 1D27           F7E9                       imul	cx
07290 1D29           89C3                       mov	bx,ax
07291                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07292                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
07293                                           ! Debug: eq int = const 1 to unsigned char = [bx+$142] (used reg = )
07294 1D2B           B0                     01  mov	al,*1
07295 1D2D           8887       0142            mov	$142[bx],al
07296                                           !BCC_EOS
07297                                           ! 1682       ata_reset(device);
07298                                           ! Debug: list unsigned char device = [S+$216-5] (used reg = )
07299 1D31           8A46         FD            mov	al,-3[bp]
07300 1D34           30E4                       xor	ah,ah
07301 1D36           50                         push	ax
07302                                           ! Debug: func () void = ata_reset+0 (used reg = )
07303 1D37           E8         0B28            call	_ata_reset
07304 1D3A           44                         inc	sp
07305 1D3B           44                         inc	sp
07306                                           !BCC_EOS
07307                                           ! 1683       outb(iobase1+6, slave ? 0xb0 : 0xa0);
07308 1D3C           8A86       FDF2            mov	al,-$20E[bp]
07309 1D40           84C0                       test	al,al
07310 1D42           74           04            je  	.1A9
07311                       00001D44            .1AA:
07312 1D44           B0                     B0  mov	al,#$B0
07313 1D46           EB           02            jmp .1AB
07314                       00001D48            .1A9:
07315 1D48           B0                     A0  mov	al,#$A0
07316                       00001D4A            .1AB:
07317                                           ! Debug: list char = al+0 (used reg = )
07318 1D4A           30E4                       xor	ah,ah
07319 1D4C           50                         push	ax
07320                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07321 1D4D           8B86       FDF8            mov	ax,-$208[bp]
07322                                           ! Debug: list unsigned int = ax+6 (used reg = )
07323 1D51           05                   0006  add	ax,*6
07324 1D54           50                         push	ax
07325                                           ! Debug: func () void = outb+0 (used reg = )
07326 1D55           E8         E7B6            call	_outb
07327 1D58           83C4                   04  add	sp,*4
07328                                           !BCC_EOS
07329                                           ! 1684       sc = inb(iobase1+2);
07330                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07331 1D5B           8B86       FDF8            mov	ax,-$208[bp]
07332                                           ! Debug: list unsigned int = ax+2 (used reg = )
07333 1D5F           40                         inc	ax
07334 1D60           40                         inc	ax
07335 1D61           50                         push	ax
07336                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07337 1D62           E8         E793            call	_inb
07338 1D65           44                         inc	sp
07339 1D66           44                         inc	sp
07340                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$216-$212] (used reg = )
07341 1D67           8886       FDF0            mov	-$210[bp],al
07342                                           !BCC_EOS
07343                                           ! 1685       sn = inb(iobase1+3);
07344                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07345 1D6B           8B86       FDF8            mov	ax,-$208[bp]
07346                                           ! Debug: list unsigned int = ax+3 (used reg = )
07347 1D6F           05                   0003  add	ax,*3
07348 1D72           50                         push	ax
07349                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07350 1D73           E8         E782            call	_inb
07351 1D76           44                         inc	sp
07352 1D77           44                         inc	sp
07353                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$216-$213] (used reg = )
07354 1D78           8886       FDEF            mov	-$211[bp],al
07355                                           !BCC_EOS
07356                                           ! 1686       if ((sc==0x01) && (sn==0x01)) {
07357                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$216-$212] (used reg = )
07358 1D7C           8A86       FDF0            mov	al,-$210[bp]
07359 1D80           3C                     01  cmp	al,*1
07360 1D82         0F85         00AF            bne 	.1AC
07361                       00001D86            .1AE:
07362                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$216-$213] (used reg = )
07363 1D86           8A86       FDEF            mov	al,-$211[bp]
07364 1D8A           3C                     01  cmp	al,*1
07365 1D8C         0F85         00A5            bne 	.1AC
07366                       00001D90            .1AD:
07367                                           ! 1687         cl = inb(iobase1+4);
07368                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07369 1D90           8B86       FDF8            mov	ax,-$208[bp]
07370                                           ! Debug: list unsigned int = ax+4 (used reg = )
07371 1D94           05                   0004  add	ax,*4
07372 1D97           50                         push	ax
07373                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07374 1D98           E8         E75D            call	_inb
07375 1D9B           44                         inc	sp
07376 1D9C           44                         inc	sp
07377                                           ! Debug: eq unsigned char = al+0 to unsigned char cl = [S+$216-$214] (used reg = )
07378 1D9D           8886       FDEE            mov	-$212[bp],al
07379                                           !BCC_EOS
07380                                           ! 1688         ch = inb(iobase1+5);
07381                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07382 1DA1           8B86       FDF8            mov	ax,-$208[bp]
07383                                           ! Debug: list unsigned int = ax+5 (used reg = )
07384 1DA5           05                   0005  add	ax,*5
07385 1DA8           50                         push	ax
07386                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07387 1DA9           E8         E74C            call	_inb
07388 1DAC           44                         inc	sp
07389 1DAD           44                         inc	sp
07390                                           ! Debug: eq unsigned char = al+0 to unsigned char ch = [S+$216-$215] (used reg = )
07391 1DAE           8886       FDED            mov	-$213[bp],al
07392                                           !BCC_EOS
07393                                           ! 1689         st = inb(iobase1+7);
07394                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07395 1DB2           8B86       FDF8            mov	ax,-$208[bp]
07396                                           ! Debug: list unsigned int = ax+7 (used reg = )
07397 1DB6           05                   0007  add	ax,*7
07398 1DB9           50                         push	ax
07399                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07400 1DBA           E8         E73B            call	_inb
07401 1DBD           44                         inc	sp
07402 1DBE           44                         inc	sp
07403                                           ! Debug: eq unsigned char = al+0 to unsigned char st = [S+$216-$216] (used reg = )
07404 1DBF           8886       FDEC            mov	-$214[bp],al
07405                                           !BCC_EOS
07406                                           ! 1690         if ((cl==0x14) && (ch==0xeb)) {
07407                                           ! Debug: logeq int = const $14 to unsigned char cl = [S+$216-$214] (used reg = )
07408 1DC3           8A86       FDEE            mov	al,-$212[bp]
07409 1DC7           3C                     14  cmp	al,*$14
07410 1DC9           75           1C            jne 	.1AF
07411                       00001DCB            .1B1:
07412                                           ! Debug: logeq int = const $EB to unsigned char ch = [S+$216-$215] (used reg = )
07413 1DCB           8A86       FDED            mov	al,-$213[bp]
07414 1DCF           3C                     EB  cmp	al,#$EB
07415 1DD1           75           14            jne 	.1AF
07416                       00001DD3            .1B0:
07417                                           ! 1691           *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type)) = (0x03);
07418                                           ! Debug: ptradd unsigned char device = [S+$216-5] to [8] struct  = const $142 (used reg = )
07419 1DD3           8A46         FD            mov	al,-3[bp]
07420 1DD6           30E4                       xor	ah,ah
07421 1DD8           B9                   001E  mov	cx,*$1E
07422 1DDB           F7E9                       imul	cx
07423 1DDD           89C3                       mov	bx,ax
07424                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07425                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
07426                                           ! Debug: eq int = const 3 to unsigned char = [bx+$142] (used reg = )
07427 1DDF           B0                     03  mov	al,*3
07428 1DE1           8887       0142            mov	$142[bx],al
07429                                           !BCC_EOS
07430                                           ! 1692         } else if ((cl==0x00) && (ch==0x00) && (st!=0x00)) {
07431 1DE5           EB           4E            jmp .1B2
07432                       00001DE7            .1AF:
07433                                           ! Debug: logeq int = const 0 to unsigned char cl = [S+$216-$214] (used reg = )
07434 1DE7           8A86       FDEE            mov	al,-$212[bp]
07435 1DEB           84C0                       test	al,al
07436 1DED           75           24            jne 	.1B3
07437                       00001DEF            .1B6:
07438                                           ! Debug: logeq int = const 0 to unsigned char ch = [S+$216-$215] (used reg = )
07439 1DEF           8A86       FDED            mov	al,-$213[bp]
07440 1DF3           84C0                       test	al,al
07441 1DF5           75           1C            jne 	.1B3
07442                       00001DF7            .1B5:
07443                                           ! Debug: ne int = const 0 to unsigned char st = [S+$216-$216] (used reg = )
07444 1DF7           8A86       FDEC            mov	al,-$214[bp]
07445 1DFB           84C0                       test	al,al
07446 1DFD           74           14            je  	.1B3
07447                       00001DFF            .1B4:
07448                                           ! 1693           *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type)) = (0x02);
07449                                           ! Debug: ptradd unsigned char device = [S+$216-5] to [8] struct  = const $142 (used reg = )
07450 1DFF           8A46         FD            mov	al,-3[bp]
07451 1E02           30E4                       xor	ah,ah
07452 1E04           B9                   001E  mov	cx,*$1E
07453 1E07           F7E9                       imul	cx
07454 1E09           89C3                       mov	bx,ax
07455                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07456                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
07457                                           ! Debug: eq int = const 2 to unsigned char = [bx+$142] (used reg = )
07458 1E0B           B0                     02  mov	al,*2
07459 1E0D           8887       0142            mov	$142[bx],al
07460                                           !BCC_EOS
07461                                           ! 1694         } else if ((cl==0xff) && (ch==0xff)) {
07462 1E11           EB           22            jmp .1B7
07463                       00001E13            .1B3:
07464                                           ! Debug: logeq int = const $FF to unsigned char cl = [S+$216-$214] (used reg = )
07465 1E13           8A86       FDEE            mov	al,-$212[bp]
07466 1E17           3C                     FF  cmp	al,#$FF
07467 1E19           75           1A            jne 	.1B8
07468                       00001E1B            .1BA:
07469                                           ! Debug: logeq int = const $FF to unsigned char ch = [S+$216-$215] (used reg = )
07470 1E1B           8A86       FDED            mov	al,-$213[bp]
07471 1E1F           3C                     FF  cmp	al,#$FF
07472 1E21           75           12            jne 	.1B8
07473                       00001E23            .1B9:
07474                                           ! 1695           *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type)) = (0x00);
07475                                           ! Debug: ptradd unsigned char device = [S+$216-5] to [8] struct  = const $142 (used reg = )
07476 1E23           8A46         FD            mov	al,-3[bp]
07477 1E26           30E4                       xor	ah,ah
07478 1E28           B9                   001E  mov	cx,*$1E
07479 1E2B           F7E9                       imul	cx
07480 1E2D           89C3                       mov	bx,ax
07481                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07482                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
07483                                           ! Debug: eq int = const 0 to unsigned char = [bx+$142] (used reg = )
07484 1E2F           30C0                       xor	al,al
07485 1E31           8887       0142            mov	$142[bx],al
07486                                           !BCC_EOS
07487                                           ! 1696         }
07488                                           ! 1697       }
07489                       00001E35            .1B8:
07490                       00001E35            .1B7:
07491                       00001E35            .1B2:
07492                                           ! 1698     }
07493                       00001E35            .1AC:
07494                                           ! 1699     type=*((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type));
07495                       00001E35            .1A6:
07496                                           ! Debug: ptradd unsigned char device = [S+$216-5] to [8] struct  = const $142 (used reg = )
07497 1E35           8A46         FD            mov	al,-3[bp]
07498 1E38           30E4                       xor	ah,ah
07499 1E3A           B9                   001E  mov	cx,*$1E
07500 1E3D           F7E9                       imul	cx
07501 1E3F           89C3                       mov	bx,ax
07502                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07503                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
07504                                           ! Debug: eq unsigned char = [bx+$142] to unsigned char type = [S+$216-6] (used reg = )
07505 1E41           8A87       0142            mov	al,$142[bx]
07506 1E45           8846         FC            mov	-4[bp],al
07507                                           !BCC_EOS
07508                                           ! 1700     if(type == 0x02) {
07509                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$216-6] (used reg = )
07510 1E48           8A46         FC            mov	al,-4[bp]
07511 1E4B           3C                     02  cmp	al,*2
07512 1E4D         0F85         04CC            bne 	.1BB
07513                       00001E51            .1BC:
07514                                           ! 1701       Bit32u sectors_low, sectors_high;
07515                                           !BCC_EOS
07516                                           ! 1702       Bit16u cylinders, heads, spt;
07517                                           !BCC_EOS
07518                                           ! 1703       Bit8u translation, removable, mode;
07519                                           !BCC_EOS
07520                                           ! 1704       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device)) = (0xFF);
07521 1E51           83C4                   EE  add	sp,*-$12
07522                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07523 1E54           8A46         FD            mov	al,-3[bp]
07524 1E57           30E4                       xor	ah,ah
07525 1E59           B9                   001E  mov	cx,*$1E
07526 1E5C           F7E9                       imul	cx
07527 1E5E           89C3                       mov	bx,ax
07528                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
07529                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
07530                                           ! Debug: eq int = const $FF to unsigned char = [bx+$143] (used reg = )
07531 1E60           B0                     FF  mov	al,#$FF
07532 1E62           8887       0143            mov	$143[bx],al
07533                                           !BCC_EOS
07534                                           ! 1705       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode)) = (0x00);
07535                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07536 1E66           8A46         FD            mov	al,-3[bp]
07537 1E69           30E4                       xor	ah,ah
07538 1E6B           B9                   001E  mov	cx,*$1E
07539 1E6E           F7E9                       imul	cx
07540 1E70           89C3                       mov	bx,ax
07541                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
07542                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
07543                                           ! Debug: eq int = const 0 to unsigned char = [bx+$146] (used reg = )
07544 1E72           30C0                       xor	al,al
07545 1E74           8887       0146            mov	$146[bx],al
07546                                           !BCC_EOS
07547                                           ! 1706       if (ata_cmd_data_io(0, device,0xEC, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) !=0 )
07548                                           ! Debug: list * unsigned char buffer = S+$228-$206 (used reg = )
07549 1E78           8D9E       FDFC            lea	bx,-$204[bp]
07550 1E7C           53                         push	bx
07551                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07552 1E7D           E8         E7DF            call	_get_SS
07553                                           ! Debug: list unsigned short = ax+0 (used reg = )
07554 1E80           50                         push	ax
07555                                           ! Debug: list long = const 0 (used reg = )
07556 1E81           31C0                       xor	ax,ax
07557 1E83           31DB                       xor	bx,bx
07558 1E85           53                         push	bx
07559 1E86           50                         push	ax
07560                                           ! Debug: list long = const 0 (used reg = )
07561 1E87           31C0                       xor	ax,ax
07562 1E89           31DB                       xor	bx,bx
07563 1E8B           53                         push	bx
07564 1E8C           50                         push	ax
07565                                           ! Debug: list int = const 0 (used reg = )
07566 1E8D           31C0                       xor	ax,ax
07567 1E8F           50                         push	ax
07568                                           ! Debug: list int = const 0 (used reg = )
07569 1E90           31C0                       xor	ax,ax
07570 1E92           50                         push	ax
07571                                           ! Debug: list int = const 0 (used reg = )
07572 1E93           31C0                       xor	ax,ax
07573 1E95           50                         push	ax
07574                                           ! Debug: list int = const 1 (used reg = )
07575 1E96           B8                   0001  mov	ax,*1
07576 1E99           50                         push	ax
07577                                           ! Debug: list int = const $EC (used reg = )
07578 1E9A           B8                   00EC  mov	ax,#$EC
07579 1E9D           50                         push	ax
07580                                           ! Debug: list unsigned char device = [S+$23E-5] (used reg = )
07581 1E9E           8A46         FD            mov	al,-3[bp]
07582 1EA1           30E4                       xor	ah,ah
07583 1EA3           50                         push	ax
07584                                           ! Debug: list int = const 0 (used reg = )
07585 1EA4           31C0                       xor	ax,ax
07586 1EA6           50                         push	ax
07587                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
07588 1EA7           E8         0ADF            call	_ata_cmd_data_io
07589 1EAA           83C4                   1A  add	sp,*$1A
07590                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
07591 1EAD           85C0                       test	ax,ax
07592 1EAF           74           0E            je  	.1BD
07593                       00001EB1            .1BE:
07594                                           ! 1707         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATA device\n");
07595                                           ! Debug: list * char = .1BF+0 (used reg = )
07596 1EB1           BB                   D7C0  mov	bx,#.1BF
07597 1EB4           53                         push	bx
07598                                           ! Debug: list int = const 7 (used reg = )
07599 1EB5           B8                   0007  mov	ax,*7
07600 1EB8           50                         push	ax
07601                                           ! Debug: func () void = bios_printf+0 (used reg = )
07602 1EB9           E8         EA82            call	_bios_printf
07603 1EBC           83C4                   04  add	sp,*4
07604                                           !BCC_EOS
07605                                           ! 1708       removable = (read_byte_SS(buffer+0) & 0x80) >> 7;
07606                       00001EBF            .1BD:
07607                                           ! Debug: list * unsigned char buffer = S+$228-$206 (used reg = )
07608 1EBF           8D9E       FDFC            lea	bx,-$204[bp]
07609 1EC3           53                         push	bx
07610                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
07611 1EC4           E8         E75F            call	_read_byte_SS
07612 1EC7           44                         inc	sp
07613 1EC8           44                         inc	sp
07614                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
07615 1EC9           24                     80  and	al,#$80
07616                                           ! Debug: sr int = const 7 to unsigned char = al+0 (used reg = )
07617 1ECB           30E4                       xor	ah,ah
07618 1ECD           B1                     07  mov	cl,*7
07619 1ECF           D3E8                       shr	ax,cl
07620                                           ! Debug: eq unsigned int = ax+0 to unsigned char removable = [S+$228-$226] (used reg = )
07621 1ED1           8886       FDDC            mov	-$224[bp],al
07622                                           !BCC_EOS
07623                                           ! 1709       mode = read_byte_SS(buffer+96) ? 0x01 : 0x00;
07624                                           ! Debug: list * unsigned char buffer = S+$228-$1A6 (used reg = )
07625 1ED5           8D9E       FE5C            lea	bx,-$1A4[bp]
07626 1ED9           53                         push	bx
07627                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
07628 1EDA           E8         E749            call	_read_byte_SS
07629 1EDD           44                         inc	sp
07630 1EDE           44                         inc	sp
07631 1EDF           84C0                       test	al,al
07632 1EE1           74           04            je  	.1C0
07633                       00001EE3            .1C1:
07634 1EE3           B0                     01  mov	al,*1
07635 1EE5           EB           02            jmp .1C2
07636                       00001EE7            .1C0:
07637 1EE7           30C0                       xor	al,al
07638                       00001EE9            .1C2:
07639                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$228-$227] (used reg = )
07640 1EE9           8886       FDDB            mov	-$225[bp],al
07641                                           !BCC_EOS
07642                                           ! 1710       blksize = read_word_SS(buffer+10);
07643                                           ! Debug: list * unsigned char buffer = S+$228-$1FC (used reg = )
07644 1EED           8D9E       FE06            lea	bx,-$1FA[bp]
07645 1EF1           53                         push	bx
07646                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
07647 1EF2           E8         E73C            call	_read_word_SS
07648 1EF5           44                         inc	sp
07649 1EF6           44                         inc	sp
07650                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$228-$20E] (used reg = )
07651 1EF7           8986       FDF4            mov	-$20C[bp],ax
07652                                           !BCC_EOS
07653                                           ! 1711       cylinders = read_word_SS(buffer+(1*2));
07654                                           ! Debug: list * unsigned char buffer = S+$228-$204 (used reg = )
07655 1EFB           8D9E       FDFE            lea	bx,-$202[bp]
07656 1EFF           53                         push	bx
07657                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
07658 1F00           E8         E72E            call	_read_word_SS
07659 1F03           44                         inc	sp
07660 1F04           44                         inc	sp
07661                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$220] (used reg = )
07662 1F05           8986       FDE2            mov	-$21E[bp],ax
07663                                           !BCC_EOS
07664                                           ! 1712       heads = read_word_SS(buffer+(3*2));
07665                                           ! Debug: list * unsigned char buffer = S+$228-$200 (used reg = )
07666 1F09           8D9E       FE02            lea	bx,-$1FE[bp]
07667 1F0D           53                         push	bx
07668                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
07669 1F0E           E8         E720            call	_read_word_SS
07670 1F11           44                         inc	sp
07671 1F12           44                         inc	sp
07672                                           ! Debug: eq unsigned short = ax+0 to unsigned short heads = [S+$228-$222] (used reg = )
07673 1F13           8986       FDE0            mov	-$220[bp],ax
07674                                           !BCC_EOS
07675                                           ! 1713       spt = read_word_SS(buffer+(6*2));
07676                                           ! Debug: list * unsigned char buffer = S+$228-$1FA (used reg = )
07677 1F17           8D9E       FE08            lea	bx,-$1F8[bp]
07678 1F1B           53                         push	bx
07679                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
07680 1F1C           E8         E712            call	_read_word_SS
07681 1F1F           44                         inc	sp
07682 1F20           44                         inc	sp
07683                                           ! Debug: eq unsigned short = ax+0 to unsigned short spt = [S+$228-$224] (used reg = )
07684 1F21           8986       FDDE            mov	-$222[bp],ax
07685                                           !BCC_EOS
07686                                           ! 1714       if (read_word_SS(buffer+(83*2)) & (1 << 10)) {
07687                                           ! Debug: list * unsigned char buffer = S+$228-$160 (used reg = )
07688 1F25           8D9E       FEA2            lea	bx,-$15E[bp]
07689 1F29           53                         push	bx
07690                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
07691 1F2A           E8         E704            call	_read_word_SS
07692 1F2D           44                         inc	sp
07693 1F2E           44                         inc	sp
07694                                           ! Debug: and int = const $400 to unsigned short = ax+0 (used reg = )
07695 1F2F           25                   0400  and	ax,#$400
07696 1F32           85C0                       test	ax,ax
07697 1F34           74           2A            je  	.1C3
07698                       00001F36            .1C4:
07699                                           ! 1715         sectors_low = read_dword_SS(buffer+(100*2));
07700                                           ! Debug: list * unsigned char buffer = S+$228-$13E (used reg = )
07701 1F36           8D9E       FEC4            lea	bx,-$13C[bp]
07702 1F3A           53                         push	bx
07703                                           ! Debug: func () unsigned long = read_dword_SS+0 (used reg = )
07704 1F3B           E8         E140            call	_read_dword_SS
07705 1F3E           89D3                       mov	bx,dx
07706 1F40           44                         inc	sp
07707 1F41           44                         inc	sp
07708                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$21A] (used reg = )
07709 1F42           8986       FDE8            mov	-$218[bp],ax
07710 1F46           899E       FDEA            mov	-$216[bp],bx
07711                                           !BCC_EOS
07712                                           ! 1716         sectors_high = read_dword_SS(buffer+(102*2));
07713                                           ! Debug: list * unsigned char buffer = S+$228-$13A (used reg = )
07714 1F4A           8D9E       FEC8            lea	bx,-$138[bp]
07715 1F4E           53                         push	bx
07716                                           ! Debug: func () unsigned long = read_dword_SS+0 (used reg = )
07717 1F4F           E8         E12C            call	_read_dword_SS
07718 1F52           89D3                       mov	bx,dx
07719 1F54           44                         inc	sp
07720 1F55           44                         inc	sp
07721                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_high = [S+$228-$21E] (used reg = )
07722 1F56           8986       FDE4            mov	-$21C[bp],ax
07723 1F5A           899E       FDE6            mov	-$21A[bp],bx
07724                                           !BCC_EOS
07725                                           ! 1717       } else {
07726 1F5E           EB           20            jmp .1C5
07727                       00001F60            .1C3:
07728                                           ! 1718      
07729                                           ! 1718    sectors_low = read_dword_SS(buffer+(60*2));
07730                                           ! Debug: list * unsigned char buffer = S+$228-$18E (used reg = )
07731 1F60           8D9E       FE74            lea	bx,-$18C[bp]
07732 1F64           53                         push	bx
07733                                           ! Debug: func () unsigned long = read_dword_SS+0 (used reg = )
07734 1F65           E8         E116            call	_read_dword_SS
07735 1F68           89D3                       mov	bx,dx
07736 1F6A           44                         inc	sp
07737 1F6B           44                         inc	sp
07738                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$21A] (used reg = )
07739 1F6C           8986       FDE8            mov	-$218[bp],ax
07740 1F70           899E       FDEA            mov	-$216[bp],bx
07741                                           !BCC_EOS
07742                                           ! 1719         sectors_high = 0;
07743                                           ! Debug: eq int = const 0 to unsigned long sectors_high = [S+$228-$21E] (used reg = )
07744 1F74           31C0                       xor	ax,ax
07745 1F76           31DB                       xor	bx,bx
07746 1F78           8986       FDE4            mov	-$21C[bp],ax
07747 1F7C           899E       FDE6            mov	-$21A[bp],bx
07748                                           !BCC_EOS
07749                                           ! 1720       }
07750                                           ! 1721       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device)) = (0xFF);
07751                       00001F80            .1C5:
07752                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07753 1F80           8A46         FD            mov	al,-3[bp]
07754 1F83           30E4                       xor	ah,ah
07755 1F85           B9                   001E  mov	cx,*$1E
07756 1F88           F7E9                       imul	cx
07757 1F8A           89C3                       mov	bx,ax
07758                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
07759                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
07760                                           ! Debug: eq int = const $FF to unsigned char = [bx+$143] (used reg = )
07761 1F8C           B0                     FF  mov	al,#$FF
07762 1F8E           8887       0143            mov	$143[bx],al
07763                                           !BCC_EOS
07764                                           ! 1722       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].removable)) = (removable);
07765                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07766 1F92           8A46         FD            mov	al,-3[bp]
07767 1F95           30E4                       xor	ah,ah
07768 1F97           B9                   001E  mov	cx,*$1E
07769 1F9A           F7E9                       imul	cx
07770 1F9C           89C3                       mov	bx,ax
07771                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
07772                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$144 (used reg = )
07773                                           ! Debug: eq unsigned char removable = [S+$228-$226] to unsigned char = [bx+$144] (used reg = )
07774 1F9E           8A86       FDDC            mov	al,-$224[bp]
07775 1FA2           8887       0144            mov	$144[bx],al
07776                                           !BCC_EOS
07777                                           ! 1723       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode)) = (mode);
07778                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07779 1FA6           8A46         FD            mov	al,-3[bp]
07780 1FA9           30E4                       xor	ah,ah
07781 1FAB           B9                   001E  mov	cx,*$1E
07782 1FAE           F7E9                       imul	cx
07783 1FB0           89C3                       mov	bx,ax
07784                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
07785                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
07786                                           ! Debug: eq unsigned char mode = [S+$228-$227] to unsigned char = [bx+$146] (used reg = )
07787 1FB2           8A86       FDDB            mov	al,-$225[bp]
07788 1FB6           8887       0146            mov	$146[bx],al
07789                                           !BCC_EOS
07790                                           ! 1724       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].blksize)) = (blksize);
07791                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07792 1FBA           8A46         FD            mov	al,-3[bp]
07793 1FBD           30E4                       xor	ah,ah
07794 1FBF           B9                   001E  mov	cx,*$1E
07795 1FC2           F7E9                       imul	cx
07796 1FC4           89C3                       mov	bx,ax
07797                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
07798                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$148 (used reg = )
07799                                           ! Debug: eq unsigned short blksize = [S+$228-$20E] to unsigned short = [bx+$148] (used reg = )
07800 1FC6           8B86       FDF4            mov	ax,-$20C[bp]
07801 1FCA           8987       0148            mov	$148[bx],ax
07802                                           !BCC_EOS
07803                                           ! 1725       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.heads)) = (heads);
07804                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07805 1FCE           8A46         FD            mov	al,-3[bp]
07806 1FD1           30E4                       xor	ah,ah
07807 1FD3           B9                   001E  mov	cx,*$1E
07808 1FD6           F7E9                       imul	cx
07809 1FD8           89C3                       mov	bx,ax
07810                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
07811                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$152 (used reg = )
07812                                           ! Debug: eq unsigned short heads = [S+$228-$222] to unsigned short = [bx+$152] (used reg = )
07813 1FDA           8B86       FDE0            mov	ax,-$220[bp]
07814 1FDE           8987       0152            mov	$152[bx],ax
07815                                           !BCC_EOS
07816                                           ! 1726       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders)) = (cylinders);
07817                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07818 1FE2           8A46         FD            mov	al,-3[bp]
07819 1FE5           30E4                       xor	ah,ah
07820 1FE7           B9                   001E  mov	cx,*$1E
07821 1FEA           F7E9                       imul	cx
07822 1FEC           89C3                       mov	bx,ax
07823                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
07824                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$154 (used reg = )
07825                                           ! Debug: eq unsigned short cylinders = [S+$228-$220] to unsigned short = [bx+$154] (used reg = )
07826 1FEE           8B86       FDE2            mov	ax,-$21E[bp]
07827 1FF2           8987       0154            mov	$154[bx],ax
07828                                           !BCC_EOS
07829                                           ! 1727       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.spt)) = (spt);
07830                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07831 1FF6           8A46         FD            mov	al,-3[bp]
07832 1FF9           30E4                       xor	ah,ah
07833 1FFB           B9                   001E  mov	cx,*$1E
07834 1FFE           F7E9                       imul	cx
07835 2000           89C3                       mov	bx,ax
07836                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
07837                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$156 (used reg = )
07838                                           ! Debug: eq unsigned short spt = [S+$228-$224] to unsigned short = [bx+$156] (used reg = )
07839 2002           8B86       FDDE            mov	ax,-$222[bp]
07840 2006           8987       0156            mov	$156[bx],ax
07841                                           !BCC_EOS
07842                                           ! 1728       *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_low)) = (sectors_low);
07843                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07844 200A           8A46         FD            mov	al,-3[bp]
07845 200D           30E4                       xor	ah,ah
07846 200F           B9                   001E  mov	cx,*$1E
07847 2012           F7E9                       imul	cx
07848 2014           89C3                       mov	bx,ax
07849                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
07850                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$158 (used reg = )
07851                                           ! Debug: eq unsigned long sectors_low = [S+$228-$21A] to unsigned long = [bx+$158] (used reg = )
07852 2016           8B86       FDE8            mov	ax,-$218[bp]
07853 201A           8BB6       FDEA            mov	si,-$216[bp]
07854 201E           8987       0158            mov	$158[bx],ax
07855 2022           89B7       015A            mov	$15A[bx],si
07856                                           !BCC_EOS
07857                                           ! 1729       *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high)) = (sectors_high);
07858                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07859 2026           8A46         FD            mov	al,-3[bp]
07860 2029           30E4                       xor	ah,ah
07861 202B           B9                   001E  mov	cx,*$1E
07862 202E           F7E9                       imul	cx
07863 2030           89C3                       mov	bx,ax
07864                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
07865                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
07866                                           ! Debug: eq unsigned long sectors_high = [S+$228-$21E] to unsigned long = [bx+$15C] (used reg = )
07867 2032           8B86       FDE4            mov	ax,-$21C[bp]
07868 2036           8BB6       FDE6            mov	si,-$21A[bp]
07869 203A           8987       015C            mov	$15C[bx],ax
07870 203E           89B7       015E            mov	$15E[bx],si
07871                                           !BCC_EOS
07872                                           ! 1730       bios_printf(4, "ata%d-%d: PCHS=%u/%d/%d translation=", channel, slave,cylinders, heads, spt);
07873                                           ! Debug: list unsigned short spt = [S+$228-$224] (used reg = )
07874 2042           FFB6       FDDE            push	-$222[bp]
07875                                           ! Debug: list unsigned short heads = [S+$22A-$222] (used reg = )
07876 2046           FFB6       FDE0            push	-$220[bp]
07877                                           ! Debug: list unsigned short cylinders = [S+$22C-$220] (used reg = )
07878 204A           FFB6       FDE2            push	-$21E[bp]
07879                                           ! Debug: list unsigned char slave = [S+$22E-$210] (used reg = )
07880 204E           8A86       FDF2            mov	al,-$20E[bp]
07881 2052           30E4                       xor	ah,ah
07882 2054           50                         push	ax
07883                                           ! Debug: list unsigned char channel = [S+$230-$20F] (used reg = )
07884 2055           8A86       FDF3            mov	al,-$20D[bp]
07885 2059           30E4                       xor	ah,ah
07886 205B           50                         push	ax
07887                                           ! Debug: list * char = .1C6+0 (used reg = )
07888 205C           BB                   D79B  mov	bx,#.1C6
07889 205F           53                         push	bx
07890                                           ! Debug: list int = const 4 (used reg = )
07891 2060           B8                   0004  mov	ax,*4
07892 2063           50                         push	ax
07893                                           ! Debug: func () void = bios_printf+0 (used reg = )
07894 2064           E8         E8D7            call	_bios_printf
07895 2067           83C4                   0E  add	sp,*$E
07896                                           !BCC_EOS
07897                                           ! 1731       translation = inb_cmos(0x39 + channel/2);
07898                                           ! Debug: div int = const 2 to unsigned char channel = [S+$228-$20F] (used reg = )
07899 206A           8A86       FDF3            mov	al,-$20D[bp]
07900 206E           30E4                       xor	ah,ah
07901 2070           D1E8                       shr	ax,*1
07902                                           ! Debug: add unsigned int = ax+0 to int = const $39 (used reg = )
07903                                           ! Debug: expression subtree swapping
07904                                           ! Debug: list unsigned int = ax+$39 (used reg = )
07905 2072           05                   0039  add	ax,*$39
07906 2075           50                         push	ax
07907                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
07908 2076           E8         E4C4            call	_inb_cmos
07909 2079           44                         inc	sp
07910 207A           44                         inc	sp
07911                                           ! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$228-$225] (used reg = )
07912 207B           8886       FDDD            mov	-$223[bp],al
07913                                           !BCC_EOS
07914                                           ! 1732       for (shift=device%4; shift>0; shift--) translation >>= 2;
07915                                           ! Debug: mod int = const 4 to unsigned char device = [S+$228-5] (used reg = )
07916 207F           8A46         FD            mov	al,-3[bp]
07917 2082           30E4                       xor	ah,ah
07918 2084           24                     03  and	al,*3
07919                                           ! Debug: eq unsigned char = al+0 to unsigned char shift = [S+$228-$211] (used reg = )
07920 2086           8886       FDF1            mov	-$20F[bp],al
07921                                           !BCC_EOS
07922                                           !BCC_EOS
07923 208A           EB           17            jmp .1C9
07924                       0000208C            .1CA:
07925                                           ! Debug: srab int = const 2 to unsigned char translation = [S+$228-$225] (used reg = )
07926 208C           8A86       FDDD            mov	al,-$223[bp]
07927 2090           30E4                       xor	ah,ah
07928 2092           D1E8                       shr	ax,*1
07929 2094           D1E8                       shr	ax,*1
07930 2096           8886       FDDD            mov	-$223[bp],al
07931                                           !BCC_EOS
07932                                           ! 1733       translation &= 0x03;
07933                       0000209A            .1C8:
07934                                           ! Debug: postdec unsigned char shift = [S+$228-$211] (used reg = )
07935 209A           8A86       FDF1            mov	al,-$20F[bp]
07936 209E           48                         dec	ax
07937 209F           8886       FDF1            mov	-$20F[bp],al
07938                       000020A3            .1C9:
07939                                           ! Debug: gt int = const 0 to unsigned char shift = [S+$228-$211] (used reg = )
07940 20A3           8A86       FDF1            mov	al,-$20F[bp]
07941 20A7           84C0                       test	al,al
07942 20A9           75           E1            jne	.1CA
07943                       000020AB            .1CB:
07944                       000020AB            .1C7:
07945                                           ! Debug: andab int = const 3 to unsigned char translation = [S+$228-$225] (used reg = )
07946 20AB           8A86       FDDD            mov	al,-$223[bp]
07947 20AF           24                     03  and	al,*3
07948 20B1           8886       FDDD            mov	-$223[bp],al
07949                                           !BCC_EOS
07950                                           ! 1734       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].translation)) = (translation);
07951                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07952 20B5           8A46         FD            mov	al,-3[bp]
07953 20B8           30E4                       xor	ah,ah
07954 20BA           B9                   001E  mov	cx,*$1E
07955 20BD           F7E9                       imul	cx
07956 20BF           89C3                       mov	bx,ax
07957                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
07958                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$14A (used reg = )
07959                                           ! Debug: eq unsigned char translation = [S+$228-$225] to unsigned char = [bx+$14A] (used reg = )
07960 20C1           8A86       FDDD            mov	al,-$223[bp]
07961 20C5           8887       014A            mov	$14A[bx],al
07962                                           !BCC_EOS
07963                                           ! 1735       switch (translation) {
07964 20C9           8A86       FDDD            mov	al,-$223[bp]
07965 20CD           EB           42            jmp .1CE
07966                                           ! 1736         case 0:
07967                                           ! 1737           bios_printf(4, "none");
07968                       000020CF            .1CF:
07969                                           ! Debug: list * char = .1D0+0 (used reg = )
07970 20CF           BB                   D796  mov	bx,#.1D0
07971 20D2           53                         push	bx
07972                                           ! Debug: list int = const 4 (used reg = )
07973 20D3           B8                   0004  mov	ax,*4
07974 20D6           50                         push	ax
07975                                           ! Debug: func () void = bios_printf+0 (used reg = )
07976 20D7           E8         E864            call	_bios_printf
07977 20DA           83C4                   04  add	sp,*4
07978                                           !BCC_EOS
07979                                           ! 1738           break;
07980 20DD           EB           42            jmp .1CC
07981                                           !BCC_EOS
07982                                           ! 1739         case 1:
07983                                           ! 1740           bios_printf(4, "lba");
07984                       000020DF            .1D1:
07985                                           ! Debug: list * char = .1D2+0 (used reg = )
07986 20DF           BB                   D792  mov	bx,#.1D2
07987 20E2           53                         push	bx
07988                                           ! Debug: list int = const 4 (used reg = )
07989 20E3           B8                   0004  mov	ax,*4
07990 20E6           50                         push	ax
07991                                           ! Debug: func () void = bios_printf+0 (used reg = )
07992 20E7           E8         E854            call	_bios_printf
07993 20EA           83C4                   04  add	sp,*4
07994                                           !BCC_EOS
07995                                           ! 1741           break;
07996 20ED           EB           32            jmp .1CC
07997                                           !BCC_EOS
07998                                           ! 1742         case 2:
07999                                           ! 1743           bios_printf(4, "large");
08000                       000020EF            .1D3:
08001                                           ! Debug: list * char = .1D4+0 (used reg = )
08002 20EF           BB                   D78C  mov	bx,#.1D4
08003 20F2           53                         push	bx
08004                                           ! Debug: list int = const 4 (used reg = )
08005 20F3           B8                   0004  mov	ax,*4
08006 20F6           50                         push	ax
08007                                           ! Debug: func () void = bios_printf+0 (used reg = )
08008 20F7           E8         E844            call	_bios_printf
08009 20FA           83C4                   04  add	sp,*4
08010                                           !BCC_EOS
08011                                           ! 1744           break;
08012 20FD           EB           22            jmp .1CC
08013                                           !BCC_EOS
08014                                           ! 1745         case 3:
08015                                           ! 1746           bios_printf(4, "r-echs");
08016                       000020FF            .1D5:
08017                                           ! Debug: list * char = .1D6+0 (used reg = )
08018 20FF           BB                   D785  mov	bx,#.1D6
08019 2102           53                         push	bx
08020                                           ! Debug: list int = const 4 (used reg = )
08021 2103           B8                   0004  mov	ax,*4
08022 2106           50                         push	ax
08023                                           ! Debug: func () void = bios_printf+0 (used reg = )
08024 2107           E8         E834            call	_bios_printf
08025 210A           83C4                   04  add	sp,*4
08026                                           !BCC_EOS
08027                                           ! 1747           break;
08028 210D           EB           12            jmp .1CC
08029                                           !BCC_EOS
08030                                           ! 1748       }
08031                                           ! 1749       switch (translation) {
08032 210F           EB           10            jmp .1CC
08033                       00002111            .1CE:
08034 2111           2C                     00  sub	al,*0
08035 2113           74           BA            je 	.1CF
08036 2115           2C                     01  sub	al,*1
08037 2117           74           C6            je 	.1D1
08038 2119           2C                     01  sub	al,*1
08039 211B           74           D2            je 	.1D3
08040 211D           2C                     01  sub	al,*1
08041 211F           74           DE            je 	.1D5
08042                       00002121            .1CC:
08043                       FFFFFDD8            ..FFFE	=	-$228
08044 2121           8A86       FDDD            mov	al,-$223[bp]
08045 2125           E9         0161            br 	.1D9
08046                                           ! 1750         case 0:
08047                                           ! 1751           break;
08048                       00002128            .1DA:
08049 2128           E9         0174            br 	.1D7
08050                                           !BCC_EOS
08051                                           ! 1752         case 1:
08052                                           ! 1753           spt = 63;
08053                       0000212B            .1DB:
08054                                           ! Debug: eq int = const $3F to unsigned short spt = [S+$228-$224] (used reg = )
08055 212B           B8                   003F  mov	ax,*$3F
08056 212E           8986       FDDE            mov	-$222[bp],ax
08057                                           !BCC_EOS
08058                                           ! 1754           sectors_low /= 63;
08059                                           ! Debug: divab unsigned long = const $3F to unsigned long sectors_low = [S+$228-$21A] (used reg = )
08060 2132           B8                   003F  mov	ax,*$3F
08061 2135           31DB                       xor	bx,bx
08062 2137           53                         push	bx
08063 2138           50                         push	ax
08064 2139           8B86       FDE8            mov	ax,-$218[bp]
08065 213D           8B9E       FDEA            mov	bx,-$216[bp]
08066 2141           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08067 2145           E8         DFF7            call	ldivul
08068 2148           8986       FDE8            mov	-$218[bp],ax
08069 214C           899E       FDEA            mov	-$216[bp],bx
08070 2150           83C4                   04  add	sp,*4
08071                                           !BCC_EOS
08072                                           ! 1755           heads = sectors_low / 1024;
08073                                           ! Debug: div unsigned long = const $400 to unsigned long sectors_low = [S+$228-$21A] (used reg = )
08074 2153           B8                   0400  mov	ax,#$400
08075 2156           31DB                       xor	bx,bx
08076 2158           53                         push	bx
08077 2159           50                         push	ax
08078 215A           8B86       FDE8            mov	ax,-$218[bp]
08079 215E           8B9E       FDEA            mov	bx,-$216[bp]
08080 2162           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08081 2166           E8         DFD6            call	ldivul
08082 2169           83C4                   04  add	sp,*4
08083                                           ! Debug: eq unsigned long = bx+0 to unsigned short heads = [S+$228-$222] (used reg = )
08084 216C           8986       FDE0            mov	-$220[bp],ax
08085                                           !BCC_EOS
08086                                           ! 1756           if (heads>128) heads = 255;
08087                                           ! Debug: gt int = const $80 to unsigned short heads = [S+$228-$222] (used reg = )
08088 2170           8B86       FDE0            mov	ax,-$220[bp]
08089 2174           3D                   0080  cmp	ax,#$80
08090 2177           76           09            jbe 	.1DC
08091                       00002179            .1DD:
08092                                           ! Debug: eq int = const $FF to unsigned short heads = [S+$228-$222] (used reg = )
08093 2179           B8                   00FF  mov	ax,#$FF
08094 217C           8986       FDE0            mov	-$220[bp],ax
08095                                           !BCC_EOS
08096                                           ! 1757           else if (heads>64) heads = 128;
08097 2180           EB           3D            jmp .1DE
08098                       00002182            .1DC:
08099                                           ! Debug: gt int = const $40 to unsigned short heads = [S+$228-$222] (used reg = )
08100 2182           8B86       FDE0            mov	ax,-$220[bp]
08101 2186           3D                   0040  cmp	ax,*$40
08102 2189           76           09            jbe 	.1DF
08103                       0000218B            .1E0:
08104                                           ! Debug: eq int = const $80 to unsigned short heads = [S+$228-$222] (used reg = )
08105 218B           B8                   0080  mov	ax,#$80
08106 218E           8986       FDE0            mov	-$220[bp],ax
08107                                           !BCC_EOS
08108                                           ! 1758           else if (heads>32) heads = 64;
08109 2192           EB           2B            jmp .1E1
08110                       00002194            .1DF:
08111                                           ! Debug: gt int = const $20 to unsigned short heads = [S+$228-$222] (used reg = )
08112 2194           8B86       FDE0            mov	ax,-$220[bp]
08113 2198           3D                   0020  cmp	ax,*$20
08114 219B           76           09            jbe 	.1E2
08115                       0000219D            .1E3:
08116                                           ! Debug: eq int = const $40 to unsigned short heads = [S+$228-$222] (used reg = )
08117 219D           B8                   0040  mov	ax,*$40
08118 21A0           8986       FDE0            mov	-$220[bp],ax
08119                                           !BCC_EOS
08120                                           ! 1759           else if (heads>16) heads = 32;
08121 21A4           EB           19            jmp .1E4
08122                       000021A6            .1E2:
08123                                           ! Debug: gt int = const $10 to unsigned short heads = [S+$228-$222] (used reg = )
08124 21A6           8B86       FDE0            mov	ax,-$220[bp]
08125 21AA           3D                   0010  cmp	ax,*$10
08126 21AD           76           09            jbe 	.1E5
08127                       000021AF            .1E6:
08128                                           ! Debug: eq int = const $20 to unsigned short heads = [S+$228-$222] (used reg = )
08129 21AF           B8                   0020  mov	ax,*$20
08130 21B2           8986       FDE0            mov	-$220[bp],ax
08131                                           !BCC_EOS
08132                                           ! 1760           else heads=16;
08133 21B6           EB           07            jmp .1E7
08134                       000021B8            .1E5:
08135                                           ! Debug: eq int = const $10 to unsigned short heads = [S+$228-$222] (used reg = )
08136 21B8           B8                   0010  mov	ax,*$10
08137 21BB           8986       FDE0            mov	-$220[bp],ax
08138                                           !BCC_EOS
08139                                           ! 1761           cylinders = sectors_low / heads;
08140                       000021BF            .1E7:
08141                       000021BF            .1E4:
08142                       000021BF            .1E1:
08143                       000021BF            .1DE:
08144                                           ! Debug: cast unsigned long = const 0 to unsigned short heads = [S+$228-$222] (used reg = )
08145 21BF           8B86       FDE0            mov	ax,-$220[bp]
08146 21C3           31DB                       xor	bx,bx
08147                                           ! Debug: div unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$21A] (used reg = )
08148 21C5           53                         push	bx
08149 21C6           50                         push	ax
08150 21C7           8B86       FDE8            mov	ax,-$218[bp]
08151 21CB           8B9E       FDEA            mov	bx,-$216[bp]
08152 21CF           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08153 21D3           E8         DF69            call	ldivul
08154 21D6           83C4                   04  add	sp,*4
08155                                           ! Debug: eq unsigned long = bx+0 to unsigned short cylinders = [S+$228-$220] (used reg = )
08156 21D9           8986       FDE2            mov	-$21E[bp],ax
08157                                           !BCC_EOS
08158                                           ! 1762           break;
08159 21DD           E9         00BF            br 	.1D7
08160                                           !BCC_EOS
08161                                           ! 1763         case 3:
08162                                           ! 1764           if (heads==16) {
08163                       000021E0            .1E8:
08164                                           ! Debug: logeq int = const $10 to unsigned short heads = [S+$228-$222] (used reg = )
08165 21E0           8B86       FDE0            mov	ax,-$220[bp]
08166 21E4           3D                   0010  cmp	ax,*$10
08167 21E7           75           72            jne 	.1E9
08168                       000021E9            .1EA:
08169                                           ! 1765             if(cylinders>61439) cylinders=61439;
08170                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$220] (used reg = )
08171 21E9           8B86       FDE2            mov	ax,-$21E[bp]
08172 21ED           31DB                       xor	bx,bx
08173                                           ! Debug: gt long = const $EFFF to unsigned long = bx+0 (used reg = )
08174 21EF           53                         push	bx
08175 21F0           50                         push	ax
08176 21F1           B8                   EFFF  mov	ax,#$EFFF
08177 21F4           31DB                       xor	bx,bx
08178 21F6           53                         push	bx
08179 21F7           50                         push	ax
08180 21F8           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08181 21FC           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08182 2200           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08183 2204           E8         DE95            call	lcmpul
08184 2207           8DA6       FDDA            lea	sp,2+..FFFD[bp]
08185 220B           76           07            jbe 	.1EB
08186                       0000220D            .1EC:
08187                                           ! Debug: eq long = const $EFFF to unsigned short cylinders = [S+$228-$220] (used reg = )
08188 220D           B8                   EFFF  mov	ax,#$EFFF
08189 2210           8986       FDE2            mov	-$21E[bp],ax
08190                                           !BCC_EOS
08191                                           ! 1766             heads=15;
08192                       00002214            .1EB:
08193                                           ! Debug: eq int = const $F to unsigned short heads = [S+$228-$222] (used reg = )
08194 2214           B8                   000F  mov	ax,*$F
08195 2217           8986       FDE0            mov	-$220[bp],ax
08196                                           !BCC_EOS
08197                                           ! 1767             cylinders = (Bit16u)
08198                                           ! 1767 ((Bit32u)(cylinders)*16/15);
08199                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$220] (used reg = )
08200 221B           8B86       FDE2            mov	ax,-$21E[bp]
08201 221F           31DB                       xor	bx,bx
08202                                           ! Debug: mul unsigned long = const $10 to unsigned long = bx+0 (used reg = )
08203 2221           53                         push	bx
08204 2222           50                         push	ax
08205 2223           B8                   0010  mov	ax,*$10
08206 2226           31DB                       xor	bx,bx
08207 2228           53                         push	bx
08208 2229           50                         push	ax
08209 222A           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08210 222E           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08211 2232           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08212 2236           E8         DE81            call	lmulul
08213 2239           83C4                   08  add	sp,*8
08214                                           ! Debug: div unsigned long = const $F to unsigned long = bx+0 (used reg = )
08215 223C           53                         push	bx
08216 223D           50                         push	ax
08217 223E           B8                   000F  mov	ax,*$F
08218 2241           31DB                       xor	bx,bx
08219 2243           53                         push	bx
08220 2244           50                         push	ax
08221 2245           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08222 2249           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08223 224D           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08224 2251           E8         DEEB            call	ldivul
08225 2254           83C4                   08  add	sp,*8
08226                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
08227                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$220] (used reg = )
08228 2257           8986       FDE2            mov	-$21E[bp],ax
08229                                           !BCC_EOS
08230                                           ! 1768           }
08231                                           ! 1769         case 2:
08232                       0000225B            .1E9:
08233                                           ! 1770           while(cylinders > 1024) {
08234                       0000225B            .1ED:
08235 225B           EB           1F            jmp .1EF
08236                       0000225D            .1F0:
08237                                           ! 1771             cylinders >>= 1;
08238                                           ! Debug: srab int = const 1 to unsigned short cylinders = [S+$228-$220] (used reg = )
08239 225D           8B86       FDE2            mov	ax,-$21E[bp]
08240 2261           D1E8                       shr	ax,*1
08241 2263           8986       FDE2            mov	-$21E[bp],ax
08242                                           !BCC_EOS
08243                                           ! 1772             heads <<= 1;
08244                                           ! Debug: slab int = const 1 to unsigned short heads = [S+$228-$222] (used reg = )
08245 2267           8B86       FDE0            mov	ax,-$220[bp]
08246 226B           D1E0                       shl	ax,*1
08247 226D           8986       FDE0            mov	-$220[bp],ax
08248                                           !BCC_EOS
08249                                           ! 1773             if (heads > 127) break;
08250                                           ! Debug: gt int = const $7F to unsigned short heads = [S+$228-$222] (used reg = )
08251 2271           8B86       FDE0            mov	ax,-$220[bp]
08252 2275           3D                   007F  cmp	ax,*$7F
08253 2278           76           02            jbe 	.1F1
08254                       0000227A            .1F2:
08255 227A           EB           09            jmp .1EE
08256                                           !BCC_EOS
08257                                           ! 1774           }
08258                       0000227C            .1F1:
08259                                           ! 1775           break;
08260                       0000227C            .1EF:
08261                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$220] (used reg = )
08262 227C           8B86       FDE2            mov	ax,-$21E[bp]
08263 2280           3D                   0400  cmp	ax,#$400
08264 2283           77           D8            ja 	.1F0
08265                       00002285            .1F3:
08266                       00002285            .1EE:
08267 2285           EB           18            jmp .1D7
08268                                           !BCC_EOS
08269                                           ! 1776       }
08270                                           ! 1777       if (cylinders > 1024) cylinders=1024;
08271 2287           EB           16            jmp .1D7
08272                       00002289            .1D9:
08273 2289           2C                     00  sub	al,*0
08274 228B         0F84         FE99            beq 	.1DA
08275 228F           2C                     01  sub	al,*1
08276 2291         0F84         FE96            beq 	.1DB
08277 2295           2C                     01  sub	al,*1
08278 2297           74           C2            je 	.1ED
08279 2299           2C                     01  sub	al,*1
08280 229B         0F84         FF41            beq 	.1E8
08281                       0000229F            .1D7:
08282                       FFFFFDD8            ..FFFD	=	-$228
08283                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$220] (used reg = )
08284 229F           8B86       FDE2            mov	ax,-$21E[bp]
08285 22A3           3D                   0400  cmp	ax,#$400
08286 22A6           76           07            jbe 	.1F4
08287                       000022A8            .1F5:
08288                                           ! Debug: eq int = const $400 to unsigned short cylinders = [S+$228-$220] (used reg = )
08289 22A8           B8                   0400  mov	ax,#$400
08290 22AB           8986       FDE2            mov	-$21E[bp],ax
08291                                           !BCC_EOS
08292                                           ! 1778       bios_printf(4, " LCHS=%d/%d/%d\n", cylinders, heads, spt);
08293                       000022AF            .1F4:
08294                                           ! Debug: list unsigned short spt = [S+$228-$224] (used reg = )
08295 22AF           FFB6       FDDE            push	-$222[bp]
08296                                           ! Debug: list unsigned short heads = [S+$22A-$222] (used reg = )
08297 22B3           FFB6       FDE0            push	-$220[bp]
08298                                           ! Debug: list unsigned short cylinders = [S+$22C-$220] (used reg = )
08299 22B7           FFB6       FDE2            push	-$21E[bp]
08300                                           ! Debug: list * char = .1F6+0 (used reg = )
08301 22BB           BB                   D775  mov	bx,#.1F6
08302 22BE           53                         push	bx
08303                                           ! Debug: list int = const 4 (used reg = )
08304 22BF           B8                   0004  mov	ax,*4
08305 22C2           50                         push	ax
08306                                           ! Debug: func () void = bios_printf+0 (used reg = )
08307 22C3           E8         E678            call	_bios_printf
08308 22C6           83C4                   0A  add	sp,*$A
08309                                           !BCC_EOS
08310                                           ! 1779       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.heads)) = (heads);
08311                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
08312 22C9           8A46         FD            mov	al,-3[bp]
08313 22CC           30E4                       xor	ah,ah
08314 22CE           B9                   001E  mov	cx,*$1E
08315 22D1           F7E9                       imul	cx
08316 22D3           89C3                       mov	bx,ax
08317                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
08318                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14C (used reg = )
08319                                           ! Debug: eq unsigned short heads = [S+$228-$222] to unsigned short = [bx+$14C] (used reg = )
08320 22D5           8B86       FDE0            mov	ax,-$220[bp]
08321 22D9           8987       014C            mov	$14C[bx],ax
08322                                           !BCC_EOS
08323                                           ! 1780       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders)) = (cylinders);
08324                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
08325 22DD           8A46         FD            mov	al,-3[bp]
08326 22E0           30E4                       xor	ah,ah
08327 22E2           B9                   001E  mov	cx,*$1E
08328 22E5           F7E9                       imul	cx
08329 22E7           89C3                       mov	bx,ax
08330                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
08331                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14E (used reg = )
08332                                           ! Debug: eq unsigned short cylinders = [S+$228-$220] to unsigned short = [bx+$14E] (used reg = )
08333 22E9           8B86       FDE2            mov	ax,-$21E[bp]
08334 22ED           8987       014E            mov	$14E[bx],ax
08335                                           !BCC_EOS
08336                                           ! 1781       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.spt)) = (spt);
08337                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
08338 22F1           8A46         FD            mov	al,-3[bp]
08339 22F4           30E4                       xor	ah,ah
08340 22F6           B9                   001E  mov	cx,*$1E
08341 22F9           F7E9                       imul	cx
08342 22FB           89C3                       mov	bx,ax
08343                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
08344                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$150 (used reg = )
08345                                           ! Debug: eq unsigned short spt = [S+$228-$224] to unsigned short = [bx+$150] (used reg = )
08346 22FD           8B86       FDDE            mov	ax,-$222[bp]
08347 2301           8987       0150            mov	$150[bx],ax
08348                                           !BCC_EOS
08349                                           ! 1782       *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdidmap[hdcount])) = (device);
08350                                           ! Debug: ptradd unsigned char hdcount = [S+$228-3] to [8] unsigned char = const $233 (used reg = )
08351 2305           8A46         FF            mov	al,-1[bp]
08352 2308           30E4                       xor	ah,ah
08353 230A           89C3                       mov	bx,ax
08354                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
08355                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$233 (used reg = )
08356                                           ! Debug: eq unsigned char device = [S+$228-5] to unsigned char = [bx+$233] (used reg = )
08357 230C           8A46         FD            mov	al,-3[bp]
08358 230F           8887       0233            mov	$233[bx],al
08359                                           !BCC_EOS
08360                                           ! 1783       hdcount++;
08361                                           ! Debug: postinc unsigned char hdcount = [S+$228-3] (used reg = )
08362 2313           8A46         FF            mov	al,-1[bp]
08363 2316           40                         inc	ax
08364 2317           8846         FF            mov	-1[bp],al
08365                                           !BCC_EOS
08366                                           ! 1784     }
08367 231A           83C4                   12  add	sp,*$12
08368                                           ! 1785     if(type == 0x03) {
08369                       0000231D            .1BB:
08370                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$216-6] (used reg = )
08371 231D           8A46         FC            mov	al,-4[bp]
08372 2320           3C                     03  cmp	al,*3
08373 2322         0F85         011F            bne 	.1F7
08374                       00002326            .1F8:
08375                                           ! 1786       Bit8u type, removable, mode;
08376                                           !BCC_EOS
08377                                           ! 1787       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device)) = (0x05);
08378 2326           83C4                   FC  add	sp,*-4
08379                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08380 2329           8A46         FD            mov	al,-3[bp]
08381 232C           30E4                       xor	ah,ah
08382 232E           B9                   001E  mov	cx,*$1E
08383 2331           F7E9                       imul	cx
08384 2333           89C3                       mov	bx,ax
08385                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08386                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
08387                                           ! Debug: eq int = const 5 to unsigned char = [bx+$143] (used reg = )
08388 2335           B0                     05  mov	al,*5
08389 2337           8887       0143            mov	$143[bx],al
08390                                           !BCC_EOS
08391                                           ! 1788       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode)) = (0x00);
08392                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08393 233B           8A46         FD            mov	al,-3[bp]
08394 233E           30E4                       xor	ah,ah
08395 2340           B9                   001E  mov	cx,*$1E
08396 2343           F7E9                       imul	cx
08397 2345           89C3                       mov	bx,ax
08398                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08399                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
08400                                           ! Debug: eq int = const 0 to unsigned char = [bx+$146] (used reg = )
08401 2347           30C0                       xor	al,al
08402 2349           8887       0146            mov	$146[bx],al
08403                                           !BCC_EOS
08404                                           ! 1789       if (ata_cmd_data_io(0, device,0xA1, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) != 0)
08405                                           ! Debug: list * unsigned char buffer = S+$21A-$206 (used reg = )
08406 234D           8D9E       FDFC            lea	bx,-$204[bp]
08407 2351           53                         push	bx
08408                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08409 2352           E8         E30A            call	_get_SS
08410                                           ! Debug: list unsigned short = ax+0 (used reg = )
08411 2355           50                         push	ax
08412                                           ! Debug: list long = const 0 (used reg = )
08413 2356           31C0                       xor	ax,ax
08414 2358           31DB                       xor	bx,bx
08415 235A           53                         push	bx
08416 235B           50                         push	ax
08417                                           ! Debug: list long = const 0 (used reg = )
08418 235C           31C0                       xor	ax,ax
08419 235E           31DB                       xor	bx,bx
08420 2360           53                         push	bx
08421 2361           50                         push	ax
08422                                           ! Debug: list int = const 0 (used reg = )
08423 2362           31C0                       xor	ax,ax
08424 2364           50                         push	ax
08425                                           ! Debug: list int = const 0 (used reg = )
08426 2365           31C0                       xor	ax,ax
08427 2367           50                         push	ax
08428                                           ! Debug: list int = const 0 (used reg = )
08429 2368           31C0                       xor	ax,ax
08430 236A           50                         push	ax
08431                                           ! Debug: list int = const 1 (used reg = )
08432 236B           B8                   0001  mov	ax,*1
08433 236E           50                         push	ax
08434                                           ! Debug: list int = const $A1 (used reg = )
08435 236F           B8                   00A1  mov	ax,#$A1
08436 2372           50                         push	ax
08437                                           ! Debug: list unsigned char device = [S+$230-5] (used reg = )
08438 2373           8A46         FD            mov	al,-3[bp]
08439 2376           30E4                       xor	ah,ah
08440 2378           50                         push	ax
08441                                           ! Debug: list int = const 0 (used reg = )
08442 2379           31C0                       xor	ax,ax
08443 237B           50                         push	ax
08444                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
08445 237C           E8         060A            call	_ata_cmd_data_io
08446 237F           83C4                   1A  add	sp,*$1A
08447                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
08448 2382           85C0                       test	ax,ax
08449 2384           74           0E            je  	.1F9
08450                       00002386            .1FA:
08451                                           ! 1790         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATAPI device\n");
08452                                           ! Debug: list * char = .1FB+0 (used reg = )
08453 2386           BB                   D74A  mov	bx,#.1FB
08454 2389           53                         push	bx
08455                                           ! Debug: list int = const 7 (used reg = )
08456 238A           B8                   0007  mov	ax,*7
08457 238D           50                         push	ax
08458                                           ! Debug: func () void = bios_printf+0 (used reg = )
08459 238E           E8         E5AD            call	_bios_printf
08460 2391           83C4                   04  add	sp,*4
08461                                           !BCC_EOS
08462                                           ! 1791       type = read_byte_SS(buffer+1) & 0x1f;
08463                       00002394            .1F9:
08464                                           ! Debug: list * unsigned char buffer = S+$21A-$205 (used reg = )
08465 2394           8D9E       FDFD            lea	bx,-$203[bp]
08466 2398           53                         push	bx
08467                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08468 2399           E8         E28A            call	_read_byte_SS
08469 239C           44                         inc	sp
08470 239D           44                         inc	sp
08471                                           ! Debug: and int = const $1F to unsigned char = al+0 (used reg = )
08472 239E           24                     1F  and	al,*$1F
08473                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$21A-$217] (used reg = )
08474 23A0           8886       FDEB            mov	-$215[bp],al
08475                                           !BCC_EOS
08476                                           ! 1792       removable = (read_byte_SS(buffer+0) & 0x80) ? 1 : 0;
08477                                           ! Debug: list * unsigned char buffer = S+$21A-$206 (used reg = )
08478 23A4           8D9E       FDFC            lea	bx,-$204[bp]
08479 23A8           53                         push	bx
08480                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08481 23A9           E8         E27A            call	_read_byte_SS
08482 23AC           44                         inc	sp
08483 23AD           44                         inc	sp
08484                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
08485 23AE           24                     80  and	al,#$80
08486 23B0           84C0                       test	al,al
08487 23B2           74           04            je  	.1FC
08488                       000023B4            .1FD:
08489 23B4           B0                     01  mov	al,*1
08490 23B6           EB           02            jmp .1FE
08491                       000023B8            .1FC:
08492 23B8           30C0                       xor	al,al
08493                       000023BA            .1FE:
08494                                           ! Debug: eq char = al+0 to unsigned char removable = [S+$21A-$218] (used reg = )
08495 23BA           8886       FDEA            mov	-$216[bp],al
08496                                           !BCC_EOS
08497                                           ! 1793       mode = read_byte_SS(buffer+96) ? 0x01 : 0x00;
08498                                           ! Debug: list * unsigned char buffer = S+$21A-$1A6 (used reg = )
08499 23BE           8D9E       FE5C            lea	bx,-$1A4[bp]
08500 23C2           53                         push	bx
08501                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08502 23C3           E8         E260            call	_read_byte_SS
08503 23C6           44                         inc	sp
08504 23C7           44                         inc	sp
08505 23C8           84C0                       test	al,al
08506 23CA           74           04            je  	.1FF
08507                       000023CC            .200:
08508 23CC           B0                     01  mov	al,*1
08509 23CE           EB           02            jmp .201
08510                       000023D0            .1FF:
08511 23D0           30C0                       xor	al,al
08512                       000023D2            .201:
08513                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$21A-$219] (used reg = )
08514 23D2           8886       FDE9            mov	-$217[bp],al
08515                                           !BCC_EOS
08516                                           ! 1794       blksize = 2048;
08517                                           ! Debug: eq int = const $800 to unsigned short blksize = [S+$21A-$20E] (used reg = )
08518 23D6           B8                   0800  mov	ax,#$800
08519 23D9           8986       FDF4            mov	-$20C[bp],ax
08520                                           !BCC_EOS
08521                                           ! 1795       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device)) = (type);
08522                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08523 23DD           8A46         FD            mov	al,-3[bp]
08524 23E0           30E4                       xor	ah,ah
08525 23E2           B9                   001E  mov	cx,*$1E
08526 23E5           F7E9                       imul	cx
08527 23E7           89C3                       mov	bx,ax
08528                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08529                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
08530                                           ! Debug: eq unsigned char type = [S+$21A-$217] to unsigned char = [bx+$143] (used reg = )
08531 23E9           8A86       FDEB            mov	al,-$215[bp]
08532 23ED           8887       0143            mov	$143[bx],al
08533                                           !BCC_EOS
08534                                           ! 1796       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].removable)) = (removable);
08535                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08536 23F1           8A46         FD            mov	al,-3[bp]
08537 23F4           30E4                       xor	ah,ah
08538 23F6           B9                   001E  mov	cx,*$1E
08539 23F9           F7E9                       imul	cx
08540 23FB           89C3                       mov	bx,ax
08541                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
08542                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$144 (used reg = )
08543                                           ! Debug: eq unsigned char removable = [S+$21A-$218] to unsigned char = [bx+$144] (used reg = )
08544 23FD           8A86       FDEA            mov	al,-$216[bp]
08545 2401           8887       0144            mov	$144[bx],al
08546                                           !BCC_EOS
08547                                           ! 1797       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode)) = (mode);
08548                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08549 2405           8A46         FD            mov	al,-3[bp]
08550 2408           30E4                       xor	ah,ah
08551 240A           B9                   001E  mov	cx,*$1E
08552 240D           F7E9                       imul	cx
08553 240F           89C3                       mov	bx,ax
08554                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08555                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
08556                                           ! Debug: eq unsigned char mode = [S+$21A-$219] to unsigned char = [bx+$146] (used reg = )
08557 2411           8A86       FDE9            mov	al,-$217[bp]
08558 2415           8887       0146            mov	$146[bx],al
08559                                           !BCC_EOS
08560                                           ! 1798       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].blksize)) = (blksize);
08561                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08562 2419           8A46         FD            mov	al,-3[bp]
08563 241C           30E4                       xor	ah,ah
08564 241E           B9                   001E  mov	cx,*$1E
08565 2421           F7E9                       imul	cx
08566 2423           89C3                       mov	bx,ax
08567                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
08568                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$148 (used reg = )
08569                                           ! Debug: eq unsigned short blksize = [S+$21A-$20E] to unsigned short = [bx+$148] (used reg = )
08570 2425           8B86       FDF4            mov	ax,-$20C[bp]
08571 2429           8987       0148            mov	$148[bx],ax
08572                                           !BCC_EOS
08573                                           ! 1799       *((Bit8u *)(&((ebda_data_t *) 0)->ata.cdidmap[cdcount])) = (device);
08574                                           ! Debug: ptradd unsigned char cdcount = [S+$21A-4] to [8] unsigned char = const $23C (used reg = )
08575 242D           8A46         FE            mov	al,-2[bp]
08576 2430           30E4                       xor	ah,ah
08577 2432           89C3                       mov	bx,ax
08578                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
08579                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$23C (used reg = )
08580                                           ! Debug: eq unsigned char device = [S+$21A-5] to unsigned char = [bx+$23C] (used reg = )
08581 2434           8A46         FD            mov	al,-3[bp]
08582 2437           8887       023C            mov	$23C[bx],al
08583                                           !BCC_EOS
08584                                           ! 1800       cdcount++;
08585                                           ! Debug: postinc unsigned char cdcount = [S+$21A-4] (used reg = )
08586 243B           8A46         FE            mov	al,-2[bp]
08587 243E           40                         inc	ax
08588 243F           8846         FE            mov	-2[bp],al
08589                                           !BCC_EOS
08590                                           ! 1801     }
08591 2442           83C4                   04  add	sp,*4
08592                                           ! 1802     {
08593                       00002445            .1F7:
08594                                           ! 1803       Bit32u sizeinmb;
08595                                           !BCC_EOS
08596                                           ! 1804       Bit16u ataversion;
08597                                           !BCC_EOS
08598                                           ! 1805       Bit8u c, i, lshift, rshift, version, model[41];
08599                                           !BCC_EOS
08600                                           ! 1806       switch (type) {
08601 2445           83C4                   CC  add	sp,*-$34
08602 2448           8A46         FC            mov	al,-4[bp]
08603 244B           E9         0213            br 	.204
08604                                           ! 1807         case 0x02:
08605                                           ! 1808           switch (blksize) {
08606                       0000244E            .205:
08607 244E           8B86       FDF4            mov	ax,-$20C[bp]
08608 2452           EB           2A            jmp .208
08609                                           ! 1809             case 1024:
08610                                           ! 1810               lshift = 22;
08611                       00002454            .209:
08612                                           ! Debug: eq int = const $16 to unsigned char lshift = [S+$24A-$21F] (used reg = )
08613 2454           B0                     16  mov	al,*$16
08614 2456           8886       FDE3            mov	-$21D[bp],al
08615                                           !BCC_EOS
08616                                           ! 1811               rshift = 10;
08617                                           ! Debug: eq int = const $A to unsigned char rshift = [S+$24A-$220] (used reg = )
08618 245A           B0                     0A  mov	al,*$A
08619 245C           8886       FDE2            mov	-$21E[bp],al
08620                                           !BCC_EOS
08621                                           ! 1812               break;
08622 2460           EB           28            jmp .206
08623                                           !BCC_EOS
08624                                           ! 1813             case 4096:
08625                                           ! 1814               lshift = 24;
08626                       00002462            .20A:
08627                                           ! Debug: eq int = const $18 to unsigned char lshift = [S+$24A-$21F] (used reg = )
08628 2462           B0                     18  mov	al,*$18
08629 2464           8886       FDE3            mov	-$21D[bp],al
08630                                           !BCC_EOS
08631                                           ! 1815               rshift = 8;
08632                                           ! Debug: eq int = const 8 to unsigned char rshift = [S+$24A-$220] (used reg = )
08633 2468           B0                     08  mov	al,*8
08634 246A           8886       FDE2            mov	-$21E[bp],al
08635                                           !BCC_EOS
08636                                           ! 1816               break;
08637 246E           EB           1A            jmp .206
08638                                           !BCC_EOS
08639                                           ! 1817        
08640                                           ! 1817      default:
08641                                           ! 1818               lshift = 21;
08642                       00002470            .20B:
08643                                           ! Debug: eq int = const $15 to unsigned char lshift = [S+$24A-$21F] (used reg = )
08644 2470           B0                     15  mov	al,*$15
08645 2472           8886       FDE3            mov	-$21D[bp],al
08646                                           !BCC_EOS
08647                                           ! 1819               rshift = 11;
08648                                           ! Debug: eq int = const $B to unsigned char rshift = [S+$24A-$220] (used reg = )
08649 2476           B0                     0B  mov	al,*$B
08650 2478           8886       FDE2            mov	-$21E[bp],al
08651                                           !BCC_EOS
08652                                           ! 1820           }
08653                                           ! 1821           sizeinmb = (*((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high)) << lshift)
08654 247C           EB           0C            jmp .206
08655                       0000247E            .208:
08656 247E           2D                   0400  sub	ax,#$400
08657 2481           74           D1            je 	.209
08658 2483           2D                   0C00  sub	ax,#$C00
08659 2486           74           DA            je 	.20A
08660 2488           EB           E6            jmp	.20B
08661                       0000248A            .206:
08662                                           ! 1822             | (*((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_low)) >> rshift);
08663                                           ! Debug: ptradd unsigned char device = [S+$24A-5] to [8] struct  = const $142 (used reg = )
08664 248A           8A46         FD            mov	al,-3[bp]
08665 248D           30E4                       xor	ah,ah
08666 248F           B9                   001E  mov	cx,*$1E
08667 2492           F7E9                       imul	cx
08668 2494           89C3                       mov	bx,ax
08669                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
08670                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$158 (used reg = )
08671                                           ! Debug: sr unsigned char rshift = [S+$24A-$220] to unsigned long = [bx+$158] (used reg = )
08672 2496           8A86       FDE2            mov	al,-$21E[bp]
08673 249A           50                         push	ax
08674 249B           8B87       0158            mov	ax,$158[bx]
08675 249F           8B9F       015A            mov	bx,$15A[bx]
08676 24A3           8A8E       FDB6            mov	cl,0+..FFFC[bp]
08677 24A7           30ED                       xor	ch,ch
08678 24A9           89CF                       mov	di,cx
08679 24AB           E8         DC4C            call	lsrul
08680 24AE           44                         inc	sp
08681 24AF           44                         inc	sp
08682 24B0           53                         push	bx
08683 24B1           50                         push	ax
08684                                           ! Debug: ptradd unsigned char device = [S+$24E-5] to [8] struct  = const $142 (used reg = )
08685 24B2           8A46         FD            mov	al,-3[bp]
08686 24B5           30E4                       xor	ah,ah
08687 24B7           B9                   001E  mov	cx,*$1E
08688 24BA           F7E9                       imul	cx
08689 24BC           89C3                       mov	bx,ax
08690                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
08691                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
08692                                           ! Debug: sl unsigned char lshift = [S+$24E-$21F] to unsigned long = [bx+$15C] (used reg = )
08693 24BE           8A86       FDE3            mov	al,-$21D[bp]
08694 24C2           50                         push	ax
08695 24C3           8B87       015C            mov	ax,$15C[bx]
08696 24C7           8B9F       015E            mov	bx,$15E[bx]
08697 24CB           8A8E       FDB2            mov	cl,-4+..FFFC[bp]
08698 24CF           30ED                       xor	ch,ch
08699 24D1           89CF                       mov	di,cx
08700 24D3           E8         DC42            call	lslul
08701 24D6           44                         inc	sp
08702 24D7           44                         inc	sp
08703                                           ! Debug: or unsigned long (temp) = [S+$24E-$24E] to unsigned long = bx+0 (used reg = )
08704 24D8           8DBE       FDB4            lea	di,-2+..FFFC[bp]
08705 24DC           E8         DBF9            call	lorul
08706 24DF           83C4                   04  add	sp,*4
08707                                           ! Debug: eq unsigned long = bx+0 to unsigned long sizeinmb = [S+$24A-$21A] (used reg = )
08708 24E2           8986       FDE8            mov	-$218[bp],ax
08709 24E6           899E       FDEA            mov	-$216[bp],bx
08710                                           !BCC_EOS
08711                                           ! 1823         case 0x03:
08712                                           ! 1824           ataversion=((Bit16u)(read_byte_SS(buffer+161))<<8)|read_byte_SS(buffer+160);
08713                       000024EA            .20C:
08714                                           ! Debug: list * unsigned char buffer = S+$24A-$166 (used reg = )
08715 24EA           8D9E       FE9C            lea	bx,-$164[bp]
08716 24EE           53                         push	bx
08717                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08718 24EF           E8         E134            call	_read_byte_SS
08719 24F2           44                         inc	sp
08720 24F3           44                         inc	sp
08721 24F4           50                         push	ax
08722                                           ! Debug: list * unsigned char buffer = S+$24C-$165 (used reg = )
08723 24F5           8D9E       FE9D            lea	bx,-$163[bp]
08724 24F9           53                         push	bx
08725                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08726 24FA           E8         E129            call	_read_byte_SS
08727 24FD           44                         inc	sp
08728 24FE           44                         inc	sp
08729                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
08730 24FF           30E4                       xor	ah,ah
08731                                           ! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
08732 2501           88C4                       mov	ah,al
08733 2503           30C0                       xor	al,al
08734                                           ! Debug: or unsigned char (temp) = [S+$24C-$24C] to unsigned int = ax+0 (used reg = )
08735 2505           0A86       FDB6            or	al,0+..FFFC[bp]
08736 2509           44                         inc	sp
08737 250A           44                         inc	sp
08738                                           ! Debug: eq unsigned int = ax+0 to unsigned short ataversion = [S+$24A-$21C] (used reg = )
08739 250B           8986       FDE6            mov	-$21A[bp],ax
08740                                           !BCC_EOS
08741                                           ! 1825           for(version=15;version>0;version--) {
08742                                           ! Debug: eq int = const $F to unsigned char version = [S+$24A-$221] (used reg = )
08743 250F           B0                     0F  mov	al,*$F
08744 2511           8886       FDE1            mov	-$21F[bp],al
08745                                           !BCC_EOS
08746                                           !BCC_EOS
08747 2515           EB           22            jmp .20F
08748                       00002517            .210:
08749                                           ! 1826             if((ataversion&(1<<version))!=0)
08750                                           ! Debug: sl unsigned char version = [S+$24A-$221] to int = const 1 (used reg = )
08751 2517           8A86       FDE1            mov	al,-$21F[bp]
08752 251B           30E4                       xor	ah,ah
08753 251D           89C3                       mov	bx,ax
08754 251F           B8                   0001  mov	ax,*1
08755 2522           89D9                       mov	cx,bx
08756 2524           D3E0                       shl	ax,cl
08757                                           ! Debug: and int = ax+0 to unsigned short ataversion = [S+$24A-$21C] (used reg = )
08758                                           ! Debug: expression subtree swapping
08759 2526           2386       FDE6            and	ax,-$21A[bp]
08760                                           ! Debug: ne int = const 0 to unsigned int = ax+0 (used reg = )
08761 252A           85C0                       test	ax,ax
08762 252C           74           02            je  	.211
08763                       0000252E            .212:
08764                                           ! 1827             break;
08765 252E           EB           11            jmp .20D
08766                                           !BCC_EOS
08767                                           ! 1828           }
08768                       00002530            .211:
08769                                           ! 1829           for(i=0;i<20;i++) {
08770                       00002530            .20E:
08771                                           ! Debug: postdec unsigned char version = [S+$24A-$221] (used reg = )
08772 2530           8A86       FDE1            mov	al,-$21F[bp]
08773 2534           48                         dec	ax
08774 2535           8886       FDE1            mov	-$21F[bp],al
08775                       00002539            .20F:
08776                                           ! Debug: gt int = const 0 to unsigned char version = [S+$24A-$221] (used reg = )
08777 2539           8A86       FDE1            mov	al,-$21F[bp]
08778 253D           84C0                       test	al,al
08779 253F           75           D6            jne	.210
08780                       00002541            .213:
08781                       00002541            .20D:
08782                                           ! Debug: eq int = const 0 to unsigned char i = [S+$24A-$21E] (used reg = )
08783 2541           30C0                       xor	al,al
08784 2543           8886       FDE4            mov	-$21C[bp],al
08785                                           !BCC_EOS
08786                                           !BCC_EOS
08787 2547           EB           69            jmp .216
08788                       00002549            .217:
08789                                           ! 1830             _write_byte_SS(read_byte_SS(buffer+(i*2)+54+1), model+(i*2));
08790                                           ! Debug: mul int = const 2 to unsigned char i = [S+$24A-$21E] (used reg = )
08791 2549           8A86       FDE4            mov	al,-$21C[bp]
08792 254D           30E4                       xor	ah,ah
08793 254F           D1E0                       shl	ax,*1
08794                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$24A-$24A (used reg = )
08795 2551           89EB                       mov	bx,bp
08796 2553           01C3                       add	bx,ax
08797                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
08798                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
08799 2555           81C3                 FDB8  add	bx,#-$248
08800 2559           53                         push	bx
08801                                           ! Debug: mul int = const 2 to unsigned char i = [S+$24C-$21E] (used reg = )
08802 255A           8A86       FDE4            mov	al,-$21C[bp]
08803 255E           30E4                       xor	ah,ah
08804 2560           D1E0                       shl	ax,*1
08805                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$24C-$206 (used reg = )
08806 2562           89EB                       mov	bx,bp
08807 2564           01C3                       add	bx,ax
08808                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$204 (used reg = )
08809                                           ! Debug: ptradd int = const 1 to [$200] unsigned char = bx-$1CE (used reg = )
08810                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1CD (used reg = )
08811                                           ! Debug: list * unsigned char = bx-$1CD (used reg = )
08812 2566           81C3                 FE33  add	bx,#-$1CD
08813 256A           53                         push	bx
08814                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08815 256B           E8         E0B8            call	_read_byte_SS
08816 256E           44                         inc	sp
08817 256F           44                         inc	sp
08818                                           ! Debug: list unsigned char = al+0 (used reg = )
08819 2570           30E4                       xor	ah,ah
08820 2572           50                         push	ax
08821                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08822 2573           E8         E0C6            call	__write_byte_SS
08823 2576           83C4                   04  add	sp,*4
08824                                           !BCC_EOS
08825                                           ! 1831             _write_byte_SS(read_byte_SS(buffer+(i*2)+54), model+(i*2)+1);
08826                                           ! Debug: mul int = const 2 to unsigned char i = [S+$24A-$21E] (used reg = )
08827 2579           8A86       FDE4            mov	al,-$21C[bp]
08828 257D           30E4                       xor	ah,ah
08829 257F           D1E0                       shl	ax,*1
08830                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$24A-$24A (used reg = )
08831 2581           89EB                       mov	bx,bp
08832 2583           01C3                       add	bx,ax
08833                                           ! Debug: ptradd int = const 1 to [$29] unsigned char = bx-$248 (used reg = )
08834                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$247 (used reg = )
08835                                           ! Debug: list * unsigned char = bx-$247 (used reg = )
08836 2585           81C3                 FDB9  add	bx,#-$247
08837 2589           53                         push	bx
08838                                           ! Debug: mul int = const 2 to unsigned char i = [S+$24C-$21E] (used reg = )
08839 258A           8A86       FDE4            mov	al,-$21C[bp]
08840 258E           30E4                       xor	ah,ah
08841 2590           D1E0                       shl	ax,*1
08842                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$24C-$206 (used reg = )
08843 2592           89EB                       mov	bx,bp
08844 2594           01C3                       add	bx,ax
08845                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$204 (used reg = )
08846                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1CE (used reg = )
08847                                           ! Debug: list * unsigned char = bx-$1CE (used reg = )
08848 2596           81C3                 FE32  add	bx,#-$1CE
08849 259A           53                         push	bx
08850                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08851 259B           E8         E088            call	_read_byte_SS
08852 259E           44                         inc	sp
08853 259F           44                         inc	sp
08854                                           ! Debug: list unsigned char = al+0 (used reg = )
08855 25A0           30E4                       xor	ah,ah
08856 25A2           50                         push	ax
08857                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08858 25A3           E8         E096            call	__write_byte_SS
08859 25A6           83C4                   04  add	sp,*4
08860                                           !BCC_EOS
08861                                           ! 1832           }
08862                                           ! 1833           _write_byte_SS(0x00, model+40);
08863                       000025A9            .215:
08864                                           ! Debug: postinc unsigned char i = [S+$24A-$21E] (used reg = )
08865 25A9           8A86       FDE4            mov	al,-$21C[bp]
08866 25AD           40                         inc	ax
08867 25AE           8886       FDE4            mov	-$21C[bp],al
08868                       000025B2            .216:
08869                                           ! Debug: lt int = const $14 to unsigned char i = [S+$24A-$21E] (used reg = )
08870 25B2           8A86       FDE4            mov	al,-$21C[bp]
08871 25B6           3C                     14  cmp	al,*$14
08872 25B8           72           8F            jb 	.217
08873                       000025BA            .218:
08874                       000025BA            .214:
08875                                           ! Debug: list * unsigned char model = S+$24A-$222 (used reg = )
08876 25BA           8D9E       FDE0            lea	bx,-$220[bp]
08877 25BE           53                         push	bx
08878                                           ! Debug: list int = const 0 (used reg = )
08879 25BF           31C0                       xor	ax,ax
08880 25C1           50                         push	ax
08881                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08882 25C2           E8         E077            call	__write_byte_SS
08883 25C5           83C4                   04  add	sp,*4
08884                                           !BCC_EOS
08885                                           ! 1834           for(i=39;i>0;i--){
08886                                           ! Debug: eq int = const $27 to unsigned char i = [S+$24A-$21E] (used reg = )
08887 25C8           B0                     27  mov	al,*$27
08888 25CA           8886       FDE4            mov	-$21C[bp],al
08889                                           !BCC_EOS
08890                                           !BCC_EOS
08891 25CE           EB           3D            jmp .21B
08892                       000025D0            .21C:
08893                                           ! 1835             if(read_byte_SS(model+i)==0x20)
08894                                           ! Debug: ptradd unsigned char i = [S+$24A-$21E] to [$29] unsigned char model = S+$24A-$24A (used reg = )
08895 25D0           8A86       FDE4            mov	al,-$21C[bp]
08896 25D4           30E4                       xor	ah,ah
08897 25D6           89EB                       mov	bx,bp
08898 25D8           01C3                       add	bx,ax
08899                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
08900                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
08901 25DA           81C3                 FDB8  add	bx,#-$248
08902 25DE           53                         push	bx
08903                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08904 25DF           E8         E044            call	_read_byte_SS
08905 25E2           44                         inc	sp
08906 25E3           44                         inc	sp
08907                                           ! Debug: logeq int = const $20 to unsigned char = al+0 (used reg = )
08908 25E4           3C                     20  cmp	al,*$20
08909 25E6           75           1A            jne 	.21D
08910                       000025E8            .21E:
08911                                           ! 1836               _write_byte_SS(0x00, model+i);
08912                                           ! Debug: ptradd unsigned char i = [S+$24A-$21E] to [$29] unsigned char model = S+$24A-$24A (used reg = )
08913 25E8           8A86       FDE4            mov	al,-$21C[bp]
08914 25EC           30E4                       xor	ah,ah
08915 25EE           89EB                       mov	bx,bp
08916 25F0           01C3                       add	bx,ax
08917                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
08918                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
08919 25F2           81C3                 FDB8  add	bx,#-$248
08920 25F6           53                         push	bx
08921                                           ! Debug: list int = const 0 (used reg = )
08922 25F7           31C0                       xor	ax,ax
08923 25F9           50                         push	ax
08924                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08925 25FA           E8         E03F            call	__write_byte_SS
08926 25FD           83C4                   04  add	sp,*4
08927                                           !BCC_EOS
08928                                           ! 1837             else break;
08929 2600           EB           02            jmp .21F
08930                       00002602            .21D:
08931 2602           EB           11            jmp .219
08932                                           !BCC_EOS
08933                                           ! 1838           }
08934                       00002604            .21F:
08935                                           ! 1839           if (i>36) {
08936                       00002604            .21A:
08937                                           ! Debug: postdec unsigned char i = [S+$24A-$21E] (used reg = )
08938 2604           8A86       FDE4            mov	al,-$21C[bp]
08939 2608           48                         dec	ax
08940 2609           8886       FDE4            mov	-$21C[bp],al
08941                       0000260D            .21B:
08942                                           ! Debug: gt int = const 0 to unsigned char i = [S+$24A-$21E] (used reg = )
08943 260D           8A86       FDE4            mov	al,-$21C[bp]
08944 2611           84C0                       test	al,al
08945 2613           75           BB            jne	.21C
08946                       00002615            .220:
08947                       00002615            .219:
08948                                           ! Debug: gt int = const $24 to unsigned char i = [S+$24A-$21E] (used reg = )
08949 2615           8A86       FDE4            mov	al,-$21C[bp]
08950 2619           3C                     24  cmp	al,*$24
08951 261B           76           40            jbe 	.221
08952                       0000261D            .222:
08953                                           ! 1840             _write_byte_SS(0x00, model+36);
08954                                           ! Debug: list * unsigned char model = S+$24A-$226 (used reg = )
08955 261D           8D9E       FDDC            lea	bx,-$224[bp]
08956 2621           53                         push	bx
08957                                           ! Debug: list int = const 0 (used reg = )
08958 2622           31C0                       xor	ax,ax
08959 2624           50                         push	ax
08960                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08961 2625           E8         E014            call	__write_byte_SS
08962 2628           83C4                   04  add	sp,*4
08963                                           !BCC_EOS
08964                                           ! 1841             for(i=35;i>32;i--){
08965                                           ! Debug: eq int = const $23 to unsigned char i = [S+$24A-$21E] (used reg = )
08966 262B           B0                     23  mov	al,*$23
08967 262D           8886       FDE4            mov	-$21C[bp],al
08968                                           !BCC_EOS
08969                                           !BCC_EOS
08970 2631           EB           22            jmp .225
08971                       00002633            .226:
08972                                           ! 1842               _write_byte_SS(0x2E, model+i);
08973                                           ! Debug: ptradd unsigned char i = [S+$24A-$21E] to [$29] unsigned char model = S+$24A-$24A (used reg = )
08974 2633           8A86       FDE4            mov	al,-$21C[bp]
08975 2637           30E4                       xor	ah,ah
08976 2639           89EB                       mov	bx,bp
08977 263B           01C3                       add	bx,ax
08978                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
08979                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
08980 263D           81C3                 FDB8  add	bx,#-$248
08981 2641           53                         push	bx
08982                                           ! Debug: list int = const $2E (used reg = )
08983 2642           B8                   002E  mov	ax,*$2E
08984 2645           50                         push	ax
08985                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08986 2646           E8         DFF3            call	__write_byte_SS
08987 2649           83C4                   04  add	sp,*4
08988                                           !BCC_EOS
08989                                           ! 1843             }
08990                                           ! 1844           }
08991                       0000264C            .224:
08992                                           ! Debug: postdec unsigned char i = [S+$24A-$21E] (used reg = )
08993 264C           8A86       FDE4            mov	al,-$21C[bp]
08994 2650           48                         dec	ax
08995 2651           8886       FDE4            mov	-$21C[bp],al
08996                       00002655            .225:
08997                                           ! Debug: gt int = const $20 to unsigned char i = [S+$24A-$21E] (used reg = )
08998 2655           8A86       FDE4            mov	al,-$21C[bp]
08999 2659           3C                     20  cmp	al,*$20
09000 265B           77           D6            ja 	.226
09001                       0000265D            .227:
09002                       0000265D            .223:
09003                                           ! 1845           break;
09004                       0000265D            .221:
09005 265D           EB           0E            jmp .202
09006                                           !BCC_EOS
09007                                           ! 1846       }
09008                                           ! 1847       switch (type) {
09009 265F           EB           0C            jmp .202
09010                       00002661            .204:
09011 2661           2C                     02  sub	al,*2
09012 2663         0F84         FDE7            beq 	.205
09013 2667           2C                     01  sub	al,*1
09014 2669         0F84         FE7D            beq 	.20C
09015                       0000266D            .202:
09016                       FFFFFDB6            ..FFFC	=	-$24A
09017 266D           8A46         FC            mov	al,-4[bp]
09018 2670           E9         018E            br 	.22A
09019                                           ! 1848         case 0x02:
09020                                           ! 1849           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
09021                       00002673            .22B:
09022 2673           8A86       FDF2            mov	al,-$20E[bp]
09023 2677           84C0                       test	al,al
09024 2679           74           05            je  	.22F
09025                       0000267B            .230:
09026 267B           BB                   D738  mov	bx,#.22D
09027 267E           EB           03            jmp .231
09028                       00002680            .22F:
09029 2680           BB                   D731  mov	bx,#.22E
09030                       00002683            .231:
09031                                           ! Debug: list * char = bx+0 (used reg = )
09032 2683           53                         push	bx
09033                                           ! Debug: list unsigned char channel = [S+$24C-$20F] (used reg = )
09034 2684           8A86       FDF3            mov	al,-$20D[bp]
09035 2688           30E4                       xor	ah,ah
09036 268A           50                         push	ax
09037                                           ! Debug: list * char = .22C+0 (used reg = )
09038 268B           BB                   D73F  mov	bx,#.22C
09039 268E           53                         push	bx
09040                                           ! Debug: list int = const 2 (used reg = )
09041 268F           B8                   0002  mov	ax,*2
09042 2692           50                         push	ax
09043                                           ! Debug: func () void = bios_printf+0 (used reg = )
09044 2693           E8         E2A8            call	_bios_printf
09045 2696           83C4                   08  add	sp,*8
09046                                           !BCC_EOS
09047                                           ! 1850           i=0;
09048                                           ! Debug: eq int = const 0 to unsigned char i = [S+$24A-$21E] (used reg = )
09049 2699           30C0                       xor	al,al
09050 269B           8886       FDE4            mov	-$21C[bp],al
09051                                           !BCC_EOS
09052                                           ! 1851           while(c=read_byte_SS(model+i++))
09053                                           ! 1852             bios_printf(2, "%c",c);
09054 269F           EB           15            jmp .233
09055                       000026A1            .234:
09056                                           ! Debug: list unsigned char c = [S+$24A-$21D] (used reg = )
09057 26A1           8A86       FDE5            mov	al,-$21B[bp]
09058 26A5           30E4                       xor	ah,ah
09059 26A7           50                         push	ax
09060                                           ! Debug: list * char = .235+0 (used reg = )
09061 26A8           BB                   D72E  mov	bx,#.235
09062 26AB           53                         push	bx
09063                                           ! Debug: list int = const 2 (used reg = )
09064 26AC           B8                   0002  mov	ax,*2
09065 26AF           50                         push	ax
09066                                           ! Debug: func () void = bios_printf+0 (used reg = )
09067 26B0           E8         E28B            call	_bios_printf
09068 26B3           83C4                   06  add	sp,*6
09069                                           !BCC_EOS
09070                                           ! 1853           if (sizeinmb < (1UL<<16))
09071                       000026B6            .233:
09072                                           ! Debug: postinc unsigned char i = [S+$24A-$21E] (used reg = )
09073 26B6           8A86       FDE4            mov	al,-$21C[bp]
09074 26BA           40                         inc	ax
09075 26BB           8886       FDE4            mov	-$21C[bp],al
09076                                           ! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$24A-$24A (used reg = )
09077 26BF           48                         dec	ax
09078 26C0           30E4                       xor	ah,ah
09079 26C2           89EB                       mov	bx,bp
09080 26C4           01C3                       add	bx,ax
09081                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
09082                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
09083 26C6           81C3                 FDB8  add	bx,#-$248
09084 26CA           53                         push	bx
09085                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
09086 26CB           E8         DF58            call	_read_byte_SS
09087 26CE           44                         inc	sp
09088 26CF           44                         inc	sp
09089                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$24A-$21D] (used reg = )
09090 26D0           8886       FDE5            mov	-$21B[bp],al
09091 26D4           84C0                       test	al,al
09092 26D6           75           C9            jne	.234
09093                       000026D8            .236:
09094                       000026D8            .232:
09095                                           ! Debug: lt unsigned long = const $10000 to unsigned long sizeinmb = [S+$24A-$21A] (used reg = )
09096 26D8           31C0                       xor	ax,ax
09097 26DA           BB                   0001  mov	bx,*1
09098 26DD           8DBE       FDE8            lea	di,-$218[bp]
09099 26E1           E8         D9B8            call	lcmpul
09100 26E4           76           1B            jbe 	.237
09101                       000026E6            .238:
09102                                           ! 1854             bios_printf(2, " ATA-%d Hard-Disk (%4u MBytes)\n", version, (Bit16u)sizeinmb);
09103                                           ! Debug: list unsigned short sizeinmb = [S+$24A-$21A] (used reg = )
09104 26E6           FFB6       FDE8            push	-$218[bp]
09105                                           ! Debug: list unsigned char version = [S+$24C-$221] (used reg = )
09106 26EA           8A86       FDE1            mov	al,-$21F[bp]
09107 26EE           30E4                       xor	ah,ah
09108 26F0           50                         push	ax
09109                                           ! Debug: list * char = .239+0 (used reg = )
09110 26F1           BB                   D70E  mov	bx,#.239
09111 26F4           53                         push	bx
09112                                           ! Debug: list int = const 2 (used reg = )
09113 26F5           B8                   0002  mov	ax,*2
09114 26F8           50                         push	ax
09115                                           ! Debug: func () void = bios_printf+0 (used reg = )
09116 26F9           E8         E242            call	_bios_printf
09117 26FC           83C4                   08  add	sp,*8
09118                                           !BCC_EOS
09119                                           ! 1855           else
09120                                           ! 1856             bios_printf(2, " ATA-%d Hard-Disk (%4u GBytes)\n", version, (Bit16u)(sizeinmb>>10));
09121 26FF           EB           2C            jmp .23A
09122                       00002701            .237:
09123                                           ! Debug: sr int = const $A to unsigned long sizeinmb = [S+$24A-$21A] (used reg = )
09124 2701           8B86       FDE8            mov	ax,-$218[bp]
09125 2705           8B9E       FDEA            mov	bx,-$216[bp]
09126 2709           88E0                       mov	al,ah
09127 270B           88DC                       mov	ah,bl
09128 270D           88FB                       mov	bl,bh
09129 270F           28FF                       sub	bh,bh
09130 2711           BF                   0002  mov	di,*2
09131 2714           E8         D9E3            call	lsrul
09132                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
09133                                           ! Debug: list unsigned short = ax+0 (used reg = )
09134 2717           50                         push	ax
09135                                           ! Debug: list unsigned char version = [S+$24C-$221] (used reg = )
09136 2718           8A86       FDE1            mov	al,-$21F[bp]
09137 271C           30E4                       xor	ah,ah
09138 271E           50                         push	ax
09139                                           ! Debug: list * char = .23B+0 (used reg = )
09140 271F           BB                   D6EE  mov	bx,#.23B
09141 2722           53                         push	bx
09142                                           ! Debug: list int = const 2 (used reg = )
09143 2723           B8                   0002  mov	ax,*2
09144 2726           50                         push	ax
09145                                           ! Debug: func () void = bios_printf+0 (used reg = )
09146 2727           E8         E214            call	_bios_printf
09147 272A           83C4                   08  add	sp,*8
09148                                           !BCC_EOS
09149                                           ! 1857           break;
09150                       0000272D            .23A:
09151 272D           E9         00E1            br 	.228
09152                                           !BCC_EOS
09153                                           ! 1858         case 0x03:
09154                                           ! 1859           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
09155                       00002730            .23C:
09156 2730           8A86       FDF2            mov	al,-$20E[bp]
09157 2734           84C0                       test	al,al
09158 2736           74           05            je  	.240
09159                       00002738            .241:
09160 2738           BB                   D6DC  mov	bx,#.23E
09161 273B           EB           03            jmp .242
09162                       0000273D            .240:
09163 273D           BB                   D6D5  mov	bx,#.23F
09164                       00002740            .242:
09165                                           ! Debug: list * char = bx+0 (used reg = )
09166 2740           53                         push	bx
09167                                           ! Debug: list unsigned char channel = [S+$24C-$20F] (used reg = )
09168 2741           8A86       FDF3            mov	al,-$20D[bp]
09169 2745           30E4                       xor	ah,ah
09170 2747           50                         push	ax
09171                                           ! Debug: list * char = .23D+0 (used reg = )
09172 2748           BB                   D6E3  mov	bx,#.23D
09173 274B           53                         push	bx
09174                                           ! Debug: list int = const 2 (used reg = )
09175 274C           B8                   0002  mov	ax,*2
09176 274F           50                         push	ax
09177                                           ! Debug: func () void = bios_printf+0 (used reg = )
09178 2750           E8         E1EB            call	_bios_printf
09179 2753           83C4                   08  add	sp,*8
09180                                           !BCC_EOS
09181                                           ! 1860           i=0; while(c=read_byte_SS(model+i++)) bios_printf(2, "%c",c);
09182                                           ! Debug: eq int = const 0 to unsigned char i = [S+$24A-$21E] (used reg = )
09183 2756           30C0                       xor	al,al
09184 2758           8886       FDE4            mov	-$21C[bp],al
09185                                           !BCC_EOS
09186 275C           EB           15            jmp .244
09187                       0000275E            .245:
09188                                           ! Debug: list unsigned char c = [S+$24A-$21D] (used reg = )
09189 275E           8A86       FDE5            mov	al,-$21B[bp]
09190 2762           30E4                       xor	ah,ah
09191 2764           50                         push	ax
09192                                           ! Debug: list * char = .246+0 (used reg = )
09193 2765           BB                   D6D2  mov	bx,#.246
09194 2768           53                         push	bx
09195                                           ! Debug: list int = const 2 (used reg = )
09196 2769           B8                   0002  mov	ax,*2
09197 276C           50                         push	ax
09198                                           ! Debug: func () void = bios_printf+0 (used reg = )
09199 276D           E8         E1CE            call	_bios_printf
09200 2770           83C4                   06  add	sp,*6
09201                                           !BCC_EOS
09202                                           ! 1861           if(*((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device))==0x05)
09203                       00002773            .244:
09204                                           ! Debug: postinc unsigned char i = [S+$24A-$21E] (used reg = )
09205 2773           8A86       FDE4            mov	al,-$21C[bp]
09206 2777           40                         inc	ax
09207 2778           8886       FDE4            mov	-$21C[bp],al
09208                                           ! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$24A-$24A (used reg = )
09209 277C           48                         dec	ax
09210 277D           30E4                       xor	ah,ah
09211 277F           89EB                       mov	bx,bp
09212 2781           01C3                       add	bx,ax
09213                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
09214                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
09215 2783           81C3                 FDB8  add	bx,#-$248
09216 2787           53                         push	bx
09217                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
09218 2788           E8         DE9B            call	_read_byte_SS
09219 278B           44                         inc	sp
09220 278C           44                         inc	sp
09221                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$24A-$21D] (used reg = )
09222 278D           8886       FDE5            mov	-$21B[bp],al
09223 2791           84C0                       test	al,al
09224 2793           75           C9            jne	.245
09225                       00002795            .247:
09226                       00002795            .243:
09227                                           ! Debug: ptradd unsigned char device = [S+$24A-5] to [8] struct  = const $142 (used reg = )
09228 2795           8A46         FD            mov	al,-3[bp]
09229 2798           30E4                       xor	ah,ah
09230 279A           B9                   001E  mov	cx,*$1E
09231 279D           F7E9                       imul	cx
09232 279F           89C3                       mov	bx,ax
09233                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
09234                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
09235                                           ! Debug: logeq int = const 5 to unsigned char = [bx+$143] (used reg = )
09236 27A1           8A87       0143            mov	al,$143[bx]
09237 27A5           3C                     05  cmp	al,*5
09238 27A7           75           17            jne 	.248
09239                       000027A9            .249:
09240                                           ! 1862             bios_printf(2, " ATAPI-%d CD-Rom/DVD-Rom\n",version);
09241                                           ! Debug: list unsigned char version = [S+$24A-$221] (used reg = )
09242 27A9           8A86       FDE1            mov	al,-$21F[bp]
09243 27AD           30E4                       xor	ah,ah
09244 27AF           50                         push	ax
09245                                           ! Debug: list * char = .24A+0 (used reg = )
09246 27B0           BB                   D6B8  mov	bx,#.24A
09247 27B3           53                         push	bx
09248                                           ! Debug: list int = const 2 (used reg = )
09249 27B4           B8                   0002  mov	ax,*2
09250 27B7           50                         push	ax
09251                                           ! Debug: func () void = bios_printf+0 (used reg = )
09252 27B8           E8         E183            call	_bios_printf
09253 27BB           83C4                   06  add	sp,*6
09254                                           !BCC_EOS
09255                                           ! 1863           else
09256                                           ! 1864             bios_printf(2, " ATAPI-%d Device\n",version);
09257 27BE           EB           15            jmp .24B
09258                       000027C0            .248:
09259                                           ! Debug: list unsigned char version = [S+$24A-$221] (used reg = )
09260 27C0           8A86       FDE1            mov	al,-$21F[bp]
09261 27C4           30E4                       xor	ah,ah
09262 27C6           50                         push	ax
09263                                           ! Debug: list * char = .24C+0 (used reg = )
09264 27C7           BB                   D6A6  mov	bx,#.24C
09265 27CA           53                         push	bx
09266                                           ! Debug: list int = const 2 (used reg = )
09267 27CB           B8                   0002  mov	ax,*2
09268 27CE           50                         push	ax
09269                                           ! Debug: func () void = bios_printf+0 (used reg = )
09270 27CF           E8         E16C            call	_bios_printf
09271 27D2           83C4                   06  add	sp,*6
09272                                           !BCC_EOS
09273                                           ! 1865           break;
09274                       000027D5            .24B:
09275 27D5           EB           3A            jmp .228
09276                                           !BCC_EOS
09277                                           ! 1866         case 0x01:
09278                                           ! 1867           bios_printf(2, "ata%d %s: Unknown device\n",channel,slave?" slave
09279                       000027D7            .24D:
09280                                           ! 1867 ":"master");
09281 27D7           8A86       FDF2            mov	al,-$20E[bp]
09282 27DB           84C0                       test	al,al
09283 27DD           74           05            je  	.251
09284                       000027DF            .252:
09285 27DF           BB                   D685  mov	bx,#.24F
09286 27E2           EB           03            jmp .253
09287                       000027E4            .251:
09288 27E4           BB                   D67E  mov	bx,#.250
09289                       000027E7            .253:
09290                                           ! Debug: list * char = bx+0 (used reg = )
09291 27E7           53                         push	bx
09292                                           ! Debug: list unsigned char channel = [S+$24C-$20F] (used reg = )
09293 27E8           8A86       FDF3            mov	al,-$20D[bp]
09294 27EC           30E4                       xor	ah,ah
09295 27EE           50                         push	ax
09296                                           ! Debug: list * char = .24E+0 (used reg = )
09297 27EF           BB                   D68C  mov	bx,#.24E
09298 27F2           53                         push	bx
09299                                           ! Debug: list int = const 2 (used reg = )
09300 27F3           B8                   0002  mov	ax,*2
09301 27F6           50                         push	ax
09302                                           ! Debug: func () void = bios_printf+0 (used reg = )
09303 27F7           E8         E144            call	_bios_printf
09304 27FA           83C4                   08  add	sp,*8
09305                                           !BCC_EOS
09306                                           ! 1868           break;
09307 27FD           EB           12            jmp .228
09308                                           !BCC_EOS
09309                                           ! 1869       }
09310                                           ! 1870     }
09311 27FF           EB           10            jmp .228
09312                       00002801            .22A:
09313 2801           2C                     01  sub	al,*1
09314 2803           74           D2            je 	.24D
09315 2805           2C                     01  sub	al,*1
09316 2807         0F84         FE68            beq 	.22B
09317 280B           2C                     01  sub	al,*1
09318 280D         0F84         FF1F            beq 	.23C
09319                       00002811            .228:
09320                       FFFFFDB6            ..FFFB	=	-$24A
09321 2811           83C4                   34  add	sp,*$34
09322                                           ! 1871   }
09323 2814           83C4                   0E  add	sp,*$E
09324                                           ! 1872   *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdcount)) = (hdcount);
09325                       00002817            .1A0:
09326                                           ! Debug: postinc unsigned char device = [S+$208-5] (used reg = )
09327 2817           8A46         FD            mov	al,-3[bp]
09328 281A           40                         inc	ax
09329 281B           8846         FD            mov	-3[bp],al
09330                       0000281E            .1A1:
09331                                           ! Debug: lt int = const 8 to unsigned char device = [S+$208-5] (used reg = )
09332 281E           8A46         FD            mov	al,-3[bp]
09333 2821           3C                     08  cmp	al,*8
09334 2823         0F82         F3E8            blo 	.1A2
09335                       00002827            .254:
09336                       00002827            .19F:
09337                                           ! Debug: eq unsigned char hdcount = [S+$208-3] to unsigned char = [+$232] (used reg = )
09338 2827           8A46         FF            mov	al,-1[bp]
09339 282A           A2         0232            mov	[$232],al
09340                                           !BCC_EOS
09341                                           ! 1873   *((Bit8u *)(&((ebda_data_t *) 0)->ata.cdcount)) = (cdcount);
09342                                           ! Debug: eq unsigned char cdcount = [S+$208-4] to unsigned char = [+$23B] (used reg = )
09343 282D           8A46         FE            mov	al,-2[bp]
09344 2830           A2         023B            mov	[$23B],al
09345                                           !BCC_EOS
09346                                           ! 1874   _write_byte(hdcount, 0x75, 0x40);
09347                                           ! Debug: list int = const $40 (used reg = )
09348 2833           B8                   0040  mov	ax,*$40
09349 2836           50                         push	ax
09350                                           ! Debug: list int = const $75 (used reg = )
09351 2837           B8                   0075  mov	ax,*$75
09352 283A           50                         push	ax
09353                                           ! Debug: list unsigned char hdcount = [S+$20C-3] (used reg = )
09354 283B           8A46         FF            mov	al,-1[bp]
09355 283E           30E4                       xor	ah,ah
09356 2840           50                         push	ax
09357                                           ! Debug: func () void = _write_byte+0 (used reg = )
09358 2841           E8         DDBC            call	__write_byte
09359 2844           83C4                   06  add	sp,*6
09360                                           !BCC_EOS
09361                                           ! 1875   bios_printf(2, "\n");
09362                                           ! Debug: list * char = .255+0 (used reg = )
09363 2847           BB                   D67C  mov	bx,#.255
09364 284A           53                         push	bx
09365                                           ! Debug: list int = const 2 (used reg = )
09366 284B           B8                   0002  mov	ax,*2
09367 284E           50                         push	ax
09368                                           ! Debug: func () void = bios_printf+0 (used reg = )
09369 284F           E8         E0EC            call	_bios_printf
09370 2852           83C4                   04  add	sp,*4
09371                                           !BCC_EOS
09372                                           ! 1876   set_DS(old_ds);
09373                                           ! Debug: list unsigned short old_ds = [S+$208-$208] (used reg = )
09374 2855           FFB6       FDFA            push	-$206[bp]
09375                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
09376 2859           E8         DE06            call	_set_DS
09377 285C           44                         inc	sp
09378 285D           44                         inc	sp
09379                                           !BCC_EOS
09380                                           ! 1877 }
09381 285E           89EC                       mov	sp,bp
09382 2860           5D                         pop	bp
09383 2861           C3                         ret
09384                                           ! 1878 void ata_reset(device)
09385                                           ! Register BX used in function ata_detect
09386                                           ! 1879 Bit16u device;
09387                                           export	_ata_reset
09388                       00002862            _ata_reset:
09389                                           !BCC_EOS
09390                                           ! 1880 {
09391                                           ! 1881   Bit16u iobase1, iobase2;
09392                                           !BCC_EOS
09393                                           ! 1882   Bit8u channel, slave, sn, sc;
09394                                           !BCC_EOS
09395                                           ! 1883   Bit8u type;
09396                                           !BCC_EOS
09397                                           ! 1884   Bit16u max;
09398                                           !BCC_EOS
09399                                           ! 1885   channel = device / 2;
09400 2862           55                         push	bp
09401 2863           89E5                       mov	bp,sp
09402 2865           83C4                   F4  add	sp,*-$C
09403                                           ! Debug: div int = const 2 to unsigned short device = [S+$E+2] (used reg = )
09404 2868           8B46         04            mov	ax,4[bp]
09405 286B           D1E8                       shr	ax,*1
09406                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$E-7] (used reg = )
09407 286D           8846         FB            mov	-5[bp],al
09408                                           !BCC_EOS
09409                                           ! 1886   slave = device % 2;
09410                                           ! Debug: mod int = const 2 to unsigned short device = [S+$E+2] (used reg = )
09411 2870           8B46         04            mov	ax,4[bp]
09412 2873           24                     01  and	al,*1
09413                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$E-8] (used reg = )
09414 2875           8846         FA            mov	-6[bp],al
09415                                           !BCC_EOS
09416                                           ! 1887   iobase1 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1));
09417                                           ! Debug: ptradd unsigned char channel = [S+$E-7] to [4] struct  = const $122 (used reg = )
09418 2878           8A46         FB            mov	al,-5[bp]
09419 287B           30E4                       xor	ah,ah
09420 287D           B1                     03  mov	cl,*3
09421 287F           D3E0                       shl	ax,cl
09422 2881           89C3                       mov	bx,ax
09423                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
09424                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
09425                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$E-4] (used reg = )
09426 2883           8B9F       0124            mov	bx,$124[bx]
09427 2887           895E         FE            mov	-2[bp],bx
09428                                           !BCC_EOS
09429                                           ! 1888   iobase2 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2));
09430                                           ! Debug: ptradd unsigned char channel = [S+$E-7] to [4] struct  = const $122 (used reg = )
09431 288A           8A46         FB            mov	al,-5[bp]
09432 288D           30E4                       xor	ah,ah
09433 288F           B1                     03  mov	cl,*3
09434 2891           D3E0                       shl	ax,cl
09435 2893           89C3                       mov	bx,ax
09436                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
09437                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
09438                                           ! Debug: eq unsigned short = [bx+$126] to unsigned short iobase2 = [S+$E-6] (used reg = )
09439 2895           8B9F       0126            mov	bx,$126[bx]
09440 2899           895E         FC            mov	-4[bp],bx
09441                                           !BCC_EOS
09442                                           ! 1889   outb(iobase2+6, 0x08 | 0x02 | 0x04);
09443                                           ! Debug: list int = const $E (used reg = )
09444 289C           B8                   000E  mov	ax,*$E
09445 289F           50                         push	ax
09446                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-6] (used reg = )
09447 28A0           8B46         FC            mov	ax,-4[bp]
09448                                           ! Debug: list unsigned int = ax+6 (used reg = )
09449 28A3           05                   0006  add	ax,*6
09450 28A6           50                         push	ax
09451                                           ! Debug: func () void = outb+0 (used reg = )
09452 28A7           E8         DC64            call	_outb
09453 28AA           83C4                   04  add	sp,*4
09454                                           !BCC_EOS
09455                                           ! 1890   await_ide(1, iobase1, 20);
09456                                           ! Debug: list int = const $14 (used reg = )
09457 28AD           B8                   0014  mov	ax,*$14
09458 28B0           50                         push	ax
09459                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
09460 28B1           FF76         FE            push	-2[bp]
09461                                           ! Debug: list int = const 1 (used reg = )
09462 28B4           B8                   0001  mov	ax,*1
09463 28B7           50                         push	ax
09464                                           ! Debug: func () int = await_ide+0 (used reg = )
09465 28B8           E8         F178            call	_await_ide
09466 28BB           83C4                   06  add	sp,*6
09467                                           !BCC_EOS
09468                                           ! 1891   outb(iobase2+6, 0x08 | 0x02);
09469                                           ! Debug: list int = const $A (used reg = )
09470 28BE           B8                   000A  mov	ax,*$A
09471 28C1           50                         push	ax
09472                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-6] (used reg = )
09473 28C2           8B46         FC            mov	ax,-4[bp]
09474                                           ! Debug: list unsigned int = ax+6 (used reg = )
09475 28C5           05                   0006  add	ax,*6
09476 28C8           50                         push	ax
09477                                           ! Debug: func () void = outb+0 (used reg = )
09478 28C9           E8         DC42            call	_outb
09479 28CC           83C4                   04  add	sp,*4
09480                                           !BCC_EOS
09481                                           ! 1892   type=*((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type));
09482                                           ! Debug: ptradd unsigned short device = [S+$E+2] to [8] struct  = const $142 (used reg = )
09483 28CF           8B46         04            mov	ax,4[bp]
09484 28D2           B9                   001E  mov	cx,*$1E
09485 28D5           F7E9                       imul	cx
09486 28D7           89C3                       mov	bx,ax
09487                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
09488                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
09489                                           ! Debug: eq unsigned char = [bx+$142] to unsigned char type = [S+$E-$B] (used reg = )
09490 28D9           8A87       0142            mov	al,$142[bx]
09491 28DD           8846         F7            mov	-9[bp],al
09492                                           !BCC_EOS
09493                                           ! 1893   if (type != 0x00) {
09494                                           ! Debug: ne int = const 0 to unsigned char type = [S+$E-$B] (used reg = )
09495 28E0           8A46         F7            mov	al,-9[bp]
09496 28E3           84C0                       test	al,al
09497 28E5         0F84         0084            beq 	.256
09498                       000028E9            .257:
09499                                           ! 1894     outb(iobase1+6, slave?0xb0:0xa0);
09500 28E9           8A46         FA            mov	al,-6[bp]
09501 28EC           84C0                       test	al,al
09502 28EE           74           04            je  	.258
09503                       000028F0            .259:
09504 28F0           B0                     B0  mov	al,#$B0
09505 28F2           EB           02            jmp .25A
09506                       000028F4            .258:
09507 28F4           B0                     A0  mov	al,#$A0
09508                       000028F6            .25A:
09509                                           ! Debug: list char = al+0 (used reg = )
09510 28F6           30E4                       xor	ah,ah
09511 28F8           50                         push	ax
09512                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$10-4] (used reg = )
09513 28F9           8B46         FE            mov	ax,-2[bp]
09514                                           ! Debug: list unsigned int = ax+6 (used reg = )
09515 28FC           05                   0006  add	ax,*6
09516 28FF           50                         push	ax
09517                                           ! Debug: func () void = outb+0 (used reg = )
09518 2900           E8         DC0B            call	_outb
09519 2903           83C4                   04  add	sp,*4
09520                                           !BCC_EOS
09521                                           ! 1895     sc = inb(iobase1+2);
09522                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$E-4] (used reg = )
09523 2906           8B46         FE            mov	ax,-2[bp]
09524                                           ! Debug: list unsigned int = ax+2 (used reg = )
09525 2909           40                         inc	ax
09526 290A           40                         inc	ax
09527 290B           50                         push	ax
09528                                           ! Debug: func () unsigned char = inb+0 (used reg = )
09529 290C           E8         DBE9            call	_inb
09530 290F           44                         inc	sp
09531 2910           44                         inc	sp
09532                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$E-$A] (used reg = )
09533 2911           8846         F8            mov	-8[bp],al
09534                                           !BCC_EOS
09535                                           ! 1896     sn = inb(iobase1+3);
09536                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$E-4] (used reg = )
09537 2914           8B46         FE            mov	ax,-2[bp]
09538                                           ! Debug: list unsigned int = ax+3 (used reg = )
09539 2917           05                   0003  add	ax,*3
09540 291A           50                         push	ax
09541                                           ! Debug: func () unsigned char = inb+0 (used reg = )
09542 291B           E8         DBDA            call	_inb
09543 291E           44                         inc	sp
09544 291F           44                         inc	sp
09545                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$E-9] (used reg = )
09546 2920           8846         F9            mov	-7[bp],al
09547                                           !BCC_EOS
09548                                           ! 1897     if ( (sc==0x01) && (sn==0x01) ) {
09549                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$E-$A] (used reg = )
09550 2923           8A46         F8            mov	al,-8[bp]
09551 2926           3C                     01  cmp	al,*1
09552 2928           75           32            jne 	.25B
09553                       0000292A            .25D:
09554                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$E-9] (used reg = )
09555 292A           8A46         F9            mov	al,-7[bp]
09556 292D           3C                     01  cmp	al,*1
09557 292F           75           2B            jne 	.25B
09558                       00002931            .25C:
09559                                           ! 1898       if (type == 0x02)
09560                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$E-$B] (used reg = )
09561 2931           8A46         F7            mov	al,-9[bp]
09562 2934           3C                     02  cmp	al,*2
09563 2936           75           13            jne 	.25E
09564                       00002938            .25F:
09565                                           ! 1899         await_ide(5, iobase1, 32000u);
09566                                           ! Debug: list unsigned int = const $7D00 (used reg = )
09567 2938           B8                   7D00  mov	ax,#$7D00
09568 293B           50                         push	ax
09569                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
09570 293C           FF76         FE            push	-2[bp]
09571                                           ! Debug: list int = const 5 (used reg = )
09572 293F           B8                   0005  mov	ax,*5
09573 2942           50                         push	ax
09574                                           ! Debug: func () int = await_ide+0 (used reg = )
09575 2943           E8         F0ED            call	_await_ide
09576 2946           83C4                   06  add	sp,*6
09577                                           !BCC_EOS
09578                                           ! 1900       else
09579                                           ! 1901         await_ide(2, iobase1, 32000u);
09580 2949           EB           11            jmp .260
09581                       0000294B            .25E:
09582                                           ! Debug: list unsigned int = const $7D00 (used reg = )
09583 294B           B8                   7D00  mov	ax,#$7D00
09584 294E           50                         push	ax
09585                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
09586 294F           FF76         FE            push	-2[bp]
09587                                           ! Debug: list int = const 2 (used reg = )
09588 2952           B8                   0002  mov	ax,*2
09589 2955           50                         push	ax
09590                                           ! Debug: func () int = await_ide+0 (used reg = )
09591 2956           E8         F0DA            call	_await_ide
09592 2959           83C4                   06  add	sp,*6
09593                                           !BCC_EOS
09594                                           ! 1902     }
09595                       0000295C            .260:
09596                                           ! 1903     await_ide(2, iobase1, 32000u);
09597                       0000295C            .25B:
09598                                           ! Debug: list unsigned int = const $7D00 (used reg = )
09599 295C           B8                   7D00  mov	ax,#$7D00
09600 295F           50                         push	ax
09601                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
09602 2960           FF76         FE            push	-2[bp]
09603                                           ! Debug: list int = const 2 (used reg = )
09604 2963           B8                   0002  mov	ax,*2
09605 2966           50                         push	ax
09606                                           ! Debug: func () int = await_ide+0 (used reg = )
09607 2967           E8         F0C9            call	_await_ide
09608 296A           83C4                   06  add	sp,*6
09609                                           !BCC_EOS
09610                                           ! 1904   }
09611                                           ! 1905   outb(iobase2+6, 0x08);
09612                       0000296D            .256:
09613                                           ! Debug: list int = const 8 (used reg = )
09614 296D           B8                   0008  mov	ax,*8
09615 2970           50                         push	ax
09616                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-6] (used reg = )
09617 2971           8B46         FC            mov	ax,-4[bp]
09618                                           ! Debug: list unsigned int = ax+6 (used reg = )
09619 2974           05                   0006  add	ax,*6
09620 2977           50                         push	ax
09621                                           ! Debug: func () void = outb+0 (used reg = )
09622 2978           E8         DB93            call	_outb
09623 297B           83C4                   04  add	sp,*4
09624                                           !BCC_EOS
09625                                           ! 1906 }
09626 297E           89EC                       mov	sp,bp
09627 2980           5D                         pop	bp
09628 2981           C3                         ret
09629                                           ! 1907 Bit16u ata_cmd_non_data()
09630                                           ! Register BX used in function ata_reset
09631                                           ! 1908 {return 0;}
09632                                           export	_ata_cmd_non_data
09633                       00002982            _ata_cmd_non_data:
09634 2982           55                         push	bp
09635 2983           89E5                       mov	bp,sp
09636 2985           31C0                       xor	ax,ax
09637 2987           5D                         pop	bp
09638 2988           C3                         ret
09639                                           !BCC_EOS
09640                                           ! 1909 Bit16u ata_cmd_data_io(ioflag, device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
09641                                           ! 1910 Bit16u ioflag, device, command, count, cylinder, head, sector, segment, offset;
09642                                           export	_ata_cmd_data_io
09643                       00002989            _ata_cmd_data_io:
09644                                           !BCC_EOS
09645                                           ! 1911 Bit32u lba_low, lba_high;
09646                                           !BCC_EOS
09647                                           ! 1912 {
09648                                           ! 1913   Bit16u iobase1, iobase2, blksize;
09649                                           !BCC_EOS
09650                                           ! 1914   Bit8u channel, slave;
09651                                           !BCC_EOS
09652                                           ! 1915   Bit8u status, current, mode;
09653                                           !BCC_EOS
09654                                           ! 1916   channel = device / 2;
09655 2989           55                         push	bp
09656 298A           89E5                       mov	bp,sp
09657 298C           83C4                   F4  add	sp,*-$C
09658                                           ! Debug: div int = const 2 to unsigned short device = [S+$E+4] (used reg = )
09659 298F           8B46         06            mov	ax,6[bp]
09660 2992           D1E8                       shr	ax,*1
09661                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$E-9] (used reg = )
09662 2994           8846         F9            mov	-7[bp],al
09663                                           !BCC_EOS
09664                                           ! 1917   slave = device % 2;
09665                                           ! Debug: mod int = const 2 to unsigned short device = [S+$E+4] (used reg = )
09666 2997           8B46         06            mov	ax,6[bp]
09667 299A           24                     01  and	al,*1
09668                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$E-$A] (used reg = )
09669 299C           8846         F8            mov	-8[bp],al
09670                                           !BCC_EOS
09671                                           ! 1918   iobase1 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1));
09672                                           ! Debug: ptradd unsigned char channel = [S+$E-9] to [4] struct  = const $122 (used reg = )
09673 299F           8A46         F9            mov	al,-7[bp]
09674 29A2           30E4                       xor	ah,ah
09675 29A4           B1                     03  mov	cl,*3
09676 29A6           D3E0                       shl	ax,cl
09677 29A8           89C3                       mov	bx,ax
09678                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
09679                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
09680                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$E-4] (used reg = )
09681 29AA           8B9F       0124            mov	bx,$124[bx]
09682 29AE           895E         FE            mov	-2[bp],bx
09683                                           !BCC_EOS
09684                                           ! 1919   iobase2 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2));
09685                                           ! Debug: ptradd unsigned char channel = [S+$E-9] to [4] struct  = const $122 (used reg = )
09686 29B1           8A46         F9            mov	al,-7[bp]
09687 29B4           30E4                       xor	ah,ah
09688 29B6           B1                     03  mov	cl,*3
09689 29B8           D3E0                       shl	ax,cl
09690 29BA           89C3                       mov	bx,ax
09691                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
09692                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
09693                                           ! Debug: eq unsigned short = [bx+$126] to unsigned short iobase2 = [S+$E-6] (used reg = )
09694 29BC           8B9F       0126            mov	bx,$126[bx]
09695 29C0           895E         FC            mov	-4[bp],bx
09696                                           !BCC_EOS
09697                                           ! 1920   mode = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode));
09698                                           ! Debug: ptradd unsigned short device = [S+$E+4] to [8] struct  = const $142 (used reg = )
09699 29C3           8B46         06            mov	ax,6[bp]
09700 29C6           B9                   001E  mov	cx,*$1E
09701 29C9           F7E9                       imul	cx
09702 29CB           89C3                       mov	bx,ax
09703                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
09704                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
09705                                           ! Debug: eq unsigned char = [bx+$146] to unsigned char mode = [S+$E-$D] (used reg = )
09706 29CD           8A87       0146            mov	al,$146[bx]
09707 29D1           8846         F5            mov	-$B[bp],al
09708                                           !BCC_EOS
09709                                           ! 1921   if ((command == 0xEC) ||
09710                                           ! 1922       (command == 0xA1)) {
09711                                           ! Debug: logeq int = const $EC to unsigned short command = [S+$E+6] (used reg = )
09712 29D4           8B46         08            mov	ax,8[bp]
09713 29D7           3D                   00EC  cmp	ax,#$EC
09714 29DA           74           08            je  	.262
09715                       000029DC            .263:
09716                                           ! Debug: logeq int = const $A1 to unsigned short command = [S+$E+6] (used reg = )
09717 29DC           8B46         08            mov	ax,8[bp]
09718 29DF           3D                   00A1  cmp	ax,#$A1
09719 29E2           75           08            jne 	.261
09720                       000029E4            .262:
09721                                           ! 1923     blksize = 0x200;
09722                                           ! Debug: eq int = const $200 to unsigned short blksize = [S+$E-8] (used reg = )
09723 29E4           B8                   0200  mov	ax,#$200
09724 29E7           8946         FA            mov	-6[bp],ax
09725                                           !BCC_EOS
09726                                           ! 1924   } else {
09727 29EA           EB           11            jmp .264
09728                       000029EC            .261:
09729                                           ! 1925     blksize = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].blksize));
09730                                           ! Debug: ptradd unsigned short device = [S+$E+4] to [8] struct  = const $142 (used reg = )
09731 29EC           8B46         06            mov	ax,6[bp]
09732 29EF           B9                   001E  mov	cx,*$1E
09733 29F2           F7E9                       imul	cx
09734 29F4           89C3                       mov	bx,ax
09735                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
09736                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$148 (used reg = )
09737                                           ! Debug: eq unsigned short = [bx+$148] to unsigned short blksize = [S+$E-8] (used reg = )
09738 29F6           8B9F       0148            mov	bx,$148[bx]
09739 29FA           895E         FA            mov	-6[bp],bx
09740                                           !BCC_EOS
09741                                           ! 1926   }
09742                                           ! 1927   if (mode == 0x01) blksize>>=2;
09743                       000029FD            .264:
09744                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$E-$D] (used reg = )
09745 29FD           8A46         F5            mov	al,-$B[bp]
09746 2A00           3C                     01  cmp	al,*1
09747 2A02           75           0C            jne 	.265
09748                       00002A04            .266:
09749                                           ! Debug: srab int = const 2 to unsigned short blksize = [S+$E-8] (used reg = )
09750 2A04           8B46         FA            mov	ax,-6[bp]
09751 2A07           D1E8                       shr	ax,*1
09752 2A09           D1E8                       shr	ax,*1
09753 2A0B           8946         FA            mov	-6[bp],ax
09754                                           !BCC_EOS
09755                                           ! 1928   else blksize>>=1;
09756 2A0E           EB           08            jmp .267
09757                       00002A10            .265:
09758                                           ! Debug: srab int = const 1 to unsigned short blksize = [S+$E-8] (used reg = )
09759 2A10           8B46         FA            mov	ax,-6[bp]
09760 2A13           D1E8                       shr	ax,*1
09761 2A15           8946         FA            mov	-6[bp],ax
09762                                           !BCC_EOS
09763                                           ! 1929   *((Bit16u *)(&((ebda_data_t *) 0)->ata.trsfsectors)) = (0);
09764                       00002A18            .267:
09765                                           ! Debug: eq int = const 0 to unsigned short = [+$254] (used reg = )
09766 2A18           31C0                       xor	ax,ax
09767 2A1A           A3         0254            mov	[$254],ax
09768                                           !BCC_EOS
09769                                           ! 1930   *((Bit32u *)(&((ebda_data_t *) 0)->ata.trsf
09770                                           ! 1930 bytes)) = (0L);
09771                                           ! Debug: eq long = const 0 to unsigned long = [+$256] (used reg = )
09772 2A1D           31C0                       xor	ax,ax
09773 2A1F           31DB                       xor	bx,bx
09774 2A21           A3         0256            mov	[$256],ax
09775 2A24           891E       0258            mov	[$258],bx
09776                                           !BCC_EOS
09777                                           ! 1931   current = 0;
09778                                           ! Debug: eq int = const 0 to unsigned char current = [S+$E-$C] (used reg = )
09779 2A28           30C0                       xor	al,al
09780 2A2A           8846         F6            mov	-$A[bp],al
09781                                           !BCC_EOS
09782                                           ! 1932   status = inb(iobase1 + 7);
09783                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$E-4] (used reg = )
09784 2A2D           8B46         FE            mov	ax,-2[bp]
09785                                           ! Debug: list unsigned int = ax+7 (used reg = )
09786 2A30           05                   0007  add	ax,*7
09787 2A33           50                         push	ax
09788                                           ! Debug: func () unsigned char = inb+0 (used reg = )
09789 2A34           E8         DAC1            call	_inb
09790 2A37           44                         inc	sp
09791 2A38           44                         inc	sp
09792                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$E-$B] (used reg = )
09793 2A39           8846         F7            mov	-9[bp],al
09794                                           !BCC_EOS
09795                                           ! 1933   if (status & 0x80) return 1;
09796                                           ! Debug: and int = const $80 to unsigned char status = [S+$E-$B] (used reg = )
09797 2A3C           8A46         F7            mov	al,-9[bp]
09798 2A3F           24                     80  and	al,#$80
09799 2A41           84C0                       test	al,al
09800 2A43           74           07            je  	.268
09801                       00002A45            .269:
09802 2A45           B8                   0001  mov	ax,*1
09803 2A48           89EC                       mov	sp,bp
09804 2A4A           5D                         pop	bp
09805 2A4B           C3                         ret
09806                                           !BCC_EOS
09807                                           ! 1934   outb(iobase2 + 6, 0x08 | 0x02);
09808                       00002A4C            .268:
09809                                           ! Debug: list int = const $A (used reg = )
09810 2A4C           B8                   000A  mov	ax,*$A
09811 2A4F           50                         push	ax
09812                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-6] (used reg = )
09813 2A50           8B46         FC            mov	ax,-4[bp]
09814                                           ! Debug: list unsigned int = ax+6 (used reg = )
09815 2A53           05                   0006  add	ax,*6
09816 2A56           50                         push	ax
09817                                           ! Debug: func () void = outb+0 (used reg = )
09818 2A57           E8         DAB4            call	_outb
09819 2A5A           83C4                   04  add	sp,*4
09820                                           !BCC_EOS
09821                                           ! 1935   if (sector == 0) {
09822                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$E+$E] (used reg = )
09823 2A5D           8B46         10            mov	ax,$10[bp]
09824 2A60           85C0                       test	ax,ax
09825 2A62         0F85         00F5            bne 	.26A
09826                       00002A66            .26B:
09827                                           ! 1936     if (*(((Bit8u *)&count)+1) >= 1 || lba_high || (lba_low >= ((1UL << 28) - count))) {
09828                                           ! Debug: ge int = const 1 to unsigned char count = [S+$E+9] (used reg = )
09829 2A66           8A46         0B            mov	al,$B[bp]
09830 2A69           3C                     01  cmp	al,*1
09831 2A6B           72           04            jb 	.270
09832 2A6D           B0                     01  mov	al,*1
09833 2A6F           EB           02            jmp	.271
09834                       00002A71            .270:
09835 2A71           30C0                       xor	al,al
09836                       00002A73            .271:
09837                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
09838 2A73           30E4                       xor	ah,ah
09839 2A75           99                         cwd
09840 2A76           89D3                       mov	bx,dx
09841 2A78           E8         D66A            call	ltstl
09842 2A7B           75           2A            jne 	.26D
09843                       00002A7D            .26F:
09844 2A7D           8B46         16            mov	ax,$16[bp]
09845 2A80           8B5E         18            mov	bx,$18[bp]
09846 2A83           E8         D65F            call	ltstl
09847 2A86           75           1F            jne 	.26D
09848                       00002A88            .26E:
09849                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$E+8] (used reg = )
09850 2A88           8B46         0A            mov	ax,$A[bp]
09851 2A8B           31DB                       xor	bx,bx
09852                                           ! Debug: sub unsigned long = bx+0 to unsigned long = const $10000000 (used reg = )
09853 2A8D           53                         push	bx
09854 2A8E           50                         push	ax
09855 2A8F           31C0                       xor	ax,ax
09856 2A91           BB                   1000  mov	bx,#$1000
09857 2A94           8D7E         F0            lea	di,-$10[bp]
09858 2A97           E8         D618            call	lsubul
09859 2A9A           83C4                   04  add	sp,*4
09860                                           ! Debug: ge unsigned long = bx+0 to unsigned long lba_low = [S+$E+$10] (used reg = )
09861 2A9D           8D7E         12            lea	di,$12[bp]
09862 2AA0           E8         D5F9            call	lcmpul
09863 2AA3         0F87         0086            bhi 	.26C
09864                       00002AA7            .26D:
09865                                           ! 1937       outb(iobase1 + 1, 0x00);
09866                                           ! Debug: list int = const 0 (used reg = )
09867 2AA7           31C0                       xor	ax,ax
09868 2AA9           50                         push	ax
09869                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$10-4] (used reg = )
09870 2AAA           8B46         FE            mov	ax,-2[bp]
09871                                           ! Debug: list unsigned int = ax+1 (used reg = )
09872 2AAD           40                         inc	ax
09873 2AAE           50                         push	ax
09874                                           ! Debug: func () void = outb+0 (used reg = )
09875 2AAF           E8         DA5C            call	_outb
09876 2AB2           83C4                   04  add	sp,*4
09877                                           !BCC_EOS
09878                                           ! 1938       outb(iobase1 + 2, *(((Bit8u *)&count)+1));
09879                                           ! Debug: list unsigned char count = [S+$E+9] (used reg = )
09880 2AB5           8A46         0B            mov	al,$B[bp]
09881 2AB8           30E4                       xor	ah,ah
09882 2ABA           50                         push	ax
09883                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$10-4] (used reg = )
09884 2ABB           8B46         FE            mov	ax,-2[bp]
09885                                           ! Debug: list unsigned int = ax+2 (used reg = )
09886 2ABE           40                         inc	ax
09887 2ABF           40                         inc	ax
09888 2AC0           50                         push	ax
09889                                           ! Debug: func () void = outb+0 (used reg = )
09890 2AC1           E8         DA4A            call	_outb
09891 2AC4           83C4                   04  add	sp,*4
09892                                           !BCC_EOS
09893                                           ! 1939       outb(iobase1 + 3, *(((Bit8u *)&*(((Bit16u *)&lba_low)+1))+1));
09894                                           ! Debug: list unsigned char lba_low = [S+$E+$13] (used reg = )
09895 2AC7           8A46         15            mov	al,$15[bp]
09896 2ACA           30E4                       xor	ah,ah
09897 2ACC           50                         push	ax
09898                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$10-4] (used reg = )
09899 2ACD           8B46         FE            mov	ax,-2[bp]
09900                                           ! Debug: list unsigned int = ax+3 (used reg = )
09901 2AD0           05                   0003  add	ax,*3
09902 2AD3           50                         push	ax
09903                                           ! Debug: func () void = outb+0 (used reg = )
09904 2AD4           E8         DA37            call	_outb
09905 2AD7           83C4                   04  add	sp,*4
09906                                           !BCC_EOS
09907                                           ! 1940       outb(iobase1 + 4, *((Bit8u *)&lba_high));
09908                                           ! Debug: list unsigned char lba_high = [S+$E+$14] (used reg = )
09909 2ADA           8A46         16            mov	al,$16[bp]
09910 2ADD           30E4                       xor	ah,ah
09911 2ADF           50                         push	ax
09912                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$10-4] (used reg = )
09913 2AE0           8B46         FE            mov	ax,-2[bp]
09914                                           ! Debug: list unsigned int = ax+4 (used reg = )
09915 2AE3           05                   0004  add	ax,*4
09916 2AE6           50                         push	ax
09917                                           ! Debug: func () void = outb+0 (used reg = )
09918 2AE7           E8         DA24            call	_outb
09919 2AEA           83C4                   04  add	sp,*4
09920                                           !BCC_EOS
09921                                           ! 1941       outb(iobase1 + 5, *(((Bit8u *)&*((Bit16u *)&lba_high))+1));
09922                                           ! Debug: list unsigned char lba_high = [S+$E+$15] (used reg = )
09923 2AED           8A46         17            mov	al,$17[bp]
09924 2AF0           30E4                       xor	ah,ah
09925 2AF2           50                         push	ax
09926                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$10-4] (used reg = )
09927 2AF3           8B46         FE            mov	ax,-2[bp]
09928                                           ! Debug: list unsigned int = ax+5 (used reg = )
09929 2AF6           05                   0005  add	ax,*5
09930 2AF9           50                         push	ax
09931                                           ! Debug: func () void = outb+0 (used reg = )
09932 2AFA           E8         DA11            call	_outb
09933 2AFD           83C4                   04  add	sp,*4
09934                                           !BCC_EOS
09935                                           ! 1942       command |= 0x04;
09936                                           ! Debug: orab int = const 4 to unsigned short command = [S+$E+6] (used reg = )
09937 2B00           8B46         08            mov	ax,8[bp]
09938 2B03           0C                     04  or	al,*4
09939 2B05           8946         08            mov	8[bp],ax
09940                                           !BCC_EOS
09941                                           ! 1943       count &= (1 << 8) - 1;
09942                                           ! Debug: andab int = const $FF to unsigned short count = [S+$E+8] (used reg = )
09943 2B08           8A46         0A            mov	al,$A[bp]
09944 2B0B           30E4                       xor	ah,ah
09945 2B0D           8946         0A            mov	$A[bp],ax
09946                                           !BCC_EOS
09947                                           ! 1944       lba_low &= (1UL << 24) - 1;
09948                                           ! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$E+$10] (used reg = )
09949 2B10           B8                   FFFF  mov	ax,#$FFFF
09950 2B13           BB                   00FF  mov	bx,#$FF
09951 2B16           53                         push	bx
09952 2B17           50                         push	ax
09953 2B18           8B46         12            mov	ax,$12[bp]
09954 2B1B           8B5E         14            mov	bx,$14[bp]
09955 2B1E           8D7E         F0            lea	di,-$10[bp]
09956 2B21           E8         D568            call	landul
09957 2B24           8946         12            mov	$12[bp],ax
09958 2B27           895E         14            mov	$14[bp],bx
09959 2B2A           83C4                   04  add	sp,*4
09960                                           !BCC_EOS
09961                                           ! 1945     }
09962                                           ! 1946     sector = (Bit16u) *((Bit8u *)&lba_low);
09963                       00002B2D            .26C:
09964                                           ! Debug: cast unsigned short = const 0 to unsigned char lba_low = [S+$E+$10] (used reg = )
09965 2B2D           8A46         12            mov	al,$12[bp]
09966 2B30           30E4                       xor	ah,ah
09967                                           ! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$E+$E] (used reg = )
09968 2B32           8946         10            mov	$10[bp],ax
09969                                           !BCC_EOS
09970                                           ! 1947     lba_low >>= 8;
09971                                           ! Debug: srab int = const 8 to unsigned long lba_low = [S+$E+$10] (used reg = )
09972 2B35           8B46         12            mov	ax,$12[bp]
09973 2B38           8B5E         14            mov	bx,$14[bp]
09974 2B3B           88E0                       mov	al,ah
09975 2B3D           88DC                       mov	ah,bl
09976 2B3F           88FB                       mov	bl,bh
09977 2B41           28FF                       sub	bh,bh
09978 2B43           8946         12            mov	$12[bp],ax
09979 2B46           895E         14            mov	$14[bp],bx
09980                                           !BCC_EOS
09981                                           ! 1948     cylinder = *((Bit16u *)&lba_low);
09982                                           ! Debug: eq unsigned short lba_low = [S+$E+$10] to unsigned short cylinder = [S+$E+$A] (used reg = )
09983 2B49           8B46         12            mov	ax,$12[bp]
09984 2B4C           8946         0C            mov	$C[bp],ax
09985                                           !BCC_EOS
09986                                           ! 1949     head = (*(((Bit16u *)&lba_low)+1) & 0x000f) | 0x40;
09987                                           ! Debug: and int = const $F to unsigned short lba_low = [S+$E+$12] (used reg = )
09988 2B4F           8A46         14            mov	al,$14[bp]
09989 2B52           24                     0F  and	al,*$F
09990                                           ! Debug: or int = const $40 to unsigned char = al+0 (used reg = )
09991 2B54           0C                     40  or	al,*$40
09992                                           ! Debug: eq unsigned char = al+0 to unsigned short head = [S+$E+$C] (used reg = )
09993 2B56           30E4                       xor	ah,ah
09994 2B58           8946         0E            mov	$E[bp],ax
09995                                           !BCC_EOS
09996                                           ! 1950   }
09997                                           ! 1951   outb(iobase1 + 1, 0x00);
09998                       00002B5B            .26A:
09999                                           ! Debug: list int = const 0 (used reg = )
10000 2B5B           31C0                       xor	ax,ax
10001 2B5D           50                         push	ax
10002                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$10-4] (used reg = )
10003 2B5E           8B46         FE            mov	ax,-2[bp]
10004                                           ! Debug: list unsigned int = ax+1 (used reg = )
10005 2B61           40                         inc	ax
10006 2B62           50                         push	ax
10007                                           ! Debug: func () void = outb+0 (used reg = )
10008 2B63           E8         D9A8            call	_outb
10009 2B66           83C4                   04  add	sp,*4
10010                                           !BCC_EOS
10011                                           ! 1952   outb(iobase1 + 2, count);
10012                                           ! Debug: list unsigned short count = [S+$E+8] (used reg = )
10013 2B69           FF76         0A            push	$A[bp]
10014                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$10-4] (used reg = )
10015 2B6C           8B46         FE            mov	ax,-2[bp]
10016                                           ! Debug: list unsigned int = ax+2 (used reg = )
10017 2B6F           40                         inc	ax
10018 2B70           40                         inc	ax
10019 2B71           50                         push	ax
10020                                           ! Debug: func () void = outb+0 (used reg = )
10021 2B72           E8         D999            call	_outb
10022 2B75           83C4                   04  add	sp,*4
10023                                           !BCC_EOS
10024                                           ! 1953   outb(iobase1 + 3, sector);
10025                                           ! Debug: list unsigned short sector = [S+$E+$E] (used reg = )
10026 2B78           FF76         10            push	$10[bp]
10027                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$10-4] (used reg = )
10028 2B7B           8B46         FE            mov	ax,-2[bp]
10029                                           ! Debug: list unsigned int = ax+3 (used reg = )
10030 2B7E           05                   0003  add	ax,*3
10031 2B81           50                         push	ax
10032                                           ! Debug: func () void = outb+0 (used reg = )
10033 2B82           E8         D989            call	_outb
10034 2B85           83C4                   04  add	sp,*4
10035                                           !BCC_EOS
10036                                           ! 1954   outb(iobase1 + 4, *((Bit8u *)&cylinder));
10037                                           ! Debug: list unsigned char cylinder = [S+$E+$A] (used reg = )
10038 2B88           8A46         0C            mov	al,$C[bp]
10039 2B8B           30E4                       xor	ah,ah
10040 2B8D           50                         push	ax
10041                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$10-4] (used reg = )
10042 2B8E           8B46         FE            mov	ax,-2[bp]
10043                                           ! Debug: list unsigned int = ax+4 (used reg = )
10044 2B91           05                   0004  add	ax,*4
10045 2B94           50                         push	ax
10046                                           ! Debug: func () void = outb+0 (used reg = )
10047 2B95           E8         D976            call	_outb
10048 2B98           83C4                   04  add	sp,*4
10049                                           !BCC_EOS
10050                                           ! 1955   outb(iobase1 + 5, *(((Bit8u *)&cylinder)+1));
10051                                           ! Debug: list unsigned char cylinder = [S+$E+$B] (used reg = )
10052 2B9B           8A46         0D            mov	al,$D[bp]
10053 2B9E           30E4                       xor	ah,ah
10054 2BA0           50                         push	ax
10055                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$10-4] (used reg = )
10056 2BA1           8B46         FE            mov	ax,-2[bp]
10057                                           ! Debug: list unsigned int = ax+5 (used reg = )
10058 2BA4           05                   0005  add	ax,*5
10059 2BA7           50                         push	ax
10060                                           ! Debug: func () void = outb+0 (used reg = )
10061 2BA8           E8         D963            call	_outb
10062 2BAB           83C4                   04  add	sp,*4
10063                                           !BCC_EOS
10064                                           ! 1956   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
10065 2BAE           8A46         F8            mov	al,-8[bp]
10066 2BB1           84C0                       test	al,al
10067 2BB3           74           04            je  	.273
10068                       00002BB5            .274:
10069 2BB5           B0                     B0  mov	al,#$B0
10070 2BB7           EB           02            jmp .275
10071                       00002BB9            .273:
10072 2BB9           B0                     A0  mov	al,#$A0
10073                       00002BBB            .275:
10074                                           ! Debug: or unsigned char head = [S+$E+$C] to char = al+0 (used reg = )
10075 2BBB           0A46         0E            or	al,$E[bp]
10076                                           ! Debug: list unsigned char = al+0 (used reg = )
10077 2BBE           30E4                       xor	ah,ah
10078 2BC0           50                         push	ax
10079                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$10-4] (used reg = )
10080 2BC1           8B46         FE            mov	ax,-2[bp]
10081                                           ! Debug: list unsigned int = ax+6 (used reg = )
10082 2BC4           05                   0006  add	ax,*6
10083 2BC7           50                         push	ax
10084                                           ! Debug: func () void = outb+0 (used reg = )
10085 2BC8           E8         D943            call	_outb
10086 2BCB           83C4                   04  add	sp,*4
10087                                           !BCC_EOS
10088                                           ! 1957   outb(iobase1 + 7, command);
10089                                           ! Debug: list unsigned short command = [S+$E+6] (used reg = )
10090 2BCE           FF76         08            push	8[bp]
10091                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-4] (used reg = )
10092 2BD1           8B46         FE            mov	ax,-2[bp]
10093                                           ! Debug: list unsigned int = ax+7 (used reg = )
10094 2BD4           05                   0007  add	ax,*7
10095 2BD7           50                         push	ax
10096                                           ! Debug: func () void = outb+0 (used reg = )
10097 2BD8           E8         D933            call	_outb
10098 2BDB           83C4                   04  add	sp,*4
10099                                           !BCC_EOS
10100                                           ! 1958   await_ide(3, iobase1, 32000u);
10101                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10102 2BDE           B8                   7D00  mov	ax,#$7D00
10103 2BE1           50                         push	ax
10104                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
10105 2BE2           FF76         FE            push	-2[bp]
10106                                           ! Debug: list int = const 3 (used reg = )
10107 2BE5           B8                   0003  mov	ax,*3
10108 2BE8           50                         push	ax
10109                                           ! Debug: func () int = await_ide+0 (used reg = )
10110 2BE9           E8         EE47            call	_await_ide
10111 2BEC           83C4                   06  add	sp,*6
10112                                           !BCC_EOS
10113                                           ! 1959   status = inb(iobase1 + 7);
10114                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$E-4] (used reg = )
10115 2BEF           8B46         FE            mov	ax,-2[bp]
10116                                           ! Debug: list unsigned int = ax+7 (used reg = )
10117 2BF2           05                   0007  add	ax,*7
10118 2BF5           50                         push	ax
10119                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10120 2BF6           E8         D8FF            call	_inb
10121 2BF9           44                         inc	sp
10122 2BFA           44                         inc	sp
10123                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$E-$B] (used reg = )
10124 2BFB           8846         F7            mov	-9[bp],al
10125                                           !BCC_EOS
10126                                           ! 1960   if (status & 0x01) {
10127                                           ! Debug: and int = const 1 to unsigned char status = [S+$E-$B] (used reg = )
10128 2BFE           8A46         F7            mov	al,-9[bp]
10129 2C01           24                     01  and	al,*1
10130 2C03           84C0                       test	al,al
10131 2C05           74           09            je  	.276
10132                       00002C07            .277:
10133                                           ! 1961     ;
10134                                           !BCC_EOS
10135                                           ! 1962     return 2;
10136 2C07           B8                   0002  mov	ax,*2
10137 2C0A           89EC                       mov	sp,bp
10138 2C0C           5D                         pop	bp
10139 2C0D           C3                         ret
10140                                           !BCC_EOS
10141                                           ! 1963   } else if ( !(status & 0x08) ) {
10142 2C0E           EB           10            jmp .278
10143                       00002C10            .276:
10144                                           ! Debug: and int = const 8 to unsigned char status = [S+$E-$B] (used reg = )
10145 2C10           8A46         F7            mov	al,-9[bp]
10146 2C13           24                     08  and	al,*8
10147 2C15           84C0                       test	al,al
10148 2C17           75           07            jne 	.279
10149                       00002C19            .27A:
10150                                           ! 1964     ;
10151                                           !BCC_EOS
10152                                           ! 1965     return 3;
10153 2C19           B8                   0003  mov	ax,*3
10154 2C1C           89EC                       mov	sp,bp
10155 2C1E           5D                         pop	bp
10156 2C1F           C3                         ret
10157                                           !BCC_EOS
10158                                           ! 1966   }
10159                                           ! 1967 #asm
10160                       00002C20            .279:
10161                       00002C20            .278:
10162                                           !BCC_EOS
10163                                           !BCC_ASM
10164                       00000016            _ata_cmd_data_io.count	set	$16
10165                       0000000A            .ata_cmd_data_io.count	set	$A
10166                       00000026            _ata_cmd_data_io.segment	set	$26
10167                       0000001A            .ata_cmd_data_io.segment	set	$1A
10168                       0000000A            _ata_cmd_data_io.iobase1	set	$A
10169                       FFFFFFFE            .ata_cmd_data_io.iobase1	set	-2
10170                       00000005            _ata_cmd_data_io.channel	set	5
10171                       FFFFFFF9            .ata_cmd_data_io.channel	set	-7
10172                       0000001E            _ata_cmd_data_io.lba_low	set	$1E
10173                       00000012            .ata_cmd_data_io.lba_low	set	$12
10174                       00000022            _ata_cmd_data_io.lba_high	set	$22
10175                       00000016            .ata_cmd_data_io.lba_high	set	$16
10176                       0000001C            _ata_cmd_data_io.sector	set	$1C
10177                       00000010            .ata_cmd_data_io.sector	set	$10
10178                       00000006            _ata_cmd_data_io.blksize	set	6
10179                       FFFFFFFA            .ata_cmd_data_io.blksize	set	-6
10180                       0000001A            _ata_cmd_data_io.head	set	$1A
10181                       0000000E            .ata_cmd_data_io.head	set	$E
10182                       00000010            _ata_cmd_data_io.ioflag	set	$10
10183                       00000004            .ata_cmd_data_io.ioflag	set	4
10184                       00000018            _ata_cmd_data_io.cylinder	set	$18
10185                       0000000C            .ata_cmd_data_io.cylinder	set	$C
10186                       00000012            _ata_cmd_data_io.device	set	$12
10187                       00000006            .ata_cmd_data_io.device	set	6
10188                       00000003            _ata_cmd_data_io.status	set	3
10189                       FFFFFFF7            .ata_cmd_data_io.status	set	-9
10190                       00000002            _ata_cmd_data_io.current	set	2
10191                       FFFFFFF6            .ata_cmd_data_io.current	set	-$A
10192                       00000014            _ata_cmd_data_io.command	set	$14
10193                       00000008            .ata_cmd_data_io.command	set	8
10194                       00000001            _ata_cmd_data_io.mode	set	1
10195                       FFFFFFF5            .ata_cmd_data_io.mode	set	-$B
10196                       00000008            _ata_cmd_data_io.iobase2	set	8
10197                       FFFFFFFC            .ata_cmd_data_io.iobase2	set	-4
10198                       00000028            _ata_cmd_data_io.offset	set	$28
10199                       0000001C            .ata_cmd_data_io.offset	set	$1C
10200                       00000004            _ata_cmd_data_io.slave	set	4
10201                       FFFFFFF8            .ata_cmd_data_io.slave	set	-8
10202 2C20           FB                                 sti ;; enable higher priority interrupts
10203                                           ! 1969 endasm
10204                                           !BCC_ENDASM
10205                                           !BCC_EOS
10206                                           ! 1970   while (1) {
10207                       00002C21            .27D:
10208                                           ! 1971     if(ioflag == 0)
10209                                           ! Debug: logeq int = const 0 to unsigned short ioflag = [S+$E+2] (used reg = )
10210 2C21           8B46         04            mov	ax,4[bp]
10211 2C24           85C0                       test	ax,ax
10212 2C26           75           36            jne 	.27E
10213                       00002C28            .27F:
10214                                           ! 1972     {
10215                                           ! 1973 #asm
10216                                           !BCC_EOS
10217                                           !BCC_ASM
10218                       00000016            _ata_cmd_data_io.count	set	$16
10219                       0000000A            .ata_cmd_data_io.count	set	$A
10220                       00000026            _ata_cmd_data_io.segment	set	$26
10221                       0000001A            .ata_cmd_data_io.segment	set	$1A
10222                       0000000A            _ata_cmd_data_io.iobase1	set	$A
10223                       FFFFFFFE            .ata_cmd_data_io.iobase1	set	-2
10224                       00000005            _ata_cmd_data_io.channel	set	5
10225                       FFFFFFF9            .ata_cmd_data_io.channel	set	-7
10226                       0000001E            _ata_cmd_data_io.lba_low	set	$1E
10227                       00000012            .ata_cmd_data_io.lba_low	set	$12
10228                       00000022            _ata_cmd_data_io.lba_high	set	$22
10229                       00000016            .ata_cmd_data_io.lba_high	set	$16
10230                       0000001C            _ata_cmd_data_io.sector	set	$1C
10231                       00000010            .ata_cmd_data_io.sector	set	$10
10232                       00000006            _ata_cmd_data_io.blksize	set	6
10233                       FFFFFFFA            .ata_cmd_data_io.blksize	set	-6
10234                       0000001A            _ata_cmd_data_io.head	set	$1A
10235                       0000000E            .ata_cmd_data_io.head	set	$E
10236                       00000010            _ata_cmd_data_io.ioflag	set	$10
10237                       00000004            .ata_cmd_data_io.ioflag	set	4
10238                       00000018            _ata_cmd_data_io.cylinder	set	$18
10239                       0000000C            .ata_cmd_data_io.cylinder	set	$C
10240                       00000012            _ata_cmd_data_io.device	set	$12
10241                       00000006            .ata_cmd_data_io.device	set	6
10242                       00000003            _ata_cmd_data_io.status	set	3
10243                       FFFFFFF7            .ata_cmd_data_io.status	set	-9
10244                       00000002            _ata_cmd_data_io.current	set	2
10245                       FFFFFFF6            .ata_cmd_data_io.current	set	-$A
10246                       00000014            _ata_cmd_data_io.command	set	$14
10247                       00000008            .ata_cmd_data_io.command	set	8
10248                       00000001            _ata_cmd_data_io.mode	set	1
10249                       FFFFFFF5            .ata_cmd_data_io.mode	set	-$B
10250                       00000008            _ata_cmd_data_io.iobase2	set	8
10251                       FFFFFFFC            .ata_cmd_data_io.iobase2	set	-4
10252                       00000028            _ata_cmd_data_io.offset	set	$28
10253                       0000001C            .ata_cmd_data_io.offset	set	$1C
10254                       00000004            _ata_cmd_data_io.slave	set	4
10255                       FFFFFFF8            .ata_cmd_data_io.slave	set	-8
10256 2C28           55                                 push bp
10257 2C29           89E5                               mov bp, sp
10258 2C2B           8B7E         2A                    mov di, _ata_cmd_data_io.offset + 2[bp]
10259 2C2E           8B46         28                    mov ax, _ata_cmd_data_io.segment + 2[bp]
10260 2C31           8B4E         08                    mov cx, _ata_cmd_data_io.blksize + 2[bp]
10261                                                   ;; adjust if there will be an overrun. 2K max sector size
10262 2C34           81FF                 F800          cmp di, #0xf800 ;;
10263 2C38           76           07                    jbe ata_in_no_adjust
10264                       00002C3A            ata_in_adjust:
10265 2C3A           81EF                 0800          sub di, #0x0800 ;; sub 2 kbytes from offset
10266 2C3E           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
10267                       00002C41            ata_in_no_adjust:
10268 2C41           8EC0                               mov es, ax ;; segment in es
10269 2C43           8B56         0C                    mov dx, _ata_cmd_data_io.iobase1 + 2[bp] ;; ATA data read port
10270 2C46           8A66         03                    mov ah, _ata_cmd_data_io.mode + 2[bp]
10271 2C49           80FC                   01          cmp ah, #0x01
10272 2C4C           74           04                    je ata_in_32
10273                       00002C4E            ata_in_16:
10274 2C4E           F3                                 rep
10275 2C4F           6D                                   insw ;; CX words transferred from port(DX) to ES:[DI]
10276 2C50           EB           03                    jmp ata_in_done
10277                       00002C52            ata_in_32:
10278 2C52           F3                                 rep
10279 2C53     66    6D                                   insd ;; CX dwords transferred from port(DX) to ES:[DI]
10280                       00002C55            ata_in_done:
10281 2C55           897E         2A                    mov _ata_cmd_data_io.offset + 2[bp], di
10282 2C58           8C46         28                    mov _ata_cmd_data_io.segment + 2[bp], es
10283 2C5B           5D                                 pop bp
10284                                           ! 2002 endasm
10285                                           !BCC_ENDASM
10286                                           !BCC_EOS
10287                                           ! 2003     }
10288                                           ! 2004     else
10289                                           ! 2005     {
10290 2C5C           EB           36            jmp .280
10291                       00002C5E            .27E:
10292                                           ! 2006 #asm
10293                                           !BCC_EOS
10294                                           !BCC_ASM
10295                       00000016            _ata_cmd_data_io.count	set	$16
10296                       0000000A            .ata_cmd_data_io.count	set	$A
10297                       00000026            _ata_cmd_data_io.segment	set	$26
10298                       0000001A            .ata_cmd_data_io.segment	set	$1A
10299                       0000000A            _ata_cmd_data_io.iobase1	set	$A
10300                       FFFFFFFE            .ata_cmd_data_io.iobase1	set	-2
10301                       00000005            _ata_cmd_data_io.channel	set	5
10302                       FFFFFFF9            .ata_cmd_data_io.channel	set	-7
10303                       0000001E            _ata_cmd_data_io.lba_low	set	$1E
10304                       00000012            .ata_cmd_data_io.lba_low	set	$12
10305                       00000022            _ata_cmd_data_io.lba_high	set	$22
10306                       00000016            .ata_cmd_data_io.lba_high	set	$16
10307                       0000001C            _ata_cmd_data_io.sector	set	$1C
10308                       00000010            .ata_cmd_data_io.sector	set	$10
10309                       00000006            _ata_cmd_data_io.blksize	set	6
10310                       FFFFFFFA            .ata_cmd_data_io.blksize	set	-6
10311                       0000001A            _ata_cmd_data_io.head	set	$1A
10312                       0000000E            .ata_cmd_data_io.head	set	$E
10313                       00000010            _ata_cmd_data_io.ioflag	set	$10
10314                       00000004            .ata_cmd_data_io.ioflag	set	4
10315                       00000018            _ata_cmd_data_io.cylinder	set	$18
10316                       0000000C            .ata_cmd_data_io.cylinder	set	$C
10317                       00000012            _ata_cmd_data_io.device	set	$12
10318                       00000006            .ata_cmd_data_io.device	set	6
10319                       00000003            _ata_cmd_data_io.status	set	3
10320                       FFFFFFF7            .ata_cmd_data_io.status	set	-9
10321                       00000002            _ata_cmd_data_io.current	set	2
10322                       FFFFFFF6            .ata_cmd_data_io.current	set	-$A
10323                       00000014            _ata_cmd_data_io.command	set	$14
10324                       00000008            .ata_cmd_data_io.command	set	8
10325                       00000001            _ata_cmd_data_io.mode	set	1
10326                       FFFFFFF5            .ata_cmd_data_io.mode	set	-$B
10327                       00000008            _ata_cmd_data_io.iobase2	set	8
10328                       FFFFFFFC            .ata_cmd_data_io.iobase2	set	-4
10329                       00000028            _ata_cmd_data_io.offset	set	$28
10330                       0000001C            .ata_cmd_data_io.offset	set	$1C
10331                       00000004            _ata_cmd_data_io.slave	set	4
10332                       FFFFFFF8            .ata_cmd_data_io.slave	set	-8
10333 2C5E           55                                 push bp
10334 2C5F           89E5                               mov bp, sp
10335 2C61           8B76         2A                    mov si, _ata_cmd_data_io.offset + 2[bp]
10336 2C64           8B46         28                    mov ax, _ata_cmd_data_io.segment + 2[bp]
10337 2C67           8B4E         08                    mov cx, _ata_cmd_data_io.blksize + 2[bp]
10338                                                   ;; adjust if there will be an overrun. 2K max sector size
10339 2C6A           81FE                 F800          cmp si, #0xf800 ;;
10340 2C6E           76           07                    jbe ata_out_no_adjust
10341                       00002C70            ata_out_adjust:
10342 2C70           81EE                 0800          sub si, #0x0800 ;; sub 2 kbytes from offset
10343 2C74           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
10344                       00002C77            ata_out_no_adjust:
10345 2C77           8EC0                               mov es, ax ;; segment in es
10346 2C79           8B56         0C                    mov dx, _ata_cmd_data_io.iobase1 + 2[bp] ;; ATA data write port
10347 2C7C           8A66         03                    mov ah, _ata_cmd_data_io.mode + 2[bp]
10348 2C7F           80FC                   01          cmp ah, #0x01
10349 2C82           74           05                    je ata_out_32
10350                       00002C84            ata_out_16:
10351 2C84           26                                 seg ES
10352 2C85           F3                                 rep
10353 2C86           6F                                   outsw ;; CX words transferred from port(DX) to ES:[SI]
10354 2C87           EB           04                    jmp ata_out_done
10355                       00002C89            ata_out_32:
10356 2C89           26                                 seg ES
10357 2C8A           F3                                 rep
10358 2C8B     66    6F                                   outsd ;; CX dwords transferred from port(DX) to ES:[SI]
10359                       00002C8D            ata_out_done:
10360 2C8D           8976         2A                    mov _ata_cmd_data_io.offset + 2[bp], si
10361 2C90           8C46         28                    mov _ata_cmd_data_io.segment + 2[bp], es
10362 2C93           5D                                 pop bp
10363                                           ! 2037 endasm
10364                                           !BCC_ENDASM
10365                                           !BCC_EOS
10366                                           ! 2038     }
10367                                           ! 2039     current++;
10368                       00002C94            .280:
10369                                           ! Debug: postinc unsigned char current = [S+$E-$C] (used reg = )
10370 2C94           8A46         F6            mov	al,-$A[bp]
10371 2C97           40                         inc	ax
10372 2C98           8846         F6            mov	-$A[bp],al
10373                                           !BCC_EOS
10374                                           ! 2040     *((Bit16u *)(&((ebda_data_t *) 0)->ata.trsfsectors)) = (current);
10375                                           ! Debug: eq unsigned char current = [S+$E-$C] to unsigned short = [+$254] (used reg = )
10376 2C9B           8A46         F6            mov	al,-$A[bp]
10377 2C9E           30E4                       xor	ah,ah
10378 2CA0           A3         0254            mov	[$254],ax
10379                                           !BCC_EOS
10380                                           ! 2041     count--;
10381                                           ! Debug: postdec unsigned short count = [S+$E+8] (used reg = )
10382 2CA3           8B46         0A            mov	ax,$A[bp]
10383 2CA6           48                         dec	ax
10384 2CA7           8946         0A            mov	$A[bp],ax
10385                                           !BCC_EOS
10386                                           ! 2042     if(ioflag == 0) await_ide(2, iobase1, 32000u);
10387                                           ! Debug: logeq int = const 0 to unsigned short ioflag = [S+$E+2] (used reg = )
10388 2CAA           8B46         04            mov	ax,4[bp]
10389 2CAD           85C0                       test	ax,ax
10390 2CAF           75           11            jne 	.281
10391                       00002CB1            .282:
10392                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10393 2CB1           B8                   7D00  mov	ax,#$7D00
10394 2CB4           50                         push	ax
10395                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
10396 2CB5           FF76         FE            push	-2[bp]
10397                                           ! Debug: list int = const 2 (used reg = )
10398 2CB8           B8                   0002  mov	ax,*2
10399 2CBB           50                         push	ax
10400                                           ! Debug: func () int = await_ide+0 (used reg = )
10401 2CBC           E8         ED74            call	_await_ide
10402 2CBF           83C4                   06  add	sp,*6
10403                                           !BCC_EOS
10404                                           ! 2043     status = inb(iobase1 + 7);
10405                       00002CC2            .281:
10406                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$E-4] (used reg = )
10407 2CC2           8B46         FE            mov	ax,-2[bp]
10408                                           ! Debug: list unsigned int = ax+7 (used reg = )
10409 2CC5           05                   0007  add	ax,*7
10410 2CC8           50                         push	ax
10411                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10412 2CC9           E8         D82C            call	_inb
10413 2CCC           44                         inc	sp
10414 2CCD           44                         inc	sp
10415                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$E-$B] (used reg = )
10416 2CCE           8846         F7            mov	-9[bp],al
10417                                           !BCC_EOS
10418                                           ! 2044     if(ioflag == 0)
10419                                           ! Debug: logeq int = const 0 to unsigned short ioflag = [S+$E+2] (used reg = )
10420 2CD1           8B46         04            mov	ax,4[bp]
10421 2CD4           85C0                       test	ax,ax
10422 2CD6           75           2F            jne 	.283
10423                       00002CD8            .284:
10424                                           ! 2045     {
10425                                           ! 2046       if (count == 0) {
10426                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$E+8] (used reg = )
10427 2CD8           8B46         0A            mov	ax,$A[bp]
10428 2CDB           85C0                       test	ax,ax
10429 2CDD           75           14            jne 	.285
10430                       00002CDF            .286:
10431                                           ! 2047         if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
10432                                           ! 2048             != 0x40 ) {
10433                                           ! Debug: and int = const $C9 to unsigned char status = [S+$E-$B] (used reg = )
10434 2CDF           8A46         F7            mov	al,-9[bp]
10435 2CE2           24                     C9  and	al,#$C9
10436                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
10437 2CE4           3C                     40  cmp	al,*$40
10438 2CE6           74           07            je  	.287
10439                       00002CE8            .288:
10440                                           ! 2049           ;
10441                                           !BCC_EOS
10442                                           ! 2050           return 4;
10443 2CE8           B8                   0004  mov	ax,*4
10444 2CEB           89EC                       mov	sp,bp
10445 2CED           5D                         pop	bp
10446 2CEE           C3                         ret
10447                                           !BCC_EOS
10448                                           ! 2051         }
10449                                           ! 2052         break;
10450                       00002CEF            .287:
10451 2CEF           EB           46            jmp .27B
10452                                           !BCC_EOS
10453                                           ! 2053       }
10454                                           ! 2054       else {
10455 2CF1           EB           12            jmp .289
10456                       00002CF3            .285:
10457                                           ! 2055         if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
10458                                           ! 2056             != (0x40 | 0x08) ) {
10459                                           ! Debug: and int = const $C9 to unsigned char status = [S+$E-$B] (used reg = )
10460 2CF3           8A46         F7            mov	al,-9[bp]
10461 2CF6           24                     C9  and	al,#$C9
10462                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
10463 2CF8           3C                     48  cmp	al,*$48
10464 2CFA           74           07            je  	.28A
10465                       00002CFC            .28B:
10466                                           ! 2057           ;
10467                                           !BCC_EOS
10468                                           ! 2058           return 5;
10469 2CFC           B8                   0005  mov	ax,*5
10470 2CFF           89EC                       mov	sp,bp
10471 2D01           5D                         pop	bp
10472 2D02           C3                         ret
10473                                           !BCC_EOS
10474                                           ! 2059         }
10475                                           ! 2060         continue;
10476                       00002D03            .28A:
10477 2D03           EB           2F            jmp .27C
10478                                           !BCC_EOS
10479                                           ! 2061       }
10480                                           ! 2062     }
10481                       00002D05            .289:
10482                                           ! 2063     else
10483                                           ! 2064     {
10484 2D05           EB           2D            jmp .28C
10485                       00002D07            .283:
10486                                           ! 2065       if (count == 0) {
10487                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$E+8] (used reg = )
10488 2D07           8B46         0A            mov	ax,$A[bp]
10489 2D0A           85C0                       test	ax,ax
10490 2D0C           75           14            jne 	.28D
10491                       00002D0E            .28E:
10492                                           ! 2066         if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
10493                                           ! 2067             != 0x40 ) {
10494                                           ! Debug: and int = const $E9 to unsigned char status = [S+$E-$B] (used reg = )
10495 2D0E           8A46         F7            mov	al,-9[bp]
10496 2D11           24                     E9  and	al,#$E9
10497                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
10498 2D13           3C                     40  cmp	al,*$40
10499 2D15           74           07            je  	.28F
10500                       00002D17            .290:
10501                                           ! 2068           ;
10502                                           !BCC_EOS
10503                                           ! 2069           return 6;
10504 2D17           B8                   0006  mov	ax,*6
10505 2D1A           89EC                       mov	sp,bp
10506 2D1C           5D                         pop	bp
10507 2D1D           C3                         ret
10508                                           !BCC_EOS
10509                                           ! 2070         }
10510                                           ! 2071         break;
10511                       00002D1E            .28F:
10512 2D1E           EB           17            jmp .27B
10513                                           !BCC_EOS
10514                                           ! 2072       }
10515                                           ! 2073       else {
10516 2D20           EB           12            jmp .291
10517                       00002D22            .28D:
10518                                           ! 2074         if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
10519                                           ! 2075   
10520                                           ! 2075           != (0x40 | 0x08) ) {
10521                                           ! Debug: and int = const $C9 to unsigned char status = [S+$E-$B] (used reg = )
10522 2D22           8A46         F7            mov	al,-9[bp]
10523 2D25           24                     C9  and	al,#$C9
10524                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
10525 2D27           3C                     48  cmp	al,*$48
10526 2D29           74           07            je  	.292
10527                       00002D2B            .293:
10528                                           ! 2076           ;
10529                                           !BCC_EOS
10530                                           ! 2077           return 7;
10531 2D2B           B8                   0007  mov	ax,*7
10532 2D2E           89EC                       mov	sp,bp
10533 2D30           5D                         pop	bp
10534 2D31           C3                         ret
10535                                           !BCC_EOS
10536                                           ! 2078         }
10537                                           ! 2079         continue;
10538                       00002D32            .292:
10539 2D32           EB           00            jmp .27C
10540                                           !BCC_EOS
10541                                           ! 2080       }
10542                                           ! 2081     }
10543                       00002D34            .291:
10544                                           ! 2082   }
10545                       00002D34            .28C:
10546                                           ! 2083   outb(iobase2+6, 0x08);
10547                       00002D34            .27C:
10548 2D34           E9         FEEA            br 	.27D
10549                       00002D37            .294:
10550                       00002D37            .27B:
10551                                           ! Debug: list int = const 8 (used reg = )
10552 2D37           B8                   0008  mov	ax,*8
10553 2D3A           50                         push	ax
10554                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-6] (used reg = )
10555 2D3B           8B46         FC            mov	ax,-4[bp]
10556                                           ! Debug: list unsigned int = ax+6 (used reg = )
10557 2D3E           05                   0006  add	ax,*6
10558 2D41           50                         push	ax
10559                                           ! Debug: func () void = outb+0 (used reg = )
10560 2D42           E8         D7C9            call	_outb
10561 2D45           83C4                   04  add	sp,*4
10562                                           !BCC_EOS
10563                                           ! 2084   return 0;
10564 2D48           31C0                       xor	ax,ax
10565 2D4A           89EC                       mov	sp,bp
10566 2D4C           5D                         pop	bp
10567 2D4D           C3                         ret
10568                                           !BCC_EOS
10569                                           ! 2085 }
10570                                           ! 2086 Bit16u ata_cmd_packet(device, cmdlen, cmdseg, cmdoff, header, length, inout, bufseg, bufoff)
10571                                           ! Register BX used in function ata_cmd_data_io
10572                                           ! 2087 Bit8u cmdlen,inout;
10573                                           export	_ata_cmd_packet
10574                       00002D4E            _ata_cmd_packet:
10575                                           !BCC_EOS
10576                                           ! 2088 Bit16u device,cmdseg, cmdoff, bufseg, bufoff;
10577                                           !BCC_EOS
10578                                           ! 2089 Bit16u header;
10579                                           !BCC_EOS
10580                                           ! 2090 Bit32u length;
10581                                           !BCC_EOS
10582                                           ! 2091 {
10583                                           ! 2092   Bit16u ebda_seg=get_ebda_seg(), old_ds;
10584 2D4E           55                         push	bp
10585 2D4F           89E5                       mov	bp,sp
10586 2D51           4C                         dec	sp
10587 2D52           4C                         dec	sp
10588                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
10589 2D53           E8         D916            call	_get_ebda_seg
10590                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
10591 2D56           8946         FE            mov	-2[bp],ax
10592                                           !BCC_EOS
10593                                           ! 2093   Bit16u iobase1, iobase2;
10594                                           !BCC_EOS
10595                                           ! 2094   Bit16u lcount, lbefore, lafter, count;
10596                                           !BCC_EOS
10597                                           ! 2095   Bit8u channel, slave;
10598                                           !BCC_EOS
10599                                           ! 2096   Bit8u status, mode, lmode;
10600                                           !BCC_EOS
10601                                           ! 2097   Bit32u total, transfer;
10602                                           !BCC_EOS
10603                                           ! 2098   channel = device / 2;
10604 2D59           83C4                   E4  add	sp,*-$1C
10605                                           ! Debug: div int = const 2 to unsigned short device = [S+$20+2] (used reg = )
10606 2D5C           8B46         04            mov	ax,4[bp]
10607 2D5F           D1E8                       shr	ax,*1
10608                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$20-$13] (used reg = )
10609 2D61           8846         EF            mov	-$11[bp],al
10610                                           !BCC_EOS
10611                                           ! 2099   slave = device % 2;
10612                                           ! Debug: mod int = const 2 to unsigned short device = [S+$20+2] (used reg = )
10613 2D64           8B46         04            mov	ax,4[bp]
10614 2D67           24                     01  and	al,*1
10615                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$20-$14] (used reg = )
10616 2D69           8846         EE            mov	-$12[bp],al
10617                                           !BCC_EOS
10618                                           ! 2100   if (inout == 0x02) {
10619                                           ! Debug: logeq int = const 2 to unsigned char inout = [S+$20+$10] (used reg = )
10620 2D6C           8A46         12            mov	al,$12[bp]
10621 2D6F           3C                     02  cmp	al,*2
10622 2D71           75           15            jne 	.295
10623                       00002D73            .296:
10624                                           ! 2101     bios_printf(4, "ata_cmd_packet: DATA_OUT not supported yet\n");
10625                                           ! Debug: list * char = .297+0 (used reg = )
10626 2D73           BB                   D650  mov	bx,#.297
10627 2D76           53                         push	bx
10628                                           ! Debug: list int = const 4 (used reg = )
10629 2D77           B8                   0004  mov	ax,*4
10630 2D7A           50                         push	ax
10631                                           ! Debug: func () void = bios_printf+0 (used reg = )
10632 2D7B           E8         DBC0            call	_bios_printf
10633 2D7E           83C4                   04  add	sp,*4
10634                                           !BCC_EOS
10635                                           ! 2102     return 1;
10636 2D81           B8                   0001  mov	ax,*1
10637 2D84           89EC                       mov	sp,bp
10638 2D86           5D                         pop	bp
10639 2D87           C3                         ret
10640                                           !BCC_EOS
10641                                           ! 2103   }
10642                                           ! 2104   if (header & 1) {
10643                       00002D88            .295:
10644                                           ! Debug: and int = const 1 to unsigned short header = [S+$20+$A] (used reg = )
10645 2D88           8A46         0C            mov	al,$C[bp]
10646 2D8B           24                     01  and	al,*1
10647 2D8D           84C0                       test	al,al
10648 2D8F           74           07            je  	.298
10649                       00002D91            .299:
10650                                           ! 2105     ;
10651                                           !BCC_EOS
10652                                           ! 2106     return 1;
10653 2D91           B8                   0001  mov	ax,*1
10654 2D94           89EC                       mov	sp,bp
10655 2D96           5D                         pop	bp
10656 2D97           C3                         ret
10657                                           !BCC_EOS
10658                                           ! 2107   }
10659                                           ! 2108   old_ds = set_DS(ebda_seg);
10660                       00002D98            .298:
10661                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
10662 2D98           FF76         FE            push	-2[bp]
10663                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
10664 2D9B           E8         D8C4            call	_set_DS
10665 2D9E           44                         inc	sp
10666 2D9F           44                         inc	sp
10667                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+$20-6] (used reg = )
10668 2DA0           8946         FC            mov	-4[bp],ax
10669                                           !BCC_EOS
10670                                           ! 2109   iobase1 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1));
10671                                           ! Debug: ptradd unsigned char channel = [S+$20-$13] to [4] struct  = const $122 (used reg = )
10672 2DA3           8A46         EF            mov	al,-$11[bp]
10673 2DA6           30E4                       xor	ah,ah
10674 2DA8           B1                     03  mov	cl,*3
10675 2DAA           D3E0                       shl	ax,cl
10676 2DAC           89C3                       mov	bx,ax
10677                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
10678                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
10679                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$20-8] (used reg = )
10680 2DAE           8B9F       0124            mov	bx,$124[bx]
10681 2DB2           895E         FA            mov	-6[bp],bx
10682                                           !BCC_EOS
10683                                           ! 2110   iobase2 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2));
10684                                           ! Debug: ptradd unsigned char channel = [S+$20-$13] to [4] struct  = const $122 (used reg = )
10685 2DB5           8A46         EF            mov	al,-$11[bp]
10686 2DB8           30E4                       xor	ah,ah
10687 2DBA           B1                     03  mov	cl,*3
10688 2DBC           D3E0                       shl	ax,cl
10689 2DBE           89C3                       mov	bx,ax
10690                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
10691                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
10692                                           ! Debug: eq unsigned short = [bx+$126] to unsigned short iobase2 = [S+$20-$A] (used reg = )
10693 2DC0           8B9F       0126            mov	bx,$126[bx]
10694 2DC4           895E         F8            mov	-8[bp],bx
10695                                           !BCC_EOS
10696                                           ! 2111   mode = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode));
10697                                           ! Debug: ptradd unsigned short device = [S+$20+2] to [8] struct  = const $142 (used reg = )
10698 2DC7           8B46         04            mov	ax,4[bp]
10699 2DCA           B9                   001E  mov	cx,*$1E
10700 2DCD           F7E9                       imul	cx
10701 2DCF           89C3                       mov	bx,ax
10702                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
10703                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
10704                                           ! Debug: eq unsigned char = [bx+$146] to unsigned char mode = [S+$20-$16] (used reg = )
10705 2DD1           8A87       0146            mov	al,$146[bx]
10706 2DD5           8846         EC            mov	-$14[bp],al
10707                                           !BCC_EOS
10708                                           ! 2112   transfer= 0L;
10709                                           ! Debug: eq long = const 0 to unsigned long transfer = [S+$20-$20] (used reg = )
10710 2DD8           31C0                       xor	ax,ax
10711 2DDA           31DB                       xor	bx,bx
10712 2DDC           8946         E2            mov	-$1E[bp],ax
10713 2DDF           895E         E4            mov	-$1C[bp],bx
10714                                           !BCC_EOS
10715                                           ! 2113   if (cmdlen < 12) cmdlen=12;
10716                                           ! Debug: lt int = const $C to unsigned char cmdlen = [S+$20+4] (used reg = )
10717 2DE2           8A46         06            mov	al,6[bp]
10718 2DE5           3C                     0C  cmp	al,*$C
10719 2DE7           73           05            jae 	.29A
10720                       00002DE9            .29B:
10721                                           ! Debug: eq int = const $C to unsigned char cmdlen = [S+$20+4] (used reg = )
10722 2DE9           B0                     0C  mov	al,*$C
10723 2DEB           8846         06            mov	6[bp],al
10724                                           !BCC_EOS
10725                                           ! 2114   if (cmdlen > 12) cmdlen=16;
10726                       00002DEE            .29A:
10727                                           ! Debug: gt int = const $C to unsigned char cmdlen = [S+$20+4] (used reg = )
10728 2DEE           8A46         06            mov	al,6[bp]
10729 2DF1           3C                     0C  cmp	al,*$C
10730 2DF3           76           05            jbe 	.29C
10731                       00002DF5            .29D:
10732                                           ! Debug: eq int = const $10 to unsigned char cmdlen = [S+$20+4] (used reg = )
10733 2DF5           B0                     10  mov	al,*$10
10734 2DF7           8846         06            mov	6[bp],al
10735                                           !BCC_EOS
10736                                           ! 2115   cmdlen>>=1;
10737                       00002DFA            .29C:
10738                                           ! Debug: srab int = const 1 to unsigned char cmdlen = [S+$20+4] (used reg = )
10739 2DFA           8A46         06            mov	al,6[bp]
10740 2DFD           30E4                       xor	ah,ah
10741 2DFF           D1E8                       shr	ax,*1
10742 2E01           8846         06            mov	6[bp],al
10743                                           !BCC_EOS
10744                                           ! 2116   *((Bit16u *)(&((ebda_data_t *) 0)->ata.trsfsectors)) = (0);
10745                                           ! Debug: eq int = const 0 to unsigned short = [+$254] (used reg = )
10746 2E04           31C0                       xor	ax,ax
10747 2E06           A3         0254            mov	[$254],ax
10748                                           !BCC_EOS
10749                                           ! 2117   *((Bit32u *)(&((ebda_data_t *) 0)->ata.trsfbytes)) = (0L);
10750                                           ! Debug: eq long = const 0 to unsigned long = [+$256] (used reg = )
10751 2E09           31C0                       xor	ax,ax
10752 2E0B           31DB                       xor	bx,bx
10753 2E0D           A3         0256            mov	[$256],ax
10754 2E10           891E       0258            mov	[$258],bx
10755                                           !BCC_EOS
10756                                           ! 2118   set_DS(old_ds);
10757                                           ! Debug: list unsigned short old_ds = [S+$20-6] (used reg = )
10758 2E14           FF76         FC            push	-4[bp]
10759                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
10760 2E17           E8         D848            call	_set_DS
10761 2E1A           44                         inc	sp
10762 2E1B           44                         inc	sp
10763                                           !BCC_EOS
10764                                           ! 2119   status = inb(iobase1 + 7);
10765                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-8] (used reg = )
10766 2E1C           8B46         FA            mov	ax,-6[bp]
10767                                           ! Debug: list unsigned int = ax+7 (used reg = )
10768 2E1F           05                   0007  add	ax,*7
10769 2E22           50                         push	ax
10770                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10771 2E23           E8         D6D2            call	_inb
10772 2E26           44                         inc	sp
10773 2E27           44                         inc	sp
10774                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$20-$15] (used reg = )
10775 2E28           8846         ED            mov	-$13[bp],al
10776                                           !BCC_EOS
10777                                           ! 2120   if (status & 0x80) return 2;
10778                                           ! Debug: and int = const $80 to unsigned char status = [S+$20-$15] (used reg = )
10779 2E2B           8A46         ED            mov	al,-$13[bp]
10780 2E2E           24                     80  and	al,#$80
10781 2E30           84C0                       test	al,al
10782 2E32           74           07            je  	.29E
10783                       00002E34            .29F:
10784 2E34           B8                   0002  mov	ax,*2
10785 2E37           89EC                       mov	sp,bp
10786 2E39           5D                         pop	bp
10787 2E3A           C3                         ret
10788                                           !BCC_EOS
10789                                           ! 2121   outb(iobase2 + 6, 0x08 | 0x02);
10790                       00002E3B            .29E:
10791                                           ! Debug: list int = const $A (used reg = )
10792 2E3B           B8                   000A  mov	ax,*$A
10793 2E3E           50                         push	ax
10794                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$22-$A] (used reg = )
10795 2E3F           8B46         F8            mov	ax,-8[bp]
10796                                           ! Debug: list unsigned int = ax+6 (used reg = )
10797 2E42           05                   0006  add	ax,*6
10798 2E45           50                         push	ax
10799                                           ! Debug: func () void = outb+0 (used reg = )
10800 2E46           E8         D6C5            call	_outb
10801 2E49           83C4                   04  add	sp,*4
10802                                           !BCC_EOS
10803                                           ! 2122   outb(iobase1 + 1, 0x00);
10804                                           ! Debug: list int = const 0 (used reg = )
10805 2E4C           31C0                       xor	ax,ax
10806 2E4E           50                         push	ax
10807                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$22-8] (used reg = )
10808 2E4F           8B46         FA            mov	ax,-6[bp]
10809                                           ! Debug: list unsigned int = ax+1 (used reg = )
10810 2E52           40                         inc	ax
10811 2E53           50                         push	ax
10812                                           ! Debug: func () void = outb+0 (used reg = )
10813 2E54           E8         D6B7            call	_outb
10814 2E57           83C4                   04  add	sp,*4
10815                                           !BCC_EOS
10816                                           ! 2123   outb(iobase1 + 2, 0x00);
10817                                           ! Debug: list int = const 0 (used reg = )
10818 2E5A           31C0                       xor	ax,ax
10819 2E5C           50                         push	ax
10820                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-8] (used reg = )
10821 2E5D           8B46         FA            mov	ax,-6[bp]
10822                                           ! Debug: list unsigned int = ax+2 (used reg = )
10823 2E60           40                         inc	ax
10824 2E61           40                         inc	ax
10825 2E62           50                         push	ax
10826                                           ! Debug: func () void = outb+0 (used reg = )
10827 2E63           E8         D6A8            call	_outb
10828 2E66           83C4                   04  add	sp,*4
10829                                           !BCC_EOS
10830                                           ! 2124   outb(iobase1 + 3, 0x00);
10831                                           ! Debug: list int = const 0 (used reg = )
10832 2E69           31C0                       xor	ax,ax
10833 2E6B           50                         push	ax
10834                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$22-8] (used reg = )
10835 2E6C           8B46         FA            mov	ax,-6[bp]
10836                                           ! Debug: list unsigned int = ax+3 (used reg = )
10837 2E6F           05                   0003  add	ax,*3
10838 2E72           50                         push	ax
10839                                           ! Debug: func () void = outb+0 (used reg = )
10840 2E73           E8         D698            call	_outb
10841 2E76           83C4                   04  add	sp,*4
10842                                           !BCC_EOS
10843                                           ! 2125   outb(iobase1 + 4, 0xfff0 & 0x00ff);
10844                                           ! Debug: list unsigned int = const $F0 (used reg = )
10845 2E79           B8                   00F0  mov	ax,#$F0
10846 2E7C           50                         push	ax
10847                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$22-8] (used reg = )
10848 2E7D           8B46         FA            mov	ax,-6[bp]
10849                                           ! Debug: list unsigned int = ax+4 (used reg = )
10850 2E80           05                   0004  add	ax,*4
10851 2E83           50                         push	ax
10852                                           ! Debug: func () void = outb+0 (used reg = )
10853 2E84           E8         D687            call	_outb
10854 2E87           83C4                   04  add	sp,*4
10855                                           !BCC_EOS
10856                                           ! 2126   outb(iobase1 + 5, 0xfff0 >> 8);
10857                                           ! Debug: list unsigned int = const $FF (used reg = )
10858 2E8A           B8                   00FF  mov	ax,#$FF
10859 2E8D           50                         push	ax
10860                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$22-8] (used reg = )
10861 2E8E           8B46         FA            mov	ax,-6[bp]
10862                                           ! Debug: list unsigned int = ax+5 (used reg = )
10863 2E91           05                   0005  add	ax,*5
10864 2E94           50                         push	ax
10865                                           ! Debug: func () void = outb+0 (used reg = )
10866 2E95           E8         D676            call	_outb
10867 2E98           83C4                   04  add	sp,*4
10868                                           !BCC_EOS
10869                                           ! 2127   outb(iobase1 + 6, slave ? 0xb0 : 0xa0);
10870 2E9B           8A46         EE            mov	al,-$12[bp]
10871 2E9E           84C0                       test	al,al
10872 2EA0           74           04            je  	.2A0
10873                       00002EA2            .2A1:
10874 2EA2           B0                     B0  mov	al,#$B0
10875 2EA4           EB           02            jmp .2A2
10876                       00002EA6            .2A0:
10877 2EA6           B0                     A0  mov	al,#$A0
10878                       00002EA8            .2A2:
10879                                           ! Debug: list char = al+0 (used reg = )
10880 2EA8           30E4                       xor	ah,ah
10881 2EAA           50                         push	ax
10882                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$22-8] (used reg = )
10883 2EAB           8B46         FA            mov	ax,-6[bp]
10884                                           ! Debug: list unsigned int = ax+6 (used reg = )
10885 2EAE           05                   0006  add	ax,*6
10886 2EB1           50                         push	ax
10887                                           ! Debug: func () void = outb+0 (used reg = )
10888 2EB2           E8         D659            call	_outb
10889 2EB5           83C4                   04  add	sp,*4
10890                                           !BCC_EOS
10891                                           ! 2128   outb(iobase1 + 7, 0xA0);
10892                                           ! Debug: list int = const $A0 (used reg = )
10893 2EB8           B8                   00A0  mov	ax,#$A0
10894 2EBB           50                         push	ax
10895                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$22-8] (used reg = )
10896 2EBC           8B46         FA            mov	ax,-6[bp]
10897                                           ! Debug: list unsigned int = ax+7 (used reg = )
10898 2EBF           05                   0007  add	ax,*7
10899 2EC2           50                         push	ax
10900                                           ! Debug: func () void = outb+0 (used reg = )
10901 2EC3           E8         D648            call	_outb
10902 2EC6           83C4                   04  add	sp,*4
10903                                           !BCC_EOS
10904                                           ! 2129   await_ide(3, iobase1, 32000u);
10905                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10906 2EC9           B8                   7D00  mov	ax,#$7D00
10907 2ECC           50                         push	ax
10908                                           ! Debug: list unsigned short iobase1 = [S+$22-8] (used reg = )
10909 2ECD           FF76         FA            push	-6[bp]
10910                                           ! Debug: list int = const 3 (used reg = )
10911 2ED0           B8                   0003  mov	ax,*3
10912 2ED3           50                         push	ax
10913                                           ! Debug: func () int = await_ide+0 (used reg = )
10914 2ED4           E8         EB5C            call	_await_ide
10915 2ED7           83C4                   06  add	sp,*6
10916                                           !BCC_EOS
10917                                           ! 2130   status = inb(iobase1 + 7);
10918                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-8] (used reg = )
10919 2EDA           8B46         FA            mov	ax,-6[bp]
10920                                           ! Debug: list unsigned int = ax+7 (used reg = )
10921 2EDD           05                   0007  add	ax,*7
10922 2EE0           50                         push	ax
10923                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10924 2EE1           E8         D614            call	_inb
10925 2EE4           44                         inc	sp
10926 2EE5           44                         inc	sp
10927                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$20-$15] (used reg = )
10928 2EE6           8846         ED            mov	-$13[bp],al
10929                                           !BCC_EOS
10930                                           ! 2131   if (status & 0x01) {
10931                                           ! Debug: and int = const 1 to unsigned char status = [S+$20-$15] (used reg = )
10932 2EE9           8A46         ED            mov	al,-$13[bp]
10933 2EEC           24                     01  and	al,*1
10934 2EEE           84C0                       test	al,al
10935 2EF0           74           09            je  	.2A3
10936                       00002EF2            .2A4:
10937                                           ! 2132     ;
10938                                           !BCC_EOS
10939                                           ! 2133     return 3;
10940 2EF2           B8                   0003  mov	ax,*3
10941 2EF5           89EC                       mov	sp,bp
10942 2EF7           5D                         pop	bp
10943 2EF8           C3                         ret
10944                                           !BCC_EOS
10945                                           ! 2134   } else if ( !(status & 0x08) ) {
10946 2EF9           EB           10            jmp .2A5
10947                       00002EFB            .2A3:
10948                                           ! Debug: and int = const 8 to unsigned char status = [S+$20-$15] (used reg = )
10949 2EFB           8A46         ED            mov	al,-$13[bp]
10950 2EFE           24                     08  and	al,*8
10951 2F00           84C0                       test	al,al
10952 2F02           75           07            jne 	.2A6
10953                       00002F04            .2A7:
10954                                           ! 2135     ;
10955                                           !BCC_EOS
10956                                           ! 2136     return 4;
10957 2F04           B8                   0004  mov	ax,*4
10958 2F07           89EC                       mov	sp,bp
10959 2F09           5D                         pop	bp
10960 2F0A           C3                         ret
10961                                           !BCC_EOS
10962                                           ! 2137   }
10963                                           ! 2138   cmdseg += (cmdoff / 16);
10964                       00002F0B            .2A6:
10965                       00002F0B            .2A5:
10966                                           ! Debug: div int = const $10 to unsigned short cmdoff = [S+$20+8] (used reg = )
10967 2F0B           8B46         0A            mov	ax,$A[bp]
10968 2F0E           B1                     04  mov	cl,*4
10969 2F10           D3E8                       shr	ax,cl
10970                                           ! Debug: addab unsigned int = ax+0 to unsigned short cmdseg = [S+$20+6] (used reg = )
10971 2F12           0346         08            add	ax,8[bp]
10972 2F15           8946         08            mov	8[bp],ax
10973                                           !BCC_EOS
10974                                           ! 2139   cmdoff %= 16;
10975                                           ! Debug: modab int = const $10 to unsigned short cmdoff = [S+$20+8] (used reg = )
10976 2F18           8B46         0A            mov	ax,$A[bp]
10977 2F1B           24                     0F  and	al,*$F
10978 2F1D           30E4                       xor	ah,ah
10979 2F1F           8946         0A            mov	$A[bp],ax
10980                                           !BCC_EOS
10981                                           ! 2140 #asm
10982                                           !BCC_EOS
10983                                           !BCC_ASM
10984                       00000028            _ata_cmd_packet.cmdoff	set	$28
10985                       0000000A            .ata_cmd_packet.cmdoff	set	$A
10986                       0000002A            _ata_cmd_packet.header	set	$2A
10987                       0000000C            .ata_cmd_packet.header	set	$C
10988                       0000000E            _ata_cmd_packet.count	set	$E
10989                       FFFFFFF0            .ata_cmd_packet.count	set	-$10
10990                       00000010            _ata_cmd_packet.lafter	set	$10
10991                       FFFFFFF2            .ata_cmd_packet.lafter	set	-$E
10992                       00000018            _ata_cmd_packet.iobase1	set	$18
10993                       FFFFFFFA            .ata_cmd_packet.iobase1	set	-6
10994                       0000000D            _ata_cmd_packet.channel	set	$D
10995                       FFFFFFEF            .ata_cmd_packet.channel	set	-$11
10996                       00000026            _ata_cmd_packet.cmdseg	set	$26
10997                       00000008            .ata_cmd_packet.cmdseg	set	8
10998                       00000024            _ata_cmd_packet.cmdlen	set	$24
10999                       00000006            .ata_cmd_packet.cmdlen	set	6
11000                       00000009            _ata_cmd_packet.lmode	set	9
11001                       FFFFFFEB            .ata_cmd_packet.lmode	set	-$15
11002                       00000022            _ata_cmd_packet.device	set	$22
11003                       00000004            .ata_cmd_packet.device	set	4
11004                       0000001C            _ata_cmd_packet.ebda_seg	set	$1C
11005                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
11006                       00000014            _ata_cmd_packet.lcount	set	$14
11007                       FFFFFFF6            .ata_cmd_packet.lcount	set	-$A
11008                       00000004            _ata_cmd_packet.total	set	4
11009                       FFFFFFE6            .ata_cmd_packet.total	set	-$1A
11010                       0000000B            _ata_cmd_packet.status	set	$B
11011                       FFFFFFED            .ata_cmd_packet.status	set	-$13
11012                       0000000A            _ata_cmd_packet.mode	set	$A
11013                       FFFFFFEC            .ata_cmd_packet.mode	set	-$14
11014                       00000034            _ata_cmd_packet.bufoff	set	$34
11015                       00000016            .ata_cmd_packet.bufoff	set	$16
11016                       00000000            _ata_cmd_packet.transfer	set	0
11017                       FFFFFFE2            .ata_cmd_packet.transfer	set	-$1E
11018                       00000016            _ata_cmd_packet.iobase2	set	$16
11019                       FFFFFFF8            .ata_cmd_packet.iobase2	set	-8
11020                       00000012            _ata_cmd_packet.lbefore	set	$12
11021                       FFFFFFF4            .ata_cmd_packet.lbefore	set	-$C
11022                       00000032            _ata_cmd_packet.bufseg	set	$32
11023                       00000014            .ata_cmd_packet.bufseg	set	$14
11024                       0000000C            _ata_cmd_packet.slave	set	$C
11025                       FFFFFFEE            .ata_cmd_packet.slave	set	-$12
11026                       00000030            _ata_cmd_packet.inout	set	$30
11027                       00000012            .ata_cmd_packet.inout	set	$12
11028                       0000001A            _ata_cmd_packet.old_ds	set	$1A
11029                       FFFFFFFC            .ata_cmd_packet.old_ds	set	-4
11030                       0000002C            _ata_cmd_packet.length	set	$2C
11031                       0000000E            .ata_cmd_packet.length	set	$E
11032 2F22           FB                               sti ;; enable higher priority interrupts
11033 2F23           55                               push bp
11034 2F24           89E5                             mov bp, sp
11035 2F26           8B76         2A                  mov si, _ata_cmd_packet.cmdoff + 2[bp]
11036 2F29           8B46         28                  mov ax, _ata_cmd_packet.cmdseg + 2[bp]
11037 2F2C           8B4E         26                  mov cx, _ata_cmd_packet.cmdlen + 2[bp]
11038 2F2F           8EC0                             mov es, ax ;; segment in es
11039 2F31           8B56         1A                  mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data write port
11040 2F34           26                               seg ES
11041 2F35           F3                               rep
11042 2F36           6F                                 outsw ;; CX words transferred from port(DX) to ES:[SI]
11043 2F37           5D                               pop bp
11044                                           ! 2153 endasm
11045                                           !BCC_ENDASM
11046                                           !BCC_EOS
11047                                           ! 2154   if (inout == 0x00) {
11048                                           ! Debug: logeq int = const 0 to unsigned char inout = [S+$20+$10] (used reg = )
11049 2F38           8A46         12            mov	al,$12[bp]
11050 2F3B           84C0                       test	al,al
11051 2F3D           75           23            jne 	.2A8
11052                       00002F3F            .2A9:
11053                                           ! 2155     await_ide(2, iobase1, 32000u);
11054                                           ! Debug: list unsigned int = const $7D00 (used reg = )
11055 2F3F           B8                   7D00  mov	ax,#$7D00
11056 2F42           50                         push	ax
11057                                           ! Debug: list unsigned short iobase1 = [S+$22-8] (used reg = )
11058 2F43           FF76         FA            push	-6[bp]
11059                                           ! Debug: list int = const 2 (used reg = )
11060 2F46           B8                   0002  mov	ax,*2
11061 2F49           50                         push	ax
11062                                           ! Debug: func () int = await_ide+0 (used reg = )
11063 2F4A           E8         EAE6            call	_await_ide
11064 2F4D           83C4                   06  add	sp,*6
11065                                           !BCC_EOS
11066                                           ! 2156     status = inb(iobase1 + 7);
11067                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-8] (used reg = )
11068 2F50           8B46         FA            mov	ax,-6[bp]
11069                                           ! Debug: list unsigned int = ax+7 (used reg = )
11070 2F53           05                   0007  add	ax,*7
11071 2F56           50                         push	ax
11072                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11073 2F57           E8         D59E            call	_inb
11074 2F5A           44                         inc	sp
11075 2F5B           44                         inc	sp
11076                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$20-$15] (used reg = )
11077 2F5C           8846         ED            mov	-$13[bp],al
11078                                           !BCC_EOS
11079                                           ! 2157   }
11080                                           ! 2158   else {
11081 2F5F           E9         026F            br 	.2AA
11082                       00002F62            .2A8:
11083                                           ! 2159     Bit16u loops = 0;
11084 2F62           4C                         dec	sp
11085 2F63           4C                         dec	sp
11086                                           ! Debug: eq int = const 0 to unsigned short loops = [S+$22-$22] (used reg = )
11087 2F64           31C0                       xor	ax,ax
11088 2F66           8946         E0            mov	-$20[bp],ax
11089                                           !BCC_EOS
11090                                           ! 2160     Bit8u sc;
11091                                           !BCC_EOS
11092                                           ! 2161     while (1) {
11093 2F69           4C                         dec	sp
11094 2F6A           4C                         dec	sp
11095                       00002F6B            .2AD:
11096                                           ! 2162       if (loops == 0) {
11097                                           ! Debug: logeq int = const 0 to unsigned short loops = [S+$24-$22] (used reg = )
11098 2F6B           8B46         E0            mov	ax,-$20[bp]
11099 2F6E           85C0                       test	ax,ax
11100 2F70           75           22            jne 	.2AE
11101                       00002F72            .2AF:
11102                                           ! 2163         status = inb(iobase2 + 6);
11103                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$24-$A] (used reg = )
11104 2F72           8B46         F8            mov	ax,-8[bp]
11105                                           ! Debug: list unsigned int = ax+6 (used reg = )
11106 2F75           05                   0006  add	ax,*6
11107 2F78           50                         push	ax
11108                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11109 2F79           E8         D57C            call	_inb
11110 2F7C           44                         inc	sp
11111 2F7D           44                         inc	sp
11112                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$24-$15] (used reg = )
11113 2F7E           8846         ED            mov	-$13[bp],al
11114                                           !BCC_EOS
11115                                           ! 2164         await_ide(3, iobase1, 32000u);
11116                                           ! Debug: list unsigned int = const $7D00 (used reg = )
11117 2F81           B8                   7D00  mov	ax,#$7D00
11118 2F84           50                         push	ax
11119                                           ! Debug: list unsigned short iobase1 = [S+$26-8] (used reg = )
11120 2F85           FF76         FA            push	-6[bp]
11121                                           ! Debug: list int = const 3 (used reg = )
11122 2F88           B8                   0003  mov	ax,*3
11123 2F8B           50                         push	ax
11124                                           ! Debug: func () int = await_ide+0 (used reg = )
11125 2F8C           E8         EAA4            call	_await_ide
11126 2F8F           83C4                   06  add	sp,*6
11127                                           !BCC_EOS
11128                                           ! 2165       }
11129                                           ! 2166       else
11130                                           ! 2167         await_ide(2, iobase1, 32000u);
11131 2F92           EB           11            jmp .2B0
11132                       00002F94            .2AE:
11133                                           ! Debug: list unsigned int = const $7D00 (used reg = )
11134 2F94           B8                   7D00  mov	ax,#$7D00
11135 2F97           50                         push	ax
11136                                           ! Debug: list unsigned short iobase1 = [S+$26-8] (used reg = )
11137 2F98           FF76         FA            push	-6[bp]
11138                                           ! Debug: list int = const 2 (used reg = )
11139 2F9B           B8                   0002  mov	ax,*2
11140 2F9E           50                         push	ax
11141                                           ! Debug: func () int = await_ide+0 (used reg = )
11142 2F9F           E8         EA91            call	_await_ide
11143 2FA2           83C4                   06  add	sp,*6
11144                                           !BCC_EOS
11145                                           ! 2168       loops++;
11146                       00002FA5            .2B0:
11147                                           ! Debug: postinc unsigned short loops = [S+$24-$22] (used reg = )
11148 2FA5           8B46         E0            mov	ax,-$20[bp]
11149 2FA8           40                         inc	ax
11150 2FA9           8946         E0            mov	-$20[bp],ax
11151                                           !BCC_EOS
11152                                           ! 2169       status = inb(iobase1 + 7);
11153                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$24-8] (used reg = )
11154 2FAC           8B46         FA            mov	ax,-6[bp]
11155                                           ! Debug: list unsigned int = ax+7 (used reg = )
11156 2FAF           05                   0007  add	ax,*7
11157 2FB2           50                         push	ax
11158                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11159 2FB3           E8         D542            call	_inb
11160 2FB6           44                         inc	sp
11161 2FB7           44                         inc	sp
11162                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$24-$15] (used reg = )
11163 2FB8           8846         ED            mov	-$13[bp],al
11164                                           !BCC_EOS
11165                                           ! 2170       sc = inb(iobase1 + 2);
11166                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$24-8] (used reg = )
11167 2FBB           8B46         FA            mov	ax,-6[bp]
11168                                           ! Debug: list unsigned int = ax+2 (used reg = )
11169 2FBE           40                         inc	ax
11170 2FBF           40                         inc	ax
11171 2FC0           50                         push	ax
11172                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11173 2FC1           E8         D534            call	_inb
11174 2FC4           44                         inc	sp
11175 2FC5           44                         inc	sp
11176                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$24-$23] (used reg = )
11177 2FC6           8846         DF            mov	-$21[bp],al
11178                                           !BCC_EOS
11179                                           ! 2171       if(((inb(iobase1 + 2)&0x7)==0x3) &&
11180                                           ! 2172          ((status & (0x40 | 0x01)) == 0x40)) break;
11181                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$24-8] (used reg = )
11182 2FC9           8B46         FA            mov	ax,-6[bp]
11183                                           ! Debug: list unsigned int = ax+2 (used reg = )
11184 2FCC           40                         inc	ax
11185 2FCD           40                         inc	ax
11186 2FCE           50                         push	ax
11187                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11188 2FCF           E8         D526            call	_inb
11189 2FD2           44                         inc	sp
11190 2FD3           44                         inc	sp
11191                                           ! Debug: and int = const 7 to unsigned char = al+0 (used reg = )
11192 2FD4           24                     07  and	al,*7
11193                                           ! Debug: logeq int = const 3 to unsigned char = al+0 (used reg = )
11194 2FD6           3C                     03  cmp	al,*3
11195 2FD8           75           0C            jne 	.2B1
11196                       00002FDA            .2B3:
11197                                           ! Debug: and int = const $41 to unsigned char status = [S+$24-$15] (used reg = )
11198 2FDA           8A46         ED            mov	al,-$13[bp]
11199 2FDD           24                     41  and	al,*$41
11200                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
11201 2FDF           3C                     40  cmp	al,*$40
11202 2FE1           75           03            jne 	.2B1
11203                       00002FE3            .2B2:
11204 2FE3           E9         01E8            br 	.2AB
11205                                           !BCC_EOS
11206                                           ! 2173       if (status & 0x01) {
11207                       00002FE6            .2B1:
11208                                           ! Debug: and int = const 1 to unsigned char status = [S+$24-$15] (used reg = )
11209 2FE6           8A46         ED            mov	al,-$13[bp]
11210 2FE9           24                     01  and	al,*1
11211 2FEB           84C0                       test	al,al
11212 2FED           74           07            je  	.2B4
11213                       00002FEF            .2B5:
11214                                           ! 2174         ;
11215                                           !BCC_EOS
11216                                           ! 2175         return 3;
11217 2FEF           B8                   0003  mov	ax,*3
11218 2FF2           89EC                       mov	sp,bp
11219 2FF4           5D                         pop	bp
11220 2FF5           C3                         ret
11221                                           !BCC_EOS
11222                                           ! 2176       }
11223                                           ! 2177       bufseg += (bufoff / 16);
11224                       00002FF6            .2B4:
11225                                           ! Debug: div int = const $10 to unsigned short bufoff = [S+$24+$14] (used reg = )
11226 2FF6           8B46         16            mov	ax,$16[bp]
11227 2FF9           B1                     04  mov	cl,*4
11228 2FFB           D3E8                       shr	ax,cl
11229                                           ! Debug: addab unsigned int = ax+0 to unsigned short bufseg = [S+$24+$12] (used reg = )
11230 2FFD           0346         14            add	ax,$14[bp]
11231 3000           8946         14            mov	$14[bp],ax
11232                                           !BCC_EOS
11233                                           ! 2178       bufoff %= 16;
11234                                           ! Debug: modab int = const $10 to unsigned short bufoff = [S+$24+$14] (used reg = )
11235 3003           8B46         16            mov	ax,$16[bp]
11236 3006           24                     0F  and	al,*$F
11237 3008           30E4                       xor	ah,ah
11238 300A           8946         16            mov	$16[bp],ax
11239                                           !BCC_EOS
11240                                           ! 2179       *((Bit8u *)&lcount) = inb(iobase1 + 4);
11241                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$24-8] (used reg = )
11242 300D           8B46         FA            mov	ax,-6[bp]
11243                                           ! Debug: list unsigned int = ax+4 (used reg = )
11244 3010           05                   0004  add	ax,*4
11245 3013           50                         push	ax
11246                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11247 3014           E8         D4E1            call	_inb
11248 3017           44                         inc	sp
11249 3018           44                         inc	sp
11250                                           ! Debug: eq unsigned char = al+0 to unsigned char lcount = [S+$24-$C] (used reg = )
11251 3019           8846         F6            mov	-$A[bp],al
11252                                           !BCC_EOS
11253                                           ! 2180       *(((Bit8u *)&lcount)+1) = inb(iobase1 + 5);
11254                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$24-8] (used reg = )
11255 301C           8B46         FA            mov	ax,-6[bp]
11256                                           ! Debug: list unsigned int = ax+5 (used reg = )
11257 301F           05                   0005  add	ax,*5
11258 3022           50                         push	ax
11259                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11260 3023           E8         D4D2            call	_inb
11261 3026           44                         inc	sp
11262 3027           44                         inc	sp
11263                                           ! Debug: eq unsigned char = al+0 to unsigned char lcount = [S+$24-$B] (used reg = )
11264 3028           8846         F7            mov	-9[bp],al
11265                                           !BCC_EOS
11266                                           ! 2181       if(header>lcount) {
11267                                           ! Debug: gt unsigned short lcount = [S+$24-$C] to unsigned short header = [S+$24+$A] (used reg = )
11268 302B           8B46         0C            mov	ax,$C[bp]
11269 302E           3B46         F6            cmp	ax,-$A[bp]
11270 3031           76           16            jbe 	.2B6
11271                       00003033            .2B7:
11272                                           ! 2182          lbefore=lcount;
11273                                           ! Debug: eq unsigned short lcount = [S+$24-$C] to unsigned short lbefore = [S+$24-$E] (used reg = )
11274 3033           8B46         F6            mov	ax,-$A[bp]
11275 3036           8946         F4            mov	-$C[bp],ax
11276                                           !BCC_EOS
11277                                           ! 2183          header-=lcount;
11278                                           ! Debug: subab unsigned short lcount = [S+$24-$C] to unsigned short header = [S+$24+$A] (used reg = )
11279 3039           8B46         0C            mov	ax,$C[bp]
11280 303C           2B46         F6            sub	ax,-$A[bp]
11281 303F           8946         0C            mov	$C[bp],ax
11282                                           !BCC_EOS
11283                                           ! 2184          lcount=0;
11284                                           ! Debug: eq int = const 0 to unsigned short lcount = [S+$24-$C] (used reg = )
11285 3042           31C0                       xor	ax,ax
11286 3044           8946         F6            mov	-$A[bp],ax
11287                                           !BCC_EOS
11288                                           ! 2185       }
11289                                           ! 2186       else {
11290 3047           EB           14            jmp .2B8
11291                       00003049            .2B6:
11292                                           ! 2187         lbefore=header;
11293                                           ! Debug: eq unsigned short header = [S+$24+$A] to unsigned short lbefore = [S+$24-$E] (used reg = )
11294 3049           8B46         0C            mov	ax,$C[bp]
11295 304C           8946         F4            mov	-$C[bp],ax
11296                                           !BCC_EOS
11297                                           ! 2188         header=0;
11298                                           ! Debug: eq int = const 0 to unsigned short header = [S+$24+$A] (used reg = )
11299 304F           31C0                       xor	ax,ax
11300 3051           8946         0C            mov	$C[bp],ax
11301                                           !BCC_EOS
11302                                           ! 2189         lcount-=lbefore;
11303                                           ! Debug: subab unsigned short lbefore = [S+$24-$E] to unsigned short lcount = [S+$24-$C] (used reg = )
11304 3054           8B46         F6            mov	ax,-$A[bp]
11305 3057           2B46         F4            sub	ax,-$C[bp]
11306 305A           8946         F6            mov	-$A[bp],ax
11307                                           !BCC_EOS
11308                                           ! 2190       }
11309                                           ! 2191       if(lcount>length) {
11310                       0000305D            .2B8:
11311                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$24-$C] (used reg = )
11312 305D           8B46         F6            mov	ax,-$A[bp]
11313 3060           31DB                       xor	bx,bx
11314                                           ! Debug: gt unsigned long length = [S+$24+$C] to unsigned long = bx+0 (used reg = )
11315 3062           8D7E         0E            lea	di,$E[bp]
11316 3065           E8         D034            call	lcmpul
11317 3068           76           20            jbe 	.2B9
11318                       0000306A            .2BA:
11319                                           ! 2192         lafter=lcount-length;
11320                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$24-$C] (used reg = )
11321 306A           8B46         F6            mov	ax,-$A[bp]
11322 306D           31DB                       xor	bx,bx
11323                                           ! Debug: sub unsigned long length = [S+$24+$C] to unsigned long = bx+0 (used reg = )
11324 306F           8D7E         0E            lea	di,$E[bp]
11325 3072           E8         D03D            call	lsubul
11326                                           ! Debug: eq unsigned long = bx+0 to unsigned short lafter = [S+$24-$10] (used reg = )
11327 3075           8946         F2            mov	-$E[bp],ax
11328                                           !BCC_EOS
11329                                           ! 2193         lcount=length;
11330                                           ! Debug: eq unsigned long length = [S+$24+$C] to unsigned short lcount = [S+$24-$C] (used reg = )
11331 3078           8B46         0E            mov	ax,$E[bp]
11332 307B           8946         F6            mov	-$A[bp],ax
11333                                           !BCC_EOS
11334                                           ! 2194         length=0;
11335                                           ! Debug: eq int = const 0 to unsigned long length = [S+$24+$C] (used reg = )
11336 307E           31C0                       xor	ax,ax
11337 3080           31DB                       xor	bx,bx
11338 3082           8946         0E            mov	$E[bp],ax
11339 3085           895E         10            mov	$10[bp],bx
11340                                           !BCC_EOS
11341                                           ! 2195       }
11342                                           ! 2196       else {
11343 3088           EB           21            jmp .2BB
11344                       0000308A            .2B9:
11345                                           ! 2197         lafter=0;
11346                                           ! Debug: eq int = const 0 to unsigned short lafter = [S+$24-$10] (used reg = )
11347 308A           31C0                       xor	ax,ax
11348 308C           8946         F2            mov	-$E[bp],ax
11349                                           !BCC_EOS
11350                                           ! 2198         length-=lcount;
11351                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$24-$C] (used reg = )
11352 308F           8B46         F6            mov	ax,-$A[bp]
11353 3092           31DB                       xor	bx,bx
11354                                           ! Debug: subab unsigned long = bx+0 to unsigned long length = [S+$24+$C] (used reg = )
11355 3094           53                         push	bx
11356 3095           50                         push	ax
11357 3096           8B46         0E            mov	ax,$E[bp]
11358 3099           8B5E         10            mov	bx,$10[bp]
11359 309C           8D7E         DA            lea	di,-$26[bp]
11360 309F           E8         D010            call	lsubul
11361 30A2           8946         0E            mov	$E[bp],ax
11362 30A5           895E         10            mov	$10[bp],bx
11363 30A8           83C4                   04  add	sp,*4
11364                                           !BCC_EOS
11365                                           ! 2199       }
11366                                           ! 2200       count = lcount;
11367                       000030AB            .2BB:
11368                                           ! Debug: eq unsigned short lcount = [S+$24-$C] to unsigned short count = [S+$24-$12] (used reg = )
11369 30AB           8B46         F6            mov	ax,-$A[bp]
11370 30AE           8946         F0            mov	-$10[bp],ax
11371                                           !BCC_EOS
11372                                           ! 2201       ;
11373                                           !BCC_EOS
11374                                           ! 2202       ;
11375                                           !BCC_EOS
11376                                           ! 2203       lmode = mode;
11377                                           ! Debug: eq unsigned char mode = [S+$24-$16] to unsigned char lmode = [S+$24-$17] (used reg = )
11378 30B1           8A46         EC            mov	al,-$14[bp]
11379 30B4           8846         EB            mov	-$15[bp],al
11380                                           !BCC_EOS
11381                                           ! 2204       if (lbefore & 0x03) lmode=0x00;
11382                                           ! Debug: and int = const 3 to unsigned short lbefore = [S+$24-$E] (used reg = )
11383 30B7           8A46         F4            mov	al,-$C[bp]
11384 30BA           24                     03  and	al,*3
11385 30BC           84C0                       test	al,al
11386 30BE           74           05            je  	.2BC
11387                       000030C0            .2BD:
11388                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$24-$17] (used reg = )
11389 30C0           30C0                       xor	al,al
11390 30C2           8846         EB            mov	-$15[bp],al
11391                                           !BCC_EOS
11392                                           ! 2205       if (lcount & 0x03) lmode=0x00;
11393                       000030C5            .2BC:
11394                                           ! Debug: and int = const 3 to unsigned short lcount = [S+$24-$C] (used reg = )
11395 30C5           8A46         F6            mov	al,-$A[bp]
11396 30C8           24                     03  and	al,*3
11397 30CA           84C0                       test	al,al
11398 30CC           74           05            je  	.2BE
11399                       000030CE            .2BF:
11400                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$24-$17] (used reg = )
11401 30CE           30C0                       xor	al,al
11402 30D0           8846         EB            mov	-$15[bp],al
11403                                           !BCC_EOS
11404                                           ! 2206       if (lafter & 0x03) lmode=0x00;
11405                       000030D3            .2BE:
11406                                           ! Debug: and int = const 3 to unsigned short lafter = [S+$24-$10] (used reg = )
11407 30D3           8A46         F2            mov	al,-$E[bp]
11408 30D6           24                     03  and	al,*3
11409 30D8           84C0                       test	al,al
11410 30DA           74           05            je  	.2C0
11411                       000030DC            .2C1:
11412                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$24-$17] (used reg = )
11413 30DC           30C0                       xor	al,al
11414 30DE           8846         EB            mov	-$15[bp],al
11415                                           !BCC_EOS
11416                                           ! 2207       if (lcount & 0x01) {
11417                       000030E1            .2C0:
11418                                           ! Debug: and int = const 1 to unsigned short lcount = [S+$24-$C] (used reg = )
11419 30E1           8A46         F6            mov	al,-$A[bp]
11420 30E4           24                     01  and	al,*1
11421 30E6           84C0                       test	al,al
11422 30E8           74           1E            je  	.2C2
11423                       000030EA            .2C3:
11424                                           ! 2208         lcount+=1;
11425                                           ! Debug: addab int = const 1 to unsigned short lcount = [S+$24-$C] (used reg = )
11426 30EA           8B46         F6            mov	ax,-$A[bp]
11427 30ED           40                         inc	ax
11428 30EE           8946         F6            mov	-$A[bp],ax
11429                                           !BCC_EOS
11430                                           ! 2209         if ((lafter > 0) && (lafter & 0x01)) {
11431                                           ! Debug: gt int = const 0 to unsigned short lafter = [S+$24-$10] (used reg = )
11432 30F1           8B46         F2            mov	ax,-$E[bp]
11433 30F4           85C0                       test	ax,ax
11434 30F6           74           10            je  	.2C4
11435                       000030F8            .2C6:
11436                                           ! Debug: and int = const 1 to unsigned short lafter = [S+$24-$10] (used reg = )
11437 30F8           8A46         F2            mov	al,-$E[bp]
11438 30FB           24                     01  and	al,*1
11439 30FD           84C0                       test	al,al
11440 30FF           74           07            je  	.2C4
11441                       00003101            .2C5:
11442                                           ! 2210           lafter-=1;
11443                                           ! Debug: subab int = const 1 to unsigned short lafter = [S+$24-$10] (used reg = )
11444 3101           8B46         F2            mov	ax,-$E[bp]
11445 3104           48                         dec	ax
11446 3105           8946         F2            mov	-$E[bp],ax
11447                                           !BCC_EOS
11448                                           ! 2211         }
11449                                           ! 2212       }
11450                       00003108            .2C4:
11451                                           ! 2213       if (lmode == 0x01) {
11452                       00003108            .2C2:
11453                                           ! Debug: logeq int = const 1 to unsigned char lmode = [S+$24-$17] (used reg = )
11454 3108           8A46         EB            mov	al,-$15[bp]
11455 310B           3C                     01  cmp	al,*1
11456 310D           75           20            jne 	.2C7
11457                       0000310F            .2C8:
11458                                           ! 2214         lcount>>=2; lbefore>>=2; lafter>>=2;
11459                                           ! Debug: srab int = const 2 to unsigned short lcount = [S+$24-$C] (used reg = )
11460 310F           8B46         F6            mov	ax,-$A[bp]
11461 3112           D1E8                       shr	ax,*1
11462 3114           D1E8                       shr	ax,*1
11463 3116           8946         F6            mov	-$A[bp],ax
11464                                           !BCC_EOS
11465                                           ! Debug: srab int = const 2 to unsigned short lbefore = [S+$24-$E] (used reg = )
11466 3119           8B46         F4            mov	ax,-$C[bp]
11467 311C           D1E8                       shr	ax,*1
11468 311E           D1E8                       shr	ax,*1
11469 3120           8946         F4            mov	-$C[bp],ax
11470                                           !BCC_EOS
11471                                           ! Debug: srab int = const 2 to unsigned short lafter = [S+$24-$10] (used reg = )
11472 3123           8B46         F2            mov	ax,-$E[bp]
11473 3126           D1E8                       shr	ax,*1
11474 3128           D1E8                       shr	ax,*1
11475 312A           8946         F2            mov	-$E[bp],ax
11476                                           !BCC_EOS
11477                                           ! 2215       }
11478                                           ! 2216       else {
11479 312D           EB           18            jmp .2C9
11480                       0000312F            .2C7:
11481                                           ! 2217         lcount>>=1; lbefore>>=1; lafter>>=1;
11482                                           ! Debug: srab int = const 1 to unsigned short lcount = [S+$24-$C] (used reg = )
11483 312F           8B46         F6            mov	ax,-$A[bp]
11484 3132           D1E8                       shr	ax,*1
11485 3134           8946         F6            mov	-$A[bp],ax
11486                                           !BCC_EOS
11487                                           ! Debug: srab int = const 1 to unsigned short lbefore = [S+$24-$E] (used reg = )
11488 3137           8B46         F4            mov	ax,-$C[bp]
11489 313A           D1E8                       shr	ax,*1
11490 313C           8946         F4            mov	-$C[bp],ax
11491                                           !BCC_EOS
11492                                           ! Debug: srab int = const 1 to unsigned short lafter = [S+$24-$10] (used reg = )
11493 313F           8B46         F2            mov	ax,-$E[bp]
11494 3142           D1E8                       shr	ax,*1
11495 3144           8946         F2            mov	-$E[bp],ax
11496                                           !BCC_EOS
11497                                           ! 2218       }
11498                                           ! 2219        ;
11499                       00003147            .2C9:
11500                                           !BCC_EOS
11501                                           ! 2220 #asm
11502                                           !BCC_EOS
11503                                           !BCC_ASM
11504                       0000002C            _ata_cmd_packet.cmdoff	set	$2C
11505                       0000000A            .ata_cmd_packet.cmdoff	set	$A
11506                       0000002E            _ata_cmd_packet.header	set	$2E
11507                       0000000C            .ata_cmd_packet.header	set	$C
11508                       00000012            _ata_cmd_packet.count	set	$12
11509                       FFFFFFF0            .ata_cmd_packet.count	set	-$10
11510                       00000014            _ata_cmd_packet.lafter	set	$14
11511                       FFFFFFF2            .ata_cmd_packet.lafter	set	-$E
11512                       0000001C            _ata_cmd_packet.iobase1	set	$1C
11513                       FFFFFFFA            .ata_cmd_packet.iobase1	set	-6
11514                       00000011            _ata_cmd_packet.channel	set	$11
11515                       FFFFFFEF            .ata_cmd_packet.channel	set	-$11
11516                       0000002A            _ata_cmd_packet.cmdseg	set	$2A
11517                       00000008            .ata_cmd_packet.cmdseg	set	8
11518                       00000028            _ata_cmd_packet.cmdlen	set	$28
11519                       00000006            .ata_cmd_packet.cmdlen	set	6
11520                       0000000D            _ata_cmd_packet.lmode	set	$D
11521                       FFFFFFEB            .ata_cmd_packet.lmode	set	-$15
11522                       00000026            _ata_cmd_packet.device	set	$26
11523                       00000004            .ata_cmd_packet.device	set	4
11524                       00000002            _ata_cmd_packet.loops	set	2
11525                       FFFFFFE0            .ata_cmd_packet.loops	set	-$20
11526                       00000020            _ata_cmd_packet.ebda_seg	set	$20
11527                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
11528                       00000018            _ata_cmd_packet.lcount	set	$18
11529                       FFFFFFF6            .ata_cmd_packet.lcount	set	-$A
11530                       00000008            _ata_cmd_packet.total	set	8
11531                       FFFFFFE6            .ata_cmd_packet.total	set	-$1A
11532                       0000000F            _ata_cmd_packet.status	set	$F
11533                       FFFFFFED            .ata_cmd_packet.status	set	-$13
11534                       0000000E            _ata_cmd_packet.mode	set	$E
11535                       FFFFFFEC            .ata_cmd_packet.mode	set	-$14
11536                       00000038            _ata_cmd_packet.bufoff	set	$38
11537                       00000016            .ata_cmd_packet.bufoff	set	$16
11538                       00000004            _ata_cmd_packet.transfer	set	4
11539                       FFFFFFE2            .ata_cmd_packet.transfer	set	-$1E
11540                       00000001            _ata_cmd_packet.sc	set	1
11541                       FFFFFFDF            .ata_cmd_packet.sc	set	-$21
11542                       0000001A            _ata_cmd_packet.iobase2	set	$1A
11543                       FFFFFFF8            .ata_cmd_packet.iobase2	set	-8
11544                       00000016            _ata_cmd_packet.lbefore	set	$16
11545                       FFFFFFF4            .ata_cmd_packet.lbefore	set	-$C
11546                       00000036            _ata_cmd_packet.bufseg	set	$36
11547                       00000014            .ata_cmd_packet.bufseg	set	$14
11548                       00000010            _ata_cmd_packet.slave	set	$10
11549                       FFFFFFEE            .ata_cmd_packet.slave	set	-$12
11550                       00000034            _ata_cmd_packet.inout	set	$34
11551                       00000012            .ata_cmd_packet.inout	set	$12
11552                       0000001E            _ata_cmd_packet.old_ds	set	$1E
11553                       FFFFFFFC            .ata_cmd_packet.old_ds	set	-4
11554                       00000030            _ata_cmd_packet.length	set	$30
11555                       0000000E            .ata_cmd_packet.length	set	$E
11556 3147           55                                 push bp
11557 3148           89E5                               mov bp, sp
11558 314A           8B56         1E                    mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data read port
11559 314D           8B4E         18                    mov cx, _ata_cmd_packet.lbefore + 2[bp]
11560 3150           E3           15                    jcxz ata_packet_no_before
11561 3152           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
11562 3155           80FC                   01          cmp ah, #0x01
11563 3158           74           05                    je ata_packet_in_before_32
11564                       0000315A            ata_packet_in_before_16:
11565 315A           ED                                 in ax, dx
11566 315B           E2           FD                    loop ata_packet_in_before_16
11567 315D           EB           08                    jmp ata_packet_no_before
11568                       0000315F            ata_packet_in_before_32:
11569 315F     66    50                                 push eax
11570                       00003161            ata_packet_in_before_32_loop:
11571 3161     66    ED                                 in eax, dx
11572 3163           E2           FC                    loop ata_packet_in_before_32_loop
11573 3165     66    58                                 pop eax
11574                       00003167            ata_packet_no_before:
11575 3167           8B4E         1A                    mov cx, _ata_cmd_packet.lcount + 2[bp]
11576 316A           E3           17                    jcxz ata_packet_after
11577 316C           8B7E         3A                    mov di, _ata_cmd_packet.bufoff + 2[bp]
11578 316F           8B46         38                    mov ax, _ata_cmd_packet.bufseg + 2[bp]
11579 3172           8EC0                               mov es, ax
11580 3174           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
11581 3177           80FC                   01          cmp ah, #0x01
11582 317A           74           04                    je ata_packet_in_32
11583                       0000317C            ata_packet_in_16:
11584 317C           F3                                 rep
11585 317D           6D                                   insw ;; CX words transferred to port(DX) to ES:[DI]
11586 317E           EB           03                    jmp ata_packet_after
11587                       00003180            ata_packet_in_32:
11588 3180           F3                                 rep
11589 3181     66    6D                                   insd ;; CX dwords transferred to port(DX) to ES:[DI]
11590                       00003183            ata_packet_after:
11591 3183           8B4E         16                    mov cx, _ata_cmd_packet.lafter + 2[bp]
11592 3186           E3           15                    jcxz ata_packet_done
11593 3188           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
11594 318B           80FC                   01          cmp ah, #0x01
11595 318E           74           05                    je ata_packet_in_after_32
11596                       00003190            ata_packet_in_after_16:
11597 3190           ED                                 in ax, dx
11598 3191           E2           FD                    loop ata_packet_in_after_16
11599 3193           EB           08                    jmp ata_packet_done
11600                       00003195            ata_packet_in_after_32:
11601 3195     66    50                                 push eax
11602                       00003197            ata_packet_in_after_32_loop:
11603 3197     66    ED                                 in eax, dx
11604 3199           E2           FC                    loop ata_packet_in_after_32_loop
11605 319B     66    58                                 pop eax
11606                       0000319D            ata_packet_done:
11607 319D           5D                                 pop bp
11608                                           ! 2273 endasm
11609                                           !BCC_ENDASM
11610                                           !BCC_EOS
11611                                           ! 2274       bufoff += count;
11612                                           ! Debug: addab unsigned short count = [S+$24-$12] to unsigned short bufoff = [S+$24+$14] (used reg = )
11613 319E           8B46         16            mov	ax,$16[bp]
11614 31A1           0346         F0            add	ax,-$10[bp]
11615 31A4           8946         16            mov	$16[bp],ax
11616                                           !BCC_EOS
11617                                           ! 2275       transfer += count;
11618                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$24-$12] (used reg = )
11619 31A7           8B46         F0            mov	ax,-$10[bp]
11620 31AA           31DB                       xor	bx,bx
11621                                           ! Debug: addab unsigned long = bx+0 to unsigned long transfer = [S+$24-$20] (used reg = )
11622 31AC           8D7E         E2            lea	di,-$1E[bp]
11623 31AF           E8         CEE2            call	laddul
11624 31B2           8946         E2            mov	-$1E[bp],ax
11625 31B5           895E         E4            mov	-$1C[bp],bx
11626                                           !BCC_EOS
11627                                           ! 2276       _write_dword(transfer, &((ebda_data_t *) 0)->ata.trsfbytes, ebda_seg);
11628                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
11629 31B8           FF76         FE            push	-2[bp]
11630                                           ! Debug: list * unsigned long = const $256 (used reg = )
11631 31BB           B8                   0256  mov	ax,#$256
11632 31BE           50                         push	ax
11633                                           ! Debug: list unsigned long transfer = [S+$28-$20] (used reg = )
11634 31BF           FF76         E4            push	-$1C[bp]
11635 31C2           FF76         E2            push	-$1E[bp]
11636                                           ! Debug: func () void = _write_dword+0 (used reg = )
11637 31C5           E8         CE9F            call	__write_dword
11638 31C8           83C4                   08  add	sp,*8
11639                                           !BCC_EOS
11640                                           ! 2277     }
11641                                           ! 2278   }
11642                       000031CB            .2AC:
11643 31CB           E9         FD9D            br 	.2AD
11644                       000031CE            .2CA:
11645                       000031CE            .2AB:
11646 31CE           83C4                   04  add	sp,*4
11647                                           ! 2279   if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
11648                       000031D1            .2AA:
11649                                           ! 2280          != 0x40 ) {
11650                                           ! Debug: and int = const $E9 to unsigned char status = [S+$20-$15] (used reg = )
11651 31D1           8A46         ED            mov	al,-$13[bp]
11652 31D4           24                     E9  and	al,#$E9
11653                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
11654 31D6           3C                     40  cmp	al,*$40
11655 31D8           74           07            je  	.2CB
11656                       000031DA            .2CC:
11657                                           ! 2281     ;
11658                                           !BCC_EOS
11659                                           ! 2282     return 4;
11660 31DA           B8                   0004  mov	ax,*4
11661 31DD           89EC                       mov	sp,bp
11662 31DF           5D                         pop	bp
11663 31E0           C3                         ret
11664                                           !BCC_EOS
11665                                           ! 2283   }
11666                                           ! 2284   outb(iobase2+6, 0x08);
11667                       000031E1            .2CB:
11668                                           ! Debug: list int = const 8 (used reg = )
11669 31E1           B8                   0008  mov	ax,*8
11670 31E4           50                         push	ax
11671                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$22-$A] (used reg = )
11672 31E5           8B46         F8            mov	ax,-8[bp]
11673                                           ! Debug: list unsigned int = ax+6 (used reg = )
11674 31E8           05                   0006  add	ax,*6
11675 31EB           50                         push	ax
11676                                           ! Debug: func () void = outb+0 (used reg = )
11677 31EC           E8         D31F            call	_outb
11678 31EF           83C4                   04  add	sp,*4
11679                                           !BCC_EOS
11680                                           ! 2285   return 0;
11681 31F2           31C0                       xor	ax,ax
11682 31F4           89EC                       mov	sp,bp
11683 31F6           5D                         pop	bp
11684 31F7           C3                         ret
11685                                           !BCC_EOS
11686                                           ! 2286 }
11687                                           ! 2287   Bit16u
11688                                           ! Register BX used in function ata_cmd_packet
11689                                           ! 2288 atapi_get_sense(device, seg, asc, ascq)
11690                                           ! 2289   Bit16u device;
11691                                           export	_atapi_get_sense
11692                       000031F8            _atapi_get_sense:
11693                                           !BCC_EOS
11694                                           ! 2290 {
11695                                           ! 2291   Bit8u atacmd[12];
11696                                           !BCC_EOS
11697                                           ! 2292   Bit8u buffer[18];
11698                                           !BCC_EOS
11699                                           ! 2293   Bit8u i;
11700                                           !BCC_EOS
11701                                           ! 2294   _memsetb(0,atacmd,get_SS(),12);
11702 31F8           55                         push	bp
11703 31F9           89E5                       mov	bp,sp
11704 31FB           83C4                   E0  add	sp,*-$20
11705                                           ! Debug: list int = const $C (used reg = )
11706 31FE           B8                   000C  mov	ax,*$C
11707 3201           50                         push	ax
11708                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11709 3202           E8         D45A            call	_get_SS
11710                                           ! Debug: list unsigned short = ax+0 (used reg = )
11711 3205           50                         push	ax
11712                                           ! Debug: list * unsigned char atacmd = S+$26-$E (used reg = )
11713 3206           8D5E         F4            lea	bx,-$C[bp]
11714 3209           53                         push	bx
11715                                           ! Debug: list int = const 0 (used reg = )
11716 320A           31C0                       xor	ax,ax
11717 320C           50                         push	ax
11718                                           ! Debug: func () void = _memsetb+0 (used reg = )
11719 320D           E8         CDF0            call	__memsetb
11720 3210           83C4                   08  add	sp,*8
11721                                           !BCC_EOS
11722                                           ! 2295   atacmd[0]=0x03;
11723                                           ! Debug: eq int = const 3 to unsigned char atacmd = [S+$22-$E] (used reg = )
11724 3213           B0                     03  mov	al,*3
11725 3215           8846         F4            mov	-$C[bp],al
11726                                           !BCC_EOS
11727                                           ! 2296   atacmd[4]=sizeof(buffer);
11728                                           ! Debug: eq int = const $12 to unsigned char atacmd = [S+$22-$A] (used reg = )
11729 3218           B0                     12  mov	al,*$12
11730 321A           8846         F8            mov	-8[bp],al
11731                                           !BCC_EOS
11732                                           ! 2297   if (ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 18L, 0x01, get_SS(), buffer) != 0)
11733                                           ! Debug: list * unsigned char buffer = S+$22-$20 (used reg = )
11734 321D           8D5E         E2            lea	bx,-$1E[bp]
11735 3220           53                         push	bx
11736                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11737 3221           E8         D43B            call	_get_SS
11738                                           ! Debug: list unsigned short = ax+0 (used reg = )
11739 3224           50                         push	ax
11740                                           ! Debug: list int = const 1 (used reg = )
11741 3225           B8                   0001  mov	ax,*1
11742 3228           50                         push	ax
11743                                           ! Debug: list long = const $12 (used reg = )
11744 3229           B8                   0012  mov	ax,*$12
11745 322C           31DB                       xor	bx,bx
11746 322E           53                         push	bx
11747 322F           50                         push	ax
11748                                           ! Debug: list int = const 0 (used reg = )
11749 3230           31C0                       xor	ax,ax
11750 3232           50                         push	ax
11751                                           ! Debug: list * unsigned char atacmd = S+$2E-$E (used reg = )
11752 3233           8D5E         F4            lea	bx,-$C[bp]
11753 3236           53                         push	bx
11754                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11755 3237           E8         D425            call	_get_SS
11756                                           ! Debug: list unsigned short = ax+0 (used reg = )
11757 323A           50                         push	ax
11758                                           ! Debug: list int = const $C (used reg = )
11759 323B           B8                   000C  mov	ax,*$C
11760 323E           50                         push	ax
11761                                           ! Debug: list unsigned short device = [S+$34+2] (used reg = )
11762 323F           FF76         04            push	4[bp]
11763                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
11764 3242           E8         FB09            call	_ata_cmd_packet
11765 3245           83C4                   14  add	sp,*$14
11766                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
11767 3248           85C0                       test	ax,ax
11768 324A           74           07            je  	.2CD
11769                       0000324C            .2CE:
11770                                           ! 2298     return 0x0002;
11771 324C           B8                   0002  mov	ax,*2
11772 324F           89EC                       mov	sp,bp
11773 3251           5D                         pop	bp
11774 3252           C3                         ret
11775                                           !BCC_EOS
11776                                           ! 2299   _write_byte(buffer[12], asc, seg);
11777                       00003253            .2CD:
11778                                           ! Debug: list int seg = [S+$22+4] (used reg = )
11779 3253           FF76         06            push	6[bp]
11780                                           ! Debug: list int asc = [S+$24+6] (used reg = )
11781 3256           FF76         08            push	8[bp]
11782                                           ! Debug: list unsigned char buffer = [S+$26-$14] (used reg = )
11783 3259           8A46         EE            mov	al,-$12[bp]
11784 325C           30E4                       xor	ah,ah
11785 325E           50                         push	ax
11786                                           ! Debug: func () void = _write_byte+0 (used reg = )
11787 325F           E8         D39E            call	__write_byte
11788 3262           83C4                   06  add	sp,*6
11789                                           !BCC_EOS
11790                                           ! 2300   _write_byte(buffer[13], ascq, seg);
11791                                           ! Debug: list int seg = [S+$22+4] (used reg = )
11792 3265           FF76         06            push	6[bp]
11793                                           ! Debug: list int ascq = [S+$24+8] (used reg = )
11794 3268           FF76         0A            push	$A[bp]
11795                                           ! Debug: list unsigned char buffer = [S+$26-$13] (used reg = )
11796 326B           8A46         EF            mov	al,-$11[bp]
11797 326E           30E4                       xor	ah,ah
11798 3270           50                         push	ax
11799                                           ! Debug: func () void = _write_byte+0 (used reg = )
11800 3271           E8         D38C            call	__write_byte
11801 3274           83C4                   06  add	sp,*6
11802                                           !BCC_EOS
11803                                           ! 2301   return 0;
11804 3277           31C0                       xor	ax,ax
11805 3279           89EC                       mov	sp,bp
11806 327B           5D                         pop	bp
11807 327C           C3                         ret
11808                                           !BCC_EOS
11809                                           ! 2302 }
11810                                           ! 2303   Bit16u
11811                                           ! Register BX used in function atapi_get_sense
11812                                           ! 2304 atapi_is_ready(device)
11813                                           ! 2305   Bit16u device;
11814                                           export	_atapi_is_ready
11815                       0000327D            _atapi_is_ready:
11816                                           !BCC_EOS
11817                                           ! 2306 {
11818                                           ! 2307   Bit8u packet[12];
11819                                           !BCC_EOS
11820                                           ! 2308   Bit8u buf[8];
11821                                           !BCC_EOS
11822                                           ! 2309   Bit32u block_len;
11823                                           !BCC_EOS
11824                                           ! 2310   Bit32u sectors;
11825                                           !BCC_EOS
11826                                           ! 2311   Bit32u timeout;
11827                                           !BCC_EOS
11828                                           ! 2312   Bit32u time;
11829                                           !BCC_EOS
11830                                           ! 2313   Bit8u asc, ascq;
11831                                           !BCC_EOS
11832                                           ! 2314   Bit8u in_progress;
11833                                           !BCC_EOS
11834                                           ! 2315   Bit16u ebda_seg = get_ebda_seg()
11835 327D           55                         push	bp
11836 327E           89E5                       mov	bp,sp
11837 3280           83C4                   D6  add	sp,*-$2A
11838                                           ! 2315 ;
11839                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
11840 3283           E8         D3E6            call	_get_ebda_seg
11841                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
11842 3286           8946         D6            mov	-$2A[bp],ax
11843                                           !BCC_EOS
11844                                           ! 2316   if (_read_byte(&((ebda_data_t *) 0)->ata.devices[device].type, ebda_seg) != 0x03) {
11845                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
11846 3289           FF76         D6            push	-$2A[bp]
11847                                           ! Debug: ptradd unsigned short device = [S+$2E+2] to [8] struct  = const $142 (used reg = )
11848 328C           8B46         04            mov	ax,4[bp]
11849 328F           B9                   001E  mov	cx,*$1E
11850 3292           F7E9                       imul	cx
11851 3294           89C3                       mov	bx,ax
11852                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
11853                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
11854 3296           81C3                 0142  add	bx,#$142
11855 329A           53                         push	bx
11856                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
11857 329B           E8         D346            call	__read_byte
11858 329E           83C4                   04  add	sp,*4
11859                                           ! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
11860 32A1           3C                     03  cmp	al,*3
11861 32A3           74           15            je  	.2CF
11862                       000032A5            .2D0:
11863                                           ! 2317     bios_printf(2, "not implemented for non-ATAPI device\n");
11864                                           ! Debug: list * char = .2D1+0 (used reg = )
11865 32A5           BB                   D62A  mov	bx,#.2D1
11866 32A8           53                         push	bx
11867                                           ! Debug: list int = const 2 (used reg = )
11868 32A9           B8                   0002  mov	ax,*2
11869 32AC           50                         push	ax
11870                                           ! Debug: func () void = bios_printf+0 (used reg = )
11871 32AD           E8         D68E            call	_bios_printf
11872 32B0           83C4                   04  add	sp,*4
11873                                           !BCC_EOS
11874                                           ! 2318     return -1;
11875 32B3           B8                   FFFF  mov	ax,#$FFFF
11876 32B6           89EC                       mov	sp,bp
11877 32B8           5D                         pop	bp
11878 32B9           C3                         ret
11879                                           !BCC_EOS
11880                                           ! 2319   }
11881                                           ! 2320   ;
11882                       000032BA            .2CF:
11883                                           !BCC_EOS
11884                                           ! 2321   _memsetb(0,packet,get_SS(),sizeof packet);
11885                                           ! Debug: list int = const $C (used reg = )
11886 32BA           B8                   000C  mov	ax,*$C
11887 32BD           50                         push	ax
11888                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11889 32BE           E8         D39E            call	_get_SS
11890                                           ! Debug: list unsigned short = ax+0 (used reg = )
11891 32C1           50                         push	ax
11892                                           ! Debug: list * unsigned char packet = S+$30-$E (used reg = )
11893 32C2           8D5E         F4            lea	bx,-$C[bp]
11894 32C5           53                         push	bx
11895                                           ! Debug: list int = const 0 (used reg = )
11896 32C6           31C0                       xor	ax,ax
11897 32C8           50                         push	ax
11898                                           ! Debug: func () void = _memsetb+0 (used reg = )
11899 32C9           E8         CD34            call	__memsetb
11900 32CC           83C4                   08  add	sp,*8
11901                                           !BCC_EOS
11902                                           ! 2322   packet[0] = 0x25;
11903                                           ! Debug: eq int = const $25 to unsigned char packet = [S+$2C-$E] (used reg = )
11904 32CF           B0                     25  mov	al,*$25
11905 32D1           8846         F4            mov	-$C[bp],al
11906                                           !BCC_EOS
11907                                           ! 2323   timeout = 5000;
11908                                           ! Debug: eq int = const $1388 to unsigned long timeout = [S+$2C-$22] (used reg = )
11909 32D4           B8                   1388  mov	ax,#$1388
11910 32D7           31DB                       xor	bx,bx
11911 32D9           8946         E0            mov	-$20[bp],ax
11912 32DC           895E         E2            mov	-$1E[bp],bx
11913                                           !BCC_EOS
11914                                           ! 2324   time = 0;
11915                                           ! Debug: eq int = const 0 to unsigned long time = [S+$2C-$26] (used reg = )
11916 32DF           31C0                       xor	ax,ax
11917 32E1           31DB                       xor	bx,bx
11918 32E3           8946         DC            mov	-$24[bp],ax
11919 32E6           895E         DE            mov	-$22[bp],bx
11920                                           !BCC_EOS
11921                                           ! 2325   in_progress = 0;
11922                                           ! Debug: eq int = const 0 to unsigned char in_progress = [S+$2C-$29] (used reg = )
11923 32E9           30C0                       xor	al,al
11924 32EB           8846         D9            mov	-$27[bp],al
11925                                           !BCC_EOS
11926                                           ! 2326   while (time < timeout) {
11927 32EE           E9         00AB            br 	.2D3
11928                       000032F1            .2D4:
11929                                           ! 2327     if (ata_cmd_packet(device, sizeof(packet), get_SS(), packet, 0, 8L, 0x01, get_SS(), buf) == 0)
11930                                           ! Debug: list * unsigned char buf = S+$2C-$16 (used reg = )
11931 32F1           8D5E         EC            lea	bx,-$14[bp]
11932 32F4           53                         push	bx
11933                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11934 32F5           E8         D367            call	_get_SS
11935                                           ! Debug: list unsigned short = ax+0 (used reg = )
11936 32F8           50                         push	ax
11937                                           ! Debug: list int = const 1 (used reg = )
11938 32F9           B8                   0001  mov	ax,*1
11939 32FC           50                         push	ax
11940                                           ! Debug: list long = const 8 (used reg = )
11941 32FD           B8                   0008  mov	ax,*8
11942 3300           31DB                       xor	bx,bx
11943 3302           53                         push	bx
11944 3303           50                         push	ax
11945                                           ! Debug: list int = const 0 (used reg = )
11946 3304           31C0                       xor	ax,ax
11947 3306           50                         push	ax
11948                                           ! Debug: list * unsigned char packet = S+$38-$E (used reg = )
11949 3307           8D5E         F4            lea	bx,-$C[bp]
11950 330A           53                         push	bx
11951                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11952 330B           E8         D351            call	_get_SS
11953                                           ! Debug: list unsigned short = ax+0 (used reg = )
11954 330E           50                         push	ax
11955                                           ! Debug: list int = const $C (used reg = )
11956 330F           B8                   000C  mov	ax,*$C
11957 3312           50                         push	ax
11958                                           ! Debug: list unsigned short device = [S+$3E+2] (used reg = )
11959 3313           FF76         04            push	4[bp]
11960                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
11961 3316           E8         FA35            call	_ata_cmd_packet
11962 3319           83C4                   14  add	sp,*$14
11963                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
11964 331C           85C0                       test	ax,ax
11965 331E           75           06            jne 	.2D5
11966                       00003320            .2D6:
11967                                           ! 2328       goto ok;
11968 3320           83C4                   00  add	sp,#..FFFA+$2C
11969 3323           E9         008D            br 	.FFFA
11970                                           !BCC_EOS
11971                                           ! 2329     if (atapi_get_sense(device, get_SS(), &asc, &ascq) == 0) {
11972                       00003326            .2D5:
11973                                           ! Debug: list * unsigned char ascq = S+$2C-$28 (used reg = )
11974 3326           8D5E         DA            lea	bx,-$26[bp]
11975 3329           53                         push	bx
11976                                           ! Debug: list * unsigned char asc = S+$2E-$27 (used reg = )
11977 332A           8D5E         DB            lea	bx,-$25[bp]
11978 332D           53                         push	bx
11979                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11980 332E           E8         D32E            call	_get_SS
11981                                           ! Debug: list unsigned short = ax+0 (used reg = )
11982 3331           50                         push	ax
11983                                           ! Debug: list unsigned short device = [S+$32+2] (used reg = )
11984 3332           FF76         04            push	4[bp]
11985                                           ! Debug: func () unsigned short = atapi_get_sense+0 (used reg = )
11986 3335           E8         FEC0            call	_atapi_get_sense
11987 3338           83C4                   08  add	sp,*8
11988                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
11989 333B           85C0                       test	ax,ax
11990 333D           75           41            jne 	.2D7
11991                       0000333F            .2D8:
11992                                           ! 2330       if (asc == 0x3a) {
11993                                           ! Debug: logeq int = const $3A to unsigned char asc = [S+$2C-$27] (used reg = )
11994 333F           8A46         DB            mov	al,-$25[bp]
11995 3342           3C                     3A  cmp	al,*$3A
11996 3344           75           07            jne 	.2D9
11997                       00003346            .2DA:
11998                                           ! 2331         ;
11999                                           !BCC_EOS
12000                                           ! 2332         return -1;
12001 3346           B8                   FFFF  mov	ax,#$FFFF
12002 3349           89EC                       mov	sp,bp
12003 334B           5D                         pop	bp
12004 334C           C3                         ret
12005                                           !BCC_EOS
12006                                           ! 2333       }
12007                                           ! 2334       if (asc == 0x04 && ascq == 0x01 && !in_progress) {
12008                       0000334D            .2D9:
12009                                           ! Debug: logeq int = const 4 to unsigned char asc = [S+$2C-$27] (used reg = )
12010 334D           8A46         DB            mov	al,-$25[bp]
12011 3350           3C                     04  cmp	al,*4
12012 3352           75           2C            jne 	.2DB
12013                       00003354            .2DE:
12014                                           ! Debug: logeq int = const 1 to unsigned char ascq = [S+$2C-$28] (used reg = )
12015 3354           8A46         DA            mov	al,-$26[bp]
12016 3357           3C                     01  cmp	al,*1
12017 3359           75           25            jne 	.2DB
12018                       0000335B            .2DD:
12019 335B           8A46         D9            mov	al,-$27[bp]
12020 335E           84C0                       test	al,al
12021 3360           75           1E            jne 	.2DB
12022                       00003362            .2DC:
12023                                           ! 2335         bios_printf(2, "Waiting for device to detect medium... ");
12024                                           ! Debug: list * char = .2DF+0 (used reg = )
12025 3362           BB                   D602  mov	bx,#.2DF
12026 3365           53                         push	bx
12027                                           ! Debug: list int = const 2 (used reg = )
12028 3366           B8                   0002  mov	ax,*2
12029 3369           50                         push	ax
12030                                           ! Debug: func () void = bios_printf+0 (used reg = )
12031 336A           E8         D5D1            call	_bios_printf
12032 336D           83C4                   04  add	sp,*4
12033                                           !BCC_EOS
12034                                           ! 2336         timeout = 30000;
12035                                           ! Debug: eq int = const $7530 to unsigned long timeout = [S+$2C-$22] (used reg = )
12036 3370           B8                   7530  mov	ax,#$7530
12037 3373           31DB                       xor	bx,bx
12038 3375           8946         E0            mov	-$20[bp],ax
12039 3378           895E         E2            mov	-$1E[bp],bx
12040                                           !BCC_EOS
12041                                           ! 2337         in_progress = 1;
12042                                           ! Debug: eq int = const 1 to unsigned char in_progress = [S+$2C-$29] (used reg = )
12043 337B           B0                     01  mov	al,*1
12044 337D           8846         D9            mov	-$27[bp],al
12045                                           !BCC_EOS
12046                                           ! 2338       }
12047                                           ! 2339     }
12048                       00003380            .2DB:
12049                                           ! 2340     time += 100;
12050                       00003380            .2D7:
12051                                           ! Debug: addab unsigned long = const $64 to unsigned long time = [S+$2C-$26] (used reg = )
12052 3380           B8                   0064  mov	ax,*$64
12053 3383           31DB                       xor	bx,bx
12054 3385           53                         push	bx
12055 3386           50                         push	ax
12056 3387           8B46         DC            mov	ax,-$24[bp]
12057 338A           8B5E         DE            mov	bx,-$22[bp]
12058 338D           8D7E         D2            lea	di,-$2E[bp]
12059 3390           E8         CD01            call	laddul
12060 3393           8946         DC            mov	-$24[bp],ax
12061 3396           895E         DE            mov	-$22[bp],bx
12062 3399           83C4                   04  add	sp,*4
12063                                           !BCC_EOS
12064                                           ! 2341   }
12065                                           ! 2342   ;
12066                       0000339C            .2D3:
12067                                           ! Debug: lt unsigned long timeout = [S+$2C-$22] to unsigned long time = [S+$2C-$26] (used reg = )
12068 339C           8B46         E0            mov	ax,-$20[bp]
12069 339F           8B5E         E2            mov	bx,-$1E[bp]
12070 33A2           8D7E         DC            lea	di,-$24[bp]
12071 33A5           E8         CCF4            call	lcmpul
12072 33A8         0F87         FF45            bhi 	.2D4
12073                       000033AC            .2E0:
12074                       000033AC            .2D2:
12075                                           !BCC_EOS
12076                                           ! 2343   return -1;
12077 33AC           B8                   FFFF  mov	ax,#$FFFF
12078 33AF           89EC                       mov	sp,bp
12079 33B1           5D                         pop	bp
12080 33B2           C3                         ret
12081                                           !BCC_EOS
12082                                           ! 2344 ok:
12083                       000033B3            .FFFA:
12084                       FFFFFFD4            ..FFFA	=	-$2C
12085                                           ! 2345   *(((Bit8u *)&*(((Bit16u *)&block_len)+1))+1) = buf[4];
12086                                           ! Debug: eq unsigned char buf = [S+$2C-$12] to unsigned char block_len = [S+$2C-$17] (used reg = )
12087 33B3           8A46         F0            mov	al,-$10[bp]
12088 33B6           8846         EB            mov	-$15[bp],al
12089                                           !BCC_EOS
12090                                           ! 2346   *((Bit8u *)&*(((Bit16u *)&block_len)+1)) = buf[5];
12091                                           ! Debug: eq unsigned char buf = [S+$2C-$11] to unsigned char block_len = [S+$2C-$18] (used reg = )
12092 33B9           8A46         F1            mov	al,-$F[bp]
12093 33BC           8846         EA            mov	-$16[bp],al
12094                                           !BCC_EOS
12095                                           ! 2347   *(((Bit8u *)&*((Bit16u *)&block_len))+1) = buf[6];
12096                                           ! Debug: eq unsigned char buf = [S+$2C-$10] to unsigned char block_len = [S+$2C-$19] (used reg = )
12097 33BF           8A46         F2            mov	al,-$E[bp]
12098 33C2           8846         E9            mov	-$17[bp],al
12099                                           !BCC_EOS
12100                                           ! 2348   *((Bit8u *)&block_len) = buf[7];
12101                                           ! Debug: eq unsigned char buf = [S+$2C-$F] to unsigned char block_len = [S+$2C-$1A] (used reg = )
12102 33C5           8A46         F3            mov	al,-$D[bp]
12103 33C8           8846         E8            mov	-$18[bp],al
12104                                           !BCC_EOS
12105                                           ! 2349   ;
12106                                           !BCC_EOS
12107                                           ! 2350   if (block_len!= 2048 && block_len!= 512)
12108                                           ! Debug: ne unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
12109                                           ! Debug: expression subtree swapping
12110 33CB           B8                   0800  mov	ax,#$800
12111 33CE           31DB                       xor	bx,bx
12112 33D0           53                         push	bx
12113 33D1           50                         push	ax
12114 33D2           8B46         E8            mov	ax,-$18[bp]
12115 33D5           8B5E         EA            mov	bx,-$16[bp]
12116 33D8           8D7E         D2            lea	di,-$2E[bp]
12117 33DB           E8         CCBE            call	lcmpul
12118 33DE           8D66         D6            lea	sp,-$2A[bp]
12119 33E1           74           33            je  	.2E1
12120                       000033E3            .2E3:
12121                                           ! Debug: ne unsigned long = const $200 to unsigned long block_len = [S+$2C-$1A] (used reg = )
12122                                           ! Debug: expression subtree swapping
12123 33E3           B8                   0200  mov	ax,#$200
12124 33E6           31DB                       xor	bx,bx
12125 33E8           53                         push	bx
12126 33E9           50                         push	ax
12127 33EA           8B46         E8            mov	ax,-$18[bp]
12128 33ED           8B5E         EA            mov	bx,-$16[bp]
12129 33F0           8D7E         D2            lea	di,-$2E[bp]
12130 33F3           E8         CCA6            call	lcmpul
12131 33F6           8D66         D6            lea	sp,-$2A[bp]
12132 33F9           74           1B            je  	.2E1
12133                       000033FB            .2E2:
12134                                           ! 2351   {
12135                                           ! 2352     bios_printf(2, "Unsupported sector size %u\n", block_len);
12136                                           ! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
12137 33FB           FF76         EA            push	-$16[bp]
12138 33FE           FF76         E8            push	-$18[bp]
12139                                           ! Debug: list * char = .2E4+0 (used reg = )
12140 3401           BB                   D5E6  mov	bx,#.2E4
12141 3404           53                         push	bx
12142                                           ! Debug: list int = const 2 (used reg = )
12143 3405           B8                   0002  mov	ax,*2
12144 3408           50                         push	ax
12145                                           ! Debug: func () void = bios_printf+0 (used reg = )
12146 3409           E8         D532            call	_bios_printf
12147 340C           83C4                   08  add	sp,*8
12148                                           !BCC_EOS
12149                                           ! 2353     return -1;
12150 340F           B8                   FFFF  mov	ax,#$FFFF
12151 3412           89EC                       mov	sp,bp
12152 3414           5D                         pop	bp
12153 3415           C3                         ret
12154                                           !BCC_EOS
12155                                           ! 2354   }
12156                                           ! 2355   _write_dword(block_len, &((ebda_data_t *) 0)->ata.devices[device].blksize, ebda_seg);
12157                       00003416            .2E1:
12158                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
12159 3416           FF76         D6            push	-$2A[bp]
12160                                           ! Debug: ptradd unsigned short device = [S+$2E+2] to [8] struct  = const $142 (used reg = )
12161 3419           8B46         04            mov	ax,4[bp]
12162 341C           B9                   001E  mov	cx,*$1E
12163 341F           F7E9                       imul	cx
12164 3421           89C3                       mov	bx,ax
12165                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
12166                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
12167 3423           81C3                 0148  add	bx,#$148
12168 3427           53                         push	bx
12169                                           ! Debug: list unsigned long block_len = [S+$30-$1A] (used reg = )
12170 3428           FF76         EA            push	-$16[bp]
12171 342B           FF76         E8            push	-$18[bp]
12172                                           ! Debug: func () void = _write_dword+0 (used reg = )
12173 342E           E8         CC36            call	__write_dword
12174 3431           83C4                   08  add	sp,*8
12175                                           !BCC_EOS
12176                                           ! 2356   *(((Bit8u *)&*(((Bit16u *)&sectors)+1))+1) = buf[0];
12177                                           ! Debug: eq unsigned char buf = [S+$2C-$16] to unsigned char sectors = [S+$2C-$1B] (used reg = )
12178 3434           8A46         EC            mov	al,-$14[bp]
12179 3437           8846         E7            mov	-$19[bp],al
12180                                           !BCC_EOS
12181                                           ! 2357   *((Bit8u *)&*(((Bit16u *)&sectors)+1)) = buf[1];
12182                                           ! Debug: eq unsigned char buf = [S+$2C-$15] to unsigned char sectors = [S+$2C-$1C] (used reg = )
12183 343A           8A46         ED            mov	al,-$13[bp]
12184 343D           8846         E6            mov	-$1A[bp],al
12185                                           !BCC_EOS
12186                                           ! 2358   *(((Bit8u *)&*((Bit16u *)&sectors))+1) = buf[2];
12187                                           ! Debug: eq unsigned char buf = [S+$2C-$14] to unsigned char sectors = [S+$2C-$1D] (used reg = )
12188 3440           8A46         EE            mov	al,-$12[bp]
12189 3443           8846         E5            mov	-$1B[bp],al
12190                                           !BCC_EOS
12191                                           ! 2359   *((Bit8u *)&sectors) = buf[3];
12192                                           ! Debug: eq unsigned char buf = [S+$2C-$13] to unsigned char sectors = [S+$2C-$1E] (used reg = )
12193 3446           8A46         EF            mov	al,-$11[bp]
12194 3449           8846         E4            mov	-$1C[bp],al
12195                                           !BCC_EOS
12196                                           ! 2360   ;
12197                                           !BCC_EOS
12198                                           ! 2361   if (block_len == 2048)
12199                                           ! Debug: logeq unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
12200                                           ! Debug: expression subtree swapping
12201 344C           B8                   0800  mov	ax,#$800
12202 344F           31DB                       xor	bx,bx
12203 3451           53                         push	bx
12204 3452           50                         push	ax
12205 3453           8B46         E8            mov	ax,-$18[bp]
12206 3456           8B5E         EA            mov	bx,-$16[bp]
12207 3459           8D7E         D2            lea	di,-$2E[bp]
12208 345C           E8         CC3D            call	lcmpul
12209 345F           8D66         D6            lea	sp,-$2A[bp]
12210 3462           75           12            jne 	.2E5
12211                       00003464            .2E6:
12212                                           ! 2362     sectors <<= 2;
12213                                           ! Debug: slab int = const 2 to unsigned long sectors = [S+$2C-$1E] (used reg = )
12214 3464           8B46         E4            mov	ax,-$1C[bp]
12215 3467           8B5E         E6            mov	bx,-$1A[bp]
12216 346A           BF                   0002  mov	di,*2
12217 346D           E8         CCA8            call	lslul
12218 3470           8946         E4            mov	-$1C[bp],ax
12219 3473           895E         E6            mov	-$1A[bp],bx
12220                                           !BCC_EOS
12221                                           ! 2363   if (sectors != _read_dword(&((ebda_data_t *) 0)->ata.devices[device].sectors_low, ebda_seg))
12222                       00003476            .2E5:
12223                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
12224 3476           FF76         D6            push	-$2A[bp]
12225                                           ! Debug: ptradd unsigned short device = [S+$2E+2] to [8] struct  = const $142 (used reg = )
12226 3479           8B46         04            mov	ax,4[bp]
12227 347C           B9                   001E  mov	cx,*$1E
12228 347F           F7E9                       imul	cx
12229 3481           89C3                       mov	bx,ax
12230                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
12231                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
12232 3483           81C3                 0158  add	bx,#$158
12233 3487           53                         push	bx
12234                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
12235 3488           E8         CBCB            call	__read_dword
12236 348B           89D3                       mov	bx,dx
12237 348D           83C4                   04  add	sp,*4
12238                                           ! Debug: ne unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
12239                                           ! Debug: expression subtree swapping
12240 3490           8D7E         E4            lea	di,-$1C[bp]
12241 3493           E8         CC06            call	lcmpul
12242 3496           74           24            je  	.2E7
12243                       00003498            .2E8:
12244                                           ! 2364     bios_printf(2, "%dMB medium detected\n", sectors>>(20-9));
12245                                           ! Debug: sr int = const $B to unsigned long sectors = [S+$2C-$1E] (used reg = )
12246 3498           8B46         E4            mov	ax,-$1C[bp]
12247 349B           8B5E         E6            mov	bx,-$1A[bp]
12248 349E           88E0                       mov	al,ah
12249 34A0           88DC                       mov	ah,bl
12250 34A2           88FB                       mov	bl,bh
12251 34A4           28FF                       sub	bh,bh
12252 34A6           BF                   0003  mov	di,*3
12253 34A9           E8         CC4E            call	lsrul
12254                                           ! Debug: list unsigned long = bx+0 (used reg = )
12255 34AC           53                         push	bx
12256 34AD           50                         push	ax
12257                                           ! Debug: list * char = .2E9+0 (used reg = )
12258 34AE           BB                   D5D0  mov	bx,#.2E9
12259 34B1           53                         push	bx
12260                                           ! Debug: list int = const 2 (used reg = )
12261 34B2           B8                   0002  mov	ax,*2
12262 34B5           50                         push	ax
12263                                           ! Debug: func () void = bios_printf+0 (used reg = )
12264 34B6           E8         D485            call	_bios_printf
12265 34B9           83C4                   08  add	sp,*8
12266                                           !BCC_EOS
12267                                           ! 2365   _write_dword(sectors, &((ebda_data_t *) 0)->ata.devices[device].sectors_low, ebda_seg);
12268                       000034BC            .2E7:
12269                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
12270 34BC           FF76         D6            push	-$2A[bp]
12271                                           ! Debug: ptradd unsigned short device = [S+$2E+2] to [8] struct  = const $142 (used reg = )
12272 34BF           8B46         04            mov	ax,4[bp]
12273 34C2           B9                   001E  mov	cx,*$1E
12274 34C5           F7E9                       imul	cx
12275 34C7           89C3                       mov	bx,ax
12276                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
12277                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
12278 34C9           81C3                 0158  add	bx,#$158
12279 34CD           53                         push	bx
12280                                           ! Debug: list unsigned long sectors = [S+$30-$1E] (used reg = )
12281 34CE           FF76         E6            push	-$1A[bp]
12282 34D1           FF76         E4            push	-$1C[bp]
12283                                           ! Debug: func () void = _write_dword+0 (used reg = )
12284 34D4           E8         CB90            call	__write_dword
12285 34D7           83C4                   08  add	sp,*8
12286                                           !BCC_EOS
12287                                           ! 2366   return 0;
12288 34DA           31C0                       xor	ax,ax
12289 34DC           89EC                       mov	sp,bp
12290 34DE           5D                         pop	bp
12291 34DF           C3                         ret
12292                                           !BCC_EOS
12293                                           ! 2367 }
12294                                           ! 2368   Bit16u
12295                                           ! Register BX used in function atapi_is_ready
12296                                           ! 2369 atapi_is_cdrom(device)
12297                                           ! 2370   Bit8u device;
12298                                           export	_atapi_is_cdrom
12299                       000034E0            _atapi_is_cdrom:
12300                                           !BCC_EOS
12301                                           ! 2371 {
12302                                           ! 2372   Bit16u ebda_seg=get_ebda_seg();
12303 34E0           55                         push	bp
12304 34E1           89E5                       mov	bp,sp
12305 34E3           4C                         dec	sp
12306 34E4           4C                         dec	sp
12307                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
12308 34E5           E8         D184            call	_get_ebda_seg
12309                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12310 34E8           8946         FE            mov	-2[bp],ax
12311                                           !BCC_EOS
12312                                           ! 2373   if (device >= (4*2))
12313                                           ! Debug: ge int = const 8 to unsigned char device = [S+4+2] (used reg = )
12314 34EB           8A46         04            mov	al,4[bp]
12315 34EE           3C                     08  cmp	al,*8
12316 34F0           72           06            jb  	.2EA
12317                       000034F2            .2EB:
12318                                           ! 2374     return 0;
12319 34F2           31C0                       xor	ax,ax
12320 34F4           89EC                       mov	sp,bp
12321 34F6           5D                         pop	bp
12322 34F7           C3                         ret
12323                                           !BCC_EOS
12324                                           ! 2375   if (_read_byte(&((ebda_data_t *) 0)->ata.devices[device].type, ebda_seg) != 0x03)
12325                       000034F8            .2EA:
12326                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
12327 34F8           FF76         FE            push	-2[bp]
12328                                           ! Debug: ptradd unsigned char device = [S+6+2] to [8] struct  = const $142 (used reg = )
12329 34FB           8A46         04            mov	al,4[bp]
12330 34FE           30E4                       xor	ah,ah
12331 3500           B9                   001E  mov	cx,*$1E
12332 3503           F7E9                       imul	cx
12333 3505           89C3                       mov	bx,ax
12334                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
12335                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
12336 3507           81C3                 0142  add	bx,#$142
12337 350B           53                         push	bx
12338                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12339 350C           E8         D0D5            call	__read_byte
12340 350F           83C4                   04  add	sp,*4
12341                                           ! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
12342 3512           3C                     03  cmp	al,*3
12343 3514           74           06            je  	.2EC
12344                       00003516            .2ED:
12345                                           ! 2376     return 0;
12346 3516           31C0                       xor	ax,ax
12347 3518           89EC                       mov	sp,bp
12348 351A           5D                         pop	bp
12349 351B           C3                         ret
12350                                           !BCC_EOS
12351                                           ! 2377   if (_read_byte(&((ebda_data_t *) 0)->ata.devices[device].device, ebda_seg) != 0x05)
12352                       0000351C            .2EC:
12353                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
12354 351C           FF76         FE            push	-2[bp]
12355                                           ! Debug: ptradd unsigned char device = [S+6+2] to [8] struct  = const $142 (used reg = )
12356 351F           8A46         04            mov	al,4[bp]
12357 3522           30E4                       xor	ah,ah
12358 3524           B9                   001E  mov	cx,*$1E
12359 3527           F7E9                       imul	cx
12360 3529           89C3                       mov	bx,ax
12361                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
12362                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
12363 352B           81C3                 0143  add	bx,#$143
12364 352F           53                         push	bx
12365                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12366 3530           E8         D0B1            call	__read_byte
12367 3533           83C4                   04  add	sp,*4
12368                                           ! Debug: ne int = const 5 to unsigned char = al+0 (used reg = )
12369 3536           3C                     05  cmp	al,*5
12370 3538           74           06            je  	.2EE
12371                       0000353A            .2EF:
12372                                           ! 2378     return 0;
12373 353A           31C0                       xor	ax,ax
12374 353C           89EC                       mov	sp,bp
12375 353E           5D                         pop	bp
12376 353F           C3                         ret
12377                                           !BCC_EOS
12378                                           ! 2379   return 1;
12379                       00003540            .2EE:
12380 3540           B8                   0001  mov	ax,*1
12381 3543           89EC                       mov	sp,bp
12382 3545           5D                         pop	bp
12383 3546           C3                         ret
12384                                           !BCC_EOS
12385                                           ! 2380 }
12386                                           ! 2381   void
12387                                           ! Register BX used in function atapi_is_cdrom
12388                                           ! 2382 cdemu_
12389                                           ! 2382 init()
12390                                           ! 2383 {
12391                                           export	_cdemu_init
12392                       00003547            _cdemu_init:
12393                                           ! 2384   Bit16u ebda_seg=get_ebda_seg();
12394 3547           55                         push	bp
12395 3548           89E5                       mov	bp,sp
12396 354A           4C                         dec	sp
12397 354B           4C                         dec	sp
12398                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
12399 354C           E8         D11D            call	_get_ebda_seg
12400                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12401 354F           8946         FE            mov	-2[bp],ax
12402                                           !BCC_EOS
12403                                           ! 2385   _write_byte(0x00, &((ebda_data_t *) 0)->cdemu.active, ebda_seg);
12404                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
12405 3552           FF76         FE            push	-2[bp]
12406                                           ! Debug: list * unsigned char = const $25A (used reg = )
12407 3555           B8                   025A  mov	ax,#$25A
12408 3558           50                         push	ax
12409                                           ! Debug: list int = const 0 (used reg = )
12410 3559           31C0                       xor	ax,ax
12411 355B           50                         push	ax
12412                                           ! Debug: func () void = _write_byte+0 (used reg = )
12413 355C           E8         D0A1            call	__write_byte
12414 355F           83C4                   06  add	sp,*6
12415                                           !BCC_EOS
12416                                           ! 2386 }
12417 3562           89EC                       mov	sp,bp
12418 3564           5D                         pop	bp
12419 3565           C3                         ret
12420                                           ! 2387   Bit8u
12421                                           ! 2388 cdemu_isactive()
12422                                           ! 2389 {
12423                                           export	_cdemu_isactive
12424                       00003566            _cdemu_isactive:
12425                                           ! 2390   Bit16u ebda_seg=get_ebda_seg();
12426 3566           55                         push	bp
12427 3567           89E5                       mov	bp,sp
12428 3569           4C                         dec	sp
12429 356A           4C                         dec	sp
12430                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
12431 356B           E8         D0FE            call	_get_ebda_seg
12432                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12433 356E           8946         FE            mov	-2[bp],ax
12434                                           !BCC_EOS
12435                                           ! 2391   return(_read_byte(&((ebda_data_t *) 0)->cdemu.active, ebda_seg));
12436                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
12437 3571           FF76         FE            push	-2[bp]
12438                                           ! Debug: list * unsigned char = const $25A (used reg = )
12439 3574           B8                   025A  mov	ax,#$25A
12440 3577           50                         push	ax
12441                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12442 3578           E8         D069            call	__read_byte
12443 357B           83C4                   04  add	sp,*4
12444                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
12445 357E           89EC                       mov	sp,bp
12446 3580           5D                         pop	bp
12447 3581           C3                         ret
12448                                           !BCC_EOS
12449                                           ! 2392 }
12450                                           ! 2393   Bit8u
12451                                           ! 2394 cdemu_emulated_drive()
12452                                           ! 2395 {
12453                                           export	_cdemu_emulated_drive
12454                       00003582            _cdemu_emulated_drive:
12455                                           ! 2396   Bit16u ebda_seg=get_ebda_seg();
12456 3582           55                         push	bp
12457 3583           89E5                       mov	bp,sp
12458 3585           4C                         dec	sp
12459 3586           4C                         dec	sp
12460                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
12461 3587           E8         D0E2            call	_get_ebda_seg
12462                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12463 358A           8946         FE            mov	-2[bp],ax
12464                                           !BCC_EOS
12465                                           ! 2397   return(_read_byte(&((ebda_data_t *) 0)->cdemu.emulated_drive, ebda_seg));
12466                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
12467 358D           FF76         FE            push	-2[bp]
12468                                           ! Debug: list * unsigned char = const $25C (used reg = )
12469 3590           B8                   025C  mov	ax,#$25C
12470 3593           50                         push	ax
12471                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12472 3594           E8         D04D            call	__read_byte
12473 3597           83C4                   04  add	sp,*4
12474                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
12475 359A           89EC                       mov	sp,bp
12476 359C           5D                         pop	bp
12477 359D           C3                         ret
12478                                           !BCC_EOS
12479                                           ! 2398 }
12480                                           ! 2399 static char isotag[6]="CD001";
12481                                           
12482                       0000359E            _isotag:
12483                       0000359E            .2F0:
12484 359E                        43            .ascii	"CD001"
12485 35A3                        00            .byte	0
12486                                           !BCC_EOS
12487                                           ! 2400 static char eltorito[24]="EL TORITO SPECIFICATION";
12488                       000035A4            _eltorito:
12489                       000035A4            .2F1:
12490 35A4                        45            .ascii	"EL TORITO SPECIFICATION"
12491 35BB                        00            .byte	0
12492                                           !BCC_EOS
12493                                           ! 2401   Bit16u
12494                                           ! 2402 cdrom_boot()
12495                                           ! 2403 {
12496                                           
12497                                           export	_cdrom_boot
12498                       000035BC            _cdrom_boot:
12499                                           ! 2404   Bit16u ebda_seg=get_ebda_seg(), old_ds;
12500 35BC           55                         push	bp
12501 35BD           89E5                       mov	bp,sp
12502 35BF           4C                         dec	sp
12503 35C0           4C                         dec	sp
12504                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
12505 35C1           E8         D0A8            call	_get_ebda_seg
12506                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12507 35C4           8946         FE            mov	-2[bp],ax
12508                                           !BCC_EOS
12509                                           ! 2405   Bit8u atacmd[12], buffer[2048];
12510                                           !BCC_EOS
12511                                           ! 2406   Bit32u lba;
12512                                           !BCC_EOS
12513                                           ! 2407   Bit16u boot_segment, nbsectors, i, error;
12514                                           !BCC_EOS
12515                                           ! 2408   Bit8u device;
12516                                           !BCC_EOS
12517                                           ! 2409   for (device=0; device<(4*2);device++) {
12518 35C7           81C4                 F7E4  add	sp,#-$81C
12519                                           ! Debug: eq int = const 0 to unsigned char device = [S+$820-$81F] (used reg = )
12520 35CB           30C0                       xor	al,al
12521 35CD           8886       F7E3            mov	-$81D[bp],al
12522                                           !BCC_EOS
12523                                           !BCC_EOS
12524 35D1           EB           1B            jmp .2F4
12525                       000035D3            .2F5:
12526                                           ! 2410     if (atapi_is_cdrom(device)) break;
12527                                           ! Debug: list unsigned char device = [S+$820-$81F] (used reg = )
12528 35D3           8A86       F7E3            mov	al,-$81D[bp]
12529 35D7           30E4                       xor	ah,ah
12530 35D9           50                         push	ax
12531                                           ! Debug: func () unsigned short = atapi_is_cdrom+0 (used reg = )
12532 35DA           E8         FF03            call	_atapi_is_cdrom
12533 35DD           44                         inc	sp
12534 35DE           44                         inc	sp
12535 35DF           85C0                       test	ax,ax
12536 35E1           74           02            je  	.2F6
12537                       000035E3            .2F7:
12538 35E3           EB           11            jmp .2F2
12539                                           !BCC_EOS
12540                                           ! 2411   }
12541                       000035E5            .2F6:
12542                                           ! 2412   if(device >= (4*2)) return 2;
12543                       000035E5            .2F3:
12544                                           ! Debug: postinc unsigned char device = [S+$820-$81F] (used reg = )
12545 35E5           8A86       F7E3            mov	al,-$81D[bp]
12546 35E9           40                         inc	ax
12547 35EA           8886       F7E3            mov	-$81D[bp],al
12548                       000035EE            .2F4:
12549                                           ! Debug: lt int = const 8 to unsigned char device = [S+$820-$81F] (used reg = )
12550 35EE           8A86       F7E3            mov	al,-$81D[bp]
12551 35F2           3C                     08  cmp	al,*8
12552 35F4           72           DD            jb 	.2F5
12553                       000035F6            .2F8:
12554                       000035F6            .2F2:
12555                                           ! Debug: ge int = const 8 to unsigned char device = [S+$820-$81F] (used reg = )
12556 35F6           8A86       F7E3            mov	al,-$81D[bp]
12557 35FA           3C                     08  cmp	al,*8
12558 35FC           72           07            jb  	.2F9
12559                       000035FE            .2FA:
12560 35FE           B8                   0002  mov	ax,*2
12561 3601           89EC                       mov	sp,bp
12562 3603           5D                         pop	bp
12563 3604           C3                         ret
12564                                           !BCC_EOS
12565                                           ! 2413   if(error = atapi_is_ready(device) != 0)
12566                       00003605            .2F9:
12567                                           ! Debug: list unsigned char device = [S+$820-$81F] (used reg = )
12568 3605           8A86       F7E3            mov	al,-$81D[bp]
12569 3609           30E4                       xor	ah,ah
12570 360B           50                         push	ax
12571                                           ! Debug: func () unsigned short = atapi_is_ready+0 (used reg = )
12572 360C           E8         FC6E            call	_atapi_is_ready
12573 360F           44                         inc	sp
12574 3610           44                         inc	sp
12575                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
12576 3611           85C0                       test	ax,ax
12577 3613           74           04            je 	.2FD
12578 3615           B0                     01  mov	al,*1
12579 3617           EB           02            jmp	.2FE
12580                       00003619            .2FD:
12581 3619           30C0                       xor	al,al
12582                       0000361B            .2FE:
12583                                           ! Debug: eq char = al+0 to unsigned short error = [S+$820-$81E] (used reg = )
12584 361B           30E4                       xor	ah,ah
12585 361D           8986       F7E4            mov	-$81C[bp],ax
12586 3621           85C0                       test	ax,ax
12587 3623           74           12            je  	.2FB
12588                       00003625            .2FC:
12589                                           ! 2414     bios_printf(4, "ata_is_ready returned %d\n",error);
12590                                           ! Debug: list unsigned short error = [S+$820-$81E] (used reg = )
12591 3625           FFB6       F7E4            push	-$81C[bp]
12592                                           ! Debug: list * char = .2FF+0 (used reg = )
12593 3629           BB                   D5B6  mov	bx,#.2FF
12594 362C           53                         push	bx
12595                                           ! Debug: list int = const 4 (used reg = )
12596 362D           B8                   0004  mov	ax,*4
12597 3630           50                         push	ax
12598                                           ! Debug: func () void = bios_printf+0 (used reg = )
12599 3631           E8         D30A            call	_bios_printf
12600 3634           83C4                   06  add	sp,*6
12601                                           !BCC_EOS
12602                                           ! 2415   _memsetb(0,atacmd,get_SS(),12);
12603                       00003637            .2FB:
12604                                           ! Debug: list int = const $C (used reg = )
12605 3637           B8                   000C  mov	ax,*$C
12606 363A           50                         push	ax
12607                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12608 363B           E8         D021            call	_get_SS
12609                                           ! Debug: list unsigned short = ax+0 (used reg = )
12610 363E           50                         push	ax
12611                                           ! Debug: list * unsigned char atacmd = S+$824-$12 (used reg = )
12612 363F           8D5E         F0            lea	bx,-$10[bp]
12613 3642           53                         push	bx
12614                                           ! Debug: list int = const 0 (used reg = )
12615 3643           31C0                       xor	ax,ax
12616 3645           50                         push	ax
12617                                           ! Debug: func () void = _memsetb+0 (used reg = )
12618 3646           E8         C9B7            call	__memsetb
12619 3649           83C4                   08  add	sp,*8
12620                                           !BCC_EOS
12621                                           ! 2416   atacmd[0]=0x28;
12622                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$820-$12] (used reg = )
12623 364C           B0                     28  mov	al,*$28
12624 364E           8846         F0            mov	-$10[bp],al
12625                                           !BCC_EOS
12626                                           ! 2417   atacmd[7]=(0x01 & 0xff00) >> 8;
12627                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$820-$B] (used reg = )
12628 3651           30C0                       xor	al,al
12629 3653           8846         F7            mov	-9[bp],al
12630                                           !BCC_EOS
12631                                           ! 2418   atacmd[8]=(0x01 & 0x00ff);
12632                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$820-$A] (used reg = )
12633 3656           B0                     01  mov	al,*1
12634 3658           8846         F8            mov	-8[bp],al
12635                                           !BCC_EOS
12636                                           ! 2419   atacmd[2]=(0x11 & 0xff000000) >> 24;
12637                                           ! Debug: eq unsigned long = const 0 to unsigned char atacmd = [S+$820-$10] (used reg = )
12638 365B           30C0                       xor	al,al
12639 365D           8846         F2            mov	-$E[bp],al
12640                                           !BCC_EOS
12641                                           ! 2420   atacmd[3]=(0x11 & 0x00ff0000) >> 16;
12642                                           ! Debug: eq long = const 0 to unsigned char atacmd = [S+$820-$F] (used reg = )
12643 3660           30C0                       xor	al,al
12644 3662           8846         F3            mov	-$D[bp],al
12645                                           !BCC_EOS
12646                                           ! 2421   atacmd[4]=(0x11 & 0x0000ff00) >> 8;
12647                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$820-$E] (used reg = )
12648 3665           30C0                       xor	al,al
12649 3667           8846         F4            mov	-$C[bp],al
12650                                           !BCC_EOS
12651                                           ! 2422   atacmd[5]=(0x11 & 0x000000ff);
12652                                           ! Debug: eq int = const $11 to unsigned char atacmd = [S+$820-$D] (used reg = )
12653 366A           B0                     11  mov	al,*$11
12654 366C           8846         F5            mov	-$B[bp],al
12655                                           !BCC_EOS
12656                                           ! 2423   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
12657                                           ! Debug: list * unsigned char buffer = S+$820-$812 (used reg = )
12658 366F           8D9E       F7F0            lea	bx,-$810[bp]
12659 3673           53                         push	bx
12660                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12661 3674           E8         CFE8            call	_get_SS
12662                                           ! Debug: list unsigned short = ax+0 (used reg = )
12663 3677           50                         push	ax
12664                                           ! Debug: list int = const 1 (used reg = )
12665 3678           B8                   0001  mov	ax,*1
12666 367B           50                         push	ax
12667                                           ! Debug: list long = const $800 (used reg = )
12668 367C           B8                   0800  mov	ax,#$800
12669 367F           31DB                       xor	bx,bx
12670 3681           53                         push	bx
12671 3682           50                         push	ax
12672                                           ! Debug: list int = const 0 (used reg = )
12673 3683           31C0                       xor	ax,ax
12674 3685           50                         push	ax
12675                                           ! Debug: list * unsigned char atacmd = S+$82C-$12 (used reg = )
12676 3686           8D5E         F0            lea	bx,-$10[bp]
12677 3689           53                         push	bx
12678                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12679 368A           E8         CFD2            call	_get_SS
12680                                           ! Debug: list unsigned short = ax+0 (used reg = )
12681 368D           50                         push	ax
12682                                           ! Debug: list int = const $C (used reg = )
12683 368E           B8                   000C  mov	ax,*$C
12684 3691           50                         push	ax
12685                                           ! Debug: list unsigned char device = [S+$832-$81F] (used reg = )
12686 3692           8A86       F7E3            mov	al,-$81D[bp]
12687 3696           30E4                       xor	ah,ah
12688 3698           50                         push	ax
12689                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
12690 3699           E8         F6B2            call	_ata_cmd_packet
12691 369C           83C4                   14  add	sp,*$14
12692                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$820-$81E] (used reg = )
12693 369F           8986       F7E4            mov	-$81C[bp],ax
12694                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
12695 36A3           85C0                       test	ax,ax
12696 36A5           74           07            je  	.300
12697                       000036A7            .301:
12698                                           ! 2424     return 3;
12699 36A7           B8                   0003  mov	ax,*3
12700 36AA           89EC                       mov	sp,bp
12701 36AC           5D                         pop	bp
12702 36AD           C3                         ret
12703                                           !BCC_EOS
12704                                           ! 2425   if(buffer[0]!=0) return 4;
12705                       000036AE            .300:
12706                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$820-$812] (used reg = )
12707 36AE           8A86       F7F0            mov	al,-$810[bp]
12708 36B2           84C0                       test	al,al
12709 36B4           74           07            je  	.302
12710                       000036B6            .303:
12711 36B6           B8                   0004  mov	ax,*4
12712 36B9           89EC                       mov	sp,bp
12713 36BB           5D                         pop	bp
12714 36BC           C3                         ret
12715                                           !BCC_EOS
12716                                           ! 2426   for(i=0;i<5;i++){
12717                       000036BD            .302:
12718                                           ! Debug: eq int = const 0 to unsigned short i = [S+$820-$81C] (used reg = )
12719 36BD           31C0                       xor	ax,ax
12720 36BF           8986       F7E6            mov	-$81A[bp],ax
12721                                           !BCC_EOS
12722                                           !BCC_EOS
12723 36C3           EB           3B            jmp .306
12724                       000036C5            .307:
12725                                           ! 2427     if(buffer[1+i]!=_read_byte(&isotag[i], 0xf000)) return 5;
12726                                           ! Debug: list unsigned int = const $F000 (used reg = )
12727 36C5           B8                   F000  mov	ax,#$F000
12728 36C8           50                         push	ax
12729                                           ! Debug: ptradd unsigned short i = [S+$822-$81C] to [6] char = isotag+0 (used reg = )
12730 36C9           8B9E       F7E6            mov	bx,-$81A[bp]
12731                                           ! Debug: address char = [bx+_isotag+0] (used reg = )
12732                                           ! Debug: list * char = bx+_isotag+0 (used reg = )
12733 36CD           81C3                 359E  add	bx,#_isotag
12734 36D1           53                         push	bx
12735                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12736 36D2           E8         CF0F            call	__read_byte
12737 36D5           83C4                   04  add	sp,*4
12738 36D8           50                         push	ax
12739                                           ! Debug: add unsigned short i = [S+$822-$81C] to int = const 1 (used reg = )
12740                                           ! Debug: expression subtree swapping
12741 36D9           8B86       F7E6            mov	ax,-$81A[bp]
12742                                           ! Debug: ptradd unsigned int = ax+1 to [$800] unsigned char buffer = S+$822-$812 (used reg = )
12743 36DD           40                         inc	ax
12744 36DE           89EB                       mov	bx,bp
12745 36E0           01C3                       add	bx,ax
12746                                           ! Debug: ne unsigned char (temp) = [S+$822-$822] to unsigned char = [bx-$810] (used reg = )
12747 36E2           8A87       F7F0            mov	al,-$810[bx]
12748 36E6           3A86       F7E0            cmp	al,-$820[bp]
12749 36EA           8DA6       F7E2            lea	sp,-$81E[bp]
12750 36EE           74           07            je  	.308
12751                       000036F0            .309:
12752 36F0           B8                   0005  mov	ax,*5
12753 36F3           89EC                       mov	sp,bp
12754 36F5           5D                         pop	bp
12755 36F6           C3                         ret
12756                                           !BCC_EOS
12757                                           ! 2428   }
12758                       000036F7            .308:
12759                                           ! 2429   for(i=0;i<23;i++)
12760                       000036F7            .305:
12761                                           ! Debug: postinc unsigned short i = [S+$820-$81C] (used reg = )
12762 36F7           8B86       F7E6            mov	ax,-$81A[bp]
12763 36FB           40                         inc	ax
12764 36FC           8986       F7E6            mov	-$81A[bp],ax
12765                       00003700            .306:
12766                                           ! Debug: lt int = const 5 to unsigned short i = [S+$820-$81C] (used reg = )
12767 3700           8B86       F7E6            mov	ax,-$81A[bp]
12768 3704           3D                   0005  cmp	ax,*5
12769 3707           72           BC            jb 	.307
12770                       00003709            .30A:
12771                       00003709            .304:
12772                                           ! Debug: eq int = const 0 to unsigned short i = [S+$820-$81C] (used reg = )
12773 3709           31C0                       xor	ax,ax
12774 370B           8986       F7E6            mov	-$81A[bp],ax
12775                                           !BCC_EOS
12776                                           !BCC_EOS
12777                                           ! 2430     if(buffer[7+i]!=_read_byte(&eltorito[i], 0xf000)) return 6;
12778 370F           EB           3D            jmp .30D
12779                       00003711            .30E:
12780                                           ! Debug: list unsigned int = const $F000 (used reg = )
12781 3711           B8                   F000  mov	ax,#$F000
12782 3714           50                         push	ax
12783                                           ! Debug: ptradd unsigned short i = [S+$822-$81C] to [$18] char = eltorito+0 (used reg = )
12784 3715           8B9E       F7E6            mov	bx,-$81A[bp]
12785                                           ! Debug: address char = [bx+_eltorito+0] (used reg = )
12786                                           ! Debug: list * char = bx+_eltorito+0 (used reg = )
12787 3719           81C3                 35A4  add	bx,#_eltorito
12788 371D           53                         push	bx
12789                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12790 371E           E8         CEC3            call	__read_byte
12791 3721           83C4                   04  add	sp,*4
12792 3724           50                         push	ax
12793                                           ! Debug: add unsigned short i = [S+$822-$81C] to int = const 7 (used reg = )
12794                                           ! Debug: expression subtree swapping
12795 3725           8B86       F7E6            mov	ax,-$81A[bp]
12796                                           ! Debug: ptradd unsigned int = ax+7 to [$800] unsigned char buffer = S+$822-$812 (used reg = )
12797 3729           05                   0007  add	ax,*7
12798 372C           89EB                       mov	bx,bp
12799 372E           01C3                       add	bx,ax
12800                                           ! Debug: ne unsigned char (temp) = [S+$822-$822] to unsigned char = [bx-$810] (used reg = )
12801 3730           8A87       F7F0            mov	al,-$810[bx]
12802 3734           3A86       F7E0            cmp	al,-$820[bp]
12803 3738           8DA6       F7E2            lea	sp,-$81E[bp]
12804 373C           74           07            je  	.30F
12805                       0000373E            .310:
12806 373E           B8                   0006  mov	ax,*6
12807 3741           89EC                       mov	sp,bp
12808 3743           5D                         pop	bp
12809 3744           C3                         ret
12810                                           !BCC_EOS
12811                                           ! 2431   lba=*((Bit32u *)&buffer[0x47]);
12812                       00003745            .30F:
12813                       00003745            .30C:
12814                                           ! Debug: postinc unsigned short i = [S+$820-$81C] (used reg = )
12815 3745           8B86       F7E6            mov	ax,-$81A[bp]
12816 3749           40                         inc	ax
12817 374A           8986       F7E6            mov	-$81A[bp],ax
12818                       0000374E            .30D:
12819                                           ! Debug: lt int = const $17 to unsigned short i = [S+$820-$81C] (used reg = )
12820 374E           8B86       F7E6            mov	ax,-$81A[bp]
12821 3752           3D                   0017  cmp	ax,*$17
12822 3755           72           BA            jb 	.30E
12823                       00003757            .311:
12824                       00003757            .30B:
12825                                           ! Debug: eq unsigned long buffer = [S+$820-$7CB] to unsigned long lba = [S+$820-$816] (used reg = )
12826 3757           8B86       F837            mov	ax,-$7C9[bp]
12827 375B           8B9E       F839            mov	bx,-$7C7[bp]
12828 375F           8986       F7EC            mov	-$814[bp],ax
12829 3763           899E       F7EE            mov	-$812[bp],bx
12830                                           !BCC_EOS
12831                                           ! 2432   _memsetb(0,atacmd,get_SS(),12);
12832                                           ! Debug: list int = const $C (used reg = )
12833 3767           B8                   000C  mov	ax,*$C
12834 376A           50                         push	ax
12835                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12836 376B           E8         CEF1            call	_get_SS
12837                                           ! Debug: list unsigned short = ax+0 (used reg = )
12838 376E           50                         push	ax
12839                                           ! Debug: list * unsigned char atacmd = S+$824-$12 (used reg = )
12840 376F           8D5E         F0            lea	bx,-$10[bp]
12841 3772           53                         push	bx
12842                                           ! Debug: list int = const 0 (used reg = )
12843 3773           31C0                       xor	ax,ax
12844 3775           50                         push	ax
12845                                           ! Debug: func () void = _memsetb+0 (used reg = )
12846 3776           E8         C887            call	__memsetb
12847 3779           83C4                   08  add	sp,*8
12848                                           !BCC_EOS
12849                                           ! 2433   atacmd[0]=0x28;
12850                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$820-$12] (used reg = )
12851 377C           B0                     28  mov	al,*$28
12852 377E           8846         F0            mov	-$10[bp],al
12853                                           !BCC_EOS
12854                                           ! 2434   atacmd[7]=(0x01 & 0xff00) >> 8;
12855                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$820-$B] (used reg = )
12856 3781           30C0                       xor	al,al
12857 3783           8846         F7            mov	-9[bp],al
12858                                           !BCC_EOS
12859                                           ! 2435   atacmd[8]=(0x01 & 0x00ff);
12860                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$820-$A] (used reg = )
12861 3786           B0                     01  mov	al,*1
12862 3788           8846         F8            mov	-8[bp],al
12863                                           !BCC_EOS
12864                                           ! 2436   atacmd[2]=*(((Bit8u *)&*(((Bit16u *)&lba)+1))+1);
12865                                           ! Debug: eq unsigned char lba = [S+$820-$813] to unsigned char atacmd = [S+$820-$10] (used reg = )
12866 378B           8A86       F7EF            mov	al,-$811[bp]
12867 378F           8846         F2            mov	-$E[bp],al
12868                                           !BCC_EOS
12869                                           ! 2437   atacmd[3]=*((Bit8u *)&*(((Bit16u *)&lba)+1));
12870                                           ! Debug: eq unsigned char lba = [S+$820-$814] to unsigned char atacmd = [S+$820-$F] (used reg = )
12871 3792           8A86       F7EE            mov	al,-$812[bp]
12872 3796           8846         F3            mov	-$D[bp],al
12873                                           !BCC_EOS
12874                                           ! 2438   atacmd[4]=*(((Bit8u *)&*((Bit16u *)&lba))+1);
12875                                           ! Debug: eq unsigned char lba = [S+$820-$815] to unsigned char atacmd = [S+$820-$E] (used reg = )
12876 3799           8A86       F7ED            mov	al,-$813[bp]
12877 379D           8846         F4            mov	-$C[bp],al
12878                                           !BCC_EOS
12879                                           ! 2439   atacmd[5]=*((Bit8u *)&lba);
12880                                           ! Debug: eq unsigned char lba = [S+$820-$816] to unsigned char atacmd = [S+$820-$D] (used reg = )
12881 37A0           8A86       F7EC            mov	al,-$814[bp]
12882 37A4           8846         F5            mov	-$B[bp],al
12883                                           !BCC_EOS
12884                                           ! 2440   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
12885                                           ! Debug: list * unsigned char buffer = S+$820-$812 (used reg = )
12886 37A7           8D9E       F7F0            lea	bx,-$810[bp]
12887 37AB           53                         push	bx
12888                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12889 37AC           E8         CEB0            call	_get_SS
12890                                           ! Debug: list unsigned short = ax+0 (used reg = )
12891 37AF           50                         push	ax
12892                                           ! Debug: list int = const 1 (used reg = )
12893 37B0           B8                   0001  mov	ax,*1
12894 37B3           50                         push	ax
12895                                           ! Debug: list long = const $800 (used reg = )
12896 37B4           B8                   0800  mov	ax,#$800
12897 37B7           31DB                       xor	bx,bx
12898 37B9           53                         push	bx
12899 37BA           50                         push	ax
12900                                           ! Debug: list int = const 0 (used reg = )
12901 37BB           31C0                       xor	ax,ax
12902 37BD           50                         push	ax
12903                                           ! Debug: list * unsigned char atacmd = S+$82C-$12 (used reg = )
12904 37BE           8D5E         F0            lea	bx,-$10[bp]
12905 37C1           53                         push	bx
12906                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12907 37C2           E8         CE9A            call	_get_SS
12908                                           ! Debug: list unsigned short = ax+0 (used reg = )
12909 37C5           50                         push	ax
12910                                           ! Debug: list int = const $C (used reg = )
12911 37C6           B8                   000C  mov	ax,*$C
12912 37C9           50                         push	ax
12913                                           ! Debug: list unsigned char device = [S+$832-$81F] (used reg = )
12914 37CA           8A86       F7E3            mov	al,-$81D[bp]
12915 37CE           30E4                       xor	ah,ah
12916 37D0           50                         push	ax
12917                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
12918 37D1           E8         F57A            call	_ata_cmd_packet
12919 37D4           83C4                   14  add	sp,*$14
12920                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$820-$81E] (used reg = )
12921 37D7           8986       F7E4            mov	-$81C[bp],ax
12922                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
12923 37DB           85C0                       test	ax,ax
12924 37DD           74           07            je  	.312
12925                       000037DF            .313:
12926                                           ! 2441     return 7;
12927 37DF           B8                   0007  mov	ax,*7
12928 37E2           89EC                       mov	sp,bp
12929 37E4           5D                         pop	bp
12930 37E5           C3                         ret
12931                                           !BCC_EOS
12932                                           ! 2442   if(buffer[0x00]!=0x01)return 8;
12933                       000037E6            .312:
12934                                           ! Debug: ne int = const 1 to unsigned char buffer = [S+$820-$812] (used reg = )
12935 37E6           8A86       F7F0            mov	al,-$810[bp]
12936 37EA           3C                     01  cmp	al,*1
12937 37EC           74           07            je  	.314
12938                       000037EE            .315:
12939 37EE           B8                   0008  mov	ax,*8
12940 37F1           89EC                       mov	sp,bp
12941 37F3           5D                         pop	bp
12942 37F4           C3                         ret
12943                                           !BCC_EOS
12944                                           ! 2443   if(buffer[0x01]!=0x00)return 9;
12945                       000037F5            .314:
12946                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$820-$811] (used reg = )
12947 37F5           8A86       F7F1            mov	al,-$80F[bp]
12948 37F9           84C0                       test	al,al
12949 37FB           74           07            je  	.316
12950                       000037FD            .317:
12951 37FD           B8                   0009  mov	ax,*9
12952 3800           89EC                       mov	sp,bp
12953 3802           5D                         pop	bp
12954 3803           C3                         ret
12955                                           !BCC_EOS
12956                                           ! 2444   if(buffer[0x1E]!=0x55)return 10;
12957                       00003804            .316:
12958                                           ! Debug: ne int = const $55 to unsigned char buffer = [S+$820-$7F4] (used reg = )
12959 3804           8A86       F80E            mov	al,-$7F2[bp]
12960 3808           3C                     55  cmp	al,*$55
12961 380A           74           07            je  	.318
12962                       0000380C            .319:
12963 380C           B8                   000A  mov	ax,*$A
12964 380F           89EC                       mov	sp,bp
12965 3811           5D                         pop	bp
12966 3812           C3                         ret
12967                                           !BCC_EOS
12968                                           ! 2445   if(buffer[0x1F]!=0xAA)return 10;
12969                       00003813            .318:
12970                                           ! Debug: ne int = const $AA to unsigned char buffer = [S+$820-$7F3] (used reg = )
12971 3813           8A86       F80F            mov	al,-$7F1[bp]
12972 3817           3C                     AA  cmp	al,#$AA
12973 3819           74           07            je  	.31A
12974                       0000381B            .31B:
12975 381B           B8                   000A  mov	ax,*$A
12976 381E           89EC                       mov	sp,bp
12977 3820           5D                         pop	bp
12978 3821           C3                         ret
12979                                           !BCC_EOS
12980                                           ! 2446   if(buffer[0x20]!=0x88)return 1
12981                       00003822            .31A:
12982                                           ! Debug: ne int = const $88 to unsigned char buffer = [S+$820-$7F2] (used reg = )
12983 3822           8A86       F810            mov	al,-$7F0[bp]
12984 3826           3C                     88  cmp	al,#$88
12985 3828           74           07            je  	.31C
12986                       0000382A            .31D:
12987                                           ! 2446 1;
12988 382A           B8                   000B  mov	ax,*$B
12989 382D           89EC                       mov	sp,bp
12990 382F           5D                         pop	bp
12991 3830           C3                         ret
12992                                           !BCC_EOS
12993                                           ! 2447   old_ds = set_DS(ebda_seg);
12994                       00003831            .31C:
12995                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
12996 3831           FF76         FE            push	-2[bp]
12997                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
12998 3834           E8         CE2B            call	_set_DS
12999 3837           44                         inc	sp
13000 3838           44                         inc	sp
13001                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+$820-6] (used reg = )
13002 3839           8946         FC            mov	-4[bp],ax
13003                                           !BCC_EOS
13004                                           ! 2448   *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.media)) = (buffer[0x21]);
13005                                           ! Debug: eq unsigned char buffer = [S+$820-$7F1] to unsigned char = [+$25B] (used reg = )
13006 383C           8A86       F811            mov	al,-$7EF[bp]
13007 3840           A2         025B            mov	[$25B],al
13008                                           !BCC_EOS
13009                                           ! 2449   if(buffer[0x21]==0){
13010                                           ! Debug: logeq int = const 0 to unsigned char buffer = [S+$820-$7F1] (used reg = )
13011 3843           8A86       F811            mov	al,-$7EF[bp]
13012 3847           84C0                       test	al,al
13013 3849           75           07            jne 	.31E
13014                       0000384B            .31F:
13015                                           ! 2450     *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive)) = (0xE0);
13016                                           ! Debug: eq int = const $E0 to unsigned char = [+$25C] (used reg = )
13017 384B           B0                     E0  mov	al,#$E0
13018 384D           A2         025C            mov	[$25C],al
13019                                           !BCC_EOS
13020                                           ! 2451   }
13021                                           ! 2452   else if(buffer[0x21]<4)
13022 3850           EB           14            jmp .320
13023                       00003852            .31E:
13024                                           ! Debug: lt int = const 4 to unsigned char buffer = [S+$820-$7F1] (used reg = )
13025 3852           8A86       F811            mov	al,-$7EF[bp]
13026 3856           3C                     04  cmp	al,*4
13027 3858           73           07            jae 	.321
13028                       0000385A            .322:
13029                                           ! 2453     *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive)) = (0x00);
13030                                           ! Debug: eq int = const 0 to unsigned char = [+$25C] (used reg = )
13031 385A           30C0                       xor	al,al
13032 385C           A2         025C            mov	[$25C],al
13033                                           !BCC_EOS
13034                                           ! 2454   else
13035                                           ! 2455     *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive)) = (0x80);
13036 385F           EB           05            jmp .323
13037                       00003861            .321:
13038                                           ! Debug: eq int = const $80 to unsigned char = [+$25C] (used reg = )
13039 3861           B0                     80  mov	al,#$80
13040 3863           A2         025C            mov	[$25C],al
13041                                           !BCC_EOS
13042                                           ! 2456   *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.controller_index)) = (device/2);
13043                       00003866            .323:
13044                       00003866            .320:
13045                                           ! Debug: div int = const 2 to unsigned char device = [S+$820-$81F] (used reg = )
13046 3866           8A86       F7E3            mov	al,-$81D[bp]
13047 386A           30E4                       xor	ah,ah
13048 386C           D1E8                       shr	ax,*1
13049                                           ! Debug: eq unsigned int = ax+0 to unsigned char = [+$25D] (used reg = )
13050 386E           A2         025D            mov	[$25D],al
13051                                           !BCC_EOS
13052                                           ! 2457   *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.device_spec)) = (device%2);
13053                                           ! Debug: mod int = const 2 to unsigned char device = [S+$820-$81F] (used reg = )
13054 3871           8A86       F7E3            mov	al,-$81D[bp]
13055 3875           30E4                       xor	ah,ah
13056 3877           24                     01  and	al,*1
13057                                           ! Debug: eq unsigned char = al+0 to unsigned char = [+$25E] (used reg = )
13058 3879           A2         025E            mov	[$25E],al
13059                                           !BCC_EOS
13060                                           ! 2458   boot_segment=*((Bit16u *)&buffer[0x22]);
13061                                           ! Debug: eq unsigned short buffer = [S+$820-$7F0] to unsigned short boot_segment = [S+$820-$818] (used reg = )
13062 387C           8B86       F812            mov	ax,-$7EE[bp]
13063 3880           8986       F7EA            mov	-$816[bp],ax
13064                                           !BCC_EOS
13065                                           ! 2459   if(boot_segment==0x0000)boot_segment=0x07C0;
13066                                           ! Debug: logeq int = const 0 to unsigned short boot_segment = [S+$820-$818] (used reg = )
13067 3884           8B86       F7EA            mov	ax,-$816[bp]
13068 3888           85C0                       test	ax,ax
13069 388A           75           07            jne 	.324
13070                       0000388C            .325:
13071                                           ! Debug: eq int = const $7C0 to unsigned short boot_segment = [S+$820-$818] (used reg = )
13072 388C           B8                   07C0  mov	ax,#$7C0
13073 388F           8986       F7EA            mov	-$816[bp],ax
13074                                           !BCC_EOS
13075                                           ! 2460   *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.load_segment)) = (boot_segment);
13076                       00003893            .324:
13077                                           ! Debug: eq unsigned short boot_segment = [S+$820-$818] to unsigned short = [+$266] (used reg = )
13078 3893           8B86       F7EA            mov	ax,-$816[bp]
13079 3897           A3         0266            mov	[$266],ax
13080                                           !BCC_EOS
13081                                           ! 2461   *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.buffer_segment)) = (0x0000);
13082                                           ! Debug: eq int = const 0 to unsigned short = [+$264] (used reg = )
13083 389A           31C0                       xor	ax,ax
13084 389C           A3         0264            mov	[$264],ax
13085                                           !BCC_EOS
13086                                           ! 2462   nbsectors=*((Bit16u *)&buffer[0x26]);
13087                                           ! Debug: eq unsigned short buffer = [S+$820-$7EC] to unsigned short nbsectors = [S+$820-$81A] (used reg = )
13088 389F           8B86       F816            mov	ax,-$7EA[bp]
13089 38A3           8986       F7E8            mov	-$818[bp],ax
13090                                           !BCC_EOS
13091                                           ! 2463   *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.sector_count)) = (nbsectors);
13092                                           ! Debug: eq unsigned short nbsectors = [S+$820-$81A] to unsigned short = [+$268] (used reg = )
13093 38A7           8B86       F7E8            mov	ax,-$818[bp]
13094 38AB           A3         0268            mov	[$268],ax
13095                                           !BCC_EOS
13096                                           ! 2464   lba=*((Bit32u *)&buffer[0x28]);
13097                                           ! Debug: eq unsigned long buffer = [S+$820-$7EA] to unsigned long lba = [S+$820-$816] (used reg = )
13098 38AE           8B86       F818            mov	ax,-$7E8[bp]
13099 38B2           8B9E       F81A            mov	bx,-$7E6[bp]
13100 38B6           8986       F7EC            mov	-$814[bp],ax
13101 38BA           899E       F7EE            mov	-$812[bp],bx
13102                                           !BCC_EOS
13103                                           ! 2465   *((Bit32u *)(&((ebda_data_t *) 0)->cdemu.ilba)) = (lba);
13104                                           ! Debug: eq unsigned long lba = [S+$820-$816] to unsigned long = [+$260] (used reg = )
13105 38BE           8B86       F7EC            mov	ax,-$814[bp]
13106 38C2           8B9E       F7EE            mov	bx,-$812[bp]
13107 38C6           A3         0260            mov	[$260],ax
13108 38C9           891E       0262            mov	[$262],bx
13109                                           !BCC_EOS
13110                                           ! 2466   _memsetb(0,atacmd,get_SS(),12);
13111                                           ! Debug: list int = const $C (used reg = )
13112 38CD           B8                   000C  mov	ax,*$C
13113 38D0           50                         push	ax
13114                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13115 38D1           E8         CD8B            call	_get_SS
13116                                           ! Debug: list unsigned short = ax+0 (used reg = )
13117 38D4           50                         push	ax
13118                                           ! Debug: list * unsigned char atacmd = S+$824-$12 (used reg = )
13119 38D5           8D5E         F0            lea	bx,-$10[bp]
13120 38D8           53                         push	bx
13121                                           ! Debug: list int = const 0 (used reg = )
13122 38D9           31C0                       xor	ax,ax
13123 38DB           50                         push	ax
13124                                           ! Debug: func () void = _memsetb+0 (used reg = )
13125 38DC           E8         C721            call	__memsetb
13126 38DF           83C4                   08  add	sp,*8
13127                                           !BCC_EOS
13128                                           ! 2467   atacmd[0]=0x28;
13129                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$820-$12] (used reg = )
13130 38E2           B0                     28  mov	al,*$28
13131 38E4           8846         F0            mov	-$10[bp],al
13132                                           !BCC_EOS
13133                                           ! 2468   i = 1+(nbsectors-1)/4;
13134                                           ! Debug: sub int = const 1 to unsigned short nbsectors = [S+$820-$81A] (used reg = )
13135 38E7           8B86       F7E8            mov	ax,-$818[bp]
13136                                           ! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
13137 38EB           48                         dec	ax
13138 38EC           D1E8                       shr	ax,*1
13139 38EE           D1E8                       shr	ax,*1
13140                                           ! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
13141                                           ! Debug: expression subtree swapping
13142                                           ! Debug: eq unsigned int = ax+1 to unsigned short i = [S+$820-$81C] (used reg = )
13143 38F0           40                         inc	ax
13144 38F1           8986       F7E6            mov	-$81A[bp],ax
13145                                           !BCC_EOS
13146                                           ! 2469   atacmd[7]=*(((Bit8u *)&i)+1);
13147                                           ! Debug: eq unsigned char i = [S+$820-$81B] to unsigned char atacmd = [S+$820-$B] (used reg = )
13148 38F5           8A86       F7E7            mov	al,-$819[bp]
13149 38F9           8846         F7            mov	-9[bp],al
13150                                           !BCC_EOS
13151                                           ! 2470   atacmd[8]=*((Bit8u *)&i);
13152                                           ! Debug: eq unsigned char i = [S+$820-$81C] to unsigned char atacmd = [S+$820-$A] (used reg = )
13153 38FC           8A86       F7E6            mov	al,-$81A[bp]
13154 3900           8846         F8            mov	-8[bp],al
13155                                           !BCC_EOS
13156                                           ! 2471   atacmd[2]=*(((Bit8u *)&*(((Bit16u *)&lba)+1))+1);
13157                                           ! Debug: eq unsigned char lba = [S+$820-$813] to unsigned char atacmd = [S+$820-$10] (used reg = )
13158 3903           8A86       F7EF            mov	al,-$811[bp]
13159 3907           8846         F2            mov	-$E[bp],al
13160                                           !BCC_EOS
13161                                           ! 2472   atacmd[3]=*((Bit8u *)&*(((Bit16u *)&lba)+1));
13162                                           ! Debug: eq unsigned char lba = [S+$820-$814] to unsigned char atacmd = [S+$820-$F] (used reg = )
13163 390A           8A86       F7EE            mov	al,-$812[bp]
13164 390E           8846         F3            mov	-$D[bp],al
13165                                           !BCC_EOS
13166                                           ! 2473   atacmd[4]=*(((Bit8u *)&*((Bit16u *)&lba))+1);
13167                                           ! Debug: eq unsigned char lba = [S+$820-$815] to unsigned char atacmd = [S+$820-$E] (used reg = )
13168 3911           8A86       F7ED            mov	al,-$813[bp]
13169 3915           8846         F4            mov	-$C[bp],al
13170                                           !BCC_EOS
13171                                           ! 2474   atacmd[5]=*((Bit8u *)&lba);
13172                                           ! Debug: eq unsigned char lba = [S+$820-$816] to unsigned char atacmd = [S+$820-$D] (used reg = )
13173 3918           8A86       F7EC            mov	al,-$814[bp]
13174 391C           8846         F5            mov	-$B[bp],al
13175                                           !BCC_EOS
13176                                           ! 2475   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, nbsectors*512L, 0x01, boot_segment,0)) != 0)
13177                                           ! Debug: list int = const 0 (used reg = )
13178 391F           31C0                       xor	ax,ax
13179 3921           50                         push	ax
13180                                           ! Debug: list unsigned short boot_segment = [S+$822-$818] (used reg = )
13181 3922           FFB6       F7EA            push	-$816[bp]
13182                                           ! Debug: list int = const 1 (used reg = )
13183 3926           B8                   0001  mov	ax,*1
13184 3929           50                         push	ax
13185                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$826-$81A] (used reg = )
13186 392A           8B86       F7E8            mov	ax,-$818[bp]
13187 392E           31DB                       xor	bx,bx
13188                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
13189 3930           53                         push	bx
13190 3931           50                         push	ax
13191 3932           B8                   0200  mov	ax,#$200
13192 3935           31DB                       xor	bx,bx
13193 3937           53                         push	bx
13194 3938           50                         push	ax
13195 3939           8B86       F7D8            mov	ax,-$828[bp]
13196 393D           8B9E       F7DA            mov	bx,-$826[bp]
13197 3941           8DBE       F7D4            lea	di,-$82C[bp]
13198 3945           E8         C772            call	lmulul
13199 3948           83C4                   08  add	sp,*8
13200                                           ! Debug: list unsigned long = bx+0 (used reg = )
13201 394B           53                         push	bx
13202 394C           50                         push	ax
13203                                           ! Debug: list int = const 0 (used reg = )
13204 394D           31C0                       xor	ax,ax
13205 394F           50                         push	ax
13206                                           ! Debug: list * unsigned char atacmd = S+$82C-$12 (used reg = )
13207 3950           8D5E         F0            lea	bx,-$10[bp]
13208 3953           53                         push	bx
13209                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13210 3954           E8         CD08            call	_get_SS
13211                                           ! Debug: list unsigned short = ax+0 (used reg = )
13212 3957           50                         push	ax
13213                                           ! Debug: list int = const $C (used reg = )
13214 3958           B8                   000C  mov	ax,*$C
13215 395B           50                         push	ax
13216                                           ! Debug: list unsigned char device = [S+$832-$81F] (used reg = )
13217 395C           8A86       F7E3            mov	al,-$81D[bp]
13218 3960           30E4                       xor	ah,ah
13219 3962           50                         push	ax
13220                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
13221 3963           E8         F3E8            call	_ata_cmd_packet
13222 3966           83C4                   14  add	sp,*$14
13223                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$820-$81E] (used reg = )
13224 3969           8986       F7E4            mov	-$81C[bp],ax
13225                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
13226 396D           85C0                       test	ax,ax
13227 396F           74           0F            je  	.326
13228                       00003971            .327:
13229                                           ! 2476   {
13230                                           ! 2477     set_DS(old_ds);
13231                                           ! Debug: list unsigned short old_ds = [S+$820-6] (used reg = )
13232 3971           FF76         FC            push	-4[bp]
13233                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
13234 3974           E8         CCEB            call	_set_DS
13235 3977           44                         inc	sp
13236 3978           44                         inc	sp
13237                                           !BCC_EOS
13238                                           ! 2478     return 12;
13239 3979           B8                   000C  mov	ax,*$C
13240 397C           89EC                       mov	sp,bp
13241 397E           5D                         pop	bp
13242 397F           C3                         ret
13243                                           !BCC_EOS
13244                                           ! 2479   }
13245                                           ! 2480   switch(*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.media))) {
13246                       00003980            .326:
13247 3980           A0         025B            mov	al,[$25B]
13248 3983           E9         009B            br 	.32A
13249                                           ! 2481     case 0x01:
13250                                           ! 2482       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt)) = (15);
13251                       00003986            .32B:
13252                                           ! Debug: eq int = const $F to unsigned short = [+$26E] (used reg = )
13253 3986           B8                   000F  mov	ax,*$F
13254 3989           A3         026E            mov	[$26E],ax
13255                                           !BCC_EOS
13256                                           ! 2483       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders)) = (80);
13257                                           ! Debug: eq int = const $50 to unsigned short = [+$26C] (used reg = )
13258 398C           B8                   0050  mov	ax,*$50
13259 398F           A3         026C            mov	[$26C],ax
13260                                           !BCC_EOS
13261                                           ! 2484       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads)) = (2);
13262                                           ! Debug: eq int = const 2 to unsigned short = [+$26A] (used reg = )
13263 3992           B8                   0002  mov	ax,*2
13264 3995           A3         026A            mov	[$26A],ax
13265                                           !BCC_EOS
13266                                           ! 2485       break;
13267 3998           E9         009C            br 	.328
13268                                           !BCC_EOS
13269                                           ! 2486     case 0x02:
13270                                           ! 2487       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt)) = (18);
13271                       0000399B            .32C:
13272                                           ! Debug: eq int = const $12 to unsigned short = [+$26E] (used reg = )
13273 399B           B8                   0012  mov	ax,*$12
13274 399E           A3         026E            mov	[$26E],ax
13275                                           !BCC_EOS
13276                                           ! 2488       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders)) = (80);
13277                                           ! Debug: eq int = const $50 to unsigned short = [+$26C] (used reg = )
13278 39A1           B8                   0050  mov	ax,*$50
13279 39A4           A3         026C            mov	[$26C],ax
13280                                           !BCC_EOS
13281                                           ! 2489       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads)) = (2);
13282                                           ! Debug: eq int = const 2 to unsigned short = [+$26A] (used reg = )
13283 39A7           B8                   0002  mov	ax,*2
13284 39AA           A3         026A            mov	[$26A],ax
13285                                           !BCC_EOS
13286                                           ! 2490       break;
13287 39AD           E9         0087            br 	.328
13288                                           !BCC_EOS
13289                                           ! 2491     case 0x03:
13290                                           ! 2492       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt)) =
13291                       000039B0            .32D:
13292                                           ! 2492  (36);
13293                                           ! Debug: eq int = const $24 to unsigned short = [+$26E] (used reg = )
13294 39B0           B8                   0024  mov	ax,*$24
13295 39B3           A3         026E            mov	[$26E],ax
13296                                           !BCC_EOS
13297                                           ! 2493       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders)) = (80);
13298                                           ! Debug: eq int = const $50 to unsigned short = [+$26C] (used reg = )
13299 39B6           B8                   0050  mov	ax,*$50
13300 39B9           A3         026C            mov	[$26C],ax
13301                                           !BCC_EOS
13302                                           ! 2494       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads)) = (2);
13303                                           ! Debug: eq int = const 2 to unsigned short = [+$26A] (used reg = )
13304 39BC           B8                   0002  mov	ax,*2
13305 39BF           A3         026A            mov	[$26A],ax
13306                                           !BCC_EOS
13307                                           ! 2495       break;
13308 39C2           EB           73            jmp .328
13309                                           !BCC_EOS
13310                                           ! 2496     case 0x04:
13311                                           ! 2497       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt)) = (_read_byte(446+6, boot_segment)&0x3f);
13312                       000039C4            .32E:
13313                                           ! Debug: list unsigned short boot_segment = [S+$820-$818] (used reg = )
13314 39C4           FFB6       F7EA            push	-$816[bp]
13315                                           ! Debug: list int = const $1C4 (used reg = )
13316 39C8           B8                   01C4  mov	ax,#$1C4
13317 39CB           50                         push	ax
13318                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
13319 39CC           E8         CC15            call	__read_byte
13320 39CF           83C4                   04  add	sp,*4
13321                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
13322 39D2           24                     3F  and	al,*$3F
13323                                           ! Debug: eq unsigned char = al+0 to unsigned short = [+$26E] (used reg = )
13324 39D4           30E4                       xor	ah,ah
13325 39D6           A3         026E            mov	[$26E],ax
13326                                           !BCC_EOS
13327                                           ! 2498       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders)) = ((_read_byte(446+6, boot_segment)<<2) + _read_byte(446+7, boot_segment) + 1);
13328                                           ! Debug: list unsigned short boot_segment = [S+$820-$818] (used reg = )
13329 39D9           FFB6       F7EA            push	-$816[bp]
13330                                           ! Debug: list int = const $1C5 (used reg = )
13331 39DD           B8                   01C5  mov	ax,#$1C5
13332 39E0           50                         push	ax
13333                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
13334 39E1           E8         CC00            call	__read_byte
13335 39E4           83C4                   04  add	sp,*4
13336 39E7           50                         push	ax
13337                                           ! Debug: list unsigned short boot_segment = [S+$822-$818] (used reg = )
13338 39E8           FFB6       F7EA            push	-$816[bp]
13339                                           ! Debug: list int = const $1C4 (used reg = )
13340 39EC           B8                   01C4  mov	ax,#$1C4
13341 39EF           50                         push	ax
13342                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
13343 39F0           E8         CBF1            call	__read_byte
13344 39F3           83C4                   04  add	sp,*4
13345                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
13346 39F6           30E4                       xor	ah,ah
13347 39F8           D1E0                       shl	ax,*1
13348 39FA           D1E0                       shl	ax,*1
13349                                           ! Debug: add unsigned char (temp) = [S+$822-$822] to unsigned int = ax+0 (used reg = )
13350 39FC           0286       F7E0            add	al,0+..FFF9[bp]
13351 3A00           80D4                   00  adc	ah,*0
13352 3A03           44                         inc	sp
13353 3A04           44                         inc	sp
13354                                           ! Debug: add int = const 1 to unsigned int = ax+0 (used reg = )
13355                                           ! Debug: eq unsigned int = ax+1 to unsigned short = [+$26C] (used reg = )
13356 3A05           40                         inc	ax
13357 3A06           A3         026C            mov	[$26C],ax
13358                                           !BCC_EOS
13359                                           ! 2499       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads)) = (_read_byte(446+5, boot_segment) + 1);
13360                                           ! Debug: list unsigned short boot_segment = [S+$820-$818] (used reg = )
13361 3A09           FFB6       F7EA            push	-$816[bp]
13362                                           ! Debug: list int = const $1C3 (used reg = )
13363 3A0D           B8                   01C3  mov	ax,#$1C3
13364 3A10           50                         push	ax
13365                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
13366 3A11           E8         CBD0            call	__read_byte
13367 3A14           83C4                   04  add	sp,*4
13368                                           ! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
13369 3A17           30E4                       xor	ah,ah
13370                                           ! Debug: eq unsigned int = ax+1 to unsigned short = [+$26A] (used reg = )
13371 3A19           40                         inc	ax
13372 3A1A           A3         026A            mov	[$26A],ax
13373                                           !BCC_EOS
13374                                           ! 2500       break;
13375 3A1D           EB           18            jmp .328
13376                                           !BCC_EOS
13377                                           ! 2501    }
13378                                           ! 2502   if(*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.media))!=0) {
13379 3A1F           EB           16            jmp .328
13380                       00003A21            .32A:
13381 3A21           2C                     01  sub	al,*1
13382 3A23         0F84         FF5F            beq 	.32B
13383 3A27           2C                     01  sub	al,*1
13384 3A29         0F84         FF6E            beq 	.32C
13385 3A2D           2C                     01  sub	al,*1
13386 3A2F         0F84         FF7D            beq 	.32D
13387 3A33           2C                     01  sub	al,*1
13388 3A35           74           8D            je 	.32E
13389                       00003A37            .328:
13390                       FFFFF7E0            ..FFF9	=	-$820
13391                                           ! Debug: ne int = const 0 to unsigned char = [+$25B] (used reg = )
13392 3A37           A0         025B            mov	al,[$25B]
13393 3A3A           84C0                       test	al,al
13394 3A3C           74           33            je  	.32F
13395                       00003A3E            .330:
13396                                           ! 2503     if(*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive))==0x00)
13397                                           ! Debug: logeq int = const 0 to unsigned char = [+$25C] (used reg = )
13398 3A3E           A0         025C            mov	al,[$25C]
13399 3A41           84C0                       test	al,al
13400 3A43           75           23            jne 	.331
13401                       00003A45            .332:
13402                                           ! 2504       _write_byte(_read_byte(0x10, 0x40)|0x41, 0x10, 0x40);
13403                                           ! Debug: list int = const $40 (used reg = )
13404 3A45           B8                   0040  mov	ax,*$40
13405 3A48           50                         push	ax
13406                                           ! Debug: list int = const $10 (used reg = )
13407 3A49           B8                   0010  mov	ax,*$10
13408 3A4C           50                         push	ax
13409                                           ! Debug: list int = const $40 (used reg = )
13410 3A4D           B8                   0040  mov	ax,*$40
13411 3A50           50                         push	ax
13412                                           ! Debug: list int = const $10 (used reg = )
13413 3A51           B8                   0010  mov	ax,*$10
13414 3A54           50                         push	ax
13415                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
13416 3A55           E8         CB8C            call	__read_byte
13417 3A58           83C4                   04  add	sp,*4
13418                                           ! Debug: or int = const $41 to unsigned char = al+0 (used reg = )
13419 3A5B           0C                     41  or	al,*$41
13420                                           ! Debug: list unsigned char = al+0 (used reg = )
13421 3A5D           30E4                       xor	ah,ah
13422 3A5F           50                         push	ax
13423                                           ! Debug: func () void = _write_byte+0 (used reg = )
13424 3A60           E8         CB9D            call	__write_byte
13425 3A63           83C4                   06  add	sp,*6
13426                                           !BCC_EOS
13427                                           ! 2505     else
13428                                           ! 2506       *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdcount)) = (*((Bit8u *)(&((ebda_data_t *) 0)->ata.hdcount)) + 1);
13429 3A66           EB           09            jmp .333
13430                       00003A68            .331:
13431                                           ! Debug: add int = const 1 to unsigned char = [+$232] (used reg = )
13432 3A68           A0         0232            mov	al,[$232]
13433 3A6B           30E4                       xor	ah,ah
13434                                           ! Debug: eq unsigned int = ax+1 to unsigned char = [+$232] (used reg = )
13435 3A6D           40                         inc	ax
13436 3A6E           A2         0232            mov	[$232],al
13437                                           !BCC_EOS
13438                                           ! 2507   }
13439                       00003A71            .333:
13440                                           ! 2508   if(*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.media))!=0)
13441                       00003A71            .32F:
13442                                           ! Debug: ne int = const 0 to unsigned char = [+$25B] (used reg = )
13443 3A71           A0         025B            mov	al,[$25B]
13444 3A74           84C0                       test	al,al
13445 3A76           74           05            je  	.334
13446                       00003A78            .335:
13447                                           ! 2509     *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.active)) = (0x01);
13448                                           ! Debug: eq int = const 1 to unsigned char = [+$25A] (used reg = )
13449 3A78           B0                     01  mov	al,*1
13450 3A7A           A2         025A            mov	[$25A],al
13451                                           !BCC_EOS
13452                                           ! 2510   i = (*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive))*0x100)+0;
13453                       00003A7D            .334:
13454                                           ! Debug: mul int = const $100 to unsigned char = [+$25C] (used reg = )
13455 3A7D           A0         025C            mov	al,[$25C]
13456 3A80           30E4                       xor	ah,ah
13457 3A82           B9                   0100  mov	cx,#$100
13458 3A85           F7E9                       imul	cx
13459                                           ! Debug: add int = const 0 to unsigned int = ax+0 (used reg = )
13460                                           ! Debug: eq unsigned int = ax+0 to unsigned short i = [S+$820-$81C] (used reg = )
13461 3A87           8986       F7E6            mov	-$81A[bp],ax
13462                                           !BCC_EOS
13463                                           ! 2511   set_DS(old_ds);
13464                                           ! Debug: list unsigned short old_ds = [S+$820-6] (used reg = )
13465 3A8B           FF76         FC            push	-4[bp]
13466                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
13467 3A8E           E8         CBD1            call	_set_DS
13468 3A91           44                         inc	sp
13469 3A92           44                         inc	sp
13470                                           !BCC_EOS
13471                                           ! 2512   return i;
13472 3A93           8B86       F7E6            mov	ax,-$81A[bp]
13473 3A97           89EC                       mov	sp,bp
13474 3A99           5D                         pop	bp
13475 3A9A           C3                         ret
13476                                           !BCC_EOS
13477                                           ! 2513 }
13478                                           ! 2514 void int14_function(regs, ds, iret_addr)
13479                                           ! Register BX used in function cdrom_boot
13480                                           ! 2515   pusha_regs_t regs;
13481                                           export	_int14_function
13482                       00003A9B            _int14_function:
13483                                           !BCC_EOS
13484                                           ! 2516   Bit16u ds;
13485                                           !BCC_EOS
13486                                           ! 2517   iret_addr_t iret_addr;
13487                                           !BCC_EOS
13488                                           ! 2518 {
13489                                           ! 2519   Bit16u addr,timer,val16;
13490                                           !BCC_EOS
13491                                           ! 2520   Bit8u counter;
13492                                           !BCC_EOS
13493                                           ! 2521 #asm
13494 3A9B           55                         push	bp
13495 3A9C           89E5                       mov	bp,sp
13496 3A9E           83C4                   F8  add	sp,*-8
13497                                           !BCC_EOS
13498                                           !BCC_ASM
13499                       0000001C            _int14_function.ds	set	$1C
13500                       00000014            .int14_function.ds	set	$14
13501                       00000001            _int14_function.counter	set	1
13502                       FFFFFFF9            .int14_function.counter	set	-7
13503                       00000004            _int14_function.timer	set	4
13504                       FFFFFFFC            .int14_function.timer	set	-4
13505                       0000001E            _int14_function.iret_addr	set	$1E
13506                       00000016            .int14_function.iret_addr	set	$16
13507                       00000006            _int14_function.addr	set	6
13508                       FFFFFFFE            .int14_function.addr	set	-2
13509                       00000002            _int14_function.val16	set	2
13510                       FFFFFFFA            .int14_function.val16	set	-6
13511                       0000000C            _int14_function.regs	set	$C
13512                       00000004            .int14_function.regs	set	4
13513 3AA1           FB                           sti
13514                                           ! 2523 endasm
13515                                           !BCC_ENDASM
13516                                           !BCC_EOS
13517                                           ! 2524   addr = *((Bit16u *)(0x400 + (regs.u.r16.dx << 1)));
13518                                           ! Debug: sl int = const 1 to unsigned short regs = [S+$A+$C] (used reg = )
13519 3AA2           8B46         0E            mov	ax,$E[bp]
13520 3AA5           D1E0                       shl	ax,*1
13521                                           ! Debug: add unsigned int = ax+0 to int = const $400 (used reg = )
13522                                           ! Debug: expression subtree swapping
13523                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$400 (used reg = )
13524 3AA7           89C3                       mov	bx,ax
13525                                           ! Debug: eq unsigned short = [bx+$400] to unsigned short addr = [S+$A-4] (used reg = )
13526 3AA9           8B9F       0400            mov	bx,$400[bx]
13527 3AAD           895E         FE            mov	-2[bp],bx
13528                                           !BCC_EOS
13529                                           ! 2525   counter = *((Bit8u *)(0x047C + regs.u.r16.dx));
13530                                           ! Debug: add unsigned short regs = [S+$A+$C] to int = const $47C (used reg = )
13531                                           ! Debug: expression subtree swapping
13532 3AB0           8B46         0E            mov	ax,$E[bp]
13533                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$47C (used reg = )
13534 3AB3           89C3                       mov	bx,ax
13535                                           ! Debug: eq unsigned char = [bx+$47C] to unsigned char counter = [S+$A-9] (used reg = )
13536 3AB5           8A87       047C            mov	al,$47C[bx]
13537 3AB9           8846         F9            mov	-7[bp],al
13538                                           !BCC_EOS
13539                                           ! 2526   if ((regs.u.r16.dx < 4) && (addr > 0)) {
13540                                           ! Debug: lt int = const 4 to unsigned short regs = [S+$A+$C] (used reg = )
13541 3ABC           8B46         0E            mov	ax,$E[bp]
13542 3ABF           3D                   0004  cmp	ax,*4
13543 3AC2         0F83         01F6            bhis	.336
13544                       00003AC6            .338:
13545                                           ! Debug: gt int = const 0 to unsigned short addr = [S+$A-4] (used reg = )
13546 3AC6           8B46         FE            mov	ax,-2[bp]
13547 3AC9           85C0                       test	ax,ax
13548 3ACB         0F84         01ED            beq 	.336
13549                       00003ACF            .337:
13550                                           ! 2527     switch (regs.u.r8.ah) {
13551 3ACF           8A46         13            mov	al,$13[bp]
13552 3AD2           E9         01CD            br 	.33B
13553                                           ! 2528       case 0:
13554                                           ! 2529         outb(addr+3, inb(addr+3) | 0x80);
13555                       00003AD5            .33C:
13556                                           ! Debug: add int = const 3 to unsigned short addr = [S+$A-4] (used reg = )
13557 3AD5           8B46         FE            mov	ax,-2[bp]
13558                                           ! Debug: list unsigned int = ax+3 (used reg = )
13559 3AD8           05                   0003  add	ax,*3
13560 3ADB           50                         push	ax
13561                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13562 3ADC           E8         CA19            call	_inb
13563 3ADF           44                         inc	sp
13564 3AE0           44                         inc	sp
13565                                           ! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
13566 3AE1           0C                     80  or	al,#$80
13567                                           ! Debug: list unsigned char = al+0 (used reg = )
13568 3AE3           30E4                       xor	ah,ah
13569 3AE5           50                         push	ax
13570                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
13571 3AE6           8B46         FE            mov	ax,-2[bp]
13572                                           ! Debug: list unsigned int = ax+3 (used reg = )
13573 3AE9           05                   0003  add	ax,*3
13574 3AEC           50                         push	ax
13575                                           ! Debug: func () void = outb+0 (used reg = )
13576 3AED           E8         CA1E            call	_outb
13577 3AF0           83C4                   04  add	sp,*4
13578                                           !BCC_EOS
13579                                           ! 2530         if (regs.u.r8.al & 0xE0 == 0) {
13580                                           ! Debug: and int = const 0 to unsigned char regs = [S+$A+$10] (used reg = )
13581 3AF3           8A46         12            mov	al,$12[bp]
13582 3AF6           30C0                       xor	al,al
13583 3AF8           84C0                       test	al,al
13584 3AFA           74           1E            je  	.33D
13585                       00003AFC            .33E:
13586                                           ! 2531           outb(addr, 0x17);
13587                                           ! Debug: list int = const $17 (used reg = )
13588 3AFC           B8                   0017  mov	ax,*$17
13589 3AFF           50                         push	ax
13590                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
13591 3B00           FF76         FE            push	-2[bp]
13592                                           ! Debug: func () void = outb+0 (used reg = )
13593 3B03           E8         CA08            call	_outb
13594 3B06           83C4                   04  add	sp,*4
13595                                           !BCC_EOS
13596                                           ! 2532           outb(addr+1, 0x04);
13597                                           ! Debug: list int = const 4 (used reg = )
13598 3B09           B8                   0004  mov	ax,*4
13599 3B0C           50                         push	ax
13600                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
13601 3B0D           8B46         FE            mov	ax,-2[bp]
13602                                           ! Debug: list unsigned int = ax+1 (used reg = )
13603 3B10           40                         inc	ax
13604 3B11           50                         push	ax
13605                                           ! Debug: func () void = outb+0 (used reg = )
13606 3B12           E8         C9F9            call	_outb
13607 3B15           83C4                   04  add	sp,*4
13608                                           !BCC_EOS
13609                                           ! 2533         } else {
13610 3B18           EB           37            jmp .33F
13611                       00003B1A            .33D:
13612                                           ! 2534           val16 = 0x600 >> ((regs.u.r8.al & 0xE0) >> 5);
13613                                           ! Debug: and int = const $E0 to unsigned char regs = [S+$A+$10] (used reg = )
13614 3B1A           8A46         12            mov	al,$12[bp]
13615 3B1D           24                     E0  and	al,#$E0
13616                                           ! Debug: sr int = const 5 to unsigned char = al+0 (used reg = )
13617 3B1F           30E4                       xor	ah,ah
13618 3B21           B1                     05  mov	cl,*5
13619 3B23           D3E8                       shr	ax,cl
13620                                           ! Debug: sr unsigned int = ax+0 to int = const $600 (used reg = )
13621 3B25           89C3                       mov	bx,ax
13622 3B27           B8                   0600  mov	ax,#$600
13623 3B2A           89D9                       mov	cx,bx
13624 3B2C           D3F8                       sar	ax,cl
13625                                           ! Debug: eq int = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
13626 3B2E           8946         FA            mov	-6[bp],ax
13627                                           !BCC_EOS
13628                                           ! 2535           outb(addr, val16 & 0xFF);
13629                                           ! Debug: and int = const $FF to unsigned short val16 = [S+$A-8] (used reg = )
13630 3B31           8A46         FA            mov	al,-6[bp]
13631                                           ! Debug: list unsigned char = al+0 (used reg = )
13632 3B34           30E4                       xor	ah,ah
13633 3B36           50                         push	ax
13634                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
13635 3B37           FF76         FE            push	-2[bp]
13636                                           ! Debug: func () void = outb+0 (used reg = )
13637 3B3A           E8         C9D1            call	_outb
13638 3B3D           83C4                   04  add	sp,*4
13639                                           !BCC_EOS
13640                                           ! 2536           outb(addr+1, *(((Bit8u *)&val16)+1));
13641                                           ! Debug: list unsigned char val16 = [S+$A-7] (used reg = )
13642 3B40           8A46         FB            mov	al,-5[bp]
13643 3B43           30E4                       xor	ah,ah
13644 3B45           50                         push	ax
13645                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
13646 3B46           8B46         FE            mov	ax,-2[bp]
13647                                           ! Debug: list unsigned int = ax+1 (used reg = )
13648 3B49           40                         inc	ax
13649 3B4A           50                         push	ax
13650                                           ! Debug: func () void = outb+0 (used reg = )
13651 3B4B           E8         C9C0            call	_outb
13652 3B4E           83C4                   04  add	sp,*4
13653                                           !BCC_EOS
13654                                           ! 2537         }
13655                                           ! 2538         outb(addr+3, regs.u.r8.al & 0x1F);
13656                       00003B51            .33F:
13657                                           ! Debug: and int = const $1F to unsigned char regs = [S+$A+$10] (used reg = )
13658 3B51           8A46         12            mov	al,$12[bp]
13659 3B54           24                     1F  and	al,*$1F
13660                                           ! Debug: list unsigned char = al+0 (used reg = )
13661 3B56           30E4                       xor	ah,ah
13662 3B58           50                         push	ax
13663                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
13664 3B59           8B46         FE            mov	ax,-2[bp]
13665                                           ! Debug: list unsigned int = ax+3 (used reg = )
13666 3B5C           05                   0003  add	ax,*3
13667 3B5F           50                         push	ax
13668                                           ! Debug: func () void = outb+0 (used reg = )
13669 3B60           E8         C9AB            call	_outb
13670 3B63           83C4                   04  add	sp,*4
13671                                           !BCC_EOS
13672                                           ! 2539         regs.u.r8.ah = inb(addr+5);
13673                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13674 3B66           8B46         FE            mov	ax,-2[bp]
13675                                           ! Debug: list unsigned int = ax+5 (used reg = )
13676 3B69           05                   0005  add	ax,*5
13677 3B6C           50                         push	ax
13678                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13679 3B6D           E8         C988            call	_inb
13680 3B70           44                         inc	sp
13681 3B71           44                         inc	sp
13682                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
13683 3B72           8846         13            mov	$13[bp],al
13684                                           !BCC_EOS
13685                                           ! 2540         regs.u.r8.al = inb(addr+6);
13686                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
13687 3B75           8B46         FE            mov	ax,-2[bp]
13688                                           ! Debug: list unsigned int = ax+6 (used reg = )
13689 3B78           05                   0006  add	ax,*6
13690 3B7B           50                         push	ax
13691                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13692 3B7C           E8         C979            call	_inb
13693 3B7F           44                         inc	sp
13694 3B80           44                         inc	sp
13695                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
13696 3B81           8846         12            mov	$12[bp],al
13697                                           !BCC_EOS
13698                                           ! 2541         iret_addr.flags.u.r8.flagsl &= 0xfe;
13699                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
13700 3B84           8A46         1A            mov	al,$1A[bp]
13701 3B87           24                     FE  and	al,#$FE
13702 3B89           8846         1A            mov	$1A[bp],al
13703                                           !BCC_EOS
13704                                           ! 2542         break;
13705 3B8C           E9         012B            br 	.339
13706                                           !BCC_EOS
13707                                           ! 2543       case 1:
13708                                           ! 2544         timer = *((Bit16u *)(0x046C));
13709                       00003B8F            .340:
13710                                           ! Debug: eq unsigned short = [+$46C] to unsigned short timer = [S+$A-6] (used reg = )
13711 3B8F           A1         046C            mov	ax,[$46C]
13712 3B92           8946         FC            mov	-4[bp],ax
13713                                           !BCC_EOS
13714                                           ! 2545         while (((inb(addr+5) & 0x60) != 0x60) && (counter)) {
13715 3B95           EB           1B            jmp .342
13716                       00003B97            .343:
13717                                           ! 2546     
13718                                           ! 2546       val16 = *((Bit16u *)(0x046C));
13719                                           ! Debug: eq unsigned short = [+$46C] to unsigned short val16 = [S+$A-8] (used reg = )
13720 3B97           A1         046C            mov	ax,[$46C]
13721 3B9A           8946         FA            mov	-6[bp],ax
13722                                           !BCC_EOS
13723                                           ! 2547           if (val16 != timer) {
13724                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
13725 3B9D           8B46         FA            mov	ax,-6[bp]
13726 3BA0           3B46         FC            cmp	ax,-4[bp]
13727 3BA3           74           0D            je  	.344
13728                       00003BA5            .345:
13729                                           ! 2548             timer = val16;
13730                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
13731 3BA5           8B46         FA            mov	ax,-6[bp]
13732 3BA8           8946         FC            mov	-4[bp],ax
13733                                           !BCC_EOS
13734                                           ! 2549             counter--;
13735                                           ! Debug: postdec unsigned char counter = [S+$A-9] (used reg = )
13736 3BAB           8A46         F9            mov	al,-7[bp]
13737 3BAE           48                         dec	ax
13738 3BAF           8846         F9            mov	-7[bp],al
13739                                           !BCC_EOS
13740                                           ! 2550           }
13741                                           ! 2551         }
13742                       00003BB2            .344:
13743                                           ! 2552         if (counter > 0) {
13744                       00003BB2            .342:
13745                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13746 3BB2           8B46         FE            mov	ax,-2[bp]
13747                                           ! Debug: list unsigned int = ax+5 (used reg = )
13748 3BB5           05                   0005  add	ax,*5
13749 3BB8           50                         push	ax
13750                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13751 3BB9           E8         C93C            call	_inb
13752 3BBC           44                         inc	sp
13753 3BBD           44                         inc	sp
13754                                           ! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
13755 3BBE           24                     60  and	al,*$60
13756                                           ! Debug: ne int = const $60 to unsigned char = al+0 (used reg = )
13757 3BC0           3C                     60  cmp	al,*$60
13758 3BC2           74           07            je  	.346
13759                       00003BC4            .347:
13760 3BC4           8A46         F9            mov	al,-7[bp]
13761 3BC7           84C0                       test	al,al
13762 3BC9           75           CC            jne	.343
13763                       00003BCB            .346:
13764                       00003BCB            .341:
13765                                           ! Debug: gt int = const 0 to unsigned char counter = [S+$A-9] (used reg = )
13766 3BCB           8A46         F9            mov	al,-7[bp]
13767 3BCE           84C0                       test	al,al
13768 3BD0           74           20            je  	.348
13769                       00003BD2            .349:
13770                                           ! 2553           outb(addr, regs.u.r8.al);
13771                                           ! Debug: list unsigned char regs = [S+$A+$10] (used reg = )
13772 3BD2           8A46         12            mov	al,$12[bp]
13773 3BD5           30E4                       xor	ah,ah
13774 3BD7           50                         push	ax
13775                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
13776 3BD8           FF76         FE            push	-2[bp]
13777                                           ! Debug: func () void = outb+0 (used reg = )
13778 3BDB           E8         C930            call	_outb
13779 3BDE           83C4                   04  add	sp,*4
13780                                           !BCC_EOS
13781                                           ! 2554           regs.u.r8.ah = inb(addr+5);
13782                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13783 3BE1           8B46         FE            mov	ax,-2[bp]
13784                                           ! Debug: list unsigned int = ax+5 (used reg = )
13785 3BE4           05                   0005  add	ax,*5
13786 3BE7           50                         push	ax
13787                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13788 3BE8           E8         C90D            call	_inb
13789 3BEB           44                         inc	sp
13790 3BEC           44                         inc	sp
13791                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
13792 3BED           8846         13            mov	$13[bp],al
13793                                           !BCC_EOS
13794                                           ! 2555         } else {
13795 3BF0           EB           05            jmp .34A
13796                       00003BF2            .348:
13797                                           ! 2556           regs.u.r8.ah = 0x80;
13798                                           ! Debug: eq int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
13799 3BF2           B0                     80  mov	al,#$80
13800 3BF4           8846         13            mov	$13[bp],al
13801                                           !BCC_EOS
13802                                           ! 2557         }
13803                                           ! 2558         iret_addr.flags.u.r8.flagsl &= 0xfe;
13804                       00003BF7            .34A:
13805                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
13806 3BF7           8A46         1A            mov	al,$1A[bp]
13807 3BFA           24                     FE  and	al,#$FE
13808 3BFC           8846         1A            mov	$1A[bp],al
13809                                           !BCC_EOS
13810                                           ! 2559         break;
13811 3BFF           E9         00B8            br 	.339
13812                                           !BCC_EOS
13813                                           ! 2560       case 2:
13814                                           ! 2561         timer = *((Bit16u *)(0x046C));
13815                       00003C02            .34B:
13816                                           ! Debug: eq unsigned short = [+$46C] to unsigned short timer = [S+$A-6] (used reg = )
13817 3C02           A1         046C            mov	ax,[$46C]
13818 3C05           8946         FC            mov	-4[bp],ax
13819                                           !BCC_EOS
13820                                           ! 2562         while (((inb(addr+5) & 0x01) == 0) && (counter)) {
13821 3C08           EB           1B            jmp .34D
13822                       00003C0A            .34E:
13823                                           ! 2563           val16 = *((Bit16u *)(0x046C));
13824                                           ! Debug: eq unsigned short = [+$46C] to unsigned short val16 = [S+$A-8] (used reg = )
13825 3C0A           A1         046C            mov	ax,[$46C]
13826 3C0D           8946         FA            mov	-6[bp],ax
13827                                           !BCC_EOS
13828                                           ! 2564           if (val16 != timer) {
13829                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
13830 3C10           8B46         FA            mov	ax,-6[bp]
13831 3C13           3B46         FC            cmp	ax,-4[bp]
13832 3C16           74           0D            je  	.34F
13833                       00003C18            .350:
13834                                           ! 2565             timer = val16;
13835                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
13836 3C18           8B46         FA            mov	ax,-6[bp]
13837 3C1B           8946         FC            mov	-4[bp],ax
13838                                           !BCC_EOS
13839                                           ! 2566             counter--;
13840                                           ! Debug: postdec unsigned char counter = [S+$A-9] (used reg = )
13841 3C1E           8A46         F9            mov	al,-7[bp]
13842 3C21           48                         dec	ax
13843 3C22           8846         F9            mov	-7[bp],al
13844                                           !BCC_EOS
13845                                           ! 2567           }
13846                                           ! 2568         }
13847                       00003C25            .34F:
13848                                           ! 2569         if (counter > 0) {
13849                       00003C25            .34D:
13850                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13851 3C25           8B46         FE            mov	ax,-2[bp]
13852                                           ! Debug: list unsigned int = ax+5 (used reg = )
13853 3C28           05                   0005  add	ax,*5
13854 3C2B           50                         push	ax
13855                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13856 3C2C           E8         C8C9            call	_inb
13857 3C2F           44                         inc	sp
13858 3C30           44                         inc	sp
13859                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
13860 3C31           24                     01  and	al,*1
13861                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
13862 3C33           84C0                       test	al,al
13863 3C35           75           07            jne 	.351
13864                       00003C37            .352:
13865 3C37           8A46         F9            mov	al,-7[bp]
13866 3C3A           84C0                       test	al,al
13867 3C3C           75           CC            jne	.34E
13868                       00003C3E            .351:
13869                       00003C3E            .34C:
13870                                           ! Debug: gt int = const 0 to unsigned char counter = [S+$A-9] (used reg = )
13871 3C3E           8A46         F9            mov	al,-7[bp]
13872 3C41           84C0                       test	al,al
13873 3C43           74           1C            je  	.353
13874                       00003C45            .354:
13875                                           ! 2570           regs.u.r8.ah = inb(addr+5);
13876                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13877 3C45           8B46         FE            mov	ax,-2[bp]
13878                                           ! Debug: list unsigned int = ax+5 (used reg = )
13879 3C48           05                   0005  add	ax,*5
13880 3C4B           50                         push	ax
13881                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13882 3C4C           E8         C8A9            call	_inb
13883 3C4F           44                         inc	sp
13884 3C50           44                         inc	sp
13885                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
13886 3C51           8846         13            mov	$13[bp],al
13887                                           !BCC_EOS
13888                                           ! 2571           regs.u.r8.al = inb(addr);
13889                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
13890 3C54           FF76         FE            push	-2[bp]
13891                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13892 3C57           E8         C89E            call	_inb
13893 3C5A           44                         inc	sp
13894 3C5B           44                         inc	sp
13895                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
13896 3C5C           8846         12            mov	$12[bp],al
13897                                           !BCC_EOS
13898                                           ! 2572         } else {
13899 3C5F           EB           05            jmp .355
13900                       00003C61            .353:
13901                                           ! 2573           regs.u.r8.ah = 0x80;
13902                                           ! Debug: eq int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
13903 3C61           B0                     80  mov	al,#$80
13904 3C63           8846         13            mov	$13[bp],al
13905                                           !BCC_EOS
13906                                           ! 2574         }
13907                                           ! 2575         iret_addr.flags.u.r8.flagsl &= 0xfe;
13908                       00003C66            .355:
13909                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
13910 3C66           8A46         1A            mov	al,$1A[bp]
13911 3C69           24                     FE  and	al,#$FE
13912 3C6B           8846         1A            mov	$1A[bp],al
13913                                           !BCC_EOS
13914                                           ! 2576         break;
13915 3C6E           EB           4A            jmp .339
13916                                           !BCC_EOS
13917                                           ! 2577       case 3:
13918                                           ! 2578         regs.u.r8.ah = inb(addr+5);
13919                       00003C70            .356:
13920                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13921 3C70           8B46         FE            mov	ax,-2[bp]
13922                                           ! Debug: list unsigned int = ax+5 (used reg = )
13923 3C73           05                   0005  add	ax,*5
13924 3C76           50                         push	ax
13925                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13926 3C77           E8         C87E            call	_inb
13927 3C7A           44                         inc	sp
13928 3C7B           44                         inc	sp
13929                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
13930 3C7C           8846         13            mov	$13[bp],al
13931                                           !BCC_EOS
13932                                           ! 2579         regs.u.r8.al = inb(addr+6);
13933                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
13934 3C7F           8B46         FE            mov	ax,-2[bp]
13935                                           ! Debug: list unsigned int = ax+6 (used reg = )
13936 3C82           05                   0006  add	ax,*6
13937 3C85           50                         push	ax
13938                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13939 3C86           E8         C86F            call	_inb
13940 3C89           44                         inc	sp
13941 3C8A           44                         inc	sp
13942                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
13943 3C8B           8846         12            mov	$12[bp],al
13944                                           !BCC_EOS
13945                                           ! 2580         iret_addr.flags.u.r8.flagsl &= 0xfe;
13946                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
13947 3C8E           8A46         1A            mov	al,$1A[bp]
13948 3C91           24                     FE  and	al,#$FE
13949 3C93           8846         1A            mov	$1A[bp],al
13950                                           !BCC_EOS
13951                                           ! 2581         break;
13952 3C96           EB           22            jmp .339
13953                                           !BCC_EOS
13954                                           ! 2582       default:
13955                                           ! 2583         iret_addr.flags.u.r8.flagsl |= 0x01;
13956                       00003C98            .357:
13957                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
13958 3C98           8A46         1A            mov	al,$1A[bp]
13959 3C9B           0C                     01  or	al,*1
13960 3C9D           8846         1A            mov	$1A[bp],al
13961                                           !BCC_EOS
13962                                           ! 2584       }
13963                                           ! 2585   } else {
13964 3CA0           EB           18            jmp .339
13965                       00003CA2            .33B:
13966 3CA2           2C                     00  sub	al,*0
13967 3CA4         0F84         FE2D            beq 	.33C
13968 3CA8           2C                     01  sub	al,*1
13969 3CAA         0F84         FEE1            beq 	.340
13970 3CAE           2C                     01  sub	al,*1
13971 3CB0         0F84         FF4E            beq 	.34B
13972 3CB4           2C                     01  sub	al,*1
13973 3CB6           74           B8            je 	.356
13974 3CB8           EB           DE            jmp	.357
13975                       00003CBA            .339:
13976                       FFFFFFF6            ..FFF8	=	-$A
13977 3CBA           EB           08            jmp .358
13978                       00003CBC            .336:
13979                                           ! 2586     iret_addr.flags.u.r8.flagsl |= 0x01;
13980                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
13981 3CBC           8A46         1A            mov	al,$1A[bp]
13982 3CBF           0C                     01  or	al,*1
13983 3CC1           8846         1A            mov	$1A[bp],al
13984                                           !BCC_EOS
13985                                           ! 2587   }
13986                                           ! 2588 }
13987                       00003CC4            .358:
13988 3CC4           89EC                       mov	sp,bp
13989 3CC6           5D                         pop	bp
13990 3CC7           C3                         ret
13991                                           ! 2589   void
13992                                           ! Register BX used in function int14_function
13993                                           ! 2590 int15_function(regs, ES, DS, FLAGS)
13994                                           ! 2591   pusha_regs_t regs;
13995                                           export	_int15_function
13996                       00003CC8            _int15_function:
13997                                           !BCC_EOS
13998                                           ! 2592   Bit16u ES, DS, FLAGS;
13999                                           !BCC_EOS
14000                                           ! 2593 {
14001                                           ! 2594   Bit16u ebda_seg=get_ebda_seg();
14002 3CC8           55                         push	bp
14003 3CC9           89E5                       mov	bp,sp
14004 3CCB           4C                         dec	sp
14005 3CCC           4C                         dec	sp
14006                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
14007 3CCD           E8         C99C            call	_get_ebda_seg
14008                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
14009 3CD0           8946         FE            mov	-2[bp],ax
14010                                           !BCC_EOS
14011                                           ! 2595   bx_bool prev_a20_enable;
14012                                           !BCC_EOS
14013                                           ! 2596   Bit16u base15_00;
14014                                           !BCC_EOS
14015                                           ! 2597   Bit8u base23_16;
14016                                           !BCC_EOS
14017                                           ! 2598   Bit16u ss;
14018                                           !BCC_EOS
14019                                           ! 2599   Bit16u BX,CX,DX;
14020                                           !BCC_EOS
14021                                           ! 2600   Bit16u bRegister;
14022                                           !BCC_EOS
14023                                           ! 2601   Bit8u irqDisable;
14024                                           !BCC_EOS
14025                                           ! 2602 ;
14026 3CD3           83C4                   EE  add	sp,*-$12
14027                                           !BCC_EOS
14028                                           ! 2603   switch (regs.u.r8.ah) {
14029 3CD6           8A46         13            mov	al,$13[bp]
14030 3CD9           E9         0488            br 	.35B
14031                                           ! 2604     case 0x24:
14032                                           ! 2605       switch (regs.u.r8.al) {
14033                       00003CDC            .35C:
14034 3CDC           8A46         12            mov	al,$12[bp]
14035 3CDF           E9         0074            br 	.35F
14036                                           ! 2606         case 0x00:
14037                                           ! 2607         case 0x01:
14038                       00003CE2            .360:
14039                                           ! 2608           set_enable_a20(regs.u.r8.al);
14040                       00003CE2            .361:
14041                                           ! Debug: list unsigned char regs = [S+$16+$10] (used reg = )
14042 3CE2           8A46         12            mov	al,$12[bp]
14043 3CE5           30E4                       xor	ah,ah
14044 3CE7           50                         push	ax
14045                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
14046 3CE8           E8         DA4D            call	_set_enable_a20
14047 3CEB           44                         inc	sp
14048 3CEC           44                         inc	sp
14049                                           !BCC_EOS
14050                                           ! 2609           FLAGS &= 0xfffe;
14051                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14052 3CED           8B46         18            mov	ax,$18[bp]
14053 3CF0           24                     FE  and	al,#$FE
14054 3CF2           8946         18            mov	$18[bp],ax
14055                                           !BCC_EOS
14056                                           ! 2610           regs.u.r8.ah = 0;
14057                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
14058 3CF5           30C0                       xor	al,al
14059 3CF7           8846         13            mov	$13[bp],al
14060                                           !BCC_EOS
14061                                           ! 2611           break;
14062 3CFA           E9         006B            br 	.35D
14063                                           !BCC_EOS
14064                                           ! 2612         case 0x02:
14065                                           ! 2613           regs.u.r8.al = (inb(0x0092) >> 1) & 0x01;
14066                       00003CFD            .362:
14067                                           ! Debug: list int = const $92 (used reg = )
14068 3CFD           B8                   0092  mov	ax,#$92
14069 3D00           50                         push	ax
14070                                           ! Debug: func () unsigned char = inb+0 (used reg = )
14071 3D01           E8         C7F4            call	_inb
14072 3D04           44                         inc	sp
14073 3D05           44                         inc	sp
14074                                           ! Debug: sr int = const 1 to unsigned char = al+0 (used reg = )
14075 3D06           30E4                       xor	ah,ah
14076 3D08           D1E8                       shr	ax,*1
14077                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
14078 3D0A           24                     01  and	al,*1
14079                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$16+$10] (used reg = )
14080 3D0C           8846         12            mov	$12[bp],al
14081                                           !BCC_EOS
14082                                           ! 2614           FLAGS &= 0xfffe;
14083                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14084 3D0F           8B46         18            mov	ax,$18[bp]
14085 3D12           24                     FE  and	al,#$FE
14086 3D14           8946         18            mov	$18[bp],ax
14087                                           !BCC_EOS
14088                                           ! 2615           regs.u.r8.ah = 0;
14089                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
14090 3D17           30C0                       xor	al,al
14091 3D19           8846         13            mov	$13[bp],al
14092                                           !BCC_EOS
14093                                           ! 2616           break;
14094 3D1C           EB           4A            jmp .35D
14095                                           !BCC_EOS
14096                                           ! 2617         case 0x03:
14097                                           ! 2618           FLAGS &= 0xfffe;
14098                       00003D1E            .363:
14099                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14100 3D1E           8B46         18            mov	ax,$18[bp]
14101 3D21           24                     FE  and	al,#$FE
14102 3D23           8946         18            mov	$18[bp],ax
14103                                           !BCC_EOS
14104                                           ! 2619           regs.u.r8.ah = 0;
14105                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
14106 3D26           30C0                       xor	al,al
14107 3D28           8846         13            mov	$13[bp],al
14108                                           !BCC_EOS
14109                                           ! 2620           regs.u.r16.bx = 3;
14110                                           ! Debug: eq int = const 3 to unsigned short regs = [S+$16+$A] (used reg = )
14111 3D2B           B8                   0003  mov	ax,*3
14112 3D2E           8946         0C            mov	$C[bp],ax
14113                                           !BCC_EOS
14114                                           ! 2621           break;
14115 3D31           EB           35            jmp .35D
14116                                           !BCC_EOS
14117                                           ! 2622         default:
14118                                           ! 2623           bios_printf(4, "int15: Func 24h, subfunc %02xh, A20 gate control not supported\n", (unsigned) regs.u.r8.al);
14119                       00003D33            .364:
14120                                           ! Debug: list unsigned char regs = [S+$16+$10] (used reg = )
14121 3D33           8A46         12            mov	al,$12[bp]
14122 3D36           30E4                       xor	ah,ah
14123 3D38           50                         push	ax
14124                                           ! Debug: list * char = .365+0 (used reg = )
14125 3D39           BB                   D576  mov	bx,#.365
14126 3D3C           53                         push	bx
14127                                           ! Debug: list int = const 4 (used reg = )
14128 3D3D           B8                   0004  mov	ax,*4
14129 3D40           50                         push	ax
14130                                           ! Debug: func () void = bios_printf+0 (used reg = )
14131 3D41           E8         CBFA            call	_bios_printf
14132 3D44           83C4                   06  add	sp,*6
14133                                           !BCC_EOS
14134                                           ! 2624           FLAGS |= 0x0001;
14135                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
14136 3D47           8B46         18            mov	ax,$18[bp]
14137 3D4A           0C                     01  or	al,*1
14138 3D4C           8946         18            mov	$18[bp],ax
14139                                           !BCC_EOS
14140                                           ! 2625           regs.u.r8.ah = 0x86
14141                                           ! 2625 ;
14142                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
14143 3D4F           B0                     86  mov	al,#$86
14144 3D51           8846         13            mov	$13[bp],al
14145                                           !BCC_EOS
14146                                           ! 2626       }
14147                                           ! 2627       break;
14148 3D54           EB           12            jmp .35D
14149                       00003D56            .35F:
14150 3D56           2C                     00  sub	al,*0
14151 3D58           74           88            je 	.360
14152 3D5A           2C                     01  sub	al,*1
14153 3D5C           74           84            je 	.361
14154 3D5E           2C                     01  sub	al,*1
14155 3D60           74           9B            je 	.362
14156 3D62           2C                     01  sub	al,*1
14157 3D64           74           B8            je 	.363
14158 3D66           EB           CB            jmp	.364
14159                       00003D68            .35D:
14160 3D68           E9         0443            br 	.359
14161                                           !BCC_EOS
14162                                           ! 2628     case 0x41:
14163                                           ! 2629       FLAGS |= 0x0001;
14164                       00003D6B            .366:
14165                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
14166 3D6B           8B46         18            mov	ax,$18[bp]
14167 3D6E           0C                     01  or	al,*1
14168 3D70           8946         18            mov	$18[bp],ax
14169                                           !BCC_EOS
14170                                           ! 2630       regs.u.r8.ah = 0x86;
14171                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
14172 3D73           B0                     86  mov	al,#$86
14173 3D75           8846         13            mov	$13[bp],al
14174                                           !BCC_EOS
14175                                           ! 2631       break;
14176 3D78           E9         0433            br 	.359
14177                                           !BCC_EOS
14178                                           ! 2632     case 0x4f:
14179                                           ! 2633       FLAGS |= 0x0001;
14180                       00003D7B            .367:
14181                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
14182 3D7B           8B46         18            mov	ax,$18[bp]
14183 3D7E           0C                     01  or	al,*1
14184 3D80           8946         18            mov	$18[bp],ax
14185                                           !BCC_EOS
14186                                           ! 2634       break;
14187 3D83           E9         0428            br 	.359
14188                                           !BCC_EOS
14189                                           ! 2635     case 0x52:
14190                                           ! 2636       FLAGS &= 0xfffe;
14191                       00003D86            .368:
14192                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14193 3D86           8B46         18            mov	ax,$18[bp]
14194 3D89           24                     FE  and	al,#$FE
14195 3D8B           8946         18            mov	$18[bp],ax
14196                                           !BCC_EOS
14197                                           ! 2637       regs.u.r8.ah = 0;
14198                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
14199 3D8E           30C0                       xor	al,al
14200 3D90           8846         13            mov	$13[bp],al
14201                                           !BCC_EOS
14202                                           ! 2638       break;
14203 3D93           E9         0418            br 	.359
14204                                           !BCC_EOS
14205                                           ! 2639     case 0x83: {
14206                       00003D96            .369:
14207                                           ! 2640       set_DS(0x40);
14208                                           ! Debug: list int = const $40 (used reg = )
14209 3D96           B8                   0040  mov	ax,*$40
14210 3D99           50                         push	ax
14211                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
14212 3D9A           E8         C8C5            call	_set_DS
14213 3D9D           44                         inc	sp
14214 3D9E           44                         inc	sp
14215                                           !BCC_EOS
14216                                           ! 2641       if( regs.u.r8.al == 0 ) {
14217                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+$16+$10] (used reg = )
14218 3D9F           8A46         12            mov	al,$12[bp]
14219 3DA2           84C0                       test	al,al
14220 3DA4         0F85         007D            bne 	.36A
14221                       00003DA8            .36B:
14222                                           ! 2642         if( ( *((Bit8u *)(0xA0)) & 1 ) == 0 ) {
14223                                           ! Debug: and int = const 1 to unsigned char = [+$A0] (used reg = )
14224 3DA8           A0         00A0            mov	al,[$A0]
14225 3DAB           24                     01  and	al,*1
14226                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
14227 3DAD           84C0                       test	al,al
14228 3DAF         0F85         0063            bne 	.36C
14229                       00003DB3            .36D:
14230                                           ! 2643           *((Bit8u *)(0xA0)) = (1);
14231                                           ! Debug: eq int = const 1 to unsigned char = [+$A0] (used reg = )
14232 3DB3           B0                     01  mov	al,*1
14233 3DB5           A2         00A0            mov	[$A0],al
14234                                           !BCC_EOS
14235                                           ! 2644           *((Bit16u *)(0x98)) = (ES);
14236                                           ! Debug: eq unsigned short ES = [S+$16+$12] to unsigned short = [+$98] (used reg = )
14237 3DB8           8B46         14            mov	ax,$14[bp]
14238 3DBB           A3         0098            mov	[$98],ax
14239                                           !BCC_EOS
14240                                           ! 2645           *((Bit16u *)(0x9A)) = (regs.u.r16.bx);
14241                                           ! Debug: eq unsigned short regs = [S+$16+$A] to unsigned short = [+$9A] (used reg = )
14242 3DBE           8B46         0C            mov	ax,$C[bp]
14243 3DC1           A3         009A            mov	[$9A],ax
14244                                           !BCC_EOS
14245                                           ! 2646           *((Bit16u *)(0x9C)) = (regs.u.r16.dx);
14246                                           ! Debug: eq unsigned short regs = [S+$16+$C] to unsigned short = [+$9C] (used reg = )
14247 3DC4           8B46         0E            mov	ax,$E[bp]
14248 3DC7           A3         009C            mov	[$9C],ax
14249                                           !BCC_EOS
14250                                           ! 2647           *((Bit16u *)(0x9E)) = (regs.u.r16.cx);
14251                                           ! Debug: eq unsigned short regs = [S+$16+$E] to unsigned short = [+$9E] (used reg = )
14252 3DCA           8B46         10            mov	ax,$10[bp]
14253 3DCD           A3         009E            mov	[$9E],ax
14254                                           !BCC_EOS
14255                                           ! 2648           FLAGS &= 0xfffe;
14256                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14257 3DD0           8B46         18            mov	ax,$18[bp]
14258 3DD3           24                     FE  and	al,#$FE
14259 3DD5           8946         18            mov	$18[bp],ax
14260                                           !BCC_EOS
14261                                           ! 2649           irqDisable = inb( 0x00a1 );
14262                                           ! Debug: list int = const $A1 (used reg = )
14263 3DD8           B8                   00A1  mov	ax,#$A1
14264 3DDB           50                         push	ax
14265                                           ! Debug: func () unsigned char = inb+0 (used reg = )
14266 3DDC           E8         C719            call	_inb
14267 3DDF           44                         inc	sp
14268 3DE0           44                         inc	sp
14269                                           ! Debug: eq unsigned char = al+0 to unsigned char irqDisable = [S+$16-$15] (used reg = )
14270 3DE1           8846         ED            mov	-$13[bp],al
14271                                           !BCC_EOS
14272                                           ! 2650           outb( 0x00a1, irqDisable & 0xFE );
14273                                           ! Debug: and int = const $FE to unsigned char irqDisable = [S+$16-$15] (used reg = )
14274 3DE4           8A46         ED            mov	al,-$13[bp]
14275 3DE7           24                     FE  and	al,#$FE
14276                                           ! Debug: list unsigned char = al+0 (used reg = )
14277 3DE9           30E4                       xor	ah,ah
14278 3DEB           50                         push	ax
14279                                           ! Debug: list int = const $A1 (used reg = )
14280 3DEC           B8                   00A1  mov	ax,#$A1
14281 3DEF           50                         push	ax
14282                                           ! Debug: func () void = outb+0 (used reg = )
14283 3DF0           E8         C71B            call	_outb
14284 3DF3           83C4                   04  add	sp,*4
14285                                           !BCC_EOS
14286                                           ! 2651           bRegister = inb_cmos( 0xB );
14287                                           ! Debug: list int = const $B (used reg = )
14288 3DF6           B8                   000B  mov	ax,*$B
14289 3DF9           50                         push	ax
14290                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
14291 3DFA           E8         C740            call	_inb_cmos
14292 3DFD           44                         inc	sp
14293 3DFE           44                         inc	sp
14294                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$16-$14] (used reg = )
14295 3DFF           30E4                       xor	ah,ah
14296 3E01           8946         EE            mov	-$12[bp],ax
14297                                           !BCC_EOS
14298                                           ! 2652           outb_cmos( 0xB, bRegister | 0x40 );
14299                                           ! Debug: or int = const $40 to unsigned short bRegister = [S+$16-$14] (used reg = )
14300 3E04           8B46         EE            mov	ax,-$12[bp]
14301 3E07           0C                     40  or	al,*$40
14302                                           ! Debug: list unsigned int = ax+0 (used reg = )
14303 3E09           50                         push	ax
14304                                           ! Debug: list int = const $B (used reg = )
14305 3E0A           B8                   000B  mov	ax,*$B
14306 3E0D           50                         push	ax
14307                                           ! Debug: func () void = outb_cmos+0 (used reg = )
14308 3E0E           E8         C71D            call	_outb_cmos
14309 3E11           83C4                   04  add	sp,*4
14310                                           !BCC_EOS
14311                                           ! 2653         } else {
14312 3E14           EB           0D            jmp .36E
14313                       00003E16            .36C:
14314                                           ! 2654           ;
14315                                           !BCC_EOS
14316                                           ! 2655           FLAGS |= 0x0001;
14317                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
14318 3E16           8B46         18            mov	ax,$18[bp]
14319 3E19           0C                     01  or	al,*1
14320 3E1B           8946         18            mov	$18[bp],ax
14321                                           !BCC_EOS
14322                                           ! 2656           regs.u.r8.ah = 0x86;
14323                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
14324 3E1E           B0                     86  mov	al,#$86
14325 3E20           8846         13            mov	$13[bp],al
14326                                           !BCC_EOS
14327                                           ! 2657         }
14328                                           ! 2658       } else if( regs.u.r8.al == 1 ) {
14329                       00003E23            .36E:
14330 3E23           EB           48            jmp .36F
14331                       00003E25            .36A:
14332                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$16+$10] (used reg = )
14333 3E25           8A46         12            mov	al,$12[bp]
14334 3E28           3C                     01  cmp	al,*1
14335 3E2A           75           2D            jne 	.370
14336                       00003E2C            .371:
14337                                           ! 2659         *((Bit8u *)(0xA0)) = (0);
14338                                           ! Debug: eq int = const 0 to unsigned char = [+$A0] (used reg = )
14339 3E2C           30C0                       xor	al,al
14340 3E2E           A2         00A0            mov	[$A0],al
14341                                           !BCC_EOS
14342                                           ! 2660         FLAGS &= 0xfffe;
14343                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14344 3E31           8B46         18            mov	ax,$18[bp]
14345 3E34           24                     FE  and	al,#$FE
14346 3E36           8946         18            mov	$18[bp],ax
14347                                           !BCC_EOS
14348                                           ! 2661         bRegister = inb_cmos( 0xB );
14349                                           ! Debug: list int = const $B (used reg = )
14350 3E39           B8                   000B  mov	ax,*$B
14351 3E3C           50                         push	ax
14352                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
14353 3E3D           E8         C6FD            call	_inb_cmos
14354 3E40           44                         inc	sp
14355 3E41           44                         inc	sp
14356                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$16-$14] (used reg = )
14357 3E42           30E4                       xor	ah,ah
14358 3E44           8946         EE            mov	-$12[bp],ax
14359                                           !BCC_EOS
14360                                           ! 2662         outb_cmos( 0xB, bRegister & ~0x40 );
14361                                           ! Debug: and int = const -$41 to unsigned short bRegister = [S+$16-$14] (used reg = )
14362 3E47           8B46         EE            mov	ax,-$12[bp]
14363 3E4A           24                     BF  and	al,#$BF
14364                                           ! Debug: list unsigned int = ax+0 (used reg = )
14365 3E4C           50                         push	ax
14366                                           ! Debug: list int = const $B (used reg = )
14367 3E4D           B8                   000B  mov	ax,*$B
14368 3E50           50                         push	ax
14369                                           ! Debug: func () void = outb_cmos+0 (used reg = )
14370 3E51           E8         C6DA            call	_outb_cmos
14371 3E54           83C4                   04  add	sp,*4
14372                                           !BCC_EOS
14373                                           ! 2663       } else {
14374 3E57           EB           14            jmp .372
14375                       00003E59            .370:
14376                                           ! 2664         ;
14377                                           !BCC_EOS
14378                                           ! 2665         FLAGS |= 0x0001;
14379                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
14380 3E59           8B46         18            mov	ax,$18[bp]
14381 3E5C           0C                     01  or	al,*1
14382 3E5E           8946         18            mov	$18[bp],ax
14383                                           !BCC_EOS
14384                                           ! 2666         regs.u.r8.ah = 0x86;
14385                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
14386 3E61           B0                     86  mov	al,#$86
14387 3E63           8846         13            mov	$13[bp],al
14388                                           !BCC_EOS
14389                                           ! 2667         regs.u.r8.al--;
14390                                           ! Debug: postdec unsigned char regs = [S+$16+$10] (used reg = )
14391 3E66           8A46         12            mov	al,$12[bp]
14392 3E69           48                         dec	ax
14393 3E6A           8846         12            mov	$12[bp],al
14394                                           !BCC_EOS
14395                                           ! 2668       }
14396                                           ! 2669       break;
14397                       00003E6D            .372:
14398                       00003E6D            .36F:
14399 3E6D           E9         033E            br 	.359
14400                                           !BCC_EOS
14401                                           ! 2670     }
14402                                           ! 2671     case 0x87:
14403                                           ! 2672 #asm
14404                       00003E70            .373:
14405                                           !BCC_EOS
14406                                           !BCC_ASM
14407                       00000006            _int15_function.CX	set	6
14408                       FFFFFFF2            .int15_function.CX	set	-$E
14409                       0000002C            _int15_function.FLAGS	set	$2C
14410                       00000018            .int15_function.FLAGS	set	$18
14411                       00000001            _int15_function.irqDisable	set	1
14412                       FFFFFFED            .int15_function.irqDisable	set	-$13
14413                       0000002A            _int15_function.DS	set	$2A
14414                       00000016            .int15_function.DS	set	$16
14415                       00000004            _int15_function.DX	set	4
14416                       FFFFFFF0            .int15_function.DX	set	-$10
14417                       0000000D            _int15_function.base23_16	set	$D
14418                       FFFFFFF9            .int15_function.base23_16	set	-7
14419                       00000002            _int15_function.bRegister	set	2
14420                       FFFFFFEE            .int15_function.bRegister	set	-$12
14421                       00000028            _int15_function.ES	set	$28
14422                       00000014            .int15_function.ES	set	$14
14423                       00000012            _int15_function.ebda_seg	set	$12
14424                       FFFFFFFE            .int15_function.ebda_seg	set	-2
14425                       0000000E            _int15_function.base15_00	set	$E
14426                       FFFFFFFA            .int15_function.base15_00	set	-6
14427                       0000000A            _int15_function.ss	set	$A
14428                       FFFFFFF6            .int15_function.ss	set	-$A
14429                       00000008            _int15_function.BX	set	8
14430                       FFFFFFF4            .int15_function.BX	set	-$C
14431                       00000018            _int15_function.regs	set	$18
14432                       00000004            .int15_function.regs	set	4
14433                       00000010            _int15_function.prev_a20_enable	set	$10
14434                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
14435 3E70           FA                           cli
14436                                           ! 2674 endasm
14437                                           !BCC_ENDASM
14438                                           !BCC_EOS
14439                                           ! 2675       prev_a20_enable = set_enable_a20(1);
14440                                           ! Debug: list int = const 1 (used reg = )
14441 3E71           B8                   0001  mov	ax,*1
14442 3E74           50                         push	ax
14443                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
14444 3E75           E8         D8C0            call	_set_enable_a20
14445 3E78           44                         inc	sp
14446 3E79           44                         inc	sp
14447                                           ! Debug: eq unsigned short = ax+0 to unsigned short prev_a20_enable = [S+$16-6] (used reg = )
14448 3E7A           8946         FC            mov	-4[bp],ax
14449                                           !BCC_EOS
14450                                           ! 2676       base15_00 = (ES << 4) + regs.u.r16.si;
14451                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$16+$12] (used reg = )
14452 3E7D           8B46         14            mov	ax,$14[bp]
14453 3E80           B1                     04  mov	cl,*4
14454 3E82           D3E0                       shl	ax,cl
14455                                           ! Debug: add unsigned short regs = [S+$16+4] to unsigned int = ax+0 (used reg = )
14456 3E84           0346         06            add	ax,6[bp]
14457                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$16-8] (used reg = )
14458 3E87           8946         FA            mov	-6[bp],ax
14459                                           !BCC_EOS
14460                                           ! 2677       base23_16 = ES >> 12;
14461                                           ! Debug: sr int = const $C to unsigned short ES = [S+$16+$12] (used reg = )
14462 3E8A           8B46         14            mov	ax,$14[bp]
14463 3E8D           88E0                       mov	al,ah
14464 3E8F           30E4                       xor	ah,ah
14465 3E91           B1                     04  mov	cl,*4
14466 3E93           D3E8                       shr	ax,cl
14467                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$16-9] (used reg = )
14468 3E95           8846         F9            mov	-7[bp],al
14469                                           !BCC_EOS
14470                                           ! 2678       if (base15_00 < (ES<<4))
14471                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$16+$12] (used reg = )
14472 3E98           8B46         14            mov	ax,$14[bp]
14473 3E9B           B1                     04  mov	cl,*4
14474 3E9D           D3E0                       shl	ax,cl
14475                                           ! Debug: lt unsigned int = ax+0 to unsigned short base15_00 = [S+$16-8] (used reg = )
14476 3E9F           3B46         FA            cmp	ax,-6[bp]
14477 3EA2           76           07            jbe 	.374
14478                       00003EA4            .375:
14479                                           ! 2679         base23_16++;
14480                                           ! Debug: postinc unsigned char base23_16 = [S+$16-9] (used reg = )
14481 3EA4           8A46         F9            mov	al,-7[bp]
14482 3EA7           40                         inc	ax
14483 3EA8           8846         F9            mov	-7[bp],al
14484                                           !BCC_EOS
14485                                           ! 2680       set_DS(ES);
14486                       00003EAB            .374:
14487                                           ! Debug: list unsigned short ES = [S+$16+$12] (used reg = )
14488 3EAB           FF76         14            push	$14[bp]
14489                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
14490 3EAE           E8         C7B1            call	_set_DS
14491 3EB1           44                         inc	sp
14492 3EB2           44                         inc	sp
14493                                           !BCC_EOS
14494                                           ! 2681       *((Bit16u *)(regs.u.r16.si+0x08+0)) = (47);
14495                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
14496 3EB3           8B46         06            mov	ax,6[bp]
14497                                           ! Debug: add int = const 0 to unsigned int = ax+8 (used reg = )
14498                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+8 (used reg = )
14499 3EB6           89C3                       mov	bx,ax
14500                                           ! Debug: eq int = const $2F to unsigned short = [bx+8] (used reg = )
14501 3EB8           B8                   002F  mov	ax,*$2F
14502 3EBB           8947         08            mov	8[bx],ax
14503                                           !BCC_EOS
14504                                           ! 2682       *((Bit16u *)(regs.u.r16.si+0x08+2)) = (base15_00);
14505                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
14506 3EBE           8B46         06            mov	ax,6[bp]
14507                                           ! Debug: add int = const 2 to unsigned int = ax+8 (used reg = )
14508                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$A (used reg = )
14509 3EC1           89C3                       mov	bx,ax
14510                                           ! Debug: eq unsigned short base15_00 = [S+$16-8] to unsigned short = [bx+$A] (used reg = )
14511 3EC3           8B46         FA            mov	ax,-6[bp]
14512 3EC6           8947         0A            mov	$A[bx],ax
14513                                           !BCC_EOS
14514                                           ! 2683       *((Bit8u *)(regs.u.r16.si+0x08+4)) = (base23_16);
14515                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
14516 3EC9           8B46         06            mov	ax,6[bp]
14517                                           ! Debug: add int = const 4 to unsigned int = ax+8 (used reg = )
14518                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$C (used reg = )
14519 3ECC           89C3                       mov	bx,ax
14520                                           ! Debug: eq unsigned char base23_16 = [S+$16-9] to unsigned char = [bx+$C] (used reg = )
14521 3ECE           8A46         F9            mov	al,-7[bp]
14522 3ED1           8847         0C            mov	$C[bx],al
14523                                           !BCC_EOS
14524                                           ! 2684       *((Bit8u *)(regs.u.r16.si+0x08+5)) = (0x93);
14525                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
14526 3ED4           8B46         06            mov	ax,6[bp]
14527                                           ! Debug: add int = const 5 to unsigned int = ax+8 (used reg = )
14528                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$D (used reg = )
14529 3ED7           89C3                       mov	bx,ax
14530                                           ! Debug: eq int = const $93 to unsigned char = [bx+$D] (used reg = )
14531 3ED9           B0                     93  mov	al,#$93
14532 3EDB           8847         0D            mov	$D[bx],al
14533                                           !BCC_EOS
14534                                           ! 2685       *((Bit16u *)(regs.u.r16.si+0x08+6)) = (0x0000);
14535                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
14536 3EDE           8B46         06            mov	ax,6[bp]
14537                                           ! Debug: add int = const 6 to unsigned int = ax+8 (used reg = )
14538                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$E (used reg = )
14539 3EE1           89C3                       mov	bx,ax
14540                                           ! Debug: eq int = const 0 to unsigned short = [bx+$E] (used reg = )
14541 3EE3           31C0                       xor	ax,ax
14542 3EE5           8947         0E            mov	$E[bx],ax
14543                                           !BCC_EOS
14544                                           ! 2686       *((Bit16u *)(regs.u.r16.si+0x20+0)) = (0xffff);
14545                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
14546 3EE8           8B46         06            mov	ax,6[bp]
14547                                           ! Debug: add int = const 0 to unsigned int = ax+$20 (used reg = )
14548                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$20 (used reg = )
14549 3EEB           89C3                       mov	bx,ax
14550                                           ! Debug: eq unsigned int = const $FFFF to unsigned short = [bx+$20] (used reg = )
14551 3EED           B8                   FFFF  mov	ax,#$FFFF
14552 3EF0           8947         20            mov	$20[bx],ax
14553                                           !BCC_EOS
14554                                           ! 2687       *((Bit16u *)(regs.u.r16.si+0x20+2)) = (0x0000);
14555                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
14556 3EF3           8B46         06            mov	ax,6[bp]
14557                                           ! Debug: add int = const 2 to unsigned int = ax+$20 (used reg = )
14558                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$22 (used reg = )
14559 3EF6           89C3                       mov	bx,ax
14560                                           ! Debug: eq int = const 0 to unsigned short = [bx+$22] (used reg = )
14561 3EF8           31C0                       xor	ax,ax
14562 3EFA           8947         22            mov	$22[bx],ax
14563                                           !BCC_EOS
14564                                           ! 2688       *((Bit8u *)(regs.u.r16.si+0x20+4)) = (0x000f);
14565                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
14566 3EFD           8B46         06            mov	ax,6[bp]
14567                                           ! Debug: add int = const 4 to unsigned int = ax+$20 (used reg = )
14568                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$24 (used reg = )
14569 3F00           89C3                       mov	bx,ax
14570                                           ! Debug: eq int = const $F to unsigned char = [bx+$24] (used reg = )
14571 3F02           B0                     0F  mov	al,*$F
14572 3F04           8847         24            mov	$24[bx],al
14573                                           !BCC_EOS
14574                                           ! 2689       *((Bit8u *)(regs.u.r16.si+0x20+5)) = (0x9b);
14575                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
14576 3F07           8B46         06            mov	ax,6[bp]
14577                                           ! Debug: add int = const 5 to unsigned int = ax+$20 (used reg = )
14578                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$25 (used reg = )
14579 3F0A           89C3                       mov	bx,ax
14580                                           ! Debug: eq int = const $9B to unsigned char = [bx+$25] (used reg = )
14581 3F0C           B0                     9B  mov	al,#$9B
14582 3F0E           8847         25            mov	$25[bx],al
14583                                           !BCC_EOS
14584                                           ! 2690       *((Bit16u *)(regs.u.r16.si+0x20+6)) = (0x0000);
14585                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
14586 3F11           8B46         06            mov	ax,6[bp]
14587                                           ! Debug: add int = const 6 to unsigned int = ax+$20 (used reg = )
14588                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$26 (used reg = )
14589 3F14           89C3                       mov	bx,ax
14590                                           ! Debug: eq int = const 0 to unsigned short = [bx+$26] (used reg = )
14591 3F16           31C0                       xor	ax,ax
14592 3F18           8947         26            mov	$26[bx],ax
14593                                           !BCC_EOS
14594                                           ! 2691       ss = get_SS();
14595                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14596 3F1B           E8         C741            call	_get_SS
14597                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$C] (used reg = )
14598 3F1E           8946         F6            mov	-$A[bp],ax
14599                                           !BCC_EOS
14600                                           ! 2692       base15_00 = ss << 4;
14601                                           ! Debug: sl int = const 4 to unsigned short ss = [S+$16-$C] (used reg = )
14602 3F21           8B46         F6            mov	ax,-$A[bp]
14603 3F24           B1                     04  mov	cl,*4
14604 3F26           D3E0                       shl	ax,cl
14605                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$16-8] (used reg = )
14606 3F28           8946         FA            mov	-6[bp],ax
14607                                           !BCC_EOS
14608                                           ! 2693       base23_16 = ss >> 12;
14609                                           ! Debug: sr int = const $C to unsigned short ss = [S+$16-$C] (used reg = )
14610 3F2B           8B46         F6            mov	ax,-$A[bp]
14611 3F2E           88E0                       mov	al,ah
14612 3F30           30E4                       xor	ah,ah
14613 3F32           B1                     04  mov	cl,*4
14614 3F34           D3E8                       shr	ax,cl
14615                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$16-9] (used reg = )
14616 3F36           8846         F9            mov	-7[bp],al
14617                                           !BCC_EOS
14618                                           ! 2694       *((Bit16u *)(regs.u.r16.si+0x28+0)) = (0xffff
14619                                           ! 2694 );
14620                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
14621 3F39           8B46         06            mov	ax,6[bp]
14622                                           ! Debug: add int = const 0 to unsigned int = ax+$28 (used reg = )
14623                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$28 (used reg = )
14624 3F3C           89C3                       mov	bx,ax
14625                                           ! Debug: eq unsigned int = const $FFFF to unsigned short = [bx+$28] (used reg = )
14626 3F3E           B8                   FFFF  mov	ax,#$FFFF
14627 3F41           8947         28            mov	$28[bx],ax
14628                                           !BCC_EOS
14629                                           ! 2695       *((Bit16u *)(regs.u.r16.si+0x28+2)) = (base15_00);
14630                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
14631 3F44           8B46         06            mov	ax,6[bp]
14632                                           ! Debug: add int = const 2 to unsigned int = ax+$28 (used reg = )
14633                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$2A (used reg = )
14634 3F47           89C3                       mov	bx,ax
14635                                           ! Debug: eq unsigned short base15_00 = [S+$16-8] to unsigned short = [bx+$2A] (used reg = )
14636 3F49           8B46         FA            mov	ax,-6[bp]
14637 3F4C           8947         2A            mov	$2A[bx],ax
14638                                           !BCC_EOS
14639                                           ! 2696       *((Bit8u *)(regs.u.r16.si+0x28+4)) = (base23_16);
14640                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
14641 3F4F           8B46         06            mov	ax,6[bp]
14642                                           ! Debug: add int = const 4 to unsigned int = ax+$28 (used reg = )
14643                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2C (used reg = )
14644 3F52           89C3                       mov	bx,ax
14645                                           ! Debug: eq unsigned char base23_16 = [S+$16-9] to unsigned char = [bx+$2C] (used reg = )
14646 3F54           8A46         F9            mov	al,-7[bp]
14647 3F57           8847         2C            mov	$2C[bx],al
14648                                           !BCC_EOS
14649                                           ! 2697       *((Bit8u *)(regs.u.r16.si+0x28+5)) = (0x93);
14650                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
14651 3F5A           8B46         06            mov	ax,6[bp]
14652                                           ! Debug: add int = const 5 to unsigned int = ax+$28 (used reg = )
14653                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2D (used reg = )
14654 3F5D           89C3                       mov	bx,ax
14655                                           ! Debug: eq int = const $93 to unsigned char = [bx+$2D] (used reg = )
14656 3F5F           B0                     93  mov	al,#$93
14657 3F61           8847         2D            mov	$2D[bx],al
14658                                           !BCC_EOS
14659                                           ! 2698       *((Bit16u *)(regs.u.r16.si+0x28+6)) = (0x0000);
14660                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
14661 3F64           8B46         06            mov	ax,6[bp]
14662                                           ! Debug: add int = const 6 to unsigned int = ax+$28 (used reg = )
14663                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$2E (used reg = )
14664 3F67           89C3                       mov	bx,ax
14665                                           ! Debug: eq int = const 0 to unsigned short = [bx+$2E] (used reg = )
14666 3F69           31C0                       xor	ax,ax
14667 3F6B           8947         2E            mov	$2E[bx],ax
14668                                           !BCC_EOS
14669                                           ! 2699       CX = regs.u.r16.cx;
14670                                           ! Debug: eq unsigned short regs = [S+$16+$E] to unsigned short CX = [S+$16-$10] (used reg = )
14671 3F6E           8B46         10            mov	ax,$10[bp]
14672 3F71           8946         F2            mov	-$E[bp],ax
14673                                           !BCC_EOS
14674                                           ! 2700 #asm
14675                                           !BCC_EOS
14676                                           !BCC_ASM
14677                       00000006            _int15_function.CX	set	6
14678                       FFFFFFF2            .int15_function.CX	set	-$E
14679                       0000002C            _int15_function.FLAGS	set	$2C
14680                       00000018            .int15_function.FLAGS	set	$18
14681                       00000001            _int15_function.irqDisable	set	1
14682                       FFFFFFED            .int15_function.irqDisable	set	-$13
14683                       0000002A            _int15_function.DS	set	$2A
14684                       00000016            .int15_function.DS	set	$16
14685                       00000004            _int15_function.DX	set	4
14686                       FFFFFFF0            .int15_function.DX	set	-$10
14687                       0000000D            _int15_function.base23_16	set	$D
14688                       FFFFFFF9            .int15_function.base23_16	set	-7
14689                       00000002            _int15_function.bRegister	set	2
14690                       FFFFFFEE            .int15_function.bRegister	set	-$12
14691                       00000028            _int15_function.ES	set	$28
14692                       00000014            .int15_function.ES	set	$14
14693                       00000012            _int15_function.ebda_seg	set	$12
14694                       FFFFFFFE            .int15_function.ebda_seg	set	-2
14695                       0000000E            _int15_function.base15_00	set	$E
14696                       FFFFFFFA            .int15_function.base15_00	set	-6
14697                       0000000A            _int15_function.ss	set	$A
14698                       FFFFFFF6            .int15_function.ss	set	-$A
14699                       00000008            _int15_function.BX	set	8
14700                       FFFFFFF4            .int15_function.BX	set	-$C
14701                       00000018            _int15_function.regs	set	$18
14702                       00000004            .int15_function.regs	set	4
14703                       00000010            _int15_function.prev_a20_enable	set	$10
14704                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
14705 3F74           89E3                             mov bx, sp
14706 3F76           36                               SEG SS
14707 3F77           8B4F         06                    mov cx, _int15_function.CX [bx]
14708 3F7A     66    50                               push eax
14709 3F7C     66    31C0                             xor eax, eax
14710 3F7F           8ED8                             mov ds, ax
14711 3F81           8C16       0469                  mov 0x0469, ss
14712 3F85           8926       0467                  mov 0x0467, sp
14713 3F89           26                               SEG ES
14714 3F8A         0F0154         08                    lgdt [si + 0x08]
14715 3F8E           2E                               SEG CS
14716 3F8F         0F011E       F8AB                    lidt [pmode_IDT_info]
14717                                                 ;; perhaps do something with IDT here
14718                                                 ;; set PE bit in CR0
14719 3F94         0F20C0                             mov eax, cr0
14720 3F97           0C                     01        or al, #0x01
14721 3F99         0F22C0                             mov cr0, eax
14722                                                 ;; far jump to flush CPU queue after transition to protected mode
14723                                                 JMP_AP(0x0020, protected_mode)
 +a   3F9C                        EA              db 0xea
 +a   3F9D                      3FA1              dw  protected_mode
 +a   3F9F                      0020              dw 0x0020
14724                       00003FA1            protected_mode:
14725                                                 ;; GDT points to valid descriptor table, now load SS, DS, ES
14726 3FA1           B8                   0028        mov ax, #0x28 ;; 101 000 = 5th descriptor in table, TI=GDT, RPL=00
14727 3FA4           8ED0                             mov ss, ax
14728 3FA6           B8                   0010        mov ax, #0x10 ;; 010 000 = 2nd descriptor in table, TI=GDT, RPL=00
14729 3FA9           8ED8                             mov ds, ax
14730 3FAB           B8                   0018        mov ax, #0x18 ;; 011 000 = 3rd descriptor in table, TI=GDT, RPL=00
14731 3FAE           8EC0                             mov es, ax
14732 3FB0           31F6                             xor si, si
14733 3FB2           31FF                             xor di, di
14734 3FB4           FC                               cld
14735 3FB5           F3                               rep
14736 3FB6           A5                                 movsw ;; move CX words from DS:SI to ES:DI
14737                                                 ;; make sure DS and ES limits are 64KB
14738 3FB7           B8                   0028        mov ax, #0x28
14739 3FBA           8ED8                             mov ds, ax
14740 3FBC           8EC0                             mov es, ax
14741                                                 ;; reset PG bit in CR0 ???
14742 3FBE         0F20C0                             mov eax, cr0
14743 3FC1           24                     FE        and al, #0xFE
14744 3FC3         0F22C0                             mov cr0, eax
14745                                                 ;; far jump to flush CPU queue after transition to real mode
14746                                                 JMP_AP(0xf000, real_mode)
 +a   3FC6                        EA              db 0xea
 +a   3FC7                      3FCB              dw  real_mode
 +a   3FC9                      F000              dw 0xf000
14747                       00003FCB            real_mode:
14748                                                 ;; restore IDT to normal real-mode defaults
14749 3FCB           2E                               SEG CS
14750 3FCC         0F011E       F8B1                    lidt [rmode_IDT_info]
14751 3FD1           31C0                             xor ax, ax
14752 3FD3           8ED8                             mov ds, ax
14753 3FD5           8E16       0469                  mov ss, 0x0469
14754 3FD9           8B26       0467                  mov sp, 0x0467
14755 3FDD     66    58                               pop eax
14756                                           ! 2752 endasm
14757                                           !BCC_ENDASM
14758                                           !BCC_EOS
14759                                           ! 2753       set_enable_a20(prev_a20_enable);
14760                                           ! Debug: list unsigned short prev_a20_enable = [S+$16-6] (used reg = )
14761 3FDF           FF76         FC            push	-4[bp]
14762                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
14763 3FE2           E8         D753            call	_set_enable_a20
14764 3FE5           44                         inc	sp
14765 3FE6           44                         inc	sp
14766                                           !BCC_EOS
14767                                           ! 2754 #asm
14768                                           !BCC_EOS
14769                                           !BCC_ASM
14770                       00000006            _int15_function.CX	set	6
14771                       FFFFFFF2            .int15_function.CX	set	-$E
14772                       0000002C            _int15_function.FLAGS	set	$2C
14773                       00000018            .int15_function.FLAGS	set	$18
14774                       00000001            _int15_function.irqDisable	set	1
14775                       FFFFFFED            .int15_function.irqDisable	set	-$13
14776                       0000002A            _int15_function.DS	set	$2A
14777                       00000016            .int15_function.DS	set	$16
14778                       00000004            _int15_function.DX	set	4
14779                       FFFFFFF0            .int15_function.DX	set	-$10
14780                       0000000D            _int15_function.base23_16	set	$D
14781                       FFFFFFF9            .int15_function.base23_16	set	-7
14782                       00000002            _int15_function.bRegister	set	2
14783                       FFFFFFEE            .int15_function.bRegister	set	-$12
14784                       00000028            _int15_function.ES	set	$28
14785                       00000014            .int15_function.ES	set	$14
14786                       00000012            _int15_function.ebda_seg	set	$12
14787                       FFFFFFFE            .int15_function.ebda_seg	set	-2
14788                       0000000E            _int15_function.base15_00	set	$E
14789                       FFFFFFFA            .int15_function.base15_00	set	-6
14790                       0000000A            _int15_function.ss	set	$A
14791                       FFFFFFF6            .int15_function.ss	set	-$A
14792                       00000008            _int15_function.BX	set	8
14793                       FFFFFFF4            .int15_function.BX	set	-$C
14794                       00000018            _int15_function.regs	set	$18
14795                       00000004            .int15_function.regs	set	4
14796                       00000010            _int15_function.prev_a20_enable	set	$10
14797                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
14798 3FE7           FB                           sti
14799                                           ! 2756 endasm
14800                                           !BCC_ENDASM
14801                                           !BCC_EOS
14802                                           ! 2757       regs.u.r8.ah = 0;
14803                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
14804 3FE8           30C0                       xor	al,al
14805 3FEA           8846         13            mov	$13[bp],al
14806                                           !BCC_EOS
14807                                           ! 2758       FLAGS &= 0xfffe;
14808                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14809 3FED           8B46         18            mov	ax,$18[bp]
14810 3FF0           24                     FE  and	al,#$FE
14811 3FF2           8946         18            mov	$18[bp],ax
14812                                           !BCC_EOS
14813                                           ! 2759       break;
14814 3FF5           E9         01B6            br 	.359
14815                                           !BCC_EOS
14816                                           ! 2760     case 0x88:
14817                                           ! 2761       regs.u.r8.al = inb_cmos(0x30);
14818                       00003FF8            .376:
14819                                           ! Debug: list int = const $30 (used reg = )
14820 3FF8           B8                   0030  mov	ax,*$30
14821 3FFB           50                         push	ax
14822                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
14823 3FFC           E8         C53E            call	_inb_cmos
14824 3FFF           44                         inc	sp
14825 4000           44                         inc	sp
14826                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$16+$10] (used reg = )
14827 4001           8846         12            mov	$12[bp],al
14828                                           !BCC_EOS
14829                                           ! 2762       regs.u.r8.ah = inb_cmos(0x31);
14830                                           ! Debug: list int = const $31 (used reg = )
14831 4004           B8                   0031  mov	ax,*$31
14832 4007           50                         push	ax
14833                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
14834 4008           E8         C532            call	_inb_cmos
14835 400B           44                         inc	sp
14836 400C           44                         inc	sp
14837                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$16+$11] (used reg = )
14838 400D           8846         13            mov	$13[bp],al
14839                                           !BCC_EOS
14840                                           ! 2763       if(regs.u.r16.ax > 0xffc0)
14841                                           ! Debug: gt unsigned int = const $FFC0 to unsigned short regs = [S+$16+$10] (used reg = )
14842 4010           8B46         12            mov	ax,$12[bp]
14843 4013           3D                   FFC0  cmp	ax,#$FFC0
14844 4016           76           06            jbe 	.377
14845                       00004018            .378:
14846                                           ! 2764         regs.u.r16.ax = 0xffc0;
14847                                           ! Debug: eq unsigned int = const $FFC0 to unsigned short regs = [S+$16+$10] (used reg = )
14848 4018           B8                   FFC0  mov	ax,#$FFC0
14849 401B           8946         12            mov	$12[bp],ax
14850                                           !BCC_EOS
14851                                           ! 2765       FLAGS &= 0xfffe;
14852                       0000401E            .377:
14853                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14854 401E           8B46         18            mov	ax,$18[bp]
14855 4021           24                     FE  and	al,#$FE
14856 4023           8946         18            mov	$18[bp],ax
14857                                           !BCC_EOS
14858                                           ! 2766       break;
14859 4026           E9         0185            br 	.359
14860                                           !BCC_EOS
14861                                           ! 2767   case 0x89:
14862                                           ! 2768 #asm
14863                       00004029            .379:
14864                                           !BCC_EOS
14865                                           !BCC_ASM
14866                       00000006            _int15_function.CX	set	6
14867                       FFFFFFF2            .int15_function.CX	set	-$E
14868                       0000002C            _int15_function.FLAGS	set	$2C
14869                       00000018            .int15_function.FLAGS	set	$18
14870                       00000001            _int15_function.irqDisable	set	1
14871                       FFFFFFED            .int15_function.irqDisable	set	-$13
14872                       0000002A            _int15_function.DS	set	$2A
14873                       00000016            .int15_function.DS	set	$16
14874                       00000004            _int15_function.DX	set	4
14875                       FFFFFFF0            .int15_function.DX	set	-$10
14876                       0000000D            _int15_function.base23_16	set	$D
14877                       FFFFFFF9            .int15_function.base23_16	set	-7
14878                       00000002            _int15_function.bRegister	set	2
14879                       FFFFFFEE            .int15_function.bRegister	set	-$12
14880                       00000028            _int15_function.ES	set	$28
14881                       00000014            .int15_function.ES	set	$14
14882                       00000012            _int15_function.ebda_seg	set	$12
14883                       FFFFFFFE            .int15_function.ebda_seg	set	-2
14884                       0000000E            _int15_function.base15_00	set	$E
14885                       FFFFFFFA            .int15_function.base15_00	set	-6
14886                       0000000A            _int15_function.ss	set	$A
14887                       FFFFFFF6            .int15_function.ss	set	-$A
14888                       00000008            _int15_function.BX	set	8
14889                       FFFFFFF4            .int15_function.BX	set	-$C
14890                       00000018            _int15_function.regs	set	$18
14891                       00000004            .int15_function.regs	set	4
14892                       00000010            _int15_function.prev_a20_enable	set	$10
14893                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
14894 4029           FA                           cli
14895                                           ! 2770 endasm
14896                                           !BCC_ENDASM
14897                                           !BCC_EOS
14898                                           ! 2771       set_enable_a20(1);
14899                                           ! Debug: list int = const 1 (used reg = )
14900 402A           B8                   0001  mov	ax,*1
14901 402D           50                         push	ax
14902                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
14903 402E           E8         D707            call	_set_enable_a20
14904 4031           44                         inc	sp
14905 4032           44                         inc	sp
14906                                           !BCC_EOS
14907                                           ! 2772  
14908                                           ! 2772      set_DS(ES);
14909                                           ! Debug: list unsigned short ES = [S+$16+$12] (used reg = )
14910 4033           FF76         14            push	$14[bp]
14911                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
14912 4036           E8         C629            call	_set_DS
14913 4039           44                         inc	sp
14914 403A           44                         inc	sp
14915                                           !BCC_EOS
14916                                           ! 2773       *((Bit16u *)(regs.u.r16.si+0x38+0)) = (0xffff);
14917                                           ! Debug: add int = const $38 to unsigned short regs = [S+$16+4] (used reg = )
14918 403B           8B46         06            mov	ax,6[bp]
14919                                           ! Debug: add int = const 0 to unsigned int = ax+$38 (used reg = )
14920                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$38 (used reg = )
14921 403E           89C3                       mov	bx,ax
14922                                           ! Debug: eq unsigned int = const $FFFF to unsigned short = [bx+$38] (used reg = )
14923 4040           B8                   FFFF  mov	ax,#$FFFF
14924 4043           8947         38            mov	$38[bx],ax
14925                                           !BCC_EOS
14926                                           ! 2774       *((Bit16u *)(regs.u.r16.si+0x38+2)) = (0x0000);
14927                                           ! Debug: add int = const $38 to unsigned short regs = [S+$16+4] (used reg = )
14928 4046           8B46         06            mov	ax,6[bp]
14929                                           ! Debug: add int = const 2 to unsigned int = ax+$38 (used reg = )
14930                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$3A (used reg = )
14931 4049           89C3                       mov	bx,ax
14932                                           ! Debug: eq int = const 0 to unsigned short = [bx+$3A] (used reg = )
14933 404B           31C0                       xor	ax,ax
14934 404D           8947         3A            mov	$3A[bx],ax
14935                                           !BCC_EOS
14936                                           ! 2775       *((Bit8u *)(regs.u.r16.si+0x38+4)) = (0x000f);
14937                                           ! Debug: add int = const $38 to unsigned short regs = [S+$16+4] (used reg = )
14938 4050           8B46         06            mov	ax,6[bp]
14939                                           ! Debug: add int = const 4 to unsigned int = ax+$38 (used reg = )
14940                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$3C (used reg = )
14941 4053           89C3                       mov	bx,ax
14942                                           ! Debug: eq int = const $F to unsigned char = [bx+$3C] (used reg = )
14943 4055           B0                     0F  mov	al,*$F
14944 4057           8847         3C            mov	$3C[bx],al
14945                                           !BCC_EOS
14946                                           ! 2776       *((Bit8u *)(regs.u.r16.si+0x38+5)) = (0x9b);
14947                                           ! Debug: add int = const $38 to unsigned short regs = [S+$16+4] (used reg = )
14948 405A           8B46         06            mov	ax,6[bp]
14949                                           ! Debug: add int = const 5 to unsigned int = ax+$38 (used reg = )
14950                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$3D (used reg = )
14951 405D           89C3                       mov	bx,ax
14952                                           ! Debug: eq int = const $9B to unsigned char = [bx+$3D] (used reg = )
14953 405F           B0                     9B  mov	al,#$9B
14954 4061           8847         3D            mov	$3D[bx],al
14955                                           !BCC_EOS
14956                                           ! 2777       *((Bit16u *)(regs.u.r16.si+0x38+6)) = (0x0000);
14957                                           ! Debug: add int = const $38 to unsigned short regs = [S+$16+4] (used reg = )
14958 4064           8B46         06            mov	ax,6[bp]
14959                                           ! Debug: add int = const 6 to unsigned int = ax+$38 (used reg = )
14960                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$3E (used reg = )
14961 4067           89C3                       mov	bx,ax
14962                                           ! Debug: eq int = const 0 to unsigned short = [bx+$3E] (used reg = )
14963 4069           31C0                       xor	ax,ax
14964 406B           8947         3E            mov	$3E[bx],ax
14965                                           !BCC_EOS
14966                                           ! 2778       BX = regs.u.r16.bx;
14967                                           ! Debug: eq unsigned short regs = [S+$16+$A] to unsigned short BX = [S+$16-$E] (used reg = )
14968 406E           8B46         0C            mov	ax,$C[bp]
14969 4071           8946         F4            mov	-$C[bp],ax
14970                                           !BCC_EOS
14971                                           ! 2779 #asm
14972                                           !BCC_EOS
14973                                           !BCC_ASM
14974                       00000006            _int15_function.CX	set	6
14975                       FFFFFFF2            .int15_function.CX	set	-$E
14976                       0000002C            _int15_function.FLAGS	set	$2C
14977                       00000018            .int15_function.FLAGS	set	$18
14978                       00000001            _int15_function.irqDisable	set	1
14979                       FFFFFFED            .int15_function.irqDisable	set	-$13
14980                       0000002A            _int15_function.DS	set	$2A
14981                       00000016            .int15_function.DS	set	$16
14982                       00000004            _int15_function.DX	set	4
14983                       FFFFFFF0            .int15_function.DX	set	-$10
14984                       0000000D            _int15_function.base23_16	set	$D
14985                       FFFFFFF9            .int15_function.base23_16	set	-7
14986                       00000002            _int15_function.bRegister	set	2
14987                       FFFFFFEE            .int15_function.bRegister	set	-$12
14988                       00000028            _int15_function.ES	set	$28
14989                       00000014            .int15_function.ES	set	$14
14990                       00000012            _int15_function.ebda_seg	set	$12
14991                       FFFFFFFE            .int15_function.ebda_seg	set	-2
14992                       0000000E            _int15_function.base15_00	set	$E
14993                       FFFFFFFA            .int15_function.base15_00	set	-6
14994                       0000000A            _int15_function.ss	set	$A
14995                       FFFFFFF6            .int15_function.ss	set	-$A
14996                       00000008            _int15_function.BX	set	8
14997                       FFFFFFF4            .int15_function.BX	set	-$C
14998                       00000018            _int15_function.regs	set	$18
14999                       00000004            .int15_function.regs	set	4
15000                       00000010            _int15_function.prev_a20_enable	set	$10
15001                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
15002 4074           89E3                             mov bx, sp
15003 4076           36                               SEG SS
15004 4077           8B5F         08                    mov bx, _int15_function.BX [bx]
15005 407A           B0                     11        mov al, #0x11 ; send initialisation commands
15006 407C           E6                     20        out 0x0020, al
15007 407E           E6                     A0        out 0x00a0, al
15008 4080           88F8                             mov al, bh
15009 4082           E6                     21        out 0x0021, al
15010 4084           88D8                             mov al, bl
15011 4086           E6                     A1        out 0x00a1, al
15012 4088           B0                     04        mov al, #0x04
15013 408A           E6                     21        out 0x0021, al
15014 408C           B0                     02        mov al, #0x02
15015 408E           E6                     A1        out 0x00a1, al
15016 4090           B0                     01        mov al, #0x01
15017 4092           E6                     21        out 0x0021, al
15018 4094           E6                     A1        out 0x00a1, al
15019 4096           B0                     FF        mov al, #0xff ; mask all IRQs, user must re-enable
15020 4098           E6                     21        out 0x0021, al
15021 409A           E6                     A1        out 0x00a1, al
15022 409C           26                               SEG ES
15023 409D         0F0154         08                    lgdt [si + 0x08]
15024 40A1           26                               SEG ES
15025 40A2         0F015C         10                    lidt [si + 0x10]
15026 40A6         0F20C0                             mov eax, cr0
15027 40A9           0C                     01        or al, #0x01
15028 40AB         0F22C0                             mov cr0, eax
15029                                                 JMP_AP(0x0038, protmode_switch)
 +a   40AE                        EA              db 0xea
 +a   40AF                      40B3              dw  protmode_switch
 +a   40B1                      0038              dw 0x0038
15030                       000040B3            protmode_switch:
15031                                                 ;; GDT points to valid descriptor table, now load SS, DS, ES
15032 40B3           B8                   0028        mov ax, #0x28
15033 40B6           8ED0                             mov ss, ax
15034 40B8           B8                   0018        mov ax, #0x18
15035 40BB           8ED8                             mov ds, ax
15036 40BD           B8                   0020        mov ax, #0x20
15037 40C0           8EC0                             mov es, ax
15038 40C2           89EC                             mov sp,bp
15039 40C4           83C4                   04        add sp,#4 ; skip return address
15040 40C7           61                               popa ; restore regs
15041 40C8           58                               pop ax ; skip saved es
15042 40C9           58                               pop ax ; skip saved ds
15043 40CA           58                               pop ax ; skip saved flags
15044 40CB           59                               pop cx ; get return offset
15045 40CC           58                               pop ax ; skip return segment
15046 40CD           58                               pop ax ; skip flags
15047 40CE           B8                   0030        mov ax, #0x30 ; ah must be 0 on successful exit
15048 40D1           50                               push ax
15049 40D2           51                               push cx ; re-create modified ret address on stack
15050 40D3           CB                               retf
15051                                           ! 2829 endasm
15052                                           !BCC_ENDASM
15053                                           !BCC_EOS
15054                                           ! 2830       break;
15055 40D4           E9         00D7            br 	.359
15056                                           !BCC_EOS
15057                                           ! 2831     case 0xbf:
15058                                           ! 2832       bios_printf(4, "*** int 15h function AH=bf not yet supported!\n");
15059                       000040D7            .37A:
15060                                           ! Debug: list * char = .37B+0 (used reg = )
15061 40D7           BB                   D547  mov	bx,#.37B
15062 40DA           53                         push	bx
15063                                           ! Debug: list int = const 4 (used reg = )
15064 40DB           B8                   0004  mov	ax,*4
15065 40DE           50                         push	ax
15066                                           ! Debug: func () void = bios_printf+0 (used reg = )
15067 40DF           E8         C85C            call	_bios_printf
15068 40E2           83C4                   04  add	sp,*4
15069                                           !BCC_EOS
15070                                           ! 2833       FLAGS |= 0x0001;
15071                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
15072 40E5           8B46         18            mov	ax,$18[bp]
15073 40E8           0C                     01  or	al,*1
15074 40EA           8946         18            mov	$18[bp],ax
15075                                           !BCC_EOS
15076                                           ! 2834       regs.u.r8.ah = 0x86;
15077                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
15078 40ED           B0                     86  mov	al,#$86
15079 40EF           8846         13            mov	$13[bp],al
15080                                           !BCC_EOS
15081                                           ! 2835       break;
15082 40F2           E9         00B9            br 	.359
15083                                           !BCC_EOS
15084                                           ! 2836     case 0xC0:
15085                                           ! 2837       FLAGS &= 0xfffe;
15086                       000040F5            .37C:
15087                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
15088 40F5           8B46         18            mov	ax,$18[bp]
15089 40F8           24                     FE  and	al,#$FE
15090 40FA           8946         18            mov	$18[bp],ax
15091                                           !BCC_EOS
15092                                           ! 2838       regs.u.r8.ah = 0;
15093                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
15094 40FD           30C0                       xor	al,al
15095 40FF           8846         13            mov	$13[bp],al
15096                                           !BCC_EOS
15097                                           ! 2839       regs.u.r16.bx = 0xe6f5;
15098                                           ! Debug: eq unsigned int = const $E6F5 to unsigned short regs = [S+$16+$A] (used reg = )
15099 4102           B8                   E6F5  mov	ax,#$E6F5
15100 4105           8946         0C            mov	$C[bp],ax
15101                                           !BCC_EOS
15102                                           ! 2840       ES = 0xF000;
15103                                           ! Debug: eq unsigned int = const $F000 to unsigned short ES = [S+$16+$12] (used reg = )
15104 4108           B8                   F000  mov	ax,#$F000
15105 410B           8946         14            mov	$14[bp],ax
15106                                           !BCC_EOS
15107                                           ! 2841       break;
15108 410E           E9         009D            br 	.359
15109                                           !BCC_EOS
15110                                           ! 2842     case 0xc1:
15111                                           ! 2843       ES = ebda_seg;
15112                       00004111            .37D:
15113                                           ! Debug: eq unsigned short ebda_seg = [S+$16-4] to unsigned short ES = [S+$16+$12] (used reg = )
15114 4111           8B46         FE            mov	ax,-2[bp]
15115 4114           8946         14            mov	$14[bp],ax
15116                                           !BCC_EOS
15117                                           ! 2844       FLAGS &= 0xfffe;
15118                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
15119 4117           8B46         18            mov	ax,$18[bp]
15120 411A           24                     FE  and	al,#$FE
15121 411C           8946         18            mov	$18[bp],ax
15122                                           !BCC_EOS
15123                                           ! 2845       break;
15124 411F           E9         008C            br 	.359
15125                                           !BCC_EOS
15126                                           ! 2846     case 0xd8:
15127                                           ! 2847       bios_printf(8, "EISA BIOS not present\n");
15128                       00004122            .37E:
15129                                           ! Debug: list * char = .37F+0 (used reg = )
15130 4122           BB                   D530  mov	bx,#.37F
15131 4125           53                         push	bx
15132                                           ! Debug: list int = const 8 (used reg = )
15133 4126           B8                   0008  mov	ax,*8
15134 4129           50                         push	ax
15135                                           ! Debug: func () void = bios_printf+0 (used reg = )
15136 412A           E8         C811            call	_bios_printf
15137 412D           83C4                   04  add	sp,*4
15138                                           !BCC_EOS
15139                                           ! 2848       FLAGS |= 0x0001;
15140                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
15141 4130           8B46         18            mov	ax,$18[bp]
15142 4133           0C                     01  or	al,*1
15143 4135           8946         18            mov	$18[bp],ax
15144                                           !BCC_EOS
15145                                           ! 2849       regs.u.r8.ah = 0x86;
15146                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
15147 4138           B0                     86  mov	al,#$86
15148 413A           8846         13            mov	$13[bp],al
15149                                           !BCC_EOS
15150                                           ! 2850      
15151                                           ! 2850  break;
15152 413D           EB           6F            jmp .359
15153                                           !BCC_EOS
15154                                           ! 2851     default:
15155                                           ! 2852       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
15156                       0000413F            .380:
15157                                           ! Debug: list unsigned short regs = [S+$16+$A] (used reg = )
15158 413F           FF76         0C            push	$C[bp]
15159                                           ! Debug: list unsigned short regs = [S+$18+$10] (used reg = )
15160 4142           FF76         12            push	$12[bp]
15161                                           ! Debug: list * char = .381+0 (used reg = )
15162 4145           BB                   D4F6  mov	bx,#.381
15163 4148           53                         push	bx
15164                                           ! Debug: list int = const 4 (used reg = )
15165 4149           B8                   0004  mov	ax,*4
15166 414C           50                         push	ax
15167                                           ! Debug: func () void = bios_printf+0 (used reg = )
15168 414D           E8         C7EE            call	_bios_printf
15169 4150           83C4                   08  add	sp,*8
15170                                           !BCC_EOS
15171                                           ! 2853       FLAGS |= 0x0001;
15172                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
15173 4153           8B46         18            mov	ax,$18[bp]
15174 4156           0C                     01  or	al,*1
15175 4158           8946         18            mov	$18[bp],ax
15176                                           !BCC_EOS
15177                                           ! 2854       regs.u.r8.ah = 0x86;
15178                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
15179 415B           B0                     86  mov	al,#$86
15180 415D           8846         13            mov	$13[bp],al
15181                                           !BCC_EOS
15182                                           ! 2855       break;
15183 4160           EB           4C            jmp .359
15184                                           !BCC_EOS
15185                                           ! 2856     }
15186                                           ! 2857 }
15187 4162           EB           4A            jmp .359
15188                       00004164            .35B:
15189 4164           2C                     24  sub	al,*$24
15190 4166         0F84         FB72            beq 	.35C
15191 416A           2C                     1D  sub	al,*$1D
15192 416C         0F84         FBFB            beq 	.366
15193 4170           2C                     0E  sub	al,*$E
15194 4172         0F84         FC05            beq 	.367
15195 4176           2C                     03  sub	al,*3
15196 4178         0F84         FC0A            beq 	.368
15197 417C           2C                     31  sub	al,*$31
15198 417E         0F84         FC14            beq 	.369
15199 4182           2C                     04  sub	al,*4
15200 4184         0F84         FCE8            beq 	.373
15201 4188           2C                     01  sub	al,*1
15202 418A         0F84         FE6A            beq 	.376
15203 418E           2C                     01  sub	al,*1
15204 4190         0F84         FE95            beq 	.379
15205 4194           2C                     36  sub	al,*$36
15206 4196         0F84         FF3D            beq 	.37A
15207 419A           2C                     01  sub	al,*1
15208 419C         0F84         FF55            beq 	.37C
15209 41A0           2C                     01  sub	al,*1
15210 41A2         0F84         FF6B            beq 	.37D
15211 41A6           2C                     17  sub	al,*$17
15212 41A8         0F84         FF76            beq 	.37E
15213 41AC           EB           91            jmp	.380
15214                       000041AE            .359:
15215                       FFFFFFEA            ..FFF7	=	-$16
15216 41AE           89EC                       mov	sp,bp
15217 41B0           5D                         pop	bp
15218 41B1           C3                         ret
15219                                           ! 2858   void
15220                                           ! Register BX used in function int15_function
15221                                           ! 2859 int15_function_mouse(regs, ES, DS, FLAGS)
15222                                           ! 2860   pusha_regs_t regs;
15223                                           export	_int15_function_mouse
15224                       000041B2            _int15_function_mouse:
15225                                           !BCC_EOS
15226                                           ! 2861   Bit16u ES, DS, FLAGS;
15227                                           !BCC_EOS
15228                                           ! 2862 {
15229                                           ! 2863   Bit16u ebda_seg=get_ebda_seg();
15230 41B2           55                         push	bp
15231 41B3           89E5                       mov	bp,sp
15232 41B5           4C                         dec	sp
15233 41B6           4C                         dec	sp
15234                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
15235 41B7           E8         C4B2            call	_get_ebda_seg
15236                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
15237 41BA           8946         FE            mov	-2[bp],ax
15238                                           !BCC_EOS
15239                                           ! 2864   Bit8u mouse_flags_1, mouse_flags_2;
15240                                           !BCC_EOS
15241                                           ! 2865   Bit16u mouse_driver_seg;
15242                                           !BCC_EOS
15243                                           ! 2866   Bit16u mouse_driver_offset;
15244                                           !BCC_EOS
15245                                           ! 2867   Bit8u comm_byte, prev_command_byte;
15246                                           !BCC_EOS
15247                                           ! 2868   Bit8u ret, mouse_data1, mouse_data2, mouse_data3;
15248                                           !BCC_EOS
15249                                           ! 2869 ;
15250 41BD           83C4                   F4  add	sp,*-$C
15251                                           !BCC_EOS
15252                                           ! 2870   switch (regs.u.r8.ah) {
15253 41C0           8A46         13            mov	al,$13[bp]
15254 41C3           E9         0665            br 	.384
15255                                           ! 2871     case 0xC2:
15256                                           ! 2872       switch (regs.u.r8.al) {
15257                       000041C6            .385:
15258 41C6           8A46         12            mov	al,$12[bp]
15259 41C9           E9         0613            br 	.388
15260                                           ! 2873         case 0:
15261                                           ! 2874 ;
15262                       000041CC            .389:
15263                                           !BCC_EOS
15264                                           ! 2875           switch (regs.u.r8.bh) {
15265 41CC           8A46         0D            mov	al,$D[bp]
15266 41CF           E9         00E9            br 	.38C
15267                                           ! 2876             case 0:
15268                                           ! 2877 ;
15269                       000041D2            .38D:
15270                                           !BCC_EOS
15271                                           ! 2878               inhibit_mouse_int_and_events();
15272                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
15273 41D2           E8         1022            call	_inhibit_mouse_int_and_events
15274                                           !BCC_EOS
15275                                           ! 2879               ret = send_to_mouse_ctrl(0xF5);
15276                                           ! Debug: list int = const $F5 (used reg = )
15277 41D5           B8                   00F5  mov	ax,#$F5
15278 41D8           50                         push	ax
15279                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15280 41D9           E8         116C            call	_send_to_mouse_ctrl
15281 41DC           44                         inc	sp
15282 41DD           44                         inc	sp
15283                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15284 41DE           8846         F5            mov	-$B[bp],al
15285                                           !BCC_EOS
15286                                           ! 2880               if (ret == 0) {
15287                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15288 41E1           8A46         F5            mov	al,-$B[bp]
15289 41E4           84C0                       test	al,al
15290 41E6           75           2B            jne 	.38E
15291                       000041E8            .38F:
15292                                           ! 2881                 ret = get_mouse_data(&mouse_data1);
15293                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
15294 41E8           8D5E         F4            lea	bx,-$C[bp]
15295 41EB           53                         push	bx
15296                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15297 41EC           E8         11A3            call	_get_mouse_data
15298 41EF           44                         inc	sp
15299 41F0           44                         inc	sp
15300                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15301 41F1           8846         F5            mov	-$B[bp],al
15302                                           !BCC_EOS
15303                                           ! 2882                 if ( (ret == 0) || (mouse_data1 == 0xFA) ) {
15304                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15305 41F4           8A46         F5            mov	al,-$B[bp]
15306 41F7           84C0                       test	al,al
15307 41F9           74           07            je  	.391
15308                       000041FB            .392:
15309                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15310 41FB           8A46         F4            mov	al,-$C[bp]
15311 41FE           3C                     FA  cmp	al,#$FA
15312 4200           75           11            jne 	.390
15313                       00004202            .391:
15314                                           ! 2883                   FLAGS &= 0xfffe;
15315                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
15316 4202           8B46         18            mov	ax,$18[bp]
15317 4205           24                     FE  and	al,#$FE
15318 4207           8946         18            mov	$18[bp],ax
15319                                           !BCC_EOS
15320                                           ! 2884                   regs.u.r8.ah = 0;
15321                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
15322 420A           30C0                       xor	al,al
15323 420C           8846         13            mov	$13[bp],al
15324                                           !BCC_EOS
15325                                           ! 2885                   return;
15326 420F           89EC                       mov	sp,bp
15327 4211           5D                         pop	bp
15328 4212           C3                         ret
15329                                           !BCC_EOS
15330                                           ! 2886                 }
15331                                           ! 2887               }
15332                       00004213            .390:
15333                                           ! 2888               FLAGS |= 0x0001;
15334                       00004213            .38E:
15335                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15336 4213           8B46         18            mov	ax,$18[bp]
15337 4216           0C                     01  or	al,*1
15338 4218           8946         18            mov	$18[bp],ax
15339                                           !BCC_EOS
15340                                           ! 2889               regs.u.r8.ah = ret;
15341                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
15342 421B           8A46         F5            mov	al,-$B[bp]
15343 421E           8846         13            mov	$13[bp],al
15344                                           !BCC_EOS
15345                                           ! 2890               return;
15346 4221           89EC                       mov	sp,bp
15347 4223           5D                         pop	bp
15348 4224           C3                         ret
15349                                           !BCC_EOS
15350                                           ! 2891               break;
15351 4225           E9         00A1            br 	.38A
15352                                           !BCC_EOS
15353                                           ! 2892             case 1:
15354                                           ! 2893 ;
15355                       00004228            .393:
15356                                           !BCC_EOS
15357                                           ! 2894               mouse_flags_2 = _read_byte(&((ebda_data_t *) 0)->mouse_flag2, ebda_seg);
15358                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
15359 4228           FF76         FE            push	-2[bp]
15360                                           ! Debug: list * unsigned char = const $27 (used reg = )
15361 422B           B8                   0027  mov	ax,*$27
15362 422E           50                         push	ax
15363                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
15364 422F           E8         C3B2            call	__read_byte
15365 4232           83C4                   04  add	sp,*4
15366                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
15367 4235           8846         FC            mov	-4[bp],al
15368                                           !BCC_EOS
15369                                           ! 2895               if ( (mouse_flags_2 & 0x80) == 0 ) {
15370                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
15371 4238           8A46         FC            mov	al,-4[bp]
15372 423B           24                     80  and	al,#$80
15373                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
15374 423D           84C0                       test	al,al
15375 423F           75           11            jne 	.394
15376                       00004241            .395:
15377                                           ! 2896                 ;
15378                                           !BCC_EOS
15379                                           ! 2897                 FLAGS |= 0x0001;
15380                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15381 4241           8B46         18            mov	ax,$18[bp]
15382 4244           0C                     01  or	al,*1
15383 4246           8946         18            mov	$18[bp],ax
15384                                           !BCC_EOS
15385                                           ! 2898                 regs.u.r8.ah = 5;
15386                                           ! Debug: eq int = const 5 to unsigned char regs = [S+$10+$11] (used reg = )
15387 4249           B0                     05  mov	al,*5
15388 424B           8846         13            mov	$13[bp],al
15389                                           !BCC_EOS
15390                                           ! 2899                 return;
15391 424E           89EC                       mov	sp,bp
15392 4250           5D                         pop	bp
15393 4251           C3                         ret
15394                                           !BCC_EOS
15395                                           ! 2900               }
15396                                           ! 2901               inhibit_mouse_int_and_events();
15397                       00004252            .394:
15398                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
15399 4252           E8         0FA2            call	_inhibit_mouse_int_and_events
15400                                           !BCC_EOS
15401                                           ! 2902               ret = send_to_mouse_ctrl(0xF4);
15402                                           ! Debug: list int = const $F4 (used reg = )
15403 4255           B8                   00F4  mov	ax,#$F4
15404 4258           50                         push	ax
15405                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15406 4259           E8         10EC            call	_send_to_mouse_ctrl
15407 425C           44                         inc	sp
15408 425D           44                         inc	sp
15409                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15410 425E           8846         F5            mov	-$B[bp],al
15411                                           !BCC_EOS
15412                                           ! 2903               if (ret == 0) {
15413                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15414 4261           8A46         F5            mov	al,-$B[bp]
15415 4264           84C0                       test	al,al
15416 4266           75           2E            jne 	.396
15417                       00004268            .397:
15418                                           ! 2904                 ret = get_mouse_data(&mouse_data1);
15419                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
15420 4268           8D5E         F4            lea	bx,-$C[bp]
15421 426B           53                         push	bx
15422                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15423 426C           E8         1123            call	_get_mouse_data
15424 426F           44                         inc	sp
15425 4270           44                         inc	sp
15426                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15427 4271           8846         F5            mov	-$B[bp],al
15428                                           !BCC_EOS
15429                                           ! 2905                 if ( (ret == 0) && (mouse_data1 == 0xFA) ) {
15430                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15431 4274           8A46         F5            mov	al,-$B[bp]
15432 4277           84C0                       test	al,al
15433 4279           75           1B            jne 	.398
15434                       0000427B            .39A:
15435                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15436 427B           8A46         F4            mov	al,-$C[bp]
15437 427E           3C                     FA  cmp	al,#$FA
15438 4280           75           14            jne 	.398
15439                       00004282            .399:
15440                                           ! 2906                   enable_mouse_int_and_events();
15441                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
15442 4282           E8         101F            call	_enable_mouse_int_and_events
15443                                           !BCC_EOS
15444                                           ! 2907                   FLAGS &= 0xfffe;
15445                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
15446 4285           8B46         18            mov	ax,$18[bp]
15447 4288           24                     FE  and	al,#$FE
15448 428A           8946         18            mov	$18[bp],ax
15449                                           !BCC_EOS
15450                                           ! 2908                   regs.u.r8.ah = 0;
15451                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
15452 428D           30C0                       xor	al,al
15453 428F           8846         13            mov	$13[bp],al
15454                                           !BCC_EOS
15455                                           ! 2909                   return;
15456 4292           89EC                       mov	sp,bp
15457 4294           5D                         pop	bp
15458 4295           C3                         ret
15459                                           !BCC_EOS
15460                                           ! 2910                 }
15461                                           ! 2911               }
15462                       00004296            .398:
15463                                           ! 2912               FLAGS |= 0x0001;
15464                       00004296            .396:
15465                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15466 4296           8B46         18            mov	ax,$18[bp]
15467 4299           0C                     01  or	al,*1
15468 429B           8946         18            mov	$18[bp],ax
15469                                           !BCC_EOS
15470                                           ! 2913               regs.u.r8.ah = ret;
15471                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
15472 429E           8A46         F5            mov	al,-$B[bp]
15473 42A1           8846         13            mov	$13[bp],al
15474                                           !BCC_EOS
15475                                           ! 2914               return;
15476 42A4           89EC                       mov	sp,bp
15477 42A6           5D                         pop	bp
15478 42A7           C3                         ret
15479                                           !BCC_EOS
15480                                           ! 2915             default:
15481                                           ! 2916               ;
15482                       000042A8            .39B:
15483                                           !BCC_EOS
15484                                           ! 2917               FLAGS |= 0x0001;
15485                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15486 42A8           8B46         18            mov	ax,$18[bp]
15487 42AB           0C                     01  or	al,*1
15488 42AD           8946         18            mov	$18[bp],ax
15489                                           !BCC_EOS
15490                                           ! 2918               regs.u.r8.ah = 
15491                                           ! 2918 1;
15492                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
15493 42B0           B0                     01  mov	al,*1
15494 42B2           8846         13            mov	$13[bp],al
15495                                           !BCC_EOS
15496                                           ! 2919               return;
15497 42B5           89EC                       mov	sp,bp
15498 42B7           5D                         pop	bp
15499 42B8           C3                         ret
15500                                           !BCC_EOS
15501                                           ! 2920           }
15502                                           ! 2921           break;
15503 42B9           EB           0E            jmp .38A
15504                       000042BB            .38C:
15505 42BB           2C                     00  sub	al,*0
15506 42BD         0F84         FF11            beq 	.38D
15507 42C1           2C                     01  sub	al,*1
15508 42C3         0F84         FF61            beq 	.393
15509 42C7           EB           DF            jmp	.39B
15510                       000042C9            .38A:
15511 42C9           E9         0538            br 	.386
15512                                           !BCC_EOS
15513                                           ! 2922         case 1:
15514                                           ! 2923         case 5:
15515                       000042CC            .39C:
15516                                           ! 2924 ;
15517                       000042CC            .39D:
15518                                           !BCC_EOS
15519                                           ! 2925           if (regs.u.r8.al == 5) {
15520                                           ! Debug: logeq int = const 5 to unsigned char regs = [S+$10+$10] (used reg = )
15521 42CC           8A46         12            mov	al,$12[bp]
15522 42CF           3C                     05  cmp	al,*5
15523 42D1         0F85         0070            bne 	.39E
15524                       000042D5            .39F:
15525                                           ! 2926             if ((regs.u.r8.bh != 3) && (regs.u.r8.bh != 4)) {
15526                                           ! Debug: ne int = const 3 to unsigned char regs = [S+$10+$B] (used reg = )
15527 42D5           8A46         0D            mov	al,$D[bp]
15528 42D8           3C                     03  cmp	al,*3
15529 42DA           74           18            je  	.3A0
15530                       000042DC            .3A2:
15531                                           ! Debug: ne int = const 4 to unsigned char regs = [S+$10+$B] (used reg = )
15532 42DC           8A46         0D            mov	al,$D[bp]
15533 42DF           3C                     04  cmp	al,*4
15534 42E1           74           11            je  	.3A0
15535                       000042E3            .3A1:
15536                                           ! 2927               FLAGS |= 0x0001;
15537                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15538 42E3           8B46         18            mov	ax,$18[bp]
15539 42E6           0C                     01  or	al,*1
15540 42E8           8946         18            mov	$18[bp],ax
15541                                           !BCC_EOS
15542                                           ! 2928               regs.u.r8.ah = 0x02;
15543                                           ! Debug: eq int = const 2 to unsigned char regs = [S+$10+$11] (used reg = )
15544 42EB           B0                     02  mov	al,*2
15545 42ED           8846         13            mov	$13[bp],al
15546                                           !BCC_EOS
15547                                           ! 2929               return;
15548 42F0           89EC                       mov	sp,bp
15549 42F2           5D                         pop	bp
15550 42F3           C3                         ret
15551                                           !BCC_EOS
15552                                           ! 2930             }
15553                                           ! 2931             mouse_flags_2 = _read_byte(&((ebda_data_t *) 0)->mouse_flag2, ebda_seg);
15554                       000042F4            .3A0:
15555                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
15556 42F4           FF76         FE            push	-2[bp]
15557                                           ! Debug: list * unsigned char = const $27 (used reg = )
15558 42F7           B8                   0027  mov	ax,*$27
15559 42FA           50                         push	ax
15560                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
15561 42FB           E8         C2E6            call	__read_byte
15562 42FE           83C4                   04  add	sp,*4
15563                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
15564 4301           8846         FC            mov	-4[bp],al
15565                                           !BCC_EOS
15566                                           ! 2932             mouse_flags_2 = (mouse_flags_2 & 0xF8) | regs.u.r8.bh - 1;
15567                                           ! Debug: sub int = const 1 to unsigned char regs = [S+$10+$B] (used reg = )
15568 4304           8A46         0D            mov	al,$D[bp]
15569 4307           30E4                       xor	ah,ah
15570 4309           48                         dec	ax
15571 430A           50                         push	ax
15572                                           ! Debug: and int = const $F8 to unsigned char mouse_flags_2 = [S+$12-6] (used reg = )
15573 430B           8A46         FC            mov	al,-4[bp]
15574 430E           24                     F8  and	al,#$F8
15575                                           ! Debug: or unsigned int (temp) = [S+$12-$12] to unsigned char = al+0 (used reg = )
15576 4310           30E4                       xor	ah,ah
15577 4312           0B46         F0            or	ax,0+..FFF6[bp]
15578 4315           44                         inc	sp
15579 4316           44                         inc	sp
15580                                           ! Debug: eq unsigned int = ax+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
15581 4317           8846         FC            mov	-4[bp],al
15582                                           !BCC_EOS
15583                                           ! 2933             mouse_flags_1 = 0x00;
15584                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
15585 431A           30C0                       xor	al,al
15586 431C           8846         FD            mov	-3[bp],al
15587                                           !BCC_EOS
15588                                           ! 2934             _write_byte(mouse_flags_1, &((ebda_data_t *) 0)->mouse_flag1, ebda_seg);
15589                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
15590 431F           FF76         FE            push	-2[bp]
15591                                           ! Debug: list * unsigned char = const $26 (used reg = )
15592 4322           B8                   0026  mov	ax,*$26
15593 4325           50                         push	ax
15594                                           ! Debug: list unsigned char mouse_flags_1 = [S+$14-5] (used reg = )
15595 4326           8A46         FD            mov	al,-3[bp]
15596 4329           30E4                       xor	ah,ah
15597 432B           50                         push	ax
15598                                           ! Debug: func () void = _write_byte+0 (used reg = )
15599 432C           E8         C2D1            call	__write_byte
15600 432F           83C4                   06  add	sp,*6
15601                                           !BCC_EOS
15602                                           ! 2935             _write_byte(mouse_flags_2, &((ebda_data_t *) 0)->mouse_flag2, ebda_seg);
15603                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
15604 4332           FF76         FE            push	-2[bp]
15605                                           ! Debug: list * unsigned char = const $27 (used reg = )
15606 4335           B8                   0027  mov	ax,*$27
15607 4338           50                         push	ax
15608                                           ! Debug: list unsigned char mouse_flags_2 = [S+$14-6] (used reg = )
15609 4339           8A46         FC            mov	al,-4[bp]
15610 433C           30E4                       xor	ah,ah
15611 433E           50                         push	ax
15612                                           ! Debug: func () void = _write_byte+0 (used reg = )
15613 433F           E8         C2BE            call	__write_byte
15614 4342           83C4                   06  add	sp,*6
15615                                           !BCC_EOS
15616                                           ! 2936           }
15617                                           ! 2937           inhibit_mouse_int_and_events();
15618                       00004345            .39E:
15619                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
15620 4345           E8         0EAF            call	_inhibit_mouse_int_and_events
15621                                           !BCC_EOS
15622                                           ! 2938           ret = send_to_mouse_ctrl(0xFF);
15623                                           ! Debug: list int = const $FF (used reg = )
15624 4348           B8                   00FF  mov	ax,#$FF
15625 434B           50                         push	ax
15626                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15627 434C           E8         0FF9            call	_send_to_mouse_ctrl
15628 434F           44                         inc	sp
15629 4350           44                         inc	sp
15630                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15631 4351           8846         F5            mov	-$B[bp],al
15632                                           !BCC_EOS
15633                                           ! 2939           if (ret == 0) {
15634                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15635 4354           8A46         F5            mov	al,-$B[bp]
15636 4357           84C0                       test	al,al
15637 4359         0F85         0087            bne 	.3A3
15638                       0000435D            .3A4:
15639                                           ! 2940             ret = get_mouse_data(&mouse_data3);
15640                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
15641 435D           8D5E         F2            lea	bx,-$E[bp]
15642 4360           53                         push	bx
15643                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15644 4361           E8         102E            call	_get_mouse_data
15645 4364           44                         inc	sp
15646 4365           44                         inc	sp
15647                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15648 4366           8846         F5            mov	-$B[bp],al
15649                                           !BCC_EOS
15650                                           ! 2941             if (mouse_data3 == 0xfe) {
15651                                           ! Debug: logeq int = const $FE to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
15652 4369           8A46         F2            mov	al,-$E[bp]
15653 436C           3C                     FE  cmp	al,#$FE
15654 436E           75           0C            jne 	.3A5
15655                       00004370            .3A6:
15656                                           ! 2942               FLAGS |= 0x0001;
15657                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15658 4370           8B46         18            mov	ax,$18[bp]
15659 4373           0C                     01  or	al,*1
15660 4375           8946         18            mov	$18[bp],ax
15661                                           !BCC_EOS
15662                                           ! 2943               return;
15663 4378           89EC                       mov	sp,bp
15664 437A           5D                         pop	bp
15665 437B           C3                         ret
15666                                           !BCC_EOS
15667                                           ! 2944             }
15668                                           ! 2945             if (mouse_data3 != 0xfa)
15669                       0000437C            .3A5:
15670                                           ! Debug: ne int = const $FA to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
15671 437C           8A46         F2            mov	al,-$E[bp]
15672 437F           3C                     FA  cmp	al,#$FA
15673 4381           74           14            je  	.3A7
15674                       00004383            .3A8:
15675                                           ! 2946               bios_printf((2 | 4 | 1), "Mouse reset returned %02x (should be ack)\n", (unsigned)mouse_data3);
15676                                           ! Debug: list unsigned char mouse_data3 = [S+$10-$10] (used reg = )
15677 4383           8A46         F2            mov	al,-$E[bp]
15678 4386           30E4                       xor	ah,ah
15679 4388           50                         push	ax
15680                                           ! Debug: list * char = .3A9+0 (used reg = )
15681 4389           BB                   D4CB  mov	bx,#.3A9
15682 438C           53                         push	bx
15683                                           ! Debug: list int = const 7 (used reg = )
15684 438D           B8                   0007  mov	ax,*7
15685 4390           50                         push	ax
15686                                           ! Debug: func () void = bios_printf+0 (used reg = )
15687 4391           E8         C5AA            call	_bios_printf
15688 4394           83C4                   06  add	sp,*6
15689                                           !BCC_EOS
15690                                           ! 2947             if ( ret == 0 ) {
15691                       00004397            .3A7:
15692                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15693 4397           8A46         F5            mov	al,-$B[bp]
15694 439A           84C0                       test	al,al
15695 439C           75           46            jne 	.3AA
15696                       0000439E            .3AB:
15697                                           ! 2948               ret = get_mouse_data(&mouse_data1);
15698                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
15699 439E           8D5E         F4            lea	bx,-$C[bp]
15700 43A1           53                         push	bx
15701                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15702 43A2           E8         0FED            call	_get_mouse_data
15703 43A5           44                         inc	sp
15704 43A6           44                         inc	sp
15705                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15706 43A7           8846         F5            mov	-$B[bp],al
15707                                           !BCC_EOS
15708                                           ! 2949               if ( ret == 0 ) {
15709                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15710 43AA           8A46         F5            mov	al,-$B[bp]
15711 43AD           84C0                       test	al,al
15712 43AF           75           33            jne 	.3AC
15713                       000043B1            .3AD:
15714                                           ! 2950                 ret = get_mouse_data(&mouse_data2);
15715                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
15716 43B1           8D5E         F3            lea	bx,-$D[bp]
15717 43B4           53                         push	bx
15718                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15719 43B5           E8         0FDA            call	_get_mouse_data
15720 43B8           44                         inc	sp
15721 43B9           44                         inc	sp
15722                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15723 43BA           8846         F5            mov	-$B[bp],al
15724                                           !BCC_EOS
15725                                           ! 2951                 if ( ret == 0 ) {
15726                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15727 43BD           8A46         F5            mov	al,-$B[bp]
15728 43C0           84C0                       test	al,al
15729 43C2           75           20            jne 	.3AE
15730                       000043C4            .3AF:
15731                                           ! 2952                   enable_mouse_int_and_events();
15732                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
15733 43C4           E8         0EDD            call	_enable_mouse_int_and_events
15734                                           !BCC_EOS
15735                                           ! 2953                   FLAGS &= 0xfffe;
15736                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
15737 43C7           8B46         18            mov	ax,$18[bp]
15738 43CA           24                     FE  and	al,#$FE
15739 43CC           8946         18            mov	$18[bp],ax
15740                                           !BCC_EOS
15741                                           ! 2954                   regs.u.r8.ah = 0;
15742                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
15743 43CF           30C0                       xor	al,al
15744 43D1           8846         13            mov	$13[bp],al
15745                                           !BCC_EOS
15746                                           ! 2955                   regs.u.r8.bl = mouse_data1;
15747                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
15748 43D4           8A46         F4            mov	al,-$C[bp]
15749 43D7           8846         0C            mov	$C[bp],al
15750                                           !BCC_EOS
15751                                           ! 2956                   regs.u.r8.bh = mouse_data2;
15752                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
15753 43DA           8A46         F3            mov	al,-$D[bp]
15754 43DD           8846         0D            mov	$D[bp],al
15755                                           !BCC_EOS
15756                                           ! 2957                   return;
15757 43E0           89EC                       mov	sp,bp
15758 43E2           5D                         pop	bp
15759 43E3           C3                         ret
15760                                           !BCC_EOS
15761                                           ! 2958                 }
15762                                           ! 2959               }
15763                       000043E4            .3AE:
15764                                           ! 2960             }
15765                       000043E4            .3AC:
15766                                           ! 2961           }
15767                       000043E4            .3AA:
15768                                           ! 2962           FLAGS |= 0x0001;
15769                       000043E4            .3A3:
15770                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15771 43E4           8B46         18            mov	ax,$18[bp]
15772 43E7           0C                     01  or	al,*1
15773 43E9           8946         18            mov	$18[bp],ax
15774                                           !BCC_EOS
15775                                           ! 2963           regs.u.r8.ah = ret;
15776                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
15777 43EC           8A46         F5            mov	al,-$B[bp]
15778 43EF           8846         13            mov	$13[bp],al
15779                                           !BCC_EOS
15780                                           ! 2964           return;
15781 43F2           89EC                       mov	sp,bp
15782 43F4           5D                         pop	bp
15783 43F5           C3                         ret
15784                                           !BCC_EOS
15785                                           ! 2965         case 2:
15786                                           ! 2966 ;
15787                       000043F6            .3B0:
15788                                           !BCC_EOS
15789                                           ! 2967           switch (regs.u.r8.bh) {
15790 43F6           8A46         0D            mov	al,$D[bp]
15791 43F9           EB           39            jmp .3B3
15792                                           ! 2968             case 0: mouse_data1 = 10; break;
15793                       000043FB            .3B4:
15794                                           ! Debug: eq int = const $A to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15795 43FB           B0                     0A  mov	al,*$A
15796 43FD           8846         F4            mov	-$C[bp],al
15797                                           !BCC_EOS
15798 4400           EB           55            jmp .3B1
15799                                           !BCC_EOS
15800                                           ! 2969             case 1: mouse_data1 = 20; break;
15801                       00004402            .3B5:
15802                                           ! Debug: eq int = const $14 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15803 4402           B0                     14  mov	al,*$14
15804 4404           8846         F4            mov	-$C[bp],al
15805                                           !BCC_EOS
15806 4407           EB           4E            jmp .3B1
15807                                           !BCC_EOS
15808                                           ! 2970             case 2: mouse_data1 = 40; break;
15809                       00004409            .3B6:
15810                                           ! Debug: eq int = const $28 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15811 4409           B0                     28  mov	al,*$28
15812 440B           8846         F4            mov	-$C[bp],al
15813                                           !BCC_EOS
15814 440E           EB           47            jmp .3B1
15815                                           !BCC_EOS
15816                                           ! 2971             case 3: mouse_data1 = 60; break;
15817                       00004410            .3B7:
15818                                           ! Debug: eq int = const $3C to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15819 4410           B0                     3C  mov	al,*$3C
15820 4412           8846         F4            mov	-$C[bp],al
15821                                           !BCC_EOS
15822 4415           EB           40            jmp .3B1
15823                                           !BCC_EOS
15824                                           ! 2972             case 4: mouse_data1 = 80; break;
15825                       00004417            .3B8:
15826                                           ! Debug: eq int = const $50 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15827 4417           B0                     50  mov	al,*$50
15828 4419           8846         F4            mov	-$C[bp],al
15829                                           !BCC_EOS
15830 441C           EB           39            jmp .3B1
15831                                           !BCC_EOS
15832                                           ! 2973             case 5: mouse_data1 = 100; break;
15833                       0000441E            .3B9:
15834                                           ! Debug: eq int = const $64 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15835 441E           B0                     64  mov	al,*$64
15836 4420           8846         F4            mov	-$C[bp],al
15837                                           !BCC_EOS
15838 4423           EB           32            jmp .3B1
15839                                           !BCC_EOS
15840                                           ! 2974             case 6: mouse_data1 = 200; break;
15841                       00004425            .3BA:
15842                                           ! Debug: eq int = const $C8 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15843 4425           B0                     C8  mov	al,#$C8
15844 4427           8846         F4            mov	-$C[bp],al
15845                                           !BCC_EOS
15846 442A           E9         002A            br 	.3B1
15847                                           !BCC_EOS
15848                                           ! 2975             default: mouse_data1 = 0;
15849                       0000442D            .3BB:
15850                                           ! Debug: eq int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15851 442D           30C0                       xor	al,al
15852 442F           8846         F4            mov	-$C[bp],al
15853                                           !BCC_EOS
15854                                           ! 2976 
15855                                           ! 2976           }
15856                                           ! 2977           if (mouse_data1 > 0) {
15857 4432           EB           23            jmp .3B1
15858                       00004434            .3B3:
15859 4434           2C                     00  sub	al,*0
15860 4436           72           F5            jb 	.3BB
15861 4438           3C                     06  cmp	al,*6
15862 443A           77           19            ja  	.3BC
15863 443C           30E4                       xor	ah,ah
15864 443E           D1E0                       shl	ax,*1
15865 4440           89C3                       mov	bx,ax
15866 4442           2E                         seg	cs
15867 4443           FFA7       4447            br	.3BD[bx]
15868                       00004447            .3BD:
15869 4447                      43FB            .word	.3B4
15870 4449                      4402            .word	.3B5
15871 444B                      4409            .word	.3B6
15872 444D                      4410            .word	.3B7
15873 444F                      4417            .word	.3B8
15874 4451                      441E            .word	.3B9
15875 4453                      4425            .word	.3BA
15876                       00004455            .3BC:
15877 4455           EB           D6            jmp	.3BB
15878                       00004457            .3B1:
15879                                           ! Debug: gt int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15880 4457           8A46         F4            mov	al,-$C[bp]
15881 445A           84C0                       test	al,al
15882 445C           74           57            je  	.3BE
15883                       0000445E            .3BF:
15884                                           ! 2978             ret = send_to_mouse_ctrl(0xF3);
15885                                           ! Debug: list int = const $F3 (used reg = )
15886 445E           B8                   00F3  mov	ax,#$F3
15887 4461           50                         push	ax
15888                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15889 4462           E8         0EE3            call	_send_to_mouse_ctrl
15890 4465           44                         inc	sp
15891 4466           44                         inc	sp
15892                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15893 4467           8846         F5            mov	-$B[bp],al
15894                                           !BCC_EOS
15895                                           ! 2979             if (ret == 0) {
15896                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15897 446A           8A46         F5            mov	al,-$B[bp]
15898 446D           84C0                       test	al,al
15899 446F           75           35            jne 	.3C0
15900                       00004471            .3C1:
15901                                           ! 2980               ret = get_mouse_data(&mouse_data2);
15902                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
15903 4471           8D5E         F3            lea	bx,-$D[bp]
15904 4474           53                         push	bx
15905                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15906 4475           E8         0F1A            call	_get_mouse_data
15907 4478           44                         inc	sp
15908 4479           44                         inc	sp
15909                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15910 447A           8846         F5            mov	-$B[bp],al
15911                                           !BCC_EOS
15912                                           ! 2981               ret = send_to_mouse_ctrl(mouse_data1);
15913                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15914 447D           8A46         F4            mov	al,-$C[bp]
15915 4480           30E4                       xor	ah,ah
15916 4482           50                         push	ax
15917                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15918 4483           E8         0EC2            call	_send_to_mouse_ctrl
15919 4486           44                         inc	sp
15920 4487           44                         inc	sp
15921                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15922 4488           8846         F5            mov	-$B[bp],al
15923                                           !BCC_EOS
15924                                           ! 2982               ret = get_mouse_data(&mouse_data2);
15925                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
15926 448B           8D5E         F3            lea	bx,-$D[bp]
15927 448E           53                         push	bx
15928                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15929 448F           E8         0F00            call	_get_mouse_data
15930 4492           44                         inc	sp
15931 4493           44                         inc	sp
15932                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15933 4494           8846         F5            mov	-$B[bp],al
15934                                           !BCC_EOS
15935                                           ! 2983               FLAGS &= 0xfffe;
15936                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
15937 4497           8B46         18            mov	ax,$18[bp]
15938 449A           24                     FE  and	al,#$FE
15939 449C           8946         18            mov	$18[bp],ax
15940                                           !BCC_EOS
15941                                           ! 2984               regs.u.r8.ah = 0;
15942                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
15943 449F           30C0                       xor	al,al
15944 44A1           8846         13            mov	$13[bp],al
15945                                           !BCC_EOS
15946                                           ! 2985             } else {
15947 44A4           EB           0D            jmp .3C2
15948                       000044A6            .3C0:
15949                                           ! 2986               FLAGS |= 0x0001;
15950                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15951 44A6           8B46         18            mov	ax,$18[bp]
15952 44A9           0C                     01  or	al,*1
15953 44AB           8946         18            mov	$18[bp],ax
15954                                           !BCC_EOS
15955                                           ! 2987               regs.u.r8.ah = 0x86;
15956                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
15957 44AE           B0                     86  mov	al,#$86
15958 44B0           8846         13            mov	$13[bp],al
15959                                           !BCC_EOS
15960                                           ! 2988             }
15961                                           ! 2989           } else {
15962                       000044B3            .3C2:
15963 44B3           EB           0D            jmp .3C3
15964                       000044B5            .3BE:
15965                                           ! 2990             FLAGS |= 0x0001;
15966                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15967 44B5           8B46         18            mov	ax,$18[bp]
15968 44B8           0C                     01  or	al,*1
15969 44BA           8946         18            mov	$18[bp],ax
15970                                           !BCC_EOS
15971                                           ! 2991             regs.u.r8.ah = 0x86;
15972                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
15973 44BD           B0                     86  mov	al,#$86
15974 44BF           8846         13            mov	$13[bp],al
15975                                           !BCC_EOS
15976                                           ! 2992           }
15977                                           ! 2993           break;
15978                       000044C2            .3C3:
15979 44C2           E9         033F            br 	.386
15980                                           !BCC_EOS
15981                                           ! 2994         case 3:
15982                                           ! 2995 ;
15983                       000044C5            .3C4:
15984                                           !BCC_EOS
15985                                           ! 2996           comm_byte = inhibit_mouse_int_and_events();
15986                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
15987 44C5           E8         0D2F            call	_inhibit_mouse_int_and_events
15988                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
15989 44C8           8846         F7            mov	-9[bp],al
15990                                           !BCC_EOS
15991                                           ! 2997           if (regs.u.r8.bh < 4) {
15992                                           ! Debug: lt int = const 4 to unsigned char regs = [S+$10+$B] (used reg = )
15993 44CB           8A46         0D            mov	al,$D[bp]
15994 44CE           3C                     04  cmp	al,*4
15995 44D0         0F83         008D            bhis	.3C5
15996                       000044D4            .3C6:
15997                                           ! 2998             ret = send_to_mouse_ctrl(0xE8);
15998                                           ! Debug: list int = const $E8 (used reg = )
15999 44D4           B8                   00E8  mov	ax,#$E8
16000 44D7           50                         push	ax
16001                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16002 44D8           E8         0E6D            call	_send_to_mouse_ctrl
16003 44DB           44                         inc	sp
16004 44DC           44                         inc	sp
16005                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16006 44DD           8846         F5            mov	-$B[bp],al
16007                                           !BCC_EOS
16008                                           ! 2999             if (ret == 0) {
16009                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16010 44E0           8A46         F5            mov	al,-$B[bp]
16011 44E3           84C0                       test	al,al
16012 44E5           75           6B            jne 	.3C7
16013                       000044E7            .3C8:
16014                                           ! 3000               ret = get_mouse_data(&mouse_data1);
16015                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16016 44E7           8D5E         F4            lea	bx,-$C[bp]
16017 44EA           53                         push	bx
16018                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16019 44EB           E8         0EA4            call	_get_mouse_data
16020 44EE           44                         inc	sp
16021 44EF           44                         inc	sp
16022                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16023 44F0           8846         F5            mov	-$B[bp],al
16024                                           !BCC_EOS
16025                                           ! 3001               if (mouse_data1 != 0xfa)
16026                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16027 44F3           8A46         F4            mov	al,-$C[bp]
16028 44F6           3C                     FA  cmp	al,#$FA
16029 44F8           74           14            je  	.3C9
16030                       000044FA            .3CA:
16031                                           ! 3002                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
16032                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16033 44FA           8A46         F4            mov	al,-$C[bp]
16034 44FD           30E4                       xor	ah,ah
16035 44FF           50                         push	ax
16036                                           ! Debug: list * char = .3CB+0 (used reg = )
16037 4500           BB                   D49F  mov	bx,#.3CB
16038 4503           53                         push	bx
16039                                           ! Debug: list int = const 7 (used reg = )
16040 4504           B8                   0007  mov	ax,*7
16041 4507           50                         push	ax
16042                                           ! Debug: func () void = bios_printf+0 (used reg = )
16043 4508           E8         C433            call	_bios_printf
16044 450B           83C4                   06  add	sp,*6
16045                                           !BCC_EOS
16046                                           ! 3003               ret = send_to_mouse_ctrl(regs.u.r8.bh);
16047                       0000450E            .3C9:
16048                                           ! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
16049 450E           8A46         0D            mov	al,$D[bp]
16050 4511           30E4                       xor	ah,ah
16051 4513           50                         push	ax
16052                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16053 4514           E8         0E31            call	_send_to_mouse_ctrl
16054 4517           44                         inc	sp
16055 4518           44                         inc	sp
16056                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16057 4519           8846         F5            mov	-$B[bp],al
16058                                           !BCC_EOS
16059                                           ! 3004               ret = get_mouse_data(&mouse_data1);
16060                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16061 451C           8D5E         F4            lea	bx,-$C[bp]
16062 451F           53                         push	bx
16063                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16064 4520           E8         0E6F            call	_get_mouse_data
16065 4523           44                         inc	sp
16066 4524           44                         inc	sp
16067                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16068 4525           8846         F5            mov	-$B[bp],al
16069                                           !BCC_EOS
16070                                           ! 3005               if (mouse_data1 != 0xfa)
16071                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16072 4528           8A46         F4            mov	al,-$C[bp]
16073 452B           3C                     FA  cmp	al,#$FA
16074 452D           74           14            je  	.3CC
16075                       0000452F            .3CD:
16076                                           ! 3006                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
16077                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16078 452F           8A46         F4            mov	al,-$C[bp]
16079 4532           30E4                       xor	ah,ah
16080 4534           50                         push	ax
16081                                           ! Debug: list * char = .3CE+0 (used reg = )
16082 4535           BB                   D473  mov	bx,#.3CE
16083 4538           53                         push	bx
16084                                           ! Debug: list int = const 7 (used reg = )
16085 4539           B8                   0007  mov	ax,*7
16086 453C           50                         push	ax
16087                                           ! Debug: func () void = bios_printf+0 (used reg = )
16088 453D           E8         C3FE            call	_bios_printf
16089 4540           83C4                   06  add	sp,*6
16090                                           !BCC_EOS
16091                                           ! 3007               FLAGS &= 0xfffe;
16092                       00004543            .3CC:
16093                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16094 4543           8B46         18            mov	ax,$18[bp]
16095 4546           24                     FE  and	al,#$FE
16096 4548           8946         18            mov	$18[bp],ax
16097                                           !BCC_EOS
16098                                           ! 3008               regs.u.r8.ah = 0;
16099                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16100 454B           30C0                       xor	al,al
16101 454D           8846         13            mov	$13[bp],al
16102                                           !BCC_EOS
16103                                           ! 3009             } else {
16104 4550           EB           0D            jmp .3CF
16105                       00004552            .3C7:
16106                                           ! 3010               FLAGS |= 0x0001;
16107                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16108 4552           8B46         18            mov	ax,$18[bp]
16109 4555           0C                     01  or	al,*1
16110 4557           8946         18            mov	$18[bp],ax
16111                                           !BCC_EOS
16112                                           ! 3011               regs.u.r8.ah = 0x86;
16113                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16114 455A           B0                     86  mov	al,#$86
16115 455C           8846         13            mov	$13[bp],al
16116                                           !BCC_EOS
16117                                           ! 3012             }
16118                                           ! 3013           } else {
16119                       0000455F            .3CF:
16120 455F           EB           0D            jmp .3D0
16121                       00004561            .3C5:
16122                                           ! 3014             FLAGS |= 0x0001;
16123                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16124 4561           8B46         18            mov	ax,$18[bp]
16125 4564           0C                     01  or	al,*1
16126 4566           8946         18            mov	$18[bp],ax
16127                                           !BCC_EOS
16128                                           ! 3015             regs.u.r8.ah = 0x86;
16129                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16130 4569           B0                     86  mov	al,#$86
16131 456B           8846         13            mov	$13[bp],al
16132                                           !BCC_EOS
16133                                           ! 3016           }
16134                                           ! 3017           set_kbd_command_byte(comm_byte);
16135                       0000456E            .3D0:
16136                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
16137 456E           8A46         F7            mov	al,-9[bp]
16138 4571           30E4                       xor	ah,ah
16139 4573           50                         push	ax
16140                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
16141 4574           E8         0E52            call	_set_kbd_command_byte
16142 4577           44                         inc	sp
16143 4578           44                         inc	sp
16144                                           !BCC_EOS
16145                                           ! 3018           break;
16146 4579           E9         0288            br 	.386
16147                                           !BCC_EOS
16148                                           ! 3019         case 4:
16149                                           ! 3020 ;
16150                       0000457C            .3D1:
16151                                           !BCC_EOS
16152                                           ! 3021           inhibit_mouse_int_and_events();
16153                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
16154 457C           E8         0C78            call	_inhibit_mouse_int_and_events
16155                                           !BCC_EOS
16156                                           ! 3022           ret = send_to_mouse_ctrl(0xF2);
16157                                           ! Debug: list int = const $F2 (used reg = )
16158 457F           B8                   00F2  mov	ax,#$F2
16159 4582           50                         push	ax
16160                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16161 4583           E8         0DC2            call	_send_to_mouse_ctrl
16162 4586           44                         inc	sp
16163 4587           44                         inc	sp
16164                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16165 4588           8846         F5            mov	-$B[bp],al
16166                                           !BCC_EOS
16167                                           ! 3023           if (ret == 0) {
16168                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16169 458B           8A46         F5            mov	al,-$B[bp]
16170 458E           84C0                       test	al,al
16171 4590           75           2D            jne 	.3D2
16172                       00004592            .3D3:
16173                                           ! 3024             ret = get_mouse_data(&mouse_data1);
16174                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16175 4592           8D5E         F4            lea	bx,-$C[bp]
16176 4595           53                         push	bx
16177                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16178 4596           E8         0DF9            call	_get_mouse_data
16179 4599           44                         inc	sp
16180 459A           44                         inc	sp
16181                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16182 459B           8846         F5            mov	-$B[bp],al
16183                                           !BCC_EOS
16184                                           ! 3025             ret = get_mouse_data(&mouse_data2);
16185                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
16186 459E           8D5E         F3            lea	bx,-$D[bp]
16187 45A1           53                         push	bx
16188                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16189 45A2           E8         0DED            call	_get_mouse_data
16190 45A5           44                         inc	sp
16191 45A6           44                         inc	sp
16192                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16193 45A7           8846         F5            mov	-$B[bp],al
16194                                           !BCC_EOS
16195                                           ! 3026             FLAGS &= 0xfffe;
16196                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16197 45AA           8B46         18            mov	ax,$18[bp]
16198 45AD           24                     FE  and	al,#$FE
16199 45AF           8946         18            mov	$18[bp],ax
16200                                           !BCC_EOS
16201                                           ! 3027             regs.u.r8.ah = 0;
16202                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16203 45B2           30C0                       xor	al,al
16204 45B4           8846         13            mov	$13[bp],al
16205                                           !BCC_EOS
16206                                           ! 3028             regs.u.r8.bh = mouse_data2;
16207                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
16208 45B7           8A46         F3            mov	al,-$D[bp]
16209 45BA           8846         0D            mov	$D[bp],al
16210                                           !BCC_EOS
16211                                           ! 3029           } else {
16212 45BD           EB           0D            jmp .3D4
16213                       000045BF            .3D2:
16214                                           ! 3030             FLAGS |= 0x0001;
16215                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16216 45BF           8B46         18            mov	ax,$18[bp]
16217 45C2           0C                     01  or	al,*1
16218 45C4           8946         18            mov	$18[bp],ax
16219                                           !BCC_EOS
16220                                           ! 3031             regs.u.r8.ah = 0x86;
16221                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16222 45C7           B0                     86  mov	al,#$86
16223 45C9           8846         13            mov	$13[bp],al
16224                                           !BCC_EOS
16225                                           ! 3032           }
16226                                           ! 3033           break;
16227                       000045CC            .3D4:
16228 45CC           E9         0235            br 	.386
16229                                           !BCC_EOS
16230                                           ! 3034         case 6:
16231                                           ! 3035 ;
16232                       000045CF            .3D5:
16233                                           !BCC_EOS
16234                                           ! 3036           switch (regs.u.r8.bh) {
16235 45CF           8A46         0D            mov	al,$D[bp]
16236 45D2           E9         015A            br 	.3D8
16237                                           ! 3037             case 0:
16238                                           ! 3038               comm_byte = inhibit_mouse_int_an
16239                       000045D5            .3D9:
16240                                           ! 3038 d_events();
16241                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
16242 45D5           E8         0C1F            call	_inhibit_mouse_int_and_events
16243                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
16244 45D8           8846         F7            mov	-9[bp],al
16245                                           !BCC_EOS
16246                                           ! 3039               ret = send_to_mouse_ctrl(0xE9);
16247                                           ! Debug: list int = const $E9 (used reg = )
16248 45DB           B8                   00E9  mov	ax,#$E9
16249 45DE           50                         push	ax
16250                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16251 45DF           E8         0D66            call	_send_to_mouse_ctrl
16252 45E2           44                         inc	sp
16253 45E3           44                         inc	sp
16254                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16255 45E4           8846         F5            mov	-$B[bp],al
16256                                           !BCC_EOS
16257                                           ! 3040               if (ret == 0) {
16258                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16259 45E7           8A46         F5            mov	al,-$B[bp]
16260 45EA           84C0                       test	al,al
16261 45EC         0F85         0095            bne 	.3DA
16262                       000045F0            .3DB:
16263                                           ! 3041                 ret = get_mouse_data(&mouse_data1);
16264                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16265 45F0           8D5E         F4            lea	bx,-$C[bp]
16266 45F3           53                         push	bx
16267                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16268 45F4           E8         0D9B            call	_get_mouse_data
16269 45F7           44                         inc	sp
16270 45F8           44                         inc	sp
16271                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16272 45F9           8846         F5            mov	-$B[bp],al
16273                                           !BCC_EOS
16274                                           ! 3042                 if (mouse_data1 != 0xfa)
16275                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16276 45FC           8A46         F4            mov	al,-$C[bp]
16277 45FF           3C                     FA  cmp	al,#$FA
16278 4601           74           14            je  	.3DC
16279                       00004603            .3DD:
16280                                           ! 3043                   bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
16281                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16282 4603           8A46         F4            mov	al,-$C[bp]
16283 4606           30E4                       xor	ah,ah
16284 4608           50                         push	ax
16285                                           ! Debug: list * char = .3DE+0 (used reg = )
16286 4609           BB                   D447  mov	bx,#.3DE
16287 460C           53                         push	bx
16288                                           ! Debug: list int = const 7 (used reg = )
16289 460D           B8                   0007  mov	ax,*7
16290 4610           50                         push	ax
16291                                           ! Debug: func () void = bios_printf+0 (used reg = )
16292 4611           E8         C32A            call	_bios_printf
16293 4614           83C4                   06  add	sp,*6
16294                                           !BCC_EOS
16295                                           ! 3044                 if (ret == 0) {
16296                       00004617            .3DC:
16297                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16298 4617           8A46         F5            mov	al,-$B[bp]
16299 461A           84C0                       test	al,al
16300 461C           75           67            jne 	.3DF
16301                       0000461E            .3E0:
16302                                           ! 3045                   ret = get_mouse_data(&mouse_data1);
16303                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16304 461E           8D5E         F4            lea	bx,-$C[bp]
16305 4621           53                         push	bx
16306                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16307 4622           E8         0D6D            call	_get_mouse_data
16308 4625           44                         inc	sp
16309 4626           44                         inc	sp
16310                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16311 4627           8846         F5            mov	-$B[bp],al
16312                                           !BCC_EOS
16313                                           ! 3046                   if (ret == 0) {
16314                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16315 462A           8A46         F5            mov	al,-$B[bp]
16316 462D           84C0                       test	al,al
16317 462F           75           54            jne 	.3E1
16318                       00004631            .3E2:
16319                                           ! 3047                     ret = get_mouse_data(&mouse_data2);
16320                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
16321 4631           8D5E         F3            lea	bx,-$D[bp]
16322 4634           53                         push	bx
16323                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16324 4635           E8         0D5A            call	_get_mouse_data
16325 4638           44                         inc	sp
16326 4639           44                         inc	sp
16327                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16328 463A           8846         F5            mov	-$B[bp],al
16329                                           !BCC_EOS
16330                                           ! 3048                     if (ret == 0) {
16331                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16332 463D           8A46         F5            mov	al,-$B[bp]
16333 4640           84C0                       test	al,al
16334 4642           75           41            jne 	.3E3
16335                       00004644            .3E4:
16336                                           ! 3049                       ret = get_mouse_data(&mouse_data3);
16337                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
16338 4644           8D5E         F2            lea	bx,-$E[bp]
16339 4647           53                         push	bx
16340                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16341 4648           E8         0D47            call	_get_mouse_data
16342 464B           44                         inc	sp
16343 464C           44                         inc	sp
16344                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16345 464D           8846         F5            mov	-$B[bp],al
16346                                           !BCC_EOS
16347                                           ! 3050                       if (ret == 0) {
16348                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16349 4650           8A46         F5            mov	al,-$B[bp]
16350 4653           84C0                       test	al,al
16351 4655           75           2E            jne 	.3E5
16352                       00004657            .3E6:
16353                                           ! 3051                         FLAGS &= 0xfffe;
16354                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16355 4657           8B46         18            mov	ax,$18[bp]
16356 465A           24                     FE  and	al,#$FE
16357 465C           8946         18            mov	$18[bp],ax
16358                                           !BCC_EOS
16359                                           ! 3052                         regs.u.r8.ah = 0;
16360                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16361 465F           30C0                       xor	al,al
16362 4661           8846         13            mov	$13[bp],al
16363                                           !BCC_EOS
16364                                           ! 3053                         regs.u.r8.bl = mouse_data1;
16365                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
16366 4664           8A46         F4            mov	al,-$C[bp]
16367 4667           8846         0C            mov	$C[bp],al
16368                                           !BCC_EOS
16369                                           ! 3054                         regs.u.r8.cl = mouse_data2;
16370                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$E] (used reg = )
16371 466A           8A46         F3            mov	al,-$D[bp]
16372 466D           8846         10            mov	$10[bp],al
16373                                           !BCC_EOS
16374                                           ! 3055                         regs.u.r8.dl = mouse_data3;
16375                                           ! Debug: eq unsigned char mouse_data3 = [S+$10-$10] to unsigned char regs = [S+$10+$C] (used reg = )
16376 4670           8A46         F2            mov	al,-$E[bp]
16377 4673           8846         0E            mov	$E[bp],al
16378                                           !BCC_EOS
16379                                           ! 3056                         set_kbd_command_byte(comm_byte);
16380                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
16381 4676           8A46         F7            mov	al,-9[bp]
16382 4679           30E4                       xor	ah,ah
16383 467B           50                         push	ax
16384                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
16385 467C           E8         0D4A            call	_set_kbd_command_byte
16386 467F           44                         inc	sp
16387 4680           44                         inc	sp
16388                                           !BCC_EOS
16389                                           ! 3057                         return;
16390 4681           89EC                       mov	sp,bp
16391 4683           5D                         pop	bp
16392 4684           C3                         ret
16393                                           !BCC_EOS
16394                                           ! 3058                       }
16395                                           ! 3059                     }
16396                       00004685            .3E5:
16397                                           ! 3060                   }
16398                       00004685            .3E3:
16399                                           ! 3061                 }
16400                       00004685            .3E1:
16401                                           ! 3062               }
16402                       00004685            .3DF:
16403                                           ! 3063               FLAGS |= 0x0001;
16404                       00004685            .3DA:
16405                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16406 4685           8B46         18            mov	ax,$18[bp]
16407 4688           0C                     01  or	al,*1
16408 468A           8946         18            mov	$18[bp],ax
16409                                           !BCC_EOS
16410                                           ! 3064               regs.u.r8.ah = ret;
16411                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
16412 468D           8A46         F5            mov	al,-$B[bp]
16413 4690           8846         13            mov	$13[bp],al
16414                                           !BCC_EOS
16415                                           ! 3065               set_kbd_command_byte(comm_byte);
16416                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
16417 4693           8A46         F7            mov	al,-9[bp]
16418 4696           30E4                       xor	ah,ah
16419 4698           50                         push	ax
16420                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
16421 4699           E8         0D2D            call	_set_kbd_command_byte
16422 469C           44                         inc	sp
16423 469D           44                         inc	sp
16424                                           !BCC_EOS
16425                                           ! 3066               return;
16426 469E           89EC                       mov	sp,bp
16427 46A0           5D                         pop	bp
16428 46A1           C3                         ret
16429                                           !BCC_EOS
16430                                           ! 3067             case 1:
16431                                           ! 3068             case 2:
16432                       000046A2            .3E7:
16433                                           ! 3069               comm_byte = inhibit_mouse_int_and_events();
16434                       000046A2            .3E8:
16435                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
16436 46A2           E8         0B52            call	_inhibit_mouse_int_and_events
16437                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
16438 46A5           8846         F7            mov	-9[bp],al
16439                                           !BCC_EOS
16440                                           ! 3070               if (regs.u.r8.bh == 1) {
16441                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$10+$B] (used reg = )
16442 46A8           8A46         0D            mov	al,$D[bp]
16443 46AB           3C                     01  cmp	al,*1
16444 46AD           75           0E            jne 	.3E9
16445                       000046AF            .3EA:
16446                                           ! 3071                 ret = send_to_mouse_ctrl(0xE6);
16447                                           ! Debug: list int = const $E6 (used reg = )
16448 46AF           B8                   00E6  mov	ax,#$E6
16449 46B2           50                         push	ax
16450                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16451 46B3           E8         0C92            call	_send_to_mouse_ctrl
16452 46B6           44                         inc	sp
16453 46B7           44                         inc	sp
16454                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16455 46B8           8846         F5            mov	-$B[bp],al
16456                                           !BCC_EOS
16457                                           ! 3072               } else {
16458 46BB           EB           0C            jmp .3EB
16459                       000046BD            .3E9:
16460                                           ! 3073                 ret = send_to_mouse_ctrl(0xE7);
16461                                           ! Debug: list int = const $E7 (used reg = )
16462 46BD           B8                   00E7  mov	ax,#$E7
16463 46C0           50                         push	ax
16464                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16465 46C1           E8         0C84            call	_send_to_mouse_ctrl
16466 46C4           44                         inc	sp
16467 46C5           44                         inc	sp
16468                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16469 46C6           8846         F5            mov	-$B[bp],al
16470                                           !BCC_EOS
16471                                           ! 3074               }
16472                                           ! 3075               if (ret == 0) {
16473                       000046C9            .3EB:
16474                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16475 46C9           8A46         F5            mov	al,-$B[bp]
16476 46CC           84C0                       test	al,al
16477 46CE           75           19            jne 	.3EC
16478                       000046D0            .3ED:
16479                                           ! 3076                 get_mouse_data(&mouse_data1);
16480                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16481 46D0           8D5E         F4            lea	bx,-$C[bp]
16482 46D3           53                         push	bx
16483                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16484 46D4           E8         0CBB            call	_get_mouse_data
16485 46D7           44                         inc	sp
16486 46D8           44                         inc	sp
16487                                           !BCC_EOS
16488                                           ! 3077                 ret = (mouse_data1 != 0xFA);
16489                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16490 46D9           8A46         F4            mov	al,-$C[bp]
16491 46DC           3C                     FA  cmp	al,#$FA
16492 46DE           74           04            je 	.3EE
16493 46E0           B0                     01  mov	al,*1
16494 46E2           EB           02            jmp	.3EF
16495                       000046E4            .3EE:
16496 46E4           30C0                       xor	al,al
16497                       000046E6            .3EF:
16498                                           ! Debug: eq char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16499 46E6           8846         F5            mov	-$B[bp],al
16500                                           !BCC_EOS
16501                                           ! 3078               }
16502                                           ! 3079               if (ret == 0) {
16503                       000046E9            .3EC:
16504                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16505 46E9           8A46         F5            mov	al,-$B[bp]
16506 46EC           84C0                       test	al,al
16507 46EE           75           0F            jne 	.3F0
16508                       000046F0            .3F1:
16509                                           ! 3080                 FLAGS &= 0xfffe;
16510                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16511 46F0           8B46         18            mov	ax,$18[bp]
16512 46F3           24                     FE  and	al,#$FE
16513 46F5           8946         18            mov	$18[bp],ax
16514                                           !BCC_EOS
16515                                           ! 3081                 regs.u.r8.ah = 0;
16516                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16517 46F8           30C0                       xor	al,al
16518 46FA           8846         13            mov	$13[bp],al
16519                                           !BCC_EOS
16520                                           ! 3082               } else {
16521 46FD           EB           0D            jmp .3F2
16522                       000046FF            .3F0:
16523                                           ! 3083                 FLAGS |= 0x0001;
16524                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16525 46FF           8B46         18            mov	ax,$18[bp]
16526 4702           0C                     01  or	al,*1
16527 4704           8946         18            mov	$18[bp],ax
16528                                           !BCC_EOS
16529                                           ! 3084                 regs.u.r8.ah = 0x86;
16530                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16531 4707           B0                     86  mov	al,#$86
16532 4709           8846         13            mov	$13[bp],al
16533                                           !BCC_EOS
16534                                           ! 3085               }
16535                                           ! 3086               set_kbd_command_byte(comm_byte);
16536                       0000470C            .3F2:
16537                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
16538 470C           8A46         F7            mov	al,-9[bp]
16539 470F           30E4                       xor	ah,ah
16540 4711           50                         push	ax
16541                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
16542 4712           E8         0CB4            call	_set_kbd_command_byte
16543 4715           44                         inc	sp
16544 4716           44                         inc	sp
16545                                           !BCC_EOS
16546                                           ! 3087               break;
16547 4717           EB           2A            jmp .3D6
16548                                           !BCC_EOS
16549                                           ! 3088             default:
16550                                           ! 3089               bios_printf((2 | 4 | 1), "INT 15h C2 AL=6, BH=%02x\n", (unsigned) regs.u.r8.bh);
16551                       00004719            .3F3:
16552                                           ! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
16553 4719           8A46         0D            mov	al,$D[bp]
16554 471C           30E4                       xor	ah,ah
16555 471E           50                         push	ax
16556                                           ! Debug: list * char = .3F4+0 (used reg = )
16557 471F           BB                   D42D  mov	bx,#.3F4
16558 4722           53                         push	bx
16559                                           ! Debug: list int = const 7 (used reg = )
16560 4723           B8                   0007  mov	ax,*7
16561 4726           50                         push	ax
16562                                           ! Debug: func () void = bios_printf+0 (used reg = )
16563 4727           E8         C214            call	_bios_printf
16564 472A           83C4                   06  add	sp,*6
16565                                           !BCC_EOS
16566                                           ! 3090           }
16567                                           ! 3091           break;
16568 472D           EB           14            jmp .3D6
16569                       0000472F            .3D8:
16570 472F           2C                     00  sub	al,*0
16571 4731         0F84         FEA0            beq 	.3D9
16572 4735           2C                     01  sub	al,*1
16573 4737         0F84         FF67            beq 	.3E7
16574 473B           2C                     01  sub	al,*1
16575 473D         0F84         FF61            beq 	.3E8
16576 4741           EB           D6            jmp	.3F3
16577                       00004743            .3D6:
16578 4743           E9         00BE            br 	.386
16579                                           !BCC_EOS
16580                                           ! 3092         case 7:
16581                                           ! 3093 ;
16582                       00004746            .3F5:
16583                                           !BCC_EOS
16584                                           ! 3094           mouse_driver_seg = ES;
16585                                           ! Debug: eq unsigned short ES = [S+$10+$12] to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
16586 4746           8B46         14            mov	ax,$14[bp]
16587 4749           8946         FA            mov	-6[bp],ax
16588                                           !BCC_EOS
16589                                           ! 3095    
16590                                           ! 3095        mouse_driver_offset = regs.u.r16.bx;
16591                                           ! Debug: eq unsigned short regs = [S+$10+$A] to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
16592 474C           8B46         0C            mov	ax,$C[bp]
16593 474F           8946         F8            mov	-8[bp],ax
16594                                           !BCC_EOS
16595                                           ! 3096           _write_word(mouse_driver_offset, &((ebda_data_t *) 0)->mouse_driver_offset, ebda_seg);
16596                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
16597 4752           FF76         FE            push	-2[bp]
16598                                           ! Debug: list * unsigned short = const $22 (used reg = )
16599 4755           B8                   0022  mov	ax,*$22
16600 4758           50                         push	ax
16601                                           ! Debug: list unsigned short mouse_driver_offset = [S+$14-$A] (used reg = )
16602 4759           FF76         F8            push	-8[bp]
16603                                           ! Debug: func () void = _write_word+0 (used reg = )
16604 475C           E8         BEB4            call	__write_word
16605 475F           83C4                   06  add	sp,*6
16606                                           !BCC_EOS
16607                                           ! 3097           _write_word(mouse_driver_seg, &((ebda_data_t *) 0)->mouse_driver_seg, ebda_seg);
16608                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
16609 4762           FF76         FE            push	-2[bp]
16610                                           ! Debug: list * unsigned short = const $24 (used reg = )
16611 4765           B8                   0024  mov	ax,*$24
16612 4768           50                         push	ax
16613                                           ! Debug: list unsigned short mouse_driver_seg = [S+$14-8] (used reg = )
16614 4769           FF76         FA            push	-6[bp]
16615                                           ! Debug: func () void = _write_word+0 (used reg = )
16616 476C           E8         BEA4            call	__write_word
16617 476F           83C4                   06  add	sp,*6
16618                                           !BCC_EOS
16619                                           ! 3098           mouse_flags_2 = _read_byte(&((ebda_data_t *) 0)->mouse_flag2, ebda_seg);
16620                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
16621 4772           FF76         FE            push	-2[bp]
16622                                           ! Debug: list * unsigned char = const $27 (used reg = )
16623 4775           B8                   0027  mov	ax,*$27
16624 4778           50                         push	ax
16625                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
16626 4779           E8         BE68            call	__read_byte
16627 477C           83C4                   04  add	sp,*4
16628                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16629 477F           8846         FC            mov	-4[bp],al
16630                                           !BCC_EOS
16631                                           ! 3099           if (mouse_driver_offset == 0 && mouse_driver_seg == 0) {
16632                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
16633 4782           8B46         F8            mov	ax,-8[bp]
16634 4785           85C0                       test	ax,ax
16635 4787           75           1D            jne 	.3F6
16636                       00004789            .3F8:
16637                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
16638 4789           8B46         FA            mov	ax,-6[bp]
16639 478C           85C0                       test	ax,ax
16640 478E           75           16            jne 	.3F6
16641                       00004790            .3F7:
16642                                           ! 3100             if ( (mouse_flags_2 & 0x80) != 0 ) {
16643                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16644 4790           8A46         FC            mov	al,-4[bp]
16645 4793           24                     80  and	al,#$80
16646                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
16647 4795           84C0                       test	al,al
16648 4797           74           0B            je  	.3F9
16649                       00004799            .3FA:
16650                                           ! 3101               mouse_flags_2 &= ~0x80;
16651                                           ! Debug: andab int = const -$81 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16652 4799           8A46         FC            mov	al,-4[bp]
16653 479C           24                     7F  and	al,*$7F
16654 479E           8846         FC            mov	-4[bp],al
16655                                           !BCC_EOS
16656                                           ! 3102               inhibit_mouse_int_and_events();
16657                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
16658 47A1           E8         0A53            call	_inhibit_mouse_int_and_events
16659                                           !BCC_EOS
16660                                           ! 3103             }
16661                                           ! 3104           }
16662                       000047A4            .3F9:
16663                                           ! 3105           else {
16664 47A4           EB           08            jmp .3FB
16665                       000047A6            .3F6:
16666                                           ! 3106             mouse_flags_2 |= 0x80;
16667                                           ! Debug: orab int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16668 47A6           8A46         FC            mov	al,-4[bp]
16669 47A9           0C                     80  or	al,#$80
16670 47AB           8846         FC            mov	-4[bp],al
16671                                           !BCC_EOS
16672                                           ! 3107           }
16673                                           ! 3108           _write_byte(mouse_flags_2, &((ebda_data_t *) 0)->mouse_flag2, ebda_seg);
16674                       000047AE            .3FB:
16675                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
16676 47AE           FF76         FE            push	-2[bp]
16677                                           ! Debug: list * unsigned char = const $27 (used reg = )
16678 47B1           B8                   0027  mov	ax,*$27
16679 47B4           50                         push	ax
16680                                           ! Debug: list unsigned char mouse_flags_2 = [S+$14-6] (used reg = )
16681 47B5           8A46         FC            mov	al,-4[bp]
16682 47B8           30E4                       xor	ah,ah
16683 47BA           50                         push	ax
16684                                           ! Debug: func () void = _write_byte+0 (used reg = )
16685 47BB           E8         BE42            call	__write_byte
16686 47BE           83C4                   06  add	sp,*6
16687                                           !BCC_EOS
16688                                           ! 3109           FLAGS &= 0xfffe;
16689                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16690 47C1           8B46         18            mov	ax,$18[bp]
16691 47C4           24                     FE  and	al,#$FE
16692 47C6           8946         18            mov	$18[bp],ax
16693                                           !BCC_EOS
16694                                           ! 3110           regs.u.r8.ah = 0;
16695                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16696 47C9           30C0                       xor	al,al
16697 47CB           8846         13            mov	$13[bp],al
16698                                           !BCC_EOS
16699                                           ! 3111           break;
16700 47CE           EB           34            jmp .386
16701                                           !BCC_EOS
16702                                           ! 3112         default:
16703                                           ! 3113 ;
16704                       000047D0            .3FC:
16705                                           !BCC_EOS
16706                                           ! 3114           regs.u.r8.ah = 1;
16707                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
16708 47D0           B0                     01  mov	al,*1
16709 47D2           8846         13            mov	$13[bp],al
16710                                           !BCC_EOS
16711                                           ! 3115           FLAGS |= 0x0001;
16712                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16713 47D5           8B46         18            mov	ax,$18[bp]
16714 47D8           0C                     01  or	al,*1
16715 47DA           8946         18            mov	$18[bp],ax
16716                                           !BCC_EOS
16717                                           ! 3116       }
16718                                           ! 3117       break;
16719 47DD           EB           25            jmp .386
16720                       000047DF            .388:
16721 47DF           2C                     00  sub	al,*0
16722 47E1           72           ED            jb 	.3FC
16723 47E3           3C                     07  cmp	al,*7
16724 47E5           77           1B            ja  	.3FD
16725 47E7           30E4                       xor	ah,ah
16726 47E9           D1E0                       shl	ax,*1
16727 47EB           89C3                       mov	bx,ax
16728 47ED           2E                         seg	cs
16729 47EE           FFA7       47F2            br	.3FE[bx]
16730                       000047F2            .3FE:
16731 47F2                      41CC            .word	.389
16732 47F4                      42CC            .word	.39C
16733 47F6                      43F6            .word	.3B0
16734 47F8                      44C5            .word	.3C4
16735 47FA                      457C            .word	.3D1
16736 47FC                      42CC            .word	.39D
16737 47FE                      45CF            .word	.3D5
16738 4800                      4746            .word	.3F5
16739                       00004802            .3FD:
16740 4802           EB           CC            jmp	.3FC
16741                       00004804            .386:
16742 4804           EB           2D            jmp .382
16743                                           !BCC_EOS
16744                                           ! 3118     default:
16745                                           ! 3119       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
16746                       00004806            .3FF:
16747                                           ! Debug: list unsigned short regs = [S+$10+$A] (used reg = )
16748 4806           FF76         0C            push	$C[bp]
16749                                           ! Debug: list unsigned short regs = [S+$12+$10] (used reg = )
16750 4809           FF76         12            push	$12[bp]
16751                                           ! Debug: list * char = .400+0 (used reg = )
16752 480C           BB                   D3F3  mov	bx,#.400
16753 480F           53                         push	bx
16754                                           ! Debug: list int = const 4 (used reg = )
16755 4810           B8                   0004  mov	ax,*4
16756 4813           50                         push	ax
16757                                           ! Debug: func () void = bios_printf+0 (used reg = )
16758 4814           E8         C127            call	_bios_printf
16759 4817           83C4                   08  add	sp,*8
16760                                           !BCC_EOS
16761                                           ! 3120       FLAGS |= 0x0001;
16762                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16763 481A           8B46         18            mov	ax,$18[bp]
16764 481D           0C                     01  or	al,*1
16765 481F           8946         18            mov	$18[bp],ax
16766                                           !BCC_EOS
16767                                           ! 3121       regs.u.r8.ah = 0x86;
16768                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16769 4822           B0                     86  mov	al,#$86
16770 4824           8846         13            mov	$13[bp],al
16771                                           !BCC_EOS
16772                                           ! 3122       break;
16773 4827           EB           0A            jmp .382
16774                                           !BCC_EOS
16775                                           ! 3123   }
16776                                           ! 3124 }
16777 4829           EB           08            jmp .382
16778                       0000482B            .384:
16779 482B           2C                     C2  sub	al,#$C2
16780 482D         0F84         F995            beq 	.385
16781 4831           EB           D3            jmp	.3FF
16782                       00004833            .382:
16783                       FFFFFFF0            ..FFF6	=	-$10
16784 4833           89EC                       mov	sp,bp
16785 4835           5D                         pop	bp
16786 4836           C3                         ret
16787                                           ! 3125 void set_e820_range(ES, DI, start, end, extra_start, extra_end, type)
16788                                           ! Register BX used in function int15_function_mouse
16789                                           ! 3126      Bit16u ES;
16790                                           export	_set_e820_range
16791                       00004837            _set_e820_range:
16792                                           !BCC_EOS
16793                                           ! 3127      Bit16u DI;
16794                                           !BCC_EOS
16795                                           ! 3128      Bit32u start;
16796                                           !BCC_EOS
16797                                           ! 3129      Bit32u end;
16798                                           !BCC_EOS
16799                                           ! 3130      Bit8u extra_start;
16800                                           !BCC_EOS
16801                                           ! 3131      Bit8u extra_end;
16802                                           !BCC_EOS
16803                                           ! 3132      Bit16u type;
16804                                           !BCC_EOS
16805                                           ! 3133 {
16806                                           ! 3134     Bit16u old_ds = set_DS(ES);
16807 4837           55                         push	bp
16808 4838           89E5                       mov	bp,sp
16809 483A           4C                         dec	sp
16810 483B           4C                         dec	sp
16811                                           ! Debug: list unsigned short ES = [S+4+2] (used reg = )
16812 483C           FF76         04            push	4[bp]
16813                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
16814 483F           E8         BE20            call	_set_DS
16815 4842           44                         inc	sp
16816 4843           44                         inc	sp
16817                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+4-4] (used reg = )
16818 4844           8946         FE            mov	-2[bp],ax
16819                                           !BCC_EOS
16820                                           ! 3135     *((Bit32u *)(DI)) = (start);
16821 4847           8B5E         06            mov	bx,6[bp]
16822                                           ! Debug: eq unsigned long start = [S+4+6] to unsigned long = [bx+0] (used reg = )
16823 484A           8B46         08            mov	ax,8[bp]
16824 484D           8B76         0A            mov	si,$A[bp]
16825 4850           8907                       mov	[bx],ax
16826 4852           8977         02            mov	2[bx],si
16827                                           !BCC_EOS
16828                                           ! 3136     *((Bit16u *)(DI+4)) = (extra_start);
16829                                           ! Debug: add int = const 4 to unsigned short DI = [S+4+4] (used reg = )
16830 4855           8B46         06            mov	ax,6[bp]
16831                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+4 (used reg = )
16832 4858           89C3                       mov	bx,ax
16833                                           ! Debug: eq unsigned char extra_start = [S+4+$E] to unsigned short = [bx+4] (used reg = )
16834 485A           8A46         10            mov	al,$10[bp]
16835 485D           30E4                       xor	ah,ah
16836 485F           8947         04            mov	4[bx],ax
16837                                           !BCC_EOS
16838                                           ! 3137     *((Bit16u *)(DI+6)) = (0x00);
16839                                           ! Debug: add int = const 6 to unsigned short DI = [S+4+4] (used reg = )
16840 4862           8B46         06            mov	ax,6[bp]
16841                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+6 (used reg = )
16842 4865           89C3                       mov	bx,ax
16843                                           ! Debug: eq int = const 0 to unsigned short = [bx+6] (used reg = )
16844 4867           31C0                       xor	ax,ax
16845 4869           8947         06            mov	6[bx],ax
16846                                           !BCC_EOS
16847                                           ! 3138     end -= start;
16848                                           ! Debug: subab unsigned long start = [S+4+6] to unsigned long end = [S+4+$A] (used reg = )
16849 486C           8B46         0C            mov	ax,$C[bp]
16850 486F           8B5E         0E            mov	bx,$E[bp]
16851 4872           8D7E         08            lea	di,8[bp]
16852 4875           E8         B83A            call	lsubul
16853 4878           8946         0C            mov	$C[bp],ax
16854 487B           895E         0E            mov	$E[bp],bx
16855                                           !BCC_EOS
16856                                           ! 3139     extra_end -= extra_start;
16857                                           ! Debug: subab unsigned char extra_start = [S+4+$E] to unsigned char extra_end = [S+4+$10] (used reg = )
16858 487E           8A46         12            mov	al,$12[bp]
16859 4881           30E4                       xor	ah,ah
16860 4883           2A46         10            sub	al,$10[bp]
16861 4886           80DC                   00  sbb	ah,*0
16862 4889           8846         12            mov	$12[bp],al
16863                                           !BCC_EOS
16864                                           ! 3140     *((Bit32u *)(DI+8)) = (end);
16865                                           ! Debug: add int = const 8 to unsigned short DI = [S+4+4] (used reg = )
16866 488C           8B46         06            mov	ax,6[bp]
16867                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+8 (used reg = )
16868 488F           89C3                       mov	bx,ax
16869                                           ! Debug: eq unsigned long end = [S+4+$A] to unsigned long = [bx+8] (used reg = )
16870 4891           8B46         0C            mov	ax,$C[bp]
16871 4894           8B76         0E            mov	si,$E[bp]
16872 4897           8947         08            mov	8[bx],ax
16873 489A           8977         0A            mov	$A[bx],si
16874                                           !BCC_EOS
16875                                           ! 3141     *((Bit16u *)(DI+12)) = (extra_end);
16876                                           ! Debug: add int = const $C to unsigned short DI = [S+4+4] (used reg = )
16877 489D           8B46         06            mov	ax,6[bp]
16878                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$C (used reg = )
16879 48A0           89C3                       mov	bx,ax
16880                                           ! Debug: eq unsigned char extra_end = [S+4+$10] to unsigned short = [bx+$C] (used reg = )
16881 48A2           8A46         12            mov	al,$12[bp]
16882 48A5           30E4                       xor	ah,ah
16883 48A7           8947         0C            mov	$C[bx],ax
16884                                           !BCC_EOS
16885                                           ! 3142     *((Bit16u *)(DI+14)) = (0x0000);
16886                                           ! Debug: add int = const $E to unsigned short DI = [S+4+4] (used reg = )
16887 48AA           8B46         06            mov	ax,6[bp]
16888                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$E (used reg = )
16889 48AD           89C3                       mov	bx,ax
16890                                           ! Debug: eq int = const 0 to unsigned short = [bx+$E] (used reg = )
16891 48AF           31C0                       xor	ax,ax
16892 48B1           8947         0E            mov	$E[bx],ax
16893                                           !BCC_EOS
16894                                           ! 3143     *((Bit16u *)(DI+16)) = (type);
16895                                           ! Debug: add int = const $10 to unsigned short DI = [S+4+4] (used reg = )
16896 48B4           8B46         06            mov	ax,6[bp]
16897                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$10 (used reg = )
16898 48B7           89C3                       mov	bx,ax
16899                                           ! Debug: eq unsigned short type = [S+4+$12] to unsigned short = [bx+$10] (used reg = )
16900 48B9           8B46         14            mov	ax,$14[bp]
16901 48BC           8947         10            mov	$10[bx],ax
16902                                           !BCC_EOS
16903                                           ! 3144     *((Bit16u *)(DI+18)) = (0x0);
16904                                           ! Debug: add int = const $12 to unsigned short DI = [S+4+4] (used reg = )
16905 48BF           8B46         06            mov	ax,6[bp]
16906                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$12 (used reg = )
16907 48C2           89C3                       mov	bx,ax
16908                                           ! Debug: eq int = const 0 to unsigned short = [bx+$12] (used reg = )
16909 48C4           31C0                       xor	ax,ax
16910 48C6           8947         12            mov	$12[bx],ax
16911                                           !BCC_EOS
16912                                           ! 3145     set_DS(old_ds);
16913                                           ! Debug: list unsigned short old_ds = [S+4-4] (used reg = )
16914 48C9           FF76         FE            push	-2[bp]
16915                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
16916 48CC           E8         BD93            call	_set_DS
16917 48CF           44                         inc	sp
16918 48D0           44                         inc	sp
16919                                           !BCC_EOS
16920                                           ! 3146 }
16921 48D1           89EC                       mov	sp,bp
16922 48D3           5D                         pop	bp
16923 48D4           C3                         ret
16924                                           ! 3147   void
16925                                           ! Register BX used in function set_e820_range
16926                                           ! 3148 int15_function32(regs, ES, DS, FLAGS)
16927                                           ! 3149   pushad_regs_t regs;
16928                                           export	_int15_function32
16929                       000048D5            _int15_function32:
16930                                           !BCC_EOS
16931                                           ! 3150   Bit16u ES, DS, FLAGS;
16932                                           !BCC_EOS
16933                                           ! 3151 {
16934                                           ! 3152   Bit32u extended_memory_size=0;
16935 48D5           55                         push	bp
16936 48D6           89E5                       mov	bp,sp
16937 48D8           83C4                   FC  add	sp,*-4
16938                                           ! Debug: eq int = const 0 to unsigned long extended_memory_size = [S+6-6] (used reg = )
16939 48DB           31C0                       xor	ax,ax
16940 48DD           31DB                       xor	bx,bx
16941 48DF           8946         FC            mov	-4[bp],ax
16942 48E2           895E         FE            mov	-2[bp],bx
16943                                           !BCC_EOS
16944                                           ! 3153   Bit32u extra_lowbits_memory_size=0;
16945 48E5           83C4                   FC  add	sp,*-4
16946                                           ! Debug: eq int = const 0 to unsigned long extra_lowbits_memory_size = [S+$A-$A] (used reg = )
16947 48E8           31C0                       xor	ax,ax
16948 48EA           31DB                       xor	bx,bx
16949 48EC           8946         F8            mov	-8[bp],ax
16950 48EF           895E         FA            mov	-6[bp],bx
16951                                           !BCC_EOS
16952                                           ! 3154   Bit16u CX,DX;
16953                                           !BCC_EOS
16954                                           ! 3155   Bit8u extra_highbits_memory_size=0;
16955 48F2           83C4                   FB  add	sp,*-5
16956                                           ! Debug: eq int = const 0 to unsigned char extra_highbits_memory_size = [S+$F-$F] (used reg = )
16957 48F5           30C0                       xor	al,al
16958 48F7           8846         F3            mov	-$D[bp],al
16959                                           !BCC_EOS
16960                                           ! 3156 ;
16961 48FA           4C                         dec	sp
16962                                           !BCC_EOS
16963                                           ! 3157   switch (regs.u.r8.ah) {
16964 48FB           8A46         21            mov	al,$21[bp]
16965 48FE           E9         0487            br 	.403
16966                                           ! 3158     case 0x86:
16967                                           ! 3159       CX = regs.u.r16.cx;
16968                       00004901            .404:
16969                                           ! Debug: eq unsigned short regs = [S+$10+$1A] to unsigned short CX = [S+$10-$C] (used reg = )
16970 4901           8B46         1C            mov	ax,$1C[bp]
16971 4904           8946         F6            mov	-$A[bp],ax
16972                                           !BCC_EOS
16973                                           ! 3160       DX = regs.u.r16.dx;
16974                                           ! Debug: eq unsigned short regs = [S+$10+$16] to unsigned short DX = [S+$10-$E] (used reg = )
16975 4907           8B46         18            mov	ax,$18[bp]
16976 490A           8946         F4            mov	-$C[bp],ax
16977                                           !BCC_EOS
16978                                           ! 3161 #asm
16979                                           !BCC_EOS
16980                                           !BCC_ASM
16981                       00000004            _int15_function32.CX	set	4
16982                       FFFFFFF6            .int15_function32.CX	set	-$A
16983                       00000001            _int15_function32.extra_highbits_memory_size	set	1
16984                       FFFFFFF3            .int15_function32.extra_highbits_memory_size	set	-$D
16985                       00000006            _int15_function32.extra_lowbits_memory_size	set	6
16986                       FFFFFFF8            .int15_function32.extra_lowbits_memory_size	set	-8
16987                       0000000A            _int15_function32.extended_memory_size	set	$A
16988                       FFFFFFFC            .int15_function32.extended_memory_size	set	-4
16989                       00000036            _int15_function32.FLAGS	set	$36
16990                       00000028            .int15_function32.FLAGS	set	$28
16991                       00000034            _int15_function32.DS	set	$34
16992                       00000026            .int15_function32.DS	set	$26
16993                       00000002            _int15_function32.DX	set	2
16994                       FFFFFFF4            .int15_function32.DX	set	-$C
16995                       00000032            _int15_function32.ES	set	$32
16996                       00000024            .int15_function32.ES	set	$24
16997                       00000012            _int15_function32.regs	set	$12
16998                       00000004            .int15_function32.regs	set	4
16999 490D           FB                               sti
17000                                                 ;; Get the count in eax
17001 490E           89E3                             mov bx, sp
17002 4910           36                               SEG SS
17003 4911           8B47         04                    mov ax, _int15_function32.CX [bx]
17004 4914     66    C1E0                   10        shl eax, #16
17005 4918           36                               SEG SS
17006 4919           8B47         02                    mov ax, _int15_function32.DX [bx]
17007                                                 ;; convert to numbers of 15usec ticks
17008 491C     66    BB               0000000F        mov ebx, #15
17009 4922     66    31D2                             xor edx, edx
17010 4925     66    F7F3                             div eax, ebx
17011 4928     66    89C1                             mov ecx, eax
17012                                                 ;; wait for ecx number of refresh requests
17013 492B           E4                     61        in al, 0x0061
17014 492D           24                     10        and al,#0x10
17015 492F           88C4                             mov ah, al
17016 4931     66    09C9                             or ecx, ecx
17017 4934           74           0E                  je int1586_tick_end
17018                       00004936            int1586_tick:
17019 4936           E4                     61        in al, 0x0061
17020 4938           24                     10        and al,#0x10
17021 493A           38E0                             cmp al, ah
17022 493C           74           F8                  je int1586_tick
17023 493E           88C4                             mov ah, al
17024 4940     66    49                               dec ecx
17025 4942           75           F2                  jnz int1586_tick
17026                       00004944            int1586_tick_end:
17027                                           ! 3190 endasm
17028                                           !BCC_ENDASM
17029                                           !BCC_EOS
17030                                           ! 3191       break;
17031 4944           E9         044F            br 	.401
17032                                           !BCC_EOS
17033                                           ! 3192     case 0xe8:
17034                                           ! 3193         switch(regs.u.r8.al) {
17035                       00004947            .405:
17036 4947           8A46         20            mov	al,$20[bp]
17037 494A           E9         0408            br 	.408
17038                                           ! 3194          case 0x20:
17039                                           ! 3195             if (regs.u.r32.edx == 0x534D4150) {
17040                       0000494D            .409:
17041                                           ! Debug: logeq long = const $534D4150 to unsigned long regs = [S+$10+$16] (used reg = )
17042                                           ! Debug: expression subtree swapping
17043 494D           B8                   4150  mov	ax,#$4150
17044 4950           BB                   534D  mov	bx,#$534D
17045 4953           53                         push	bx
17046 4954           50                         push	ax
17047 4955           8B46         18            mov	ax,$18[bp]
17048 4958           8B5E         1A            mov	bx,$1A[bp]
17049 495B           8D7E         EE            lea	di,-2+..FFF5[bp]
17050 495E           E8         B73B            call	lcmpul
17051 4961           8D66         F2            lea	sp,2+..FFF5[bp]
17052 4964         0F85         038B            bne 	.40A
17053                       00004968            .40B:
17054                                           ! 3196                 *((Bit8u *)&extended_memory_size) = inb_cmos(0x34);
17055                                           ! Debug: list int = const $34 (used reg = )
17056 4968           B8                   0034  mov	ax,*$34
17057 496B           50                         push	ax
17058                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17059 496C           E8         BBCE            call	_inb_cmos
17060 496F           44                         inc	sp
17061 4970           44                         inc	sp
17062                                           ! Debug: eq unsigned char = al+0 to unsigned char extended_memory_size = [S+$10-6] (used reg = )
17063 4971           8846         FC            mov	-4[bp],al
17064                                           !BCC_EOS
17065                                           ! 3197                 *(((Bit8u *)&*((Bit16u *)&extended_memory_size))+1) = inb_cmos(0x35);
17066                                           ! Debug: list int = const $35 (used reg = )
17067 4974           B8                   0035  mov	ax,*$35
17068 4977           50                         push	ax
17069                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17070 4978           E8         BBC2            call	_inb_cmos
17071 497B           44                         inc	sp
17072 497C           44                         inc	sp
17073                                           ! Debug: eq unsigned char = al+0 to unsigned char extended_memory_size = [S+$10-5] (used reg = )
17074 497D           8846         FD            mov	-3[bp],al
17075                                           !BCC_EOS
17076                                           ! 3198                 extended_memory_size *= 64;
17077                                           ! Debug: mulab unsigned long = const $40 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17078 4980           B8                   0040  mov	ax,*$40
17079 4983           31DB                       xor	bx,bx
17080 4985           53                         push	bx
17081 4986           50                         push	ax
17082 4987           8B46         FC            mov	ax,-4[bp]
17083 498A           8B5E         FE            mov	bx,-2[bp]
17084 498D           8D7E         EE            lea	di,-2+..FFF5[bp]
17085 4990           E8         B727            call	lmulul
17086 4993           8946         FC            mov	-4[bp],ax
17087 4996           895E         FE            mov	-2[bp],bx
17088 4999           83C4                   04  add	sp,*4
17089                                           !BCC_EOS
17090                                           ! 3199                 if (extended_memory_size > 0x2fc000) {
17091                                           ! Debug: gt long = const $2FC000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17092 499C           B8                   C000  mov	ax,#$C000
17093 499F           BB                   002F  mov	bx,*$2F
17094 49A2           8D7E         FC            lea	di,-4[bp]
17095 49A5           E8         B6F4            call	lcmpul
17096 49A8           73           0C            jae 	.40C
17097                       000049AA            .40D:
17098                                           ! 3200                     extended_memory_size = 0x2fc000;
17099                                           ! Debug: eq long = const $2FC000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17100 49AA           B8                   C000  mov	ax,#$C000
17101 49AD           BB                   002F  mov	bx,*$2F
17102 49B0           8946         FC            mov	-4[bp],ax
17103 49B3           895E         FE            mov	-2[bp],bx
17104                                           !BCC_EOS
17105                                           ! 3201                 }
17106                                           ! 3202                 extended_memory_size *= 1024;
17107                       000049B6            .40C:
17108                                           ! Debug: mulab unsigned long = const $400 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17109 49B6           B8                   0400  mov	ax,#$400
17110 49B9           31DB                       xor	bx,bx
17111 49BB           53                         push	bx
17112 49BC           50                         push	ax
17113 49BD           8B46         FC            mov	ax,-4[bp]
17114 49C0           8B5E         FE            mov	bx,-2[bp]
17115 49C3           8D7E         EE            lea	di,-2+..FFF5[bp]
17116 49C6           E8         B6F1            call	lmulul
17117 49C9           8946         FC            mov	-4[bp],ax
17118 49CC           895E         FE            mov	-2[bp],bx
17119 49CF           83C4                   04  add	sp,*4
17120                                           !BCC_EOS
17121                                           ! 3203                 extended_memory_size += (16L * 1024 * 1024);
17122                                           ! Debug: addab long = const $1000000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17123 49D2           31C0                       xor	ax,ax
17124 49D4           BB                   0100  mov	bx,#$100
17125 49D7           53                         push	bx
17126 49D8           50                         push	ax
17127 49D9           8B46         FC            mov	ax,-4[bp]
17128 49DC           8B5E         FE            mov	bx,-2[bp]
17129 49DF           8D7E         EE            lea	di,-2+..FFF5[bp]
17130 49E2           E8         B6AF            call	laddul
17131 49E5           8946         FC            mov	-4[bp],ax
17132 49E8           895E         FE            mov	-2[bp],bx
17133 49EB           83C4                   04  add	sp,*4
17134                                           !BCC_EOS
17135                                           ! 3204                 if (extended_memory_size <= (16L * 1024 * 1024)) {
17136                                           ! Debug: le long = const $1000000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17137 49EE           31C0                       xor	ax,ax
17138 49F0           BB                   0100  mov	bx,#$100
17139 49F3           8D7E         FC            lea	di,-4[bp]
17140 49F6           E8         B6A3            call	lcmpul
17141 49F9           72           50            jb  	.40E
17142                       000049FB            .40F:
17143                                           ! 3205                     *((Bit8u *)&extended_memory_size) = inb_cmos(0x30);
17144                                           ! Debug: list int = const $30 (used reg = )
17145 49FB           B8                   0030  mov	ax,*$30
17146 49FE           50                         push	ax
17147                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17148 49FF           E8         BB3B            call	_inb_cmos
17149 4A02           44                         inc	sp
17150 4A03           44                         inc	sp
17151                                           ! Debug: eq unsigned char = al+0 to unsigned char extended_memory_size = [S+$10-6] (used reg = )
17152 4A04           8846         FC            mov	-4[bp],al
17153                                           !BCC_EOS
17154                                           ! 3206                     *(((Bit8u *)&*((Bit16u *)&extended_memory_size))+1) = inb_cmos(0x31);
17155                                           ! Debug: list int = const $31 (used reg = )
17156 4A07           B8                   0031  mov	ax,*$31
17157 4A0A           50                         push	ax
17158                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17159 4A0B           E8         BB2F            call	_inb_cmos
17160 4A0E           44                         inc	sp
17161 4A0F           44                         inc	sp
17162                                           ! Debug: eq unsigned char = al+0 to unsigned char extended_memory_size = [S+$10-5] (used reg = )
17163 4A10           8846         FD            mov	-3[bp],al
17164                                           !BCC_EOS
17165                                           ! 3207                     extended_memory_size *= 1024;
17166                                           ! Debug: mulab unsigned long = const $400 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17167 4A13           B8                   0400  mov	ax,#$400
17168 4A16           31DB                       xor	bx,bx
17169 4A18           53                         push	bx
17170 4A19           50                         push	ax
17171 4A1A           8B46         FC            mov	ax,-4[bp]
17172 4A1D           8B5E         FE            mov	bx,-2[bp]
17173 4A20           8D7E         EE            lea	di,-2+..FFF5[bp]
17174 4A23           E8         B694            call	lmulul
17175 4A26           8946         FC            mov	-4[bp],ax
17176 4A29           895E         FE            mov	-2[bp],bx
17177 4A2C           83C4                   04  add	sp,*4
17178                                           !BCC_EOS
17179                                           ! 3208                     extended_memory_size += (1L * 1024 * 1024);
17180                                           ! Debug: addab long = const $100000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17181 4A2F           31C0                       xor	ax,ax
17182 4A31           BB                   0010  mov	bx,*$10
17183 4A34           53                         push	bx
17184 4A35           50                         push	ax
17185 4A36           8B46         FC            mov	ax,-4[bp]
17186 4A39           8B5E         FE            mov	bx,-2[bp]
17187 4A3C           8D7E         EE            lea	di,-2+..FFF5[bp]
17188 4A3F           E8         B652            call	laddul
17189 4A42           8946         FC            mov	-4[bp],ax
17190 4A45           895E         FE            mov	-2[bp],bx
17191 4A48           83C4                   04  add	sp,*4
17192                                           !BCC_EOS
17193                                           ! 3209                 }
17194                                           ! 3210                 *((Bit8u *)&*(((Bit16u *)&extra_lowbits_memory_size)+1)) = inb_cmos(0x5b);
17195                       00004A4B            .40E:
17196                                           ! Debug: list int = const $5B (used reg = )
17197 4A4B           B8                   005B  mov	ax,*$5B
17198 4A4E           50                         push	ax
17199                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17200 4A4F           E8         BAEB            call	_inb_cmos
17201 4A52           44                         inc	sp
17202 4A53           44                         inc	sp
17203                                           ! Debug: eq unsigned char = al+0 to unsigned char extra_lowbits_memory_size = [S+$10-8] (used reg = )
17204 4A54           8846         FA            mov	-6[bp],al
17205                                           !BCC_EOS
17206                                           ! 3211                 *(((Bit8u *)&*(((Bit16u *)&extra_lowbits_memory_size)+1))+1) = inb_cmos(0x5c);
17207                                           ! Debug: list int = const $5C (used reg = )
17208 4A57           B8                   005C  mov	ax,*$5C
17209 4A5A           50                         push	ax
17210                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17211 4A5B           E8         BADF            call	_inb_cmos
17212 4A5E           44                         inc	sp
17213 4A5F           44                         inc	sp
17214                                           ! Debug: eq unsigned char = al+0 to unsigned char extra_lowbits_memory_size = [S+$10-7] (used reg = )
17215 4A60           8846         FB            mov	-5[bp],al
17216                                           !BCC_EOS
17217                                           ! 3212                 *((Bit16u *)&extra_lowbits_memory_size) = 0;
17218                                           ! Debug: eq int = const 0 to unsigned short extra_lowbits_memory_size = [S+$10-$A] (used reg = )
17219 4A63           31C0                       xor	ax,ax
17220 4A65           8946         F8            mov	-8[bp],ax
17221                                           !BCC_EOS
17222                                           ! 3213                 extra_highbits_memory_size = inb_cmos(0x5d);
17223                                           ! Debug: list int = const $5D (used reg = )
17224 4A68           B8                   005D  mov	ax,*$5D
17225 4A6B           50                         push	ax
17226                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17227 4A6C           E8         BACE            call	_inb_cmos
17228 4A6F           44                         inc	sp
17229 4A70           44                         inc	sp
17230                                           ! Debug: eq unsigned char = al+0 to unsigned char extra_highbits_memory_size = [S+$10-$F] (used reg = )
17231 4A71           8846         F3            mov	-$D[bp],al
17232                                           !BCC_EOS
17233                                           ! 3214                 switch(regs.u.r16.bx)
17234 4A74           8B46         14            mov	ax,$14[bp]
17235                                           ! 3215                 {
17236 4A77           E9         0233            br 	.412
17237                                           ! 3216                     case 0:
17238                                           ! 3217                         set_e820_range(ES, regs.u.r16.di,
17239                       00004A7A            .413:
17240                                           ! 3218                                        0x0000000L, 0x0009f000L, 0, 0, 1);
17241                                           ! Debug: list int = const 1 (used reg = )
17242 4A7A           B8                   0001  mov	ax,*1
17243 4A7D           50                         push	ax
17244                                           ! Debug: list int = const 0 (used reg = )
17245 4A7E           31C0                       xor	ax,ax
17246 4A80           50                         push	ax
17247                                           ! Debug: list int = const 0 (used reg = )
17248 4A81           31C0                       xor	ax,ax
17249 4A83           50                         push	ax
17250                                           ! Debug: list long = const $9F000 (used reg = )
17251 4A84           B8                   F000  mov	ax,#$F000
17252 4A87           BB                   0009  mov	bx,*9
17253 4A8A           53                         push	bx
17254 4A8B           50                         push	ax
17255                                           ! Debug: list long = const 0 (used reg = )
17256 4A8C           31C0                       xor	ax,ax
17257 4A8E           31DB                       xor	bx,bx
17258 4A90           53                         push	bx
17259 4A91           50                         push	ax
17260                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17261 4A92           FF76         04            push	4[bp]
17262                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17263 4A95           FF76         24            push	$24[bp]
17264                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17265 4A98           E8         FD9C            call	_set_e820_range
17266 4A9B           83C4                   12  add	sp,*$12
17267                                           !BCC_EOS
17268                                           ! 3219                         regs.u.r32.ebx = 1
17269                                           ! 3219 ;
17270                                           ! Debug: eq int = const 1 to unsigned long regs = [S+$10+$12] (used reg = )
17271 4A9E           B8                   0001  mov	ax,*1
17272 4AA1           31DB                       xor	bx,bx
17273 4AA3           8946         14            mov	$14[bp],ax
17274 4AA6           895E         16            mov	$16[bp],bx
17275                                           !BCC_EOS
17276                                           ! 3220                         break;
17277 4AA9           E9         0226            br 	.410
17278                                           !BCC_EOS
17279                                           ! 3221                     case 1:
17280                                           ! 3222                         set_e820_range(ES, regs.u.r16.di,
17281                       00004AAC            .414:
17282                                           ! 3223                                        0x0009f000L, 0x000a0000L, 0, 0, 2);
17283                                           ! Debug: list int = const 2 (used reg = )
17284 4AAC           B8                   0002  mov	ax,*2
17285 4AAF           50                         push	ax
17286                                           ! Debug: list int = const 0 (used reg = )
17287 4AB0           31C0                       xor	ax,ax
17288 4AB2           50                         push	ax
17289                                           ! Debug: list int = const 0 (used reg = )
17290 4AB3           31C0                       xor	ax,ax
17291 4AB5           50                         push	ax
17292                                           ! Debug: list long = const $A0000 (used reg = )
17293 4AB6           31C0                       xor	ax,ax
17294 4AB8           BB                   000A  mov	bx,*$A
17295 4ABB           53                         push	bx
17296 4ABC           50                         push	ax
17297                                           ! Debug: list long = const $9F000 (used reg = )
17298 4ABD           B8                   F000  mov	ax,#$F000
17299 4AC0           BB                   0009  mov	bx,*9
17300 4AC3           53                         push	bx
17301 4AC4           50                         push	ax
17302                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17303 4AC5           FF76         04            push	4[bp]
17304                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17305 4AC8           FF76         24            push	$24[bp]
17306                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17307 4ACB           E8         FD69            call	_set_e820_range
17308 4ACE           83C4                   12  add	sp,*$12
17309                                           !BCC_EOS
17310                                           ! 3224                         regs.u.r32.ebx = 2;
17311                                           ! Debug: eq int = const 2 to unsigned long regs = [S+$10+$12] (used reg = )
17312 4AD1           B8                   0002  mov	ax,*2
17313 4AD4           31DB                       xor	bx,bx
17314 4AD6           8946         14            mov	$14[bp],ax
17315 4AD9           895E         16            mov	$16[bp],bx
17316                                           !BCC_EOS
17317                                           ! 3225                         break;
17318 4ADC           E9         01F3            br 	.410
17319                                           !BCC_EOS
17320                                           ! 3226                     case 2:
17321                                           ! 3227                         set_e820_range(ES, regs.u.r16.di,
17322                       00004ADF            .415:
17323                                           ! 3228                                        0x000e8000L, 0x00100000L, 0, 0, 2);
17324                                           ! Debug: list int = const 2 (used reg = )
17325 4ADF           B8                   0002  mov	ax,*2
17326 4AE2           50                         push	ax
17327                                           ! Debug: list int = const 0 (used reg = )
17328 4AE3           31C0                       xor	ax,ax
17329 4AE5           50                         push	ax
17330                                           ! Debug: list int = const 0 (used reg = )
17331 4AE6           31C0                       xor	ax,ax
17332 4AE8           50                         push	ax
17333                                           ! Debug: list long = const $100000 (used reg = )
17334 4AE9           31C0                       xor	ax,ax
17335 4AEB           BB                   0010  mov	bx,*$10
17336 4AEE           53                         push	bx
17337 4AEF           50                         push	ax
17338                                           ! Debug: list long = const $E8000 (used reg = )
17339 4AF0           B8                   8000  mov	ax,#$8000
17340 4AF3           BB                   000E  mov	bx,*$E
17341 4AF6           53                         push	bx
17342 4AF7           50                         push	ax
17343                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17344 4AF8           FF76         04            push	4[bp]
17345                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17346 4AFB           FF76         24            push	$24[bp]
17347                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17348 4AFE           E8         FD36            call	_set_e820_range
17349 4B01           83C4                   12  add	sp,*$12
17350                                           !BCC_EOS
17351                                           ! 3229                         if (extended_memory_size <= 0x100000)
17352                                           ! Debug: le long = const $100000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17353 4B04           31C0                       xor	ax,ax
17354 4B06           BB                   0010  mov	bx,*$10
17355 4B09           8D7E         FC            lea	di,-4[bp]
17356 4B0C           E8         B58D            call	lcmpul
17357 4B0F           72           0D            jb  	.416
17358                       00004B11            .417:
17359                                           ! 3230                             regs.u.r32.ebx = 6;
17360                                           ! Debug: eq int = const 6 to unsigned long regs = [S+$10+$12] (used reg = )
17361 4B11           B8                   0006  mov	ax,*6
17362 4B14           31DB                       xor	bx,bx
17363 4B16           8946         14            mov	$14[bp],ax
17364 4B19           895E         16            mov	$16[bp],bx
17365                                           !BCC_EOS
17366                                           ! 3231                         else
17367                                           ! 3232                             regs.u.r32.ebx = 3;
17368 4B1C           EB           0B            jmp .418
17369                       00004B1E            .416:
17370                                           ! Debug: eq int = const 3 to unsigned long regs = [S+$10+$12] (used reg = )
17371 4B1E           B8                   0003  mov	ax,*3
17372 4B21           31DB                       xor	bx,bx
17373 4B23           8946         14            mov	$14[bp],ax
17374 4B26           895E         16            mov	$16[bp],bx
17375                                           !BCC_EOS
17376                                           ! 3233                         break;
17377                       00004B29            .418:
17378 4B29           E9         01A6            br 	.410
17379                                           !BCC_EOS
17380                                           ! 3234                     case 3:
17381                                           ! 3235                         set_e820_range(ES, regs.u.r16.di,
17382                       00004B2C            .419:
17383                                           ! 3236                                        0x00100000L,
17384                                           ! 3237                                        extended_memory_size - 0x00010000L, 0, 0, 1);
17385                                           ! Debug: list int = const 1 (used reg = )
17386 4B2C           B8                   0001  mov	ax,*1
17387 4B2F           50                         push	ax
17388                                           ! Debug: list int = const 0 (used reg = )
17389 4B30           31C0                       xor	ax,ax
17390 4B32           50                         push	ax
17391                                           ! Debug: list int = const 0 (used reg = )
17392 4B33           31C0                       xor	ax,ax
17393 4B35           50                         push	ax
17394                                           ! Debug: sub long = const $10000 to unsigned long extended_memory_size = [S+$16-6] (used reg = )
17395 4B36           31C0                       xor	ax,ax
17396 4B38           BB                   0001  mov	bx,*1
17397 4B3B           53                         push	bx
17398 4B3C           50                         push	ax
17399 4B3D           8B46         FC            mov	ax,-4[bp]
17400 4B40           8B5E         FE            mov	bx,-2[bp]
17401 4B43           8D7E         E8            lea	di,-8+..FFF5[bp]
17402 4B46           E8         B569            call	lsubul
17403 4B49           83C4                   04  add	sp,*4
17404                                           ! Debug: list unsigned long = bx+0 (used reg = )
17405 4B4C           53                         push	bx
17406 4B4D           50                         push	ax
17407                                           ! Debug: list long = const $100000 (used reg = )
17408 4B4E           31C0                       xor	ax,ax
17409 4B50           BB                   0010  mov	bx,*$10
17410 4B53           53                         push	bx
17411 4B54           50                         push	ax
17412                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17413 4B55           FF76         04            push	4[bp]
17414                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17415 4B58           FF76         24            push	$24[bp]
17416                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17417 4B5B           E8         FCD9            call	_set_e820_range
17418 4B5E           83C4                   12  add	sp,*$12
17419                                           !BCC_EOS
17420                                           ! 3238                         regs.u.r32.ebx = 5;
17421                                           ! Debug: eq int = const 5 to unsigned long regs = [S+$10+$12] (used reg = )
17422 4B61           B8                   0005  mov	ax,*5
17423 4B64           31DB                       xor	bx,bx
17424 4B66           8946         14            mov	$14[bp],ax
17425 4B69           895E         16            mov	$16[bp],bx
17426                                           !BCC_EOS
17427                                           ! 3239                         break;
17428 4B6C           E9         0163            br 	.410
17429                                           !BCC_EOS
17430                                           ! 3240                     case 4:
17431                                           ! 3241                         set_e820_range(ES, regs.u.r16.di,
17432                       00004B6F            .41A:
17433                                           ! 3242                                        extended_memory_size - 0x00010000L - 0x00002000,
17434                                           ! 3243                                        extended_memory_size - 0x00010000L, 0, 0, 2);
17435                                           ! Debug: list int = const 2 (used reg = )
17436 4B6F           B8                   0002  mov	ax,*2
17437 4B72           50                         push	ax
17438                                           ! Debug: list int = const 0 (used reg = )
17439 4B73           31C0                       xor	ax,ax
17440 4B75           50                         push	ax
17441                                           ! Debug: list int = const 0 (used reg = )
17442 4B76           31C0                       xor	ax,ax
17443 4B78           50                         push	ax
17444                                           ! Debug: sub long = const $10000 to unsigned long extended_memory_size = [S+$16-6] (used reg = )
17445 4B79           31C0                       xor	ax,ax
17446 4B7B           BB                   0001  mov	bx,*1
17447 4B7E           53                         push	bx
17448 4B7F           50                         push	ax
17449 4B80           8B46         FC            mov	ax,-4[bp]
17450 4B83           8B5E         FE            mov	bx,-2[bp]
17451 4B86           8D7E         E8            lea	di,-8+..FFF5[bp]
17452 4B89           E8         B526            call	lsubul
17453 4B8C           83C4                   04  add	sp,*4
17454                                           ! Debug: list unsigned long = bx+0 (used reg = )
17455 4B8F           53                         push	bx
17456 4B90           50                         push	ax
17457                                           ! Debug: sub long = const $10000 to unsigned long extended_memory_size = [S+$1A-6] (used reg = )
17458 4B91           31C0                       xor	ax,ax
17459 4B93           BB                   0001  mov	bx,*1
17460 4B96           53                         push	bx
17461 4B97           50                         push	ax
17462 4B98           8B46         FC            mov	ax,-4[bp]
17463 4B9B           8B5E         FE            mov	bx,-2[bp]
17464 4B9E           8D7E         E4            lea	di,-$C+..FFF5[bp]
17465 4BA1           E8         B50E            call	lsubul
17466 4BA4           83C4                   04  add	sp,*4
17467                                           ! Debug: sub unsigned long = const $2000 to unsigned long = bx+0 (used reg = )
17468 4BA7           53                         push	bx
17469 4BA8           50                         push	ax
17470 4BA9           B8                   2000  mov	ax,#$2000
17471 4BAC           31DB                       xor	bx,bx
17472 4BAE           53                         push	bx
17473 4BAF           50                         push	ax
17474 4BB0           8B46         E4            mov	ax,-$C+..FFF5[bp]
17475 4BB3           8B5E         E6            mov	bx,-$A+..FFF5[bp]
17476 4BB6           8D7E         E0            lea	di,-$10+..FFF5[bp]
17477 4BB9           E8         B4F6            call	lsubul
17478 4BBC           83C4                   08  add	sp,*8
17479                                           ! Debug: list unsigned long = bx+0 (used reg = )
17480 4BBF           53                         push	bx
17481 4BC0           50                         push	ax
17482                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17483 4BC1           FF76         04            push	4[bp]
17484                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17485 4BC4           FF76         24            push	$24[bp]
17486                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17487 4BC7           E8         FC6D            call	_set_e820_range
17488 4BCA           83C4                   12  add	sp,*$12
17489                                           !BCC_EOS
17490                                           ! 3244                         regs.u.r32.ebx = 5;
17491                                           ! Debug: eq int = const 5 to unsigned long regs = [S+$10+$12] (used reg = )
17492 4BCD           B8                   0005  mov	ax,*5
17493 4BD0           31DB                       xor	bx,bx
17494 4BD2           8946         14            mov	$14[bp],ax
17495 4BD5           895E         16            mov	$16[bp],bx
17496                                           !BCC_EOS
17497                                           ! 3245                         break;
17498 4BD8           E9         00F7            br 	.410
17499                                           !BCC_EOS
17500                                           ! 3246                     case 5:
17501                                           ! 3247                         set_e820_range(ES, regs.u.r16.di,
17502                       00004BDB            .41B:
17503                                           ! 3248                                        extended_memory_size - 0x00010000L,
17504                                           ! 3249                                        extended_memory_size, 0, 0, 3);
17505                                           ! Debug: list int = const 3 (used reg = )
17506 4BDB           B8                   0003  mov	ax,*3
17507 4BDE           50                         push	ax
17508                                           ! Debug: list int = const 0 (used reg = )
17509 4BDF           31C0                       xor	ax,ax
17510 4BE1           50                         push	ax
17511                                           ! Debug: list int = const 0 (used reg = )
17512 4BE2           31C0                       xor	ax,ax
17513 4BE4           50                         push	ax
17514                                           ! Debug: list unsigned long extended_memory_size = [S+$16-6] (used reg = )
17515 4BE5           FF76         FE            push	-2[bp]
17516 4BE8           FF76         FC            push	-4[bp]
17517                                           ! Debug: sub long = const $10000 to unsigned long extended_memory_size = [S+$1A-6] (used reg = )
17518 4BEB           31C0                       xor	ax,ax
17519 4BED           BB                   0001  mov	bx,*1
17520 4BF0           53                         push	bx
17521 4BF1           50                         push	ax
17522 4BF2           8B46         FC            mov	ax,-4[bp]
17523 4BF5           8B5E         FE            mov	bx,-2[bp]
17524 4BF8           8D7E         E4            lea	di,-$C+..FFF5[bp]
17525 4BFB           E8         B4B4            call	lsubul
17526 4BFE           83C4                   04  add	sp,*4
17527                                           ! Debug: list unsigned long = bx+0 (used reg = )
17528 4C01           53                         push	bx
17529 4C02           50                         push	ax
17530                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17531 4C03           FF76         04            push	4[bp]
17532                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17533 4C06           FF76         24            push	$24[bp]
17534                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17535 4C09           E8         FC2B            call	_set_e820_range
17536 4C0C           83C4                   12  add	sp,*$12
17537                                           !BCC_EOS
17538                                           ! 3250                         regs.u.r32.ebx = 6;
17539                                           ! Debug: eq int = const 6 to unsigned long regs = [S+$10+$12] (used reg = )
17540 4C0F           B8                   0006  mov	ax,*6
17541 4C12           31DB                       xor	bx,bx
17542 4C14           8946         14            mov	$14[bp],ax
17543 4C17           895E         16            mov	$16[bp],bx
17544                                           !BCC_EOS
17545                                           ! 3251                         break;
17546 4C1A           E9         00B5            br 	.410
17547                                           !BCC_EOS
17548                                           ! 3252                     case 6:
17549                                           ! 3253                         set_e820_range(ES, regs.u.r16.di,
17550                       00004C1D            .41C:
17551                                           ! 3254                                        0xfffc0000L, 0x00000000L, 0, 0, 2);
17552                                           ! Debug: list int = const 2 (used reg = )
17553 4C1D           B8                   0002  mov	ax,*2
17554 4C20           50                         push	ax
17555                                           ! Debug: list int = const 0 (used reg = )
17556 4C21           31C0                       xor	ax,ax
17557 4C23           50                         push	ax
17558                                           ! Debug: list int = const 0 (used reg = )
17559 4C24           31C0                       xor	ax,ax
17560 4C26           50                         push	ax
17561                                           ! Debug: list long = const 0 (used reg = )
17562 4C27           31C0                       xor	ax,ax
17563 4C29           31DB                       xor	bx,bx
17564 4C2B           53                         push	bx
17565 4C2C           50                         push	ax
17566                                           ! Debug: list unsigned long = const $FFFC0000 (used reg = )
17567 4C2D           31C0                       xor	ax,ax
17568 4C2F           BB                   FFFC  mov	bx,#$FFFC
17569 4C32           53                         push	bx
17570 4C33           50                         push	ax
17571                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17572 4C34           FF76         04            push	4[bp]
17573                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17574 4C37           FF76         24            push	$24[bp]
17575                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17576 4C3A           E8         FBFA            call	_set_e820_range
17577 4C3D           83C4                   12  add	sp,*$12
17578                                           !BCC_EOS
17579                                           ! 3255                         if (extra_highbits_memory_size || extra_lowbits_memory_size)
17580                                           ! Debug: cast unsigned long = const 0 to unsigned char extra_highbits_memory_size = [S+$10-$F] (used reg = )
17581 4C40           8A46         F3            mov	al,-$D[bp]
17582 4C43           30E4                       xor	ah,ah
17583 4C45           31DB                       xor	bx,bx
17584 4C47           E8         B49B            call	ltstl
17585 4C4A           75           0B            jne 	.41E
17586                       00004C4C            .41F:
17587 4C4C           8B46         F8            mov	ax,-8[bp]
17588 4C4F           8B5E         FA            mov	bx,-6[bp]
17589 4C52           E8         B490            call	ltstl
17590 4C55           74           0D            je  	.41D
17591                       00004C57            .41E:
17592                                           ! 3256                             regs.u.r32.ebx = 7;
17593                                           ! Debug: eq int = const 7 to unsigned long regs = [S+$10+$12] (used reg = )
17594 4C57           B8                   0007  mov	ax,*7
17595 4C5A           31DB                       xor	bx,bx
17596 4C5C           8946         14            mov	$14[bp],ax
17597 4C5F           895E         16            mov	$16[bp],bx
17598                                           !BCC_EOS
17599                                           ! 3257                         else
17600                                           ! 3258                             regs.u.r32.ebx = 0;
17601 4C62           EB           0A            jmp .420
17602                       00004C64            .41D:
17603                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$10+$12] (used reg = )
17604 4C64           31C0                       xor	ax,ax
17605 4C66           31DB                       xor	bx,bx
17606 4C68           8946         14            mov	$14[bp],ax
17607 4C6B           895E         16            mov	$16[bp],bx
17608                                           !BCC_EOS
17609                                           ! 3259                         break;
17610                       00004C6E            .420:
17611 4C6E           EB           62            jmp .410
17612                                           !BCC_EOS
17613                                           ! 3260                     case 7:
17614                                           ! 3261                         set_e82
17615                                           ! 3261 0_range(ES, regs.u.r16.di, 0x00000000L,
17616                       00004C70            .421:
17617                                           ! 3262                             extra_lowbits_memory_size, 1, extra_highbits_memory_size
17618                                           ! 3263                                        + 1, 1);
17619                                           ! Debug: list int = const 1 (used reg = )
17620 4C70           B8                   0001  mov	ax,*1
17621 4C73           50                         push	ax
17622                                           ! Debug: add int = const 1 to unsigned char extra_highbits_memory_size = [S+$12-$F] (used reg = )
17623 4C74           8A46         F3            mov	al,-$D[bp]
17624 4C77           30E4                       xor	ah,ah
17625                                           ! Debug: list unsigned int = ax+1 (used reg = )
17626 4C79           40                         inc	ax
17627 4C7A           50                         push	ax
17628                                           ! Debug: list int = const 1 (used reg = )
17629 4C7B           B8                   0001  mov	ax,*1
17630 4C7E           50                         push	ax
17631                                           ! Debug: list unsigned long extra_lowbits_memory_size = [S+$16-$A] (used reg = )
17632 4C7F           FF76         FA            push	-6[bp]
17633 4C82           FF76         F8            push	-8[bp]
17634                                           ! Debug: list long = const 0 (used reg = )
17635 4C85           31C0                       xor	ax,ax
17636 4C87           31DB                       xor	bx,bx
17637 4C89           53                         push	bx
17638 4C8A           50                         push	ax
17639                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17640 4C8B           FF76         04            push	4[bp]
17641                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17642 4C8E           FF76         24            push	$24[bp]
17643                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17644 4C91           E8         FBA3            call	_set_e820_range
17645 4C94           83C4                   12  add	sp,*$12
17646                                           !BCC_EOS
17647                                           ! 3264                         regs.u.r32.ebx = 0;
17648                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$10+$12] (used reg = )
17649 4C97           31C0                       xor	ax,ax
17650 4C99           31DB                       xor	bx,bx
17651 4C9B           8946         14            mov	$14[bp],ax
17652 4C9E           895E         16            mov	$16[bp],bx
17653                                           !BCC_EOS
17654                                           ! 3265                         break;
17655 4CA1           EB           2F            jmp .410
17656                                           !BCC_EOS
17657                                           ! 3266                     default:
17658                                           ! 3267                         goto int15_unimplemented;
17659                       00004CA3            .422:
17660 4CA3           83C4                   00  add	sp,#..FFF4-..FFF5
17661 4CA6           E9         00BA            br 	.FFF4
17662                                           !BCC_EOS
17663                                           ! 3268                         break;
17664 4CA9           EB           27            jmp .410
17665                                           !BCC_EOS
17666                                           ! 3269                 }
17667                                           ! 3270                 regs.u.r32.eax = 0x534D4150;
17668 4CAB           EB           25            jmp .410
17669                       00004CAD            .412:
17670 4CAD           2D                   0000  sub	ax,*0
17671 4CB0           7C           F1            jl 	.422
17672 4CB2           3D                   0007  cmp	ax,*7
17673 4CB5           77           19            ja  	.423
17674 4CB7           D1E0                       shl	ax,*1
17675 4CB9           89C3                       mov	bx,ax
17676 4CBB           2E                         seg	cs
17677 4CBC           FFA7       4CC0            br	.424[bx]
17678                       00004CC0            .424:
17679 4CC0                      4A7A            .word	.413
17680 4CC2                      4AAC            .word	.414
17681 4CC4                      4ADF            .word	.415
17682 4CC6                      4B2C            .word	.419
17683 4CC8                      4B6F            .word	.41A
17684 4CCA                      4BDB            .word	.41B
17685 4CCC                      4C1D            .word	.41C
17686 4CCE                      4C70            .word	.421
17687                       00004CD0            .423:
17688 4CD0           EB           D1            jmp	.422
17689                       00004CD2            .410:
17690                                           ! Debug: eq long = const $534D4150 to unsigned long regs = [S+$10+$1E] (used reg = )
17691 4CD2           B8                   4150  mov	ax,#$4150
17692 4CD5           BB                   534D  mov	bx,#$534D
17693 4CD8           8946         20            mov	$20[bp],ax
17694 4CDB           895E         22            mov	$22[bp],bx
17695                                           !BCC_EOS
17696                                           ! 3271                 regs.u.r32.ecx = 0x14;
17697                                           ! Debug: eq int = const $14 to unsigned long regs = [S+$10+$1A] (used reg = )
17698 4CDE           B8                   0014  mov	ax,*$14
17699 4CE1           31DB                       xor	bx,bx
17700 4CE3           8946         1C            mov	$1C[bp],ax
17701 4CE6           895E         1E            mov	$1E[bp],bx
17702                                           !BCC_EOS
17703                                           ! 3272                 FLAGS &= 0xfffe;
17704                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$26] (used reg = )
17705 4CE9           8B46         28            mov	ax,$28[bp]
17706 4CEC           24                     FE  and	al,#$FE
17707 4CEE           8946         28            mov	$28[bp],ax
17708                                           !BCC_EOS
17709                                           ! 3273             } else {
17710 4CF1           EB           05            jmp .425
17711                       00004CF3            .40A:
17712                                           ! 3274               goto int15_unimplemented;
17713 4CF3           83C4                   00  add	sp,#..FFF4-..FFF5
17714 4CF6           EB           6B            jmp .FFF4
17715                                           !BCC_EOS
17716                                           ! 3275             }
17717                                           ! 3276             break;
17718                       00004CF8            .425:
17719 4CF8           EB           67            jmp .406
17720                                           !BCC_EOS
17721                                           ! 3277         case 0x01:
17722                                           ! 3278           FLAGS &= 0xfffe;
17723                       00004CFA            .426:
17724                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$26] (used reg = )
17725 4CFA           8B46         28            mov	ax,$28[bp]
17726 4CFD           24                     FE  and	al,#$FE
17727 4CFF           8946         28            mov	$28[bp],ax
17728                                           !BCC_EOS
17729                                           ! 3279           regs.u.r8.cl = inb_cmos(0x30);
17730                                           ! Debug: list int = const $30 (used reg = )
17731 4D02           B8                   0030  mov	ax,*$30
17732 4D05           50                         push	ax
17733                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17734 4D06           E8         B834            call	_inb_cmos
17735 4D09           44                         inc	sp
17736 4D0A           44                         inc	sp
17737                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$1A] (used reg = )
17738 4D0B           8846         1C            mov	$1C[bp],al
17739                                           !BCC_EOS
17740                                           ! 3280           regs.u.r8.ch = inb_cmos(0x31);
17741                                           ! Debug: list int = const $31 (used reg = )
17742 4D0E           B8                   0031  mov	ax,*$31
17743 4D11           50                         push	ax
17744                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17745 4D12           E8         B828            call	_inb_cmos
17746 4D15           44                         inc	sp
17747 4D16           44                         inc	sp
17748                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$1B] (used reg = )
17749 4D17           8846         1D            mov	$1D[bp],al
17750                                           !BCC_EOS
17751                                           ! 3281           if(regs.u.r16.cx > 0x3c00)
17752                                           ! Debug: gt int = const $3C00 to unsigned short regs = [S+$10+$1A] (used reg = )
17753 4D1A           8B46         1C            mov	ax,$1C[bp]
17754 4D1D           3D                   3C00  cmp	ax,#$3C00
17755 4D20           76           06            jbe 	.427
17756                       00004D22            .428:
17757                                           ! 3282           {
17758                                           ! 3283             regs.u.r16.cx = 0x3c00;
17759                                           ! Debug: eq int = const $3C00 to unsigned short regs = [S+$10+$1A] (used reg = )
17760 4D22           B8                   3C00  mov	ax,#$3C00
17761 4D25           8946         1C            mov	$1C[bp],ax
17762                                           !BCC_EOS
17763                                           ! 3284           }
17764                                           ! 3285           regs.u.r8.dl = inb_cmos(0x34);
17765                       00004D28            .427:
17766                                           ! Debug: list int = const $34 (used reg = )
17767 4D28           B8                   0034  mov	ax,*$34
17768 4D2B           50                         push	ax
17769                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17770 4D2C           E8         B80E            call	_inb_cmos
17771 4D2F           44                         inc	sp
17772 4D30           44                         inc	sp
17773                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$16] (used reg = )
17774 4D31           8846         18            mov	$18[bp],al
17775                                           !BCC_EOS
17776                                           ! 3286           regs.u.r8.dh = inb_cmos(0x35);
17777                                           ! Debug: list int = const $35 (used reg = )
17778 4D34           B8                   0035  mov	ax,*$35
17779 4D37           50                         push	ax
17780                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17781 4D38           E8         B802            call	_inb_cmos
17782 4D3B           44                         inc	sp
17783 4D3C           44                         inc	sp
17784                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$17] (used reg = )
17785 4D3D           8846         19            mov	$19[bp],al
17786                                           !BCC_EOS
17787                                           ! 3287           regs.u.r16.ax = regs.u.r16.cx;
17788                                           ! Debug: eq unsigned short regs = [S+$10+$1A] to unsigned short regs = [S+$10+$1E] (used reg = )
17789 4D40           8B46         1C            mov	ax,$1C[bp]
17790 4D43           8946         20            mov	$20[bp],ax
17791                                           !BCC_EOS
17792                                           ! 3288           regs.u.r16.bx = regs.u.r16.dx;
17793                                           ! Debug: eq unsigned short regs = [S+$10+$16] to unsigned short regs = [S+$10+$12] (used reg = )
17794 4D46           8B46         18            mov	ax,$18[bp]
17795 4D49           8946         14            mov	$14[bp],ax
17796                                           !BCC_EOS
17797                                           ! 3289           break;
17798 4D4C           EB           13            jmp .406
17799                                           !BCC_EOS
17800                                           ! 3290         default:
17801                                           ! 3291           goto int15_unimplemented;
17802                       00004D4E            .429:
17803 4D4E           83C4                   00  add	sp,#..FFF4-..FFF5
17804 4D51           EB           10            jmp .FFF4
17805                                           !BCC_EOS
17806                                           ! 3292        }
17807                                           ! 3293        break;
17808 4D53           EB           0C            jmp .406
17809                       00004D55            .408:
17810 4D55           2C                     01  sub	al,*1
17811 4D57           74           A1            je 	.426
17812 4D59           2C                     1F  sub	al,*$1F
17813 4D5B         0F84         FBEE            beq 	.409
17814 4D5F           EB           ED            jmp	.429
17815                       00004D61            .406:
17816 4D61           EB           33            jmp .401
17817                                           !BCC_EOS
17818                                           ! 3294     int15_unimplemented:
17819                       00004D63            .FFF4:
17820                                           ! 3295     default:
17821                                           ! 3296       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
17822                       00004D63            .42A:
17823                                           ! Debug: list unsigned short regs = [S+$10+$12] (used reg = )
17824 4D63           FF76         14            push	$14[bp]
17825                                           ! Debug: list unsigned short regs = [S+$12+$1E] (used reg = )
17826 4D66           FF76         20            push	$20[bp]
17827                                           ! Debug: list * char = .42B+0 (used reg = )
17828 4D69           BB                   D3B9  mov	bx,#.42B
17829 4D6C           53                         push	bx
17830                                           ! Debug: list int = const 4 (used reg = )
17831 4D6D           B8                   0004  mov	ax,*4
17832 4D70           50                         push	ax
17833                                           ! Debug: func () void = bios_printf+0 (used reg = )
17834 4D71           E8         BBCA            call	_bios_printf
17835 4D74           83C4                   08  add	sp,*8
17836                                           !BCC_EOS
17837                                           ! 3297       FLAGS |= 0x0001;
17838                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$26] (used reg = )
17839 4D77           8B46         28            mov	ax,$28[bp]
17840 4D7A           0C                     01  or	al,*1
17841 4D7C           8946         28            mov	$28[bp],ax
17842                                           !BCC_EOS
17843                                           ! 3298       regs.u.r8.ah = 0x86;
17844                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$1F] (used reg = )
17845 4D7F           B0                     86  mov	al,#$86
17846 4D81           8846         21            mov	$21[bp],al
17847                                           !BCC_EOS
17848                                           ! 3299       break;
17849 4D84           EB           10            jmp .401
17850                                           !BCC_EOS
17851                                           ! 3300     }
17852                                           ! 3301 }
17853 4D86           EB           0E            jmp .401
17854                       00004D88            .403:
17855 4D88           2C                     86  sub	al,#$86
17856 4D8A         0F84         FB73            beq 	.404
17857 4D8E           2C                     62  sub	al,*$62
17858 4D90         0F84         FBB3            beq 	.405
17859 4D94           EB           CD            jmp	.42A
17860                       00004D96            .401:
17861                       FFFFFFF0            ..FFF5	=	-$10
17862                       FFFFFFF0            ..FFF4	=	-$10
17863 4D96           89EC                       mov	sp,bp
17864 4D98           5D                         pop	bp
17865 4D99           C3                         ret
17866                                           ! 3302   void
17867                                           ! Register BX used in function int15_function32
17868                                           ! 3303 int16_function(DI, SI, BP, SP, BX, DX, CX, AX, FLAGS)
17869                                           ! 3304   Bit16u DI, SI, BP, SP, BX, DX, CX, AX, FLAGS;
17870                                           export	_int16_function
17871                       00004D9A            _int16_function:
17872                                           !BCC_EOS
17873                                           ! 3305 {
17874                                           ! 3306   Bit8u scan_code, ascii_code, shift_flags, led_flags, count;
17875                                           !BCC_EOS
17876                                           ! 3307   Bit16u kbd_code, max;
17877                                           !BCC_EOS
17878                                           ! 3308   ;
17879 4D9A           55                         push	bp
17880 4D9B           89E5                       mov	bp,sp
17881 4D9D           83C4                   F6  add	sp,*-$A
17882                                           !BCC_EOS
17883                                           ! 3309   shift_flags = *((Bit8u *)(0x17));
17884                                           ! Debug: eq unsigned char = [+$17] to unsigned char shift_flags = [S+$C-5] (used reg = )
17885 4DA0           A0         0017            mov	al,[$17]
17886 4DA3           8846         FD            mov	-3[bp],al
17887                                           !BCC_EOS
17888                                           ! 3310   led_flags = *((Bit8u *)(0x97));
17889                                           ! Debug: eq unsigned char = [+$97] to unsigned char led_flags = [S+$C-6] (used reg = )
17890 4DA6           A0         0097            mov	al,[$97]
17891 4DA9           8846         FC            mov	-4[bp],al
17892                                           !BCC_EOS
17893                                           ! 3311   if ((((shift_flags >> 4) & 0x07) ^ (led_flags & 0x07)) != 0) {
17894                                           ! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
17895 4DAC           8A46         FC            mov	al,-4[bp]
17896 4DAF           24                     07  and	al,*7
17897 4DB1           50                         push	ax
17898                                           ! Debug: sr int = const 4 to unsigned char shift_flags = [S+$E-5] (used reg = )
17899 4DB2           8A46         FD            mov	al,-3[bp]
17900 4DB5           30E4                       xor	ah,ah
17901 4DB7           B1                     04  mov	cl,*4
17902 4DB9           D3E8                       shr	ax,cl
17903                                           ! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
17904 4DBB           24                     07  and	al,*7
17905                                           ! Debug: eor unsigned char (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
17906 4DBD           3246         F4            xor	al,-$C[bp]
17907 4DC0           44                         inc	sp
17908 4DC1           44                         inc	sp
17909                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
17910 4DC2           84C0                       test	al,al
17911 4DC4         0F84         0095            beq 	.42C
17912                       00004DC8            .42D:
17913                                           ! 3312 #asm
17914                                           !BCC_EOS
17915                                           !BCC_ASM
17916                       00000012            _int16_function.BP	set	$12
17917                       00000008            .int16_function.BP	set	8
17918                       00000005            _int16_function.count	set	5
17919                       FFFFFFFB            .int16_function.count	set	-5
17920                       0000001A            _int16_function.CX	set	$1A
17921                       00000010            .int16_function.CX	set	$10
17922                       00000008            _int16_function.ascii_code	set	8
17923                       FFFFFFFE            .int16_function.ascii_code	set	-2
17924                       0000000E            _int16_function.DI	set	$E
17925                       00000004            .int16_function.DI	set	4
17926                       0000001E            _int16_function.FLAGS	set	$1E
17927                       00000014            .int16_function.FLAGS	set	$14
17928                       00000002            _int16_function.kbd_code	set	2
17929                       FFFFFFF8            .int16_function.kbd_code	set	-8
17930                       00000009            _int16_function.scan_code	set	9
17931                       FFFFFFFF            .int16_function.scan_code	set	-1
17932                       00000018            _int16_function.DX	set	$18
17933                       0000000E            .int16_function.DX	set	$E
17934                       00000006            _int16_function.led_flags	set	6
17935                       FFFFFFFC            .int16_function.led_flags	set	-4
17936                       00000010            _int16_function.SI	set	$10
17937                       00000006            .int16_function.SI	set	6
17938                       0000001C            _int16_function.AX	set	$1C
17939                       00000012            .int16_function.AX	set	$12
17940                       00000014            _int16_function.SP	set	$14
17941                       0000000A            .int16_function.SP	set	$A
17942                       00000016            _int16_function.BX	set	$16
17943                       0000000C            .int16_function.BX	set	$C
17944                       00000007            _int16_function.shift_flags	set	7
17945                       FFFFFFFD            .int16_function.shift_flags	set	-3
17946                       00000000            _int16_function.max	set	0
17947                       FFFFFFF6            .int16_function.max	set	-$A
17948 4DC8           FA                             cli
17949                                           ! 3314 endasm
17950                                           !BCC_ENDASM
17951                                           !BCC_EOS
17952                                           ! 3315     outb(0x0060, 0xed);
17953                                           ! Debug: list int = const $ED (used reg = )
17954 4DC9           B8                   00ED  mov	ax,#$ED
17955 4DCC           50                         push	ax
17956                                           ! Debug: list int = const $60 (used reg = )
17957 4DCD           B8                   0060  mov	ax,*$60
17958 4DD0           50                         push	ax
17959                                           ! Debug: func () void = outb+0 (used reg = )
17960 4DD1           E8         B73A            call	_outb
17961 4DD4           83C4                   04  add	sp,*4
17962                                           !BCC_EOS
17963                                           ! 3316     while ((inb(0x0064) & 0x01) == 0) outb(0x0080, 0x21);
17964 4DD7           EB           0E            jmp .42F
17965                       00004DD9            .430:
17966                                           ! Debug: list int = const $21 (used reg = )
17967 4DD9           B8                   0021  mov	ax,*$21
17968 4DDC           50                         push	ax
17969                                           ! Debug: list int = const $80 (used reg = )
17970 4DDD           B8                   0080  mov	ax,#$80
17971 4DE0           50                         push	ax
17972                                           ! Debug: func () void = outb+0 (used reg = )
17973 4DE1           E8         B72A            call	_outb
17974 4DE4           83C4                   04  add	sp,*4
17975                                           !BCC_EOS
17976                                           ! 3317     if ((inb(0x0060) == 0xfa)) {
17977                       00004DE7            .42F:
17978                                           ! Debug: list int = const $64 (used reg = )
17979 4DE7           B8                   0064  mov	ax,*$64
17980 4DEA           50                         push	ax
17981                                           ! Debug: func () unsigned char = inb+0 (used reg = )
17982 4DEB           E8         B70A            call	_inb
17983 4DEE           44                         inc	sp
17984 4DEF           44                         inc	sp
17985                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
17986 4DF0           24                     01  and	al,*1
17987                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
17988 4DF2           84C0                       test	al,al
17989 4DF4           74           E3            je 	.430
17990                       00004DF6            .431:
17991                       00004DF6            .42E:
17992                                           ! Debug: list int = const $60 (used reg = )
17993 4DF6           B8                   0060  mov	ax,*$60
17994 4DF9           50                         push	ax
17995                                           ! Debug: func () unsigned char = inb+0 (used reg = )
17996 4DFA           E8         B6FB            call	_inb
17997 4DFD           44                         inc	sp
17998 4DFE           44                         inc	sp
17999                                           ! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
18000 4DFF           3C                     FA  cmp	al,#$FA
18001 4E01           75           59            jne 	.432
18002                       00004E03            .433:
18003                                           ! 3318       led_flags &= 0xf8;
18004                                           ! Debug: andab int = const $F8 to unsigned char led_flags = [S+$C-6] (used reg = )
18005 4E03           8A46         FC            mov	al,-4[bp]
18006 4E06           24                     F8  and	al,#$F8
18007 4E08           8846         FC            mov	-4[bp],al
18008                                           !BCC_EOS
18009                                           ! 3319       led_flags |= ((shift_flags >> 4) & 0x07);
18010                                           ! Debug: sr int = const 4 to unsigned char shift_flags = [S+$C-5] (used reg = )
18011 4E0B           8A46         FD            mov	al,-3[bp]
18012 4E0E           30E4                       xor	ah,ah
18013 4E10           B1                     04  mov	cl,*4
18014 4E12           D3E8                       shr	ax,cl
18015                                           ! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
18016 4E14           24                     07  and	al,*7
18017                                           ! Debug: orab unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
18018 4E16           0A46         FC            or	al,-4[bp]
18019 4E19           8846         FC            mov	-4[bp],al
18020                                           !BCC_EOS
18021                                           ! 3320       outb(0x0060, led_flags & 0x07);
18022                                           ! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
18023 4E1C           8A46         FC            mov	al,-4[bp]
18024 4E1F           24                     07  and	al,*7
18025                                           ! Debug: list unsigned char = al+0 (used reg = )
18026 4E21           30E4                       xor	ah,ah
18027 4E23           50                         push	ax
18028                                           ! Debug: list int = const $60 (used reg = )
18029 4E24           B8                   0060  mov	ax,*$60
18030 4E27           50                         push	ax
18031                                           ! Debug: func () void = outb+0 (used reg = )
18032 4E28           E8         B6E3            call	_outb
18033 4E2B           83C4                   04  add	sp,*4
18034                                           !BCC_EOS
18035                                           ! 3321       while ((inb(0x0064) & 0x01) == 0) outb(0x0080, 0x21);
18036 4E2E           EB           0E            jmp .435
18037                       00004E30            .436:
18038                                           ! Debug: list int = const $21 (used reg = )
18039 4E30           B8                   0021  mov	ax,*$21
18040 4E33           50                         push	ax
18041                                           ! Debug: list int = const $80 (used reg = )
18042 4E34           B8                   0080  mov	ax,#$80
18043 4E37           50                         push	ax
18044                                           ! Debug: func () void = outb+0 (used reg = )
18045 4E38           E8         B6D3            call	_outb
18046 4E3B           83C4                   04  add	sp,*4
18047                                           !BCC_EOS
18048                                           ! 3322       inb(0x0060);
18049                       00004E3E            .435:
18050                                           ! Debug: list int = const $64 (used reg = )
18051 4E3E           B8                   0064  mov	ax,*$64
18052 4E41           50                         push	ax
18053                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18054 4E42           E8         B6B3            call	_inb
18055 4E45           44                         inc	sp
18056 4E46           44                         inc	sp
18057                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
18058 4E47           24                     01  and	al,*1
18059                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
18060 4E49           84C0                       test	al,al
18061 4E4B           74           E3            je 	.436
18062                       00004E4D            .437:
18063                       00004E4D            .434:
18064                                           ! Debug: list int = const $60 (used reg = )
18065 4E4D           B8                   0060  mov	ax,*$60
18066 4E50           50                         push	ax
18067                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18068 4E51           E8         B6A4            call	_inb
18069 4E54           44                         inc	sp
18070 4E55           44                         inc	sp
18071                                           !BCC_EOS
18072                                           ! 3323       *((Bit8u *)(0x97)) = (led_flags);
18073                                           ! Debug: eq unsigned char led_flags = [S+$C-6] to unsigned char = [+$97] (used reg = )
18074 4E56           8A46         FC            mov	al,-4[bp]
18075 4E59           A2         0097            mov	[$97],al
18076                                           !BCC_EOS
18077                                           ! 3324     }
18078                                           ! 3325 #asm
18079                       00004E5C            .432:
18080                                           !BCC_EOS
18081                                           !BCC_ASM
18082                       00000012            _int16_function.BP	set	$12
18083                       00000008            .int16_function.BP	set	8
18084                       00000005            _int16_function.count	set	5
18085                       FFFFFFFB            .int16_function.count	set	-5
18086                       0000001A            _int16_function.CX	set	$1A
18087                       00000010            .int16_function.CX	set	$10
18088                       00000008            _int16_function.ascii_code	set	8
18089                       FFFFFFFE            .int16_function.ascii_code	set	-2
18090                       0000000E            _int16_function.DI	set	$E
18091                       00000004            .int16_function.DI	set	4
18092                       0000001E            _int16_function.FLAGS	set	$1E
18093                       00000014            .int16_function.FLAGS	set	$14
18094                       00000002            _int16_function.kbd_code	set	2
18095                       FFFFFFF8            .int16_function.kbd_code	set	-8
18096                       00000009            _int16_function.scan_code	set	9
18097                       FFFFFFFF            .int16_function.scan_code	set	-1
18098                       00000018            _int16_function.DX	set	$18
18099                       0000000E            .int16_function.DX	set	$E
18100                       00000006            _int16_function.led_flags	set	6
18101                       FFFFFFFC            .int16_function.led_flags	set	-4
18102                       00000010            _int16_function.SI	set	$10
18103                       00000006            .int16_function.SI	set	6
18104                       0000001C            _int16_function.AX	set	$1C
18105                       00000012            .int16_function.AX	set	$12
18106                       00000014            _int16_function.SP	set	$14
18107                       0000000A            .int16_function.SP	set	$A
18108                       00000016            _int16_function.BX	set	$16
18109                       0000000C            .int16_function.BX	set	$C
18110                       00000007            _int16_function.shift_flags	set	7
18111                       FFFFFFFD            .int16_function.shift_flags	set	-3
18112                       00000000            _int16_function.max	set	0
18113                       FFFFFFF6            .int16_function.max	set	-$A
18114 4E5C           FB                             sti
18115                                           ! 3327 endasm
18116                                           !BCC_ENDASM
18117                                           !BCC_EOS
18118                                           ! 3328   }
18119                                           ! 3329  
18120                                           ! 3329  switch (*(((Bit8u *)&AX)+1)) {
18121                       00004E5D            .42C:
18122 4E5D           8A46         13            mov	al,$13[bp]
18123 4E60           E9         029C            br 	.43A
18124                                           ! 3330     case 0x00:
18125                                           ! 3331       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
18126                       00004E63            .43B:
18127                                           ! Debug: list int = const 1 (used reg = )
18128 4E63           B8                   0001  mov	ax,*1
18129 4E66           50                         push	ax
18130                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
18131 4E67           8D5E         FE            lea	bx,-2[bp]
18132 4E6A           53                         push	bx
18133                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
18134 4E6B           8D5E         FF            lea	bx,-1[bp]
18135 4E6E           53                         push	bx
18136                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
18137 4E6F           E8         02D8            call	_dequeue_key
18138 4E72           83C4                   06  add	sp,*6
18139 4E75           85C0                       test	ax,ax
18140 4E77           75           0E            jne 	.43C
18141                       00004E79            .43D:
18142                                           ! 3332         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
18143                                           ! Debug: list * char = .43E+0 (used reg = )
18144 4E79           BB                   D395  mov	bx,#.43E
18145 4E7C           53                         push	bx
18146                                           ! Debug: list int = const 7 (used reg = )
18147 4E7D           B8                   0007  mov	ax,*7
18148 4E80           50                         push	ax
18149                                           ! Debug: func () void = bios_printf+0 (used reg = )
18150 4E81           E8         BABA            call	_bios_printf
18151 4E84           83C4                   04  add	sp,*4
18152                                           !BCC_EOS
18153                                           ! 3333       }
18154                                           ! 3334       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
18155                       00004E87            .43C:
18156                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
18157 4E87           8A46         FF            mov	al,-1[bp]
18158 4E8A           84C0                       test	al,al
18159 4E8C           74           0E            je  	.43F
18160                       00004E8E            .441:
18161                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18162 4E8E           8A46         FE            mov	al,-2[bp]
18163 4E91           3C                     F0  cmp	al,#$F0
18164 4E93           75           07            jne 	.43F
18165                       00004E95            .440:
18166                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18167 4E95           30C0                       xor	al,al
18168 4E97           8846         FE            mov	-2[bp],al
18169                                           !BCC_EOS
18170                                           ! 3335       else if (ascii_code == 0xE0) ascii_code = 0;
18171 4E9A           EB           0C            jmp .442
18172                       00004E9C            .43F:
18173                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18174 4E9C           8A46         FE            mov	al,-2[bp]
18175 4E9F           3C                     E0  cmp	al,#$E0
18176 4EA1           75           05            jne 	.443
18177                       00004EA3            .444:
18178                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18179 4EA3           30C0                       xor	al,al
18180 4EA5           8846         FE            mov	-2[bp],al
18181                                           !BCC_EOS
18182                                           ! 3336       AX = (scan_code << 8) | ascii_code;
18183                       00004EA8            .443:
18184                       00004EA8            .442:
18185                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
18186 4EA8           8A46         FF            mov	al,-1[bp]
18187 4EAB           30E4                       xor	ah,ah
18188 4EAD           88C4                       mov	ah,al
18189 4EAF           30C0                       xor	al,al
18190                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
18191 4EB1           0A46         FE            or	al,-2[bp]
18192                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
18193 4EB4           8946         12            mov	$12[bp],ax
18194                                           !BCC_EOS
18195                                           ! 3337       break;
18196 4EB7           E9         028C            br 	.438
18197                                           !BCC_EOS
18198                                           ! 3338     case 0x01:
18199                                           ! 3339       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
18200                       00004EBA            .445:
18201                                           ! Debug: list int = const 0 (used reg = )
18202 4EBA           31C0                       xor	ax,ax
18203 4EBC           50                         push	ax
18204                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
18205 4EBD           8D5E         FE            lea	bx,-2[bp]
18206 4EC0           53                         push	bx
18207                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
18208 4EC1           8D5E         FF            lea	bx,-1[bp]
18209 4EC4           53                         push	bx
18210                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
18211 4EC5           E8         0282            call	_dequeue_key
18212 4EC8           83C4                   06  add	sp,*6
18213 4ECB           85C0                       test	ax,ax
18214 4ECD           75           0C            jne 	.446
18215                       00004ECF            .447:
18216                                           ! 3340         FLAGS |= 0x0040;
18217                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
18218 4ECF           8B46         14            mov	ax,$14[bp]
18219 4ED2           0C                     40  or	al,*$40
18220 4ED4           8946         14            mov	$14[bp],ax
18221                                           !BCC_EOS
18222                                           ! 3341         return;
18223 4ED7           89EC                       mov	sp,bp
18224 4ED9           5D                         pop	bp
18225 4EDA           C3                         ret
18226                                           !BCC_EOS
18227                                           ! 3342       }
18228                                           ! 3343       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
18229                       00004EDB            .446:
18230                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
18231 4EDB           8A46         FF            mov	al,-1[bp]
18232 4EDE           84C0                       test	al,al
18233 4EE0           74           0E            je  	.448
18234                       00004EE2            .44A:
18235                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18236 4EE2           8A46         FE            mov	al,-2[bp]
18237 4EE5           3C                     F0  cmp	al,#$F0
18238 4EE7           75           07            jne 	.448
18239                       00004EE9            .449:
18240                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18241 4EE9           30C0                       xor	al,al
18242 4EEB           8846         FE            mov	-2[bp],al
18243                                           !BCC_EOS
18244                                           ! 3344       else if (ascii_code == 0xE0) ascii_code = 0;
18245 4EEE           EB           0C            jmp .44B
18246                       00004EF0            .448:
18247                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18248 4EF0           8A46         FE            mov	al,-2[bp]
18249 4EF3           3C                     E0  cmp	al,#$E0
18250 4EF5           75           05            jne 	.44C
18251                       00004EF7            .44D:
18252                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18253 4EF7           30C0                       xor	al,al
18254 4EF9           8846         FE            mov	-2[bp],al
18255                                           !BCC_EOS
18256                                           ! 3345       AX = (scan_code << 8) | ascii_code;
18257                       00004EFC            .44C:
18258                       00004EFC            .44B:
18259                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
18260 4EFC           8A46         FF            mov	al,-1[bp]
18261 4EFF           30E4                       xor	ah,ah
18262 4F01           88C4                       mov	ah,al
18263 4F03           30C0                       xor	al,al
18264                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
18265 4F05           0A46         FE            or	al,-2[bp]
18266                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
18267 4F08           8946         12            mov	$12[bp],ax
18268                                           !BCC_EOS
18269                                           ! 3346       FLAGS &= 0xffbf;
18270                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
18271 4F0B           8B46         14            mov	ax,$14[bp]
18272 4F0E           24                     BF  and	al,#$BF
18273 4F10           8946         14            mov	$14[bp],ax
18274                                           !BCC_EOS
18275                                           ! 3347       break;
18276 4F13           E9         0230            br 	.438
18277                                           !BCC_EOS
18278                                           ! 3348     case 0x02:
18279                                           ! 3349       shift_flags = *((Bit8u *)(0x17));
18280                       00004F16            .44E:
18281                                           ! Debug: eq unsigned char = [+$17] to unsigned char shift_flags = [S+$C-5] (used reg = )
18282 4F16           A0         0017            mov	al,[$17]
18283 4F19           8846         FD            mov	-3[bp],al
18284                                           !BCC_EOS
18285                                           ! 3350       *((Bit8u *)&AX) = (shift_flags);
18286                                           ! Debug: eq unsigned char shift_flags = [S+$C-5] to unsigned char AX = [S+$C+$10] (used reg = )
18287 4F1C           8A46         FD            mov	al,-3[bp]
18288 4F1F           8846         12            mov	$12[bp],al
18289                                           !BCC_EOS
18290                                           ! 3351       break;
18291 4F22           E9         0221            br 	.438
18292                                           !BCC_EOS
18293                                           ! 3352     case 0x05:
18294                                           ! 3353       if ( !enqueue_key(*(((Bit8u *)&CX)+1), ( CX & 0x00ff )) ) {
18295                       00004F25            .44F:
18296                                           ! Debug: and int = const $FF to unsigned short CX = [S+$C+$E] (used reg = )
18297 4F25           8A46         10            mov	al,$10[bp]
18298                                           ! Debug: list unsigned char = al+0 (used reg = )
18299 4F28           30E4                       xor	ah,ah
18300 4F2A           50                         push	ax
18301                                           ! Debug: list unsigned char CX = [S+$E+$F] (used reg = )
18302 4F2B           8A46         11            mov	al,$11[bp]
18303 4F2E           30E4                       xor	ah,ah
18304 4F30           50                         push	ax
18305                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
18306 4F31           E8         0A55            call	_enqueue_key
18307 4F34           83C4                   04  add	sp,*4
18308 4F37           85C0                       test	ax,ax
18309 4F39           75           07            jne 	.450
18310                       00004F3B            .451:
18311                                           ! 3354         *((Bit8u *)&AX) = (1);
18312                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$C+$10] (used reg = )
18313 4F3B           B0                     01  mov	al,*1
18314 4F3D           8846         12            mov	$12[bp],al
18315                                           !BCC_EOS
18316                                           ! 3355       }
18317                                           ! 3356       else {
18318 4F40           EB           05            jmp .452
18319                       00004F42            .450:
18320                                           ! 3357         *((Bit8u *)&AX) = (0);
18321                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$C+$10] (used reg = )
18322 4F42           30C0                       xor	al,al
18323 4F44           8846         12            mov	$12[bp],al
18324                                           !BCC_EOS
18325                                           ! 3358       }
18326                                           ! 3359       break;
18327                       00004F47            .452:
18328 4F47           E9         01FC            br 	.438
18329                                           !BCC_EOS
18330                                           ! 3360     case 0x09:
18331                                           ! 3361       *((Bit8u *)&AX) = (0x30);
18332                       00004F4A            .453:
18333                                           ! Debug: eq int = const $30 to unsigned char AX = [S+$C+$10] (used reg = )
18334 4F4A           B0                     30  mov	al,*$30
18335 4F4C           8846         12            mov	$12[bp],al
18336                                           !BCC_EOS
18337                                           ! 3362       break;
18338 4F4F           E9         01F4            br 	.438
18339                                           !BCC_EOS
18340                                           ! 3363     case 0x0A:
18341                                           ! 3364       count = 2;
18342                       00004F52            .454:
18343                                           ! Debug: eq int = const 2 to unsigned char count = [S+$C-7] (used reg = )
18344 4F52           B0                     02  mov	al,*2
18345 4F54           8846         FB            mov	-5[bp],al
18346                                           !BCC_EOS
18347                                           ! 3365       kbd_code = 0x0;
18348                                           ! Debug: eq int = const 0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
18349 4F57           31C0                       xor	ax,ax
18350 4F59           8946         F8            mov	-8[bp],ax
18351                                           !BCC_EOS
18352                                           ! 3366       outb(0x0060, 0xf2);
18353                                           ! Debug: list int = const $F2 (used reg = )
18354 4F5C           B8                   00F2  mov	ax,#$F2
18355 4F5F           50                         push	ax
18356                                           ! Debug: list int = const $60 (used reg = )
18357 4F60           B8                   0060  mov	ax,*$60
18358 4F63           50                         push	ax
18359                                           ! Debug: func () void = outb+0 (used reg = )
18360 4F64           E8         B5A7            call	_outb
18361 4F67           83C4                   04  add	sp,*4
18362                                           !BCC_EOS
18363                                           ! 3367       max=0xffff;
18364                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
18365 4F6A           B8                   FFFF  mov	ax,#$FFFF
18366 4F6D           8946         F6            mov	-$A[bp],ax
18367                                           !BCC_EOS
18368                                           ! 3368       while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x00);
18369 4F70           EB           0D            jmp .456
18370                       00004F72            .457:
18371                                           ! Debug: list int = const 0 (used reg = )
18372 4F72           31C0                       xor	ax,ax
18373 4F74           50                         push	ax
18374                                           ! Debug: list int = const $80 (used reg = )
18375 4F75           B8                   0080  mov	ax,#$80
18376 4F78           50                         push	ax
18377                                           ! Debug: func () void = outb+0 (used reg = )
18378 4F79           E8         B592            call	_outb
18379 4F7C           83C4                   04  add	sp,*4
18380                                           !BCC_EOS
18381                                           ! 3369       if (max>0x0) {
18382                       00004F7F            .456:
18383                                           ! Debug: list int = const $64 (used reg = )
18384 4F7F           B8                   0064  mov	ax,*$64
18385 4F82           50                         push	ax
18386                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18387 4F83           E8         B572            call	_inb
18388 4F86           44                         inc	sp
18389 4F87           44                         inc	sp
18390                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
18391 4F88           24                     01  and	al,*1
18392                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
18393 4F8A           84C0                       test	al,al
18394 4F8C           75           0B            jne 	.458
18395                       00004F8E            .459:
18396                                           ! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
18397 4F8E           8B46         F6            mov	ax,-$A[bp]
18398 4F91           48                         dec	ax
18399 4F92           8946         F6            mov	-$A[bp],ax
18400                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
18401 4F95           85C0                       test	ax,ax
18402 4F97           75           D9            jne	.457
18403                       00004F99            .458:
18404                       00004F99            .455:
18405                                           ! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
18406 4F99           8B46         F6            mov	ax,-$A[bp]
18407 4F9C           85C0                       test	ax,ax
18408 4F9E           74           6D            je  	.45A
18409                       00004FA0            .45B:
18410                                           ! 3370         if ((inb(0x0060) == 0xfa)) {
18411                                           ! Debug: list int = const $60 (used reg = )
18412 4FA0           B8                   0060  mov	ax,*$60
18413 4FA3           50                         push	ax
18414                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18415 4FA4           E8         B551            call	_inb
18416 4FA7           44                         inc	sp
18417 4FA8           44                         inc	sp
18418                                           ! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
18419 4FA9           3C                     FA  cmp	al,#$FA
18420 4FAB           75           60            jne 	.45C
18421                       00004FAD            .45D:
18422                                           ! 3371           do {
18423                       00004FAD            .460:
18424                                           ! 3372             max=0xffff;
18425                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
18426 4FAD           B8                   FFFF  mov	ax,#$FFFF
18427 4FB0           8946         F6            mov	-$A[bp],ax
18428                                           !BCC_EOS
18429                                           ! 3373             while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x00);
18430 4FB3           EB           0D            jmp .462
18431                       00004FB5            .463:
18432                                           ! Debug: list int = const 0 (used reg = )
18433 4FB5           31C0                       xor	ax,ax
18434 4FB7           50                         push	ax
18435                                           ! Debug: list int = const $80 (used reg = )
18436 4FB8           B8                   0080  mov	ax,#$80
18437 4FBB           50                         push	ax
18438                                           ! Debug: func () void = outb+0 (used reg = )
18439 4FBC           E8         B54F            call	_outb
18440 4FBF           83C4                   04  add	sp,*4
18441                                           !BCC_EOS
18442                                           ! 3374             if (max>0x0) {
18443                       00004FC2            .462:
18444                                           ! Debug: list int = const $64 (used reg = )
18445 4FC2           B8                   0064  mov	ax,*$64
18446 4FC5           50                         push	ax
18447                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18448 4FC6           E8         B52F            call	_inb
18449 4FC9           44                         inc	sp
18450 4FCA           44                         inc	sp
18451                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
18452 4FCB           24                     01  and	al,*1
18453                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
18454 4FCD           84C0                       test	al,al
18455 4FCF           75           0B            jne 	.464
18456                       00004FD1            .465:
18457                                           ! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
18458 4FD1           8B46         F6            mov	ax,-$A[bp]
18459 4FD4           48                         dec	ax
18460 4FD5           8946         F6            mov	-$A[bp],ax
18461                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
18462 4FD8           85C0                       test	ax,ax
18463 4FDA           75           D9            jne	.463
18464                       00004FDC            .464:
18465                       00004FDC            .461:
18466                                           ! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
18467 4FDC           8B46         F6            mov	ax,-$A[bp]
18468 4FDF           85C0                       test	ax,ax
18469 4FE1           74           1F            je  	.466
18470                       00004FE3            .467:
18471                                           ! 3375               kbd_code >>= 8;
18472                                           ! Debug: srab int = const 8 to unsigned short kbd_code = [S+$C-$A] (used reg = )
18473 4FE3           8B46         F8            mov	ax,-8[bp]
18474 4FE6           88E0                       mov	al,ah
18475 4FE8           30E4                       xor	ah,ah
18476 4FEA           8946         F8            mov	-8[bp],ax
18477                                           !BCC_EOS
18478                                           ! 3376               kbd_code |= (inb(0x0060) << 8);
18479                                           ! Debug: list int = const $60 (used reg = )
18480 4FED           B8                   0060  mov	ax,*$60
18481 4FF0           50                         push	ax
18482                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18483 4FF1           E8         B504            call	_inb
18484 4FF4           44                         inc	sp
18485 4FF5           44                         inc	sp
18486                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
18487 4FF6           30E4                       xor	ah,ah
18488 4FF8           88C4                       mov	ah,al
18489 4FFA           30C0                       xor	al,al
18490                                           ! Debug: orab unsigned int = ax+0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
18491 4FFC           0B46         F8            or	ax,-8[bp]
18492 4FFF           8946         F8            mov	-8[bp],ax
18493                                           !BCC_EOS
18494                                           ! 3377             }
18495                                           ! 3378           } while (--count>0);
18496                       00005002            .466:
18497                       00005002            .45F:
18498                                           ! Debug: predec unsigned char count = [S+$C-7] (used reg = )
18499 5002           8A46         FB            mov	al,-5[bp]
18500 5005           48                         dec	ax
18501 5006           8846         FB            mov	-5[bp],al
18502                                           ! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
18503 5009           84C0                       test	al,al
18504 500B           75           A0            jne	.460
18505                       0000500D            .468:
18506                                           !BCC_EOS
18507                                           ! 3379         }
18508                       0000500D            .45E:
18509                                           ! 3380       }
18510                       0000500D            .45C:
18511                                           ! 3381       BX=kbd_code;
18512                       0000500D            .45A:
18513                                           ! Debug: eq unsigned short kbd_code = [S+$C-$A] to unsigned short BX = [S+$C+$A] (used reg = )
18514 500D           8B46         F8            mov	ax,-8[bp]
18515 5010           8946         0C            mov	$C[bp],ax
18516                                           !BCC_EOS
18517                                           ! 3382       break;
18518 5013           E9         0130            br 	.438
18519                                           !BCC_EOS
18520                                           ! 3383     case 0x10:
18521                                           ! 3384       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
18522                       00005016            .469:
18523                                           ! Debug: list int = const 1 (used reg = )
18524 5016           B8                   0001  mov	ax,*1
18525 5019           50                         push	ax
18526                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
18527 501A           8D5E         FE            lea	bx,-2[bp]
18528 501D           53                         push	bx
18529                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
18530 501E           8D5E         FF            lea	bx,-1[bp]
18531 5021           53                         push	bx
18532                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
18533 5022           E8         0125            call	_dequeue_key
18534 5025           83C4                   06  add	sp,*6
18535 5028           85C0                       test	ax,ax
18536 502A           75           0E            jne 	.46A
18537                       0000502C            .46B:
18538                                           ! 3385         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
18539                                           ! Debug: list * char = .46C+0 (used reg = )
18540 502C           BB                   D371  mov	bx,#.46C
18541 502F           53                         push	bx
18542                                           ! Debug: list int = const 7 (used reg = )
18543 5030           B8                   0007  mov	ax,*7
18544 5033           50                         push	ax
18545                                           ! Debug: func () void = bios_printf+0 (used reg = )
18546 5034           E8         B907            call	_bios_printf
18547 5037           83C4                   04  add	sp,*4
18548                                           !BCC_EOS
18549                                           ! 3386       }
18550                                           ! 3387       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
18551                       0000503A            .46A:
18552                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
18553 503A           8A46         FF            mov	al,-1[bp]
18554 503D           84C0                       test	al,al
18555 503F           74           0C            je  	.46D
18556                       00005041            .46F:
18557                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18558 5041           8A46         FE            mov	al,-2[bp]
18559 5044           3C                     F0  cmp	al,#$F0
18560 5046           75           05            jne 	.46D
18561                       00005048            .46E:
18562                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18563 5048           30C0                       xor	al,al
18564 504A           8846         FE            mov	-2[bp],al
18565                                           !BCC_EOS
18566                                           ! 3388       AX = (scan_code << 8) | ascii_code;
18567                       0000504D            .46D:
18568                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
18569 504D           8A46         FF            mov	al,-1[bp]
18570 5050           30E4                       xor	ah,ah
18571 5052           88C4                       mov	ah,al
18572 5054           30C0                       xor	al,al
18573                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
18574 5056           0A46         FE            or	al,-2[bp]
18575                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
18576 5059           8946         12            mov	$12[bp],ax
18577                                           !BCC_EOS
18578                                           ! 3389       break;
18579 505C           E9         00E7            br 	.438
18580                                           !BCC_EOS
18581                                           ! 3390     case 0x11:
18582                                           ! 3391       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
18583                       0000505F            .470:
18584                                           ! Debug: list int = const 0 (used reg = )
18585 505F           31C0                       xor	ax,ax
18586 5061           50                         push	ax
18587                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
18588 5062           8D5E         FE            lea	bx,-2[bp]
18589 5065           53                         push	bx
18590                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
18591 5066           8D5E         FF            lea	bx,-1[bp]
18592 5069           53                         push	bx
18593                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
18594 506A           E8         00DD            call	_dequeue_key
18595 506D           83C4                   06  add	sp,*6
18596 5070           85C0                       test	ax,ax
18597 5072           75           0C            jne 	.471
18598                       00005074            .472:
18599                                           ! 3392         FLAGS |= 0x0040;
18600                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
18601 5074           8B46         14            mov	ax,$14[bp]
18602 5077           0C                     40  or	al,*$40
18603 5079           8946         14            mov	$14[bp],ax
18604                                           !BCC_EOS
18605                                           ! 3393         return;
18606 507C           89EC                       mov	sp,bp
18607 507E           5D                         pop	bp
18608 507F           C3                         ret
18609                                           !BCC_EOS
18610                                           ! 3394       }
18611                                           ! 3395       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
18612                       00005080            .471:
18613                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
18614 5080           8A46         FF            mov	al,-1[bp]
18615 5083           84C0                       test	al,al
18616 5085           74           0C            je  	.473
18617                       00005087            .475:
18618                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18619 5087           8A46         FE            mov	al,-2[bp]
18620 508A           3C                     F0  cmp	al,#$F0
18621 508C           75           05            jne 	.473
18622                       0000508E            .474:
18623                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18624 508E           30C0                       xor	al,al
18625 5090           8846         FE            mov	-2[bp],al
18626                                           !BCC_EOS
18627                                           ! 3396       AX = (scan_code <
18628                       00005093            .473:
18629                                           ! 3396 < 8) | ascii_code;
18630                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
18631 5093           8A46         FF            mov	al,-1[bp]
18632 5096           30E4                       xor	ah,ah
18633 5098           88C4                       mov	ah,al
18634 509A           30C0                       xor	al,al
18635                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
18636 509C           0A46         FE            or	al,-2[bp]
18637                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
18638 509F           8946         12            mov	$12[bp],ax
18639                                           !BCC_EOS
18640                                           ! 3397       FLAGS &= 0xffbf;
18641                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
18642 50A2           8B46         14            mov	ax,$14[bp]
18643 50A5           24                     BF  and	al,#$BF
18644 50A7           8946         14            mov	$14[bp],ax
18645                                           !BCC_EOS
18646                                           ! 3398       break;
18647 50AA           E9         0099            br 	.438
18648                                           !BCC_EOS
18649                                           ! 3399     case 0x12:
18650                                           ! 3400       shift_flags = *((Bit8u *)(0x17));
18651                       000050AD            .476:
18652                                           ! Debug: eq unsigned char = [+$17] to unsigned char shift_flags = [S+$C-5] (used reg = )
18653 50AD           A0         0017            mov	al,[$17]
18654 50B0           8846         FD            mov	-3[bp],al
18655                                           !BCC_EOS
18656                                           ! 3401       *((Bit8u *)&AX) = (shift_flags);
18657                                           ! Debug: eq unsigned char shift_flags = [S+$C-5] to unsigned char AX = [S+$C+$10] (used reg = )
18658 50B3           8A46         FD            mov	al,-3[bp]
18659 50B6           8846         12            mov	$12[bp],al
18660                                           !BCC_EOS
18661                                           ! 3402       shift_flags = *((Bit8u *)(0x18)) & 0x73;
18662                                           ! Debug: and int = const $73 to unsigned char = [+$18] (used reg = )
18663 50B9           A0         0018            mov	al,[$18]
18664 50BC           24                     73  and	al,*$73
18665                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
18666 50BE           8846         FD            mov	-3[bp],al
18667                                           !BCC_EOS
18668                                           ! 3403       shift_flags |= *((Bit8u *)(0x96)) & 0x0c;
18669                                           ! Debug: and int = const $C to unsigned char = [+$96] (used reg = )
18670 50C1           A0         0096            mov	al,[$96]
18671 50C4           24                     0C  and	al,*$C
18672                                           ! Debug: orab unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
18673 50C6           0A46         FD            or	al,-3[bp]
18674 50C9           8846         FD            mov	-3[bp],al
18675                                           !BCC_EOS
18676                                           ! 3404       *(((Bit8u *)&AX)+1) = (shift_flags);
18677                                           ! Debug: eq unsigned char shift_flags = [S+$C-5] to unsigned char AX = [S+$C+$11] (used reg = )
18678 50CC           8A46         FD            mov	al,-3[bp]
18679 50CF           8846         13            mov	$13[bp],al
18680                                           !BCC_EOS
18681                                           ! 3405       ;
18682                                           !BCC_EOS
18683                                           ! 3406       break;
18684 50D2           EB           72            jmp .438
18685                                           !BCC_EOS
18686                                           ! 3407     case 0x92:
18687                                           ! 3408       *(((Bit8u *)&AX)+1) = (0x80);
18688                       000050D4            .477:
18689                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$C+$11] (used reg = )
18690 50D4           B0                     80  mov	al,#$80
18691 50D6           8846         13            mov	$13[bp],al
18692                                           !BCC_EOS
18693                                           ! 3409       break;
18694 50D9           EB           6B            jmp .438
18695                                           !BCC_EOS
18696                                           ! 3410     case 0xA2:
18697                                           ! 3411       break;
18698                       000050DB            .478:
18699 50DB           EB           69            jmp .438
18700                                           !BCC_EOS
18701                                           ! 3412     case 0x6F:
18702                                           ! 3413       if (( AX & 0x00ff ) == 0x08)
18703                       000050DD            .479:
18704                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
18705 50DD           8A46         12            mov	al,$12[bp]
18706                                           ! Debug: logeq int = const 8 to unsigned char = al+0 (used reg = )
18707 50E0           3C                     08  cmp	al,*8
18708 50E2           75           05            jne 	.47A
18709                       000050E4            .47B:
18710                                           ! 3414         *(((Bit8u *)&AX)+1) = (0x02);
18711                                           ! Debug: eq int = const 2 to unsigned char AX = [S+$C+$11] (used reg = )
18712 50E4           B0                     02  mov	al,*2
18713 50E6           8846         13            mov	$13[bp],al
18714                                           !BCC_EOS
18715                                           ! 3415     default:
18716                       000050E9            .47A:
18717                                           ! 3416       bios_printf(4, "KBD: unsupported int 16h function %02x\n", *(((Bit8u *)&AX)+1));
18718                       000050E9            .47C:
18719                                           ! Debug: list unsigned char AX = [S+$C+$11] (used reg = )
18720 50E9           8A46         13            mov	al,$13[bp]
18721 50EC           30E4                       xor	ah,ah
18722 50EE           50                         push	ax
18723                                           ! Debug: list * char = .47D+0 (used reg = )
18724 50EF           BB                   D349  mov	bx,#.47D
18725 50F2           53                         push	bx
18726                                           ! Debug: list int = const 4 (used reg = )
18727 50F3           B8                   0004  mov	ax,*4
18728 50F6           50                         push	ax
18729                                           ! Debug: func () void = bios_printf+0 (used reg = )
18730 50F7           E8         B844            call	_bios_printf
18731 50FA           83C4                   06  add	sp,*6
18732                                           !BCC_EOS
18733                                           ! 3417   }
18734                                           ! 3418 }
18735 50FD           EB           47            jmp .438
18736                       000050FF            .43A:
18737 50FF           2C                     00  sub	al,*0
18738 5101           72           E6            jb 	.47C
18739 5103           3C                     12  cmp	al,*$12
18740 5105           77           31            ja  	.47E
18741 5107           30E4                       xor	ah,ah
18742 5109           D1E0                       shl	ax,*1
18743 510B           89C3                       mov	bx,ax
18744 510D           2E                         seg	cs
18745 510E           FFA7       5112            br	.47F[bx]
18746                       00005112            .47F:
18747 5112                      4E63            .word	.43B
18748 5114                      4EBA            .word	.445
18749 5116                      4F16            .word	.44E
18750 5118                      50E9            .word	.47C
18751 511A                      50E9            .word	.47C
18752 511C                      4F25            .word	.44F
18753 511E                      50E9            .word	.47C
18754 5120                      50E9            .word	.47C
18755 5122                      50E9            .word	.47C
18756 5124                      4F4A            .word	.453
18757 5126                      4F52            .word	.454
18758 5128                      50E9            .word	.47C
18759 512A                      50E9            .word	.47C
18760 512C                      50E9            .word	.47C
18761 512E                      50E9            .word	.47C
18762 5130                      50E9            .word	.47C
18763 5132                      5016            .word	.469
18764 5134                      505F            .word	.470
18765 5136                      50AD            .word	.476
18766                       00005138            .47E:
18767 5138           2C                     6F  sub	al,*$6F
18768 513A           74           A1            je 	.479
18769 513C           2C                     23  sub	al,*$23
18770 513E           74           94            je 	.477
18771 5140           2C                     10  sub	al,*$10
18772 5142           74           97            je 	.478
18773 5144           EB           A3            jmp	.47C
18774                       00005146            .438:
18775                       FFFFFFF4            ..FFF3	=	-$C
18776 5146           89EC                       mov	sp,bp
18777 5148           5D                         pop	bp
18778 5149           C3                         ret
18779                                           ! 3419   unsigned int
18780                                           ! Register BX used in function int16_function
18781                                           ! 3420 dequeue_key(scan_code, ascii_code, incr)
18782                                           ! 3421   Bit8u *scan_code;
18783                                           export	_dequeue_key
18784                       0000514A            _dequeue_key:
18785                                           !BCC_EOS
18786                                           ! 3422   Bit8u *ascii_code;
18787                                           !BCC_EOS
18788                                           ! 3423   unsigned int incr;
18789                                           !BCC_EOS
18790                                           ! 3424 {
18791                                           ! 3425   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail;
18792                                           !BCC_EOS
18793                                           ! 3426   Bit8u acode, scode;
18794                                           !BCC_EOS
18795                                           ! 3427   buffer_start = *((Bit16u *)(0x0080));
18796 514A           55                         push	bp
18797 514B           89E5                       mov	bp,sp
18798 514D           83C4                   F6  add	sp,*-$A
18799                                           ! Debug: eq unsigned short = [+$80] to unsigned short buffer_start = [S+$C-4] (used reg = )
18800 5150           A1         0080            mov	ax,[$80]
18801 5153           8946         FE            mov	-2[bp],ax
18802                                           !BCC_EOS
18803                                           ! 3428   buffer_end = *((Bit16u *)(0x0082));
18804                                           ! Debug: eq unsigned short = [+$82] to unsigned short buffer_end = [S+$C-6] (used reg = )
18805 5156           A1         0082            mov	ax,[$82]
18806 5159           8946         FC            mov	-4[bp],ax
18807                                           !BCC_EOS
18808                                           ! 3429   buffer_head = *((Bit16u *)(0x001a));
18809                                           ! Debug: eq unsigned short = [+$1A] to unsigned short buffer_head = [S+$C-8] (used reg = )
18810 515C           A1         001A            mov	ax,[$1A]
18811 515F           8946         FA            mov	-6[bp],ax
18812                                           !BCC_EOS
18813                                           ! 3430   buffer_tail = *((Bit16u *)(0x001c));
18814                                           ! Debug: eq unsigned short = [+$1C] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
18815 5162           A1         001C            mov	ax,[$1C]
18816 5165           8946         F8            mov	-8[bp],ax
18817                                           !BCC_EOS
18818                                           ! 3431   if (buffer_head != buffer_tail) {
18819                                           ! Debug: ne unsigned short buffer_tail = [S+$C-$A] to unsigned short buffer_head = [S+$C-8] (used reg = )
18820 5168           8B46         FA            mov	ax,-6[bp]
18821 516B           3B46         F8            cmp	ax,-8[bp]
18822 516E           74           5D            je  	.480
18823                       00005170            .481:
18824                                           ! 3432     acode = *((Bit8u *)(buffer_head));
18825 5170           8B5E         FA            mov	bx,-6[bp]
18826                                           ! Debug: eq unsigned char = [bx+0] to unsigned char acode = [S+$C-$B] (used reg = )
18827 5173           8A07                       mov	al,[bx]
18828 5175           8846         F7            mov	-9[bp],al
18829                                           !BCC_EOS
18830                                           ! 3433     scode = *((Bit8u *)(buffer_head+1));
18831                                           ! Debug: add int = const 1 to unsigned short buffer_head = [S+$C-8] (used reg = )
18832 5178           8B46         FA            mov	ax,-6[bp]
18833                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+1 (used reg = )
18834 517B           89C3                       mov	bx,ax
18835                                           ! Debug: eq unsigned char = [bx+1] to unsigned char scode = [S+$C-$C] (used reg = )
18836 517D           8A47         01            mov	al,1[bx]
18837 5180           8846         F6            mov	-$A[bp],al
18838                                           !BCC_EOS
18839                                           ! 3434     _write_byte_SS(acode, ascii_code);
18840                                           ! Debug: list * unsigned char ascii_code = [S+$C+4] (used reg = )
18841 5183           FF76         06            push	6[bp]
18842                                           ! Debug: list unsigned char acode = [S+$E-$B] (used reg = )
18843 5186           8A46         F7            mov	al,-9[bp]
18844 5189           30E4                       xor	ah,ah
18845 518B           50                         push	ax
18846                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
18847 518C           E8         B4AD            call	__write_byte_SS
18848 518F           83C4                   04  add	sp,*4
18849                                           !BCC_EOS
18850                                           ! 3435     _write_byte_SS(scode, scan_code);
18851                                           ! Debug: list * unsigned char scan_code = [S+$C+2] (used reg = )
18852 5192           FF76         04            push	4[bp]
18853                                           ! Debug: list unsigned char scode = [S+$E-$C] (used reg = )
18854 5195           8A46         F6            mov	al,-$A[bp]
18855 5198           30E4                       xor	ah,ah
18856 519A           50                         push	ax
18857                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
18858 519B           E8         B49E            call	__write_byte_SS
18859 519E           83C4                   04  add	sp,*4
18860                                           !BCC_EOS
18861                                           ! 3436     if (incr) {
18862 51A1           8B46         08            mov	ax,8[bp]
18863 51A4           85C0                       test	ax,ax
18864 51A6           74           1C            je  	.482
18865                       000051A8            .483:
18866                                           ! 3437       buffer_head += 2;
18867                                           ! Debug: addab int = const 2 to unsigned short buffer_head = [S+$C-8] (used reg = )
18868 51A8           8B46         FA            mov	ax,-6[bp]
18869 51AB           40                         inc	ax
18870 51AC           40                         inc	ax
18871 51AD           8946         FA            mov	-6[bp],ax
18872                                           !BCC_EOS
18873                                           ! 3438       if (buffer_head >= buffer_end)
18874                                           ! Debug: ge unsigned short buffer_end = [S+$C-6] to unsigned short buffer_head = [S+$C-8] (used reg = )
18875 51B0           8B46         FA            mov	ax,-6[bp]
18876 51B3           3B46         FC            cmp	ax,-4[bp]
18877 51B6           72           06            jb  	.484
18878                       000051B8            .485:
18879                                           ! 3439         buffer_head = buffer_start;
18880                                           ! Debug: eq unsigned short buffer_start = [S+$C-4] to unsigned short buffer_head = [S+$C-8] (used reg = )
18881 51B8           8B46         FE            mov	ax,-2[bp]
18882 51BB           8946         FA            mov	-6[bp],ax
18883                                           !BCC_EOS
18884                                           ! 3440       *((Bit16u *)(0x001a)) = (buffer_head);
18885                       000051BE            .484:
18886                                           ! Debug: eq unsigned short buffer_head = [S+$C-8] to unsigned short = [+$1A] (used reg = )
18887 51BE           8B46         FA            mov	ax,-6[bp]
18888 51C1           A3         001A            mov	[$1A],ax
18889                                           !BCC_EOS
18890                                           ! 3441     }
18891                                           ! 3442     return(1);
18892                       000051C4            .482:
18893 51C4           B8                   0001  mov	ax,*1
18894 51C7           89EC                       mov	sp,bp
18895 51C9           5D                         pop	bp
18896 51CA           C3                         ret
18897                                           !BCC_EOS
18898                                           ! 3443   }
18899                                           ! 3444   else {
18900 51CB           EB           06            jmp .486
18901                       000051CD            .480:
18902                                           ! 3445     return(0);
18903 51CD           31C0                       xor	ax,ax
18904 51CF           89EC                       mov	sp,bp
18905 51D1           5D                         pop	bp
18906 51D2           C3                         ret
18907                                           !BCC_EOS
18908                                           ! 3446   }
18909                                           ! 3447 }
18910                       000051D3            .486:
18911 51D3           89EC                       mov	sp,bp
18912 51D5           5D                         pop	bp
18913 51D6           C3                         ret
18914                                           ! 3448 static char panic_msg_keyb_buffer_full[] = "%s: keyboard input buffer full\n";
18915                                           ! Register BX used in function dequeue_key
18916                                           
18917                       000051D7            _panic_msg_keyb_buffer_full:
18918                       000051D7            .487:
18919 51D7                        25            .ascii	"%s: keyboard input buffer full"
18920 51F5                        0A            .byte	$A
18921 51F6                        00            .byte	0
18922                                           !BCC_EOS
18923                                           ! 3449   Bit8u
18924                                           ! 3450 inhibit_mouse_int_and_events()
18925                                           ! 3451 {
18926                                           
18927                                           export	_inhibit_mouse_int_and_events
18928                       000051F7            _inhibit_mouse_int_and_events:
18929                                           ! 3452   Bit8u command_byte, prev_command_byte;
18930                                           !BCC_EOS
18931                                           ! 3453   if ( inb(0x0064) & 0x02 )
18932 51F7           55                         push	bp
18933 51F8           89E5                       mov	bp,sp
18934 51FA           4C                         dec	sp
18935 51FB           4C                         dec	sp
18936                                           ! Debug: list int = const $64 (used reg = )
18937 51FC           B8                   0064  mov	ax,*$64
18938 51FF           50                         push	ax
18939                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18940 5200           E8         B2F5            call	_inb
18941 5203           44                         inc	sp
18942 5204           44                         inc	sp
18943                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
18944 5205           24                     02  and	al,*2
18945 5207           84C0                       test	al,al
18946 5209           74           12            je  	.488
18947                       0000520B            .489:
18948                                           ! 3454     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
18949                                           ! Debug: list * char = .48A+0 (used reg = )
18950 520B           BB                   D33E  mov	bx,#.48A
18951 520E           53                         push	bx
18952                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
18953 520F           BB                   51D7  mov	bx,#_panic_msg_keyb_buffer_full
18954 5212           53                         push	bx
18955                                           ! Debug: list int = const 7 (used reg = )
18956 5213           B8                   0007  mov	ax,*7
18957 5216           50                         push	ax
18958                                           ! Debug: func () void = bios_printf+0 (used reg = )
18959 5217           E8         B724            call	_bios_printf
18960 521A           83C4                   06  add	sp,*6
18961                                           !BCC_EOS
18962                                           ! 3455   outb(0x0064, 0x20);
18963                       0000521D            .488:
18964                                           ! Debug: list int = const $20 (used reg = )
18965 521D           B8                   0020  mov	ax,*$20
18966 5220           50                         push	ax
18967                                           ! Debug: list int = const $64 (used reg = )
18968 5221           B8                   0064  mov	ax,*$64
18969 5224           50                         push	ax
18970                                           ! Debug: func () void = outb+0 (used reg = )
18971 5225           E8         B2E6            call	_outb
18972 5228           83C4                   04  add	sp,*4
18973                                           !BCC_EOS
18974                                           ! 3456   while ( (inb(0x0064) & 0x01) != 0x01 );
18975 522B           EB           00            jmp .48C
18976                       0000522D            .48D:
18977                                           !BCC_EOS
18978                                           ! 3457   prev_command_byte = inb(0x0060);
18979                       0000522D            .48C:
18980                                           ! Debug: list int = const $64 (used reg = )
18981 522D           B8                   0064  mov	ax,*$64
18982 5230           50                         push	ax
18983                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18984 5231           E8         B2C4            call	_inb
18985 5234           44                         inc	sp
18986 5235           44                         inc	sp
18987                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
18988 5236           24                     01  and	al,*1
18989                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
18990 5238           3C                     01  cmp	al,*1
18991 523A           75           F1            jne	.48D
18992                       0000523C            .48E:
18993                       0000523C            .48B:
18994                                           ! Debug: list int = const $60 (used reg = )
18995 523C           B8                   0060  mov	ax,*$60
18996 523F           50                         push	ax
18997                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18998 5240           E8         B2B5            call	_inb
18999 5243           44                         inc	sp
19000 5244           44                         inc	sp
19001                                           ! Debug: eq unsigned char = al+0 to unsigned char prev_command_byte = [S+4-4] (used reg = )
19002 5245           8846         FE            mov	-2[bp],al
19003                                           !BCC_EOS
19004                                           ! 3458   command_byte = prev_command_byte;
19005                                           ! Debug: eq unsigned char prev_command_byte = [S+4-4] to unsigned char command_byte = [S+4-3] (used reg = )
19006 5248           8A46         FE            mov	al,-2[bp]
19007 524B           8846         FF            mov	-1[bp],al
19008                                           !BCC_EOS
19009                                           ! 3459   if ( inb(0x0064) & 0x02 )
19010                                           ! Debug: list int = const $64 (used reg = )
19011 524E           B8                   0064  mov	ax,*$64
19012 5251           50                         push	ax
19013                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19014 5252           E8         B2A3            call	_inb
19015 5255           44                         inc	sp
19016 5256           44                         inc	sp
19017                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
19018 5257           24                     02  and	al,*2
19019 5259           84C0                       test	al,al
19020 525B           74           12            je  	.48F
19021                       0000525D            .490:
19022                                           ! 3460     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
19023                                           ! Debug: list * char = .491+0 (used reg = )
19024 525D           BB                   D333  mov	bx,#.491
19025 5260           53                         push	bx
19026                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
19027 5261           BB                   51D7  mov	bx,#_panic_msg_keyb_buffer_full
19028 5264           53                         push	bx
19029                                           ! Debug: list int = const 7 (used reg = )
19030 5265           B8                   0007  mov	ax,*7
19031 5268           50                         push	ax
19032                                           ! Debug: func () void = bios_printf+0 (used reg = )
19033 5269           E8         B6D2            call	_bios_printf
19034 526C           83C4                   06  add	sp,*6
19035                                           !BCC_EOS
19036                                           ! 3461   command_byte &= 0xfd;
19037                       0000526F            .48F:
19038                                           ! Debug: andab int = const $FD to unsigned char command_byte = [S+4-3] (used reg = )
19039 526F           8A46         FF            mov	al,-1[bp]
19040 5272           24                     FD  and	al,#$FD
19041 5274           8846         FF            mov	-1[bp],al
19042                                           !BCC_EOS
19043                                           ! 3462   command_byte |= 0x20;
19044                                           ! Debug: orab int = const $20 to unsigned char command_byte = [S+4-3] (used reg = )
19045 5277           8A46         FF            mov	al,-1[bp]
19046 527A           0C                     20  or	al,*$20
19047 527C           8846         FF            mov	-1[bp],al
19048                                           !BCC_EOS
19049                                           ! 3463   outb(0x0064, 0x60);
19050                                           ! Debug: list int = const $60 (used reg = )
19051 527F           B8                   0060  mov	ax,*$60
19052 5282           50                         push	ax
19053                                           ! Debug: list int = const $64 (used reg = )
19054 5283           B8                   0064  mov	ax,*$64
19055 5286           50                         push	ax
19056                                           ! Debug: func () void = outb+0 (used reg = )
19057 5287           E8         B284            call	_outb
19058 528A           83C4                   04  add	sp,*4
19059                                           !BCC_EOS
19060                                           ! 3464   outb(0x0060, command_byte);
19061                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
19062 528D           8A46         FF            mov	al,-1[bp]
19063 5290           30E4                       xor	ah,ah
19064 5292           50                         push	ax
19065                                           ! Debug: list int = const $60 (used reg = )
19066 5293           B8                   0060  mov	ax,*$60
19067 5296           50                         push	ax
19068                                           ! Debug: func () void = outb+0 (used reg = )
19069 5297           E8         B274            call	_outb
19070 529A           83C4                   04  add	sp,*4
19071                                           !BCC_EOS
19072                                           ! 3465   return(prev_command_byte);
19073 529D           8A46         FE            mov	al,-2[bp]
19074 52A0           89EC                       mov	sp,bp
19075 52A2           5D                         pop	bp
19076 52A3           C3                         ret
19077                                           !BCC_EOS
19078                                           ! 3466 }
19079                                           ! 3467   void
19080                                           ! Register BX used in function inhibit_mouse_int_and_events
19081                                           ! 3468 enable_mouse_int_and_events()
19082                                           ! 3469 {
19083                                           export	_enable_mouse_int_and_events
19084                       000052A4            _enable_mouse_int_and_events:
19085                                           ! 3470   Bit8u command_byte;
19086                                           !BCC_EOS
19087                                           ! 3471   i
19088                                           ! 3471 f ( inb(0x0064) & 0x02 )
19089 52A4           55                         push	bp
19090 52A5           89E5                       mov	bp,sp
19091 52A7           4C                         dec	sp
19092 52A8           4C                         dec	sp
19093                                           ! Debug: list int = const $64 (used reg = )
19094 52A9           B8                   0064  mov	ax,*$64
19095 52AC           50                         push	ax
19096                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19097 52AD           E8         B248            call	_inb
19098 52B0           44                         inc	sp
19099 52B1           44                         inc	sp
19100                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
19101 52B2           24                     02  and	al,*2
19102 52B4           84C0                       test	al,al
19103 52B6           74           12            je  	.492
19104                       000052B8            .493:
19105                                           ! 3472     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
19106                                           ! Debug: list * char = .494+0 (used reg = )
19107 52B8           BB                   D329  mov	bx,#.494
19108 52BB           53                         push	bx
19109                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
19110 52BC           BB                   51D7  mov	bx,#_panic_msg_keyb_buffer_full
19111 52BF           53                         push	bx
19112                                           ! Debug: list int = const 7 (used reg = )
19113 52C0           B8                   0007  mov	ax,*7
19114 52C3           50                         push	ax
19115                                           ! Debug: func () void = bios_printf+0 (used reg = )
19116 52C4           E8         B677            call	_bios_printf
19117 52C7           83C4                   06  add	sp,*6
19118                                           !BCC_EOS
19119                                           ! 3473   outb(0x0064, 0x20);
19120                       000052CA            .492:
19121                                           ! Debug: list int = const $20 (used reg = )
19122 52CA           B8                   0020  mov	ax,*$20
19123 52CD           50                         push	ax
19124                                           ! Debug: list int = const $64 (used reg = )
19125 52CE           B8                   0064  mov	ax,*$64
19126 52D1           50                         push	ax
19127                                           ! Debug: func () void = outb+0 (used reg = )
19128 52D2           E8         B239            call	_outb
19129 52D5           83C4                   04  add	sp,*4
19130                                           !BCC_EOS
19131                                           ! 3474   while ( (inb(0x0064) & 0x01) != 0x01 );
19132 52D8           EB           00            jmp .496
19133                       000052DA            .497:
19134                                           !BCC_EOS
19135                                           ! 3475   command_byte = inb(0x0060);
19136                       000052DA            .496:
19137                                           ! Debug: list int = const $64 (used reg = )
19138 52DA           B8                   0064  mov	ax,*$64
19139 52DD           50                         push	ax
19140                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19141 52DE           E8         B217            call	_inb
19142 52E1           44                         inc	sp
19143 52E2           44                         inc	sp
19144                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
19145 52E3           24                     01  and	al,*1
19146                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
19147 52E5           3C                     01  cmp	al,*1
19148 52E7           75           F1            jne	.497
19149                       000052E9            .498:
19150                       000052E9            .495:
19151                                           ! Debug: list int = const $60 (used reg = )
19152 52E9           B8                   0060  mov	ax,*$60
19153 52EC           50                         push	ax
19154                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19155 52ED           E8         B208            call	_inb
19156 52F0           44                         inc	sp
19157 52F1           44                         inc	sp
19158                                           ! Debug: eq unsigned char = al+0 to unsigned char command_byte = [S+4-3] (used reg = )
19159 52F2           8846         FF            mov	-1[bp],al
19160                                           !BCC_EOS
19161                                           ! 3476   if ( inb(0x0064) & 0x02 )
19162                                           ! Debug: list int = const $64 (used reg = )
19163 52F5           B8                   0064  mov	ax,*$64
19164 52F8           50                         push	ax
19165                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19166 52F9           E8         B1FC            call	_inb
19167 52FC           44                         inc	sp
19168 52FD           44                         inc	sp
19169                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
19170 52FE           24                     02  and	al,*2
19171 5300           84C0                       test	al,al
19172 5302           74           12            je  	.499
19173                       00005304            .49A:
19174                                           ! 3477     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
19175                                           ! Debug: list * char = .49B+0 (used reg = )
19176 5304           BB                   D31F  mov	bx,#.49B
19177 5307           53                         push	bx
19178                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
19179 5308           BB                   51D7  mov	bx,#_panic_msg_keyb_buffer_full
19180 530B           53                         push	bx
19181                                           ! Debug: list int = const 7 (used reg = )
19182 530C           B8                   0007  mov	ax,*7
19183 530F           50                         push	ax
19184                                           ! Debug: func () void = bios_printf+0 (used reg = )
19185 5310           E8         B62B            call	_bios_printf
19186 5313           83C4                   06  add	sp,*6
19187                                           !BCC_EOS
19188                                           ! 3478   command_byte |= 0x02;
19189                       00005316            .499:
19190                                           ! Debug: orab int = const 2 to unsigned char command_byte = [S+4-3] (used reg = )
19191 5316           8A46         FF            mov	al,-1[bp]
19192 5319           0C                     02  or	al,*2
19193 531B           8846         FF            mov	-1[bp],al
19194                                           !BCC_EOS
19195                                           ! 3479   command_byte &= 0xdf;
19196                                           ! Debug: andab int = const $DF to unsigned char command_byte = [S+4-3] (used reg = )
19197 531E           8A46         FF            mov	al,-1[bp]
19198 5321           24                     DF  and	al,#$DF
19199 5323           8846         FF            mov	-1[bp],al
19200                                           !BCC_EOS
19201                                           ! 3480   outb(0x0064, 0x60);
19202                                           ! Debug: list int = const $60 (used reg = )
19203 5326           B8                   0060  mov	ax,*$60
19204 5329           50                         push	ax
19205                                           ! Debug: list int = const $64 (used reg = )
19206 532A           B8                   0064  mov	ax,*$64
19207 532D           50                         push	ax
19208                                           ! Debug: func () void = outb+0 (used reg = )
19209 532E           E8         B1DD            call	_outb
19210 5331           83C4                   04  add	sp,*4
19211                                           !BCC_EOS
19212                                           ! 3481   outb(0x0060, command_byte);
19213                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
19214 5334           8A46         FF            mov	al,-1[bp]
19215 5337           30E4                       xor	ah,ah
19216 5339           50                         push	ax
19217                                           ! Debug: list int = const $60 (used reg = )
19218 533A           B8                   0060  mov	ax,*$60
19219 533D           50                         push	ax
19220                                           ! Debug: func () void = outb+0 (used reg = )
19221 533E           E8         B1CD            call	_outb
19222 5341           83C4                   04  add	sp,*4
19223                                           !BCC_EOS
19224                                           ! 3482 }
19225 5344           89EC                       mov	sp,bp
19226 5346           5D                         pop	bp
19227 5347           C3                         ret
19228                                           ! 3483   Bit8u
19229                                           ! Register BX used in function enable_mouse_int_and_events
19230                                           ! 3484 send_to_mouse_ctrl(sendbyte)
19231                                           ! 3485   Bit8u sendbyte;
19232                                           export	_send_to_mouse_ctrl
19233                       00005348            _send_to_mouse_ctrl:
19234                                           !BCC_EOS
19235                                           ! 3486 {
19236                                           ! 3487   Bit8u response;
19237                                           !BCC_EOS
19238                                           ! 3488   if ( inb(0x0064) & 0x02 )
19239 5348           55                         push	bp
19240 5349           89E5                       mov	bp,sp
19241 534B           4C                         dec	sp
19242 534C           4C                         dec	sp
19243                                           ! Debug: list int = const $64 (used reg = )
19244 534D           B8                   0064  mov	ax,*$64
19245 5350           50                         push	ax
19246                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19247 5351           E8         B1A4            call	_inb
19248 5354           44                         inc	sp
19249 5355           44                         inc	sp
19250                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
19251 5356           24                     02  and	al,*2
19252 5358           84C0                       test	al,al
19253 535A           74           12            je  	.49C
19254                       0000535C            .49D:
19255                                           ! 3489     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"sendmouse");
19256                                           ! Debug: list * char = .49E+0 (used reg = )
19257 535C           BB                   D315  mov	bx,#.49E
19258 535F           53                         push	bx
19259                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
19260 5360           BB                   51D7  mov	bx,#_panic_msg_keyb_buffer_full
19261 5363           53                         push	bx
19262                                           ! Debug: list int = const 7 (used reg = )
19263 5364           B8                   0007  mov	ax,*7
19264 5367           50                         push	ax
19265                                           ! Debug: func () void = bios_printf+0 (used reg = )
19266 5368           E8         B5D3            call	_bios_printf
19267 536B           83C4                   06  add	sp,*6
19268                                           !BCC_EOS
19269                                           ! 3490   outb(0x0064, 0xD4);
19270                       0000536E            .49C:
19271                                           ! Debug: list int = const $D4 (used reg = )
19272 536E           B8                   00D4  mov	ax,#$D4
19273 5371           50                         push	ax
19274                                           ! Debug: list int = const $64 (used reg = )
19275 5372           B8                   0064  mov	ax,*$64
19276 5375           50                         push	ax
19277                                           ! Debug: func () void = outb+0 (used reg = )
19278 5376           E8         B195            call	_outb
19279 5379           83C4                   04  add	sp,*4
19280                                           !BCC_EOS
19281                                           ! 3491   outb(0x0060, sendbyte);
19282                                           ! Debug: list unsigned char sendbyte = [S+4+2] (used reg = )
19283 537C           8A46         04            mov	al,4[bp]
19284 537F           30E4                       xor	ah,ah
19285 5381           50                         push	ax
19286                                           ! Debug: list int = const $60 (used reg = )
19287 5382           B8                   0060  mov	ax,*$60
19288 5385           50                         push	ax
19289                                           ! Debug: func () void = outb+0 (used reg = )
19290 5386           E8         B185            call	_outb
19291 5389           83C4                   04  add	sp,*4
19292                                           !BCC_EOS
19293                                           ! 3492   return(0);
19294 538C           30C0                       xor	al,al
19295 538E           89EC                       mov	sp,bp
19296 5390           5D                         pop	bp
19297 5391           C3                         ret
19298                                           !BCC_EOS
19299                                           ! 3493 }
19300                                           ! 3494   Bit8u
19301                                           ! Register BX used in function send_to_mouse_ctrl
19302                                           ! 3495 get_mouse_data(data)
19303                                           ! 3496   Bit8u *data;
19304                                           export	_get_mouse_data
19305                       00005392            _get_mouse_data:
19306                                           !BCC_EOS
19307                                           ! 3497 {
19308                                           ! 3498   Bit8u response;
19309                                           !BCC_EOS
19310                                           ! 3499   while ((inb(0x0064) & 0x21) != 0x21) { }
19311 5392           55                         push	bp
19312 5393           89E5                       mov	bp,sp
19313 5395           4C                         dec	sp
19314 5396           4C                         dec	sp
19315 5397           EB           00            jmp .4A0
19316                       00005399            .4A1:
19317                                           ! 3500   response = inb(0x0060);
19318                       00005399            .4A0:
19319                                           ! Debug: list int = const $64 (used reg = )
19320 5399           B8                   0064  mov	ax,*$64
19321 539C           50                         push	ax
19322                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19323 539D           E8         B158            call	_inb
19324 53A0           44                         inc	sp
19325 53A1           44                         inc	sp
19326                                           ! Debug: and int = const $21 to unsigned char = al+0 (used reg = )
19327 53A2           24                     21  and	al,*$21
19328                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
19329 53A4           3C                     21  cmp	al,*$21
19330 53A6           75           F1            jne	.4A1
19331                       000053A8            .4A2:
19332                       000053A8            .49F:
19333                                           ! Debug: list int = const $60 (used reg = )
19334 53A8           B8                   0060  mov	ax,*$60
19335 53AB           50                         push	ax
19336                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19337 53AC           E8         B149            call	_inb
19338 53AF           44                         inc	sp
19339 53B0           44                         inc	sp
19340                                           ! Debug: eq unsigned char = al+0 to unsigned char response = [S+4-3] (used reg = )
19341 53B1           8846         FF            mov	-1[bp],al
19342                                           !BCC_EOS
19343                                           ! 3501   _write_byte_SS(response, data);
19344                                           ! Debug: list * unsigned char data = [S+4+2] (used reg = )
19345 53B4           FF76         04            push	4[bp]
19346                                           ! Debug: list unsigned char response = [S+6-3] (used reg = )
19347 53B7           8A46         FF            mov	al,-1[bp]
19348 53BA           30E4                       xor	ah,ah
19349 53BC           50                         push	ax
19350                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
19351 53BD           E8         B27C            call	__write_byte_SS
19352 53C0           83C4                   04  add	sp,*4
19353                                           !BCC_EOS
19354                                           ! 3502   return(0);
19355 53C3           30C0                       xor	al,al
19356 53C5           89EC                       mov	sp,bp
19357 53C7           5D                         pop	bp
19358 53C8           C3                         ret
19359                                           !BCC_EOS
19360                                           ! 3503 }
19361                                           ! 3504   void
19362                                           ! 3505 set_kbd_command_byte(command_byte)
19363                                           ! 3506   Bit8u command_byte;
19364                                           export	_set_kbd_command_byte
19365                       000053C9            _set_kbd_command_byte:
19366                                           !BCC_EOS
19367                                           ! 3507 {
19368                                           ! 3508   if ( inb(0x0064) & 0x02 )
19369 53C9           55                         push	bp
19370 53CA           89E5                       mov	bp,sp
19371                                           ! Debug: list int = const $64 (used reg = )
19372 53CC           B8                   0064  mov	ax,*$64
19373 53CF           50                         push	ax
19374                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19375 53D0           E8         B125            call	_inb
19376 53D3           89EC                       mov	sp,bp
19377                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
19378 53D5           24                     02  and	al,*2
19379 53D7           84C0                       test	al,al
19380 53D9           74           11            je  	.4A3
19381                       000053DB            .4A4:
19382                                           ! 3509     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"setkbdcomm");
19383                                           ! Debug: list * char = .4A5+0 (used reg = )
19384 53DB           BB                   D30A  mov	bx,#.4A5
19385 53DE           53                         push	bx
19386                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
19387 53DF           BB                   51D7  mov	bx,#_panic_msg_keyb_buffer_full
19388 53E2           53                         push	bx
19389                                           ! Debug: list int = const 7 (used reg = )
19390 53E3           B8                   0007  mov	ax,*7
19391 53E6           50                         push	ax
19392                                           ! Debug: func () void = bios_printf+0 (used reg = )
19393 53E7           E8         B554            call	_bios_printf
19394 53EA           89EC                       mov	sp,bp
19395                                           !BCC_EOS
19396                                           ! 3510   outb(0x0064, 0xD4);
19397                       000053EC            .4A3:
19398                                           ! Debug: list int = const $D4 (used reg = )
19399 53EC           B8                   00D4  mov	ax,#$D4
19400 53EF           50                         push	ax
19401                                           ! Debug: list int = const $64 (used reg = )
19402 53F0           B8                   0064  mov	ax,*$64
19403 53F3           50                         push	ax
19404                                           ! Debug: func () void = outb+0 (used reg = )
19405 53F4           E8         B117            call	_outb
19406 53F7           89EC                       mov	sp,bp
19407                                           !BCC_EOS
19408                                           ! 3511   outb(0x0064, 0x60);
19409                                           ! Debug: list int = const $60 (used reg = )
19410 53F9           B8                   0060  mov	ax,*$60
19411 53FC           50                         push	ax
19412                                           ! Debug: list int = const $64 (used reg = )
19413 53FD           B8                   0064  mov	ax,*$64
19414 5400           50                         push	ax
19415                                           ! Debug: func () void = outb+0 (used reg = )
19416 5401           E8         B10A            call	_outb
19417 5404           89EC                       mov	sp,bp
19418                                           !BCC_EOS
19419                                           ! 3512   outb(0x0060, command_byte);
19420                                           ! Debug: list unsigned char command_byte = [S+2+2] (used reg = )
19421 5406           8A46         04            mov	al,4[bp]
19422 5409           30E4                       xor	ah,ah
19423 540B           50                         push	ax
19424                                           ! Debug: list int = const $60 (used reg = )
19425 540C           B8                   0060  mov	ax,*$60
19426 540F           50                         push	ax
19427                                           ! Debug: func () void = outb+0 (used reg = )
19428 5410           E8         B0FB            call	_outb
19429 5413           89EC                       mov	sp,bp
19430                                           !BCC_EOS
19431                                           ! 3513 }
19432 5415           5D                         pop	bp
19433 5416           C3                         ret
19434                                           ! 3514   void
19435                                           ! Register BX used in function set_kbd_command_byte
19436                                           ! 3515 int09_function(DI, SI, BP, SP, BX, DX, CX, AX)
19437                                           ! 3516   Bit16u DI, SI, BP, SP, BX, DX, CX, AX;
19438                                           export	_int09_function
19439                       00005417            _int09_function:
19440                                           !BCC_EOS
19441                                           ! 3517 {
19442                                           ! 3518   Bit8u scancode, asciicode, shift_flags;
19443                                           !BCC_EOS
19444                                           ! 3519   Bit8u mf2_flags, mf2_state;
19445                                           !BCC_EOS
19446                                           ! 3520   scancode = ( AX & 0x00ff );
19447 5417           55                         push	bp
19448 5418           89E5                       mov	bp,sp
19449 541A           83C4                   FA  add	sp,*-6
19450                                           ! Debug: and int = const $FF to unsigned short AX = [S+8+$10] (used reg = )
19451 541D           8A46         12            mov	al,$12[bp]
19452                                           ! Debug: eq unsigned char = al+0 to unsigned char scancode = [S+8-3] (used reg = )
19453 5420           8846         FF            mov	-1[bp],al
19454                                           !BCC_EOS
19455                                           ! 3521   if (scancode == 0) {
19456                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
19457 5423           8A46         FF            mov	al,-1[bp]
19458 5426           84C0                       test	al,al
19459 5428           75           12            jne 	.4A6
19460                       0000542A            .4A7:
19461                                           ! 3522     bios_printf(4, "KBD: int09 handler: AL=0\n");
19462                                           ! Debug: list * char = .4A8+0 (used reg = )
19463 542A           BB                   D2F0  mov	bx,#.4A8
19464 542D           53                         push	bx
19465                                           ! Debug: list int = const 4 (used reg = )
19466 542E           B8                   0004  mov	ax,*4
19467 5431           50                         push	ax
19468                                           ! Debug: func () void = bios_printf+0 (used reg = )
19469 5432           E8         B509            call	_bios_printf
19470 5435           83C4                   04  add	sp,*4
19471                                           !BCC_EOS
19472                                           ! 3523     return;
19473 5438           89EC                       mov	sp,bp
19474 543A           5D                         pop	bp
19475 543B           C3                         ret
19476                                           !BCC_EOS
19477                                           ! 3524   }
19478                                           ! 3525   shift_flags = *((Bit8u *)(0x17));
19479                       0000543C            .4A6:
19480                                           ! Debug: eq unsigned char = [+$17] to unsigned char shift_flags = [S+8-5] (used reg = )
19481 543C           A0         0017            mov	al,[$17]
19482 543F           8846         FD            mov	-3[bp],al
19483                                           !BCC_EOS
19484                                           ! 3526   mf2_flags = *((Bit8u *)(0x18));
19485                                           ! Debug: eq unsigned char = [+$18] to unsigned char mf2_flags = [S+8-6] (used reg = )
19486 5442           A0         0018            mov	al,[$18]
19487 5445           8846         FC            mov	-4[bp],al
19488                                           !BCC_EOS
19489                                           ! 3527   mf2_state = *((Bit8u *)(0x96));
19490                                           ! Debug: eq unsigned char = [+$96] to unsigned char mf2_state = [S+8-7] (used reg = )
19491 5448           A0         0096            mov	al,[$96]
19492 544B           8846         FB            mov	-5[bp],al
19493                                           !BCC_EOS
19494                                           ! 3528   asciicode = 0;
19495                                           ! Debug: eq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
19496 544E           30C0                       xor	al,al
19497 5450           8846         FE            mov	-2[bp],al
19498                                           !BCC_EOS
19499                                           ! 3529   switch (scancode) {
19500 5453           8A46         FF            mov	al,-1[bp]
19501 5456           E9         04B6            br 	.4AB
19502                                           ! 3530     case 0x3a:
19503                                           ! 3531       shift_flags ^= 0x40;
19504                       00005459            .4AC:
19505                                           ! Debug: eorab int = const $40 to unsigned char shift_flags = [S+8-5] (used reg = )
19506 5459           8A46         FD            mov	al,-3[bp]
19507 545C           34                     40  xor	al,*$40
19508 545E           8846         FD            mov	-3[bp],al
19509                                           !BCC_EOS
19510                                           ! 3532       *((Bit8u *)(0x17)) = (shift_flags);
19511                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19512 5461           8A46         FD            mov	al,-3[bp]
19513 5464           A2         0017            mov	[$17],al
19514                                           !BCC_EOS
19515                                           ! 3533       mf2_flags |= 0x40;
19516                                           ! Debug: orab int = const $40 to unsigned char mf2_flags = [S+8-6] (used reg = )
19517 5467           8A46         FC            mov	al,-4[bp]
19518 546A           0C                     40  or	al,*$40
19519 546C           8846         FC            mov	-4[bp],al
19520                                           !BCC_EOS
19521                                           ! 3534       *((Bit8u *)(0x18)) = (mf2_flags);
19522                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19523 546F           8A46         FC            mov	al,-4[bp]
19524 5472           A2         0018            mov	[$18],al
19525                                           !BCC_EOS
19526                                           ! 3535       break;
19527 5475           E9         04EE            br 	.4A9
19528                                           !BCC_EOS
19529                                           ! 3536     case 0xba:
19530                                           ! 3537       mf2_flags &= ~0x40;
19531                       00005478            .4AD:
19532                                           ! Debug: andab int = const -$41 to unsigned char mf2_flags = [S+8-6] (used reg = )
19533 5478           8A46         FC            mov	al,-4[bp]
19534 547B           24                     BF  and	al,#$BF
19535 547D           8846         FC            mov	-4[bp],al
19536                                           !BCC_EOS
19537                                           ! 3538       *((Bit8u *)(0x18)) = (mf2_flags);
19538                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19539 5480           8A46         FC            mov	al,-4[bp]
19540 5483           A2         0018            mov	[$18],al
19541                                           !BCC_EOS
19542                                           ! 3539       break;
19543 5486           E9         04DD            br 	.4A9
19544                                           !BCC_EOS
19545                                           ! 3540     case 0x2a:
19546                                           ! 3541       shift_flags |= 0x02;
19547                       00005489            .4AE:
19548                                           ! Debug: orab int = const 2 to unsigned char shift_flags = [S+8-5] (used reg = )
19549 5489           8A46         FD            mov	al,-3[bp]
19550 548C           0C                     02  or	al,*2
19551 548E           8846         FD            mov	-3[bp],al
19552                                           !BCC_EOS
19553                                           ! 3542       *((Bit8u *)(0x17)) = (shift_flags);
19554                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19555 5491           8A46         FD            mov	al,-3[bp]
19556 5494           A2         0017            mov	[$17],al
19557                                           !BCC_EOS
19558                                           ! 3543       break;
19559 5497           E9         04CC            br 	.4A9
19560                                           !BCC_EOS
19561                                           ! 3544     case 0xaa:
19562                                           ! 3545       shift_flags &= ~0x02;
19563                       0000549A            .4AF:
19564                                           ! Debug: andab int = const -3 to unsigned char shift_flags = [S+8-5] (used reg = )
19565 549A           8A46         FD            mov	al,-3[bp]
19566 549D           24                     FD  and	al,#$FD
19567 549F           8846         FD            mov	-3[bp],al
19568                                           !BCC_EOS
19569                                           ! 3546       *((Bit8u *)(0x17)) = (shift_flags);
19570                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19571 54A2           8A46         FD            mov	al,-3[bp]
19572 54A5           A2         0017            mov	[$17],al
19573                                           !BCC_EOS
19574                                           ! 3547       break;
19575 54A8           E9         04BB            br 	.4A9
19576                                           !BCC_EOS
19577                                           ! 3548     case 0x36:
19578                                           ! 3549       shift_flags |= 0x01;
19579                       000054AB            .4B0:
19580                                           ! Debug: orab int = const 1 to unsigned char shift_flags = [S+8-5] (used reg = )
19581 54AB           8A46         FD            mov	al,-3[bp]
19582 54AE           0C                     01  or	al,*1
19583 54B0           8846         FD            mov	-3[bp],al
19584                                           !BCC_EOS
19585                                           ! 3550       *((Bit8u *)(0x17)) = (shift_flags);
19586                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19587 54B3           8A46         FD            mov	al,-3[bp]
19588 54B6           A2         0017            mov	[$17],al
19589                                           !BCC_EOS
19590                                           ! 3551       break;
19591 54B9           E9         04AA            br 	.4A9
19592                                           !BCC_EOS
19593                                           ! 3552     case 0xb6:
19594                                           ! 3553       
19595                                           ! 3553 shift_flags &= ~0x01;
19596                       000054BC            .4B1:
19597                                           ! Debug: andab int = const -2 to unsigned char shift_flags = [S+8-5] (used reg = )
19598 54BC           8A46         FD            mov	al,-3[bp]
19599 54BF           24                     FE  and	al,#$FE
19600 54C1           8846         FD            mov	-3[bp],al
19601                                           !BCC_EOS
19602                                           ! 3554       *((Bit8u *)(0x17)) = (shift_flags);
19603                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19604 54C4           8A46         FD            mov	al,-3[bp]
19605 54C7           A2         0017            mov	[$17],al
19606                                           !BCC_EOS
19607                                           ! 3555       break;
19608 54CA           E9         0499            br 	.4A9
19609                                           !BCC_EOS
19610                                           ! 3556     case 0x1d:
19611                                           ! 3557       if ((mf2_state & 0x01) == 0) {
19612                       000054CD            .4B2:
19613                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
19614 54CD           8A46         FB            mov	al,-5[bp]
19615 54D0           24                     01  and	al,*1
19616                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19617 54D2           84C0                       test	al,al
19618 54D4           75           35            jne 	.4B3
19619                       000054D6            .4B4:
19620                                           ! 3558         shift_flags |= 0x04;
19621                                           ! Debug: orab int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
19622 54D6           8A46         FD            mov	al,-3[bp]
19623 54D9           0C                     04  or	al,*4
19624 54DB           8846         FD            mov	-3[bp],al
19625                                           !BCC_EOS
19626                                           ! 3559         *((Bit8u *)(0x17)) = (shift_flags);
19627                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19628 54DE           8A46         FD            mov	al,-3[bp]
19629 54E1           A2         0017            mov	[$17],al
19630                                           !BCC_EOS
19631                                           ! 3560         if (mf2_state & 0x02) {
19632                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19633 54E4           8A46         FB            mov	al,-5[bp]
19634 54E7           24                     02  and	al,*2
19635 54E9           84C0                       test	al,al
19636 54EB           74           10            je  	.4B5
19637                       000054ED            .4B6:
19638                                           ! 3561           mf2_state |= 0x04;
19639                                           ! Debug: orab int = const 4 to unsigned char mf2_state = [S+8-7] (used reg = )
19640 54ED           8A46         FB            mov	al,-5[bp]
19641 54F0           0C                     04  or	al,*4
19642 54F2           8846         FB            mov	-5[bp],al
19643                                           !BCC_EOS
19644                                           ! 3562           *((Bit8u *)(0x96)) = (mf2_state);
19645                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
19646 54F5           8A46         FB            mov	al,-5[bp]
19647 54F8           A2         0096            mov	[$96],al
19648                                           !BCC_EOS
19649                                           ! 3563         } else {
19650 54FB           EB           0E            jmp .4B7
19651                       000054FD            .4B5:
19652                                           ! 3564           mf2_flags |= 0x01;
19653                                           ! Debug: orab int = const 1 to unsigned char mf2_flags = [S+8-6] (used reg = )
19654 54FD           8A46         FC            mov	al,-4[bp]
19655 5500           0C                     01  or	al,*1
19656 5502           8846         FC            mov	-4[bp],al
19657                                           !BCC_EOS
19658                                           ! 3565           *((Bit8u *)(0x18)) = (mf2_flags);
19659                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19660 5505           8A46         FC            mov	al,-4[bp]
19661 5508           A2         0018            mov	[$18],al
19662                                           !BCC_EOS
19663                                           ! 3566         }
19664                                           ! 3567       }
19665                       0000550B            .4B7:
19666                                           ! 3568       break;
19667                       0000550B            .4B3:
19668 550B           E9         0458            br 	.4A9
19669                                           !BCC_EOS
19670                                           ! 3569     case 0x9d:
19671                                           ! 3570       if ((mf2_state & 0x01) == 0) {
19672                       0000550E            .4B8:
19673                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
19674 550E           8A46         FB            mov	al,-5[bp]
19675 5511           24                     01  and	al,*1
19676                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19677 5513           84C0                       test	al,al
19678 5515           75           35            jne 	.4B9
19679                       00005517            .4BA:
19680                                           ! 3571         shift_flags &= ~0x04;
19681                                           ! Debug: andab int = const -5 to unsigned char shift_flags = [S+8-5] (used reg = )
19682 5517           8A46         FD            mov	al,-3[bp]
19683 551A           24                     FB  and	al,#$FB
19684 551C           8846         FD            mov	-3[bp],al
19685                                           !BCC_EOS
19686                                           ! 3572         *((Bit8u *)(0x17)) = (shift_flags);
19687                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19688 551F           8A46         FD            mov	al,-3[bp]
19689 5522           A2         0017            mov	[$17],al
19690                                           !BCC_EOS
19691                                           ! 3573         if (mf2_state & 0x02) {
19692                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19693 5525           8A46         FB            mov	al,-5[bp]
19694 5528           24                     02  and	al,*2
19695 552A           84C0                       test	al,al
19696 552C           74           10            je  	.4BB
19697                       0000552E            .4BC:
19698                                           ! 3574           mf2_state &= ~0x04;
19699                                           ! Debug: andab int = const -5 to unsigned char mf2_state = [S+8-7] (used reg = )
19700 552E           8A46         FB            mov	al,-5[bp]
19701 5531           24                     FB  and	al,#$FB
19702 5533           8846         FB            mov	-5[bp],al
19703                                           !BCC_EOS
19704                                           ! 3575           *((Bit8u *)(0x96)) = (mf2_state);
19705                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
19706 5536           8A46         FB            mov	al,-5[bp]
19707 5539           A2         0096            mov	[$96],al
19708                                           !BCC_EOS
19709                                           ! 3576         } else {
19710 553C           EB           0E            jmp .4BD
19711                       0000553E            .4BB:
19712                                           ! 3577           mf2_flags &= ~0x01;
19713                                           ! Debug: andab int = const -2 to unsigned char mf2_flags = [S+8-6] (used reg = )
19714 553E           8A46         FC            mov	al,-4[bp]
19715 5541           24                     FE  and	al,#$FE
19716 5543           8846         FC            mov	-4[bp],al
19717                                           !BCC_EOS
19718                                           ! 3578           *((Bit8u *)(0x18)) = (mf2_flags);
19719                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19720 5546           8A46         FC            mov	al,-4[bp]
19721 5549           A2         0018            mov	[$18],al
19722                                           !BCC_EOS
19723                                           ! 3579         }
19724                                           ! 3580       }
19725                       0000554C            .4BD:
19726                                           ! 3581       break;
19727                       0000554C            .4B9:
19728 554C           E9         0417            br 	.4A9
19729                                           !BCC_EOS
19730                                           ! 3582     case 0x38:
19731                                           ! 3583       shift_flags |= 0x08;
19732                       0000554F            .4BE:
19733                                           ! Debug: orab int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
19734 554F           8A46         FD            mov	al,-3[bp]
19735 5552           0C                     08  or	al,*8
19736 5554           8846         FD            mov	-3[bp],al
19737                                           !BCC_EOS
19738                                           ! 3584       *((Bit8u *)(0x17)) = (shift_flags);
19739                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19740 5557           8A46         FD            mov	al,-3[bp]
19741 555A           A2         0017            mov	[$17],al
19742                                           !BCC_EOS
19743                                           ! 3585       if (mf2_state & 0x02) {
19744                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19745 555D           8A46         FB            mov	al,-5[bp]
19746 5560           24                     02  and	al,*2
19747 5562           84C0                       test	al,al
19748 5564           74           10            je  	.4BF
19749                       00005566            .4C0:
19750                                           ! 3586         mf2_state |= 0x08;
19751                                           ! Debug: orab int = const 8 to unsigned char mf2_state = [S+8-7] (used reg = )
19752 5566           8A46         FB            mov	al,-5[bp]
19753 5569           0C                     08  or	al,*8
19754 556B           8846         FB            mov	-5[bp],al
19755                                           !BCC_EOS
19756                                           ! 3587         *((Bit8u *)(0x96)) = (mf2_state);
19757                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
19758 556E           8A46         FB            mov	al,-5[bp]
19759 5571           A2         0096            mov	[$96],al
19760                                           !BCC_EOS
19761                                           ! 3588       } else {
19762 5574           EB           0E            jmp .4C1
19763                       00005576            .4BF:
19764                                           ! 3589         mf2_flags |= 0x02;
19765                                           ! Debug: orab int = const 2 to unsigned char mf2_flags = [S+8-6] (used reg = )
19766 5576           8A46         FC            mov	al,-4[bp]
19767 5579           0C                     02  or	al,*2
19768 557B           8846         FC            mov	-4[bp],al
19769                                           !BCC_EOS
19770                                           ! 3590         *((Bit8u *)(0x18)) = (mf2_flags);
19771                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19772 557E           8A46         FC            mov	al,-4[bp]
19773 5581           A2         0018            mov	[$18],al
19774                                           !BCC_EOS
19775                                           ! 3591       }
19776                                           ! 3592       break;
19777                       00005584            .4C1:
19778 5584           E9         03DF            br 	.4A9
19779                                           !BCC_EOS
19780                                           ! 3593     case 0xb8:
19781                                           ! 3594       shift_flags &= ~0x08;
19782                       00005587            .4C2:
19783                                           ! Debug: andab int = const -9 to unsigned char shift_flags = [S+8-5] (used reg = )
19784 5587           8A46         FD            mov	al,-3[bp]
19785 558A           24                     F7  and	al,#$F7
19786 558C           8846         FD            mov	-3[bp],al
19787                                           !BCC_EOS
19788                                           ! 3595       *((Bit8u *)(0x17)) = (shift_flags);
19789                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19790 558F           8A46         FD            mov	al,-3[bp]
19791 5592           A2         0017            mov	[$17],al
19792                                           !BCC_EOS
19793                                           ! 3596       if (mf2_state & 0x02) {
19794                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19795 5595           8A46         FB            mov	al,-5[bp]
19796 5598           24                     02  and	al,*2
19797 559A           84C0                       test	al,al
19798 559C           74           10            je  	.4C3
19799                       0000559E            .4C4:
19800                                           ! 3597         mf2_state &= ~0x08;
19801                                           ! Debug: andab int = const -9 to unsigned char mf2_state = [S+8-7] (used reg = )
19802 559E           8A46         FB            mov	al,-5[bp]
19803 55A1           24                     F7  and	al,#$F7
19804 55A3           8846         FB            mov	-5[bp],al
19805                                           !BCC_EOS
19806                                           ! 3598         *((Bit8u *)(0x96)) = (mf2_state);
19807                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
19808 55A6           8A46         FB            mov	al,-5[bp]
19809 55A9           A2         0096            mov	[$96],al
19810                                           !BCC_EOS
19811                                           ! 3599       } else {
19812 55AC           EB           0E            jmp .4C5
19813                       000055AE            .4C3:
19814                                           ! 3600         mf2_flags &= ~0x02;
19815                                           ! Debug: andab int = const -3 to unsigned char mf2_flags = [S+8-6] (used reg = )
19816 55AE           8A46         FC            mov	al,-4[bp]
19817 55B1           24                     FD  and	al,#$FD
19818 55B3           8846         FC            mov	-4[bp],al
19819                                           !BCC_EOS
19820                                           ! 3601         *((Bit8u *)(0x18)) = (mf2_flags);
19821                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19822 55B6           8A46         FC            mov	al,-4[bp]
19823 55B9           A2         0018            mov	[$18],al
19824                                           !BCC_EOS
19825                                           ! 3602       }
19826                                           ! 3603       break;
19827                       000055BC            .4C5:
19828 55BC           E9         03A7            br 	.4A9
19829                                           !BCC_EOS
19830                                           ! 3604     case 0x45:
19831                                           ! 3605       if ((mf2_state & 0x03) == 0) {
19832                       000055BF            .4C6:
19833                                           ! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
19834 55BF           8A46         FB            mov	al,-5[bp]
19835 55C2           24                     03  and	al,*3
19836                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19837 55C4           84C0                       test	al,al
19838 55C6           75           1C            jne 	.4C7
19839                       000055C8            .4C8:
19840                                           ! 3606         mf2_flags |= 0x20;
19841                                           ! Debug: orab int = const $20 to unsigned char mf2_flags = [S+8-6] (used reg = )
19842 55C8           8A46         FC            mov	al,-4[bp]
19843 55CB           0C                     20  or	al,*$20
19844 55CD           8846         FC            mov	-4[bp],al
19845                                           !BCC_EOS
19846                                           ! 3607         *((Bit8u *)(0x18)) = (mf2_flags);
19847                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19848 55D0           8A46         FC            mov	al,-4[bp]
19849 55D3           A2         0018            mov	[$18],al
19850                                           !BCC_EOS
19851                                           ! 3608         shift_flags ^= 0x20;
19852                                           ! Debug: eorab int = const $20 to unsigned char shift_flags = [S+8-5] (used reg = )
19853 55D6           8A46         FD            mov	al,-3[bp]
19854 55D9           34                     20  xor	al,*$20
19855 55DB           8846         FD            mov	-3[bp],al
19856                                           !BCC_EOS
19857                                           ! 3609         *((Bit8u *)(0x17)) = (shift_flags);
19858                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19859 55DE           8A46         FD            mov	al,-3[bp]
19860 55E1           A2         0017            mov	[$17],al
19861                                           !BCC_EOS
19862                                           ! 3610       }
19863                                           ! 3611       break;
19864                       000055E4            .4C7:
19865 55E4           E9         037F            br 	.4A9
19866                                           !BCC_EOS
19867                                           ! 3612     case 0xc5:
19868                                           ! 3613       if ((mf2_state & 0x03) == 0) {
19869                       000055E7            .4C9:
19870                                           ! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
19871 55E7           8A46         FB            mov	al,-5[bp]
19872 55EA           24                     03  and	al,*3
19873                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19874 55EC           84C0                       test	al,al
19875 55EE           75           0E            jne 	.4CA
19876                       000055F0            .4CB:
19877                                           ! 3614         mf2_flags &= ~0x20;
19878                                           ! Debug: andab int = const -$21 to unsigned char mf2_flags = [S+8-6] (used reg = )
19879 55F0           8A46         FC            mov	al,-4[bp]
19880 55F3           24                     DF  and	al,#$DF
19881 55F5           8846         FC            mov	-4[bp],al
19882                                           !BCC_EOS
19883                                           ! 3615         *((Bit8u *)(0x18)) = (mf2_flags);
19884                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19885 55F8           8A46         FC            mov	al,-4[bp]
19886 55FB           A2         0018            mov	[$18],al
19887                                           !BCC_EOS
19888                                           ! 3616       }
19889                                           ! 3617       break;
19890                       000055FE            .4CA:
19891 55FE           E9         0365            br 	.4A9
19892                                           !BCC_EOS
19893                                           ! 3618     case 0x46:
19894                                           ! 3619       if ((mf2_state & 0x02) || (!(mf2_state & 0x10) && (shift_flags & 0x04))) {
19895                       00005601            .4CC:
19896                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19897 5601           8A46         FB            mov	al,-5[bp]
19898 5604           24                     02  and	al,*2
19899 5606           84C0                       test	al,al
19900 5608           75           12            jne 	.4CE
19901                       0000560A            .4CF:
19902                                           ! Debug: and int = const $10 to unsigned char mf2_state = [S+8-7] (used reg = )
19903 560A           8A46         FB            mov	al,-5[bp]
19904 560D           24                     10  and	al,*$10
19905 560F           84C0                       test	al,al
19906 5611           75           32            jne 	.4CD
19907                       00005613            .4D0:
19908                                           ! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
19909 5613           8A46         FD            mov	al,-3[bp]
19910 5616           24                     04  and	al,*4
19911 5618           84C0                       test	al,al
19912 561A           74           29            je  	.4CD
19913                       0000561C            .4CE:
19914                                           ! 3620         mf2_state &= ~0x02;
19915                                           ! Debug: andab int = const -3 to unsigned char mf2_state = [S+8-7] (used reg = )
19916 561C           8A46         FB            mov	al,-5[bp]
19917 561F           24                     FD  and	al,#$FD
19918 5621           8846         FB            mov	-5[bp],al
19919                                           !BCC_EOS
19920                                           ! 3621         *((Bit8u *)(0x96)) = (mf2_state);
19921                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
19922 5624           8A46         FB            mov	al,-5[bp]
19923 5627           A2         0096            mov	[$96],al
19924                                           !BCC_EOS
19925                                           ! 3622         *((Bit8u *)(0x71)) = (0x80);
19926                                           ! Debug: eq int = const $80 to unsigned char = [+$71] (used reg = )
19927 562A           B0                     80  mov	al,#$80
19928 562C           A2         0071            mov	[$71],al
19929                                           !BCC_EOS
19930                                           ! 3623         *((Bit16u *)(0x001C)) = (*((Bit16u *)(0x001A)));
19931                                           ! Debug: eq unsigned short = [+$1A] to unsigned short = [+$1C] (used reg = )
19932 562F           A1         001A            mov	ax,[$1A]
19933 5632           A3         001C            mov	[$1C],ax
19934                                           !BCC_EOS
19935                                           ! 3624 #asm
19936                                           !BCC_EOS
19937                                           !BCC_ASM
19938                       0000000E            _int09_function.BP	set	$E
19939                       00000008            .int09_function.BP	set	8
19940                       00000016            _int09_function.CX	set	$16
19941                       00000010            .int09_function.CX	set	$10
19942                       0000000A            _int09_function.DI	set	$A
19943                       00000004            .int09_function.DI	set	4
19944                       00000014            _int09_function.DX	set	$14
19945                       0000000E            .int09_function.DX	set	$E
19946                       00000002            _int09_function.mf2_flags	set	2
19947                       FFFFFFFC            .int09_function.mf2_flags	set	-4
19948                       0000000C            _int09_function.SI	set	$C
19949                       00000006            .int09_function.SI	set	6
19950                       00000001            _int09_function.mf2_state	set	1
19951                       FFFFFFFB            .int09_function.mf2_state	set	-5
19952                       00000018            _int09_function.AX	set	$18
19953                       00000012            .int09_function.AX	set	$12
19954                       00000004            _int09_function.asciicode	set	4
19955                       FFFFFFFE            .int09_function.asciicode	set	-2
19956                       00000005            _int09_function.scancode	set	5
19957                       FFFFFFFF            .int09_function.scancode	set	-1
19958                       00000010            _int09_function.SP	set	$10
19959                       0000000A            .int09_function.SP	set	$A
19960                       00000012            _int09_function.BX	set	$12
19961                       0000000C            .int09_function.BX	set	$C
19962                       00000003            _int09_function.shift_flags	set	3
19963                       FFFFFFFD            .int09_function.shift_flags	set	-3
19964 5635           CD                     1B          int #0x1B
19965                                           ! 3626 endasm
19966                                           !BCC_ENDASM
19967                                           !BCC_EOS
19968                                           ! 3627         enqueue_key(0, 0);
19969                                           ! Debug: list int = const 0 (used reg = )
19970 5637           31C0                       xor	ax,ax
19971 5639           50                         push	ax
19972                                           ! Debug: list int = const 0 (used reg = )
19973 563A           31C0                       xor	ax,ax
19974 563C           50                         push	ax
19975                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
19976 563D           E8         0349            call	_enqueue_key
19977 5640           83C4                   04  add	sp,*4
19978                                           !BCC_EOS
19979                                           ! 3628       } els
19980                                           ! 3628 e {
19981 5643           EB           1C            jmp .4D1
19982                       00005645            .4CD:
19983                                           ! 3629         mf2_flags |= 0x10;
19984                                           ! Debug: orab int = const $10 to unsigned char mf2_flags = [S+8-6] (used reg = )
19985 5645           8A46         FC            mov	al,-4[bp]
19986 5648           0C                     10  or	al,*$10
19987 564A           8846         FC            mov	-4[bp],al
19988                                           !BCC_EOS
19989                                           ! 3630         *((Bit8u *)(0x18)) = (mf2_flags);
19990                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19991 564D           8A46         FC            mov	al,-4[bp]
19992 5650           A2         0018            mov	[$18],al
19993                                           !BCC_EOS
19994                                           ! 3631         shift_flags ^= 0x10;
19995                                           ! Debug: eorab int = const $10 to unsigned char shift_flags = [S+8-5] (used reg = )
19996 5653           8A46         FD            mov	al,-3[bp]
19997 5656           34                     10  xor	al,*$10
19998 5658           8846         FD            mov	-3[bp],al
19999                                           !BCC_EOS
20000                                           ! 3632         *((Bit8u *)(0x17)) = (shift_flags);
20001                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
20002 565B           8A46         FD            mov	al,-3[bp]
20003 565E           A2         0017            mov	[$17],al
20004                                           !BCC_EOS
20005                                           ! 3633       }
20006                                           ! 3634       break;
20007                       00005661            .4D1:
20008 5661           E9         0302            br 	.4A9
20009                                           !BCC_EOS
20010                                           ! 3635     case 0xc6:
20011                                           ! 3636       if ((mf2_state & 0x02) || (!(mf2_state & 0x10) && (shift_flags & 0x04))) {
20012                       00005664            .4D2:
20013                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
20014 5664           8A46         FB            mov	al,-5[bp]
20015 5667           24                     02  and	al,*2
20016 5669           84C0                       test	al,al
20017 566B           75           12            jne 	.4D4
20018                       0000566D            .4D5:
20019                                           ! Debug: and int = const $10 to unsigned char mf2_state = [S+8-7] (used reg = )
20020 566D           8A46         FB            mov	al,-5[bp]
20021 5670           24                     10  and	al,*$10
20022 5672           84C0                       test	al,al
20023 5674           75           0B            jne 	.4D3
20024                       00005676            .4D6:
20025                                           ! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
20026 5676           8A46         FD            mov	al,-3[bp]
20027 5679           24                     04  and	al,*4
20028 567B           84C0                       test	al,al
20029 567D           74           02            je  	.4D3
20030                       0000567F            .4D4:
20031                                           ! 3637       } else {
20032 567F           EB           0E            jmp .4D7
20033                       00005681            .4D3:
20034                                           ! 3638         mf2_flags &= ~0x10;
20035                                           ! Debug: andab int = const -$11 to unsigned char mf2_flags = [S+8-6] (used reg = )
20036 5681           8A46         FC            mov	al,-4[bp]
20037 5684           24                     EF  and	al,#$EF
20038 5686           8846         FC            mov	-4[bp],al
20039                                           !BCC_EOS
20040                                           ! 3639         *((Bit8u *)(0x18)) = (mf2_flags);
20041                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
20042 5689           8A46         FC            mov	al,-4[bp]
20043 568C           A2         0018            mov	[$18],al
20044                                           !BCC_EOS
20045                                           ! 3640       }
20046                                           ! 3641       break;
20047                       0000568F            .4D7:
20048 568F           E9         02D4            br 	.4A9
20049                                           !BCC_EOS
20050                                           ! 3642     default:
20051                                           ! 3643       if (scancode & 0x80) {
20052                       00005692            .4D8:
20053                                           ! Debug: and int = const $80 to unsigned char scancode = [S+8-3] (used reg = )
20054 5692           8A46         FF            mov	al,-1[bp]
20055 5695           24                     80  and	al,#$80
20056 5697           84C0                       test	al,al
20057 5699           74           03            je  	.4D9
20058                       0000569B            .4DA:
20059                                           ! 3644         break;
20060 569B           E9         02C8            br 	.4A9
20061                                           !BCC_EOS
20062                                           ! 3645       }
20063                                           ! 3646       if (scancode > 0x58) {
20064                       0000569E            .4D9:
20065                                           ! Debug: gt int = const $58 to unsigned char scancode = [S+8-3] (used reg = )
20066 569E           8A46         FF            mov	al,-1[bp]
20067 56A1           3C                     58  cmp	al,*$58
20068 56A3           76           18            jbe 	.4DB
20069                       000056A5            .4DC:
20070                                           ! 3647         bios_printf(4, "KBD: int09h_handler(): unknown scancode read: 0x%02x!\n", scancode);
20071                                           ! Debug: list unsigned char scancode = [S+8-3] (used reg = )
20072 56A5           8A46         FF            mov	al,-1[bp]
20073 56A8           30E4                       xor	ah,ah
20074 56AA           50                         push	ax
20075                                           ! Debug: list * char = .4DD+0 (used reg = )
20076 56AB           BB                   D2B9  mov	bx,#.4DD
20077 56AE           53                         push	bx
20078                                           ! Debug: list int = const 4 (used reg = )
20079 56AF           B8                   0004  mov	ax,*4
20080 56B2           50                         push	ax
20081                                           ! Debug: func () void = bios_printf+0 (used reg = )
20082 56B3           E8         B288            call	_bios_printf
20083 56B6           83C4                   06  add	sp,*6
20084                                           !BCC_EOS
20085                                           ! 3648         return;
20086 56B9           89EC                       mov	sp,bp
20087 56BB           5D                         pop	bp
20088 56BC           C3                         ret
20089                                           !BCC_EOS
20090                                           ! 3649       }
20091                                           ! 3650       if (scancode == 0x53) {
20092                       000056BD            .4DB:
20093                                           ! Debug: logeq int = const $53 to unsigned char scancode = [S+8-3] (used reg = )
20094 56BD           8A46         FF            mov	al,-1[bp]
20095 56C0           3C                     53  cmp	al,*$53
20096 56C2           75           14            jne 	.4DE
20097                       000056C4            .4DF:
20098                                           ! 3651         if ((shift_flags & 0x0f) == 0x0c) {
20099                                           ! Debug: and int = const $F to unsigned char shift_flags = [S+8-5] (used reg = )
20100 56C4           8A46         FD            mov	al,-3[bp]
20101 56C7           24                     0F  and	al,*$F
20102                                           ! Debug: logeq int = const $C to unsigned char = al+0 (used reg = )
20103 56C9           3C                     0C  cmp	al,*$C
20104 56CB           75           0B            jne 	.4E0
20105                       000056CD            .4E1:
20106                                           ! 3652           *((Bit16u *)(0x0072)) = (0x1234);
20107                                           ! Debug: eq int = const $1234 to unsigned short = [+$72] (used reg = )
20108 56CD           B8                   1234  mov	ax,#$1234
20109 56D0           A3         0072            mov	[$72],ax
20110                                           !BCC_EOS
20111                                           ! 3653 #asm
20112                                           !BCC_EOS
20113                                           !BCC_ASM
20114                       0000000E            _int09_function.BP	set	$E
20115                       00000008            .int09_function.BP	set	8
20116                       00000016            _int09_function.CX	set	$16
20117                       00000010            .int09_function.CX	set	$10
20118                       0000000A            _int09_function.DI	set	$A
20119                       00000004            .int09_function.DI	set	4
20120                       00000014            _int09_function.DX	set	$14
20121                       0000000E            .int09_function.DX	set	$E
20122                       00000002            _int09_function.mf2_flags	set	2
20123                       FFFFFFFC            .int09_function.mf2_flags	set	-4
20124                       0000000C            _int09_function.SI	set	$C
20125                       00000006            .int09_function.SI	set	6
20126                       00000001            _int09_function.mf2_state	set	1
20127                       FFFFFFFB            .int09_function.mf2_state	set	-5
20128                       00000018            _int09_function.AX	set	$18
20129                       00000012            .int09_function.AX	set	$12
20130                       00000004            _int09_function.asciicode	set	4
20131                       FFFFFFFE            .int09_function.asciicode	set	-2
20132                       00000005            _int09_function.scancode	set	5
20133                       FFFFFFFF            .int09_function.scancode	set	-1
20134                       00000010            _int09_function.SP	set	$10
20135                       0000000A            .int09_function.SP	set	$A
20136                       00000012            _int09_function.BX	set	$12
20137                       0000000C            .int09_function.BX	set	$C
20138                       00000003            _int09_function.shift_flags	set	3
20139                       FFFFFFFD            .int09_function.shift_flags	set	-3
20140 56D3           EA         E05B      F000            jmp 0xf000:post;
20141                                           ! 3655 endasm
20142                                           !BCC_ENDASM
20143                                           !BCC_EOS
20144                                           ! 3656         }
20145                                           ! 3657       }
20146                       000056D8            .4E0:
20147                                           ! 3658       set_DS(get_CS());
20148                       000056D8            .4DE:
20149                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
20150 56D8           E8         AF81            call	_get_CS
20151                                           ! Debug: list unsigned short = ax+0 (used reg = )
20152 56DB           50                         push	ax
20153                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
20154 56DC           E8         AF83            call	_set_DS
20155 56DF           44                         inc	sp
20156 56E0           44                         inc	sp
20157                                           !BCC_EOS
20158                                           ! 3659       if (shift_flags & 0x08) {
20159                                           ! Debug: and int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
20160 56E1           8A46         FD            mov	al,-3[bp]
20161 56E4           24                     08  and	al,*8
20162 56E6           84C0                       test	al,al
20163 56E8           74           3D            je  	.4E2
20164                       000056EA            .4E3:
20165                                           ! 3660         asciicode = scan_to_scanascii[scancode].alt;
20166                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20167 56EA           8A46         FF            mov	al,-1[bp]
20168 56ED           30E4                       xor	ah,ah
20169 56EF           89C2                       mov	dx,ax
20170 56F1           D1E0                       shl	ax,*1
20171 56F3           D1E0                       shl	ax,*1
20172 56F5           01D0                       add	ax,dx
20173 56F7           D1E0                       shl	ax,*1
20174 56F9           89C3                       mov	bx,ax
20175 56FB           81C3                 017E  add	bx,#_scan_to_scanascii
20176                                           ! Debug: eq unsigned short = [bx+6] to unsigned char asciicode = [S+8-4] (used reg = )
20177 56FF           8A47         06            mov	al,6[bx]
20178 5702           8846         FE            mov	-2[bp],al
20179                                           !BCC_EOS
20180                                           ! 3661         scancode = scan_to_scanascii[scancode].alt >> 8;
20181                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20182 5705           8A46         FF            mov	al,-1[bp]
20183 5708           30E4                       xor	ah,ah
20184 570A           89C2                       mov	dx,ax
20185 570C           D1E0                       shl	ax,*1
20186 570E           D1E0                       shl	ax,*1
20187 5710           01D0                       add	ax,dx
20188 5712           D1E0                       shl	ax,*1
20189 5714           89C3                       mov	bx,ax
20190 5716           81C3                 017E  add	bx,#_scan_to_scanascii
20191                                           ! Debug: sr int = const 8 to unsigned short = [bx+6] (used reg = )
20192 571A           8B47         06            mov	ax,6[bx]
20193 571D           88E0                       mov	al,ah
20194 571F           30E4                       xor	ah,ah
20195                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20196 5721           8846         FF            mov	-1[bp],al
20197                                           !BCC_EOS
20198                                           ! 3662       } else if (shift_flags & 0x04) {
20199 5724           E9         01AD            br 	.4E4
20200                       00005727            .4E2:
20201                                           ! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
20202 5727           8A46         FD            mov	al,-3[bp]
20203 572A           24                     04  and	al,*4
20204 572C           84C0                       test	al,al
20205 572E           74           3D            je  	.4E5
20206                       00005730            .4E6:
20207                                           ! 3663         asciicode = scan_to_scanascii[scancode].control;
20208                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20209 5730           8A46         FF            mov	al,-1[bp]
20210 5733           30E4                       xor	ah,ah
20211 5735           89C2                       mov	dx,ax
20212 5737           D1E0                       shl	ax,*1
20213 5739           D1E0                       shl	ax,*1
20214 573B           01D0                       add	ax,dx
20215 573D           D1E0                       shl	ax,*1
20216 573F           89C3                       mov	bx,ax
20217 5741           81C3                 017E  add	bx,#_scan_to_scanascii
20218                                           ! Debug: eq unsigned short = [bx+4] to unsigned char asciicode = [S+8-4] (used reg = )
20219 5745           8A47         04            mov	al,4[bx]
20220 5748           8846         FE            mov	-2[bp],al
20221                                           !BCC_EOS
20222                                           ! 3664         scancode = scan_to_scanascii[scancode].control >> 8;
20223                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20224 574B           8A46         FF            mov	al,-1[bp]
20225 574E           30E4                       xor	ah,ah
20226 5750           89C2                       mov	dx,ax
20227 5752           D1E0                       shl	ax,*1
20228 5754           D1E0                       shl	ax,*1
20229 5756           01D0                       add	ax,dx
20230 5758           D1E0                       shl	ax,*1
20231 575A           89C3                       mov	bx,ax
20232 575C           81C3                 017E  add	bx,#_scan_to_scanascii
20233                                           ! Debug: sr int = const 8 to unsigned short = [bx+4] (used reg = )
20234 5760           8B47         04            mov	ax,4[bx]
20235 5763           88E0                       mov	al,ah
20236 5765           30E4                       xor	ah,ah
20237                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20238 5767           8846         FF            mov	-1[bp],al
20239                                           !BCC_EOS
20240                                           ! 3665       } else if (((mf2_state & 0x02) > 0) && ((scancode >= 0x47) && (scancode <= 0x53))) {
20241 576A           E9         0167            br 	.4E7
20242                       0000576D            .4E5:
20243                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
20244 576D           8A46         FB            mov	al,-5[bp]
20245 5770           24                     02  and	al,*2
20246                                           ! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
20247 5772           84C0                       test	al,al
20248 5774           74           32            je  	.4E8
20249                       00005776            .4EA:
20250                                           ! Debug: ge int = const $47 to unsigned char scancode = [S+8-3] (used reg = )
20251 5776           8A46         FF            mov	al,-1[bp]
20252 5779           3C                     47  cmp	al,*$47
20253 577B           72           2B            jb  	.4E8
20254                       0000577D            .4EB:
20255                                           ! Debug: le int = const $53 to unsigned char scancode = [S+8-3] (used reg = )
20256 577D           8A46         FF            mov	al,-1[bp]
20257 5780           3C                     53  cmp	al,*$53
20258 5782           77           24            ja  	.4E8
20259                       00005784            .4E9:
20260                                           ! 3666         asciicode = 0xe0;
20261                                           ! Debug: eq int = const $E0 to unsigned char asciicode = [S+8-4] (used reg = )
20262 5784           B0                     E0  mov	al,#$E0
20263 5786           8846         FE            mov	-2[bp],al
20264                                           !BCC_EOS
20265                                           ! 3667         scancode = scan_to_scanascii[scancode].normal >> 8;
20266                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20267 5789           8A46         FF            mov	al,-1[bp]
20268 578C           30E4                       xor	ah,ah
20269 578E           89C2                       mov	dx,ax
20270 5790           D1E0                       shl	ax,*1
20271 5792           D1E0                       shl	ax,*1
20272 5794           01D0                       add	ax,dx
20273 5796           D1E0                       shl	ax,*1
20274 5798           89C3                       mov	bx,ax
20275                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
20276 579A           8B87       017E            mov	ax,_scan_to_scanascii[bx]
20277 579E           88E0                       mov	al,ah
20278 57A0           30E4                       xor	ah,ah
20279                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20280 57A2           8846         FF            mov	-1[bp],al
20281                                           !BCC_EOS
20282                                           ! 3668       } else if (shift_flags & 0x03) {
20283 57A5           E9         012C            br 	.4EC
20284                       000057A8            .4E8:
20285                                           ! Debug: and int = const 3 to unsigned char shift_flags = [S+8-5] (used reg = )
20286 57A8           8A46         FD            mov	al,-3[bp]
20287 57AB           24                     03  and	al,*3
20288 57AD           84C0                       test	al,al
20289 57AF         0F84         0092            beq 	.4ED
20290                       000057B3            .4EE:
20291                                           ! 3669         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
20292                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20293 57B3           8A46         FF            mov	al,-1[bp]
20294 57B6           30E4                       xor	ah,ah
20295 57B8           89C2                       mov	dx,ax
20296 57BA           D1E0                       shl	ax,*1
20297 57BC           D1E0                       shl	ax,*1
20298 57BE           01D0                       add	ax,dx
20299 57C0           D1E0                       shl	ax,*1
20300 57C2           89C3                       mov	bx,ax
20301 57C4           81C3                 017E  add	bx,#_scan_to_scanascii
20302                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
20303 57C8           8A46         FD            mov	al,-3[bp]
20304 57CB           2247         08            and	al,8[bx]
20305 57CE           84C0                       test	al,al
20306 57D0           74           36            je  	.4EF
20307                       000057D2            .4F0:
20308                                           ! 3670           asciicode = scan_to_scanascii[scancode].normal;
20309                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20310 57D2           8A46         FF            mov	al,-1[bp]
20311 57D5           30E4                       xor	ah,ah
20312 57D7           89C2                       mov	dx,ax
20313 57D9           D1E0                       shl	ax,*1
20314 57DB           D1E0                       shl	ax,*1
20315 57DD           01D0                       add	ax,dx
20316 57DF           D1E0                       shl	ax,*1
20317 57E1           89C3                       mov	bx,ax
20318                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
20319 57E3           8A87       017E            mov	al,_scan_to_scanascii[bx]
20320 57E7           8846         FE            mov	-2[bp],al
20321                                           !BCC_EOS
20322                                           ! 3671           scancode = scan_to_scanascii[scancode].normal >> 8;
20323                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20324 57EA           8A46         FF            mov	al,-1[bp]
20325 57ED           30E4                       xor	ah,ah
20326 57EF           89C2                       mov	dx,ax
20327 57F1           D1E0                       shl	ax,*1
20328 57F3           D1E0                       shl	ax,*1
20329 57F5           01D0                       add	ax,dx
20330 57F7           D1E0                       shl	ax,*1
20331 57F9           89C3                       mov	bx,ax
20332                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
20333 57FB           8B87       017E            mov	ax,_scan_to_scanascii[bx]
20334 57FF           88E0                       mov	al,ah
20335 5801           30E4                       xor	ah,ah
20336                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20337 5803           8846         FF            mov	-1[bp],al
20338                                           !BCC_EOS
20339                                           ! 3672         } else {
20340 5806           EB           3A            jmp .4F1
20341                       00005808            .4EF:
20342                                           ! 3673           asciicode = scan_to_scanascii[scancode].shift;
20343                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20344 5808           8A46         FF            mov	al,-1[bp]
20345 580B           30E4                       xor	ah,ah
20346 580D           89C2                       mov	dx,ax
20347 580F           D1E0                       shl	ax,*1
20348 5811           D1E0                       shl	ax,*1
20349 5813           01D0                       add	ax,dx
20350 5815           D1E0                       shl	ax,*1
20351 5817           89C3                       mov	bx,ax
20352 5819           81C3                 017E  add	bx,#_scan_to_scanascii
20353                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
20354 581D           8A47         02            mov	al,2[bx]
20355 5820           8846         FE            mov	-2[bp],al
20356                                           !BCC_EOS
20357                                           ! 3674           scancode = scan_to_scanascii[scancode].shift >> 8;
20358                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20359 5823           8A46         FF            mov	al,-1[bp]
20360 5826           30E4                       xor	ah,ah
20361 5828           89C2                       mov	dx,ax
20362 582A           D1E0                       shl	ax,*1
20363 582C           D1E0                       shl	ax,*1
20364 582E           01D0                       add	ax,dx
20365 5830           D1E0                       shl	ax,*1
20366 5832           89C3                       mov	bx,ax
20367 5834           81C3                 017E  add	bx,#_scan_to_scanascii
20368                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
20369 5838           8B47         02            mov	ax,2[bx]
20370 583B           88E0                       mov	al,ah
20371 583D           30E4                       xor	ah,ah
20372                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20373 583F           8846         FF            mov	-1[bp],al
20374                                           !BCC_EOS
20375                                           ! 3675         }
20376                                           ! 3676       } else {
20377                       00005842            .4F1:
20378 5842           E9         008F            br 	.4F2
20379                       00005845            .4ED:
20380                                           ! 3677         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
20381                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20382 5845           8A46         FF            mov	al,-1[bp]
20383 5848           30E4                       xor	ah,ah
20384 584A           89C2                       mov	dx,ax
20385 584C           D1E0                       shl	ax,*1
20386 584E           D1E0                       shl	ax,*1
20387 5850           01D0                       add	ax,dx
20388 5852           D1E0                       shl	ax,*1
20389 5854           89C3                       mov	bx,ax
20390 5856           81C3                 017E  add	bx,#_scan_to_scanascii
20391                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
20392 585A           8A46         FD            mov	al,-3[bp]
20393 585D           2247         08            and	al,8[bx]
20394 5860           84C0                       test	al,al
20395 5862           74           3C            je  	.4F3
20396                       00005864            .4F4:
20397                                           ! 3678           asciicode = scan_to_scanascii[scancode].shift;
20398                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20399 5864           8A46         FF            mov	al,-1[bp]
20400 5867           30E4                       xor	ah,ah
20401 5869           89C2                       mov	dx,ax
20402 586B           D1E0                       shl	ax,*1
20403 586D           D1E0                       shl	ax,*1
20404 586F           01D0                       add	ax,dx
20405 5871           D1E0                       shl	ax,*1
20406 5873           89C3                       mov	bx,ax
20407 5875           81C3                 017E  add	bx,#_scan_to_scanascii
20408                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
20409 5879           8A47         02            mov	al,2[bx]
20410 587C           8846         FE            mov	-2[bp],al
20411                                           !BCC_EOS
20412                                           ! 3679           scancode = scan_to_scanascii[scancode].shift >> 8;
20413                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20414 587F           8A46         FF            mov	al,-1[bp]
20415 5882           30E4                       xor	ah,ah
20416 5884           89C2                       mov	dx,ax
20417 5886           D1E0                       shl	ax,*1
20418 5888           D1E0                       shl	ax,*1
20419 588A           01D0                       add	ax,dx
20420 588C           D1E0                       shl	ax,*1
20421 588E           89C3                       mov	bx,ax
20422 5890           81C3                 017E  add	bx,#_scan_to_scanascii
20423                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
20424 5894           8B47         02            mov	ax,2[bx]
20425 5897           88E0                       mov	al,ah
20426 5899           30E4                       xor	ah,ah
20427                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20428 589B           8846         FF            mov	-1[bp],al
20429                                           !BCC_EOS
20430                                           ! 3680         } else {
20431 589E           EB           34            jmp .4F5
20432                       000058A0            .4F3:
20433                                           ! 3681           asciicode = scan_to_scanascii[scancode].normal;
20434                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20435 58A0           8A46         FF            mov	al,-1[bp]
20436 58A3           30E4                       xor	ah,ah
20437 58A5           89C2                       mov	dx,ax
20438 58A7           D1E0                       shl	ax,*1
20439 58A9           D1E0                       shl	ax,*1
20440 58AB           01D0                       add	ax,dx
20441 58AD           D1E0                       shl	ax,*1
20442 58AF           89C3                       mov	bx,ax
20443                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
20444 58B1           8A87       017E            mov	al,_scan_to_scanascii[bx]
20445 58B5           8846         FE            mov	-2[bp],al
20446                                           !BCC_EOS
20447                                           ! 3682           scancode = scan_to_scanascii[scancode].normal >> 8;
20448                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20449 58B8           8A46         FF            mov	al,-1[bp]
20450 58BB           30E4                       xor	ah,ah
20451 58BD           89C2                       mov	dx,ax
20452 58BF           D1E0                       shl	ax,*1
20453 58C1           D1E0                       shl	ax,*1
20454 58C3           01D0                       add	ax,dx
20455 58C5           D1E0                       shl	ax,*1
20456 58C7           89C3                       mov	bx,ax
20457                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
20458 58C9           8B87       017E            mov	ax,_scan_to_scanascii[bx]
20459 58CD           88E0                       mov	al,ah
20460 58CF           30E4                       xor	ah,ah
20461                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20462 58D1           8846         FF            mov	-1[bp],al
20463                                           !BCC_EOS
20464                                           ! 3683         }
20465                                           ! 3684       }
20466                       000058D4            .4F5:
20467                                           ! 3685       set_DS(0x40);
20468                       000058D4            .4F2:
20469                       000058D4            .4EC:
20470                       000058D4            .4E7:
20471                       000058D4            .4E4:
20472                                           ! Debug: list int = const $40 (used reg = )
20473 58D4           B8                   0040  mov	ax,*$40
20474 58D7           50                         push	ax
20475                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
20476 58D8           E8         AD87            call	_set_DS
20477 58DB           44                         inc	sp
20478 58DC           44                         inc	sp
20479                                           !BCC_EOS
20480                                           ! 3686       if (scancode==0 && asciicode==0) {
20481                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
20482 58DD           8A46         FF            mov	al,-1[bp]
20483 58E0           84C0                       test	al,al
20484 58E2           75           15            jne 	.4F6
20485                       000058E4            .4F8:
20486                                           ! Debug: logeq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
20487 58E4           8A46         FE            mov	al,-2[bp]
20488 58E7           84C0                       test	al,al
20489 58E9           75           0E            jne 	.4F6
20490                       000058EB            .4F7:
20491                                           ! 3687    
20492                                           ! 3687      bios_printf(4, "KBD: int09h_handler(): scancode & asciicode are zero?\n");
20493                                           ! Debug: list * char = .4F9+0 (used reg = )
20494 58EB           BB                   D282  mov	bx,#.4F9
20495 58EE           53                         push	bx
20496                                           ! Debug: list int = const 4 (used reg = )
20497 58EF           B8                   0004  mov	ax,*4
20498 58F2           50                         push	ax
20499                                           ! Debug: func () void = bios_printf+0 (used reg = )
20500 58F3           E8         B048            call	_bios_printf
20501 58F6           83C4                   04  add	sp,*4
20502                                           !BCC_EOS
20503                                           ! 3688       }
20504                                           ! 3689       enqueue_key(scancode, asciicode);
20505                       000058F9            .4F6:
20506                                           ! Debug: list unsigned char asciicode = [S+8-4] (used reg = )
20507 58F9           8A46         FE            mov	al,-2[bp]
20508 58FC           30E4                       xor	ah,ah
20509 58FE           50                         push	ax
20510                                           ! Debug: list unsigned char scancode = [S+$A-3] (used reg = )
20511 58FF           8A46         FF            mov	al,-1[bp]
20512 5902           30E4                       xor	ah,ah
20513 5904           50                         push	ax
20514                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
20515 5905           E8         0081            call	_enqueue_key
20516 5908           83C4                   04  add	sp,*4
20517                                           !BCC_EOS
20518                                           ! 3690       break;
20519 590B           EB           59            jmp .4A9
20520                                           !BCC_EOS
20521                                           ! 3691   }
20522                                           ! 3692   if ((scancode & 0x7f) != 0x1d) {
20523 590D           EB           57            jmp .4A9
20524                       0000590F            .4AB:
20525 590F           2C                     1D  sub	al,*$1D
20526 5911         0F84         FBB8            beq 	.4B2
20527 5915           2C                     0D  sub	al,*$D
20528 5917         0F84         FB6E            beq 	.4AE
20529 591B           2C                     0C  sub	al,*$C
20530 591D         0F84         FB8A            beq 	.4B0
20531 5921           2C                     02  sub	al,*2
20532 5923         0F84         FC28            beq 	.4BE
20533 5927           2C                     02  sub	al,*2
20534 5929         0F84         FB2C            beq 	.4AC
20535 592D           2C                     0B  sub	al,*$B
20536 592F         0F84         FC8C            beq 	.4C6
20537 5933           2C                     01  sub	al,*1
20538 5935         0F84         FCC8            beq 	.4CC
20539 5939           2C                     57  sub	al,*$57
20540 593B         0F84         FBCF            beq 	.4B8
20541 593F           2C                     0D  sub	al,*$D
20542 5941         0F84         FB55            beq 	.4AF
20543 5945           2C                     0C  sub	al,*$C
20544 5947         0F84         FB71            beq 	.4B1
20545 594B           2C                     02  sub	al,*2
20546 594D         0F84         FC36            beq 	.4C2
20547 5951           2C                     02  sub	al,*2
20548 5953         0F84         FB21            beq 	.4AD
20549 5957           2C                     0B  sub	al,*$B
20550 5959         0F84         FC8A            beq 	.4C9
20551 595D           2C                     01  sub	al,*1
20552 595F         0F84         FD01            beq 	.4D2
20553 5963           E9         FD2C            br 	.4D8
20554                       00005966            .4A9:
20555                       FFFFFFF8            ..FFF2	=	-8
20556                                           ! Debug: and int = const $7F to unsigned char scancode = [S+8-3] (used reg = )
20557 5966           8A46         FF            mov	al,-1[bp]
20558 5969           24                     7F  and	al,*$7F
20559                                           ! Debug: ne int = const $1D to unsigned char = al+0 (used reg = )
20560 596B           3C                     1D  cmp	al,*$1D
20561 596D           74           08            je  	.4FA
20562                       0000596F            .4FB:
20563                                           ! 3693     mf2_state &= ~0x01;
20564                                           ! Debug: andab int = const -2 to unsigned char mf2_state = [S+8-7] (used reg = )
20565 596F           8A46         FB            mov	al,-5[bp]
20566 5972           24                     FE  and	al,#$FE
20567 5974           8846         FB            mov	-5[bp],al
20568                                           !BCC_EOS
20569                                           ! 3694   }
20570                                           ! 3695   mf2_state &= ~0x02;
20571                       00005977            .4FA:
20572                                           ! Debug: andab int = const -3 to unsigned char mf2_state = [S+8-7] (used reg = )
20573 5977           8A46         FB            mov	al,-5[bp]
20574 597A           24                     FD  and	al,#$FD
20575 597C           8846         FB            mov	-5[bp],al
20576                                           !BCC_EOS
20577                                           ! 3696   *((Bit8u *)(0x96)) = (mf2_state);
20578                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
20579 597F           8A46         FB            mov	al,-5[bp]
20580 5982           A2         0096            mov	[$96],al
20581                                           !BCC_EOS
20582                                           ! 3697 }
20583 5985           89EC                       mov	sp,bp
20584 5987           5D                         pop	bp
20585 5988           C3                         ret
20586                                           ! 3698   unsigned int
20587                                           ! Register BX used in function int09_function
20588                                           ! 3699 enqueue_key(scan_code, ascii_code)
20589                                           ! 3700   Bit8u scan_code, ascii_code;
20590                                           export	_enqueue_key
20591                       00005989            _enqueue_key:
20592                                           !BCC_EOS
20593                                           ! 3701 {
20594                                           ! 3702   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail, temp_tail, old_ds;
20595                                           !BCC_EOS
20596                                           ! 3703   old_ds = set_DS(0x40);
20597 5989           55                         push	bp
20598 598A           89E5                       mov	bp,sp
20599 598C           83C4                   F4  add	sp,*-$C
20600                                           ! Debug: list int = const $40 (used reg = )
20601 598F           B8                   0040  mov	ax,*$40
20602 5992           50                         push	ax
20603                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
20604 5993           E8         ACCC            call	_set_DS
20605 5996           44                         inc	sp
20606 5997           44                         inc	sp
20607                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+$E-$E] (used reg = )
20608 5998           8946         F4            mov	-$C[bp],ax
20609                                           !BCC_EOS
20610                                           ! 3704   buffer_start = *((Bit16u *)(0x0080));
20611                                           ! Debug: eq unsigned short = [+$80] to unsigned short buffer_start = [S+$E-4] (used reg = )
20612 599B           A1         0080            mov	ax,[$80]
20613 599E           8946         FE            mov	-2[bp],ax
20614                                           !BCC_EOS
20615                                           ! 3705   buffer_end = *((Bit16u *)(0x0082));
20616                                           ! Debug: eq unsigned short = [+$82] to unsigned short buffer_end = [S+$E-6] (used reg = )
20617 59A1           A1         0082            mov	ax,[$82]
20618 59A4           8946         FC            mov	-4[bp],ax
20619                                           !BCC_EOS
20620                                           ! 3706   buffer_head = *((Bit16u *)(0x001A));
20621                                           ! Debug: eq unsigned short = [+$1A] to unsigned short buffer_head = [S+$E-8] (used reg = )
20622 59A7           A1         001A            mov	ax,[$1A]
20623 59AA           8946         FA            mov	-6[bp],ax
20624                                           !BCC_EOS
20625                                           ! 3707   buffer_tail = *((Bit16u *)(0x001C));
20626                                           ! Debug: eq unsigned short = [+$1C] to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20627 59AD           A1         001C            mov	ax,[$1C]
20628 59B0           8946         F8            mov	-8[bp],ax
20629                                           !BCC_EOS
20630                                           ! 3708   temp_tail = buffer_tail;
20631                                           ! Debug: eq unsigned short buffer_tail = [S+$E-$A] to unsigned short temp_tail = [S+$E-$C] (used reg = )
20632 59B3           8B46         F8            mov	ax,-8[bp]
20633 59B6           8946         F6            mov	-$A[bp],ax
20634                                           !BCC_EOS
20635                                           ! 3709   buffer_tail += 2;
20636                                           ! Debug: addab int = const 2 to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20637 59B9           8B46         F8            mov	ax,-8[bp]
20638 59BC           40                         inc	ax
20639 59BD           40                         inc	ax
20640 59BE           8946         F8            mov	-8[bp],ax
20641                                           !BCC_EOS
20642                                           ! 3710   if (buffer_tail >= buffer_end)
20643                                           ! Debug: ge unsigned short buffer_end = [S+$E-6] to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20644 59C1           8B46         F8            mov	ax,-8[bp]
20645 59C4           3B46         FC            cmp	ax,-4[bp]
20646 59C7           72           06            jb  	.4FC
20647                       000059C9            .4FD:
20648                                           ! 3711     buffer_tail = buffer_start;
20649                                           ! Debug: eq unsigned short buffer_start = [S+$E-4] to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20650 59C9           8B46         FE            mov	ax,-2[bp]
20651 59CC           8946         F8            mov	-8[bp],ax
20652                                           !BCC_EOS
20653                                           ! 3712   if (buffer_tail == buffer_head) {
20654                       000059CF            .4FC:
20655                                           ! Debug: logeq unsigned short buffer_head = [S+$E-8] to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20656 59CF           8B46         F8            mov	ax,-8[bp]
20657 59D2           3B46         FA            cmp	ax,-6[bp]
20658 59D5           75           0E            jne 	.4FE
20659                       000059D7            .4FF:
20660                                           ! 3713     set_DS(old_ds);
20661                                           ! Debug: list unsigned short old_ds = [S+$E-$E] (used reg = )
20662 59D7           FF76         F4            push	-$C[bp]
20663                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
20664 59DA           E8         AC85            call	_set_DS
20665 59DD           44                         inc	sp
20666 59DE           44                         inc	sp
20667                                           !BCC_EOS
20668                                           ! 3714     return(0);
20669 59DF           31C0                       xor	ax,ax
20670 59E1           89EC                       mov	sp,bp
20671 59E3           5D                         pop	bp
20672 59E4           C3                         ret
20673                                           !BCC_EOS
20674                                           ! 3715   }
20675                                           ! 3716   *((Bit8u *)(temp_tail)) = (ascii_code);
20676                       000059E5            .4FE:
20677 59E5           8B5E         F6            mov	bx,-$A[bp]
20678                                           ! Debug: eq unsigned char ascii_code = [S+$E+4] to unsigned char = [bx+0] (used reg = )
20679 59E8           8A46         06            mov	al,6[bp]
20680 59EB           8807                       mov	[bx],al
20681                                           !BCC_EOS
20682                                           ! 3717   *((Bit8u *)(temp_tail+1)) = (scan_code);
20683                                           ! Debug: add int = const 1 to unsigned short temp_tail = [S+$E-$C] (used reg = )
20684 59ED           8B46         F6            mov	ax,-$A[bp]
20685                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+1 (used reg = )
20686 59F0           89C3                       mov	bx,ax
20687                                           ! Debug: eq unsigned char scan_code = [S+$E+2] to unsigned char = [bx+1] (used reg = )
20688 59F2           8A46         04            mov	al,4[bp]
20689 59F5           8847         01            mov	1[bx],al
20690                                           !BCC_EOS
20691                                           ! 3718   *((Bit16u *)(0x001C)) = (buffer_tail);
20692                                           ! Debug: eq unsigned short buffer_tail = [S+$E-$A] to unsigned short = [+$1C] (used reg = )
20693 59F8           8B46         F8            mov	ax,-8[bp]
20694 59FB           A3         001C            mov	[$1C],ax
20695                                           !BCC_EOS
20696                                           ! 3719   set_DS(old_ds);
20697                                           ! Debug: list unsigned short old_ds = [S+$E-$E] (used reg = )
20698 59FE           FF76         F4            push	-$C[bp]
20699                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
20700 5A01           E8         AC5E            call	_set_DS
20701 5A04           44                         inc	sp
20702 5A05           44                         inc	sp
20703                                           !BCC_EOS
20704                                           ! 3720   return(1);
20705 5A06           B8                   0001  mov	ax,*1
20706 5A09           89EC                       mov	sp,bp
20707 5A0B           5D                         pop	bp
20708 5A0C           C3                         ret
20709                                           !BCC_EOS
20710                                           ! 3721 }
20711                                           ! 3722   void
20712                                           ! Register BX used in function enqueue_key
20713                                           ! 3723 int74_function(make_farcall, Z, Y, X, status)
20714                                           ! 3724   Bit16u make_farcall, Z, Y, X, status;
20715                                           export	_int74_function
20716                       00005A0D            _int74_function:
20717                                           !BCC_EOS
20718                                           ! 3725 {
20719                                           ! 3726   Bit8u in_byte, index, package_count;
20720                                           !BCC_EOS
20721                                           ! 3727   Bit8u mouse_flags_1, mouse_flags_2;
20722                                           !BCC_EOS
20723                                           ! 3728 ;
20724 5A0D           55                         push	bp
20725 5A0E           89E5                       mov	bp,sp
20726 5A10           83C4                   FA  add	sp,*-6
20727                                           !BCC_EOS
20728                                           ! 3729   make_farcall = 0;
20729                                           ! Debug: eq int = const 0 to unsigned short make_farcall = [S+8+2] (used reg = )
20730 5A13           31C0                       xor	ax,ax
20731 5A15           8946         04            mov	4[bp],ax
20732                                           !BCC_EOS
20733                                           ! 3730   in_byte = inb(0x0064);
20734                                           ! Debug: list int = const $64 (used reg = )
20735 5A18           B8                   0064  mov	ax,*$64
20736 5A1B           50                         push	ax
20737                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20738 5A1C           E8         AAD9            call	_inb
20739 5A1F           44                         inc	sp
20740 5A20           44                         inc	sp
20741                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+8-3] (used reg = )
20742 5A21           8846         FF            mov	-1[bp],al
20743                                           !BCC_EOS
20744                                           ! 3731   if ((in_byte & 0x21) != 0x21) {
20745                                           ! Debug: and int = const $21 to unsigned char in_byte = [S+8-3] (used reg = )
20746 5A24           8A46         FF            mov	al,-1[bp]
20747 5A27           24                     21  and	al,*$21
20748                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
20749 5A29           3C                     21  cmp	al,*$21
20750 5A2B           74           04            je  	.500
20751                       00005A2D            .501:
20752                                           ! 3732     return;
20753 5A2D           89EC                       mov	sp,bp
20754 5A2F           5D                         pop	bp
20755 5A30           C3                         ret
20756                                           !BCC_EOS
20757                                           ! 3733   }
20758                                           ! 3734   in_byte = inb(0x0060);
20759                       00005A31            .500:
20760                                           ! Debug: list int = const $60 (used reg = )
20761 5A31           B8                   0060  mov	ax,*$60
20762 5A34           50                         push	ax
20763                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20764 5A35           E8         AAC0            call	_inb
20765 5A38           44                         inc	sp
20766 5A39           44                         inc	sp
20767                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+8-3] (used reg = )
20768 5A3A           8846         FF            mov	-1[bp],al
20769                                           !BCC_EOS
20770                                           ! 3735 ;
20771                                           !BCC_EOS
20772                                           ! 3736   mouse_flags_1 = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_flag1));
20773                                           ! Debug: eq unsigned char = [+$26] to unsigned char mouse_flags_1 = [S+8-6] (used reg = )
20774 5A3D           A0         0026            mov	al,[$26]
20775 5A40           8846         FC            mov	-4[bp],al
20776                                           !BCC_EOS
20777                                           ! 3737   mouse_flags_2 = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_flag2));
20778                                           ! Debug: eq unsigned char = [+$27] to unsigned char mouse_flags_2 = [S+8-7] (used reg = )
20779 5A43           A0         0027            mov	al,[$27]
20780 5A46           8846         FB            mov	-5[bp],al
20781                                           !BCC_EOS
20782                                           ! 3738   if ((mouse_flags_2 & 0x80) != 0x80) {
20783                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+8-7] (used reg = )
20784 5A49           8A46         FB            mov	al,-5[bp]
20785 5A4C           24                     80  and	al,#$80
20786                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
20787 5A4E           3C                     80  cmp	al,#$80
20788 5A50           74           04            je  	.502
20789                       00005A52            .503:
20790                                           ! 3739       return;
20791 5A52           89EC                       mov	sp,bp
20792 5A54           5D                         pop	bp
20793 5A55           C3                         ret
20794                                           !BCC_EOS
20795                                           ! 3740   }
20796                                           ! 3741   package_count = mouse_flags_2 & 0x07;
20797                       00005A56            .502:
20798                                           ! Debug: and int = const 7 to unsigned char mouse_flags_2 = [S+8-7] (used reg = )
20799 5A56           8A46         FB            mov	al,-5[bp]
20800 5A59           24                     07  and	al,*7
20801                                           ! Debug: eq unsigned char = al+0 to unsigned char package_count = [S+8-5] (used reg = )
20802 5A5B           8846         FD            mov	-3[bp],al
20803                                           !BCC_EOS
20804                                           ! 3742   index = mouse_flags_1 & 0x07;
20805                                           ! Debug: and int = const 7 to unsigned char mouse_flags_1 = [S+8-6] (used reg = )
20806 5A5E           8A46         FC            mov	al,-4[bp]
20807 5A61           24                     07  and	al,*7
20808                                           ! Debug: eq unsigned char = al+0 to unsigned char index = [S+8-4] (used reg = )
20809 5A63           8846         FE            mov	-2[bp],al
20810                                           !BCC_EOS
20811                                           ! 3743   *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[index])) = (in_byte);
20812                                           ! Debug: ptradd unsigned char index = [S+8-4] to [8] unsigned char = const $28 (used reg = )
20813 5A66           8A46         FE            mov	al,-2[bp]
20814 5A69           30E4                       xor	ah,ah
20815 5A6B           89C3                       mov	bx,ax
20816                                           ! Debug: address unsigned char = [bx+$28] (used reg = )
20817                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$28 (used reg = )
20818                                           ! Debug: eq unsigned char in_byte = [S+8-3] to unsigned char = [bx+$28] (used reg = )
20819 5A6D           8A46         FF            mov	al,-1[bp]
20820 5A70           8847         28            mov	$28[bx],al
20821                                           !BCC_EOS
20822                                           ! 3744   if (index >= package_count) {
20823                                           ! Debug: ge unsigned char package_count = [S+8-5] to unsigned char index = [S+8-4] (used reg = )
20824 5A73           8A46         FE            mov	al,-2[bp]
20825 5A76           3A46         FD            cmp	al,-3[bp]
20826 5A79           72           5A            jb  	.504
20827                       00005A7B            .505:
20828                                           ! 3745 ;
20829                                           !BCC_EOS
20830                                           ! 3746     if (package_count == 3) {
20831                                           ! Debug: logeq int = const 3 to unsigned char package_count = [S+8-5] (used reg = )
20832 5A7B           8A46         FD            mov	al,-3[bp]
20833 5A7E           3C                     03  cmp	al,*3
20834 5A80           75           20            jne 	.506
20835                       00005A82            .507:
20836                                           ! 3747       status = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[0]));
20837                                           ! Debug: eq unsigned char = [+$28] to unsigned short status = [S+8+$A] (used reg = )
20838 5A82           A0         0028            mov	al,[$28]
20839 5A85           30E4                       xor	ah,ah
20840 5A87           8946         0C            mov	$C[bp],ax
20841                                           !BCC_EOS
20842                                           ! 3748       *(((Bit8u *)&status)+1) = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[1]));
20843                                           ! Debug: eq unsigned char = [+$29] to unsigned char status = [S+8+$B] (used reg = )
20844 5A8A           A0         0029            mov	al,[$29]
20845 5A8D           8846         0D            mov	$D[bp],al
20846                                           !BCC_EOS
20847                                           ! 3749       X = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[2]));
20848                                           ! Debug: eq unsigned char = [+$2A] to unsigned short X = [S+8+8] (used reg = )
20849 5A90           A0         002A            mov	al,[$2A]
20850 5A93           30E4                       xor	ah,ah
20851 5A95           8946         0A            mov	$A[bp],ax
20852                                           !BCC_EOS
20853                                           ! 3750       Y = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[3]));
20854                                           ! Debug: eq unsigned char = [+$2B] to unsigned short Y = [S+8+6] (used reg = )
20855 5A98           A0         002B            mov	al,[$2B]
20856 5A9B           30E4                       xor	ah,ah
20857 5A9D           8946         08            mov	8[bp],ax
20858                                           !BCC_EOS
20859                                           ! 3751     } else {
20860 5AA0           EB           18            jmp .508
20861                       00005AA2            .506:
20862                                           ! 3752       status = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[0]));
20863                                           ! Debug: eq unsigned char = [+$28] to unsigned short status = [S+8+$A] (used reg = )
20864 5AA2           A0         0028            mov	al,[$28]
20865 5AA5           30E4                       xor	ah,ah
20866 5AA7           8946         0C            mov	$C[bp],ax
20867                                           !BCC_EOS
20868                                           ! 3753       X = *((Bit8u *)(&((ebda_data_t *) 0)->mou
20869                                           ! 3753 se_data[1]));
20870                                           ! Debug: eq unsigned char = [+$29] to unsigned short X = [S+8+8] (used reg = )
20871 5AAA           A0         0029            mov	al,[$29]
20872 5AAD           30E4                       xor	ah,ah
20873 5AAF           8946         0A            mov	$A[bp],ax
20874                                           !BCC_EOS
20875                                           ! 3754       Y = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[2]));
20876                                           ! Debug: eq unsigned char = [+$2A] to unsigned short Y = [S+8+6] (used reg = )
20877 5AB2           A0         002A            mov	al,[$2A]
20878 5AB5           30E4                       xor	ah,ah
20879 5AB7           8946         08            mov	8[bp],ax
20880                                           !BCC_EOS
20881                                           ! 3755     }
20882                                           ! 3756     Z = 0;
20883                       00005ABA            .508:
20884                                           ! Debug: eq int = const 0 to unsigned short Z = [S+8+4] (used reg = )
20885 5ABA           31C0                       xor	ax,ax
20886 5ABC           8946         06            mov	6[bp],ax
20887                                           !BCC_EOS
20888                                           ! 3757     mouse_flags_1 = 0;
20889                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+8-6] (used reg = )
20890 5ABF           30C0                       xor	al,al
20891 5AC1           8846         FC            mov	-4[bp],al
20892                                           !BCC_EOS
20893                                           ! 3758     if (mouse_flags_2 & 0x80)
20894                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+8-7] (used reg = )
20895 5AC4           8A46         FB            mov	al,-5[bp]
20896 5AC7           24                     80  and	al,#$80
20897 5AC9           84C0                       test	al,al
20898 5ACB           74           06            je  	.509
20899                       00005ACD            .50A:
20900                                           ! 3759       make_farcall = 1;
20901                                           ! Debug: eq int = const 1 to unsigned short make_farcall = [S+8+2] (used reg = )
20902 5ACD           B8                   0001  mov	ax,*1
20903 5AD0           8946         04            mov	4[bp],ax
20904                                           !BCC_EOS
20905                                           ! 3760   } else {
20906                       00005AD3            .509:
20907 5AD3           EB           07            jmp .50B
20908                       00005AD5            .504:
20909                                           ! 3761     mouse_flags_1++;
20910                                           ! Debug: postinc unsigned char mouse_flags_1 = [S+8-6] (used reg = )
20911 5AD5           8A46         FC            mov	al,-4[bp]
20912 5AD8           40                         inc	ax
20913 5AD9           8846         FC            mov	-4[bp],al
20914                                           !BCC_EOS
20915                                           ! 3762   }
20916                                           ! 3763   *((Bit8u *)(&((ebda_data_t *) 0)->mouse_flag1)) = (mouse_flags_1);
20917                       00005ADC            .50B:
20918                                           ! Debug: eq unsigned char mouse_flags_1 = [S+8-6] to unsigned char = [+$26] (used reg = )
20919 5ADC           8A46         FC            mov	al,-4[bp]
20920 5ADF           A2         0026            mov	[$26],al
20921                                           !BCC_EOS
20922                                           ! 3764 }
20923 5AE2           89EC                       mov	sp,bp
20924 5AE4           5D                         pop	bp
20925 5AE5           C3                         ret
20926                                           ! 3765   int
20927                                           ! Register BX used in function int74_function
20928                                           ! 3766 int13_edd(DS, SI, device)
20929                                           ! 3767   Bit16u DS, SI;
20930                                           export	_int13_edd
20931                       00005AE6            _int13_edd:
20932                                           !BCC_EOS
20933                                           ! 3768   Bit8u device;
20934                                           !BCC_EOS
20935                                           ! 3769 {
20936                                           ! 3770   Bit32u lba_low, lba_high;
20937                                           !BCC_EOS
20938                                           ! 3771   Bit16u npc, nph, npspt, size, t13;
20939                                           !BCC_EOS
20940                                           ! 3772   Bit16u ebda_seg=get_ebda_seg();
20941 5AE6           55                         push	bp
20942 5AE7           89E5                       mov	bp,sp
20943 5AE9           83C4                   EC  add	sp,*-$14
20944                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
20945 5AEC           E8         AB7D            call	_get_ebda_seg
20946                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$16-$16] (used reg = )
20947 5AEF           8946         EC            mov	-$14[bp],ax
20948                                           !BCC_EOS
20949                                           ! 3773   Bit8u type=*((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type));
20950 5AF2           4C                         dec	sp
20951                                           ! Debug: ptradd unsigned char device = [S+$17+6] to [8] struct  = const $142 (used reg = )
20952 5AF3           8A46         08            mov	al,8[bp]
20953 5AF6           30E4                       xor	ah,ah
20954 5AF8           B9                   001E  mov	cx,*$1E
20955 5AFB           F7E9                       imul	cx
20956 5AFD           89C3                       mov	bx,ax
20957                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
20958                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
20959                                           ! Debug: eq unsigned char = [bx+$142] to unsigned char type = [S+$17-$17] (used reg = )
20960 5AFF           8A87       0142            mov	al,$142[bx]
20961 5B03           8846         EB            mov	-$15[bp],al
20962                                           !BCC_EOS
20963                                           ! 3774   size=_read_word(SI+(Bit16u)&((dpt_t *) 0)->size, DS);
20964 5B06           4C                         dec	sp
20965                                           ! Debug: list unsigned short DS = [S+$18+2] (used reg = )
20966 5B07           FF76         04            push	4[bp]
20967                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$1A+4] (used reg = )
20968 5B0A           8B46         06            mov	ax,6[bp]
20969                                           ! Debug: list unsigned int = ax+0 (used reg = )
20970 5B0D           50                         push	ax
20971                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
20972 5B0E           E8         AAE1            call	__read_word
20973 5B11           83C4                   04  add	sp,*4
20974                                           ! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$18-$12] (used reg = )
20975 5B14           8946         F0            mov	-$10[bp],ax
20976                                           !BCC_EOS
20977                                           ! 3775   t13 = size == 74;
20978                                           ! Debug: logeq int = const $4A to unsigned short size = [S+$18-$12] (used reg = )
20979 5B17           8B46         F0            mov	ax,-$10[bp]
20980 5B1A           3D                   004A  cmp	ax,*$4A
20981 5B1D           75           04            jne	.50C
20982 5B1F           B0                     01  mov	al,*1
20983 5B21           EB           02            jmp	.50D
20984                       00005B23            .50C:
20985 5B23           30C0                       xor	al,al
20986                       00005B25            .50D:
20987                                           ! Debug: eq char = al+0 to unsigned short t13 = [S+$18-$14] (used reg = )
20988 5B25           30E4                       xor	ah,ah
20989 5B27           8946         EE            mov	-$12[bp],ax
20990                                           !BCC_EOS
20991                                           ! 3776   if(size < 26)
20992                                           ! Debug: lt int = const $1A to unsigned short size = [S+$18-$12] (used reg = )
20993 5B2A           8B46         F0            mov	ax,-$10[bp]
20994 5B2D           3D                   001A  cmp	ax,*$1A
20995 5B30           73           07            jae 	.50E
20996                       00005B32            .50F:
20997                                           ! 3777     return 1;
20998 5B32           B8                   0001  mov	ax,*1
20999 5B35           89EC                       mov	sp,bp
21000 5B37           5D                         pop	bp
21001 5B38           C3                         ret
21002                                           !BCC_EOS
21003                                           ! 3778   if(size >= 26) {
21004                       00005B39            .50E:
21005                                           ! Debug: ge int = const $1A to unsigned short size = [S+$18-$12] (used reg = )
21006 5B39           8B46         F0            mov	ax,-$10[bp]
21007 5B3C           3D                   001A  cmp	ax,*$1A
21008 5B3F         0F82         01DB            blo 	.510
21009                       00005B43            .511:
21010                                           ! 3779     Bit16u blksize, infos;
21011                                           !BCC_EOS
21012                                           ! 3780     _write_word(26, SI+(Bit16u)&((dpt_t *) 0)->size, DS);
21013 5B43           83C4                   FC  add	sp,*-4
21014                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21015 5B46           FF76         04            push	4[bp]
21016                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$1E+4] (used reg = )
21017 5B49           8B46         06            mov	ax,6[bp]
21018                                           ! Debug: list unsigned int = ax+0 (used reg = )
21019 5B4C           50                         push	ax
21020                                           ! Debug: list int = const $1A (used reg = )
21021 5B4D           B8                   001A  mov	ax,*$1A
21022 5B50           50                         push	ax
21023                                           ! Debug: func () void = _write_word+0 (used reg = )
21024 5B51           E8         AABF            call	__write_word
21025 5B54           83C4                   06  add	sp,*6
21026                                           !BCC_EOS
21027                                           ! 3781     blksize = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].blksize));
21028                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
21029 5B57           8A46         08            mov	al,8[bp]
21030 5B5A           30E4                       xor	ah,ah
21031 5B5C           B9                   001E  mov	cx,*$1E
21032 5B5F           F7E9                       imul	cx
21033 5B61           89C3                       mov	bx,ax
21034                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
21035                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$148 (used reg = )
21036                                           ! Debug: eq unsigned short = [bx+$148] to unsigned short blksize = [S+$1C-$1A] (used reg = )
21037 5B63           8B9F       0148            mov	bx,$148[bx]
21038 5B67           895E         E8            mov	-$18[bp],bx
21039                                           !BCC_EOS
21040                                           ! 3782     if (type == 0x02)
21041                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$1C-$17] (used reg = )
21042 5B6A           8A46         EB            mov	al,-$15[bp]
21043 5B6D           3C                     02  cmp	al,*2
21044 5B6F         0F85         00DB            bne 	.512
21045                       00005B73            .513:
21046                                           ! 3783     {
21047                                           ! 3784       npc = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders));
21048                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
21049 5B73           8A46         08            mov	al,8[bp]
21050 5B76           30E4                       xor	ah,ah
21051 5B78           B9                   001E  mov	cx,*$1E
21052 5B7B           F7E9                       imul	cx
21053 5B7D           89C3                       mov	bx,ax
21054                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
21055                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$154 (used reg = )
21056                                           ! Debug: eq unsigned short = [bx+$154] to unsigned short npc = [S+$1C-$C] (used reg = )
21057 5B7F           8B9F       0154            mov	bx,$154[bx]
21058 5B83           895E         F6            mov	-$A[bp],bx
21059                                           !BCC_EOS
21060                                           ! 3785       nph = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.heads));
21061                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
21062 5B86           8A46         08            mov	al,8[bp]
21063 5B89           30E4                       xor	ah,ah
21064 5B8B           B9                   001E  mov	cx,*$1E
21065 5B8E           F7E9                       imul	cx
21066 5B90           89C3                       mov	bx,ax
21067                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
21068                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$152 (used reg = )
21069                                           ! Debug: eq unsigned short = [bx+$152] to unsigned short nph = [S+$1C-$E] (used reg = )
21070 5B92           8B9F       0152            mov	bx,$152[bx]
21071 5B96           895E         F4            mov	-$C[bp],bx
21072                                           !BCC_EOS
21073                                           ! 3786       npspt = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.spt));
21074                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
21075 5B99           8A46         08            mov	al,8[bp]
21076 5B9C           30E4                       xor	ah,ah
21077 5B9E           B9                   001E  mov	cx,*$1E
21078 5BA1           F7E9                       imul	cx
21079 5BA3           89C3                       mov	bx,ax
21080                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
21081                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$156 (used reg = )
21082                                           ! Debug: eq unsigned short = [bx+$156] to unsigned short npspt = [S+$1C-$10] (used reg = )
21083 5BA5           8B9F       0156            mov	bx,$156[bx]
21084 5BA9           895E         F2            mov	-$E[bp],bx
21085                                           !BCC_EOS
21086                                           ! 3787       lba_low = *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_low));
21087                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
21088 5BAC           8A46         08            mov	al,8[bp]
21089 5BAF           30E4                       xor	ah,ah
21090 5BB1           B9                   001E  mov	cx,*$1E
21091 5BB4           F7E9                       imul	cx
21092 5BB6           89C3                       mov	bx,ax
21093                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
21094                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$158 (used reg = )
21095                                           ! Debug: eq unsigned long = [bx+$158] to unsigned long lba_low = [S+$1C-6] (used reg = )
21096 5BB8           8B87       0158            mov	ax,$158[bx]
21097 5BBC           8B9F       015A            mov	bx,$15A[bx]
21098 5BC0           8946         FC            mov	-4[bp],ax
21099 5BC3           895E         FE            mov	-2[bp],bx
21100                                           !BCC_EOS
21101                                           ! 3788       lba_high = *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high));
21102                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
21103 5BC6           8A46         08            mov	al,8[bp]
21104 5BC9           30E4                       xor	ah,ah
21105 5BCB           B9                   001E  mov	cx,*$1E
21106 5BCE           F7E9                       imul	cx
21107 5BD0           89C3                       mov	bx,ax
21108                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
21109                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
21110                                           ! Debug: eq unsigned long = [bx+$15C] to unsigned long lba_high = [S+$1C-$A] (used reg = )
21111 5BD2           8B87       015C            mov	ax,$15C[bx]
21112 5BD6           8B9F       015E            mov	bx,$15E[bx]
21113 5BDA           8946         F8            mov	-8[bp],ax
21114 5BDD           895E         FA            mov	-6[bp],bx
21115                                           !BCC_EOS
21116                                           ! 3789       if (lba_high || (lba_low/npspt)/nph > 0x3fff)
21117 5BE0           8B46         F8            mov	ax,-8[bp]
21118 5BE3           8B5E         FA            mov	bx,-6[bp]
21119 5BE6           E8         A4FC            call	ltstl
21120 5BE9           75           50            jne 	.515
21121                       00005BEB            .516:
21122                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$1C-$E] (used reg = )
21123 5BEB           8B46         F4            mov	ax,-$C[bp]
21124 5BEE           31DB                       xor	bx,bx
21125 5BF0           53                         push	bx
21126 5BF1           50                         push	ax
21127                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$20-$10] (used reg = )
21128 5BF2           8B46         F2            mov	ax,-$E[bp]
21129 5BF5           31DB                       xor	bx,bx
21130                                           ! Debug: div unsigned long = bx+0 to unsigned long lba_low = [S+$20-6] (used reg = )
21131 5BF7           53                         push	bx
21132 5BF8           50                         push	ax
21133 5BF9           8B46         FC            mov	ax,-4[bp]
21134 5BFC           8B5E         FE            mov	bx,-2[bp]
21135 5BFF           8D7E         DE            lea	di,-$22[bp]
21136 5C02           E8         A53A            call	ldivul
21137 5C05           83C4                   04  add	sp,*4
21138                                           ! Debug: div unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
21139 5C08           8D7E         E2            lea	di,-$1E[bp]
21140 5C0B           E8         A531            call	ldivul
21141 5C0E           83C4                   04  add	sp,*4
21142                                           ! Debug: gt unsigned long = const $3FFF to unsigned long = bx+0 (used reg = )
21143 5C11           53                         push	bx
21144 5C12           50                         push	ax
21145 5C13           B8                   3FFF  mov	ax,#$3FFF
21146 5C16           31DB                       xor	bx,bx
21147 5C18           53                         push	bx
21148 5C19           50                         push	ax
21149 5C1A           8B46         E2            mov	ax,-$1E[bp]
21150 5C1D           8B5E         E4            mov	bx,-$1C[bp]
21151 5C20           8D7E         DE            lea	di,-$22[bp]
21152 5C23           E8         A476            call	lcmpul
21153 5C26           76           04            jbe	.517
21154 5C28           B0                     01  mov	al,*1
21155 5C2A           EB           02            jmp	.518
21156                       00005C2C            .517:
21157 5C2C           30C0                       xor	al,al
21158                       00005C2E            .518:
21159 5C2E           83C4                   08  add	sp,*8
21160                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
21161 5C31           30E4                       xor	ah,ah
21162 5C33           99                         cwd
21163 5C34           89D3                       mov	bx,dx
21164 5C36           E8         A4AC            call	ltstl
21165 5C39           74           0D            je  	.514
21166                       00005C3B            .515:
21167                                           ! 3790       {
21168                                           ! 3791         infos = 0 << 1;
21169                                           ! Debug: eq int = const 0 to unsigned short infos = [S+$1C-$1C] (used reg = )
21170 5C3B           31C0                       xor	ax,ax
21171 5C3D           8946         E6            mov	-$1A[bp],ax
21172                                           !BCC_EOS
21173                                           ! 3792         npc = 0x3fff;
21174                                           ! Debug: eq int = const $3FFF to unsigned short npc = [S+$1C-$C] (used reg = )
21175 5C40           B8                   3FFF  mov	ax,#$3FFF
21176 5C43           8946         F6            mov	-$A[bp],ax
21177                                           !BCC_EOS
21178                                           ! 3793       }
21179                                           ! 3794       else
21180                                           ! 3795       {
21181 5C46           EB           06            jmp .51A
21182                       00005C48            .514:
21183                                           ! 3796         infos = 1 << 1;
21184                                           ! Debug: eq int = const 2 to unsigned short infos = [S+$1C-$1C] (used reg = )
21185 5C48           B8                   0002  mov	ax,*2
21186 5C4B           8946         E6            mov	-$1A[bp],ax
21187                                           !BCC_EOS
21188                                           ! 3797       }
21189                                           ! 3798     }
21190                       00005C4E            .51A:
21191                                           ! 3799     if (type == 0x03)
21192                       00005C4E            .512:
21193                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$1C-$17] (used reg = )
21194 5C4E           8A46         EB            mov	al,-$15[bp]
21195 5C51           3C                     03  cmp	al,*3
21196 5C53           75           30            jne 	.51B
21197                       00005C55            .51C:
21198                                           ! 3800     {
21199                                           ! 3801       npc = 0xffffffff;
21200                                           ! Debug: eq unsigned long = const $FFFFFFFF to unsigned short npc = [S+$1C-$C] (used reg = )
21201 5C55           B8                   FFFF  mov	ax,#$FFFF
21202 5C58           8946         F6            mov	-$A[bp],ax
21203                                           !BCC_EOS
21204                                           ! 3802       nph = 0xffffffff;
21205                                           ! Debug: eq unsigned long = const $FFFFFFFF to unsigned short nph = [S+$1C-$E] (used reg = )
21206 5C5B           B8                   FFFF  mov	ax,#$FFFF
21207 5C5E           8946         F4            mov	-$C[bp],ax
21208                                           !BCC_EOS
21209                                           ! 3803       npspt = 0xffffffff;
21210                                           ! Debug: eq unsigned long = const $FFFFFFFF to unsigned short npspt = [S+$1C-$10] (used reg = )
21211 5C61           B8                   FFFF  mov	ax,#$FFFF
21212 5C64           8946         F2            mov	-$E[bp],ax
21213                                           !BCC_EOS
21214                                           ! 3804       lba_low = 0xffffffff;
21215                                           ! Debug: eq unsigned long = const $FFFFFFFF to unsigned long lba_low = [S+$1C-6] (used reg = )
21216 5C67           B8                   FFFF  mov	ax,#$FFFF
21217 5C6A           BB                   FFFF  mov	bx,#$FFFF
21218 5C6D           8946         FC            mov	-4[bp],ax
21219 5C70           895E         FE            mov	-2[bp],bx
21220                                           !BCC_EOS
21221                                           ! 3805       lba_high = 0xffffffff;
21222                                           ! Debug: eq unsigned long = const $FFFFFFFF to unsigned long lba_high = [S+$1C-$A] (used reg = )
21223 5C73           B8                   FFFF  mov	ax,#$FFFF
21224 5C76           BB                   FFFF  mov	bx,#$FFFF
21225 5C79           8946         F8            mov	-8[bp],ax
21226 5C7C           895E         FA            mov	-6[bp],bx
21227                                           !BCC_EOS
21228                                           ! 3806       infos = 1 << 2 | 1 << 4 |
21229                                           ! 3807                1 << 5 | 1 << 6;
21230                                           ! Debug: eq int = const $74 to unsigned short infos = [S+$1C-$1C] (used reg = )
21231 5C7F           B8                   0074  mov	ax,*$74
21232 5C82           8946         E6            mov	-$1A[bp],ax
21233                                           !BCC_EOS
21234                                           ! 3808     }
21235                                           ! 3809     _write_word(infos, SI+(Bit16u)&((dpt_t *) 0)->infos, DS);
21236                       00005C85            .51B:
21237                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21238 5C85           FF76         04            push	4[bp]
21239                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$1E+4] (used reg = )
21240 5C88           8B46         06            mov	ax,6[bp]
21241                                           ! Debug: list unsigned int = ax+2 (used reg = )
21242 5C8B           40                         inc	ax
21243 5C8C           40                         inc	ax
21244 5C8D           50                         push	ax
21245                                           ! Debug: list unsigned short infos = [S+$20-$1C] (used reg = )
21246 5C8E           FF76         E6            push	-$1A[bp]
21247                                           ! Debug: func () void = _write_word+0 (used reg = )
21248 5C91           E8         A97F            call	__write_word
21249 5C94           83C4                   06  add	sp,*6
21250                                           !BCC_EOS
21251                                           ! 3810     _write_dword((Bit32u)npc, SI+(Bit16u)&((dpt_t *) 0)->cylinders, DS);
21252                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21253 5C97           FF76         04            push	4[bp]
21254                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$1E+4] (used reg = )
21255 5C9A           8B46         06            mov	ax,6[bp]
21256                                           ! Debug: list unsigned int = ax+4 (used reg = )
21257 5C9D           05                   0004  add	ax,*4
21258 5CA0           50                         push	ax
21259                                           ! Debug: cast unsigned long = const 0 to unsigned short npc = [S+$20-$C] (used reg = )
21260 5CA1           8B46         F6            mov	ax,-$A[bp]
21261 5CA4           31DB                       xor	bx,bx
21262                                           ! Debug: list unsigned long = bx+0 (used reg = )
21263 5CA6           53                         push	bx
21264 5CA7           50                         push	ax
21265                                           ! Debug: func () void = _write_dword+0 (used reg = )
21266 5CA8           E8         A3BC            call	__write_dword
21267 5CAB           83C4                   08  add	sp,*8
21268                                           !BCC_EOS
21269                                           ! 3811     _write_dword((Bit32u)nph, SI+(Bit16u)&((dpt_t *) 0)->heads, DS);
21270                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21271 5CAE           FF76         04            push	4[bp]
21272                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$1E+4] (used reg = )
21273 5CB1           8B46         06            mov	ax,6[bp]
21274                                           ! Debug: list unsigned int = ax+8 (used reg = )
21275 5CB4           05                   0008  add	ax,*8
21276 5CB7           50                         push	ax
21277                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$20-$E] (used reg = )
21278 5CB8           8B46         F4            mov	ax,-$C[bp]
21279 5CBB           31DB                       xor	bx,bx
21280                                           ! Debug: list unsigned long = bx+0 (used reg = )
21281 5CBD           53                         push	bx
21282 5CBE           50                         push	ax
21283                                           ! Debug: func () void = _write_dword+0 (used reg = )
21284 5CBF           E8         A3A5            call	__write_dword
21285 5CC2           83C4                   08  add	sp,*8
21286                                           !BCC_EOS
21287                                           ! 3812     _write_dword((Bit32u)npspt, SI+(Bit16u)&((dpt_t *) 0)->spt, DS);
21288                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21289 5CC5           FF76         04            push	4[bp]
21290                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$1E+4] (used reg = )
21291 5CC8           8B46         06            mov	ax,6[bp]
21292                                           ! Debug: list unsigned int = ax+$C (used reg = )
21293 5CCB           05                   000C  add	ax,*$C
21294 5CCE           50                         push	ax
21295                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$20-$10] (used reg = )
21296 5CCF           8B46         F2            mov	ax,-$E[bp]
21297 5CD2           31DB                       xor	bx,bx
21298                                           ! Debug: list unsigned long = bx+0 (used reg = )
21299 5CD4           53                         push	bx
21300 5CD5           50                         push	ax
21301                                           ! Debug: func () void = _write_dword+0 (used reg = )
21302 5CD6           E8         A38E            call	__write_dword
21303 5CD9           83C4                   08  add	sp,*8
21304                                           !BCC_EOS
21305                                           ! 3813     _write_dword(lba_low, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, DS);
21306                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21307 5CDC           FF76         04            push	4[bp]
21308                                           ! Debug: add unsigned short = const $10 to unsigned short SI = [S+$1E+4] (used reg = )
21309 5CDF           8B46         06            mov	ax,6[bp]
21310                                           ! Debug: list unsigned int = ax+$10 (used reg = )
21311 5CE2           05                   0010  add	ax,*$10
21312 5CE5           50                         push	ax
21313                                           ! Debug: list unsigned long lba_low = [S+$20-6] (used reg = )
21314 5CE6           FF76         FE            push	-2[bp]
21315 5CE9           FF76         FC            push	-4[bp]
21316                                           ! Debug: func () void = _write_dword+0 (used reg = )
21317 5CEC           E8         A378            call	__write_dword
21318 5CEF           83C4                   08  add	sp,*8
21319                                           !BCC_EOS
21320                                           ! 3814     _write_dword(lba_high, SI+(Bit16u)&((dpt_t
21321                                           ! 3814  *) 0)->sector_count2, DS);
21322                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21323 5CF2           FF76         04            push	4[bp]
21324                                           ! Debug: add unsigned short = const $14 to unsigned short SI = [S+$1E+4] (used reg = )
21325 5CF5           8B46         06            mov	ax,6[bp]
21326                                           ! Debug: list unsigned int = ax+$14 (used reg = )
21327 5CF8           05                   0014  add	ax,*$14
21328 5CFB           50                         push	ax
21329                                           ! Debug: list unsigned long lba_high = [S+$20-$A] (used reg = )
21330 5CFC           FF76         FA            push	-6[bp]
21331 5CFF           FF76         F8            push	-8[bp]
21332                                           ! Debug: func () void = _write_dword+0 (used reg = )
21333 5D02           E8         A362            call	__write_dword
21334 5D05           83C4                   08  add	sp,*8
21335                                           !BCC_EOS
21336                                           ! 3815     _write_word(blksize, SI+(Bit16u)&((dpt_t *) 0)->blksize, DS);
21337                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21338 5D08           FF76         04            push	4[bp]
21339                                           ! Debug: add unsigned short = const $18 to unsigned short SI = [S+$1E+4] (used reg = )
21340 5D0B           8B46         06            mov	ax,6[bp]
21341                                           ! Debug: list unsigned int = ax+$18 (used reg = )
21342 5D0E           05                   0018  add	ax,*$18
21343 5D11           50                         push	ax
21344                                           ! Debug: list unsigned short blksize = [S+$20-$1A] (used reg = )
21345 5D12           FF76         E8            push	-$18[bp]
21346                                           ! Debug: func () void = _write_word+0 (used reg = )
21347 5D15           E8         A8FB            call	__write_word
21348 5D18           83C4                   06  add	sp,*6
21349                                           !BCC_EOS
21350                                           ! 3816   }
21351 5D1B           83C4                   04  add	sp,*4
21352                                           ! 3817   if(size >= 30) {
21353                       00005D1E            .510:
21354                                           ! Debug: ge int = const $1E to unsigned short size = [S+$18-$12] (used reg = )
21355 5D1E           8B46         F0            mov	ax,-$10[bp]
21356 5D21           3D                   001E  cmp	ax,*$1E
21357 5D24         0F82         01BC            blo 	.51D
21358                       00005D28            .51E:
21359                                           ! 3818     Bit8u channel, dev, irq, mode, checksum, i, translation;
21360                                           !BCC_EOS
21361                                           ! 3819     Bit16u iobase1, iobase2, options;
21362                                           !BCC_EOS
21363                                           ! 3820     _write_word(30, SI+(Bit16u)&((dpt_t *) 0)->size, DS);
21364 5D28           83C4                   F2  add	sp,*-$E
21365                                           ! Debug: list unsigned short DS = [S+$26+2] (used reg = )
21366 5D2B           FF76         04            push	4[bp]
21367                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$28+4] (used reg = )
21368 5D2E           8B46         06            mov	ax,6[bp]
21369                                           ! Debug: list unsigned int = ax+0 (used reg = )
21370 5D31           50                         push	ax
21371                                           ! Debug: list int = const $1E (used reg = )
21372 5D32           B8                   001E  mov	ax,*$1E
21373 5D35           50                         push	ax
21374                                           ! Debug: func () void = _write_word+0 (used reg = )
21375 5D36           E8         A8DA            call	__write_word
21376 5D39           83C4                   06  add	sp,*6
21377                                           !BCC_EOS
21378                                           ! 3821     _write_word(ebda_seg, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, DS);
21379                                           ! Debug: list unsigned short DS = [S+$26+2] (used reg = )
21380 5D3C           FF76         04            push	4[bp]
21381                                           ! Debug: add unsigned short = const $1C to unsigned short SI = [S+$28+4] (used reg = )
21382 5D3F           8B46         06            mov	ax,6[bp]
21383                                           ! Debug: list unsigned int = ax+$1C (used reg = )
21384 5D42           05                   001C  add	ax,*$1C
21385 5D45           50                         push	ax
21386                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$16] (used reg = )
21387 5D46           FF76         EC            push	-$14[bp]
21388                                           ! Debug: func () void = _write_word+0 (used reg = )
21389 5D49           E8         A8C7            call	__write_word
21390 5D4C           83C4                   06  add	sp,*6
21391                                           !BCC_EOS
21392                                           ! 3822     _write_word(&((ebda_data_t *) 0)->ata.dpte, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, DS);
21393                                           ! Debug: list unsigned short DS = [S+$26+2] (used reg = )
21394 5D4F           FF76         04            push	4[bp]
21395                                           ! Debug: add unsigned short = const $1A to unsigned short SI = [S+$28+4] (used reg = )
21396 5D52           8B46         06            mov	ax,6[bp]
21397                                           ! Debug: list unsigned int = ax+$1A (used reg = )
21398 5D55           05                   001A  add	ax,*$1A
21399 5D58           50                         push	ax
21400                                           ! Debug: list * struct  = const $244 (used reg = )
21401 5D59           B8                   0244  mov	ax,#$244
21402 5D5C           50                         push	ax
21403                                           ! Debug: func () void = _write_word+0 (used reg = )
21404 5D5D           E8         A8B3            call	__write_word
21405 5D60           83C4                   06  add	sp,*6
21406                                           !BCC_EOS
21407                                           ! 3823     channel = device / 2;
21408                                           ! Debug: div int = const 2 to unsigned char device = [S+$26+6] (used reg = )
21409 5D63           8A46         08            mov	al,8[bp]
21410 5D66           30E4                       xor	ah,ah
21411 5D68           D1E8                       shr	ax,*1
21412                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$26-$19] (used reg = )
21413 5D6A           8846         E9            mov	-$17[bp],al
21414                                           !BCC_EOS
21415                                           ! 3824     iobase1 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1));
21416                                           ! Debug: ptradd unsigned char channel = [S+$26-$19] to [4] struct  = const $122 (used reg = )
21417 5D6D           8A46         E9            mov	al,-$17[bp]
21418 5D70           30E4                       xor	ah,ah
21419 5D72           B1                     03  mov	cl,*3
21420 5D74           D3E0                       shl	ax,cl
21421 5D76           89C3                       mov	bx,ax
21422                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
21423                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
21424                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$26-$22] (used reg = )
21425 5D78           8B9F       0124            mov	bx,$124[bx]
21426 5D7C           895E         E0            mov	-$20[bp],bx
21427                                           !BCC_EOS
21428                                           ! 3825     iobase2 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2));
21429                                           ! Debug: ptradd unsigned char channel = [S+$26-$19] to [4] struct  = const $122 (used reg = )
21430 5D7F           8A46         E9            mov	al,-$17[bp]
21431 5D82           30E4                       xor	ah,ah
21432 5D84           B1                     03  mov	cl,*3
21433 5D86           D3E0                       shl	ax,cl
21434 5D88           89C3                       mov	bx,ax
21435                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
21436                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
21437                                           ! Debug: eq unsigned short = [bx+$126] to unsigned short iobase2 = [S+$26-$24] (used reg = )
21438 5D8A           8B9F       0126            mov	bx,$126[bx]
21439 5D8E           895E         DE            mov	-$22[bp],bx
21440                                           !BCC_EOS
21441                                           ! 3826     irq = *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[channel].irq));
21442                                           ! Debug: ptradd unsigned char channel = [S+$26-$19] to [4] struct  = const $122 (used reg = )
21443 5D91           8A46         E9            mov	al,-$17[bp]
21444 5D94           30E4                       xor	ah,ah
21445 5D96           B1                     03  mov	cl,*3
21446 5D98           D3E0                       shl	ax,cl
21447 5D9A           89C3                       mov	bx,ax
21448                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
21449                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$128 (used reg = )
21450                                           ! Debug: eq unsigned char = [bx+$128] to unsigned char irq = [S+$26-$1B] (used reg = )
21451 5D9C           8A87       0128            mov	al,$128[bx]
21452 5DA0           8846         E7            mov	-$19[bp],al
21453                                           !BCC_EOS
21454                                           ! 3827     mode = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode));
21455                                           ! Debug: ptradd unsigned char device = [S+$26+6] to [8] struct  = const $142 (used reg = )
21456 5DA3           8A46         08            mov	al,8[bp]
21457 5DA6           30E4                       xor	ah,ah
21458 5DA8           B9                   001E  mov	cx,*$1E
21459 5DAB           F7E9                       imul	cx
21460 5DAD           89C3                       mov	bx,ax
21461                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
21462                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
21463                                           ! Debug: eq unsigned char = [bx+$146] to unsigned char mode = [S+$26-$1C] (used reg = )
21464 5DAF           8A87       0146            mov	al,$146[bx]
21465 5DB3           8846         E6            mov	-$1A[bp],al
21466                                           !BCC_EOS
21467                                           ! 3828     translation = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].translation));
21468                                           ! Debug: ptradd unsigned char device = [S+$26+6] to [8] struct  = const $142 (used reg = )
21469 5DB6           8A46         08            mov	al,8[bp]
21470 5DB9           30E4                       xor	ah,ah
21471 5DBB           B9                   001E  mov	cx,*$1E
21472 5DBE           F7E9                       imul	cx
21473 5DC0           89C3                       mov	bx,ax
21474                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
21475                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$14A (used reg = )
21476                                           ! Debug: eq unsigned char = [bx+$14A] to unsigned char translation = [S+$26-$1F] (used reg = )
21477 5DC2           8A87       014A            mov	al,$14A[bx]
21478 5DC6           8846         E3            mov	-$1D[bp],al
21479                                           !BCC_EOS
21480                                           ! 3829     options = (1<<4);
21481                                           ! Debug: eq int = const $10 to unsigned short options = [S+$26-$26] (used reg = )
21482 5DC9           B8                   0010  mov	ax,*$10
21483 5DCC           8946         DC            mov	-$24[bp],ax
21484                                           !BCC_EOS
21485                                           ! 3830     options |= (mode==0x01?1:0)<<7;
21486                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$26-$1C] (used reg = )
21487 5DCF           8A46         E6            mov	al,-$1A[bp]
21488 5DD2           3C                     01  cmp	al,*1
21489 5DD4           75           04            jne 	.51F
21490                       00005DD6            .520:
21491 5DD6           B0                     01  mov	al,*1
21492 5DD8           EB           02            jmp .521
21493                       00005DDA            .51F:
21494 5DDA           30C0                       xor	al,al
21495                       00005DDC            .521:
21496                                           ! Debug: sl int = const 7 to char = al+0 (used reg = )
21497 5DDC           30E4                       xor	ah,ah
21498 5DDE           B1                     07  mov	cl,*7
21499 5DE0           D3E0                       shl	ax,cl
21500                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$26-$26] (used reg = )
21501 5DE2           0B46         DC            or	ax,-$24[bp]
21502 5DE5           8946         DC            mov	-$24[bp],ax
21503                                           !BCC_EOS
21504                                           ! 3831     if (type == 0x02)
21505                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$26-$17] (used reg = )
21506 5DE8           8A46         EB            mov	al,-$15[bp]
21507 5DEB           3C                     02  cmp	al,*2
21508 5DED           75           4F            jne 	.522
21509                       00005DEF            .523:
21510                                           ! 3832     {
21511                                           ! 3833       options |= (translation==0?0:1)<<3;
21512                                           ! Debug: logeq int = const 0 to unsigned char translation = [S+$26-$1F] (used reg = )
21513 5DEF           8A46         E3            mov	al,-$1D[bp]
21514 5DF2           84C0                       test	al,al
21515 5DF4           75           04            jne 	.524
21516                       00005DF6            .525:
21517 5DF6           30C0                       xor	al,al
21518 5DF8           EB           02            jmp .526
21519                       00005DFA            .524:
21520 5DFA           B0                     01  mov	al,*1
21521                       00005DFC            .526:
21522                                           ! Debug: sl int = const 3 to char = al+0 (used reg = )
21523 5DFC           30E4                       xor	ah,ah
21524 5DFE           B1                     03  mov	cl,*3
21525 5E00           D3E0                       shl	ax,cl
21526                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$26-$26] (used reg = )
21527 5E02           0B46         DC            or	ax,-$24[bp]
21528 5E05           8946         DC            mov	-$24[bp],ax
21529                                           !BCC_EOS
21530                                           ! 3834       options |= (translation==1?1:0)<<9;
21531                                           ! Debug: logeq int = const 1 to unsigned char translation = [S+$26-$1F] (used reg = )
21532 5E08           8A46         E3            mov	al,-$1D[bp]
21533 5E0B           3C                     01  cmp	al,*1
21534 5E0D           75           04            jne 	.527
21535                       00005E0F            .528:
21536 5E0F           B0                     01  mov	al,*1
21537 5E11           EB           02            jmp .529
21538                       00005E13            .527:
21539 5E13           30C0                       xor	al,al
21540                       00005E15            .529:
21541                                           ! Debug: sl int = const 9 to char = al+0 (used reg = )
21542 5E15           30E4                       xor	ah,ah
21543 5E17           88C4                       mov	ah,al
21544 5E19           30C0                       xor	al,al
21545 5E1B           D1E0                       shl	ax,*1
21546                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$26-$26] (used reg = )
21547 5E1D           0B46         DC            or	ax,-$24[bp]
21548 5E20           8946         DC            mov	-$24[bp],ax
21549                                           !BCC_EOS
21550                                           ! 3835       options |= (translation==3?3:0)<<9;
21551                                           ! Debug: logeq int = const 3 to unsigned char translation = [S+$26-$1F] (used reg = )
21552 5E23           8A46         E3            mov	al,-$1D[bp]
21553 5E26           3C                     03  cmp	al,*3
21554 5E28           75           04            jne 	.52A
21555                       00005E2A            .52B:
21556 5E2A           B0                     03  mov	al,*3
21557 5E2C           EB           02            jmp .52C
21558                       00005E2E            .52A:
21559 5E2E           30C0                       xor	al,al
21560                       00005E30            .52C:
21561                                           ! Debug: sl int = const 9 to char = al+0 (used reg = )
21562 5E30           30E4                       xor	ah,ah
21563 5E32           88C4                       mov	ah,al
21564 5E34           30C0                       xor	al,al
21565 5E36           D1E0                       shl	ax,*1
21566                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$26-$26] (used reg = )
21567 5E38           0B46         DC            or	ax,-$24[bp]
21568 5E3B           8946         DC            mov	-$24[bp],ax
21569                                           !BCC_EOS
21570                                           ! 3836     }
21571                                           ! 3837     if (type == 0x03)
21572                       00005E3E            .522:
21573                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$26-$17] (used reg = )
21574 5E3E           8A46         EB            mov	al,-$15[bp]
21575 5E41           3C                     03  cmp	al,*3
21576 5E43           75           10            jne 	.52D
21577                       00005E45            .52E:
21578                                           ! 3838     {
21579                                           ! 3839       options |= (1<<5);
21580                                           ! Debug: orab int = const $20 to unsigned short options = [S+$26-$26] (used reg = )
21581 5E45           8B46         DC            mov	ax,-$24[bp]
21582 5E48           0C                     20  or	al,*$20
21583 5E4A           8946         DC            mov	-$24[bp],ax
21584                                           !BCC_EOS
21585                                           ! 3840       options |= (1<<6);
21586                                           ! Debug: orab int = const $40 to unsigned short options = [S+$26-$26] (used reg = )
21587 5E4D           8B46         DC            mov	ax,-$24[bp]
21588 5E50           0C                     40  or	al,*$40
21589 5E52           8946         DC            mov	-$24[bp],ax
21590                                           !BCC_EOS
21591                                           ! 3841     }
21592                                           ! 3842     *((Bit16u *)(&((ebda_data_t *) 0)->ata.dpte.iobase1)) = (iobase1);
21593                       00005E55            .52D:
21594                                           ! Debug: eq unsigned short iobase1 = [S+$26-$22] to unsigned short = [+$244] (used reg = )
21595 5E55           8B46         E0            mov	ax,-$20[bp]
21596 5E58           A3         0244            mov	[$244],ax
21597                                           !BCC_EOS
21598                                           ! 3843     *((Bit16u *)(&((ebda_data_t *) 0)->ata.dpte.iobase2)) = (iobase2 + 6);
21599                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$26-$24] (used reg = )
21600 5E5B           8B46         DE            mov	ax,-$22[bp]
21601                                           ! Debug: eq unsigned int = ax+6 to unsigned short = [+$246] (used reg = )
21602 5E5E           05                   0006  add	ax,*6
21603 5E61           A3         0246            mov	[$246],ax
21604                                           !BCC_EOS
21605                                           ! 3844     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.prefix)) = ((0xe | (device % 2))<<4);
21606                                           ! Debug: mod int = const 2 to unsigned char device = [S+$26+6] (used reg = )
21607 5E64           8A46         08            mov	al,8[bp]
21608 5E67           30E4                       xor	ah,ah
21609 5E69           24                     01  and	al,*1
21610                                           ! Debug: or unsigned char = al+0 to int = const $E (used reg = )
21611                                           ! Debug: expression subtree swapping
21612 5E6B           0C                     0E  or	al,*$E
21613                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
21614 5E6D           30E4                       xor	ah,ah
21615 5E6F           B1                     04  mov	cl,*4
21616 5E71           D3E0                       shl	ax,cl
21617                                           ! Debug: eq unsigned int = ax+0 to unsigned char = [+$248] (used reg = )
21618 5E73           A2         0248            mov	[$248],al
21619                                           !BCC_EOS
21620                                           ! 3845     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.unused)) = (0xcb);
21621                                           ! Debug: eq int = const $CB to unsigned char = [+$249] (used reg = )
21622 5E76           B0                     CB  mov	al,#$CB
21623 5E78           A2         0249            mov	[$249],al
21624                                           !BCC_EOS
21625                                           ! 3846     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.irq)) = (irq);
21626                                           ! Debug: eq unsigned char irq = [S+$26-$1B] to unsigned char = [+$24A] (used reg = )
21627 5E7B           8A46         E7            mov	al,-$19[bp]
21628 5E7E           A2         024A            mov	[$24A],al
21629                                           !BCC_EOS
21630                                           ! 3847     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.blkcount)) = (1);
21631                                           ! Debug: eq int = const 1 to unsigned char = [+$24B] (used reg = )
21632 5E81           B0                     01  mov	al,*1
21633 5E83           A2         024B            mov	[$24B],al
21634                                           !BCC_EOS
21635                                           ! 3848     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.dma)) = (0);
21636                                           ! Debug: eq int = const 0 to unsigned char = [+$24C] (used reg = )
21637 5E86           30C0                       xor	al,al
21638 5E88           A2         024C            mov	[$24C],al
21639                                           !BCC_EOS
21640                                           ! 3849     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.pio)) = (0);
21641                                           ! Debug: eq int = const 0 to unsigned char = [+$24D] (used reg = )
21642 5E8B           30C0                       xor	al,al
21643 5E8D           A2         024D            mov	[$24D],al
21644                                           !BCC_EOS
21645                                           ! 3850     *((Bit16u *)(&((ebda_data_t *) 0)->ata.dpte.options)) = (options);
21646                                           ! Debug: eq unsigned short options = [S+$26-$26] to unsigned short = [+$24E] (used reg = )
21647 5E90           8B46         DC            mov	ax,-$24[bp]
21648 5E93           A3         024E            mov	[$24E],ax
21649                                           !BCC_EOS
21650                                           ! 3851     *((Bit16u *)(&((ebda_data_t *) 0)->ata.dpte.reserved)) = (0);
21651                                           ! Debug: eq int = const 0 to unsigned short = [+$250] (used reg = )
21652 5E96           31C0                       xor	ax,ax
21653 5E98           A3         0250            mov	[$250],ax
21654                                           !BCC_EOS
21655                                           ! 3852     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.revision)) = (0x11);
21656                                           ! Debug: eq int = const $11 to unsigned char = [+$252] (used reg = )
21657 5E9B           B0                     11  mov	al,*$11
21658 5E9D           A2         0252            mov	[$252],al
21659                                           !BCC_EOS
21660                                           ! 3853     checksum=0;
21661                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$26-$1D] (used reg = )
21662 5EA0           30C0                       xor	al,al
21663 5EA2           8846         E5            mov	-$1B[bp],al
21664                                           !BCC_EOS
21665                                           ! 3854     for (i=0; i<15; i++) checksum+=*((Bit8u *)(((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i));
21666                                           ! Debug: eq int = const 0 to unsigned char i = [S+$26-$1E] (used reg = )
21667 5EA5           30C0                       xor	al,al
21668 5EA7           8846         E4            mov	-$1C[bp],al
21669                                           !BCC_EOS
21670                                           !BCC_EOS
21671 5EAA           EB           1D            jmp .531
21672                       00005EAC            .532:
21673                                           ! Debug: ptradd unsigned char i = [S+$26-$1E] to * unsigned char = const $244 (used reg = )
21674 5EAC           8A46         E4            mov	al,-$1C[bp]
21675 5EAF           30E4                       xor	ah,ah
21676                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = ax+$244 (used reg = )
21677 5EB1           89C3                       mov	bx,ax
21678                                           ! Debug: addab unsigned char = [bx+$244] to unsigned char checksum = [S+$26-$1D] (used reg = )
21679 5EB3           8A46         E5            mov	al,-$1B[bp]
21680 5EB6           30E4                       xor	ah,ah
21681 5EB8           0287       0244            add	al,$244[bx]
21682 5EBC           80D4                   00  adc	ah,*0
21683 5EBF           8846         E5            mov	-$1B[bp],al
21684                                           !BCC_EOS
21685                                           ! 3855     checksum = -checks
21686                       00005EC2            .530:
21687                                           ! Debug: postinc unsigned char i = [S+$26-$1E] (used reg = )
21688 5EC2           8A46         E4            mov	al,-$1C[bp]
21689 5EC5           40                         inc	ax
21690 5EC6           8846         E4            mov	-$1C[bp],al
21691                       00005EC9            .531:
21692                                           ! Debug: lt int = const $F to unsigned char i = [S+$26-$1E] (used reg = )
21693 5EC9           8A46         E4            mov	al,-$1C[bp]
21694 5ECC           3C                     0F  cmp	al,*$F
21695 5ECE           72           DC            jb 	.532
21696                       00005ED0            .533:
21697                       00005ED0            .52F:
21698                                           ! 3855 um;
21699                                           ! Debug: neg unsigned char checksum = [S+$26-$1D] (used reg = )
21700 5ED0           31C0                       xor	ax,ax
21701 5ED2           2A46         E5            sub	al,-$1B[bp]
21702 5ED5           80DC                   00  sbb	ah,*0
21703                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$26-$1D] (used reg = )
21704 5ED8           8846         E5            mov	-$1B[bp],al
21705                                           !BCC_EOS
21706                                           ! 3856     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.checksum)) = (checksum);
21707                                           ! Debug: eq unsigned char checksum = [S+$26-$1D] to unsigned char = [+$253] (used reg = )
21708 5EDB           8A46         E5            mov	al,-$1B[bp]
21709 5EDE           A2         0253            mov	[$253],al
21710                                           !BCC_EOS
21711                                           ! 3857   }
21712 5EE1           83C4                   0E  add	sp,*$E
21713                                           ! 3858   if(size >= 66) {
21714                       00005EE4            .51D:
21715                                           ! Debug: ge int = const $42 to unsigned short size = [S+$18-$12] (used reg = )
21716 5EE4           8B46         F0            mov	ax,-$10[bp]
21717 5EE7           3D                   0042  cmp	ax,*$42
21718 5EEA         0F82         0267            blo 	.534
21719                       00005EEE            .535:
21720                                           ! 3859     Bit8u channel, iface, checksum, i;
21721                                           !BCC_EOS
21722                                           ! 3860     Bit16u iobase1;
21723                                           !BCC_EOS
21724                                           ! 3861     channel = device / 2;
21725 5EEE           83C4                   FA  add	sp,*-6
21726                                           ! Debug: div int = const 2 to unsigned char device = [S+$1E+6] (used reg = )
21727 5EF1           8A46         08            mov	al,8[bp]
21728 5EF4           30E4                       xor	ah,ah
21729 5EF6           D1E8                       shr	ax,*1
21730                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$1E-$19] (used reg = )
21731 5EF8           8846         E9            mov	-$17[bp],al
21732                                           !BCC_EOS
21733                                           ! 3862     iface = *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[channel].iface));
21734                                           ! Debug: ptradd unsigned char channel = [S+$1E-$19] to [4] struct  = const $122 (used reg = )
21735 5EFB           8A46         E9            mov	al,-$17[bp]
21736 5EFE           30E4                       xor	ah,ah
21737 5F00           B1                     03  mov	cl,*3
21738 5F02           D3E0                       shl	ax,cl
21739 5F04           89C3                       mov	bx,ax
21740                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
21741                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$122 (used reg = )
21742                                           ! Debug: eq unsigned char = [bx+$122] to unsigned char iface = [S+$1E-$1A] (used reg = )
21743 5F06           8A87       0122            mov	al,$122[bx]
21744 5F0A           8846         E8            mov	-$18[bp],al
21745                                           !BCC_EOS
21746                                           ! 3863     iobase1 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1));
21747                                           ! Debug: ptradd unsigned char channel = [S+$1E-$19] to [4] struct  = const $122 (used reg = )
21748 5F0D           8A46         E9            mov	al,-$17[bp]
21749 5F10           30E4                       xor	ah,ah
21750 5F12           B1                     03  mov	cl,*3
21751 5F14           D3E0                       shl	ax,cl
21752 5F16           89C3                       mov	bx,ax
21753                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
21754                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
21755                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$1E-$1E] (used reg = )
21756 5F18           8B9F       0124            mov	bx,$124[bx]
21757 5F1C           895E         E4            mov	-$1C[bp],bx
21758                                           !BCC_EOS
21759                                           ! 3864     set_DS(DS);
21760                                           ! Debug: list unsigned short DS = [S+$1E+2] (used reg = )
21761 5F1F           FF76         04            push	4[bp]
21762                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
21763 5F22           E8         A73D            call	_set_DS
21764 5F25           44                         inc	sp
21765 5F26           44                         inc	sp
21766                                           !BCC_EOS
21767                                           ! 3865     *((Bit16u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.key)) = (0xbedd);
21768                                           ! Debug: add unsigned short = const $1E to unsigned short SI = [S+$1E+4] (used reg = )
21769 5F27           8B46         06            mov	ax,6[bp]
21770                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$1E (used reg = )
21771 5F2A           89C3                       mov	bx,ax
21772                                           ! Debug: eq unsigned int = const $BEDD to unsigned short = [bx+$1E] (used reg = )
21773 5F2C           B8                   BEDD  mov	ax,#$BEDD
21774 5F2F           8947         1E            mov	$1E[bx],ax
21775                                           !BCC_EOS
21776                                           ! 3866     *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.dpi_length)) = (t13 ? 44 : 36);
21777 5F32           8B46         EE            mov	ax,-$12[bp]
21778 5F35           85C0                       test	ax,ax
21779 5F37           74           04            je  	.536
21780                       00005F39            .537:
21781 5F39           B0                     2C  mov	al,*$2C
21782 5F3B           EB           02            jmp .538
21783                       00005F3D            .536:
21784 5F3D           B0                     24  mov	al,*$24
21785                       00005F3F            .538:
21786 5F3F           50                         push	ax
21787                                           ! Debug: add unsigned short = const $20 to unsigned short SI = [S+$20+4] (used reg = )
21788 5F40           8B46         06            mov	ax,6[bp]
21789                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$20 (used reg = )
21790 5F43           89C3                       mov	bx,ax
21791                                           ! Debug: eq char (temp) = [S+$20-$20] to unsigned char = [bx+$20] (used reg = )
21792 5F45           8A46         E2            mov	al,-$1E[bp]
21793 5F48           8847         20            mov	$20[bx],al
21794 5F4B           44                         inc	sp
21795 5F4C           44                         inc	sp
21796                                           !BCC_EOS
21797                                           ! 3867     *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.reserved1)) = (0);
21798                                           ! Debug: add unsigned short = const $21 to unsigned short SI = [S+$1E+4] (used reg = )
21799 5F4D           8B46         06            mov	ax,6[bp]
21800                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$21 (used reg = )
21801 5F50           89C3                       mov	bx,ax
21802                                           ! Debug: eq int = const 0 to unsigned char = [bx+$21] (used reg = )
21803 5F52           30C0                       xor	al,al
21804 5F54           8847         21            mov	$21[bx],al
21805                                           !BCC_EOS
21806                                           ! 3868     *((Bit16u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.reserved2)) = (0);
21807                                           ! Debug: add unsigned short = const $22 to unsigned short SI = [S+$1E+4] (used reg = )
21808 5F57           8B46         06            mov	ax,6[bp]
21809                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$22 (used reg = )
21810 5F5A           89C3                       mov	bx,ax
21811                                           ! Debug: eq int = const 0 to unsigned short = [bx+$22] (used reg = )
21812 5F5C           31C0                       xor	ax,ax
21813 5F5E           8947         22            mov	$22[bx],ax
21814                                           !BCC_EOS
21815                                           ! 3869     if (iface==0x00) {
21816                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$1E-$1A] (used reg = )
21817 5F61           8A46         E8            mov	al,-$18[bp]
21818 5F64           84C0                       test	al,al
21819 5F66           75           2A            jne 	.539
21820                       00005F68            .53A:
21821                                           ! 3870       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.host_bus[0])) = ('I');
21822                                           ! Debug: add unsigned short = const $24 to unsigned short SI = [S+$1E+4] (used reg = )
21823 5F68           8B46         06            mov	ax,6[bp]
21824                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$24 (used reg = )
21825 5F6B           89C3                       mov	bx,ax
21826                                           ! Debug: eq int = const $49 to unsigned char = [bx+$24] (used reg = )
21827 5F6D           B0                     49  mov	al,*$49
21828 5F6F           8847         24            mov	$24[bx],al
21829                                           !BCC_EOS
21830                                           ! 3871       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.host_bus[1])) = ('S');
21831                                           ! Debug: add unsigned short = const $25 to unsigned short SI = [S+$1E+4] (used reg = )
21832 5F72           8B46         06            mov	ax,6[bp]
21833                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$25 (used reg = )
21834 5F75           89C3                       mov	bx,ax
21835                                           ! Debug: eq int = const $53 to unsigned char = [bx+$25] (used reg = )
21836 5F77           B0                     53  mov	al,*$53
21837 5F79           8847         25            mov	$25[bx],al
21838                                           !BCC_EOS
21839                                           ! 3872       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.host_bus[2])) = ('A');
21840                                           ! Debug: add unsigned short = const $26 to unsigned short SI = [S+$1E+4] (used reg = )
21841 5F7C           8B46         06            mov	ax,6[bp]
21842                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$26 (used reg = )
21843 5F7F           89C3                       mov	bx,ax
21844                                           ! Debug: eq int = const $41 to unsigned char = [bx+$26] (used reg = )
21845 5F81           B0                     41  mov	al,*$41
21846 5F83           8847         26            mov	$26[bx],al
21847                                           !BCC_EOS
21848                                           ! 3873       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.host_bus[3])) = (' ');
21849                                           ! Debug: add unsigned short = const $27 to unsigned short SI = [S+$1E+4] (used reg = )
21850 5F86           8B46         06            mov	ax,6[bp]
21851                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$27 (used reg = )
21852 5F89           89C3                       mov	bx,ax
21853                                           ! Debug: eq int = const $20 to unsigned char = [bx+$27] (used reg = )
21854 5F8B           B0                     20  mov	al,*$20
21855 5F8D           8847         27            mov	$27[bx],al
21856                                           !BCC_EOS
21857                                           ! 3874     }
21858                                           ! 3875     else {
21859 5F90           EB           00            jmp .53B
21860                       00005F92            .539:
21861                                           ! 3876     }
21862                                           ! 3877     if (type == 0x02) {
21863                       00005F92            .53B:
21864                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$1E-$17] (used reg = )
21865 5F92           8A46         EB            mov	al,-$15[bp]
21866 5F95           3C                     02  cmp	al,*2
21867 5F97         0F85         0052            bne 	.53C
21868                       00005F9B            .53D:
21869                                           ! 3878         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[0])) = ('A');
21870                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$1E+4] (used reg = )
21871 5F9B           8B46         06            mov	ax,6[bp]
21872                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$28 (used reg = )
21873 5F9E           89C3                       mov	bx,ax
21874                                           ! Debug: eq int = const $41 to unsigned char = [bx+$28] (used reg = )
21875 5FA0           B0                     41  mov	al,*$41
21876 5FA2           8847         28            mov	$28[bx],al
21877                                           !BCC_EOS
21878                                           ! 3879         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[1])) = ('T');
21879                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$1E+4] (used reg = )
21880 5FA5           8B46         06            mov	ax,6[bp]
21881                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$29 (used reg = )
21882 5FA8           89C3                       mov	bx,ax
21883                                           ! Debug: eq int = const $54 to unsigned char = [bx+$29] (used reg = )
21884 5FAA           B0                     54  mov	al,*$54
21885 5FAC           8847         29            mov	$29[bx],al
21886                                           !BCC_EOS
21887                                           ! 3880         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[2])) = ('A');
21888                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$1E+4] (used reg = )
21889 5FAF           8B46         06            mov	ax,6[bp]
21890                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2A (used reg = )
21891 5FB2           89C3                       mov	bx,ax
21892                                           ! Debug: eq int = const $41 to unsigned char = [bx+$2A] (used reg = )
21893 5FB4           B0                     41  mov	al,*$41
21894 5FB6           8847         2A            mov	$2A[bx],al
21895                                           !BCC_EOS
21896                                           ! 3881         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[3])) = (' ');
21897                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$1E+4] (used reg = )
21898 5FB9           8B46         06            mov	ax,6[bp]
21899                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2B (used reg = )
21900 5FBC           89C3                       mov	bx,ax
21901                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2B] (used reg = )
21902 5FBE           B0                     20  mov	al,*$20
21903 5FC0           8847         2B            mov	$2B[bx],al
21904                                           !BCC_EOS
21905                                           ! 3882         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[4])) = (' ');
21906                                           ! Debug: add unsigned short = const $2C to unsigned short SI = [S+$1E+4] (used reg = )
21907 5FC3           8B46         06            mov	ax,6[bp]
21908                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2C (used reg = )
21909 5FC6           89C3                       mov	bx,ax
21910                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2C] (used reg = )
21911 5FC8           B0                     20  mov	al,*$20
21912 5FCA           8847         2C            mov	$2C[bx],al
21913                                           !BCC_EOS
21914                                           ! 3883         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[5])) = (' ');
21915                                           ! Debug: add unsigned short = const $2D to unsigned short SI = [S+$1E+4] (used reg = )
21916 5FCD           8B46         06            mov	ax,6[bp]
21917                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2D (used reg = )
21918 5FD0           89C3                       mov	bx,ax
21919                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2D] (used reg = )
21920 5FD2           B0                     20  mov	al,*$20
21921 5FD4           8847         2D            mov	$2D[bx],al
21922                                           !BCC_EOS
21923                                           ! 3884         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[6])) = (' ');
21924                                           ! Debug: add unsigned short = const $2E to unsigned short SI = [S+$1E+4] (used reg = )
21925 5FD7           8B46         06            mov	ax,6[bp]
21926                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2E (used reg = )
21927 5FDA           89C3                       mov	bx,ax
21928                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2E] (used reg = )
21929 5FDC           B0                     20  mov	al,*$20
21930 5FDE           8847         2E            mov	$2E[bx],al
21931                                           !BCC_EOS
21932                                           ! 3885         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[7])) = (' ');
21933                                           ! Debug: add unsigned short = const $2F to unsigned short SI = [S+$1E+4] (used reg = )
21934 5FE1           8B46         06            mov	ax,6[bp]
21935                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2F (used reg = )
21936 5FE4           89C3                       mov	bx,ax
21937                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2F] (used reg = )
21938 5FE6           B0                     20  mov	al,*$20
21939 5FE8           8847         2F            mov	$2F[bx],al
21940                                           !BCC_EOS
21941                                           ! 3886     } else if (type == 0x03) {
21942 5FEB           EB           57            jmp .53E
21943                       00005FED            .53C:
21944                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$1E-$17] (used reg = )
21945 5FED           8A46         EB            mov	al,-$15[bp]
21946 5FF0           3C                     03  cmp	al,*3
21947 5FF2           75           50            jne 	.53F
21948                       00005FF4            .540:
21949                                           ! 3887         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[0])) = ('A');
21950                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$1E+4] (used reg = )
21951 5FF4           8B46         06            mov	ax,6[bp]
21952                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$28 (used reg = )
21953 5FF7           89C3                       mov	bx,ax
21954                                           ! Debug: eq int = const $41 to unsigned char = [bx+$28] (used reg = )
21955 5FF9           B0                     41  mov	al,*$41
21956 5FFB           8847         28            mov	$28[bx],al
21957                                           !BCC_EOS
21958                                           ! 3888         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[1])) = ('T');
21959                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$1E+4] (used reg = )
21960 5FFE           8B46         06            mov	ax,6[bp]
21961                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$29 (used reg = )
21962 6001           89C3                       mov	bx,ax
21963                                           ! Debug: eq int = const $54 to unsigned char = [bx+$29] (used reg = )
21964 6003           B0                     54  mov	al,*$54
21965 6005           8847         29            mov	$29[bx],al
21966                                           !BCC_EOS
21967                                           ! 3889         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[2])) = ('A');
21968                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$1E+4] (used reg = )
21969 6008           8B46         06            mov	ax,6[bp]
21970                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2A (used reg = )
21971 600B           89C3                       mov	bx,ax
21972                                           ! Debug: eq int = const $41 to unsigned char = [bx+$2A] (used reg = )
21973 600D           B0                     41  mov	al,*$41
21974 600F           8847         2A            mov	$2A[bx],al
21975                                           !BCC_EOS
21976                                           ! 3890         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[3])) = ('P');
21977                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$1E+4] (used reg = )
21978 6012           8B46         06            mov	ax,6[bp]
21979                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2B (used reg = )
21980 6015           89C3                       mov	bx,ax
21981                                           ! Debug: eq int = const $50 to unsigned char = [bx+$2B] (used reg = )
21982 6017           B0                     50  mov	al,*$50
21983 6019           8847         2B            mov	$2B[bx],al
21984                                           !BCC_EOS
21985                                           ! 3891         *((Bit8u *)(SI+(Bit16u
21986                                           ! 3891 )&((dpt_t *) 0)->dpi.t13.iface_type[4])) = ('I');
21987                                           ! Debug: add unsigned short = const $2C to unsigned short SI = [S+$1E+4] (used reg = )
21988 601C           8B46         06            mov	ax,6[bp]
21989                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2C (used reg = )
21990 601F           89C3                       mov	bx,ax
21991                                           ! Debug: eq int = const $49 to unsigned char = [bx+$2C] (used reg = )
21992 6021           B0                     49  mov	al,*$49
21993 6023           8847         2C            mov	$2C[bx],al
21994                                           !BCC_EOS
21995                                           ! 3892         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[5])) = (' ');
21996                                           ! Debug: add unsigned short = const $2D to unsigned short SI = [S+$1E+4] (used reg = )
21997 6026           8B46         06            mov	ax,6[bp]
21998                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2D (used reg = )
21999 6029           89C3                       mov	bx,ax
22000                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2D] (used reg = )
22001 602B           B0                     20  mov	al,*$20
22002 602D           8847         2D            mov	$2D[bx],al
22003                                           !BCC_EOS
22004                                           ! 3893         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[6])) = (' ');
22005                                           ! Debug: add unsigned short = const $2E to unsigned short SI = [S+$1E+4] (used reg = )
22006 6030           8B46         06            mov	ax,6[bp]
22007                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2E (used reg = )
22008 6033           89C3                       mov	bx,ax
22009                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2E] (used reg = )
22010 6035           B0                     20  mov	al,*$20
22011 6037           8847         2E            mov	$2E[bx],al
22012                                           !BCC_EOS
22013                                           ! 3894         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[7])) = (' ');
22014                                           ! Debug: add unsigned short = const $2F to unsigned short SI = [S+$1E+4] (used reg = )
22015 603A           8B46         06            mov	ax,6[bp]
22016                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2F (used reg = )
22017 603D           89C3                       mov	bx,ax
22018                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2F] (used reg = )
22019 603F           B0                     20  mov	al,*$20
22020 6041           8847         2F            mov	$2F[bx],al
22021                                           !BCC_EOS
22022                                           ! 3895     }
22023                                           ! 3896     if (iface==0x00) {
22024                       00006044            .53F:
22025                       00006044            .53E:
22026                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$1E-$1A] (used reg = )
22027 6044           8A46         E8            mov	al,-$18[bp]
22028 6047           84C0                       test	al,al
22029 6049           75           26            jne 	.541
22030                       0000604B            .542:
22031                                           ! 3897       *((Bit16u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_path[0])) = (iobase1);
22032                                           ! Debug: add unsigned short = const $30 to unsigned short SI = [S+$1E+4] (used reg = )
22033 604B           8B46         06            mov	ax,6[bp]
22034                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$30 (used reg = )
22035 604E           89C3                       mov	bx,ax
22036                                           ! Debug: eq unsigned short iobase1 = [S+$1E-$1E] to unsigned short = [bx+$30] (used reg = )
22037 6050           8B46         E4            mov	ax,-$1C[bp]
22038 6053           8947         30            mov	$30[bx],ax
22039                                           !BCC_EOS
22040                                           ! 3898       *((Bit16u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_path[2])) = (0);
22041                                           ! Debug: add unsigned short = const $32 to unsigned short SI = [S+$1E+4] (used reg = )
22042 6056           8B46         06            mov	ax,6[bp]
22043                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$32 (used reg = )
22044 6059           89C3                       mov	bx,ax
22045                                           ! Debug: eq int = const 0 to unsigned short = [bx+$32] (used reg = )
22046 605B           31C0                       xor	ax,ax
22047 605D           8947         32            mov	$32[bx],ax
22048                                           !BCC_EOS
22049                                           ! 3899       *((Bit32u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_path[4])) = (0L);
22050                                           ! Debug: add unsigned short = const $34 to unsigned short SI = [S+$1E+4] (used reg = )
22051 6060           8B46         06            mov	ax,6[bp]
22052                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+$34 (used reg = )
22053 6063           89C3                       mov	bx,ax
22054                                           ! Debug: eq long = const 0 to unsigned long = [bx+$34] (used reg = )
22055 6065           31C0                       xor	ax,ax
22056 6067           31F6                       xor	si,si
22057 6069           8947         34            mov	$34[bx],ax
22058 606C           8977         36            mov	$36[bx],si
22059                                           !BCC_EOS
22060                                           ! 3900     }
22061                                           ! 3901     else {
22062 606F           EB           00            jmp .543
22063                       00006071            .541:
22064                                           ! 3902     }
22065                                           ! 3903     *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[0])) = (device%2);
22066                       00006071            .543:
22067                                           ! Debug: mod int = const 2 to unsigned char device = [S+$1E+6] (used reg = )
22068 6071           8A46         08            mov	al,8[bp]
22069 6074           30E4                       xor	ah,ah
22070 6076           24                     01  and	al,*1
22071 6078           50                         push	ax
22072                                           ! Debug: add unsigned short = const $38 to unsigned short SI = [S+$20+4] (used reg = )
22073 6079           8B46         06            mov	ax,6[bp]
22074                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$38 (used reg = )
22075 607C           89C3                       mov	bx,ax
22076                                           ! Debug: eq unsigned char (temp) = [S+$20-$20] to unsigned char = [bx+$38] (used reg = )
22077 607E           8A46         E2            mov	al,-$1E[bp]
22078 6081           8847         38            mov	$38[bx],al
22079 6084           44                         inc	sp
22080 6085           44                         inc	sp
22081                                           !BCC_EOS
22082                                           ! 3904     *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[1])) = (0);
22083                                           ! Debug: add unsigned short = const $39 to unsigned short SI = [S+$1E+4] (used reg = )
22084 6086           8B46         06            mov	ax,6[bp]
22085                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$39 (used reg = )
22086 6089           89C3                       mov	bx,ax
22087                                           ! Debug: eq int = const 0 to unsigned char = [bx+$39] (used reg = )
22088 608B           30C0                       xor	al,al
22089 608D           8847         39            mov	$39[bx],al
22090                                           !BCC_EOS
22091                                           ! 3905     *((Bit16u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[2])) = (0);
22092                                           ! Debug: add unsigned short = const $3A to unsigned short SI = [S+$1E+4] (used reg = )
22093 6090           8B46         06            mov	ax,6[bp]
22094                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$3A (used reg = )
22095 6093           89C3                       mov	bx,ax
22096                                           ! Debug: eq int = const 0 to unsigned short = [bx+$3A] (used reg = )
22097 6095           31C0                       xor	ax,ax
22098 6097           8947         3A            mov	$3A[bx],ax
22099                                           !BCC_EOS
22100                                           ! 3906     *((Bit32u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[4])) = (0L);
22101                                           ! Debug: add unsigned short = const $3C to unsigned short SI = [S+$1E+4] (used reg = )
22102 609A           8B46         06            mov	ax,6[bp]
22103                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+$3C (used reg = )
22104 609D           89C3                       mov	bx,ax
22105                                           ! Debug: eq long = const 0 to unsigned long = [bx+$3C] (used reg = )
22106 609F           31C0                       xor	ax,ax
22107 60A1           31F6                       xor	si,si
22108 60A3           8947         3C            mov	$3C[bx],ax
22109 60A6           8977         3E            mov	$3E[bx],si
22110                                           !BCC_EOS
22111                                           ! 3907     if (t13) {
22112 60A9           8B46         EE            mov	ax,-$12[bp]
22113 60AC           85C0                       test	ax,ax
22114 60AE           74           1E            je  	.544
22115                       000060B0            .545:
22116                                           ! 3908       *((Bit32u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[8])) = (0L);
22117                                           ! Debug: add unsigned short = const $40 to unsigned short SI = [S+$1E+4] (used reg = )
22118 60B0           8B46         06            mov	ax,6[bp]
22119                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+$40 (used reg = )
22120 60B3           89C3                       mov	bx,ax
22121                                           ! Debug: eq long = const 0 to unsigned long = [bx+$40] (used reg = )
22122 60B5           31C0                       xor	ax,ax
22123 60B7           31F6                       xor	si,si
22124 60B9           8947         40            mov	$40[bx],ax
22125 60BC           8977         42            mov	$42[bx],si
22126                                           !BCC_EOS
22127                                           ! 3909       *((Bit32u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[12])) = (0L);
22128                                           ! Debug: add unsigned short = const $44 to unsigned short SI = [S+$1E+4] (used reg = )
22129 60BF           8B46         06            mov	ax,6[bp]
22130                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+$44 (used reg = )
22131 60C2           89C3                       mov	bx,ax
22132                                           ! Debug: eq long = const 0 to unsigned long = [bx+$44] (used reg = )
22133 60C4           31C0                       xor	ax,ax
22134 60C6           31F6                       xor	si,si
22135 60C8           8947         44            mov	$44[bx],ax
22136 60CB           8977         46            mov	$46[bx],si
22137                                           !BCC_EOS
22138                                           ! 3910     }
22139                                           ! 3911     if (t13)
22140                       000060CE            .544:
22141 60CE           8B46         EE            mov	ax,-$12[bp]
22142 60D1           85C0                       test	ax,ax
22143 60D3           74           0C            je  	.546
22144                       000060D5            .547:
22145                                           ! 3912       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.reserved3)) = (0);
22146                                           ! Debug: add unsigned short = const $48 to unsigned short SI = [S+$1E+4] (used reg = )
22147 60D5           8B46         06            mov	ax,6[bp]
22148                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$48 (used reg = )
22149 60D8           89C3                       mov	bx,ax
22150                                           ! Debug: eq int = const 0 to unsigned char = [bx+$48] (used reg = )
22151 60DA           30C0                       xor	al,al
22152 60DC           8847         48            mov	$48[bx],al
22153                                           !BCC_EOS
22154                                           ! 3913     else
22155                                           ! 3914       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.phoenix.reserved3)) = (0);
22156 60DF           EB           0A            jmp .548
22157                       000060E1            .546:
22158                                           ! Debug: add unsigned short = const $40 to unsigned short SI = [S+$1E+4] (used reg = )
22159 60E1           8B46         06            mov	ax,6[bp]
22160                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$40 (used reg = )
22161 60E4           89C3                       mov	bx,ax
22162                                           ! Debug: eq int = const 0 to unsigned char = [bx+$40] (used reg = )
22163 60E6           30C0                       xor	al,al
22164 60E8           8847         40            mov	$40[bx],al
22165                                           !BCC_EOS
22166                                           ! 3915     checksum = 0;
22167                       000060EB            .548:
22168                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$1E-$1B] (used reg = )
22169 60EB           30C0                       xor	al,al
22170 60ED           8846         E7            mov	-$19[bp],al
22171                                           !BCC_EOS
22172                                           ! 3916     for (i = 30; i < (t13 ? 73 : 65); i++) checksum += *((Bit8u *)(SI + i));
22173                                           ! Debug: eq int = const $1E to unsigned char i = [S+$1E-$1C] (used reg = )
22174 60F0           B0                     1E  mov	al,*$1E
22175 60F2           8846         E6            mov	-$1A[bp],al
22176                                           !BCC_EOS
22177                                           !BCC_EOS
22178 60F5           EB           1F            jmp .54B
22179                       000060F7            .54C:
22180                                           ! Debug: add unsigned char i = [S+$1E-$1C] to unsigned short SI = [S+$1E+4] (used reg = )
22181 60F7           8B46         06            mov	ax,6[bp]
22182 60FA           0246         E6            add	al,-$1A[bp]
22183 60FD           80D4                   00  adc	ah,*0
22184                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+0 (used reg = )
22185 6100           89C3                       mov	bx,ax
22186                                           ! Debug: addab unsigned char = [bx+0] to unsigned char checksum = [S+$1E-$1B] (used reg = )
22187 6102           8A46         E7            mov	al,-$19[bp]
22188 6105           30E4                       xor	ah,ah
22189 6107           0207                       add	al,[bx]
22190 6109           80D4                   00  adc	ah,*0
22191 610C           8846         E7            mov	-$19[bp],al
22192                                           !BCC_EOS
22193                                           ! 3917     checksum = -checksum;
22194                       0000610F            .54A:
22195                                           ! Debug: postinc unsigned char i = [S+$1E-$1C] (used reg = )
22196 610F           8A46         E6            mov	al,-$1A[bp]
22197 6112           40                         inc	ax
22198 6113           8846         E6            mov	-$1A[bp],al
22199                       00006116            .54B:
22200 6116           8B46         EE            mov	ax,-$12[bp]
22201 6119           85C0                       test	ax,ax
22202 611B           74           04            je  	.54E
22203                       0000611D            .54F:
22204 611D           B0                     49  mov	al,*$49
22205 611F           EB           02            jmp .550
22206                       00006121            .54E:
22207 6121           B0                     41  mov	al,*$41
22208                       00006123            .550:
22209                                           ! Debug: lt char = al+0 to unsigned char i = [S+$1E-$1C] (used reg = )
22210 6123           3A46         E6            cmp	al,-$1A[bp]
22211 6126           77           CF            ja 	.54C
22212                       00006128            .54D:
22213                       00006128            .549:
22214                                           ! Debug: neg unsigned char checksum = [S+$1E-$1B] (used reg = )
22215 6128           31C0                       xor	ax,ax
22216 612A           2A46         E7            sub	al,-$19[bp]
22217 612D           80DC                   00  sbb	ah,*0
22218                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$1E-$1B] (used reg = )
22219 6130           8846         E7            mov	-$19[bp],al
22220                                           !BCC_EOS
22221                                           ! 3918     if (t13)
22222 6133           8B46         EE            mov	ax,-$12[bp]
22223 6136           85C0                       test	ax,ax
22224 6138           74           0D            je  	.551
22225                       0000613A            .552:
22226                                           ! 3919       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.checksum)) = (checksum);
22227                                           ! Debug: add unsigned short = const $49 to unsigned short SI = [S+$1E+4] (used reg = )
22228 613A           8B46         06            mov	ax,6[bp]
22229                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$49 (used reg = )
22230 613D           89C3                       mov	bx,ax
22231                                           ! Debug: eq unsigned char checksum = [S+$1E-$1B] to unsigned char = [bx+$49] (used reg = )
22232 613F           8A46         E7            mov	al,-$19[bp]
22233 6142           8847         49            mov	$49[bx],al
22234                                           !BCC_EOS
22235                                           ! 3920     else
22236                                           ! 3921       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.phoenix.checksum)) = (checksum);
22237 6145           EB           0B            jmp .553
22238                       00006147            .551:
22239                                           ! Debug: add unsigned short = const $41 to unsigned short SI = [S+$1E+4] (used reg = )
22240 6147           8B46         06            mov	ax,6[bp]
22241                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$41 (used reg = )
22242 614A           89C3                       mov	bx,ax
22243                                           ! Debug: eq unsigned char checksum = [S+$1E-$1B] to unsigned char = [bx+$41] (used reg = )
22244 614C           8A46         E7            mov	al,-$19[bp]
22245 614F           8847         41            mov	$41[bx],al
22246                                           !BCC_EOS
22247                                           ! 3922   }
22248                       00006152            .553:
22249 6152           83C4                   06  add	sp,*6
22250                                           ! 3923   return 0;
22251                       00006155            .534:
22252 6155           31C0                       xor	ax,ax
22253 6157           89EC                       mov	sp,bp
22254 6159           5D                         pop	bp
22255 615A           C3                         ret
22256                                           !BCC_EOS
22257                                           ! 3924 }
22258                                           ! 3925   void
22259                                           ! Register BX used in function int13_edd
22260                                           ! 3926 int13_harddisk(EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
22261                                           ! 3927   Bit16u EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
22262                                           export	_int13_harddisk
22263                       0000615B            _int13_harddisk:
22264                                           !BCC_EOS
22265                                           ! 3928 {
22266                                           ! 3929   Bit32u lba_low, lba_high;
22267                                           !BCC_EOS
22268                                           ! 3930   Bit16u cylinder, head, sector;
22269                                           !BCC_EOS
22270                                           ! 3931   Bit16u segment, offset;
22271                                           !BCC_EOS
22272                                           ! 3932   Bit16u npc, nph, npspt, nlc, nlh, nlspt;
22273                                           !BCC_EOS
22274                                           ! 3933   Bit16u size, count;
22275                                           !BCC_EOS
22276                                           ! 3934   Bit8u device, status;
22277                                           !BCC_EOS
22278                                           ! 3935   ;
22279 615B           55                         push	bp
22280 615C           89E5                       mov	bp,sp
22281 615E           83C4                   DC  add	sp,*-$24
22282                                           !BCC_EOS
22283                                           ! 3936   _write_byte(0, 0x008e, 0x0040);
22284                                           ! Debug: list int = const $40 (used reg = )
22285 6161           B8                   0040  mov	ax,*$40
22286 6164           50                         push	ax
22287                                           ! Debug: list int = const $8E (used reg = )
22288 6165           B8                   008E  mov	ax,#$8E
22289 6168           50                         push	ax
22290                                           ! Debug: list int = const 0 (used reg = )
22291 6169           31C0                       xor	ax,ax
22292 616B           50                         push	ax
22293                                           ! Debug: func () void = _write_byte+0 (used reg = )
22294 616C           E8         A491            call	__write_byte
22295 616F           83C4                   06  add	sp,*6
22296                                           !BCC_EOS
22297                                           ! 3937   if ( (( ELDX & 0x00ff ) < 0x80) || (( ELDX & 0x00ff ) >= 0x80 + (4*2)) ) {
22298                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$26+$E] (used reg = )
22299 6172           8A46         10            mov	al,$10[bp]
22300                                           ! Debug: lt int = const $80 to unsigned char = al+0 (used reg = )
22301 6175           3C                     80  cmp	al,#$80
22302 6177           72           07            jb  	.555
22303                       00006179            .556:
22304                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$26+$E] (used reg = )
22305 6179           8A46         10            mov	al,$10[bp]
22306                                           ! Debug: ge int = const $88 to unsigned char = al+0 (used reg = )
22307 617C           3C                     88  cmp	al,#$88
22308 617E           72           20            jb  	.554
22309                       00006180            .555:
22310                                           ! 3938     bios_printf(4, "int13_harddisk: f
22311                                           ! 3938 unction %02x, ELDL out of range %02x\n", *(((Bit8u *)&AX)+1), ( ELDX & 0x00ff ));
22312                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$26+$E] (used reg = )
22313 6180           8A46         10            mov	al,$10[bp]
22314                                           ! Debug: list unsigned char = al+0 (used reg = )
22315 6183           30E4                       xor	ah,ah
22316 6185           50                         push	ax
22317                                           ! Debug: list unsigned char AX = [S+$28+$17] (used reg = )
22318 6186           8A46         19            mov	al,$19[bp]
22319 6189           30E4                       xor	ah,ah
22320 618B           50                         push	ax
22321                                           ! Debug: list * char = .557+0 (used reg = )
22322 618C           BB                   D24B  mov	bx,#.557
22323 618F           53                         push	bx
22324                                           ! Debug: list int = const 4 (used reg = )
22325 6190           B8                   0004  mov	ax,*4
22326 6193           50                         push	ax
22327                                           ! Debug: func () void = bios_printf+0 (used reg = )
22328 6194           E8         A7A7            call	_bios_printf
22329 6197           83C4                   08  add	sp,*8
22330                                           !BCC_EOS
22331                                           ! 3939     goto int13_fail;
22332 619A           83C4                   00  add	sp,#..FFF1+$26
22333 619D           E9         0727            br 	.FFF1
22334                                           !BCC_EOS
22335                                           ! 3940   }
22336                                           ! 3941   device=*((Bit8u *)(&((ebda_data_t *) 0)->ata.hdidmap[( ELDX & 0x00ff )-0x80]));
22337                       000061A0            .554:
22338                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$26+$E] (used reg = )
22339 61A0           8A46         10            mov	al,$10[bp]
22340                                           ! Debug: sub int = const $80 to unsigned char = al+0 (used reg = )
22341 61A3           30E4                       xor	ah,ah
22342                                           ! Debug: ptradd unsigned int = ax-$80 to [8] unsigned char = const $233 (used reg = )
22343 61A5           05                   FF80  add	ax,*-$80
22344 61A8           89C3                       mov	bx,ax
22345                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
22346                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$233 (used reg = )
22347                                           ! Debug: eq unsigned char = [bx+$233] to unsigned char device = [S+$26-$25] (used reg = )
22348 61AA           8A87       0233            mov	al,$233[bx]
22349 61AE           8846         DD            mov	-$23[bp],al
22350                                           !BCC_EOS
22351                                           ! 3942   if (device >= (4*2)) {
22352                                           ! Debug: ge int = const 8 to unsigned char device = [S+$26-$25] (used reg = )
22353 61B1           8A46         DD            mov	al,-$23[bp]
22354 61B4           3C                     08  cmp	al,*8
22355 61B6           72           20            jb  	.558
22356                       000061B8            .559:
22357                                           ! 3943     bios_printf(4, "int13_harddisk: function %02x, unmapped device for ELDL=%02x\n", *(((Bit8u *)&AX)+1), ( ELDX & 0x00ff ));
22358                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$26+$E] (used reg = )
22359 61B8           8A46         10            mov	al,$10[bp]
22360                                           ! Debug: list unsigned char = al+0 (used reg = )
22361 61BB           30E4                       xor	ah,ah
22362 61BD           50                         push	ax
22363                                           ! Debug: list unsigned char AX = [S+$28+$17] (used reg = )
22364 61BE           8A46         19            mov	al,$19[bp]
22365 61C1           30E4                       xor	ah,ah
22366 61C3           50                         push	ax
22367                                           ! Debug: list * char = .55A+0 (used reg = )
22368 61C4           BB                   D20D  mov	bx,#.55A
22369 61C7           53                         push	bx
22370                                           ! Debug: list int = const 4 (used reg = )
22371 61C8           B8                   0004  mov	ax,*4
22372 61CB           50                         push	ax
22373                                           ! Debug: func () void = bios_printf+0 (used reg = )
22374 61CC           E8         A76F            call	_bios_printf
22375 61CF           83C4                   08  add	sp,*8
22376                                           !BCC_EOS
22377                                           ! 3944     goto int13_fail;
22378 61D2           83C4                   00  add	sp,#..FFF1+$26
22379 61D5           E9         06EF            br 	.FFF1
22380                                           !BCC_EOS
22381                                           ! 3945   }
22382                                           ! 3946   switch (*(((Bit8u *)&AX)+1)) {
22383                       000061D8            .558:
22384 61D8           8A46         19            mov	al,$19[bp]
22385 61DB           E9         066E            br 	.55D
22386                                           ! 3947     case 0x00:
22387                                           ! 3948       ata_reset (device);
22388                       000061DE            .55E:
22389                                           ! Debug: list unsigned char device = [S+$26-$25] (used reg = )
22390 61DE           8A46         DD            mov	al,-$23[bp]
22391 61E1           30E4                       xor	ah,ah
22392 61E3           50                         push	ax
22393                                           ! Debug: func () void = ata_reset+0 (used reg = )
22394 61E4           E8         C67B            call	_ata_reset
22395 61E7           44                         inc	sp
22396 61E8           44                         inc	sp
22397                                           !BCC_EOS
22398                                           ! 3949       goto int13_success;
22399 61E9           83C4                   00  add	sp,#..FFEF-..FFF0
22400 61EC           E9         06FD            br 	.FFEF
22401                                           !BCC_EOS
22402                                           ! 3950       break;
22403 61EF           E9         06D5            br 	.55B
22404                                           !BCC_EOS
22405                                           ! 3951     case 0x01:
22406                                           ! 3952       status = _read_byte(0x0074, 0x0040);
22407                       000061F2            .55F:
22408                                           ! Debug: list int = const $40 (used reg = )
22409 61F2           B8                   0040  mov	ax,*$40
22410 61F5           50                         push	ax
22411                                           ! Debug: list int = const $74 (used reg = )
22412 61F6           B8                   0074  mov	ax,*$74
22413 61F9           50                         push	ax
22414                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
22415 61FA           E8         A3E7            call	__read_byte
22416 61FD           83C4                   04  add	sp,*4
22417                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$26-$26] (used reg = )
22418 6200           8846         DC            mov	-$24[bp],al
22419                                           !BCC_EOS
22420                                           ! 3953       *(((Bit8u *)&AX)+1) = (status);
22421                                           ! Debug: eq unsigned char status = [S+$26-$26] to unsigned char AX = [S+$26+$17] (used reg = )
22422 6203           8A46         DC            mov	al,-$24[bp]
22423 6206           8846         19            mov	$19[bp],al
22424                                           !BCC_EOS
22425                                           ! 3954       _write_byte(0, 0x0074, 0x0040);
22426                                           ! Debug: list int = const $40 (used reg = )
22427 6209           B8                   0040  mov	ax,*$40
22428 620C           50                         push	ax
22429                                           ! Debug: list int = const $74 (used reg = )
22430 620D           B8                   0074  mov	ax,*$74
22431 6210           50                         push	ax
22432                                           ! Debug: list int = const 0 (used reg = )
22433 6211           31C0                       xor	ax,ax
22434 6213           50                         push	ax
22435                                           ! Debug: func () void = _write_byte+0 (used reg = )
22436 6214           E8         A3E9            call	__write_byte
22437 6217           83C4                   06  add	sp,*6
22438                                           !BCC_EOS
22439                                           ! 3955       if (status) goto int13_fail_nostatus;
22440 621A           8A46         DC            mov	al,-$24[bp]
22441 621D           84C0                       test	al,al
22442 621F           74           08            je  	.560
22443                       00006221            .561:
22444 6221           83C4                   00  add	sp,#..FFEE-..FFF0
22445 6224           E9         06B9            br 	.FFEE
22446                                           !BCC_EOS
22447                                           ! 3956       else goto int13_success_noah;
22448 6227           EB           06            jmp .562
22449                       00006229            .560:
22450 6229           83C4                   00  add	sp,#..FFED-..FFF0
22451 622C           E9         06C2            br 	.FFED
22452                                           !BCC_EOS
22453                                           ! 3957       break;
22454                       0000622F            .562:
22455 622F           E9         0695            br 	.55B
22456                                           !BCC_EOS
22457                                           ! 3958     case 0x02:
22458                                           ! 3959     case 0x03:
22459                       00006232            .563:
22460                                           ! 3960     case 0x04:
22461                       00006232            .564:
22462                                           ! 3961       count = ( AX & 0x00ff );
22463                       00006232            .565:
22464                                           ! Debug: and int = const $FF to unsigned short AX = [S+$26+$16] (used reg = )
22465 6232           8A46         18            mov	al,$18[bp]
22466                                           ! Debug: eq unsigned char = al+0 to unsigned short count = [S+$26-$24] (used reg = )
22467 6235           30E4                       xor	ah,ah
22468 6237           8946         DE            mov	-$22[bp],ax
22469                                           !BCC_EOS
22470                                           ! 3962       cylinder = *(((Bit8u *)&CX)+1);
22471                                           ! Debug: eq unsigned char CX = [S+$26+$15] to unsigned short cylinder = [S+$26-$C] (used reg = )
22472 623A           8A46         17            mov	al,$17[bp]
22473 623D           30E4                       xor	ah,ah
22474 623F           8946         F6            mov	-$A[bp],ax
22475                                           !BCC_EOS
22476                                           ! 3963       cylinder |= ( ((Bit16u) ( CX & 0x00ff )) << 2) & 0x300;
22477                                           ! Debug: and int = const $FF to unsigned short CX = [S+$26+$14] (used reg = )
22478 6242           8A46         16            mov	al,$16[bp]
22479                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
22480 6245           30E4                       xor	ah,ah
22481                                           ! Debug: sl int = const 2 to unsigned short = ax+0 (used reg = )
22482 6247           D1E0                       shl	ax,*1
22483 6249           D1E0                       shl	ax,*1
22484                                           ! Debug: and int = const $300 to unsigned int = ax+0 (used reg = )
22485 624B           25                   0300  and	ax,#$300
22486                                           ! Debug: orab unsigned int = ax+0 to unsigned short cylinder = [S+$26-$C] (used reg = )
22487 624E           0B46         F6            or	ax,-$A[bp]
22488 6251           8946         F6            mov	-$A[bp],ax
22489                                           !BCC_EOS
22490                                           ! 3964       sector = (( CX & 0x00ff ) & 0x3f);
22491                                           ! Debug: and int = const $FF to unsigned short CX = [S+$26+$14] (used reg = )
22492 6254           8A46         16            mov	al,$16[bp]
22493                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
22494 6257           24                     3F  and	al,*$3F
22495                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$26-$10] (used reg = )
22496 6259           30E4                       xor	ah,ah
22497 625B           8946         F2            mov	-$E[bp],ax
22498                                           !BCC_EOS
22499                                           ! 3965       head = *(((Bit8u *)&DX)+1);
22500                                           ! Debug: eq unsigned char DX = [S+$26+$13] to unsigned short head = [S+$26-$E] (used reg = )
22501 625E           8A46         15            mov	al,$15[bp]
22502 6261           30E4                       xor	ah,ah
22503 6263           8946         F4            mov	-$C[bp],ax
22504                                           !BCC_EOS
22505                                           ! 3966       segment = ES;
22506                                           ! Debug: eq unsigned short ES = [S+$26+6] to unsigned short segment = [S+$26-$12] (used reg = )
22507 6266           8B46         08            mov	ax,8[bp]
22508 6269           8946         F0            mov	-$10[bp],ax
22509                                           !BCC_EOS
22510                                           ! 3967       offset = BX;
22511                                           ! Debug: eq unsigned short BX = [S+$26+$10] to unsigned short offset = [S+$26-$14] (used reg = )
22512 626C           8B46         12            mov	ax,$12[bp]
22513 626F           8946         EE            mov	-$12[bp],ax
22514                                           !BCC_EOS
22515                                           ! 3968       if ((count > 128) || (count == 0) || (sector == 0)) {
22516                                           ! Debug: gt int = const $80 to unsigned short count = [S+$26-$24] (used reg = )
22517 6272           8B46         DE            mov	ax,-$22[bp]
22518 6275           3D                   0080  cmp	ax,#$80
22519 6278           77           0E            ja  	.567
22520                       0000627A            .569:
22521                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$26-$24] (used reg = )
22522 627A           8B46         DE            mov	ax,-$22[bp]
22523 627D           85C0                       test	ax,ax
22524 627F           74           07            je  	.567
22525                       00006281            .568:
22526                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$26-$10] (used reg = )
22527 6281           8B46         F2            mov	ax,-$E[bp]
22528 6284           85C0                       test	ax,ax
22529 6286           75           1A            jne 	.566
22530                       00006288            .567:
22531                                           ! 3969         bios_printf(4, "int13_harddisk: function %02x, parameter out of range!\n",*(((Bit8u *)&AX)+1));
22532                                           ! Debug: list unsigned char AX = [S+$26+$17] (used reg = )
22533 6288           8A46         19            mov	al,$19[bp]
22534 628B           30E4                       xor	ah,ah
22535 628D           50                         push	ax
22536                                           ! Debug: list * char = .56A+0 (used reg = )
22537 628E           BB                   D1D5  mov	bx,#.56A
22538 6291           53                         push	bx
22539                                           ! Debug: list int = const 4 (used reg = )
22540 6292           B8                   0004  mov	ax,*4
22541 6295           50                         push	ax
22542                                           ! Debug: func () void = bios_printf+0 (used reg = )
22543 6296           E8         A6A5            call	_bios_printf
22544 6299           83C4                   06  add	sp,*6
22545                                           !BCC_EOS
22546                                           ! 3970         goto int13_fail;
22547 629C           83C4                   00  add	sp,#..FFF1-..FFF0
22548 629F           E9         0625            br 	.FFF1
22549                                           !BCC_EOS
22550                                           ! 3971       }
22551                                           ! 3972       nlc = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders));
22552                       000062A2            .566:
22553                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22554 62A2           8A46         DD            mov	al,-$23[bp]
22555 62A5           30E4                       xor	ah,ah
22556 62A7           B9                   001E  mov	cx,*$1E
22557 62AA           F7E9                       imul	cx
22558 62AC           89C3                       mov	bx,ax
22559                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
22560                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14E (used reg = )
22561                                           ! Debug: eq unsigned short = [bx+$14E] to unsigned short nlc = [S+$26-$1C] (used reg = )
22562 62AE           8B9F       014E            mov	bx,$14E[bx]
22563 62B2           895E         E6            mov	-$1A[bp],bx
22564                                           !BCC_EOS
22565                                           ! 3973       nlh = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.heads));
22566                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22567 62B5           8A46         DD            mov	al,-$23[bp]
22568 62B8           30E4                       xor	ah,ah
22569 62BA           B9                   001E  mov	cx,*$1E
22570 62BD           F7E9                       imul	cx
22571 62BF           89C3                       mov	bx,ax
22572                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
22573                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14C (used reg = )
22574                                           ! Debug: eq unsigned short = [bx+$14C] to unsigned short nlh = [S+$26-$1E] (used reg = )
22575 62C1           8B9F       014C            mov	bx,$14C[bx]
22576 62C5           895E         E4            mov	-$1C[bp],bx
22577                                           !BCC_EOS
22578                                           ! 3974       nlspt = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.spt));
22579                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22580 62C8           8A46         DD            mov	al,-$23[bp]
22581 62CB           30E4                       xor	ah,ah
22582 62CD           B9                   001E  mov	cx,*$1E
22583 62D0           F7E9                       imul	cx
22584 62D2           89C3                       mov	bx,ax
22585                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
22586                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$150 (used reg = )
22587                                           ! Debug: eq unsigned short = [bx+$150] to unsigned short nlspt = [S+$26-$20] (used reg = )
22588 62D4           8B9F       0150            mov	bx,$150[bx]
22589 62D8           895E         E2            mov	-$1E[bp],bx
22590                                           !BCC_EOS
22591                                           ! 3975       if( (cylinder >= nlc) || (head >= nlh) || (sector > nlspt) ) {
22592                                           ! Debug: ge unsigned short nlc = [S+$26-$1C] to unsigned short cylinder = [S+$26-$C] (used reg = )
22593 62DB           8B46         F6            mov	ax,-$A[bp]
22594 62DE           3B46         E6            cmp	ax,-$1A[bp]
22595 62E1           73           10            jae 	.56C
22596                       000062E3            .56E:
22597                                           ! Debug: ge unsigned short nlh = [S+$26-$1E] to unsigned short head = [S+$26-$E] (used reg = )
22598 62E3           8B46         F4            mov	ax,-$C[bp]
22599 62E6           3B46         E4            cmp	ax,-$1C[bp]
22600 62E9           73           08            jae 	.56C
22601                       000062EB            .56D:
22602                                           ! Debug: gt unsigned short nlspt = [S+$26-$20] to unsigned short sector = [S+$26-$10] (used reg = )
22603 62EB           8B46         F2            mov	ax,-$E[bp]
22604 62EE           3B46         E2            cmp	ax,-$1E[bp]
22605 62F1           76           23            jbe 	.56B
22606                       000062F3            .56C:
22607                                           ! 3976         bios_printf(4, "int13_harddisk: function %02x, parameters out of range %04x/%04x/%04x!\n", *(((Bit8u *)&AX)+1), cylinder, head, sector);
22608                                           ! Debug: list unsigned short sector = [S+$26-$10] (used reg = )
22609 62F3           FF76         F2            push	-$E[bp]
22610                                           ! Debug: list unsigned short head = [S+$28-$E] (used reg = )
22611 62F6           FF76         F4            push	-$C[bp]
22612                                           ! Debug: list unsigned short cylinder = [S+$2A-$C] (used reg = )
22613 62F9           FF76         F6            push	-$A[bp]
22614                                           ! Debug: list unsigned char AX = [S+$2C+$17] (used reg = )
22615 62FC           8A46         19            mov	al,$19[bp]
22616 62FF           30E4                       xor	ah,ah
22617 6301           50                         push	ax
22618                                           ! Debug: list * char = .56F+0 (used reg = )
22619 6302           BB                   D18D  mov	bx,#.56F
22620 6305           53                         push	bx
22621                                           ! Debug: list int = const 4 (used reg = )
22622 6306           B8                   0004  mov	ax,*4
22623 6309           50                         push	ax
22624                                           ! Debug: func () void = bios_printf+0 (used reg = )
22625 630A           E8         A631            call	_bios_printf
22626 630D           83C4                   0C  add	sp,*$C
22627                                           !BCC_EOS
22628                                           ! 3977         goto int13_fail;
22629 6310           83C4                   00  add	sp,#..FFF1-..FFF0
22630 6313           E9         05B1            br 	.FFF1
22631                                           !BCC_EOS
22632                                           ! 3978       }
22633                                           ! 3979       if (*(((Bit8u *)&AX)+1) == 0x04) goto int13_success;
22634                       00006316            .56B:
22635                                           ! Debug: logeq int = const 4 to unsigned char AX = [S+$26+$17] (used reg = )
22636 6316           8A46         19            mov	al,$19[bp]
22637 6319           3C                     04  cmp	al,*4
22638 631B           75           06            jne 	.570
22639                       0000631D            .571:
22640 631D           83C4                   00  add	sp,#..FFEF-..FFF0
22641 6320           E9         05C9            br 	.FFEF
22642                                           !BCC_EOS
22643                                           ! 3980       nph = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.heads));
22644                       00006323            .570:
22645                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22646 6323           8A46         DD            mov	al,-$23[bp]
22647 6326           30E4                       xor	ah,ah
22648 6328           B9                   001E  mov	cx,*$1E
22649 632B           F7E9                       imul	cx
22650 632D           89C3                       mov	bx,ax
22651                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
22652                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$152 (used reg = )
22653                                           ! Debug: eq unsigned short = [bx+$152] to unsigned short nph = [S+$26-$18] (used reg = )
22654 632F           8B9F       0152            mov	bx,$152[bx]
22655 6333           895E         EA            mov	-$16[bp],bx
22656                                           !BCC_EOS
22657                                           ! 3981       npspt = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.spt));
22658                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22659 6336           8A46         DD            mov	al,-$23[bp]
22660 6339           30E4                       xor	ah,ah
22661 633B           B9                   001E  mov	cx,*$1E
22662 633E           F7E9                       imul	cx
22663 6340           89C3                       mov	bx,ax
22664                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
22665                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$156 (used reg = )
22666                                           ! Debug: eq unsigned short = [bx+$156] to unsigned short npspt = [S+$26-$1A] (used reg = )
22667 6342           8B9F       0156            mov	bx,$156[bx]
22668 6346           895E         E8            mov	-$18[bp],bx
22669                                           !BCC_EOS
22670                                           ! 3982       if ( (nph != nlh) || (npspt != nlspt)) {
22671                                           ! Debug: ne unsigned short nlh = [S+$26-$1E] to unsigned short nph = [S+$26-$18] (used reg = )
22672 6349           8B46         EA            mov	ax,-$16[bp]
22673 634C           3B46         E4            cmp	ax,-$1C[bp]
22674 634F           75           08            jne 	.573
22675                       00006351            .574:
22676                                           ! Debug: ne unsigned short nlspt = [S+$26-$20] to unsigned short npspt = [S+$26-$1A] (used reg = )
22677 6351           8B46         E8            mov	ax,-$18[bp]
22678 6354           3B46         E2            cmp	ax,-$1E[bp]
22679 6357           74           72            je  	.572
22680                       00006359            .573:
22681                                           ! 3983         lba_low = ((((Bit32u)cylinder * (Bit32u)nlh) + (Bit32u)head) * (Bit32u)nlspt) + (Bit32
22682                                           ! 3983 u)sector - 1;
22683                                           ! Debug: cast unsigned long = const 0 to unsigned short sector = [S+$26-$10] (used reg = )
22684 6359           8B46         F2            mov	ax,-$E[bp]
22685 635C           31DB                       xor	bx,bx
22686 635E           53                         push	bx
22687 635F           50                         push	ax
22688                                           ! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$2A-$20] (used reg = )
22689 6360           8B46         E2            mov	ax,-$1E[bp]
22690 6363           31DB                       xor	bx,bx
22691 6365           53                         push	bx
22692 6366           50                         push	ax
22693                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$2E-$E] (used reg = )
22694 6367           8B46         F4            mov	ax,-$C[bp]
22695 636A           31DB                       xor	bx,bx
22696 636C           53                         push	bx
22697 636D           50                         push	ax
22698                                           ! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$32-$1E] (used reg = )
22699 636E           8B46         E4            mov	ax,-$1C[bp]
22700 6371           31DB                       xor	bx,bx
22701 6373           53                         push	bx
22702 6374           50                         push	ax
22703                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$36-$C] (used reg = )
22704 6375           8B46         F6            mov	ax,-$A[bp]
22705 6378           31DB                       xor	bx,bx
22706                                           ! Debug: mul unsigned long (temp) = [S+$36-$36] to unsigned long = bx+0 (used reg = )
22707 637A           8D7E         CC            lea	di,-$E+..FFF0[bp]
22708 637D           E8         9D3A            call	lmulul
22709 6380           83C4                   04  add	sp,*4
22710                                           ! Debug: add unsigned long (temp) = [S+$32-$32] to unsigned long = bx+0 (used reg = )
22711 6383           8D7E         D0            lea	di,-$A+..FFF0[bp]
22712 6386           E8         9D0B            call	laddul
22713 6389           83C4                   04  add	sp,*4
22714                                           ! Debug: mul unsigned long (temp) = [S+$2E-$2E] to unsigned long = bx+0 (used reg = )
22715 638C           8D7E         D4            lea	di,-6+..FFF0[bp]
22716 638F           E8         9D28            call	lmulul
22717 6392           83C4                   04  add	sp,*4
22718                                           ! Debug: add unsigned long (temp) = [S+$2A-$2A] to unsigned long = bx+0 (used reg = )
22719 6395           8D7E         D8            lea	di,-2+..FFF0[bp]
22720 6398           E8         9CF9            call	laddul
22721 639B           83C4                   04  add	sp,*4
22722                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
22723 639E           53                         push	bx
22724 639F           50                         push	ax
22725 63A0           B8                   0001  mov	ax,*1
22726 63A3           31DB                       xor	bx,bx
22727 63A5           53                         push	bx
22728 63A6           50                         push	ax
22729 63A7           8B46         D8            mov	ax,-2+..FFF0[bp]
22730 63AA           8B5E         DA            mov	bx,0+..FFF0[bp]
22731 63AD           8D7E         D4            lea	di,-6+..FFF0[bp]
22732 63B0           E8         9CFF            call	lsubul
22733 63B3           83C4                   08  add	sp,*8
22734                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$26-6] (used reg = )
22735 63B6           8946         FC            mov	-4[bp],ax
22736 63B9           895E         FE            mov	-2[bp],bx
22737                                           !BCC_EOS
22738                                           ! 3984         lba_high = 0;
22739                                           ! Debug: eq int = const 0 to unsigned long lba_high = [S+$26-$A] (used reg = )
22740 63BC           31C0                       xor	ax,ax
22741 63BE           31DB                       xor	bx,bx
22742 63C0           8946         F8            mov	-8[bp],ax
22743 63C3           895E         FA            mov	-6[bp],bx
22744                                           !BCC_EOS
22745                                           ! 3985         sector = 0;
22746                                           ! Debug: eq int = const 0 to unsigned short sector = [S+$26-$10] (used reg = )
22747 63C6           31C0                       xor	ax,ax
22748 63C8           8946         F2            mov	-$E[bp],ax
22749                                           !BCC_EOS
22750                                           ! 3986       }
22751                                           ! 3987       if (*(((Bit8u *)&AX)+1) == 0x02)
22752                       000063CB            .572:
22753                                           ! Debug: logeq int = const 2 to unsigned char AX = [S+$26+$17] (used reg = )
22754 63CB           8A46         19            mov	al,$19[bp]
22755 63CE           3C                     02  cmp	al,*2
22756 63D0           75           36            jne 	.575
22757                       000063D2            .576:
22758                                           ! 3988         status=ata_cmd_data_io(0, device, 0x20, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
22759                                           ! Debug: list unsigned short offset = [S+$26-$14] (used reg = )
22760 63D2           FF76         EE            push	-$12[bp]
22761                                           ! Debug: list unsigned short segment = [S+$28-$12] (used reg = )
22762 63D5           FF76         F0            push	-$10[bp]
22763                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
22764 63D8           FF76         FA            push	-6[bp]
22765 63DB           FF76         F8            push	-8[bp]
22766                                           ! Debug: list unsigned long lba_low = [S+$2E-6] (used reg = )
22767 63DE           FF76         FE            push	-2[bp]
22768 63E1           FF76         FC            push	-4[bp]
22769                                           ! Debug: list unsigned short sector = [S+$32-$10] (used reg = )
22770 63E4           FF76         F2            push	-$E[bp]
22771                                           ! Debug: list unsigned short head = [S+$34-$E] (used reg = )
22772 63E7           FF76         F4            push	-$C[bp]
22773                                           ! Debug: list unsigned short cylinder = [S+$36-$C] (used reg = )
22774 63EA           FF76         F6            push	-$A[bp]
22775                                           ! Debug: list unsigned short count = [S+$38-$24] (used reg = )
22776 63ED           FF76         DE            push	-$22[bp]
22777                                           ! Debug: list int = const $20 (used reg = )
22778 63F0           B8                   0020  mov	ax,*$20
22779 63F3           50                         push	ax
22780                                           ! Debug: list unsigned char device = [S+$3C-$25] (used reg = )
22781 63F4           8A46         DD            mov	al,-$23[bp]
22782 63F7           30E4                       xor	ah,ah
22783 63F9           50                         push	ax
22784                                           ! Debug: list int = const 0 (used reg = )
22785 63FA           31C0                       xor	ax,ax
22786 63FC           50                         push	ax
22787                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
22788 63FD           E8         C589            call	_ata_cmd_data_io
22789 6400           83C4                   1A  add	sp,*$1A
22790                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$26-$26] (used reg = )
22791 6403           8846         DC            mov	-$24[bp],al
22792                                           !BCC_EOS
22793                                           ! 3989       else
22794                                           ! 3990         status=ata_cmd_data_io(1, device, 0x30, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
22795 6406           EB           35            jmp .577
22796                       00006408            .575:
22797                                           ! Debug: list unsigned short offset = [S+$26-$14] (used reg = )
22798 6408           FF76         EE            push	-$12[bp]
22799                                           ! Debug: list unsigned short segment = [S+$28-$12] (used reg = )
22800 640B           FF76         F0            push	-$10[bp]
22801                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
22802 640E           FF76         FA            push	-6[bp]
22803 6411           FF76         F8            push	-8[bp]
22804                                           ! Debug: list unsigned long lba_low = [S+$2E-6] (used reg = )
22805 6414           FF76         FE            push	-2[bp]
22806 6417           FF76         FC            push	-4[bp]
22807                                           ! Debug: list unsigned short sector = [S+$32-$10] (used reg = )
22808 641A           FF76         F2            push	-$E[bp]
22809                                           ! Debug: list unsigned short head = [S+$34-$E] (used reg = )
22810 641D           FF76         F4            push	-$C[bp]
22811                                           ! Debug: list unsigned short cylinder = [S+$36-$C] (used reg = )
22812 6420           FF76         F6            push	-$A[bp]
22813                                           ! Debug: list unsigned short count = [S+$38-$24] (used reg = )
22814 6423           FF76         DE            push	-$22[bp]
22815                                           ! Debug: list int = const $30 (used reg = )
22816 6426           B8                   0030  mov	ax,*$30
22817 6429           50                         push	ax
22818                                           ! Debug: list unsigned char device = [S+$3C-$25] (used reg = )
22819 642A           8A46         DD            mov	al,-$23[bp]
22820 642D           30E4                       xor	ah,ah
22821 642F           50                         push	ax
22822                                           ! Debug: list int = const 1 (used reg = )
22823 6430           B8                   0001  mov	ax,*1
22824 6433           50                         push	ax
22825                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
22826 6434           E8         C552            call	_ata_cmd_data_io
22827 6437           83C4                   1A  add	sp,*$1A
22828                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$26-$26] (used reg = )
22829 643A           8846         DC            mov	-$24[bp],al
22830                                           !BCC_EOS
22831                                           ! 3991       *((Bit8u *)&AX) = (*((Bit16u *)(&((ebda_data_t *) 0)->ata.trsfsectors)));
22832                       0000643D            .577:
22833                                           ! Debug: eq unsigned short = [+$254] to unsigned char AX = [S+$26+$16] (used reg = )
22834 643D           A0         0254            mov	al,[$254]
22835 6440           8846         18            mov	$18[bp],al
22836                                           !BCC_EOS
22837                                           ! 3992       if (status != 0) {
22838                                           ! Debug: ne int = const 0 to unsigned char status = [S+$26-$26] (used reg = )
22839 6443           8A46         DC            mov	al,-$24[bp]
22840 6446           84C0                       test	al,al
22841 6448           74           25            je  	.578
22842                       0000644A            .579:
22843                                           ! 3993         bios_printf(4, "int13_harddisk: function %02x, error %02x !\n",*(((Bit8u *)&AX)+1),status);
22844                                           ! Debug: list unsigned char status = [S+$26-$26] (used reg = )
22845 644A           8A46         DC            mov	al,-$24[bp]
22846 644D           30E4                       xor	ah,ah
22847 644F           50                         push	ax
22848                                           ! Debug: list unsigned char AX = [S+$28+$17] (used reg = )
22849 6450           8A46         19            mov	al,$19[bp]
22850 6453           30E4                       xor	ah,ah
22851 6455           50                         push	ax
22852                                           ! Debug: list * char = .57A+0 (used reg = )
22853 6456           BB                   D160  mov	bx,#.57A
22854 6459           53                         push	bx
22855                                           ! Debug: list int = const 4 (used reg = )
22856 645A           B8                   0004  mov	ax,*4
22857 645D           50                         push	ax
22858                                           ! Debug: func () void = bios_printf+0 (used reg = )
22859 645E           E8         A4DD            call	_bios_printf
22860 6461           83C4                   08  add	sp,*8
22861                                           !BCC_EOS
22862                                           ! 3994         *(((Bit8u *)&AX)+1) = (0x0c);
22863                                           ! Debug: eq int = const $C to unsigned char AX = [S+$26+$17] (used reg = )
22864 6464           B0                     0C  mov	al,*$C
22865 6466           8846         19            mov	$19[bp],al
22866                                           !BCC_EOS
22867                                           ! 3995         goto int13_fail_noah;
22868 6469           83C4                   00  add	sp,#..FFEC-..FFF0
22869 646C           E9         045D            br 	.FFEC
22870                                           !BCC_EOS
22871                                           ! 3996       }
22872                                           ! 3997       goto int13_success;
22873                       0000646F            .578:
22874 646F           83C4                   00  add	sp,#..FFEF-..FFF0
22875 6472           E9         0477            br 	.FFEF
22876                                           !BCC_EOS
22877                                           ! 3998       break;
22878 6475           E9         044F            br 	.55B
22879                                           !BCC_EOS
22880                                           ! 3999     case 0x05:
22881                                           ! 4000       bios_printf(4, "format disk track called\n");
22882                       00006478            .57B:
22883                                           ! Debug: list * char = .57C+0 (used reg = )
22884 6478           BB                   D146  mov	bx,#.57C
22885 647B           53                         push	bx
22886                                           ! Debug: list int = const 4 (used reg = )
22887 647C           B8                   0004  mov	ax,*4
22888 647F           50                         push	ax
22889                                           ! Debug: func () void = bios_printf+0 (used reg = )
22890 6480           E8         A4BB            call	_bios_printf
22891 6483           83C4                   04  add	sp,*4
22892                                           !BCC_EOS
22893                                           ! 4001       goto int13_success;
22894 6486           83C4                   00  add	sp,#..FFEF-..FFF0
22895 6489           E9         0460            br 	.FFEF
22896                                           !BCC_EOS
22897                                           ! 4002       return;
22898 648C           89EC                       mov	sp,bp
22899 648E           5D                         pop	bp
22900 648F           C3                         ret
22901                                           !BCC_EOS
22902                                           ! 4003       break;
22903 6490           E9         0434            br 	.55B
22904                                           !BCC_EOS
22905                                           ! 4004     case 0x08:
22906                                           ! 4005       nlc = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders));
22907                       00006493            .57D:
22908                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22909 6493           8A46         DD            mov	al,-$23[bp]
22910 6496           30E4                       xor	ah,ah
22911 6498           B9                   001E  mov	cx,*$1E
22912 649B           F7E9                       imul	cx
22913 649D           89C3                       mov	bx,ax
22914                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
22915                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14E (used reg = )
22916                                           ! Debug: eq unsigned short = [bx+$14E] to unsigned short nlc = [S+$26-$1C] (used reg = )
22917 649F           8B9F       014E            mov	bx,$14E[bx]
22918 64A3           895E         E6            mov	-$1A[bp],bx
22919                                           !BCC_EOS
22920                                           ! 4006       nlh = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.heads));
22921                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22922 64A6           8A46         DD            mov	al,-$23[bp]
22923 64A9           30E4                       xor	ah,ah
22924 64AB           B9                   001E  mov	cx,*$1E
22925 64AE           F7E9                       imul	cx
22926 64B0           89C3                       mov	bx,ax
22927                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
22928                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14C (used reg = )
22929                                           ! Debug: eq unsigned short = [bx+$14C] to unsigned short nlh = [S+$26-$1E] (used reg = )
22930 64B2           8B9F       014C            mov	bx,$14C[bx]
22931 64B6           895E         E4            mov	-$1C[bp],bx
22932                                           !BCC_EOS
22933                                           ! 4007       nlspt = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.spt));
22934                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22935 64B9           8A46         DD            mov	al,-$23[bp]
22936 64BC           30E4                       xor	ah,ah
22937 64BE           B9                   001E  mov	cx,*$1E
22938 64C1           F7E9                       imul	cx
22939 64C3           89C3                       mov	bx,ax
22940                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
22941                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$150 (used reg = )
22942                                           ! Debug: eq unsigned short = [bx+$150] to unsigned short nlspt = [S+$26-$20] (used reg = )
22943 64C5           8B9F       0150            mov	bx,$150[bx]
22944 64C9           895E         E2            mov	-$1E[bp],bx
22945                                           !BCC_EOS
22946                                           ! 4008       count = *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdcount));
22947                                           ! Debug: eq unsigned char = [+$232] to unsigned short count = [S+$26-$24] (used reg = )
22948 64CC           A0         0232            mov	al,[$232]
22949 64CF           30E4                       xor	ah,ah
22950 64D1           8946         DE            mov	-$22[bp],ax
22951                                           !BCC_EOS
22952                                           ! 4009       nlc = nlc - 1;
22953                                           ! Debug: sub int = const 1 to unsigned short nlc = [S+$26-$1C] (used reg = )
22954 64D4           8B46         E6            mov	ax,-$1A[bp]
22955                                           ! Debug: eq unsigned int = ax-1 to unsigned short nlc = [S+$26-$1C] (used reg = )
22956 64D7           48                         dec	ax
22957 64D8           8946         E6            mov	-$1A[bp],ax
22958                                           !BCC_EOS
22959                                           ! 4010       *((Bit8u *)&AX) = (0);
22960                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$26+$16] (used reg = )
22961 64DB           30C0                       xor	al,al
22962 64DD           8846         18            mov	$18[bp],al
22963                                           !BCC_EOS
22964                                           ! 4011       *(((Bit8u *)&CX)+1) = (nlc & 0xff);
22965                                           ! Debug: and int = const $FF to unsigned short nlc = [S+$26-$1C] (used reg = )
22966 64E0           8A46         E6            mov	al,-$1A[bp]
22967                                           ! Debug: eq unsigned char = al+0 to unsigned char CX = [S+$26+$15] (used reg = )
22968 64E3           8846         17            mov	$17[bp],al
22969                                           !BCC_EOS
22970                                           ! 4012       *((Bit8u *)&CX) = (((nlc >> 2) & 0xc0) | (nlspt & 0x3f));
22971                                           ! Debug: and int = const $3F to unsigned short nlspt = [S+$26-$20] (used reg = )
22972 64E6           8A46         E2            mov	al,-$1E[bp]
22973 64E9           24                     3F  and	al,*$3F
22974 64EB           50                         push	ax
22975                                           ! Debug: sr int = const 2 to unsigned short nlc = [S+$28-$1C] (used reg = )
22976 64EC           8B46         E6            mov	ax,-$1A[bp]
22977 64EF           D1E8                       shr	ax,*1
22978 64F1           D1E8                       shr	ax,*1
22979                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
22980 64F3           24                     C0  and	al,#$C0
22981                                           ! Debug: or unsigned char (temp) = [S+$28-$28] to unsigned char = al+0 (used reg = )
22982 64F5           0A46         DA            or	al,0+..FFF0[bp]
22983 64F8           44                         inc	sp
22984 64F9           44                         inc	sp
22985                                           ! Debug: eq unsigned char = al+0 to unsigned char CX = [S+$26+$14] (used reg = )
22986 64FA           8846         16            mov	$16[bp],al
22987                                           !BCC_EOS
22988                                           ! 4013       *(((Bit8u *)&DX)+1) = (nlh - 1);
22989                                           ! Debug: sub int = const 1 to unsigned short nlh = [S+$26-$1E] (used reg = )
22990 64FD           8B46         E4            mov	ax,-$1C[bp]
22991                                           ! Debug: eq unsigned int = ax-1 to unsigned char DX = [S+$26+$13] (used reg = )
22992 6500           48                         dec	ax
22993 6501           8846         15            mov	$15[bp],al
22994                                           !BCC_EOS
22995                                           ! 4014       *((Bit8u *)&DX) = (count);
22996                                           ! Debug: eq unsigned short count = [S+$26-$24] to unsigned char DX = [S+$26+$12] (used reg = )
22997 6504           8A46         DE            mov	al,-$22[bp]
22998 6507           8846         14            mov	$14[bp],al
22999                                           !BCC_EOS
23000                                           ! 4015       goto int13_success;
23001 650A           83C4                   00  add	sp,#..FFEF-..FFF0
23002 650D           E9         03DC            br 	.FFEF
23003                                           !BCC_EOS
23004                                           ! 4016       break;
23005 6510           E9         03B4            br 	.55B
23006                                           !BCC_EOS
23007                                           ! 4017     case 0x10:
23008                                           ! 4018       status = inb(*((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[device/2].iobase1)) + 7);
23009                       00006513            .57E:
23010                                           ! Debug: div int = const 2 to unsigned char device = [S+$26-$25] (used reg = )
23011 6513           8A46         DD            mov	al,-$23[bp]
23012 6516           30E4                       xor	ah,ah
23013 6518           D1E8                       shr	ax,*1
23014                                           ! Debug: ptradd unsigned int = ax+0 to [4] struct  = const $122 (used reg = )
23015 651A           B1                     03  mov	cl,*3
23016 651C           D3E0                       shl	ax,cl
23017 651E           89C3                       mov	bx,ax
23018                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
23019                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
23020                                           ! Debug: add int = const 7 to unsigned short = [bx+$124] (used reg = )
23021 6520           8B9F       0124            mov	bx,$124[bx]
23022                                           ! Debug: list unsigned int = bx+7 (used reg = )
23023 6524           83C3                   07  add	bx,*7
23024 6527           53                         push	bx
23025                                           ! Debug: func () unsigned char = inb+0 (used reg = )
23026 6528           E8         9FCD            call	_inb
23027 652B           44                         inc	sp
23028 652C           44                         inc	sp
23029                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$26-$26] (used reg = )
23030 652D           8846         DC            mov	-$24[bp],al
23031                                           !BCC_EOS
23032                                           ! 4019       if ( (status & (0x80 | 0x40)) == 0x40 ) {
23033                                           ! Debug: and int = const $C0 to unsigned char status = [S+$26-$26] (used reg = )
23034 6530           8A46         DC            mov	al,-$24[bp]
23035 6533           24                     C0  and	al,#$C0
23036                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
23037 6535           3C                     40  cmp	al,*$40
23038 6537           75           08            jne 	.57F
23039                       00006539            .580:
23040                                           ! 4020         goto int13_success;
23041 6539           83C4                   00  add	sp,#..FFEF-..FFF0
23042 653C           E9         03AD            br 	.FFEF
23043                                           !BCC_EOS
23044                                           ! 4021       }
23045                                           ! 4022       else {
23046 653F           EB           0B            jmp .581
23047                       00006541            .57F:
23048                                           ! 4023         *(((Bit8u *)&AX)+1) = (0xAA);
23049                                           ! Debug: eq int = const $AA to unsigned char AX = [S+$26+$17] (used reg = )
23050 6541           B0                     AA  mov	al,#$AA
23051 6543           8846         19            mov	$19[bp],al
23052                                           !BCC_EOS
23053                                           ! 4024         goto int13_fail_noah;
23054 6546           83C4                   00  add	sp,#..FFEC-..FFF0
23055 6549           E9         0380            br 	.FFEC
23056                                           !BCC_EOS
23057                                           ! 4025       }
23058                                           ! 4026       break;
23059                       0000654C            .581:
23060 654C           E9         0378            br 	.55B
23061                                           !BCC_EOS
23062                                           ! 4027     case 0x15:
23063                                           ! 4028       nlc = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders));
23064                       0000654F            .582:
23065                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23066 654F           8A46         DD            mov	al,-$23[bp]
23067 6552           30E4                       xor	ah,ah
23068 6554           B9                   001E  mov	cx,*$1E
23069 6557           F7E9                       imul	cx
23070 6559           89C3                       mov	bx,ax
23071                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
23072                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14E (used reg = )
23073                                           ! Debug: eq unsigned short = [bx+$14E] to unsigned short nlc = [S+$26-$1C] (used reg = )
23074 655B           8B9F       014E            mov	bx,$14E[bx]
23075 655F           895E         E6            mov	-$1A[bp],bx
23076                                           !BCC_EOS
23077                                           ! 4029       nlh = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.heads));
23078                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23079 6562           8A46         DD            mov	al,-$23[bp]
23080 6565           30E4                       xor	ah,ah
23081 6567           B9                   001E  mov	cx,*$1E
23082 656A           F7E9                       imul	cx
23083 656C           89C3                       mov	bx,ax
23084                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
23085                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14C (used reg = )
23086                                           ! Debug: eq unsigned short = [bx+$14C] to unsigned short nlh = [S+$26-$1E] (used reg = )
23087 656E           8B9F       014C            mov	bx,$14C[bx]
23088 6572           895E         E4            mov	-$1C[bp],bx
23089                                           !BCC_EOS
23090                                           ! 4030       nlspt = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.spt));
23091                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23092 6575           8A46         DD            mov	al,-$23[bp]
23093 6578           30E4                       xor	ah,ah
23094 657A           B9                   001E  mov	cx,*$1E
23095 657D           F7E9                       imul	cx
23096 657F           89C3                       mov	bx,ax
23097                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
23098                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$150 (used reg = )
23099                                           ! Debug: eq unsigned short = [bx+$150] to unsigned short nlspt = [S+$26-$20] (used reg = )
23100 6581           8B9F       0150            mov	bx,$150[bx]
23101 6585           895E         E2            mov	-$1E[bp],bx
23102                                           !BCC_EOS
23103                                           ! 4031       lba_low = (Bit32u)(nlc - 1) * (Bit32u)nlh * (Bit32u)nlspt;
23104                                           ! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$26-$20] (used reg = )
23105 6588           8B46         E2            mov	ax,-$1E[bp]
23106 658B           31DB                       xor	bx,bx
23107 658D           53                         push	bx
23108 658E           50                         push	ax
23109                                           ! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$2A-$1E] (used reg = )
23110 658F           8B46         E4            mov	ax,-$1C[bp]
23111 6592           31DB                       xor	bx,bx
23112 6594           53                         push	bx
23113 6595           50                         push	ax
23114                                           ! Debug: sub int = const 1 to unsigned short nlc = [S+$2E-$1C] (used reg = )
23115 6596           8B46         E6            mov	ax,-$1A[bp]
23116                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
23117 6599           48                         dec	ax
23118 659A           31DB                       xor	bx,bx
23119                                           ! Debug: mul unsigned long (temp) = [S+$2E-$2E] to unsigned long = bx+0 (used reg = )
23120 659C           8D7E         D4            lea	di,-6+..FFF0[bp]
23121 659F           E8         9B18            call	lmulul
23122 65A2           83C4                   04  add	sp,*4
23123                                           ! Debug: mul unsigned long (temp) = [S+$2A-$2A] to unsigned long = bx+0 (used reg = )
23124 65A5           8D7E         D8            lea	di,-2+..FFF0[bp]
23125 65A8           E8         9B0F            call	lmulul
23126 65AB           83C4                   04  add	sp,*4
23127                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$26-6] (used reg = )
23128 65AE           8946         FC            mov	-4[bp],ax
23129 65B1           895E         FE            mov	-2[bp],bx
23130                                           !BCC_EOS
23131                                           ! 4032       CX = *(((Bit16u *)&lba_low)+1);
23132                                           ! Debug: eq unsigned short lba_low = [S+$26-4] to unsigned short CX = [S+$26+$14] (used reg = )
23133 65B4           8B46         FE            mov	ax,-2[bp]
23134 65B7           8946         16            mov	$16[bp],ax
23135                                           !BCC_EOS
23136                                           ! 4033       DX = 
23137                                           ! 4033 *((Bit16u *)&lba_low);
23138                                           ! Debug: eq unsigned short lba_low = [S+$26-6] to unsigned short DX = [S+$26+$12] (used reg = )
23139 65BA           8B46         FC            mov	ax,-4[bp]
23140 65BD           8946         14            mov	$14[bp],ax
23141                                           !BCC_EOS
23142                                           ! 4034       *(((Bit8u *)&AX)+1) = (3);
23143                                           ! Debug: eq int = const 3 to unsigned char AX = [S+$26+$17] (used reg = )
23144 65C0           B0                     03  mov	al,*3
23145 65C2           8846         19            mov	$19[bp],al
23146                                           !BCC_EOS
23147                                           ! 4035       goto int13_success_noah;
23148 65C5           83C4                   00  add	sp,#..FFED-..FFF0
23149 65C8           E9         0326            br 	.FFED
23150                                           !BCC_EOS
23151                                           ! 4036       break;
23152 65CB           E9         02F9            br 	.55B
23153                                           !BCC_EOS
23154                                           ! 4037     case 0x41:
23155                                           ! 4038       BX=0xaa55;
23156                       000065CE            .583:
23157                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$26+$10] (used reg = )
23158 65CE           B8                   AA55  mov	ax,#$AA55
23159 65D1           8946         12            mov	$12[bp],ax
23160                                           !BCC_EOS
23161                                           ! 4039       *(((Bit8u *)&AX)+1) = (0x30);
23162                                           ! Debug: eq int = const $30 to unsigned char AX = [S+$26+$17] (used reg = )
23163 65D4           B0                     30  mov	al,*$30
23164 65D6           8846         19            mov	$19[bp],al
23165                                           !BCC_EOS
23166                                           ! 4040       CX=0x0007;
23167                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$26+$14] (used reg = )
23168 65D9           B8                   0007  mov	ax,*7
23169 65DC           8946         16            mov	$16[bp],ax
23170                                           !BCC_EOS
23171                                           ! 4041       goto int13_success_noah;
23172 65DF           83C4                   00  add	sp,#..FFED-..FFF0
23173 65E2           E9         030C            br 	.FFED
23174                                           !BCC_EOS
23175                                           ! 4042       break;
23176 65E5           E9         02DF            br 	.55B
23177                                           !BCC_EOS
23178                                           ! 4043     case 0x42:
23179                                           ! 4044     case 0x43:
23180                       000065E8            .584:
23181                                           ! 4045     case 0x44:
23182                       000065E8            .585:
23183                                           ! 4046     case 0x47:
23184                       000065E8            .586:
23185                                           ! 4047       count=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->count, DS);
23186                       000065E8            .587:
23187                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23188 65E8           FF76         06            push	6[bp]
23189                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$28+$A] (used reg = )
23190 65EB           8B46         0C            mov	ax,$C[bp]
23191                                           ! Debug: list unsigned int = ax+2 (used reg = )
23192 65EE           40                         inc	ax
23193 65EF           40                         inc	ax
23194 65F0           50                         push	ax
23195                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
23196 65F1           E8         9FFE            call	__read_word
23197 65F4           83C4                   04  add	sp,*4
23198                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$26-$24] (used reg = )
23199 65F7           8946         DE            mov	-$22[bp],ax
23200                                           !BCC_EOS
23201                                           ! 4048       segment=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->segment, DS);
23202                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23203 65FA           FF76         06            push	6[bp]
23204                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$28+$A] (used reg = )
23205 65FD           8B46         0C            mov	ax,$C[bp]
23206                                           ! Debug: list unsigned int = ax+6 (used reg = )
23207 6600           05                   0006  add	ax,*6
23208 6603           50                         push	ax
23209                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
23210 6604           E8         9FEB            call	__read_word
23211 6607           83C4                   04  add	sp,*4
23212                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$26-$12] (used reg = )
23213 660A           8946         F0            mov	-$10[bp],ax
23214                                           !BCC_EOS
23215                                           ! 4049       offset=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->offset, DS);
23216                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23217 660D           FF76         06            push	6[bp]
23218                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$28+$A] (used reg = )
23219 6610           8B46         0C            mov	ax,$C[bp]
23220                                           ! Debug: list unsigned int = ax+4 (used reg = )
23221 6613           05                   0004  add	ax,*4
23222 6616           50                         push	ax
23223                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
23224 6617           E8         9FD8            call	__read_word
23225 661A           83C4                   04  add	sp,*4
23226                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$26-$14] (used reg = )
23227 661D           8946         EE            mov	-$12[bp],ax
23228                                           !BCC_EOS
23229                                           ! 4050       lba_high=_read_dword(SI+(Bit16u)&((int13ext_t *) 0)->lba2, DS);
23230                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23231 6620           FF76         06            push	6[bp]
23232                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$28+$A] (used reg = )
23233 6623           8B46         0C            mov	ax,$C[bp]
23234                                           ! Debug: list unsigned int = ax+$C (used reg = )
23235 6626           05                   000C  add	ax,*$C
23236 6629           50                         push	ax
23237                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
23238 662A           E8         9A29            call	__read_dword
23239 662D           89D3                       mov	bx,dx
23240 662F           83C4                   04  add	sp,*4
23241                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$26-$A] (used reg = )
23242 6632           8946         F8            mov	-8[bp],ax
23243 6635           895E         FA            mov	-6[bp],bx
23244                                           !BCC_EOS
23245                                           ! 4051       if (lba_high > *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high)) ) {
23246                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23247 6638           8A46         DD            mov	al,-$23[bp]
23248 663B           30E4                       xor	ah,ah
23249 663D           B9                   001E  mov	cx,*$1E
23250 6640           F7E9                       imul	cx
23251 6642           89C3                       mov	bx,ax
23252                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
23253                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
23254                                           ! Debug: gt unsigned long = [bx+$15C] to unsigned long lba_high = [S+$26-$A] (used reg = )
23255 6644           8B87       015C            mov	ax,$15C[bx]
23256 6648           8B9F       015E            mov	bx,$15E[bx]
23257 664C           8D7E         F8            lea	di,-8[bp]
23258 664F           E8         9A4A            call	lcmpul
23259 6652           73           1A            jae 	.588
23260                       00006654            .589:
23261                                           ! 4052         bios_printf(4, "int13_harddisk: function %02x. LBA out of range\n",*(((Bit8u *)&AX)+1));
23262                                           ! Debug: list unsigned char AX = [S+$26+$17] (used reg = )
23263 6654           8A46         19            mov	al,$19[bp]
23264 6657           30E4                       xor	ah,ah
23265 6659           50                         push	ax
23266                                           ! Debug: list * char = .58A+0 (used reg = )
23267 665A           BB                   D115  mov	bx,#.58A
23268 665D           53                         push	bx
23269                                           ! Debug: list int = const 4 (used reg = )
23270 665E           B8                   0004  mov	ax,*4
23271 6661           50                         push	ax
23272                                           ! Debug: func () void = bios_printf+0 (used reg = )
23273 6662           E8         A2D9            call	_bios_printf
23274 6665           83C4                   06  add	sp,*6
23275                                           !BCC_EOS
23276                                           ! 4053         goto int13_fail;
23277 6668           83C4                   00  add	sp,#..FFF1-..FFF0
23278 666B           E9         0259            br 	.FFF1
23279                                           !BCC_EOS
23280                                           ! 4054       }
23281                                           ! 4055       lba_low=_read_dword(SI+(Bit16u)&((int13ext_t *) 0)->lba1, DS);
23282                       0000666E            .588:
23283                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23284 666E           FF76         06            push	6[bp]
23285                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$28+$A] (used reg = )
23286 6671           8B46         0C            mov	ax,$C[bp]
23287                                           ! Debug: list unsigned int = ax+8 (used reg = )
23288 6674           05                   0008  add	ax,*8
23289 6677           50                         push	ax
23290                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
23291 6678           E8         99DB            call	__read_dword
23292 667B           89D3                       mov	bx,dx
23293 667D           83C4                   04  add	sp,*4
23294                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$26-6] (used reg = )
23295 6680           8946         FC            mov	-4[bp],ax
23296 6683           895E         FE            mov	-2[bp],bx
23297                                           !BCC_EOS
23298                                           ! 4056       if (lba_high == *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high))
23299                                           ! 4057           && lba_low >= *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_low)) ) {
23300                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23301 6686           8A46         DD            mov	al,-$23[bp]
23302 6689           30E4                       xor	ah,ah
23303 668B           B9                   001E  mov	cx,*$1E
23304 668E           F7E9                       imul	cx
23305 6690           89C3                       mov	bx,ax
23306                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
23307                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
23308                                           ! Debug: logeq unsigned long = [bx+$15C] to unsigned long lba_high = [S+$26-$A] (used reg = )
23309 6692           8B87       015C            mov	ax,$15C[bx]
23310 6696           8B9F       015E            mov	bx,$15E[bx]
23311 669A           8D7E         F8            lea	di,-8[bp]
23312 669D           E8         99FC            call	lcmpul
23313 66A0           75           36            jne 	.58B
23314                       000066A2            .58D:
23315                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23316 66A2           8A46         DD            mov	al,-$23[bp]
23317 66A5           30E4                       xor	ah,ah
23318 66A7           B9                   001E  mov	cx,*$1E
23319 66AA           F7E9                       imul	cx
23320 66AC           89C3                       mov	bx,ax
23321                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
23322                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$158 (used reg = )
23323                                           ! Debug: ge unsigned long = [bx+$158] to unsigned long lba_low = [S+$26-6] (used reg = )
23324 66AE           8B87       0158            mov	ax,$158[bx]
23325 66B2           8B9F       015A            mov	bx,$15A[bx]
23326 66B6           8D7E         FC            lea	di,-4[bp]
23327 66B9           E8         99E0            call	lcmpul
23328 66BC           77           1A            ja  	.58B
23329                       000066BE            .58C:
23330                                           ! 4058         bios_printf(4, "int13_harddisk: function %02x. LBA out of range\n",*(((Bit8u *)&AX)+1));
23331                                           ! Debug: list unsigned char AX = [S+$26+$17] (used reg = )
23332 66BE           8A46         19            mov	al,$19[bp]
23333 66C1           30E4                       xor	ah,ah
23334 66C3           50                         push	ax
23335                                           ! Debug: list * char = .58E+0 (used reg = )
23336 66C4           BB                   D0E4  mov	bx,#.58E
23337 66C7           53                         push	bx
23338                                           ! Debug: list int = const 4 (used reg = )
23339 66C8           B8                   0004  mov	ax,*4
23340 66CB           50                         push	ax
23341                                           ! Debug: func () void = bios_printf+0 (used reg = )
23342 66CC           E8         A26F            call	_bios_printf
23343 66CF           83C4                   06  add	sp,*6
23344                                           !BCC_EOS
23345                                           ! 4059         goto int13_fail;
23346 66D2           83C4                   00  add	sp,#..FFF1-..FFF0
23347 66D5           E9         01EF            br 	.FFF1
23348                                           !BCC_EOS
23349                                           ! 4060       }
23350                                           ! 4061       if (( *(((Bit8u *)&AX)+1) == 0x44 ) || ( *(((Bit8u *)&AX)+1) == 0x47 ))
23351                       000066D8            .58B:
23352                                           ! Debug: logeq int = const $44 to unsigned char AX = [S+$26+$17] (used reg = )
23353 66D8           8A46         19            mov	al,$19[bp]
23354 66DB           3C                     44  cmp	al,*$44
23355 66DD           74           07            je  	.590
23356                       000066DF            .591:
23357                                           ! Debug: logeq int = const $47 to unsigned char AX = [S+$26+$17] (used reg = )
23358 66DF           8A46         19            mov	al,$19[bp]
23359 66E2           3C                     47  cmp	al,*$47
23360 66E4           75           06            jne 	.58F
23361                       000066E6            .590:
23362                                           ! 4062         goto int13_success;
23363 66E6           83C4                   00  add	sp,#..FFEF-..FFF0
23364 66E9           E9         0200            br 	.FFEF
23365                                           !BCC_EOS
23366                                           ! 4063       if (*(((Bit8u *)&AX)+1) == 0x42)
23367                       000066EC            .58F:
23368                                           ! Debug: logeq int = const $42 to unsigned char AX = [S+$26+$17] (used reg = )
23369 66EC           8A46         19            mov	al,$19[bp]
23370 66EF           3C                     42  cmp	al,*$42
23371 66F1           75           36            jne 	.592
23372                       000066F3            .593:
23373                                           ! 4064         status=ata_cmd_data_io(0, device, 0x20, count, 0, 0, 0, lba_low, lba_high, segment, offset);
23374                                           ! Debug: list unsigned short offset = [S+$26-$14] (used reg = )
23375 66F3           FF76         EE            push	-$12[bp]
23376                                           ! Debug: list unsigned short segment = [S+$28-$12] (used reg = )
23377 66F6           FF76         F0            push	-$10[bp]
23378                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
23379 66F9           FF76         FA            push	-6[bp]
23380 66FC           FF76         F8            push	-8[bp]
23381                                           ! Debug: list unsigned long lba_low = [S+$2E-6] (used reg = )
23382 66FF           FF76         FE            push	-2[bp]
23383 6702           FF76         FC            push	-4[bp]
23384                                           ! Debug: list int = const 0 (used reg = )
23385 6705           31C0                       xor	ax,ax
23386 6707           50                         push	ax
23387                                           ! Debug: list int = const 0 (used reg = )
23388 6708           31C0                       xor	ax,ax
23389 670A           50                         push	ax
23390                                           ! Debug: list int = const 0 (used reg = )
23391 670B           31C0                       xor	ax,ax
23392 670D           50                         push	ax
23393                                           ! Debug: list unsigned short count = [S+$38-$24] (used reg = )
23394 670E           FF76         DE            push	-$22[bp]
23395                                           ! Debug: list int = const $20 (used reg = )
23396 6711           B8                   0020  mov	ax,*$20
23397 6714           50                         push	ax
23398                                           ! Debug: list unsigned char device = [S+$3C-$25] (used reg = )
23399 6715           8A46         DD            mov	al,-$23[bp]
23400 6718           30E4                       xor	ah,ah
23401 671A           50                         push	ax
23402                                           ! Debug: list int = const 0 (used reg = )
23403 671B           31C0                       xor	ax,ax
23404 671D           50                         push	ax
23405                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
23406 671E           E8         C268            call	_ata_cmd_data_io
23407 6721           83C4                   1A  add	sp,*$1A
23408                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$26-$26] (used reg = )
23409 6724           8846         DC            mov	-$24[bp],al
23410                                           !BCC_EOS
23411                                           ! 4065       else
23412                                           ! 4066         status=ata_cmd_data_io(1, device, 0x30, count, 0, 0, 0, lba_low, lba_high, segment, offset);
23413 6727           EB           35            jmp .594
23414                       00006729            .592:
23415                                           ! Debug: list unsigned short offset = [S+$26-$14] (used reg = )
23416 6729           FF76         EE            push	-$12[bp]
23417                                           ! Debug: list unsigned short segment = [S+$28-$12] (used reg = )
23418 672C           FF76         F0            push	-$10[bp]
23419                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
23420 672F           FF76         FA            push	-6[bp]
23421 6732           FF76         F8            push	-8[bp]
23422                                           ! Debug: list unsigned long lba_low = [S+$2E-6] (used reg = )
23423 6735           FF76         FE            push	-2[bp]
23424 6738           FF76         FC            push	-4[bp]
23425                                           ! Debug: list int = const 0 (used reg = )
23426 673B           31C0                       xor	ax,ax
23427 673D           50                         push	ax
23428                                           ! Debug: list int = const 0 (used reg = )
23429 673E           31C0                       xor	ax,ax
23430 6740           50                         push	ax
23431                                           ! Debug: list int = const 0 (used reg = )
23432 6741           31C0                       xor	ax,ax
23433 6743           50                         push	ax
23434                                           ! Debug: list unsigned short count = [S+$38-$24] (used reg = )
23435 6744           FF76         DE            push	-$22[bp]
23436                                           ! Debug: list int = const $30 (used reg = )
23437 6747           B8                   0030  mov	ax,*$30
23438 674A           50                         push	ax
23439                                           ! Debug: list unsigned char device = [S+$3C-$25] (used reg = )
23440 674B           8A46         DD            mov	al,-$23[bp]
23441 674E           30E4                       xor	ah,ah
23442 6750           50                         push	ax
23443                                           ! Debug: list int = const 1 (used reg = )
23444 6751           B8                   0001  mov	ax,*1
23445 6754           50                         push	ax
23446                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
23447 6755           E8         C231            call	_ata_cmd_data_io
23448 6758           83C4                   1A  add	sp,*$1A
23449                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$26-$26] (used reg = )
23450 675B           8846         DC            mov	-$24[bp],al
23451                                           !BCC_EOS
23452                                           ! 4067       count=*((Bit16u *)(&((ebda_data_t *) 0)->ata.trsfsectors));
23453                       0000675E            .594:
23454                                           ! Debug: eq unsigned short = [+$254] to unsigned short count = [S+$26-$24] (used reg = )
23455 675E           A1         0254            mov	ax,[$254]
23456 6761           8946         DE            mov	-$22[bp],ax
23457                                           !BCC_EOS
23458                                           ! 4068       _write_word(count, SI+(Bit16u)&((int13ext_t *) 0)->count, DS);
23459                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23460 6764           FF76         06            push	6[bp]
23461                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$28+$A] (used reg = )
23462 6767           8B46         0C            mov	ax,$C[bp]
23463                                           ! Debug: list unsigned int = ax+2 (used reg = )
23464 676A           40                         inc	ax
23465 676B           40                         inc	ax
23466 676C           50                         push	ax
23467                                           ! Debug: list unsigned short count = [S+$2A-$24] (used reg = )
23468 676D           FF76         DE            push	-$22[bp]
23469                                           ! Debug: func () void = _write_word+0 (used reg = )
23470 6770           E8         9EA0            call	__write_word
23471 6773           83C4                   06  add	sp,*6
23472                                           !BCC_EOS
23473                                           ! 4069       if (status != 0) {
23474                                           ! Debug: ne int = const 0 to unsigned char status = [S+$26-$26] (used reg = )
23475 6776           8A46         DC            mov	al,-$24[bp]
23476 6779           84C0                       test	al,al
23477 677B           74           25            je  	.595
23478                       0000677D            .596:
23479                                           ! 4070         bios_printf(4, "int13_harddisk: function %02x, error %02x !\n",*(((Bit8u *)&AX)+1),status);
23480                                           ! Debug: list unsigned char status = [S+$26-$26] (used reg = )
23481 677D           8A46         DC            mov	al,-$24[bp]
23482 6780           30E4                       xor	ah,ah
23483 6782           50                         push	ax
23484                                           ! Debug: list unsigned char AX = [S+$28+$17] (used reg = )
23485 6783           8A46         19            mov	al,$19[bp]
23486 6786           30E4                       xor	ah,ah
23487 6788           50                         push	ax
23488                                           ! Debug: list * char = .597+0 (used reg = )
23489 6789           BB                   D0B7  mov	bx,#.597
23490 678C           53                         push	bx
23491                                           ! Debug: list int = const 4 (used reg = )
23492 678D           B8                   0004  mov	ax,*4
23493 6790           50                         push	ax
23494                                           ! Debug: func () void = bios_printf+0 (used reg = )
23495 6791           E8         A1AA            call	_bios_printf
23496 6794           83C4                   08  add	sp,*8
23497                                           !BCC_EOS
23498                                           ! 4071         *(((Bit8u *)&AX)+1) = (0x0c);
23499                                           ! Debug: eq int = const $C to unsigned char AX = [S+$26+$17] (used reg = )
23500 6797           B0                     0C  mov	al,*$C
23501 6799           8846         19            mov	$19[bp],al
23502                                           !BCC_EOS
23503                                           ! 4072         goto int13_fail_noah;
23504 679C           83C4                   00  add	sp,#..FFEC-..FFF0
23505 679F           E9         012A            br 	.FFEC
23506                                           !BCC_EOS
23507                                           ! 4073       }
23508                                           ! 4074       goto int13_success;
23509                       000067A2            .595:
23510 67A2           83C4                   00  add	sp,#..FFEF-..FFF0
23511 67A5           E9         0144            br 	.FFEF
23512                                           !BCC_EOS
23513                                           ! 4075       break;
23514 67A8           E9         011C            br 	.55B
23515                                           !BCC_EOS
23516                                           ! 4076     case 0x45:
23517                                           ! 4077     case 0x49:
23518                       000067AB            .598:
23519                                           ! 4078       goto int13_success;
23520                       000067AB            .599:
23521 67AB           83C4                   00  add	sp,#..FFEF-..FFF0
23522 67AE           E9         013B            br 	.FFEF
23523                                           !BCC_EOS
23524                                           ! 4079       break;
23525 67B1           E9         0113            br 	.55B
23526                                           !BCC_EOS
23527                                           ! 4080     case 0x46:
23528                                           ! 4081       *(((Bit8u *)&AX)+1) = (0xb2);
23529                       000067B4            .59A:
23530                                           ! Debug: eq int = const $B2 to unsigned char AX = [S+$26+$17] (used reg = )
23531 67B4           B0                     B2  mov	al,#$B2
23532 67B6           8846         19            mov	$19[bp],al
23533                                           !BCC_EOS
23534                                           ! 4082       goto int13
23535                                           ! 4082 _fail_noah;
23536 67B9           83C4                   00  add	sp,#..FFEC-..FFF0
23537 67BC           E9         010D            br 	.FFEC
23538                                           !BCC_EOS
23539                                           ! 4083       break;
23540 67BF           E9         0105            br 	.55B
23541                                           !BCC_EOS
23542                                           ! 4084     case 0x48:
23543                                           ! 4085       if (int13_edd(DS, SI, device))
23544                       000067C2            .59B:
23545                                           ! Debug: list unsigned char device = [S+$26-$25] (used reg = )
23546 67C2           8A46         DD            mov	al,-$23[bp]
23547 67C5           30E4                       xor	ah,ah
23548 67C7           50                         push	ax
23549                                           ! Debug: list unsigned short SI = [S+$28+$A] (used reg = )
23550 67C8           FF76         0C            push	$C[bp]
23551                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
23552 67CB           FF76         06            push	6[bp]
23553                                           ! Debug: func () int = int13_edd+0 (used reg = )
23554 67CE           E8         F315            call	_int13_edd
23555 67D1           83C4                   06  add	sp,*6
23556 67D4           85C0                       test	ax,ax
23557 67D6           74           06            je  	.59C
23558                       000067D8            .59D:
23559                                           ! 4086         goto int13_fail;
23560 67D8           83C4                   00  add	sp,#..FFF1-..FFF0
23561 67DB           E9         00E9            br 	.FFF1
23562                                           !BCC_EOS
23563                                           ! 4087       goto int13_success;
23564                       000067DE            .59C:
23565 67DE           83C4                   00  add	sp,#..FFEF-..FFF0
23566 67E1           E9         0108            br 	.FFEF
23567                                           !BCC_EOS
23568                                           ! 4088       break;
23569 67E4           E9         00E0            br 	.55B
23570                                           !BCC_EOS
23571                                           ! 4089     case 0x4e:
23572                                           ! 4090       switch (( AX & 0x00ff )) {
23573                       000067E7            .59E:
23574                                           ! Debug: and int = const $FF to unsigned short AX = [S+$26+$16] (used reg = )
23575 67E7           8A46         18            mov	al,$18[bp]
23576 67EA           EB           10            jmp .5A1
23577                                           ! 4091         case 0x01:
23578                                           ! 4092         case 0x03:
23579                       000067EC            .5A2:
23580                                           ! 4093         case 0x04:
23581                       000067EC            .5A3:
23582                                           ! 4094         case 0x06:
23583                       000067EC            .5A4:
23584                                           ! 4095           goto int13_success;
23585                       000067EC            .5A5:
23586 67EC           83C4                   00  add	sp,#..FFEF-..FFF0
23587 67EF           E9         00FA            br 	.FFEF
23588                                           !BCC_EOS
23589                                           ! 4096           break;
23590 67F2           EB           1A            jmp .59F
23591                                           !BCC_EOS
23592                                           ! 4097         default:
23593                                           ! 4098           goto int13_fail;
23594                       000067F4            .5A6:
23595 67F4           83C4                   00  add	sp,#..FFF1-..FFF0
23596 67F7           E9         00CD            br 	.FFF1
23597                                           !BCC_EOS
23598                                           ! 4099       }
23599                                           ! 4100       break;
23600 67FA           EB           12            jmp .59F
23601                       000067FC            .5A1:
23602 67FC           2C                     01  sub	al,*1
23603 67FE           74           EC            je 	.5A2
23604 6800           2C                     02  sub	al,*2
23605 6802           74           E8            je 	.5A3
23606 6804           2C                     01  sub	al,*1
23607 6806           74           E4            je 	.5A4
23608 6808           2C                     02  sub	al,*2
23609 680A           74           E0            je 	.5A5
23610 680C           EB           E6            jmp	.5A6
23611                       0000680E            .59F:
23612 680E           E9         00B6            br 	.55B
23613                                           !BCC_EOS
23614                                           ! 4101     case 0x09:
23615                                           ! 4102     case 0x0c:
23616                       00006811            .5A7:
23617                                           ! 4103     case 0x0d:
23618                       00006811            .5A8:
23619                                           ! 4104     case 0x11:
23620                       00006811            .5A9:
23621                                           ! 4105     case 0x14:
23622                       00006811            .5AA:
23623                                           ! 4106       bios_printf(4, "int13_harddisk: function %02xh unimplemented, returns success\n", *(((Bit8u *)&AX)+1));
23624                       00006811            .5AB:
23625                                           ! Debug: list unsigned char AX = [S+$26+$17] (used reg = )
23626 6811           8A46         19            mov	al,$19[bp]
23627 6814           30E4                       xor	ah,ah
23628 6816           50                         push	ax
23629                                           ! Debug: list * char = .5AC+0 (used reg = )
23630 6817           BB                   D078  mov	bx,#.5AC
23631 681A           53                         push	bx
23632                                           ! Debug: list int = const 4 (used reg = )
23633 681B           B8                   0004  mov	ax,*4
23634 681E           50                         push	ax
23635                                           ! Debug: func () void = bios_printf+0 (used reg = )
23636 681F           E8         A11C            call	_bios_printf
23637 6822           83C4                   06  add	sp,*6
23638                                           !BCC_EOS
23639                                           ! 4107       goto int13_success;
23640 6825           83C4                   00  add	sp,#..FFEF-..FFF0
23641 6828           E9         00C1            br 	.FFEF
23642                                           !BCC_EOS
23643                                           ! 4108       break;
23644 682B           E9         0099            br 	.55B
23645                                           !BCC_EOS
23646                                           ! 4109     case 0x0a:
23647                                           ! 4110     case 0x0b:
23648                       0000682E            .5AD:
23649                                           ! 4111     case 0x18:
23650                       0000682E            .5AE:
23651                                           ! 4112     case 0x50:
23652                       0000682E            .5AF:
23653                                           ! 4113     default:
23654                       0000682E            .5B0:
23655                                           ! 4114       bios_printf(4, "int13_harddisk: function %02xh unsupported, returns fail\n", *(((Bit8u *)&AX)+1));
23656                       0000682E            .5B1:
23657                                           ! Debug: list unsigned char AX = [S+$26+$17] (used reg = )
23658 682E           8A46         19            mov	al,$19[bp]
23659 6831           30E4                       xor	ah,ah
23660 6833           50                         push	ax
23661                                           ! Debug: list * char = .5B2+0 (used reg = )
23662 6834           BB                   D03E  mov	bx,#.5B2
23663 6837           53                         push	bx
23664                                           ! Debug: list int = const 4 (used reg = )
23665 6838           B8                   0004  mov	ax,*4
23666 683B           50                         push	ax
23667                                           ! Debug: func () void = bios_printf+0 (used reg = )
23668 683C           E8         A0FF            call	_bios_printf
23669 683F           83C4                   06  add	sp,*6
23670                                           !BCC_EOS
23671                                           ! 4115       goto int13_fail;
23672 6842           83C4                   00  add	sp,#..FFF1-..FFF0
23673 6845           E9         007F            jmp .FFF1
23674                                           !BCC_EOS
23675                                           ! 4116       break;
23676 6848           EB           7D            jmp .55B
23677                                           !BCC_EOS
23678                                           ! 4117   }
23679                                           ! 4118 int13_fail:
23680 684A           EB           7B            jmp .55B
23681                       0000684C            .55D:
23682 684C           2C                     00  sub	al,*0
23683 684E           72           DE            jb 	.5B1
23684 6850           3C                     18  cmp	al,*$18
23685 6852           77           3D            ja  	.5B3
23686 6854           30E4                       xor	ah,ah
23687 6856           D1E0                       shl	ax,*1
23688 6858           89C3                       mov	bx,ax
23689 685A           2E                         seg	cs
23690 685B           FFA7       685F            br	.5B4[bx]
23691                       0000685F            .5B4:
23692 685F                      61DE            .word	.55E
23693 6861                      61F2            .word	.55F
23694 6863                      6232            .word	.563
23695 6865                      6232            .word	.564
23696 6867                      6232            .word	.565
23697 6869                      6478            .word	.57B
23698 686B                      682E            .word	.5B1
23699 686D                      682E            .word	.5B1
23700 686F                      6493            .word	.57D
23701 6871                      6811            .word	.5A7
23702 6873                      682E            .word	.5AD
23703 6875                      682E            .word	.5AE
23704 6877                      6811            .word	.5A8
23705 6879                      6811            .word	.5A9
23706 687B                      682E            .word	.5B1
23707 687D                      682E            .word	.5B1
23708 687F                      6513            .word	.57E
23709 6881                      6811            .word	.5AA
23710 6883                      682E            .word	.5B1
23711 6885                      682E            .word	.5B1
23712 6887                      6811            .word	.5AB
23713 6889                      654F            .word	.582
23714 688B                      682E            .word	.5B1
23715 688D                      682E            .word	.5B1
23716 688F                      682E            .word	.5AF
23717                       00006891            .5B3:
23718 6891           2C                     41  sub	al,*$41
23719 6893           72           99            jb 	.5B1
23720 6895           3C                     0F  cmp	al,*$F
23721 6897           77           2B            ja  	.5B5
23722 6899           30E4                       xor	ah,ah
23723 689B           D1E0                       shl	ax,*1
23724 689D           89C3                       mov	bx,ax
23725 689F           2E                         seg	cs
23726 68A0           FFA7       68A4            br	.5B6[bx]
23727                       000068A4            .5B6:
23728 68A4                      65CE            .word	.583
23729 68A6                      65E8            .word	.584
23730 68A8                      65E8            .word	.585
23731 68AA                      65E8            .word	.586
23732 68AC                      67AB            .word	.598
23733 68AE                      67B4            .word	.59A
23734 68B0                      65E8            .word	.587
23735 68B2                      67C2            .word	.59B
23736 68B4                      67AB            .word	.599
23737 68B6                      682E            .word	.5B1
23738 68B8                      682E            .word	.5B1
23739 68BA                      682E            .word	.5B1
23740 68BC                      682E            .word	.5B1
23741 68BE                      67E7            .word	.59E
23742 68C0                      682E            .word	.5B1
23743 68C2                      682E            .word	.5B0
23744                       000068C4            .5B5:
23745 68C4           E9         FF67            br 	.5B1
23746                       000068C7            .55B:
23747                       FFFFFFDA            ..FFF0	=	-$26
23748                       000068C7            .FFF1:
23749                       FFFFFFDA            ..FFF1	=	-$26
23750                                           ! 4119   *(((Bit8u *)&AX)+1) = (0x01);
23751                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$26+$17] (used reg = )
23752 68C7           B0                     01  mov	al,*1
23753 68C9           8846         19            mov	$19[bp],al
23754                                           !BCC_EOS
23755                                           ! 4120 int13_fail_noah:
23756                       000068CC            .FFEC:
23757                       FFFFFFDA            ..FFEC	=	-$26
23758                                           ! 4121   _write_byte(*(((Bit8u *)&AX)+1), 0x0074, 0x0040);
23759                                           ! Debug: list int = const $40 (used reg = )
23760 68CC           B8                   0040  mov	ax,*$40
23761 68CF           50                         push	ax
23762                                           ! Debug: list int = const $74 (used reg = )
23763 68D0           B8                   0074  mov	ax,*$74
23764 68D3           50                         push	ax
23765                                           ! Debug: list unsigned char AX = [S+$2A+$17] (used reg = )
23766 68D4           8A46         19            mov	al,$19[bp]
23767 68D7           30E4                       xor	ah,ah
23768 68D9           50                         push	ax
23769                                           ! Debug: func () void = _write_byte+0 (used reg = )
23770 68DA           E8         9D23            call	__write_byte
23771 68DD           83C4                   06  add	sp,*6
23772                                           !BCC_EOS
23773                                           ! 4122 int13_fail_nostatus:
23774                       000068E0            .FFEE:
23775                       FFFFFFDA            ..FFEE	=	-$26
23776                                           ! 4123   FLAGS |= 0x0001;
23777                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$26+$1C] (used reg = )
23778 68E0           8B46         1E            mov	ax,$1E[bp]
23779 68E3           0C                     01  or	al,*1
23780 68E5           8946         1E            mov	$1E[bp],ax
23781                                           !BCC_EOS
23782                                           ! 4124   return;
23783 68E8           89EC                       mov	sp,bp
23784 68EA           5D                         pop	bp
23785 68EB           C3                         ret
23786                                           !BCC_EOS
23787                                           ! 4125 int13_success:
23788                       000068EC            .FFEF:
23789                       FFFFFFDA            ..FFEF	=	-$26
23790                                           ! 4126   *(((Bit8u *)&AX)+1) = (0x00);
23791                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$26+$17] (used reg = )
23792 68EC           30C0                       xor	al,al
23793 68EE           8846         19            mov	$19[bp],al
23794                                           !BCC_EOS
23795                                           ! 4127 int13_success_noah:
23796                       000068F1            .FFED:
23797                       FFFFFFDA            ..FFED	=	-$26
23798                                           ! 4128   _write_byte(0x00, 0x0074, 0x0040);
23799                                           ! Debug: list int = const $40 (used reg = )
23800 68F1           B8                   0040  mov	ax,*$40
23801 68F4           50                         push	ax
23802                                           ! Debug: list int = const $74 (used reg = )
23803 68F5           B8                   0074  mov	ax,*$74
23804 68F8           50                         push	ax
23805                                           ! Debug: list int = const 0 (used reg = )
23806 68F9           31C0                       xor	ax,ax
23807 68FB           50                         push	ax
23808                                           ! Debug: func () void = _write_byte+0 (used reg = )
23809 68FC           E8         9D01            call	__write_byte
23810 68FF           83C4                   06  add	sp,*6
23811                                           !BCC_EOS
23812                                           ! 4129   FLAGS &= 0xfffe;
23813                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$26+$1C] (used reg = )
23814 6902           8B46         1E            mov	ax,$1E[bp]
23815 6905           24                     FE  and	al,#$FE
23816 6907           8946         1E            mov	$1E[bp],ax
23817                                           !BCC_EOS
23818                                           ! 4130 }
23819 690A           89EC                       mov	sp,bp
23820 690C           5D                         pop	bp
23821 690D           C3                         ret
23822                                           ! 4131   void
23823                                           ! Register BX used in function int13_harddisk
23824                                           ! 4132 int13_cdrom(EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
23825                                           ! 4133   Bit16u EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
23826                                           export	_int13_cdrom
23827                       0000690E            _int13_cdrom:
23828                                           !BCC_EOS
23829                                           ! 4134 {
23830                                           ! 4135   Bit8u device, status, locks;
23831                                           !BCC_EOS
23832                                           ! 4136   Bit8u atacmd[12];
23833                                           !BCC_EOS
23834                                           ! 4137   Bit32u lba;
23835                                           !BCC_EOS
23836                                           ! 4138   Bit16u count, segment, offset, i, size;
23837                                           !BCC_EOS
23838                                           ! 4139   ;
23839 690E           55                         push	bp
23840 690F           89E5                       mov	bp,sp
23841 6911           83C4                   E2  add	sp,*-$1E
23842                                           !BCC_EOS
23843                                           ! 4140   _write_byte(0x00, 0x0074, 0x0040);
23844                                           ! Debug: list int = const $40 (used reg = )
23845 6914           B8                   0040  mov	ax,*$40
23846 6917           50                         push	ax
23847                                           ! Debug: list int = const $74 (used reg = )
23848 6918           B8                   0074  mov	ax,*$74
23849 691B           50                         push	ax
23850                                           ! Debug: list int = const 0 (used reg = )
23851 691C           31C0                       xor	ax,ax
23852 691E           50                         push	ax
23853                                           ! Debug: func () void = _write_byte+0 (used reg = )
23854 691F           E8         9CDE            call	__write_byte
23855 6922           83C4                   06  add	sp,*6
23856                                           !BCC_EOS
23857                                           ! 4141   if( (( ELDX & 0x00ff ) < 0xE0) || (( ELDX & 0x00ff ) >= 0xE0+(4*2)) ) {
23858                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$E] (used reg = )
23859 6925           8A46         10            mov	al,$10[bp]
23860                                           ! Debug: lt int = const $E0 to unsigned char = al+0 (used reg = )
23861 6928           3C                     E0  cmp	al,#$E0
23862 692A           72           07            jb  	.5B8
23863                       0000692C            .5B9:
23864                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$E] (used reg = )
23865 692C           8A46         10            mov	al,$10[bp]
23866                                           ! Debug: ge int = const $E8 to unsigned char = al+0 (used reg = )
23867 692F           3C                     E8  cmp	al,#$E8
23868 6931           72           20            jb  	.5B7
23869                       00006933            .5B8:
23870                                           ! 4142     bios_printf(4, "int13_cdrom: function %02x, ELDL out of range %02x\n", *(((Bit8u *)&AX)+1), ( ELDX & 0x00ff ));
23871                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$E] (used reg = )
23872 6933           8A46         10            mov	al,$10[bp]
23873                                           ! Debug: list unsigned char = al+0 (used reg = )
23874 6936           30E4                       xor	ah,ah
23875 6938           50                         push	ax
23876                                           ! Debug: list unsigned char AX = [S+$22+$17] (used reg = )
23877 6939           8A46         19            mov	al,$19[bp]
23878 693C           30E4                       xor	ah,ah
23879 693E           50                         push	ax
23880                                           ! Debug: list * char = .5BA+0 (used reg = )
23881 693F           BB                   D00A  mov	bx,#.5BA
23882 6942           53                         push	bx
23883                                           ! Debug: list int = const 4 (used reg = )
23884 6943           B8                   0004  mov	ax,*4
23885 6946           50                         push	ax
23886                                           ! Debug: func () void = bios_printf+0 (used reg = )
23887 6947           E8         9FF4            call	_bios_printf
23888 694A           83C4                   08  add	sp,*8
23889                                           !BCC_EOS
23890                                           ! 4143     goto int13_fail;
23891 694D           83C4                   00  add	sp,#..FFEB+$20
23892 6950           E9         0469            br 	.FFEB
23893                                           !BCC_EOS
23894                                           ! 4144   }
23895                                           ! 4145   device=*((Bit8u *)(&((ebda_data_t *) 0)->ata.cdidmap[( ELDX & 0x00ff )-0xE0]));
23896                       00006953            .5B7:
23897                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$E] (used reg = )
23898 6953           8A46         10            mov	al,$10[bp]
23899                                           ! Debug: sub int = const $E0 to unsigned char = al+0 (used reg = )
23900 6956           30E4                       xor	ah,ah
23901                                           ! Debug: ptradd unsigned int = ax-$E0 to [8] unsigned char = const $23C (used reg = )
23902 6958           05                   FF20  add	ax,#-$E0
23903 695B           89C3                       mov	bx,ax
23904                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
23905                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$23C (used reg = )
23906                                           ! Debug: eq unsigned char = [bx+$23C] to unsigned char device = [S+$20-3] (used reg = )
23907 695D           8A87       023C            mov	al,$23C[bx]
23908 6961           8846         FF            mov	-1[bp],al
23909                                           !BCC_EOS
23910                                           ! 4146   if (device >= (4*2)) {
23911                                           ! Debug: ge int = const 8 to unsigned char device = [S+$20-3] (used reg = )
23912 6964           8A46         FF            mov	al,-1[bp]
23913 6967           3C                     08  cmp	al,*8
23914 6969           72           20            jb  	.5BB
23915                       0000696B            .5BC:
23916                                           ! 4147     bios_printf(4, "int13_cdrom: function %02x, unmapped device for ELDL=%02x\n", *(((Bit8u *)&AX)+1), ( ELDX & 0x00ff ));
23917                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$E] (used reg = )
23918 696B           8A46         10            mov	al,$10[bp]
23919                                           ! Debug: list unsigned char = al+0 (used reg = )
23920 696E           30E4                       xor	ah,ah
23921 6970           50                         push	ax
23922                                           ! Debug: list unsigned char AX = [S+$22+$17] (used reg = )
23923 6971           8A46         19            mov	al,$19[bp]
23924 6974           30E4                       xor	ah,ah
23925 6976           50                         push	ax
23926                                           ! Debug: list * char = .5BD+0 (used reg = )
23927 6977           BB                   CFCF  mov	bx,#.5BD
23928 697A           53                         push	bx
23929                                           ! Debug: list int = const 4 (used reg = )
23930 697B           B8                   0004  mov	ax,*4
23931 697E           50                         push	ax
23932                                           ! Debug: func () void = bios_printf+0 (used reg = )
23933 697F           E8         9FBC            call	_bios_printf
23934 6982           83C4                   08  add	sp,*8
23935                                           !BCC_EOS
23936                                           ! 4148     goto int13_fail;
23937 6985           83C4                   00  add	sp,#..FFEB+$20
23938 6988           E9         0431            br 	.FFEB
23939                                           !BCC_EOS
23940                                           ! 4149   }
23941                                           ! 4150   switch (*(((Bit8u *)&AX)+1)) {
23942                       0000698B            .5BB:
23943 698B           8A46         19            mov	al,$19[bp]
23944 698E           E9         03B0            br 	.5C0
23945                                           ! 4151     case 0x00:
23946                                           ! 4152     case 0x09:
23947                       00006991            .5C1:
23948                                           ! 4153     case 0x0c:
23949                       00006991            .5C2:
23950                                           ! 4154     case 0x0d:
23951                       00006991            .5C3:
23952                                           ! 4155     case 0x10:
23953                       00006991            .5C4:
23954                                           ! 4156     case 0x11:
23955                       00006991            .5C5:
23956                                           ! 4157     case 0x14:
23957                       00006991            .5C6:
23958                                           ! 4158     case 0x16:
23959                       00006991            .5C7:
23960                                           ! 4159       goto int
23961                       00006991            .5C8:
23962                                           ! 4159 13_success;
23963 6991           83C4                   00  add	sp,#..FFE9-..FFEA
23964 6994           E9         044A            br 	.FFE9
23965                                           !BCC_EOS
23966                                           ! 4160       break;
23967 6997           E9         0422            br 	.5BE
23968                                           !BCC_EOS
23969                                           ! 4161     case 0x03:
23970                                           ! 4162     case 0x05:
23971                       0000699A            .5C9:
23972                                           ! 4163     case 0x43:
23973                       0000699A            .5CA:
23974                                           ! 4164       *(((Bit8u *)&AX)+1) = (0x03);
23975                       0000699A            .5CB:
23976                                           ! Debug: eq int = const 3 to unsigned char AX = [S+$20+$17] (used reg = )
23977 699A           B0                     03  mov	al,*3
23978 699C           8846         19            mov	$19[bp],al
23979                                           !BCC_EOS
23980                                           ! 4165       goto int13_fail_noah;
23981 699F           83C4                   00  add	sp,#..FFE8-..FFEA
23982 69A2           E9         041C            br 	.FFE8
23983                                           !BCC_EOS
23984                                           ! 4166       break;
23985 69A5           E9         0414            br 	.5BE
23986                                           !BCC_EOS
23987                                           ! 4167     case 0x01:
23988                                           ! 4168       status = _read_byte(0x0074, 0x0040);
23989                       000069A8            .5CC:
23990                                           ! Debug: list int = const $40 (used reg = )
23991 69A8           B8                   0040  mov	ax,*$40
23992 69AB           50                         push	ax
23993                                           ! Debug: list int = const $74 (used reg = )
23994 69AC           B8                   0074  mov	ax,*$74
23995 69AF           50                         push	ax
23996                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
23997 69B0           E8         9C31            call	__read_byte
23998 69B3           83C4                   04  add	sp,*4
23999                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$20-4] (used reg = )
24000 69B6           8846         FE            mov	-2[bp],al
24001                                           !BCC_EOS
24002                                           ! 4169       *(((Bit8u *)&AX)+1) = (status);
24003                                           ! Debug: eq unsigned char status = [S+$20-4] to unsigned char AX = [S+$20+$17] (used reg = )
24004 69B9           8A46         FE            mov	al,-2[bp]
24005 69BC           8846         19            mov	$19[bp],al
24006                                           !BCC_EOS
24007                                           ! 4170       _write_byte(0, 0x0074, 0x0040);
24008                                           ! Debug: list int = const $40 (used reg = )
24009 69BF           B8                   0040  mov	ax,*$40
24010 69C2           50                         push	ax
24011                                           ! Debug: list int = const $74 (used reg = )
24012 69C3           B8                   0074  mov	ax,*$74
24013 69C6           50                         push	ax
24014                                           ! Debug: list int = const 0 (used reg = )
24015 69C7           31C0                       xor	ax,ax
24016 69C9           50                         push	ax
24017                                           ! Debug: func () void = _write_byte+0 (used reg = )
24018 69CA           E8         9C33            call	__write_byte
24019 69CD           83C4                   06  add	sp,*6
24020                                           !BCC_EOS
24021                                           ! 4171       if (status) goto int13_fail_nostatus;
24022 69D0           8A46         FE            mov	al,-2[bp]
24023 69D3           84C0                       test	al,al
24024 69D5           74           08            je  	.5CD
24025                       000069D7            .5CE:
24026 69D7           83C4                   00  add	sp,#..FFE7-..FFEA
24027 69DA           E9         03F8            br 	.FFE7
24028                                           !BCC_EOS
24029                                           ! 4172       else goto int13_success_noah;
24030 69DD           EB           06            jmp .5CF
24031                       000069DF            .5CD:
24032 69DF           83C4                   00  add	sp,#..FFE6-..FFEA
24033 69E2           E9         0401            br 	.FFE6
24034                                           !BCC_EOS
24035                                           ! 4173       break;
24036                       000069E5            .5CF:
24037 69E5           E9         03D4            br 	.5BE
24038                                           !BCC_EOS
24039                                           ! 4174     case 0x15:
24040                                           ! 4175       *(((Bit8u *)&AX)+1) = (0x02);
24041                       000069E8            .5D0:
24042                                           ! Debug: eq int = const 2 to unsigned char AX = [S+$20+$17] (used reg = )
24043 69E8           B0                     02  mov	al,*2
24044 69EA           8846         19            mov	$19[bp],al
24045                                           !BCC_EOS
24046                                           ! 4176       goto int13_fail_noah;
24047 69ED           83C4                   00  add	sp,#..FFE8-..FFEA
24048 69F0           E9         03CE            br 	.FFE8
24049                                           !BCC_EOS
24050                                           ! 4177       break;
24051 69F3           E9         03C6            br 	.5BE
24052                                           !BCC_EOS
24053                                           ! 4178     case 0x41:
24054                                           ! 4179       BX=0xaa55;
24055                       000069F6            .5D1:
24056                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$20+$10] (used reg = )
24057 69F6           B8                   AA55  mov	ax,#$AA55
24058 69F9           8946         12            mov	$12[bp],ax
24059                                           !BCC_EOS
24060                                           ! 4180       *(((Bit8u *)&AX)+1) = (0x30);
24061                                           ! Debug: eq int = const $30 to unsigned char AX = [S+$20+$17] (used reg = )
24062 69FC           B0                     30  mov	al,*$30
24063 69FE           8846         19            mov	$19[bp],al
24064                                           !BCC_EOS
24065                                           ! 4181       CX=0x0007;
24066                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$20+$14] (used reg = )
24067 6A01           B8                   0007  mov	ax,*7
24068 6A04           8946         16            mov	$16[bp],ax
24069                                           !BCC_EOS
24070                                           ! 4182       goto int13_success_noah;
24071 6A07           83C4                   00  add	sp,#..FFE6-..FFEA
24072 6A0A           E9         03D9            br 	.FFE6
24073                                           !BCC_EOS
24074                                           ! 4183       break;
24075 6A0D           E9         03AC            br 	.5BE
24076                                           !BCC_EOS
24077                                           ! 4184     case 0x42:
24078                                           ! 4185     case 0x44:
24079                       00006A10            .5D2:
24080                                           ! 4186     case 0x47:
24081                       00006A10            .5D3:
24082                                           ! 4187       count=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->count, DS);
24083                       00006A10            .5D4:
24084                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24085 6A10           FF76         06            push	6[bp]
24086                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$22+$A] (used reg = )
24087 6A13           8B46         0C            mov	ax,$C[bp]
24088                                           ! Debug: list unsigned int = ax+2 (used reg = )
24089 6A16           40                         inc	ax
24090 6A17           40                         inc	ax
24091 6A18           50                         push	ax
24092                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
24093 6A19           E8         9BD6            call	__read_word
24094 6A1C           83C4                   04  add	sp,*4
24095                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$20-$18] (used reg = )
24096 6A1F           8946         EA            mov	-$16[bp],ax
24097                                           !BCC_EOS
24098                                           ! 4188       segment=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->segment, DS);
24099                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24100 6A22           FF76         06            push	6[bp]
24101                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$22+$A] (used reg = )
24102 6A25           8B46         0C            mov	ax,$C[bp]
24103                                           ! Debug: list unsigned int = ax+6 (used reg = )
24104 6A28           05                   0006  add	ax,*6
24105 6A2B           50                         push	ax
24106                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
24107 6A2C           E8         9BC3            call	__read_word
24108 6A2F           83C4                   04  add	sp,*4
24109                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$20-$1A] (used reg = )
24110 6A32           8946         E8            mov	-$18[bp],ax
24111                                           !BCC_EOS
24112                                           ! 4189       offset=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->offset, DS);
24113                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24114 6A35           FF76         06            push	6[bp]
24115                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$22+$A] (used reg = )
24116 6A38           8B46         0C            mov	ax,$C[bp]
24117                                           ! Debug: list unsigned int = ax+4 (used reg = )
24118 6A3B           05                   0004  add	ax,*4
24119 6A3E           50                         push	ax
24120                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
24121 6A3F           E8         9BB0            call	__read_word
24122 6A42           83C4                   04  add	sp,*4
24123                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$20-$1C] (used reg = )
24124 6A45           8946         E6            mov	-$1A[bp],ax
24125                                           !BCC_EOS
24126                                           ! 4190       lba=_read_dword(SI+(Bit16u)&((int13ext_t *) 0)->lba2, DS);
24127                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24128 6A48           FF76         06            push	6[bp]
24129                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$22+$A] (used reg = )
24130 6A4B           8B46         0C            mov	ax,$C[bp]
24131                                           ! Debug: list unsigned int = ax+$C (used reg = )
24132 6A4E           05                   000C  add	ax,*$C
24133 6A51           50                         push	ax
24134                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
24135 6A52           E8         9601            call	__read_dword
24136 6A55           89D3                       mov	bx,dx
24137 6A57           83C4                   04  add	sp,*4
24138                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$20-$16] (used reg = )
24139 6A5A           8946         EC            mov	-$14[bp],ax
24140 6A5D           895E         EE            mov	-$12[bp],bx
24141                                           !BCC_EOS
24142                                           ! 4191       if (lba != 0L) {
24143                                           ! Debug: ne long = const 0 to unsigned long lba = [S+$20-$16] (used reg = )
24144                                           ! Debug: expression subtree swapping
24145 6A60           31C0                       xor	ax,ax
24146 6A62           31DB                       xor	bx,bx
24147 6A64           53                         push	bx
24148 6A65           50                         push	ax
24149 6A66           8B46         EC            mov	ax,-$14[bp]
24150 6A69           8B5E         EE            mov	bx,-$12[bp]
24151 6A6C           8D7E         DE            lea	di,-2+..FFEA[bp]
24152 6A6F           E8         962A            call	lcmpul
24153 6A72           8D66         E2            lea	sp,2+..FFEA[bp]
24154 6A75           74           1A            je  	.5D5
24155                       00006A77            .5D6:
24156                                           ! 4192         bios_printf((2 | 4 | 1), "int13_cdrom: function %02x. Can't use 64bits lba\n",*(((Bit8u *)&AX)+1));
24157                                           ! Debug: list unsigned char AX = [S+$20+$17] (used reg = )
24158 6A77           8A46         19            mov	al,$19[bp]
24159 6A7A           30E4                       xor	ah,ah
24160 6A7C           50                         push	ax
24161                                           ! Debug: list * char = .5D7+0 (used reg = )
24162 6A7D           BB                   CF9D  mov	bx,#.5D7
24163 6A80           53                         push	bx
24164                                           ! Debug: list int = const 7 (used reg = )
24165 6A81           B8                   0007  mov	ax,*7
24166 6A84           50                         push	ax
24167                                           ! Debug: func () void = bios_printf+0 (used reg = )
24168 6A85           E8         9EB6            call	_bios_printf
24169 6A88           83C4                   06  add	sp,*6
24170                                           !BCC_EOS
24171                                           ! 4193         goto int13_fail;
24172 6A8B           83C4                   00  add	sp,#..FFEB-..FFEA
24173 6A8E           E9         032B            br 	.FFEB
24174                                           !BCC_EOS
24175                                           ! 4194       }
24176                                           ! 4195       lba=_read_dword(SI+(Bit16u)&((int13ext_t *) 0)->lba1, DS);
24177                       00006A91            .5D5:
24178                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24179 6A91           FF76         06            push	6[bp]
24180                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$22+$A] (used reg = )
24181 6A94           8B46         0C            mov	ax,$C[bp]
24182                                           ! Debug: list unsigned int = ax+8 (used reg = )
24183 6A97           05                   0008  add	ax,*8
24184 6A9A           50                         push	ax
24185                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
24186 6A9B           E8         95B8            call	__read_dword
24187 6A9E           89D3                       mov	bx,dx
24188 6AA0           83C4                   04  add	sp,*4
24189                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$20-$16] (used reg = )
24190 6AA3           8946         EC            mov	-$14[bp],ax
24191 6AA6           895E         EE            mov	-$12[bp],bx
24192                                           !BCC_EOS
24193                                           ! 4196       if ((*(((Bit8u *)&AX)+1) == 0x44) || (*(((Bit8u *)&AX)+1) == 0x47))
24194                                           ! Debug: logeq int = const $44 to unsigned char AX = [S+$20+$17] (used reg = )
24195 6AA9           8A46         19            mov	al,$19[bp]
24196 6AAC           3C                     44  cmp	al,*$44
24197 6AAE           74           07            je  	.5D9
24198                       00006AB0            .5DA:
24199                                           ! Debug: logeq int = const $47 to unsigned char AX = [S+$20+$17] (used reg = )
24200 6AB0           8A46         19            mov	al,$19[bp]
24201 6AB3           3C                     47  cmp	al,*$47
24202 6AB5           75           06            jne 	.5D8
24203                       00006AB7            .5D9:
24204                                           ! 4197         goto int13_success;
24205 6AB7           83C4                   00  add	sp,#..FFE9-..FFEA
24206 6ABA           E9         0324            br 	.FFE9
24207                                           !BCC_EOS
24208                                           ! 4198       _memsetb(0,atacmd,get_SS(),12);
24209                       00006ABD            .5D8:
24210                                           ! Debug: list int = const $C (used reg = )
24211 6ABD           B8                   000C  mov	ax,*$C
24212 6AC0           50                         push	ax
24213                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
24214 6AC1           E8         9B9B            call	_get_SS
24215                                           ! Debug: list unsigned short = ax+0 (used reg = )
24216 6AC4           50                         push	ax
24217                                           ! Debug: list * unsigned char atacmd = S+$24-$11 (used reg = )
24218 6AC5           8D5E         F1            lea	bx,-$F[bp]
24219 6AC8           53                         push	bx
24220                                           ! Debug: list int = const 0 (used reg = )
24221 6AC9           31C0                       xor	ax,ax
24222 6ACB           50                         push	ax
24223                                           ! Debug: func () void = _memsetb+0 (used reg = )
24224 6ACC           E8         9531            call	__memsetb
24225 6ACF           83C4                   08  add	sp,*8
24226                                           !BCC_EOS
24227                                           ! 4199       atacmd[0]=0x28;
24228                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$20-$11] (used reg = )
24229 6AD2           B0                     28  mov	al,*$28
24230 6AD4           8846         F1            mov	-$F[bp],al
24231                                           !BCC_EOS
24232                                           ! 4200       atacmd[7]=*(((Bit8u *)&count)+1);
24233                                           ! Debug: eq unsigned char count = [S+$20-$17] to unsigned char atacmd = [S+$20-$A] (used reg = )
24234 6AD7           8A46         EB            mov	al,-$15[bp]
24235 6ADA           8846         F8            mov	-8[bp],al
24236                                           !BCC_EOS
24237                                           ! 4201       atacmd[8]=*((Bit8u *)&count);
24238                                           ! Debug: eq unsigned char count = [S+$20-$18] to unsigned char atacmd = [S+$20-9] (used reg = )
24239 6ADD           8A46         EA            mov	al,-$16[bp]
24240 6AE0           8846         F9            mov	-7[bp],al
24241                                           !BCC_EOS
24242                                           ! 4202       atacmd[2]=*(((Bit8u *)&*(((Bit16u *)&lba)+1))+1);
24243                                           ! Debug: eq unsigned char lba = [S+$20-$13] to unsigned char atacmd = [S+$20-$F] (used reg = )
24244 6AE3           8A46         EF            mov	al,-$11[bp]
24245 6AE6           8846         F3            mov	-$D[bp],al
24246                                           !BCC_EOS
24247                                           ! 4203       atacmd[3]=*((Bit8u *)&*(((Bit16u *)&lba)+1));
24248                                           ! Debug: eq unsigned char lba = [S+$20-$14] to unsigned char atacmd = [S+$20-$E] (used reg = )
24249 6AE9           8A46         EE            mov	al,-$12[bp]
24250 6AEC           8846         F4            mov	-$C[bp],al
24251                                           !BCC_EOS
24252                                           ! 4204       atacmd[4]=*(((Bit8u *)&*((Bit16u *)&lba))+1);
24253                                           ! Debug: eq unsigned char lba = [S+$20-$15] to unsigned char atacmd = [S+$20-$D] (used reg = )
24254 6AEF           8A46         ED            mov	al,-$13[bp]
24255 6AF2           8846         F5            mov	-$B[bp],al
24256                                           !BCC_EOS
24257                                           ! 4205       atacmd[5]=*((Bit8u *)&lba);
24258                                           ! Debug: eq unsigned char lba = [S+$20-$16] to unsigned char atacmd = [S+$20-$C] (used reg = )
24259 6AF5           8A46         EC            mov	al,-$14[bp]
24260 6AF8           8846         F6            mov	-$A[bp],al
24261                                           !BCC_EOS
24262                                           ! 4206       status = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, count*2048L, 0x01, segment,offset);
24263                                           ! Debug: list unsigned short offset = [S+$20-$1C] (used reg = )
24264 6AFB           FF76         E6            push	-$1A[bp]
24265                                           ! Debug: list unsigned short segment = [S+$22-$1A] (used reg = )
24266 6AFE           FF76         E8            push	-$18[bp]
24267                                           ! Debug: list int = const 1 (used reg = )
24268 6B01           B8                   0001  mov	ax,*1
24269 6B04           50                         push	ax
24270                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$26-$18] (used reg = )
24271 6B05           8B46         EA            mov	ax,-$16[bp]
24272 6B08           31DB                       xor	bx,bx
24273                                           ! Debug: mul long = const $800 to unsigned long = bx+0 (used reg = )
24274 6B0A           53                         push	bx
24275 6B0B           50                         push	ax
24276 6B0C           B8                   0800  mov	ax,#$800
24277 6B0F           31DB                       xor	bx,bx
24278 6B11           53                         push	bx
24279 6B12           50                         push	ax
24280 6B13           8B46         D8            mov	ax,-8+..FFEA[bp]
24281 6B16           8B5E         DA            mov	bx,-6+..FFEA[bp]
24282 6B19           8D7E         D4            lea	di,-$C+..FFEA[bp]
24283 6B1C           E8         959B            call	lmulul
24284 6B1F           83C4                   08  add	sp,*8
24285                                           ! Debug: list unsigned long = bx+0 (used reg = )
24286 6B22           53                         push	bx
24287 6B23           50                         push	ax
24288                                           ! Debug: list int = const 0 (used reg = )
24289 6B24           31C0                       xor	ax,ax
24290 6B26           50                         push	ax
24291                                           ! Debug: list * unsigned char atacmd = S+$2C-$11 (used reg = )
24292 6B27           8D5E         F1            lea	bx,-$F[bp]
24293 6B2A           53                         push	bx
24294                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
24295 6B2B           E8         9B31            call	_get_SS
24296                                           ! Debug: list unsigned short = ax+0 (used reg = )
24297 6B2E           50                         push	ax
24298                                           ! Debug: list int = const $C (used reg = )
24299 6B2F           B8                   000C  mov	ax,*$C
24300 6B32           50                         push	ax
24301                                           ! Debug: list unsigned char device = [S+$32-3] (used reg = )
24302 6B33           8A46         FF            mov	al,-1[bp]
24303 6B36           30E4                       xor	ah,ah
24304 6B38           50                         push	ax
24305                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
24306 6B39           E8         C212            call	_ata_cmd_packet
24307 6B3C           83C4                   14  add	sp,*$14
24308                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$20-4] (used reg = )
24309 6B3F           8846         FE            mov	-2[bp],al
24310                                           !BCC_EOS
24311                                           ! 4207       count = (Bit16u)(*((Bit32u *)(&((ebda_data_t *) 0)->ata.trsfbytes)) >> 11);
24312                                           ! Debug: sr int = const $B to unsigned long = [+$256] (used reg = )
24313 6B42           A1         0256            mov	ax,[$256]
24314 6B45           8B1E       0258            mov	bx,[$258]
24315 6B49           88E0                       mov	al,ah
24316 6B4B           88DC                       mov	ah,bl
24317 6B4D           88FB                       mov	bl,bh
24318 6B4F           28FF                       sub	bh,bh
24319 6B51           BF                   0003  mov	di,*3
24320 6B54           E8         95A3            call	lsrul
24321                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
24322                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$20-$18] (used reg = )
24323 6B57           8946         EA            mov	-$16[bp],ax
24324                                           !BCC_EOS
24325                                           ! 4208       _write_word(count, SI+(Bit16u)&((int13ext_t *) 0)->count, DS);
24326                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24327 6B5A           FF76         06            push	6[bp]
24328                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$22+$A] (used reg = )
24329 6B5D           8B46         0C            mov	ax,$C[bp]
24330                                           ! Debug: list unsigned int = ax+2 (used reg = )
24331 6B60           40                         inc	ax
24332 6B61           40                         inc	ax
24333 6B62           50                         push	ax
24334                                           ! Debug: list unsigned short count = [S+$24-$18] (used reg = )
24335 6B63           FF76         EA            push	-$16[bp]
24336                                           ! Debug: func () void = _write_word+0 (used reg = )
24337 6B66           E8         9AAA            call	__write_word
24338 6B69           83C4                   06  add	sp,*6
24339                                           !BCC_EOS
24340                                           ! 4209       if (status != 0) {
24341                                           ! Debug: ne int = const 0 to unsigned char status = [S+$20-4] (used reg = )
24342 6B6C           8A46         FE            mov	al,-2[bp]
24343 6B6F           84C0                       test	al,al
24344 6B71           74           25            je  	.5DB
24345                       00006B73            .5DC:
24346                                           ! 4210         bios_printf(4, "int13_cdrom: function %02x, status %02x !\n",*(((Bit8u *)&AX)+1),status);
24347                                           ! Debug: list unsigned char status = [S+$20-4] (used reg = )
24348 6B73           8A46         FE            mov	al,-2[bp]
24349 6B76           30E4                       xor	ah,ah
24350 6B78           50                         push	ax
24351                                           ! Debug: list unsigned char AX = [S+$22+$17] (used reg = )
24352 6B79           8A46         19            mov	al,$19[bp]
24353 6B7C           30E4                       xor	ah,ah
24354 6B7E           50                         push	ax
24355                                           ! Debug: list * char = .5DD+0 (used reg = )
24356 6B7F           BB                   CF72  mov	bx,#.5DD
24357 6B82           53                         push	bx
24358                                           ! Debug: list int = const 4 (used reg = )
24359 6B83           B8                   0004  mov	ax,*4
24360 6B86           50                         push	ax
24361                                           ! Debug: func () void = bios_printf+0 (used reg = )
24362 6B87           E8         9DB4            call	_bios_printf
24363 6B8A           83C4                   08  add	sp,*8
24364                                           !BCC_EOS
24365                                           ! 4211         *(((Bit8u *)&AX)+1) = (0x0c);
24366                                           ! Debug: eq int = const $C to unsigned char AX = [S+$20+$17] (used reg = )
24367 6B8D           B0                     0C  mov	al,*$C
24368 6B8F           8846         19            mov	$19[bp],al
24369                                           !BCC_EOS
24370                                           ! 4212         goto int13_fail_noah;
24371 6B92           83C4                   00  add	sp,#..FFE8-..FFEA
24372 6B95           E9         0229            br 	.FFE8
24373                                           !BCC_EOS
24374                                           ! 4213       }
24375                                           ! 4214       goto int13_success;
24376                       00006B98            .5DB:
24377 6B98           83C4                   00  add	sp,#..FFE9-..FFEA
24378 6B9B           E9         0243            br 	.FFE9
24379                                           !BCC_EOS
24380                                           ! 4215 
24381                                           ! 4215       break;
24382 6B9E           E9         021B            br 	.5BE
24383                                           !BCC_EOS
24384                                           ! 4216     case 0x45:
24385                                           ! 4217       if (( AX & 0x00ff ) > 2) goto int13_fail;
24386                       00006BA1            .5DE:
24387                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$16] (used reg = )
24388 6BA1           8A46         18            mov	al,$18[bp]
24389                                           ! Debug: gt int = const 2 to unsigned char = al+0 (used reg = )
24390 6BA4           3C                     02  cmp	al,*2
24391 6BA6           76           06            jbe 	.5DF
24392                       00006BA8            .5E0:
24393 6BA8           83C4                   00  add	sp,#..FFEB-..FFEA
24394 6BAB           E9         020E            br 	.FFEB
24395                                           !BCC_EOS
24396                                           ! 4218       locks = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].lock));
24397                       00006BAE            .5DF:
24398                                           ! Debug: ptradd unsigned char device = [S+$20-3] to [8] struct  = const $142 (used reg = )
24399 6BAE           8A46         FF            mov	al,-1[bp]
24400 6BB1           30E4                       xor	ah,ah
24401 6BB3           B9                   001E  mov	cx,*$1E
24402 6BB6           F7E9                       imul	cx
24403 6BB8           89C3                       mov	bx,ax
24404                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
24405                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$145 (used reg = )
24406                                           ! Debug: eq unsigned char = [bx+$145] to unsigned char locks = [S+$20-5] (used reg = )
24407 6BBA           8A87       0145            mov	al,$145[bx]
24408 6BBE           8846         FD            mov	-3[bp],al
24409                                           !BCC_EOS
24410                                           ! 4219       switch (( AX & 0x00ff )) {
24411                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$16] (used reg = )
24412 6BC1           8A46         18            mov	al,$18[bp]
24413 6BC4           E9         0095            br 	.5E3
24414                                           ! 4220         case 0 :
24415                                           ! 4221           if (locks == 0xff) {
24416                       00006BC7            .5E4:
24417                                           ! Debug: logeq int = const $FF to unsigned char locks = [S+$20-5] (used reg = )
24418 6BC7           8A46         FD            mov	al,-3[bp]
24419 6BCA           3C                     FF  cmp	al,#$FF
24420 6BCC           75           10            jne 	.5E5
24421                       00006BCE            .5E6:
24422                                           ! 4222             *(((Bit8u *)&AX)+1) = (0xb4);
24423                                           ! Debug: eq int = const $B4 to unsigned char AX = [S+$20+$17] (used reg = )
24424 6BCE           B0                     B4  mov	al,#$B4
24425 6BD0           8846         19            mov	$19[bp],al
24426                                           !BCC_EOS
24427                                           ! 4223             *((Bit8u *)&AX) = (1);
24428                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$20+$16] (used reg = )
24429 6BD3           B0                     01  mov	al,*1
24430 6BD5           8846         18            mov	$18[bp],al
24431                                           !BCC_EOS
24432                                           ! 4224             goto int13_fail_noah;
24433 6BD8           83C4                   00  add	sp,#..FFE8-..FFEA
24434 6BDB           E9         01E3            br 	.FFE8
24435                                           !BCC_EOS
24436                                           ! 4225           }
24437                                           ! 4226           *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].lock)) = (++locks);
24438                       00006BDE            .5E5:
24439                                           ! Debug: preinc unsigned char locks = [S+$20-5] (used reg = )
24440 6BDE           8A46         FD            mov	al,-3[bp]
24441 6BE1           40                         inc	ax
24442 6BE2           8846         FD            mov	-3[bp],al
24443 6BE5           50                         push	ax
24444                                           ! Debug: ptradd unsigned char device = [S+$22-3] to [8] struct  = const $142 (used reg = )
24445 6BE6           8A46         FF            mov	al,-1[bp]
24446 6BE9           30E4                       xor	ah,ah
24447 6BEB           B9                   001E  mov	cx,*$1E
24448 6BEE           F7E9                       imul	cx
24449 6BF0           89C3                       mov	bx,ax
24450                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
24451                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$145 (used reg = )
24452                                           ! Debug: eq unsigned char (temp) = [S+$22-$22] to unsigned char = [bx+$145] (used reg = )
24453 6BF2           8A46         E0            mov	al,0+..FFEA[bp]
24454 6BF5           8887       0145            mov	$145[bx],al
24455 6BF9           44                         inc	sp
24456 6BFA           44                         inc	sp
24457                                           !BCC_EOS
24458                                           ! 4227           *((Bit8u *)&AX) = (1);
24459                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$20+$16] (used reg = )
24460 6BFB           B0                     01  mov	al,*1
24461 6BFD           8846         18            mov	$18[bp],al
24462                                           !BCC_EOS
24463                                           ! 4228           break;
24464 6C00           EB           68            jmp .5E1
24465                                           !BCC_EOS
24466                                           ! 4229         case 1 :
24467                                           ! 4230           if (locks == 0x00) {
24468                       00006C02            .5E7:
24469                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$20-5] (used reg = )
24470 6C02           8A46         FD            mov	al,-3[bp]
24471 6C05           84C0                       test	al,al
24472 6C07           75           10            jne 	.5E8
24473                       00006C09            .5E9:
24474                                           ! 4231             *(((Bit8u *)&AX)+1) = (0xb0);
24475                                           ! Debug: eq int = const $B0 to unsigned char AX = [S+$20+$17] (used reg = )
24476 6C09           B0                     B0  mov	al,#$B0
24477 6C0B           8846         19            mov	$19[bp],al
24478                                           !BCC_EOS
24479                                           ! 4232             *((Bit8u *)&AX) = (0);
24480                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$20+$16] (used reg = )
24481 6C0E           30C0                       xor	al,al
24482 6C10           8846         18            mov	$18[bp],al
24483                                           !BCC_EOS
24484                                           ! 4233             goto int13_fail_noah;
24485 6C13           83C4                   00  add	sp,#..FFE8-..FFEA
24486 6C16           E9         01A8            br 	.FFE8
24487                                           !BCC_EOS
24488                                           ! 4234           }
24489                                           ! 4235           *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].lock)) = (--locks);
24490                       00006C19            .5E8:
24491                                           ! Debug: predec unsigned char locks = [S+$20-5] (used reg = )
24492 6C19           8A46         FD            mov	al,-3[bp]
24493 6C1C           48                         dec	ax
24494 6C1D           8846         FD            mov	-3[bp],al
24495 6C20           50                         push	ax
24496                                           ! Debug: ptradd unsigned char device = [S+$22-3] to [8] struct  = const $142 (used reg = )
24497 6C21           8A46         FF            mov	al,-1[bp]
24498 6C24           30E4                       xor	ah,ah
24499 6C26           B9                   001E  mov	cx,*$1E
24500 6C29           F7E9                       imul	cx
24501 6C2B           89C3                       mov	bx,ax
24502                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
24503                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$145 (used reg = )
24504                                           ! Debug: eq unsigned char (temp) = [S+$22-$22] to unsigned char = [bx+$145] (used reg = )
24505 6C2D           8A46         E0            mov	al,0+..FFEA[bp]
24506 6C30           8887       0145            mov	$145[bx],al
24507 6C34           44                         inc	sp
24508 6C35           44                         inc	sp
24509                                           !BCC_EOS
24510                                           ! 4236           *((Bit8u *)&AX) = (locks==0?0:1);
24511                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$20-5] (used reg = )
24512 6C36           8A46         FD            mov	al,-3[bp]
24513 6C39           84C0                       test	al,al
24514 6C3B           75           04            jne 	.5EA
24515                       00006C3D            .5EB:
24516 6C3D           30C0                       xor	al,al
24517 6C3F           EB           02            jmp .5EC
24518                       00006C41            .5EA:
24519 6C41           B0                     01  mov	al,*1
24520                       00006C43            .5EC:
24521                                           ! Debug: eq char = al+0 to unsigned char AX = [S+$20+$16] (used reg = )
24522 6C43           8846         18            mov	$18[bp],al
24523                                           !BCC_EOS
24524                                           ! 4237           break;
24525 6C46           EB           22            jmp .5E1
24526                                           !BCC_EOS
24527                                           ! 4238         case 2 :
24528                                           ! 4239           *((Bit8u *)&AX) = (locks==0?0:1);
24529                       00006C48            .5ED:
24530                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$20-5] (used reg = )
24531 6C48           8A46         FD            mov	al,-3[bp]
24532 6C4B           84C0                       test	al,al
24533 6C4D           75           04            jne 	.5EE
24534                       00006C4F            .5EF:
24535 6C4F           30C0                       xor	al,al
24536 6C51           EB           02            jmp .5F0
24537                       00006C53            .5EE:
24538 6C53           B0                     01  mov	al,*1
24539                       00006C55            .5F0:
24540                                           ! Debug: eq char = al+0 to unsigned char AX = [S+$20+$16] (used reg = )
24541 6C55           8846         18            mov	$18[bp],al
24542                                           !BCC_EOS
24543                                           ! 4240           break;
24544 6C58           EB           10            jmp .5E1
24545                                           !BCC_EOS
24546                                           ! 4241       }
24547                                           ! 4242       goto int13_success;
24548 6C5A           EB           0E            jmp .5E1
24549                       00006C5C            .5E3:
24550 6C5C           2C                     00  sub	al,*0
24551 6C5E         0F84         FF65            beq 	.5E4
24552 6C62           2C                     01  sub	al,*1
24553 6C64           74           9C            je 	.5E7
24554 6C66           2C                     01  sub	al,*1
24555 6C68           74           DE            je 	.5ED
24556                       00006C6A            .5E1:
24557 6C6A           83C4                   00  add	sp,#..FFE9-..FFEA
24558 6C6D           E9         0171            br 	.FFE9
24559                                           !BCC_EOS
24560                                           ! 4243       break;
24561 6C70           E9         0149            br 	.5BE
24562                                           !BCC_EOS
24563                                           ! 4244     case 0x46:
24564                                           ! 4245       locks = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].lock));
24565                       00006C73            .5F1:
24566                                           ! Debug: ptradd unsigned char device = [S+$20-3] to [8] struct  = const $142 (used reg = )
24567 6C73           8A46         FF            mov	al,-1[bp]
24568 6C76           30E4                       xor	ah,ah
24569 6C78           B9                   001E  mov	cx,*$1E
24570 6C7B           F7E9                       imul	cx
24571 6C7D           89C3                       mov	bx,ax
24572                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
24573                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$145 (used reg = )
24574                                           ! Debug: eq unsigned char = [bx+$145] to unsigned char locks = [S+$20-5] (used reg = )
24575 6C7F           8A87       0145            mov	al,$145[bx]
24576 6C83           8846         FD            mov	-3[bp],al
24577                                           !BCC_EOS
24578                                           ! 4246       if (locks != 0) {
24579                                           ! Debug: ne int = const 0 to unsigned char locks = [S+$20-5] (used reg = )
24580 6C86           8A46         FD            mov	al,-3[bp]
24581 6C89           84C0                       test	al,al
24582 6C8B           74           0B            je  	.5F2
24583                       00006C8D            .5F3:
24584                                           ! 4247         *(((Bit8u *)&AX)+1) = (0xb1);
24585                                           ! Debug: eq int = const $B1 to unsigned char AX = [S+$20+$17] (used reg = )
24586 6C8D           B0                     B1  mov	al,#$B1
24587 6C8F           8846         19            mov	$19[bp],al
24588                                           !BCC_EOS
24589                                           ! 4248         goto int13_fail_noah;
24590 6C92           83C4                   00  add	sp,#..FFE8-..FFEA
24591 6C95           E9         0129            br 	.FFE8
24592                                           !BCC_EOS
24593                                           ! 4249       }
24594                                           ! 4250 #asm
24595                       00006C98            .5F2:
24596                                           !BCC_EOS
24597                                           !BCC_ASM
24598                       0000002C            _int13_cdrom.BP	set	$2C
24599                       0000000E            .int13_cdrom.BP	set	$E
24600                       00000022            _int13_cdrom.EHBX	set	$22
24601                       00000004            .int13_cdrom.EHBX	set	4
24602                       0000003A            _int13_cdrom.CS	set	$3A
24603                       0000001C            .int13_cdrom.CS	set	$1C
24604                       00000008            _int13_cdrom.count	set	8
24605                       FFFFFFEA            .int13_cdrom.count	set	-$16
24606                       00000034            _int13_cdrom.CX	set	$34
24607                       00000016            .int13_cdrom.CX	set	$16
24608                       00000006            _int13_cdrom.segment	set	6
24609                       FFFFFFE8            .int13_cdrom.segment	set	-$18
24610                       00000028            _int13_cdrom.DI	set	$28
24611                       0000000A            .int13_cdrom.DI	set	$A
24612                       0000003C            _int13_cdrom.FLAGS	set	$3C
24613                       0000001E            .int13_cdrom.FLAGS	set	$1E
24614                       00000024            _int13_cdrom.DS	set	$24
24615                       00000006            .int13_cdrom.DS	set	6
24616                       0000002E            _int13_cdrom.ELDX	set	$2E
24617                       00000010            .int13_cdrom.ELDX	set	$10
24618                       00000032            _int13_cdrom.DX	set	$32
24619                       00000014            .int13_cdrom.DX	set	$14
24620                       00000000            _int13_cdrom.size	set	0
24621                       FFFFFFE2            .int13_cdrom.size	set	-$1E
24622                       00000002            _int13_cdrom.i	set	2
24623                       FFFFFFE4            .int13_cdrom.i	set	-$1C
24624                       0000001D            _int13_cdrom.device	set	$1D
24625                       FFFFFFFF            .int13_cdrom.device	set	-1
24626                       00000026            _int13_cdrom.ES	set	$26
24627                       00000008            .int13_cdrom.ES	set	8
24628                       0000002A            _int13_cdrom.SI	set	$2A
24629                       0000000C            .int13_cdrom.SI	set	$C
24630                       00000038            _int13_cdrom.IP	set	$38
24631                       0000001A            .int13_cdrom.IP	set	$1A
24632                       0000000A            _int13_cdrom.lba	set	$A
24633                       FFFFFFEC            .int13_cdrom.lba	set	-$14
24634                       0000001C            _int13_cdrom.status	set	$1C
24635                       FFFFFFFE            .int13_cdrom.status	set	-2
24636                       0000000F            _int13_cdrom.atacmd	set	$F
24637                       FFFFFFF1            .int13_cdrom.atacmd	set	-$F
24638                       00000036            _int13_cdrom.AX	set	$36
24639                       00000018            .int13_cdrom.AX	set	$18
24640                       00000004            _int13_cdrom.offset	set	4
24641                       FFFFFFE6            .int13_cdrom.offset	set	-$1A
24642                       00000030            _int13_cdrom.BX	set	$30
24643                       00000012            .int13_cdrom.BX	set	$12
24644                       0000001B            _int13_cdrom.locks	set	$1B
24645                       FFFFFFFD            .int13_cdrom.locks	set	-3
24646 6C98           55                                 push bp
24647 6C99           89E5                               mov bp, sp
24648 6C9B           B4                     52          mov ah, #0x52
24649 6C9D           CD                     15          int #0x15
24650 6C9F           8866         1E                    mov _int13_cdrom.status + 2[bp], ah
24651 6CA2           73           06                    jnc int13_cdrom_rme_end
24652 6CA4           C706       001C      0001          mov _int13_cdrom.status, #1
24653                       00006CAA            int13_cdrom_rme_end:
24654 6CAA           5D                                 pop bp
24655                                           ! 4260 endasm
24656                                           !BCC_ENDASM
24657                                           !BCC_EOS
24658                                           ! 4261       if (status != 0) {
24659                                           ! Debug: ne int = const 0 to unsigned char status = [S+$20-4] (used reg = )
24660 6CAB           8A46         FE            mov	al,-2[bp]
24661 6CAE           84C0                       test	al,al
24662 6CB0           74           0B            je  	.5F4
24663                       00006CB2            .5F5:
24664                                           ! 4262         *(((Bit8u *)&AX)+1) = (0xb1);
24665                                           ! Debug: eq int = const $B1 to unsigned char AX = [S+$20+$17] (used reg = )
24666 6CB2           B0                     B1  mov	al,#$B1
24667 6CB4           8846         19            mov	$19[bp],al
24668                                           !BCC_EOS
24669                                           ! 4263         goto int13_fail_noah;
24670 6CB7           83C4                   00  add	sp,#..FFE8-..FFEA
24671 6CBA           E9         0104            br 	.FFE8
24672                                           !BCC_EOS
24673                                           ! 4264       }
24674                                           ! 4265       goto int13_success;
24675                       00006CBD            .5F4:
24676 6CBD           83C4                   00  add	sp,#..FFE9-..FFEA
24677 6CC0           E9         011E            br 	.FFE9
24678                                           !BCC_EOS
24679                                           ! 4266       break;
24680 6CC3           E9         00F6            br 	.5BE
24681                                           !BCC_EOS
24682                                           ! 4267     case 0x48:
24683                                           ! 4268       if (int13_edd(DS, SI, device))
24684                       00006CC6            .5F6:
24685                                           ! Debug: list unsigned char device = [S+$20-3] (used reg = )
24686 6CC6           8A46         FF            mov	al,-1[bp]
24687 6CC9           30E4                       xor	ah,ah
24688 6CCB           50                         push	ax
24689                                           ! Debug: list unsigned short SI = [S+$22+$A] (used reg = )
24690 6CCC           FF76         0C            push	$C[bp]
24691                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
24692 6CCF           FF76         06            push	6[bp]
24693                                           ! Debug: func () int = int13_edd+0 (used reg = )
24694 6CD2           E8         EE11            call	_int13_edd
24695 6CD5           83C4                   06  add	sp,*6
24696 6CD8           85C0                       test	ax,ax
24697 6CDA           74           06            je  	.5F7
24698                       00006CDC            .5F8:
24699                                           ! 4269         goto int13_fail;
24700 6CDC           83C4                   00  add	sp,#..FFEB-..FFEA
24701 6CDF           E9         00DA            br 	.FFEB
24702                                           !BCC_EOS
24703                                           ! 4270       goto int13_success;
24704                       00006CE2            .5F7:
24705 6CE2           83C4                   00  add	sp,#..FFE9-..FFEA
24706 6CE5           E9         00F9            br 	.FFE9
24707                                           !BCC_EOS
24708                                           ! 4271       break;
24709 6CE8           E9         00D1            br 	.5BE
24710                                           !BCC_EOS
24711                                           ! 4272     case 0x49:
24712                                           ! 4273       *(((Bit8u *)&AX)+1) = (06);
24713                       00006CEB            .5F9:
24714                                           ! Debug: eq int = const 6 to unsigned char AX = [S+$20+$17] (used reg = )
24715 6CEB           B0                     06  mov	al,*6
24716 6CED           8846         19            mov	$19[bp],al
24717                                           !BCC_EOS
24718                                           ! 4274       goto int13_fail_nostatus;
24719 6CF0           83C4                   00  add	sp,#..FFE7-..FFEA
24720 6CF3           E9         00DF            br 	.FFE7
24721                                           !BCC_EOS
24722                                           ! 4275       break;
24723 6CF6           E9         00C3            br 	.5BE
24724                                           !BCC_EOS
24725                                           ! 4276     case 0x4e:
24726                                           ! 4277       switch (( AX & 0x00ff )) {
24727                       00006CF9            .5FA:
24728                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$16] (used reg = )
24729 6CF9           8A46         18            mov	al,$18[bp]
24730 6CFC           EB           10            jmp .5FD
24731                                           ! 4278         case 0x01:
24732                                           ! 4279         case 0x03:
24733                       00006CFE            .5FE:
24734                                           ! 4280         case 0x04:
24735                       00006CFE            .5FF:
24736                                           ! 4281         case 0x06:
24737                       00006CFE            .600:
24738                                           ! 4282           goto int13_success;
24739                       00006CFE            .601:
24740 6CFE           83C4                   00  add	sp,#..FFE9-..FFEA
24741 6D01           E9         00DD            br 	.FFE9
24742                                           !BCC_EOS
24743                                           ! 4283           break;
24744 6D04           EB           1A            jmp .5FB
24745                                           !BCC_EOS
24746                                           ! 4284         default:
24747                                           ! 4285           goto int13_fail;
24748                       00006D06            .602:
24749 6D06           83C4                   00  add	sp,#..FFEB-..FFEA
24750 6D09           E9         00B0            br 	.FFEB
24751                                           !BCC_EOS
24752                                           ! 4286       }
24753                                           ! 4287       break;
24754 6D0C           EB           12            jmp .5FB
24755                       00006D0E            .5FD:
24756 6D0E           2C                     01  sub	al,*1
24757 6D10           74           EC            je 	.5FE
24758 6D12           2C                     02  sub	al,*2
24759 6D14           74           E8            je 	.5FF
24760 6D16           2C                     01  sub	al,*1
24761 6D18           74           E4            je 	.600
24762 6D1A           2C                     02  sub	al,*2
24763 6D1C           74           E0            je 	.601
24764 6D1E           EB           E6            jmp	.602
24765                       00006D20            .5FB:
24766 6D20           E9         0099            br 	.5BE
24767                                           !BCC_EOS
24768                                           ! 4288     case 0x02:
24769                                           ! 4289     case 0x04:
24770                       00006D23            .603:
24771                                           ! 4290     case 0x08:
24772                       00006D23            .604:
24773                                           ! 4291     case 0x0a:
24774                       00006D23            .605:
24775                                           ! 4292     case 0x0b:
24776                       00006D23            .606:
24777                                           ! 4293     case 0x18:
24778                       00006D23            .607:
24779                                           ! 4294     case 0x50:
24780                       00006D23            .608:
24781                                           ! 4294 
24782                                           ! 4295     default:
24783                       00006D23            .609:
24784                                           ! 4296       bios_printf(4, "int13_cdrom: unsupported AH=%02x\n", *(((Bit8u *)&AX)+1));
24785                       00006D23            .60A:
24786                                           ! Debug: list unsigned char AX = [S+$20+$17] (used reg = )
24787 6D23           8A46         19            mov	al,$19[bp]
24788 6D26           30E4                       xor	ah,ah
24789 6D28           50                         push	ax
24790                                           ! Debug: list * char = .60B+0 (used reg = )
24791 6D29           BB                   CF50  mov	bx,#.60B
24792 6D2C           53                         push	bx
24793                                           ! Debug: list int = const 4 (used reg = )
24794 6D2D           B8                   0004  mov	ax,*4
24795 6D30           50                         push	ax
24796                                           ! Debug: func () void = bios_printf+0 (used reg = )
24797 6D31           E8         9C0A            call	_bios_printf
24798 6D34           83C4                   06  add	sp,*6
24799                                           !BCC_EOS
24800                                           ! 4297       goto int13_fail;
24801 6D37           83C4                   00  add	sp,#..FFEB-..FFEA
24802 6D3A           E9         007F            jmp .FFEB
24803                                           !BCC_EOS
24804                                           ! 4298       break;
24805 6D3D           EB           7D            jmp .5BE
24806                                           !BCC_EOS
24807                                           ! 4299   }
24808                                           ! 4300 int13_fail:
24809 6D3F           EB           7B            jmp .5BE
24810                       00006D41            .5C0:
24811 6D41           2C                     00  sub	al,*0
24812 6D43           72           DE            jb 	.60A
24813 6D45           3C                     18  cmp	al,*$18
24814 6D47           77           3D            ja  	.60C
24815 6D49           30E4                       xor	ah,ah
24816 6D4B           D1E0                       shl	ax,*1
24817 6D4D           89C3                       mov	bx,ax
24818 6D4F           2E                         seg	cs
24819 6D50           FFA7       6D54            br	.60D[bx]
24820                       00006D54            .60D:
24821 6D54                      6991            .word	.5C1
24822 6D56                      69A8            .word	.5CC
24823 6D58                      6D23            .word	.603
24824 6D5A                      699A            .word	.5C9
24825 6D5C                      6D23            .word	.604
24826 6D5E                      699A            .word	.5CA
24827 6D60                      6D23            .word	.60A
24828 6D62                      6D23            .word	.60A
24829 6D64                      6D23            .word	.605
24830 6D66                      6991            .word	.5C2
24831 6D68                      6D23            .word	.606
24832 6D6A                      6D23            .word	.607
24833 6D6C                      6991            .word	.5C3
24834 6D6E                      6991            .word	.5C4
24835 6D70                      6D23            .word	.60A
24836 6D72                      6D23            .word	.60A
24837 6D74                      6991            .word	.5C5
24838 6D76                      6991            .word	.5C6
24839 6D78                      6D23            .word	.60A
24840 6D7A                      6D23            .word	.60A
24841 6D7C                      6991            .word	.5C7
24842 6D7E                      69E8            .word	.5D0
24843 6D80                      6991            .word	.5C8
24844 6D82                      6D23            .word	.60A
24845 6D84                      6D23            .word	.608
24846                       00006D86            .60C:
24847 6D86           2C                     41  sub	al,*$41
24848 6D88           72           99            jb 	.60A
24849 6D8A           3C                     0F  cmp	al,*$F
24850 6D8C           77           2B            ja  	.60E
24851 6D8E           30E4                       xor	ah,ah
24852 6D90           D1E0                       shl	ax,*1
24853 6D92           89C3                       mov	bx,ax
24854 6D94           2E                         seg	cs
24855 6D95           FFA7       6D99            br	.60F[bx]
24856                       00006D99            .60F:
24857 6D99                      69F6            .word	.5D1
24858 6D9B                      6A10            .word	.5D2
24859 6D9D                      699A            .word	.5CB
24860 6D9F                      6A10            .word	.5D3
24861 6DA1                      6BA1            .word	.5DE
24862 6DA3                      6C73            .word	.5F1
24863 6DA5                      6A10            .word	.5D4
24864 6DA7                      6CC6            .word	.5F6
24865 6DA9                      6CEB            .word	.5F9
24866 6DAB                      6D23            .word	.60A
24867 6DAD                      6D23            .word	.60A
24868 6DAF                      6D23            .word	.60A
24869 6DB1                      6D23            .word	.60A
24870 6DB3                      6CF9            .word	.5FA
24871 6DB5                      6D23            .word	.60A
24872 6DB7                      6D23            .word	.609
24873                       00006DB9            .60E:
24874 6DB9           E9         FF67            br 	.60A
24875                       00006DBC            .5BE:
24876                       FFFFFFE0            ..FFEA	=	-$20
24877                       00006DBC            .FFEB:
24878                       FFFFFFE0            ..FFEB	=	-$20
24879                                           ! 4301   *(((Bit8u *)&AX)+1) = (0x01);
24880                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$20+$17] (used reg = )
24881 6DBC           B0                     01  mov	al,*1
24882 6DBE           8846         19            mov	$19[bp],al
24883                                           !BCC_EOS
24884                                           ! 4302 int13_fail_noah:
24885                       00006DC1            .FFE8:
24886                       FFFFFFE0            ..FFE8	=	-$20
24887                                           ! 4303   _write_byte(*(((Bit8u *)&AX)+1), 0x0074, 0x0040);
24888                                           ! Debug: list int = const $40 (used reg = )
24889 6DC1           B8                   0040  mov	ax,*$40
24890 6DC4           50                         push	ax
24891                                           ! Debug: list int = const $74 (used reg = )
24892 6DC5           B8                   0074  mov	ax,*$74
24893 6DC8           50                         push	ax
24894                                           ! Debug: list unsigned char AX = [S+$24+$17] (used reg = )
24895 6DC9           8A46         19            mov	al,$19[bp]
24896 6DCC           30E4                       xor	ah,ah
24897 6DCE           50                         push	ax
24898                                           ! Debug: func () void = _write_byte+0 (used reg = )
24899 6DCF           E8         982E            call	__write_byte
24900 6DD2           83C4                   06  add	sp,*6
24901                                           !BCC_EOS
24902                                           ! 4304 int13_fail_nostatus:
24903                       00006DD5            .FFE7:
24904                       FFFFFFE0            ..FFE7	=	-$20
24905                                           ! 4305   FLAGS |= 0x0001;
24906                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1C] (used reg = )
24907 6DD5           8B46         1E            mov	ax,$1E[bp]
24908 6DD8           0C                     01  or	al,*1
24909 6DDA           8946         1E            mov	$1E[bp],ax
24910                                           !BCC_EOS
24911                                           ! 4306   return;
24912 6DDD           89EC                       mov	sp,bp
24913 6DDF           5D                         pop	bp
24914 6DE0           C3                         ret
24915                                           !BCC_EOS
24916                                           ! 4307 int13_success:
24917                       00006DE1            .FFE9:
24918                       FFFFFFE0            ..FFE9	=	-$20
24919                                           ! 4308   *(((Bit8u *)&AX)+1) = (0x00);
24920                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$20+$17] (used reg = )
24921 6DE1           30C0                       xor	al,al
24922 6DE3           8846         19            mov	$19[bp],al
24923                                           !BCC_EOS
24924                                           ! 4309 int13_success_noah:
24925                       00006DE6            .FFE6:
24926                       FFFFFFE0            ..FFE6	=	-$20
24927                                           ! 4310   _write_byte(0x00, 0x0074, 0x0040);
24928                                           ! Debug: list int = const $40 (used reg = )
24929 6DE6           B8                   0040  mov	ax,*$40
24930 6DE9           50                         push	ax
24931                                           ! Debug: list int = const $74 (used reg = )
24932 6DEA           B8                   0074  mov	ax,*$74
24933 6DED           50                         push	ax
24934                                           ! Debug: list int = const 0 (used reg = )
24935 6DEE           31C0                       xor	ax,ax
24936 6DF0           50                         push	ax
24937                                           ! Debug: func () void = _write_byte+0 (used reg = )
24938 6DF1           E8         980C            call	__write_byte
24939 6DF4           83C4                   06  add	sp,*6
24940                                           !BCC_EOS
24941                                           ! 4311   FLAGS &= 0xfffe;
24942                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1C] (used reg = )
24943 6DF7           8B46         1E            mov	ax,$1E[bp]
24944 6DFA           24                     FE  and	al,#$FE
24945 6DFC           8946         1E            mov	$1E[bp],ax
24946                                           !BCC_EOS
24947                                           ! 4312 }
24948 6DFF           89EC                       mov	sp,bp
24949 6E01           5D                         pop	bp
24950 6E02           C3                         ret
24951                                           ! 4313   void
24952                                           ! Register BX used in function int13_cdrom
24953                                           ! 4314 int13_eltorito(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
24954                                           ! 4315   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
24955                                           export	_int13_eltorito
24956                       00006E03            _int13_eltorito:
24957                                           !BCC_EOS
24958                                           ! 4316 {
24959                                           ! 4317   Bit16u ebda_seg=get_ebda_seg();
24960 6E03           55                         push	bp
24961 6E04           89E5                       mov	bp,sp
24962 6E06           4C                         dec	sp
24963 6E07           4C                         dec	sp
24964                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
24965 6E08           E8         9861            call	_get_ebda_seg
24966                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
24967 6E0B           8946         FE            mov	-2[bp],ax
24968                                           !BCC_EOS
24969                                           ! 4318   ;
24970                                           !BCC_EOS
24971                                           ! 4319   switch (*(((Bit8u *)&AX)+1)) {
24972 6E0E           8A46         17            mov	al,$17[bp]
24973 6E11           E9         0191            br 	.612
24974                                           ! 4320     case 0x4a:
24975                                           ! 4321     case 0x4c:
24976                       00006E14            .613:
24977                                           ! 4322     case 0x4d:
24978                       00006E14            .614:
24979                                           ! 4323       bios_printf((2 | 4 | 1), "Int13 eltorito call with AX=%04x. Please report\n",AX);
24980                       00006E14            .615:
24981                                           ! Debug: list unsigned short AX = [S+4+$14] (used reg = )
24982 6E14           FF76         16            push	$16[bp]
24983                                           ! Debug: list * char = .616+0 (used reg = )
24984 6E17           BB                   CF1F  mov	bx,#.616
24985 6E1A           53                         push	bx
24986                                           ! Debug: list int = const 7 (used reg = )
24987 6E1B           B8                   0007  mov	ax,*7
24988 6E1E           50                         push	ax
24989                                           ! Debug: func () void = bios_printf+0 (used reg = )
24990 6E1F           E8         9B1C            call	_bios_printf
24991 6E22           83C4                   06  add	sp,*6
24992                                           !BCC_EOS
24993                                           ! 4324       goto int13_fail;
24994 6E25           83C4                   00  add	sp,#..FFE4-..FFE5
24995 6E28           E9         0194            br 	.FFE4
24996                                           !BCC_EOS
24997                                           ! 4325       break;
24998 6E2B           E9         0191            br 	.610
24999                                           !BCC_EOS
25000                                           ! 4326     case 0x4b:
25001                                           ! 4327       *((Bit8u *)(SI+0x00)) = (0x13);
25002                       00006E2E            .617:
25003                                           ! Debug: add int = const 0 to unsigned short SI = [S+4+8] (used reg = )
25004 6E2E           8B46         0A            mov	ax,$A[bp]
25005                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+0 (used reg = )
25006 6E31           89C3                       mov	bx,ax
25007                                           ! Debug: eq int = const $13 to unsigned char = [bx+0] (used reg = )
25008 6E33           B0                     13  mov	al,*$13
25009 6E35           8807                       mov	[bx],al
25010                                           !BCC_EOS
25011                                           ! 4328       *((Bit8u *)(SI+0x01)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.media, ebda_seg));
25012                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25013 6E37           FF76         FE            push	-2[bp]
25014                                           ! Debug: list * unsigned char = const $25B (used reg = )
25015 6E3A           B8                   025B  mov	ax,#$25B
25016 6E3D           50                         push	ax
25017                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25018 6E3E           E8         97A3            call	__read_byte
25019 6E41           83C4                   04  add	sp,*4
25020 6E44           50                         push	ax
25021                                           ! Debug: add int = const 1 to unsigned short SI = [S+6+8] (used reg = )
25022 6E45           8B46         0A            mov	ax,$A[bp]
25023                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+1 (used reg = )
25024 6E48           89C3                       mov	bx,ax
25025                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+1] (used reg = )
25026 6E4A           8A46         FC            mov	al,0+..FFE5[bp]
25027 6E4D           8847         01            mov	1[bx],al
25028 6E50           44                         inc	sp
25029 6E51           44                         inc	sp
25030                                           !BCC_EOS
25031                                           ! 4329       *((Bit8u *)(SI+0x02)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.emulated_drive, ebda_seg));
25032                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25033 6E52           FF76         FE            push	-2[bp]
25034                                           ! Debug: list * unsigned char = const $25C (used reg = )
25035 6E55           B8                   025C  mov	ax,#$25C
25036 6E58           50                         push	ax
25037                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25038 6E59           E8         9788            call	__read_byte
25039 6E5C           83C4                   04  add	sp,*4
25040 6E5F           50                         push	ax
25041                                           ! Debug: add int = const 2 to unsigned short SI = [S+6+8] (used reg = )
25042 6E60           8B46         0A            mov	ax,$A[bp]
25043                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+2 (used reg = )
25044 6E63           89C3                       mov	bx,ax
25045                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+2] (used reg = )
25046 6E65           8A46         FC            mov	al,0+..FFE5[bp]
25047 6E68           8847         02            mov	2[bx],al
25048 6E6B           44                         inc	sp
25049 6E6C           44                         inc	sp
25050                                           !BCC_EOS
25051                                           ! 4330       *((Bit8u *)(SI+0x03)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.controller_index, ebda_seg));
25052                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25053 6E6D           FF76         FE            push	-2[bp]
25054                                           ! Debug: list * unsigned char = const $25D (used reg = )
25055 6E70           B8                   025D  mov	ax,#$25D
25056 6E73           50                         push	ax
25057                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25058 6E74           E8         976D            call	__read_byte
25059 6E77           83C4                   04  add	sp,*4
25060 6E7A           50                         push	ax
25061                                           ! Debug: add int = const 3 to unsigned short SI = [S+6+8] (used reg = )
25062 6E7B           8B46         0A            mov	ax,$A[bp]
25063                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+3 (used reg = )
25064 6E7E           89C3                       mov	bx,ax
25065                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+3] (used reg = )
25066 6E80           8A46         FC            mov	al,0+..FFE5[bp]
25067 6E83           8847         03            mov	3[bx],al
25068 6E86           44                         inc	sp
25069 6E87           44                         inc	sp
25070                                           !BCC_EOS
25071                                           ! 4331       *((Bit32u *)(SI+0x04)) = (_read_dword(&((ebda_data_t *) 0)->cdemu.ilba, ebda_seg));
25072                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25073 6E88           FF76         FE            push	-2[bp]
25074                                           ! Debug: list * unsigned long = const $260 (used reg = )
25075 6E8B           B8                   0260  mov	ax,#$260
25076 6E8E           50                         push	ax
25077                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
25078 6E8F           E8         91C4            call	__read_dword
25079 6E92           89D3                       mov	bx,dx
25080 6E94           83C4                   04  add	sp,*4
25081 6E97           53                         push	bx
25082 6E98           50                         push	ax
25083                                           ! Debug: add int = const 4 to unsigned short SI = [S+8+8] (used reg = )
25084 6E99           8B46         0A            mov	ax,$A[bp]
25085                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+4 (used reg = )
25086 6E9C           89C3                       mov	bx,ax
25087                                           ! Debug: eq unsigned long (temp) = [S+8-8] to unsigned long = [bx+4] (used reg = )
25088 6E9E           8B46         FA            mov	ax,-2+..FFE5[bp]
25089 6EA1           8B76         FC            mov	si,0+..FFE5[bp]
25090 6EA4           8947         04            mov	4[bx],ax
25091 6EA7           8977         06            mov	6[bx],si
25092 6EAA           83C4                   04  add	sp,*4
25093                                           !BCC_EOS
25094                                           ! 4332       *((Bit16u *)(SI+0x08)) = (_read_word(&((ebda_data_t *) 0)->cdemu.device_spec, ebda_seg));
25095                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25096 6EAD           FF76         FE            push	-2[bp]
25097                                           ! Debug: list * unsigned short = const $25E (used reg = )
25098 6EB0           B8                   025E  mov	ax,#$25E
25099 6EB3           50                         push	ax
25100                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
25101 6EB4           E8         973B            call	__read_word
25102 6EB7           83C4                   04  add	sp,*4
25103 6EBA           50                         push	ax
25104                                           ! Debug: add int = const 8 to unsigned short SI = [S+6+8] (used reg = )
25105 6EBB           8B46         0A            mov	ax,$A[bp]
25106                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+8 (used reg = )
25107 6EBE           89C3                       mov	bx,ax
25108                                           ! Debug: eq unsigned short (temp) = [S+6-6] to unsigned short = [bx+8] (used reg = )
25109 6EC0           8B46         FC            mov	ax,0+..FFE5[bp]
25110 6EC3           8947         08            mov	8[bx],ax
25111 6EC6           44                         inc	sp
25112 6EC7           44                         inc	sp
25113                                           !BCC_EOS
25114                                           ! 4333       *((Bit16u *)(SI+0x0a)) = (_read_word(&((ebda_data_t *) 0)->cdemu.buffer_segment, ebda_seg));
25115                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25116 6EC8           FF76         FE            push	-2[bp]
25117                                           ! Debug: list * unsigned short = const $264 (used reg = )
25118 6ECB           B8                   0264  mov	ax,#$264
25119 6ECE           50                         push	ax
25120                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
25121 6ECF           E8         9720            call	__read_word
25122 6ED2           83C4                   04  add	sp,*4
25123 6ED5           50                         push	ax
25124                                           ! Debug: add int = const $A to unsigned short SI = [S+6+8] (used reg = )
25125 6ED6           8B46         0A            mov	ax,$A[bp]
25126                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$A (used reg = )
25127 6ED9           89C3                       mov	bx,ax
25128                                           ! Debug: eq unsigned short (temp) = [S+6-6] to unsigned short = [bx+$A] (used reg = )
25129 6EDB           8B46         FC            mov	ax,0+..FFE5[bp]
25130 6EDE           8947         0A            mov	$A[bx],ax
25131 6EE1           44                         inc	sp
25132 6EE2           44                         inc	sp
25133                                           !BCC_EOS
25134                                           ! 4334       *((Bit16u *)(SI+0x0c)) = (_read_word(&((ebda_data_t *) 0)->cdemu.load_segment, ebda_seg));
25135                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25136 6EE3           FF76         FE            push	-2[bp]
25137                                           ! Debug: list * unsigned short = const $266 (used reg = )
25138 6EE6           B8                   0266  mov	ax,#$266
25139 6EE9           50                         push	ax
25140                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
25141 6EEA           E8         9705            call	__read_word
25142 6EED           83C4                   04  add	sp,*4
25143 6EF0           50                         push	ax
25144                                           ! Debug: add int = const $C to unsigned short SI = [S+6+8] (used reg = )
25145 6EF1           8B46         0A            mov	ax,$A[bp]
25146                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$C (used reg = )
25147 6EF4           89C3                       mov	bx,ax
25148                                           ! Debug: eq unsigned short (temp) = [S+6-6] to unsigned short = [bx+$C] (used reg = )
25149 6EF6           8B46         FC            mov	ax,0+..FFE5[bp]
25150 6EF9           8947         0C            mov	$C[bx],ax
25151 6EFC           44                         inc	sp
25152 6EFD           44                         inc	sp
25153                                           !BCC_EOS
25154                                           ! 4335       *((Bit16u *)(SI+0x0e)) = (_read_word(&((ebda_data_t *) 0)->cdemu.sector_count, ebda_seg));
25155                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25156 6EFE           FF76         FE            push	-2[bp]
25157                                           ! Debug: list * unsigned short = const $268 (used reg = )
25158 6F01           B8                   0268  mov	ax,#$268
25159 6F04           50                         push	ax
25160                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
25161 6F05           E8         96EA            call	__read_word
25162 6F08           83C4                   04  add	sp,*4
25163 6F0B           50                         push	ax
25164                                           ! Debug: add int = const $E to unsigned short SI = [S+6+8] (used reg = )
25165 6F0C           8B46         0A            mov	ax,$A[bp]
25166                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$E (used reg = )
25167 6F0F           89C3                       mov	bx,ax
25168                                           ! Debug: eq unsigned short (temp) = [S+6-6] to unsigned short = [bx+$E] (used reg = )
25169 6F11           8B46         FC            mov	ax,0+..FFE5[bp]
25170 6F14           8947         0E            mov	$E[bx],ax
25171 6F17           44                         inc	sp
25172 6F18           44                         inc	sp
25173                                           !BCC_EOS
25174                                           ! 4336       *((Bit8u *)(SI+0x10)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders, ebda_seg));
25175                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25176 6F19           FF76         FE            push	-2[bp]
25177                                           ! Debug: list * unsigned short = const $26C (used reg = )
25178 6F1C           B8                   026C  mov	ax,#$26C
25179 6F1F           50                         push	ax
25180                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25181 6F20           E8         96C1            call	__read_byte
25182 6F23           83C4                   04  add	sp,*4
25183 6F26           50                         push	ax
25184                                           ! Debug: add int = const $10 to unsigned short SI = [S+6+8] (used reg = )
25185 6F27           8B46         0A            mov	ax,$A[bp]
25186                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$10 (used reg = )
25187 6F2A           89C3                       mov	bx,ax
25188                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+$10] (used reg = )
25189 6F2C           8A46         FC            mov	al,0+..FFE5[bp]
25190 6F2F           8847         10            mov	$10[bx],al
25191 6F32           44                         inc	sp
25192 6F33           44                         inc	sp
25193                                           !BCC_EOS
25194                                           ! 4337       *((Bit8u *)(SI+0x11)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.vdevice.spt, ebda_seg));
25195                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25196 6F34           FF76         FE            push	-2[bp]
25197                                           ! Debug: list * unsigned short = const $26E (used reg = )
25198 6F37           B8                   026E  mov	ax,#$26E
25199 6F3A           50                         push	ax
25200                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25201 6F3B           E8         96A6            call	__read_byte
25202 6F3E           83C4                   04  add	sp,*4
25203 6F41           50                         push	ax
25204                                           ! Debug: add int = const $11 to unsigned short SI = [S+6+8] (used reg = )
25205 6F42           8B46         0A            mov	ax,$A[bp]
25206                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$11 (used reg = )
25207 6F45           89C3                       mov	bx,ax
25208                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+$11] (used reg = )
25209 6F47           8A46         FC            mov	al,0+..FFE5[bp]
25210 6F4A           8847         11            mov	$11[bx],al
25211 6F4D           44                         inc	sp
25212 6F4E           44                         inc	sp
25213                                           !BCC_EOS
25214                                           ! 4338       *((Bit8u *)(SI+0x12)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.vdevice.heads, ebda_seg));
25215                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25216 6F4F           FF76         FE            push	-2[bp]
25217                                           ! Debug: list * unsigned short = const $26A (used reg = )
25218 6F52           B8                   026A  mov	ax,#$26A
25219 6F55           50                         push	ax
25220                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25221 6F56           E8         968B            call	__read_byte
25222 6F59           83C4                   04  add	sp,*4
25223 6F5C           50                         push	ax
25224                                           ! Debug: add int = const $12 to unsigned short SI = [S+6+8] (used reg = )
25225 6F5D           8B46         0A            mov	ax,$A[bp]
25226                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$12 (used reg = )
25227 6F60           89C3                       mov	bx,ax
25228                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+$12] (used reg = )
25229 6F62           8A46         FC            mov	al,0+..FFE5[bp]
25230 6F65           8847         12            mov	$12[bx],al
25231 6F68           44                         inc	sp
25232 6F69           44                         inc	sp
25233                                           !BCC_EOS
25234                                           ! 4339       if(( AX & 0x00ff ) == 0x00) {
25235                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
25236 6F6A           8A46         16            mov	al,$16[bp]
25237                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
25238 6F6D           84C0                       test	al,al
25239 6F6F           75           10            jne 	.618
25240                       00006F71            .619:
25241                                           ! 4340         _write_byte(0x00, &((ebda_data_t *) 0)->cdemu.active, ebda_seg);
25242                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25243 6F71           FF76         FE            push	-2[bp]
25244                                           ! Debug: list * unsigned char = const $25A (used reg = )
25245 6F74           B8                   025A  mov	ax,#$25A
25246 6F77           50                         push	ax
25247                                           ! Debug: list int = const 0 (used reg = )
25248 6F78           31C0                       xor	ax,ax
25249 6F7A           50                         push	ax
25250                                           ! Debug: func () void = _write_byte+0 (used reg = )
25251 6F7B           E8         9682            call	__write_byte
25252 6F7E           83C4                   06  add	sp,*6
25253                                           !BCC_EOS
25254                                           ! 4341       }
25255                                           ! 4342       goto in
25256                       00006F81            .618:
25257                                           ! 4342 t13_success;
25258 6F81           83C4                   00  add	sp,#..FFE3-..FFE5
25259 6F84           EB           5E            jmp .FFE3
25260                                           !BCC_EOS
25261                                           ! 4343       break;
25262 6F86           EB           37            jmp .610
25263                                           !BCC_EOS
25264                                           ! 4344     default:
25265                                           ! 4345       bios_printf(4, "int13_eltorito: unsupported AH=%02x\n", *(((Bit8u *)&AX)+1));
25266                       00006F88            .61A:
25267                                           ! Debug: list unsigned char AX = [S+4+$15] (used reg = )
25268 6F88           8A46         17            mov	al,$17[bp]
25269 6F8B           30E4                       xor	ah,ah
25270 6F8D           50                         push	ax
25271                                           ! Debug: list * char = .61B+0 (used reg = )
25272 6F8E           BB                   CEFA  mov	bx,#.61B
25273 6F91           53                         push	bx
25274                                           ! Debug: list int = const 4 (used reg = )
25275 6F92           B8                   0004  mov	ax,*4
25276 6F95           50                         push	ax
25277                                           ! Debug: func () void = bios_printf+0 (used reg = )
25278 6F96           E8         99A5            call	_bios_printf
25279 6F99           83C4                   06  add	sp,*6
25280                                           !BCC_EOS
25281                                           ! 4346       goto int13_fail;
25282 6F9C           83C4                   00  add	sp,#..FFE4-..FFE5
25283 6F9F           EB           1E            jmp .FFE4
25284                                           !BCC_EOS
25285                                           ! 4347       break;
25286 6FA1           EB           1C            jmp .610
25287                                           !BCC_EOS
25288                                           ! 4348   }
25289                                           ! 4349 int13_fail:
25290 6FA3           EB           1A            jmp .610
25291                       00006FA5            .612:
25292 6FA5           2C                     4A  sub	al,*$4A
25293 6FA7         0F84         FE69            beq 	.613
25294 6FAB           2C                     01  sub	al,*1
25295 6FAD         0F84         FE7D            beq 	.617
25296 6FB1           2C                     01  sub	al,*1
25297 6FB3         0F84         FE5D            beq 	.614
25298 6FB7           2C                     01  sub	al,*1
25299 6FB9         0F84         FE57            beq 	.615
25300 6FBD           EB           C9            jmp	.61A
25301                       00006FBF            .610:
25302                       FFFFFFFC            ..FFE5	=	-4
25303                       00006FBF            .FFE4:
25304                       FFFFFFFC            ..FFE4	=	-4
25305                                           ! 4350   *(((Bit8u *)&AX)+1) = (0x01);
25306                                           ! Debug: eq int = const 1 to unsigned char AX = [S+4+$15] (used reg = )
25307 6FBF           B0                     01  mov	al,*1
25308 6FC1           8846         17            mov	$17[bp],al
25309                                           !BCC_EOS
25310                                           ! 4351   _write_byte(*(((Bit8u *)&AX)+1), 0x0074, 0x0040);
25311                                           ! Debug: list int = const $40 (used reg = )
25312 6FC4           B8                   0040  mov	ax,*$40
25313 6FC7           50                         push	ax
25314                                           ! Debug: list int = const $74 (used reg = )
25315 6FC8           B8                   0074  mov	ax,*$74
25316 6FCB           50                         push	ax
25317                                           ! Debug: list unsigned char AX = [S+8+$15] (used reg = )
25318 6FCC           8A46         17            mov	al,$17[bp]
25319 6FCF           30E4                       xor	ah,ah
25320 6FD1           50                         push	ax
25321                                           ! Debug: func () void = _write_byte+0 (used reg = )
25322 6FD2           E8         962B            call	__write_byte
25323 6FD5           83C4                   06  add	sp,*6
25324                                           !BCC_EOS
25325                                           ! 4352   FLAGS |= 0x0001;
25326                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$1A] (used reg = )
25327 6FD8           8B46         1C            mov	ax,$1C[bp]
25328 6FDB           0C                     01  or	al,*1
25329 6FDD           8946         1C            mov	$1C[bp],ax
25330                                           !BCC_EOS
25331                                           ! 4353   return;
25332 6FE0           89EC                       mov	sp,bp
25333 6FE2           5D                         pop	bp
25334 6FE3           C3                         ret
25335                                           !BCC_EOS
25336                                           ! 4354 int13_success:
25337                       00006FE4            .FFE3:
25338                       FFFFFFFC            ..FFE3	=	-4
25339                                           ! 4355   *(((Bit8u *)&AX)+1) = (0x00);
25340                                           ! Debug: eq int = const 0 to unsigned char AX = [S+4+$15] (used reg = )
25341 6FE4           30C0                       xor	al,al
25342 6FE6           8846         17            mov	$17[bp],al
25343                                           !BCC_EOS
25344                                           ! 4356   _write_byte(0x00, 0x0074, 0x0040);
25345                                           ! Debug: list int = const $40 (used reg = )
25346 6FE9           B8                   0040  mov	ax,*$40
25347 6FEC           50                         push	ax
25348                                           ! Debug: list int = const $74 (used reg = )
25349 6FED           B8                   0074  mov	ax,*$74
25350 6FF0           50                         push	ax
25351                                           ! Debug: list int = const 0 (used reg = )
25352 6FF1           31C0                       xor	ax,ax
25353 6FF3           50                         push	ax
25354                                           ! Debug: func () void = _write_byte+0 (used reg = )
25355 6FF4           E8         9609            call	__write_byte
25356 6FF7           83C4                   06  add	sp,*6
25357                                           !BCC_EOS
25358                                           ! 4357   FLAGS &= 0xfffe;
25359                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+4+$1A] (used reg = )
25360 6FFA           8B46         1C            mov	ax,$1C[bp]
25361 6FFD           24                     FE  and	al,#$FE
25362 6FFF           8946         1C            mov	$1C[bp],ax
25363                                           !BCC_EOS
25364                                           ! 4358 }
25365 7002           89EC                       mov	sp,bp
25366 7004           5D                         pop	bp
25367 7005           C3                         ret
25368                                           ! 4359   void
25369                                           ! Register BX used in function int13_eltorito
25370                                           ! 4360 int13_cdemu(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
25371                                           ! 4361   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
25372                                           export	_int13_cdemu
25373                       00007006            _int13_cdemu:
25374                                           !BCC_EOS
25375                                           ! 4362 {
25376                                           ! 4363   Bit8u device, status;
25377                                           !BCC_EOS
25378                                           ! 4364   Bit16u vheads, vspt, vcylinders;
25379                                           !BCC_EOS
25380                                           ! 4365   Bit16u head, sector, cylinder, nbsectors, count;
25381                                           !BCC_EOS
25382                                           ! 4366   Bit32u vlba, ilba, slba, elba, lba;
25383                                           !BCC_EOS
25384                                           ! 4367   Bit16u before, segment, offset;
25385                                           !BCC_EOS
25386                                           ! 4368   Bit8u atacmd[12];
25387                                           !BCC_EOS
25388                                           ! 4369   ;
25389 7006           55                         push	bp
25390 7007           89E5                       mov	bp,sp
25391 7009           83C4                   C8  add	sp,*-$38
25392                                           !BCC_EOS
25393                                           ! 4370   device = *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.controller_index)) * 2;
25394                                           ! Debug: mul int = const 2 to unsigned char = [+$25D] (used reg = )
25395 700C           A0         025D            mov	al,[$25D]
25396 700F           30E4                       xor	ah,ah
25397 7011           D1E0                       shl	ax,*1
25398                                           ! Debug: eq unsigned int = ax+0 to unsigned char device = [S+$3A-3] (used reg = )
25399 7013           8846         FF            mov	-1[bp],al
25400                                           !BCC_EOS
25401                                           ! 4371   device += *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.device_spec));
25402                                           ! Debug: addab unsigned char = [+$25E] to unsigned char device = [S+$3A-3] (used reg = )
25403 7016           8A46         FF            mov	al,-1[bp]
25404 7019           30E4                       xor	ah,ah
25405 701B           0206       025E            add	al,[$25E]
25406 701F           80D4                   00  adc	ah,*0
25407 7022           8846         FF            mov	-1[bp],al
25408                                           !BCC_EOS
25409                                           ! 4372   _write_byte(0x00, 0x0074, 0x0040);
25410                                           ! Debug: list int = const $40 (used reg = )
25411 7025           B8                   0040  mov	ax,*$40
25412 7028           50                         push	ax
25413                                           ! Debug: list int = const $74 (used reg = )
25414 7029           B8                   0074  mov	ax,*$74
25415 702C           50                         push	ax
25416                                           ! Debug: list int = const 0 (used reg = )
25417 702D           31C0                       xor	ax,ax
25418 702F           50                         push	ax
25419                                           ! Debug: func () void = _write_byte+0 (used reg = )
25420 7030           E8         95CD            call	__write_byte
25421 7033           83C4                   06  add	sp,*6
25422                                           !BCC_EOS
25423                                           ! 4373   if( (*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.active)) ==0) ||
25424                                           ! 4374       (*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive)) != ( DX & 0x00ff ))) {
25425                                           ! Debug: logeq int = const 0 to unsigned char = [+$25A] (used reg = )
25426 7036           A0         025A            mov	al,[$25A]
25427 7039           84C0                       test	al,al
25428 703B           74           09            je  	.61D
25429                       0000703D            .61E:
25430                                           ! Debug: and int = const $FF to unsigned short DX = [S+$3A+$10] (used reg = )
25431 703D           8A46         12            mov	al,$12[bp]
25432                                           ! Debug: ne unsigned char = al+0 to unsigned char = [+$25C] (used reg = )
25433                                           ! Debug: expression subtree swapping
25434 7040           3A06       025C            cmp	al,[$25C]
25435 7044           74           20            je  	.61C
25436                       00007046            .61D:
25437                                           ! 4375     bios_printf(4, "int13_cdemu: function %02x, emulation not active for DL= %02x\n", *(((Bit8u *)&AX)+1), ( DX & 0x00ff ));
25438                                           ! Debug: and int = const $FF to unsigned short DX = [S+$3A+$10] (used reg = )
25439 7046           8A46         12            mov	al,$12[bp]
25440                                           ! Debug: list unsigned char = al+0 (used reg = )
25441 7049           30E4                       xor	ah,ah
25442 704B           50                         push	ax
25443                                           ! Debug: list unsigned char AX = [S+$3C+$15] (used reg = )
25444 704C           8A46         17            mov	al,$17[bp]
25445 704F           30E4                       xor	ah,ah
25446 7051           50                         push	ax
25447                                           ! Debug: list * char = .61F+0 (used reg = )
25448 7052           BB                   CEBB  mov	bx,#.61F
25449 7055           53                         push	bx
25450                                           ! Debug: list int = const 4 (used reg = )
25451 7056           B8                   0004  mov	ax,*4
25452 7059           50                         push	ax
25453                                           ! Debug: func () void = bios_printf+0 (used reg = )
25454 705A           E8         98E1            call	_bios_printf
25455 705D           83C4                   08  add	sp,*8
25456                                           !BCC_EOS
25457                                           ! 4376     goto int13_fail;
25458 7060           83C4                   00  add	sp,#..FFE2+$3A
25459 7063           E9         03CA            br 	.FFE2
25460                                           !BCC_EOS
25461                                           ! 4377   }
25462                                           ! 4378   switch (*(((Bit8u *)&AX)+1)) {
25463                       00007066            .61C:
25464 7066           8A46         17            mov	al,$17[bp]
25465 7069           E9         0349            br 	.622
25466                                           ! 4379     case 0x00:
25467                                           ! 4380     case 0x09:
25468                       0000706C            .623:
25469                                           ! 4381     case 0x0c:
25470                       0000706C            .624:
25471                                           ! 4382     case 0x0d:
25472                       0000706C            .625:
25473                                           ! 4383     case 0x10:
25474                       0000706C            .626:
25475                                           ! 4384     case 0x11:
25476                       0000706C            .627:
25477                                           ! 4385     case 0x14:
25478                       0000706C            .628:
25479                                           ! 4386     case 0x16:
25480                       0000706C            .629:
25481                                           ! 4387       goto int13_success;
25482                       0000706C            .62A:
25483 706C           83C4                   00  add	sp,#..FFE0-..FFE1
25484 706F           E9         03E3            br 	.FFE0
25485                                           !BCC_EOS
25486                                           ! 4388       break;
25487 7072           E9         03BB            br 	.620
25488                                           !BCC_EOS
25489                                           ! 4389     case 0x03:
25490                                           ! 4390     case 0x05:
25491                       00007075            .62B:
25492                                           ! 4391       *(((Bit8u *)&AX)+1) = (0x03);
25493                       00007075            .62C:
25494                                           ! Debug: eq int = const 3 to unsigned char AX = [S+$3A+$15] (used reg = )
25495 7075           B0                     03  mov	al,*3
25496 7077           8846         17            mov	$17[bp],al
25497                                           !BCC_EOS
25498                                           ! 4392       goto int13_fail_noah;
25499 707A           83C4                   00  add	sp,#..FFDF-..FFE1
25500 707D           E9         03B5            br 	.FFDF
25501                                           !BCC_EOS
25502                                           ! 4393       break;
25503 7080           E9         03AD            br 	.620
25504                                           !BCC_EOS
25505                                           ! 4394     case 0x01:
25506                                           ! 4395       status=_read_byte(0x0074, 0x0040);
25507                       00007083            .62D:
25508                                           ! Debug: list int = const $40 (used reg = )
25509 7083           B8                   0040  mov	ax,*$40
25510 7086           50                         push	ax
25511                                           ! Debug: list int = const $74 (used reg = )
25512 7087           B8                   0074  mov	ax,*$74
25513 708A           50                         push	ax
25514                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25515 708B           E8         9556            call	__read_byte
25516 708E           83C4                   04  add	sp,*4
25517                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$3A-4] (used reg = )
25518 7091           8846         FE            mov	-2[bp],al
25519                                           !BCC_EOS
25520                                           ! 4396       *(((Bit8u *)&AX)+1) = (status);
25521                                           ! Debug: eq unsigned char status = [S+$3A-4] to unsigned char AX = [S+$3A+$15] (used reg = )
25522 7094           8A46         FE            mov	al,-2[bp]
25523 7097           8846         17            mov	$17[bp],al
25524                                           !BCC_EOS
25525                                           ! 4397       _write_byte(0, 0x0074, 0x0040);
25526                                           ! Debug: list int = const $40 (used reg = )
25527 709A           B8                   0040  mov	ax,*$40
25528 709D           50                         push	ax
25529                                           ! Debug: list int = const $74 (used reg = )
25530 709E           B8                   0074  mov	ax,*$74
25531 70A1           50                         push	ax
25532                                           ! Debug: list int = const 0 (used reg = )
25533 70A2           31C0                       xor	ax,ax
25534 70A4           50                         push	ax
25535                                           ! Debug: func () void = _write_byte+0 (used reg = )
25536 70A5           E8         9558            call	__write_byte
25537 70A8           83C4                   06  add	sp,*6
25538                                           !BCC_EOS
25539                                           ! 4398       if (status) goto int13_fail_nostatus;
25540 70AB           8A46         FE            mov	al,-2[bp]
25541 70AE           84C0                       test	al,al
25542 70B0           74           08            je  	.62E
25543                       000070B2            .62F:
25544 70B2           83C4                   00  add	sp,#..FFDE-..FFE1
25545 70B5           E9         0391            br 	.FFDE
25546                                           !BCC_EOS
25547                                           ! 4399       else goto int13_success_noah;
25548 70B8           EB           06            jmp .630
25549                       000070BA            .62E:
25550 70BA           83C4                   00  add	sp,#..FFDD-..FFE1
25551 70BD           E9         039A            br 	.FFDD
25552                                           !BCC_EOS
25553                                           ! 4400       break;
25554                       000070C0            .630:
25555 70C0           E9         036D            br 	.620
25556                                           !BCC_EOS
25557                                           ! 4401     case 0x02:
25558                                           ! 4402     case 0x04:
25559                       000070C3            .631:
25560                                           ! 4403       vspt = *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt));
25561                       000070C3            .632:
25562                                           ! Debug: eq unsigned short = [+$26E] to unsigned short vspt = [S+$3A-8] (used reg = )
25563 70C3           A1         026E            mov	ax,[$26E]
25564 70C6           8946         FA            mov	-6[bp],ax
25565                                           !BCC_EOS
25566                                           ! 4404       vcylinders = *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders));
25567                                           ! Debug: eq unsigned short = [+$26C] to unsigned short vcylinders = [S+$3A-$A] (used reg = )
25568 70C9           A1         026C            mov	ax,[$26C]
25569 70CC           8946         F8            mov	-8[bp],ax
25570                                           !BCC_EOS
25571                                           ! 4405       vheads = *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads));
25572                                           ! Debug: eq unsigned short = [+$26A] to unsigned short vheads = [S+$3A-6] (used reg = )
25573 70CF           A1         026A            mov	ax,[$26A]
25574 70D2           8946         FC            mov	-4[bp],ax
25575                                           !BCC_EOS
25576                                           ! 4406       ilba = *((Bit32u *)(&((ebda_data_t *) 0)->cdem
25577                                           ! 4406 u.ilba));
25578                                           ! Debug: eq unsigned long = [+$260] to unsigned long ilba = [S+$3A-$1C] (used reg = )
25579 70D5           A1         0260            mov	ax,[$260]
25580 70D8           8B1E       0262            mov	bx,[$262]
25581 70DC           8946         E6            mov	-$1A[bp],ax
25582 70DF           895E         E8            mov	-$18[bp],bx
25583                                           !BCC_EOS
25584                                           ! 4407       sector = ( CX & 0x00ff ) & 0x003f;
25585                                           ! Debug: and int = const $FF to unsigned short CX = [S+$3A+$12] (used reg = )
25586 70E2           8A46         14            mov	al,$14[bp]
25587                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
25588 70E5           24                     3F  and	al,*$3F
25589                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$3A-$E] (used reg = )
25590 70E7           30E4                       xor	ah,ah
25591 70E9           8946         F4            mov	-$C[bp],ax
25592                                           !BCC_EOS
25593                                           ! 4408       cylinder = (( CX & 0x00ff ) & 0x00c0) << 2 | *(((Bit8u *)&CX)+1);
25594                                           ! Debug: and int = const $FF to unsigned short CX = [S+$3A+$12] (used reg = )
25595 70EC           8A46         14            mov	al,$14[bp]
25596                                           ! Debug: and int = const $C0 to unsigned char = al+0 (used reg = )
25597 70EF           24                     C0  and	al,#$C0
25598                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
25599 70F1           30E4                       xor	ah,ah
25600 70F3           D1E0                       shl	ax,*1
25601 70F5           D1E0                       shl	ax,*1
25602                                           ! Debug: or unsigned char CX = [S+$3A+$13] to unsigned int = ax+0 (used reg = )
25603 70F7           0A46         15            or	al,$15[bp]
25604                                           ! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$3A-$10] (used reg = )
25605 70FA           8946         F2            mov	-$E[bp],ax
25606                                           !BCC_EOS
25607                                           ! 4409       head = *(((Bit8u *)&DX)+1);
25608                                           ! Debug: eq unsigned char DX = [S+$3A+$11] to unsigned short head = [S+$3A-$C] (used reg = )
25609 70FD           8A46         13            mov	al,$13[bp]
25610 7100           30E4                       xor	ah,ah
25611 7102           8946         F6            mov	-$A[bp],ax
25612                                           !BCC_EOS
25613                                           ! 4410       nbsectors = ( AX & 0x00ff );
25614                                           ! Debug: and int = const $FF to unsigned short AX = [S+$3A+$14] (used reg = )
25615 7105           8A46         16            mov	al,$16[bp]
25616                                           ! Debug: eq unsigned char = al+0 to unsigned short nbsectors = [S+$3A-$12] (used reg = )
25617 7108           30E4                       xor	ah,ah
25618 710A           8946         F0            mov	-$10[bp],ax
25619                                           !BCC_EOS
25620                                           ! 4411       segment = ES;
25621                                           ! Debug: eq unsigned short ES = [S+$3A+4] to unsigned short segment = [S+$3A-$2C] (used reg = )
25622 710D           8B46         06            mov	ax,6[bp]
25623 7110           8946         D6            mov	-$2A[bp],ax
25624                                           !BCC_EOS
25625                                           ! 4412       offset = BX;
25626                                           ! Debug: eq unsigned short BX = [S+$3A+$E] to unsigned short offset = [S+$3A-$2E] (used reg = )
25627 7113           8B46         10            mov	ax,$10[bp]
25628 7116           8946         D4            mov	-$2C[bp],ax
25629                                           !BCC_EOS
25630                                           ! 4413       if(nbsectors==0) goto int13_success;
25631                                           ! Debug: logeq int = const 0 to unsigned short nbsectors = [S+$3A-$12] (used reg = )
25632 7119           8B46         F0            mov	ax,-$10[bp]
25633 711C           85C0                       test	ax,ax
25634 711E           75           06            jne 	.633
25635                       00007120            .634:
25636 7120           83C4                   00  add	sp,#..FFE0-..FFE1
25637 7123           E9         032F            br 	.FFE0
25638                                           !BCC_EOS
25639                                           ! 4414       if ((sector > vspt)
25640                       00007126            .633:
25641                                           ! 4415        || (cylinder >= vcylinders)
25642                                           ! 4416        || (head >= vheads)) {
25643                                           ! Debug: gt unsigned short vspt = [S+$3A-8] to unsigned short sector = [S+$3A-$E] (used reg = )
25644 7126           8B46         F4            mov	ax,-$C[bp]
25645 7129           3B46         FA            cmp	ax,-6[bp]
25646 712C           77           10            ja  	.636
25647                       0000712E            .638:
25648                                           ! Debug: ge unsigned short vcylinders = [S+$3A-$A] to unsigned short cylinder = [S+$3A-$10] (used reg = )
25649 712E           8B46         F2            mov	ax,-$E[bp]
25650 7131           3B46         F8            cmp	ax,-8[bp]
25651 7134           73           08            jae 	.636
25652                       00007136            .637:
25653                                           ! Debug: ge unsigned short vheads = [S+$3A-6] to unsigned short head = [S+$3A-$C] (used reg = )
25654 7136           8B46         F6            mov	ax,-$A[bp]
25655 7139           3B46         FC            cmp	ax,-4[bp]
25656 713C           72           06            jb  	.635
25657                       0000713E            .636:
25658                                           ! 4417         goto int13_fail;
25659 713E           83C4                   00  add	sp,#..FFE2-..FFE1
25660 7141           E9         02EC            br 	.FFE2
25661                                           !BCC_EOS
25662                                           ! 4418       }
25663                                           ! 4419       if (*(((Bit8u *)&AX)+1) == 0x04) goto int13_success;
25664                       00007144            .635:
25665                                           ! Debug: logeq int = const 4 to unsigned char AX = [S+$3A+$15] (used reg = )
25666 7144           8A46         17            mov	al,$17[bp]
25667 7147           3C                     04  cmp	al,*4
25668 7149           75           06            jne 	.639
25669                       0000714B            .63A:
25670 714B           83C4                   00  add	sp,#..FFE0-..FFE1
25671 714E           E9         0304            br 	.FFE0
25672                                           !BCC_EOS
25673                                           ! 4420       segment = ES+(BX / 16);
25674                       00007151            .639:
25675                                           ! Debug: div int = const $10 to unsigned short BX = [S+$3A+$E] (used reg = )
25676 7151           8B46         10            mov	ax,$10[bp]
25677 7154           B1                     04  mov	cl,*4
25678 7156           D3E8                       shr	ax,cl
25679                                           ! Debug: add unsigned int = ax+0 to unsigned short ES = [S+$3A+4] (used reg = )
25680                                           ! Debug: expression subtree swapping
25681 7158           0346         06            add	ax,6[bp]
25682                                           ! Debug: eq unsigned int = ax+0 to unsigned short segment = [S+$3A-$2C] (used reg = )
25683 715B           8946         D6            mov	-$2A[bp],ax
25684                                           !BCC_EOS
25685                                           ! 4421       offset = BX % 16;
25686                                           ! Debug: mod int = const $10 to unsigned short BX = [S+$3A+$E] (used reg = )
25687 715E           8B46         10            mov	ax,$10[bp]
25688 7161           24                     0F  and	al,*$F
25689                                           ! Debug: eq unsigned char = al+0 to unsigned short offset = [S+$3A-$2E] (used reg = )
25690 7163           30E4                       xor	ah,ah
25691 7165           8946         D4            mov	-$2C[bp],ax
25692                                           !BCC_EOS
25693                                           ! 4422       vlba=((((Bit32u)cylinder*(Bit32u)vheads)+(Bit32u)head)*(Bit32u)vspt)+((Bit32u)(sector-1));
25694                                           ! Debug: sub int = const 1 to unsigned short sector = [S+$3A-$E] (used reg = )
25695 7168           8B46         F4            mov	ax,-$C[bp]
25696                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
25697 716B           48                         dec	ax
25698 716C           31DB                       xor	bx,bx
25699 716E           53                         push	bx
25700 716F           50                         push	ax
25701                                           ! Debug: cast unsigned long = const 0 to unsigned short vspt = [S+$3E-8] (used reg = )
25702 7170           8B46         FA            mov	ax,-6[bp]
25703 7173           31DB                       xor	bx,bx
25704 7175           53                         push	bx
25705 7176           50                         push	ax
25706                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$42-$C] (used reg = )
25707 7177           8B46         F6            mov	ax,-$A[bp]
25708 717A           31DB                       xor	bx,bx
25709 717C           53                         push	bx
25710 717D           50                         push	ax
25711                                           ! Debug: cast unsigned long = const 0 to unsigned short vheads = [S+$46-6] (used reg = )
25712 717E           8B46         FC            mov	ax,-4[bp]
25713 7181           31DB                       xor	bx,bx
25714 7183           53                         push	bx
25715 7184           50                         push	ax
25716                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$4A-$10] (used reg = )
25717 7185           8B46         F2            mov	ax,-$E[bp]
25718 7188           31DB                       xor	bx,bx
25719                                           ! Debug: mul unsigned long (temp) = [S+$4A-$4A] to unsigned long = bx+0 (used reg = )
25720 718A           8D7E         B8            lea	di,-$E+..FFE1[bp]
25721 718D           E8         8F2A            call	lmulul
25722 7190           83C4                   04  add	sp,*4
25723                                           ! Debug: add unsigned long (temp) = [S+$46-$46] to unsigned long = bx+0 (used reg = )
25724 7193           8D7E         BC            lea	di,-$A+..FFE1[bp]
25725 7196           E8         8EFB            call	laddul
25726 7199           83C4                   04  add	sp,*4
25727                                           ! Debug: mul unsigned long (temp) = [S+$42-$42] to unsigned long = bx+0 (used reg = )
25728 719C           8D7E         C0            lea	di,-6+..FFE1[bp]
25729 719F           E8         8F18            call	lmulul
25730 71A2           83C4                   04  add	sp,*4
25731                                           ! Debug: add unsigned long (temp) = [S+$3E-$3E] to unsigned long = bx+0 (used reg = )
25732 71A5           8D7E         C4            lea	di,-2+..FFE1[bp]
25733 71A8           E8         8EE9            call	laddul
25734 71AB           83C4                   04  add	sp,*4
25735                                           ! Debug: eq unsigned long = bx+0 to unsigned long vlba = [S+$3A-$18] (used reg = )
25736 71AE           8946         EA            mov	-$16[bp],ax
25737 71B1           895E         EC            mov	-$14[bp],bx
25738                                           !BCC_EOS
25739                                           ! 4423       *((Bit8u *)&AX) = (nbsectors);
25740                                           ! Debug: eq unsigned short nbsectors = [S+$3A-$12] to unsigned char AX = [S+$3A+$14] (used reg = )
25741 71B4           8A46         F0            mov	al,-$10[bp]
25742 71B7           8846         16            mov	$16[bp],al
25743                                           !BCC_EOS
25744                                           ! 4424       slba = (Bit32u)vlba/4;
25745                                           ! Debug: div unsigned long = const 4 to unsigned long vlba = [S+$3A-$18] (used reg = )
25746 71BA           B8                   0004  mov	ax,*4
25747 71BD           31DB                       xor	bx,bx
25748 71BF           53                         push	bx
25749 71C0           50                         push	ax
25750 71C1           8B46         EA            mov	ax,-$16[bp]
25751 71C4           8B5E         EC            mov	bx,-$14[bp]
25752 71C7           8D7E         C4            lea	di,-2+..FFE1[bp]
25753 71CA           E8         8F72            call	ldivul
25754 71CD           83C4                   04  add	sp,*4
25755                                           ! Debug: eq unsigned long = bx+0 to unsigned long slba = [S+$3A-$20] (used reg = )
25756 71D0           8946         E2            mov	-$1E[bp],ax
25757 71D3           895E         E4            mov	-$1C[bp],bx
25758                                           !BCC_EOS
25759                                           ! 4425       before= (Bit16u)vlba%4;
25760                                           ! Debug: mod int = const 4 to unsigned short vlba = [S+$3A-$18] (used reg = )
25761 71D6           8B46         EA            mov	ax,-$16[bp]
25762 71D9           24                     03  and	al,*3
25763                                           ! Debug: eq unsigned char = al+0 to unsigned short before = [S+$3A-$2A] (used reg = )
25764 71DB           30E4                       xor	ah,ah
25765 71DD           8946         D8            mov	-$28[bp],ax
25766                                           !BCC_EOS
25767                                           ! 4426       elba = (Bit32u)(vlba+nbsectors-1)/4;
25768                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$3A-$12] (used reg = )
25769 71E0           8B46         F0            mov	ax,-$10[bp]
25770 71E3           31DB                       xor	bx,bx
25771                                           ! Debug: add unsigned long = bx+0 to unsigned long vlba = [S+$3A-$18] (used reg = )
25772                                           ! Debug: expression subtree swapping
25773 71E5           8D7E         EA            lea	di,-$16[bp]
25774 71E8           E8         8EA9            call	laddul
25775                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
25776 71EB           53                         push	bx
25777 71EC           50                         push	ax
25778 71ED           B8                   0001  mov	ax,*1
25779 71F0           31DB                       xor	bx,bx
25780 71F2           53                         push	bx
25781 71F3           50                         push	ax
25782 71F4           8B46         C4            mov	ax,-2+..FFE1[bp]
25783 71F7           8B5E         C6            mov	bx,0+..FFE1[bp]
25784 71FA           8D7E         C0            lea	di,-6+..FFE1[bp]
25785 71FD           E8         8EB2            call	lsubul
25786 7200           83C4                   08  add	sp,*8
25787                                           ! Debug: cast unsigned long = const 0 to unsigned long = bx+0 (used reg = )
25788                                           ! Debug: div unsigned long = const 4 to unsigned long = bx+0 (used reg = )
25789 7203           53                         push	bx
25790 7204           50                         push	ax
25791 7205           B8                   0004  mov	ax,*4
25792 7208           31DB                       xor	bx,bx
25793 720A           53                         push	bx
25794 720B           50                         push	ax
25795 720C           8B46         C4            mov	ax,-2+..FFE1[bp]
25796 720F           8B5E         C6            mov	bx,0+..FFE1[bp]
25797 7212           8D7E         C0            lea	di,-6+..FFE1[bp]
25798 7215           E8         8F27            call	ldivul
25799 7218           83C4                   08  add	sp,*8
25800                                           ! Debug: eq unsigned long = bx+0 to unsigned long elba = [S+$3A-$24] (used reg = )
25801 721B           8946         DE            mov	-$22[bp],ax
25802 721E           895E         E0            mov	-$20[bp],bx
25803                                           !BCC_EOS
25804                                           ! 4427       _memsetb(0,atacmd,get_SS(),12);
25805                                           ! Debug: list int = const $C (used reg = )
25806 7221           B8                   000C  mov	ax,*$C
25807 7224           50                         push	ax
25808                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
25809 7225           E8         9437            call	_get_SS
25810                                           ! Debug: list unsigned short = ax+0 (used reg = )
25811 7228           50                         push	ax
25812                                           ! Debug: list * unsigned char atacmd = S+$3E-$3A (used reg = )
25813 7229           8D5E         C8            lea	bx,-$38[bp]
25814 722C           53                         push	bx
25815                                           ! Debug: list int = const 0 (used reg = )
25816 722D           31C0                       xor	ax,ax
25817 722F           50                         push	ax
25818                                           ! Debug: func () void = _memsetb+0 (used reg = )
25819 7230           E8         8DCD            call	__memsetb
25820 7233           83C4                   08  add	sp,*8
25821                                           !BCC_EOS
25822                                           ! 4428       atacmd[0]=0x28;
25823                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$3A-$3A] (used reg = )
25824 7236           B0                     28  mov	al,*$28
25825 7238           8846         C8            mov	-$38[bp],al
25826                                           !BCC_EOS
25827                                           ! 4429       count = (Bit16u)(elba-slba)+1;
25828                                           ! Debug: sub unsigned long slba = [S+$3A-$20] to unsigned long elba = [S+$3A-$24] (used reg = )
25829 723B           8B46         DE            mov	ax,-$22[bp]
25830 723E           8B5E         E0            mov	bx,-$20[bp]
25831 7241           8D7E         E2            lea	di,-$1E[bp]
25832 7244           E8         8E6B            call	lsubul
25833                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
25834                                           ! Debug: add int = const 1 to unsigned short = ax+0 (used reg = )
25835                                           ! Debug: eq unsigned int = ax+1 to unsigned short count = [S+$3A-$14] (used reg = )
25836 7247           40                         inc	ax
25837 7248           8946         EE            mov	-$12[bp],ax
25838                                           !BCC_EOS
25839                                           ! 4430       atacmd[7]=*(((Bit8u *)&count)+1);
25840                                           ! Debug: eq unsigned char count = [S+$3A-$13] to unsigned char atacmd = [S+$3A-$33] (used reg = )
25841 724B           8A46         EF            mov	al,-$11[bp]
25842 724E           8846         CF            mov	-$31[bp],al
25843                                           !BCC_EOS
25844                                           ! 4431       atacmd[8]=*((Bit8u *)&count);
25845                                           ! Debug: eq unsigned char count = [S+$3A-$14] to unsigned char atacmd = [S+$3A-$32] (used reg = )
25846 7251           8A46         EE            mov	al,-$12[bp]
25847 7254           8846         D0            mov	-$30[bp],al
25848                                           !BCC_EOS
25849                                           ! 4432       lba = ilba+slba;
25850                                           ! Debug: add unsigned long slba = [S+$3A-$20] to unsigned long ilba = [S+$3A-$1C] (used reg = )
25851 7257           8B46         E6            mov	ax,-$1A[bp]
25852 725A           8B5E         E8            mov	bx,-$18[bp]
25853 725D           8D7E         E2            lea	di,-$1E[bp]
25854 7260           E8         8E31            call	laddul
25855                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$3A-$28] (used reg = )
25856 7263           8946         DA            mov	-$26[bp],ax
25857 7266           895E         DC            mov	-$24[bp],bx
25858                                           !BCC_EOS
25859                                           ! 4433       atacmd[2]=*(((Bit8u *)&*(((Bit16u *)&lba)+1))+1);
25860                                           ! Debug: eq unsigned char lba = [S+$3A-$25] to unsigned char atacmd = [S+$3A-$38] (used reg = )
25861 7269           8A46         DD            mov	al,-$23[bp]
25862 726C           8846         CA            mov	-$36[bp],al
25863                                           !BCC_EOS
25864                                           ! 4434       atacmd[3]=*((Bit8u *)&*(((Bit16u *)&lba)+1));
25865                                           ! Debug: eq unsigned char lba = [S+$3A-$26] to unsigned char atacmd = [S+$3A-$37] (used reg = )
25866 726F           8A46         DC            mov	al,-$24[bp]
25867 7272           8846         CB            mov	-$35[bp],al
25868                                           !BCC_EOS
25869                                           ! 4435       atacmd[4]=*(((Bit8u *)&*((Bit16u *)&lba))+1);
25870                                           ! Debug: eq unsigned char lba = [S+$3A-$27] to unsigned char atacmd = [S+$3A-$36] (used reg = )
25871 7275           8A46         DB            mov	al,-$25[bp]
25872 7278           8846         CC            mov	-$34[bp],al
25873                                           !BCC_EOS
25874                                           ! 4436       atacmd[5]=*((Bit8u *)&lba);
25875                                           ! Debug: eq unsigned char lba = [S+$3A-$28] to unsigned char atacmd = [S+$3A-$35] (used reg = )
25876 727B           8A46         DA            mov	al,-$26[bp]
25877 727E           8846         CD            mov	-$33[bp],al
25878                                           !BCC_EOS
25879                                           ! 4437       if((status = ata_cmd_packet(device, 12, get_SS(), atacmd, before*512, nbsectors*512L, 0x01, segment,offset)) != 0) {
25880                                           ! Debug: list unsigned short offset = [S+$3A-$2E] (used reg = )
25881 7281           FF76         D4            push	-$2C[bp]
25882                                           ! Debug: list unsigned short segment = [S+$3C-$2C] (used reg = )
25883 7284           FF76         D6            push	-$2A[bp]
25884                                           ! Debug: list int = const 1 (used reg = )
25885 7287           B8                   0001  mov	ax,*1
25886 728A           50                         push	ax
25887                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$40-$12] (used reg = )
25888 728B           8B46         F0            mov	ax,-$10[bp]
25889 728E           31DB                       xor	bx,bx
25890                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
25891 7290           53                         push	bx
25892 7291           50                         push	ax
25893 7292           B8                   0200  mov	ax,#$200
25894 7295           31DB                       xor	bx,bx
25895 7297           53                         push	bx
25896 7298           50                         push	ax
25897 7299           8B46         BE            mov	ax,-8+..FFE1[bp]
25898 729C           8B5E         C0            mov	bx,-6+..FFE1[bp]
25899 729F           8D7E         BA            lea	di,-$C+..FFE1[bp]
25900 72A2           E8         8E15            call	lmulul
25901 72A5           83C4                   08  add	sp,*8
25902                                           ! Debug: list unsigned long = bx+0 (used reg = )
25903 72A8           53                         push	bx
25904 72A9           50                         push	ax
25905                                           ! Debug: mul int = const $200 to unsigned short before = [S+$44-$2A] (used reg = )
25906 72AA           8B46         D8            mov	ax,-$28[bp]
25907 72AD           B9                   0200  mov	cx,#$200
25908 72B0           F7E9                       imul	cx
25909                                           ! Debug: list unsigned int = ax+0 (used reg = )
25910 72B2           50                         push	ax
25911                                           ! Debug: list * unsigned char atacmd = S+$46-$3A (used reg = )
25912 72B3           8D5E         C8            lea	bx,-$38[bp]
25913 72B6           53                         push	bx
25914                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
25915 72B7           E8         93A5            call	_get_SS
25916                                           ! Debug: list unsigned short = ax+0 (used reg = )
25917 72BA           50                         push	ax
25918                                           ! Debug: list int = const $C (used reg = )
25919 72BB           B8                   000C  mov	ax,*$C
25920 72BE           50                         push	ax
25921                                           ! Debug: list unsigned char device = [S+$4C-3] (used reg = )
25922 72BF           8A46         FF            mov	al,-1[bp]
25923 72C2           30E4                       xor	ah,ah
25924 72C4           50                         push	ax
25925                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
25926 72C5           E8         BA86            call	_ata_cmd_packet
25927 72C8           83C4                   14  add	sp,*$14
25928                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$3A-4] (used reg = )
25929 72CB           8846         FE            mov	-2[bp],al
25930                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
25931 72CE           84C0                       test	al,al
25932 72D0           74           2A            je  	.63B
25933                       000072D2            .63C:
25934                                           ! 4438         bios_printf(4, "int13_cdemu: function %02x, error %02x !\n",*(((Bit8u *)&AX)+1),status);
25935                                           ! Debug: list unsigned char status = [S+$3A-4] (used reg = )
25936 72D2           8A46         FE            mov	al,-2[bp]
25937 72D5           30E4                       xor	ah,ah
25938 72D7           50                         push	ax
25939                                           ! Debug: list unsigned char AX = [S+$3C+$15] (used reg = )
25940 72D8           8A46         17            mov	al,$17[bp]
25941 72DB           30E4                       xor	ah,ah
25942 72DD           50                         push	ax
25943                                           ! Debug: list * char = .63D+0 (used reg = )
25944 72DE           BB                   CE91  mov	bx,#.63D
25945 72E1           53                         push	bx
25946                                           ! Debug: list int = const 4 (used reg = )
25947 72E2           B8                   0004  mov	ax,*4
25948 72E5           50                         push	ax
25949                                           ! Debug: func () void = bios_printf+0 (used reg = )
25950 72E6           E8         9655            call	_bios_printf
25951 72E9           83C4                   08  add	sp,*8
25952                                           !BCC_EOS
25953                                           ! 4439         *(((Bit8u *)&AX)+1) = (0x02);
25954                                           ! Debug: eq int = const 2 to unsigned char AX = [S+$3A+$15] (used reg = )
25955 72EC           B0                     02  mov	al,*2
25956 72EE           8846         17            mov	$17[bp],al
25957                                           !BCC_EOS
25958                                           ! 4440         *((Bit8u *)&AX) = (0);
25959                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$3A+$14] (used reg = )
25960 72F1           30C0                       xor	al,al
25961 72F3           8846         16            mov	$16[bp],al
25962                                           !BCC_EOS
25963                                           ! 4441         goto int13_fail_noah;
25964 72F6           83C4                   00  add	sp,#..FFDF-..FFE1
25965 72F9           E9         0139            br 	.FFDF
25966                                           !BCC_EOS
25967                                           ! 4442       }
25968                                           ! 4443       goto int13_success;
25969                       000072FC            .63B:
25970 72FC           83C4                   00  add	sp,#..FFE0-..FFE1
25971 72FF           E9         0153            br 	.FFE0
25972                                           !BCC_EOS
25973                                           ! 4444       break;
25974 7302           E9         012B            br 	.620
25975                                           !BCC_EOS
25976                                           ! 4445     case 0x08:
25977                                           ! 4446       vspt=*((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt));
25978                       00007305            .63E:
25979                                           ! Debug: eq unsigned short = [+$26E] to unsigned short vspt = [S+$3A-8] (used reg = )
25980 7305           A1         026E            mov	ax,[$26E]
25981 7308           8946         FA            mov	-6[bp],ax
25982                                           !BCC_EOS
25983                                           ! 4447       vcylinders=*((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders)) - 1;
25984                                           ! Debug: sub int = const 1 to unsigned short = [+$26C] (used reg = )
25985 730B           A1         026C            mov	ax,[$26C]
25986                                           ! Debug: eq unsigned int = ax-1 to unsigned short vcylinders = [S+$3A-$A] (used reg = )
25987 730E           48                         dec	ax
25988 730F           8946         F8            mov	-8[bp],ax
25989                                           !BCC_EOS
25990                                           ! 4448       vheads=*((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads)) - 1;
25991                                           ! Debug: sub int = const 1 to unsigned short = [+$26A] (used reg = )
25992 7312           A1         026A            mov	ax,[$26A]
25993                                           ! Debug: eq unsigned int = ax-1 to unsigned short vheads = [S+$3A-6] (used reg = )
25994 7315           48                         dec	ax
25995 7316           8946         FC            mov	-4[bp],ax
25996                                           !BCC_EOS
25997                                           ! 4449       *((Bit8u *)&AX) = (0x00);
25998                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$3A+$14] (used reg = )
25999 7319           30C0                       xor	al,al
26000 731B           8846         16            mov	$16[bp],al
26001                                           !BCC_EOS
26002                                           ! 4450       *((Bit8u *)&BX) = (0x00);
26003                                           ! Debug: eq int = const 0 to unsigned char BX = [S+$3A+$E] (used reg = )
26004 731E           30C0                       xor	al,al
26005 7320           8846         10            mov	$10[bp],al
26006                                           !BCC_EOS
26007                                           ! 4451       *(((Bit8u *)&CX)+1) = (vcylinders & 0xff);
26008                                           ! Debug: and int = const $FF to unsigned short vcylinders = [S+$3A-$A] (used reg = )
26009 7323           8A46         F8            mov	al,-8[bp]
26010                                           ! Debug: eq unsigned char = al+0 to unsigned char CX = [S+$3A+$13] (used reg = )
26011 7326           8846         15            mov	$15[bp],al
26012                                           !BCC_EOS
26013                                           ! 4452       *((Bit8u *)&CX) = (((vcylinders >> 2) & 0xc0) | (vspt & 0x3f));
26014                                           ! Debug: and int = const $3F to unsigned short vspt = [S+$3A-8] (used reg = )
26015 7329           8A46         FA            mov	al,-6[bp]
26016 732C           24                     3F  and	al,*$3F
26017 732E           50                         push	ax
26018                                           ! Debug: sr int = const 2 to unsigned short vcylinders = [S+$3C-$A] (used reg = )
26019 732F           8B46         F8            mov	ax,-8[bp]
26020 7332           D1E8                       shr	ax,*1
26021 7334           D1E8                       shr	ax,*1
26022                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
26023 7336           24                     C0  and	al,#$C0
26024                                           ! Debug: or unsigned char (temp) = [S+$3C-$3C] to unsigned char = al+0 (used reg = )
26025 7338           0A46         C6            or	al,0+..FFE1[bp]
26026 733B           44                         inc	sp
26027 733C           44                         inc	sp
26028                                           ! Debug: eq unsigned char = al+0 to unsigned char CX = [S+$3A+$12] (used reg = )
26029 733D           8846         14            mov	$14[bp],al
26030                                           !BCC_EOS
26031                                           ! 4453       *(((Bit8u *)&DX)+1) = (vheads);
26032                                           ! Debug: eq unsigned short vheads = [S+$3A-6] to unsigned char DX = [S+$3A+$11] (used reg = )
26033 7340           8A46         FC            mov	al,-4[bp]
26034 7343           8846         13            mov	$13[bp],al
26035                                           !BCC_EOS
26036                                           ! 4454       *((Bit8u *)&DX) = (0x02);
26037                                           ! Debug: eq int = const 2 to unsigned char DX = [S+$3A+$10] (used reg = )
26038 7346           B0                     02  mov	al,*2
26039 7348           8846         12            mov	$12[bp],al
26040                                           !BCC_EOS
26041                                           ! 4455       switch(*((Bit8u *)(&((ebda_data_t *) 0)->cdemu
26042                                           ! 4455 .media))) {
26043 734B           A0         025B            mov	al,[$25B]
26044 734E           EB           17            jmp .641
26045                                           ! 4456         case 0x01: *((Bit8u *)&BX) = (0x02); break;
26046                       00007350            .642:
26047                                           ! Debug: eq int = const 2 to unsigned char BX = [S+$3A+$E] (used reg = )
26048 7350           B0                     02  mov	al,*2
26049 7352           8846         10            mov	$10[bp],al
26050                                           !BCC_EOS
26051 7355           EB           1C            jmp .63F
26052                                           !BCC_EOS
26053                                           ! 4457         case 0x02: *((Bit8u *)&BX) = (0x04); break;
26054                       00007357            .643:
26055                                           ! Debug: eq int = const 4 to unsigned char BX = [S+$3A+$E] (used reg = )
26056 7357           B0                     04  mov	al,*4
26057 7359           8846         10            mov	$10[bp],al
26058                                           !BCC_EOS
26059 735C           EB           15            jmp .63F
26060                                           !BCC_EOS
26061                                           ! 4458         case 0x03: *((Bit8u *)&BX) = (0x06); break;
26062                       0000735E            .644:
26063                                           ! Debug: eq int = const 6 to unsigned char BX = [S+$3A+$E] (used reg = )
26064 735E           B0                     06  mov	al,*6
26065 7360           8846         10            mov	$10[bp],al
26066                                           !BCC_EOS
26067 7363           EB           0E            jmp .63F
26068                                           !BCC_EOS
26069                                           ! 4459     }
26070                                           ! 4460 #asm
26071 7365           EB           0C            jmp .63F
26072                       00007367            .641:
26073 7367           2C                     01  sub	al,*1
26074 7369           74           E5            je 	.642
26075 736B           2C                     01  sub	al,*1
26076 736D           74           E8            je 	.643
26077 736F           2C                     01  sub	al,*1
26078 7371           74           EB            je 	.644
26079                       00007373            .63F:
26080                                           !BCC_EOS
26081                                           !BCC_ASM
26082                       00000044            _int13_cdemu.BP	set	$44
26083                       0000000C            .int13_cdemu.BP	set	$C
26084                       00000052            _int13_cdemu.CS	set	$52
26085                       0000001A            .int13_cdemu.CS	set	$1A
26086                       00000028            _int13_cdemu.nbsectors	set	$28
26087                       FFFFFFF0            .int13_cdemu.nbsectors	set	-$10
26088                       00000026            _int13_cdemu.count	set	$26
26089                       FFFFFFEE            .int13_cdemu.count	set	-$12
26090                       0000004C            _int13_cdemu.CX	set	$4C
26091                       00000014            .int13_cdemu.CX	set	$14
26092                       00000016            _int13_cdemu.elba	set	$16
26093                       FFFFFFDE            .int13_cdemu.elba	set	-$22
26094                       0000000E            _int13_cdemu.segment	set	$E
26095                       FFFFFFD6            .int13_cdemu.segment	set	-$2A
26096                       00000040            _int13_cdemu.DI	set	$40
26097                       00000008            .int13_cdemu.DI	set	8
26098                       00000054            _int13_cdemu.FLAGS	set	$54
26099                       0000001C            .int13_cdemu.FLAGS	set	$1C
26100                       00000030            _int13_cdemu.vcylinders	set	$30
26101                       FFFFFFF8            .int13_cdemu.vcylinders	set	-8
26102                       0000002C            _int13_cdemu.sector	set	$2C
26103                       FFFFFFF4            .int13_cdemu.sector	set	-$C
26104                       0000003C            _int13_cdemu.DS	set	$3C
26105                       00000004            .int13_cdemu.DS	set	4
26106                       0000002E            _int13_cdemu.head	set	$2E
26107                       FFFFFFF6            .int13_cdemu.head	set	-$A
26108                       0000002A            _int13_cdemu.cylinder	set	$2A
26109                       FFFFFFF2            .int13_cdemu.cylinder	set	-$E
26110                       0000004A            _int13_cdemu.DX	set	$4A
26111                       00000012            .int13_cdemu.DX	set	$12
26112                       00000037            _int13_cdemu.device	set	$37
26113                       FFFFFFFF            .int13_cdemu.device	set	-1
26114                       0000003E            _int13_cdemu.ES	set	$3E
26115                       00000006            .int13_cdemu.ES	set	6
26116                       00000032            _int13_cdemu.vspt	set	$32
26117                       FFFFFFFA            .int13_cdemu.vspt	set	-6
26118                       00000022            _int13_cdemu.vlba	set	$22
26119                       FFFFFFEA            .int13_cdemu.vlba	set	-$16
26120                       00000042            _int13_cdemu.SI	set	$42
26121                       0000000A            .int13_cdemu.SI	set	$A
26122                       00000050            _int13_cdemu.IP	set	$50
26123                       00000018            .int13_cdemu.IP	set	$18
26124                       00000012            _int13_cdemu.lba	set	$12
26125                       FFFFFFDA            .int13_cdemu.lba	set	-$26
26126                       00000036            _int13_cdemu.status	set	$36
26127                       FFFFFFFE            .int13_cdemu.status	set	-2
26128                       00000000            _int13_cdemu.atacmd	set	0
26129                       FFFFFFC8            .int13_cdemu.atacmd	set	-$38
26130                       0000004E            _int13_cdemu.AX	set	$4E
26131                       00000016            .int13_cdemu.AX	set	$16
26132                       0000001E            _int13_cdemu.ilba	set	$1E
26133                       FFFFFFE6            .int13_cdemu.ilba	set	-$1A
26134                       00000010            _int13_cdemu.before	set	$10
26135                       FFFFFFD8            .int13_cdemu.before	set	-$28
26136                       0000000C            _int13_cdemu.offset	set	$C
26137                       FFFFFFD4            .int13_cdemu.offset	set	-$2C
26138                       0000001A            _int13_cdemu.slba	set	$1A
26139                       FFFFFFE2            .int13_cdemu.slba	set	-$1E
26140                       00000046            _int13_cdemu.SP	set	$46
26141                       0000000E            .int13_cdemu.SP	set	$E
26142                       00000034            _int13_cdemu.vheads	set	$34
26143                       FFFFFFFC            .int13_cdemu.vheads	set	-4
26144                       00000048            _int13_cdemu.BX	set	$48
26145                       00000010            .int13_cdemu.BX	set	$10
26146 7373           55                               push bp
26147 7374           89E5                             mov bp, sp
26148 7376           B8                   EFDE        mov ax, #diskette_param_table2
26149 7379           8946         42                  mov _int13_cdemu.DI+2[bp], ax
26150 737C           8C4E         40                  mov _int13_cdemu.ES+2[bp], cs
26151 737F           5D                               pop bp
26152                                           ! 4467 endasm
26153                                           !BCC_ENDASM
26154                                           !BCC_EOS
26155                                           ! 4468       goto int13_success;
26156 7380           83C4                   00  add	sp,#..FFE0-..FFE1
26157 7383           E9         00CF            br 	.FFE0
26158                                           !BCC_EOS
26159                                           ! 4469       break;
26160 7386           E9         00A7            br 	.620
26161                                           !BCC_EOS
26162                                           ! 4470     case 0x15:
26163                                           ! 4471       *(((Bit8u *)&AX)+1) = (0x03);
26164                       00007389            .645:
26165                                           ! Debug: eq int = const 3 to unsigned char AX = [S+$3A+$15] (used reg = )
26166 7389           B0                     03  mov	al,*3
26167 738B           8846         17            mov	$17[bp],al
26168                                           !BCC_EOS
26169                                           ! 4472       goto int13_success_noah;
26170 738E           83C4                   00  add	sp,#..FFDD-..FFE1
26171 7391           E9         00C6            br 	.FFDD
26172                                           !BCC_EOS
26173                                           ! 4473       break;
26174 7394           E9         0099            br 	.620
26175                                           !BCC_EOS
26176                                           ! 4474     case 0x0a:
26177                                           ! 4475     case 0x0b:
26178                       00007397            .646:
26179                                           ! 4476     case 0x18:
26180                       00007397            .647:
26181                                           ! 4477     case 0x41:
26182                       00007397            .648:
26183                                           ! 4478     case 0x42:
26184                       00007397            .649:
26185                                           ! 4479     case 0x43:
26186                       00007397            .64A:
26187                                           ! 4480     case 0x44:
26188                       00007397            .64B:
26189                                           ! 4481     case 0x45:
26190                       00007397            .64C:
26191                                           ! 4482     case 0x46:
26192                       00007397            .64D:
26193                                           ! 4483     case 0x47:
26194                       00007397            .64E:
26195                                           ! 4484     case 0x48:
26196                       00007397            .64F:
26197                                           ! 4485     case 0x49:
26198                       00007397            .650:
26199                                           ! 4486     case 0x4e:
26200                       00007397            .651:
26201                                           ! 4487     case 0x50:
26202                       00007397            .652:
26203                                           ! 4488     default:
26204                       00007397            .653:
26205                                           ! 4489       bios_printf(4, "int13_cdemu function AH=%02x unsupported, returns fail\n", *(((Bit8u *)&AX)+1));
26206                       00007397            .654:
26207                                           ! Debug: list unsigned char AX = [S+$3A+$15] (used reg = )
26208 7397           8A46         17            mov	al,$17[bp]
26209 739A           30E4                       xor	ah,ah
26210 739C           50                         push	ax
26211                                           ! Debug: list * char = .655+0 (used reg = )
26212 739D           BB                   CE59  mov	bx,#.655
26213 73A0           53                         push	bx
26214                                           ! Debug: list int = const 4 (used reg = )
26215 73A1           B8                   0004  mov	ax,*4
26216 73A4           50                         push	ax
26217                                           ! Debug: func () void = bios_printf+0 (used reg = )
26218 73A5           E8         9596            call	_bios_printf
26219 73A8           83C4                   06  add	sp,*6
26220                                           !BCC_EOS
26221                                           ! 4490       goto int13_fail;
26222 73AB           83C4                   00  add	sp,#..FFE2-..FFE1
26223 73AE           E9         007F            jmp .FFE2
26224                                           !BCC_EOS
26225                                           ! 4491       break;
26226 73B1           EB           7D            jmp .620
26227                                           !BCC_EOS
26228                                           ! 4492   }
26229                                           ! 4493 int13_fail:
26230 73B3           EB           7B            jmp .620
26231                       000073B5            .622:
26232 73B5           2C                     00  sub	al,*0
26233 73B7           72           DE            jb 	.654
26234 73B9           3C                     18  cmp	al,*$18
26235 73BB           77           3D            ja  	.656
26236 73BD           30E4                       xor	ah,ah
26237 73BF           D1E0                       shl	ax,*1
26238 73C1           89C3                       mov	bx,ax
26239 73C3           2E                         seg	cs
26240 73C4           FFA7       73C8            br	.657[bx]
26241                       000073C8            .657:
26242 73C8                      706C            .word	.623
26243 73CA                      7083            .word	.62D
26244 73CC                      70C3            .word	.631
26245 73CE                      7075            .word	.62B
26246 73D0                      70C3            .word	.632
26247 73D2                      7075            .word	.62C
26248 73D4                      7397            .word	.654
26249 73D6                      7397            .word	.654
26250 73D8                      7305            .word	.63E
26251 73DA                      706C            .word	.624
26252 73DC                      7397            .word	.646
26253 73DE                      7397            .word	.647
26254 73E0                      706C            .word	.625
26255 73E2                      706C            .word	.626
26256 73E4                      7397            .word	.654
26257 73E6                      7397            .word	.654
26258 73E8                      706C            .word	.627
26259 73EA                      706C            .word	.628
26260 73EC                      7397            .word	.654
26261 73EE                      7397            .word	.654
26262 73F0                      706C            .word	.629
26263 73F2                      7389            .word	.645
26264 73F4                      706C            .word	.62A
26265 73F6                      7397            .word	.654
26266 73F8                      7397            .word	.648
26267                       000073FA            .656:
26268 73FA           2C                     41  sub	al,*$41
26269 73FC           72           99            jb 	.654
26270 73FE           3C                     0F  cmp	al,*$F
26271 7400           77           2B            ja  	.658
26272 7402           30E4                       xor	ah,ah
26273 7404           D1E0                       shl	ax,*1
26274 7406           89C3                       mov	bx,ax
26275 7408           2E                         seg	cs
26276 7409           FFA7       740D            br	.659[bx]
26277                       0000740D            .659:
26278 740D                      7397            .word	.649
26279 740F                      7397            .word	.64A
26280 7411                      7397            .word	.64B
26281 7413                      7397            .word	.64C
26282 7415                      7397            .word	.64D
26283 7417                      7397            .word	.64E
26284 7419                      7397            .word	.64F
26285 741B                      7397            .word	.650
26286 741D                      7397            .word	.651
26287 741F                      7397            .word	.654
26288 7421                      7397            .word	.654
26289 7423                      7397            .word	.654
26290 7425                      7397            .word	.654
26291 7427                      7397            .word	.652
26292 7429                      7397            .word	.654
26293 742B                      7397            .word	.653
26294                       0000742D            .658:
26295 742D           E9         FF67            br 	.654
26296                       00007430            .620:
26297                       FFFFFFC6            ..FFE1	=	-$3A
26298                       00007430            .FFE2:
26299                       FFFFFFC6            ..FFE2	=	-$3A
26300                                           ! 4494   *(((Bit8u *)&AX)+1) = (0x01);
26301                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$3A+$15] (used reg = )
26302 7430           B0                     01  mov	al,*1
26303 7432           8846         17            mov	$17[bp],al
26304                                           !BCC_EOS
26305                                           ! 4495 int13_fail_noah:
26306                       00007435            .FFDF:
26307                       FFFFFFC6            ..FFDF	=	-$3A
26308                                           ! 4496   _write_byte(*(((Bit8u *)&AX)+1), 0x0074, 0x0040);
26309                                           ! Debug: list int = const $40 (used reg = )
26310 7435           B8                   0040  mov	ax,*$40
26311 7438           50                         push	ax
26312                                           ! Debug: list int = const $74 (used reg = )
26313 7439           B8                   0074  mov	ax,*$74
26314 743C           50                         push	ax
26315                                           ! Debug: list unsigned char AX = [S+$3E+$15] (used reg = )
26316 743D           8A46         17            mov	al,$17[bp]
26317 7440           30E4                       xor	ah,ah
26318 7442           50                         push	ax
26319                                           ! Debug: func () void = _write_byte+0 (used reg = )
26320 7443           E8         91BA            call	__write_byte
26321 7446           83C4                   06  add	sp,*6
26322                                           !BCC_EOS
26323                                           ! 4497 int13_fail_nostatus:
26324                       00007449            .FFDE:
26325                       FFFFFFC6            ..FFDE	=	-$3A
26326                                           ! 4498   FLAGS |= 0x0001;
26327                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$3A+$1A] (used reg = )
26328 7449           8B46         1C            mov	ax,$1C[bp]
26329 744C           0C                     01  or	al,*1
26330 744E           8946         1C            mov	$1C[bp],ax
26331                                           !BCC_EOS
26332                                           ! 4499   return;
26333 7451           89EC                       mov	sp,bp
26334 7453           5D                         pop	bp
26335 7454           C3                         ret
26336                                           !BCC_EOS
26337                                           ! 4500 int13_success:
26338                       00007455            .FFE0:
26339                       FFFFFFC6            ..FFE0	=	-$3A
26340                                           ! 4501   *(((Bit8u *)&AX)+1) = (0x00);
26341                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$3A+$15] (used reg = )
26342 7455           30C0                       xor	al,al
26343 7457           8846         17            mov	$17[bp],al
26344                                           !BCC_EOS
26345                                           ! 4502 int13_success_noah:
26346                       0000745A            .FFDD:
26347                       FFFFFFC6            ..FFDD	=	-$3A
26348                                           ! 4503   _write_byte(0x00, 0x0074, 0x0040);
26349                                           ! Debug: list int = const $40 (used reg = )
26350 745A           B8                   0040  mov	ax,*$40
26351 745D           50                         push	ax
26352                                           ! Debug: list int = const $74 (used reg = )
26353 745E           B8                   0074  mov	ax,*$74
26354 7461           50                         push	ax
26355                                           ! Debug: list int = const 0 (used reg = )
26356 7462           31C0                       xor	ax,ax
26357 7464           50                         push	ax
26358                                           ! Debug: func () void = _write_byte+0 (used reg = )
26359 7465           E8         9198            call	__write_byte
26360 7468           83C4                   06  add	sp,*6
26361                                           !BCC_EOS
26362                                           ! 4504   FLAGS &= 0xfffe;
26363                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$3A+$1A] (used reg = )
26364 746B           8B46         1C            mov	ax,$1C[bp]
26365 746E           24                     FE  and	al,#$FE
26366 7470           8946         1C            mov	$1C[bp],ax
26367                                           !BCC_EOS
26368                                           ! 4505 }
26369 7473           89EC                       mov	sp,bp
26370 7475           5D                         pop	bp
26371 7476           C3                         ret
26372                                           ! 4506 void floppy_reset_controller()
26373                                           ! Register BX used in function int13_cdemu
26374                                           ! 4507 {
26375                                           export	_floppy_reset_controller
26376                       00007477            _floppy_reset_controller:
26377                                           ! 4508   Bit8u val8;
26378                                           !BCC_EOS
26379                                           ! 4509   val8 = inb(0x03f2);
26380 7477           55                         push	bp
26381 7478           89E5                       mov	bp,sp
26382 747A           4C                         dec	sp
26383 747B           4C                         dec	sp
26384                                           ! Debug: list int = const $3F2 (used reg = )
26385 747C           B8                   03F2  mov	ax,#$3F2
26386 747F           50                         push	ax
26387                                           ! Debug: func () unsigned char = inb+0 (used reg = )
26388 7480           E8         9075            call	_inb
26389 7483           44                         inc	sp
26390 7484           44                         inc	sp
26391                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
26392 7485           8846         FF            mov	-1[bp],al
26393                                           !BCC_EOS
26394                                           ! 4510   outb(0x03f2, val8 & ~0x04);
26395                                           ! Debug: and int = const -5 to unsigned char val8 = [S+4-3] (used reg = )
26396 7488           8A46         FF            mov	al,-1[bp]
26397 748B           24                     FB  and	al,#$FB
26398                                           ! Debug: list unsigned char = al+0 (used reg = )
26399 748D           30E4                       xor	ah,ah
26400 748F           50                         push	ax
26401                                           ! Debug: list int = const $3F2 (used reg = )
26402 7490           B8                   03F2  mov	ax,#$3F2
26403 7493           50                         push	ax
26404                                           ! Debug: func () void = outb+0 (used reg = )
26405 7494           E8         9077            call	_outb
26406 7497           83C4                   04  add	sp,*4
26407                                           !BCC_EOS
26408                                           ! 4511   outb(0x03f2, val8 | 0x04);
26409                                           ! Debug: or int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
26410 749A           8A46         FF            mov	al,-1[bp]
26411 749D           0C                     04  or	al,*4
26412                                           ! Debug: list unsigned char = al+0 (used reg = )
26413 749F           30E4                       xor	ah,ah
26414 74A1           50                         push	ax
26415                                           ! Debug: list int = const $3F2 (used reg = )
26416 74A2           B8                   03F2  mov	ax,#$3F2
26417 74A5           50                         push	ax
26418                                           ! Debug: func () void = outb+0 (used reg = )
26419 74A6           E8         9065            call	_outb
26420 74A9           83C4                   04  add	sp,*4
26421                                           !BCC_EOS
26422                                           ! 4512   do {
26423                       000074AC            .65C:
26424                                           ! 4513     val8 = inb(0x03f4);
26425                                           ! Debug: list int = const $3F4 (used reg = )
26426 74AC           B8                   03F4  mov	ax,#$3F4
26427 74AF           50                         push	ax
26428                                           ! Debug: func () unsigned char = inb+0 (used reg = )
26429 74B0           E8         9045            call	_inb
26430 74B3           44                         inc	sp
26431 74B4           44                         inc	sp
26432                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
26433 74B5           8846         FF            mov	-1[bp],al
26434                                           !BCC_EOS
26435                                           ! 4514   } while ((val8 & 0xc0) != 0x80);
26436                       000074B8            .65B:
26437                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+4-3] (used reg = )
26438 74B8           8A46         FF            mov	al,-1[bp]
26439 74BB           24                     C0  and	al,#$C0
26440                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
26441 74BD           3C                     80  cmp	al,#$80
26442 74BF           75           EB            jne	.65C
26443                       000074C1            .65D:
26444                                           !BCC_EOS
26445                                           ! 4515 }
26446                       000074C1            .65A:
26447 74C1           89EC                       mov	sp,bp
26448 74C3           5D                         pop	bp
26449 74C4           C3                         ret
26450                                           ! 4516 void floppy_prepare_controller(drive)
26451                                           ! 4517   Bit16u drive;
26452                                           export	_floppy_prepare_controller
26453                       000074C5            _floppy_prepare_controller:
26454                                           !BCC_EOS
26455                                           ! 4518 {
26456                                           ! 4519   Bit8u val8, dor, prev_reset;
26457                                           !BCC_EOS
26458                                           ! 4520   val8 = *((Bit8u *)(0x003e));
26459 74C5           55                         push	bp
26460 74C6           89E5                       mov	bp,sp
26461 74C8           83C4                   FC  add	sp,*-4
26462                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+6-3] (used reg = )
26463 74CB           A0         003E            mov	al,[$3E]
26464 74CE           8846         FF            mov	-1[bp],al
26465                                           !BCC_EOS
26466                                           ! 4521   val8 &= 0x7f;
26467                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
26468 74D1           8A46         FF            mov	al,-1[bp]
26469 74D4           24                     7F  and	al,*$7F
26470 74D6           8846         FF            mov	-1[bp],al
26471                                           !BCC_EOS
26472                                           ! 4522   *((Bit8u *)(0x003e)) = (val8);
26473                                           ! Debug: eq unsigned char val8 = [S+6-3] to unsigned char = [+$3E] (used reg = )
26474 74D9           8A46         FF            mov	al,-1[bp]
26475 74DC           A2         003E            mov	[$3E],al
26476                                           !BCC_EOS
26477                                           ! 4523   prev_reset = inb(0x03f2) & 0x04;
26478                                           ! Debug: list int = const $3F2 (used reg = )
26479 74DF           B8                   03F2  mov	ax,#$3F2
26480 74E2           50                         push	ax
26481                                           ! Debug: func () unsigned char = inb+0 (used reg = )
26482 74E3           E8         9012            call	_inb
26483 74E6           44                         inc	sp
26484 74E7           44                         inc	sp
26485                                           ! Debug: and int = const 4 to unsigned char = al+0 (used reg = )
26486 74E8           24                     04  and	al,*4
26487                                           ! Debug: eq unsigned char = al+0 to unsigned char prev_reset = [S+6-5] (used reg = )
26488 74EA           8846         FD            mov	-3[bp],al
26489                                           !BCC_EOS
26490                                           ! 4524   if (drive)
26491 74ED           8B46         04            mov	ax,4[bp]
26492 74F0           85C0                       test	ax,ax
26493 74F2           74           07            je  	.65E
26494                       000074F4            .65F:
26495                                           ! 4525     dor = 0x20;
26496                                           ! Debug: eq int = const $20 to unsigned char dor = [S+6-4] (used reg = )
26497 74F4           B0                     20  mov	al,*$20
26498 74F6           8846         FE            mov	-2[bp],al
26499                                           !BCC_EOS
26500                                           ! 4526   else
26501                                           ! 4527     dor = 0x10;
26502 74F9           EB           05            jmp .660
26503                       000074FB            .65E:
26504                                           ! Debug: eq int = const $10 to unsigned char dor = [S+6-4] (used reg = )
26505 74FB           B0                     10  mov	al,*$10
26506 74FD           8846         FE            mov	-2[bp],al
26507                                           !BCC_EOS
26508                                           ! 4528   dor |= 0x0c;
26509                       00007500            .660:
26510                                           ! Debug: orab int = const $C to unsigned char dor = [S+6-4] (used reg = )
26511 7500           8A46         FE            mov	al,-2[bp]
26512 7503           0C                     0C  or	al,*$C
26513 7505           8846         FE            mov	-2[bp],al
26514                                           !BCC_EOS
26515                                           ! 4529   dor |= drive;
26516                                           ! Debug: orab unsigned short drive = [S+6+2] to unsigned char dor = [S+6-4] (used reg = )
26517 7508           8B46         04            mov	ax,4[bp]
26518 750B           0A46         FE            or	al,-2[bp]
26519 750E           8846         FE            mov	-2[bp],al
26520                                           !BCC_EOS
26521                                           ! 4530   outb(0x03f2, dor);
26522                                           ! Debug: list unsigned char dor = [S+6-4] (used reg = )
26523 7511           8A46         FE            mov	al,-2[bp]
26524 7514           30E4                       xor	ah,ah
26525 7516           50                         push	ax
26526                                           ! Debug: list int = const $3F2 (used reg = )
26527 7517           B8                   03F2  mov	ax,#$3F2
26528 751A           50                         push	ax
26529                                           ! Debug: func () void = outb+0 (used reg = )
26530 751B           E8         8FF0            call	_outb
26531 751E           83C4                   04  add	sp,*4
26532                                           !BCC_EOS
26533                                           ! 4531   *((Bit8u *)(0x40)) = (37);
26534                                           ! Debug: eq int = const $25 to unsigned char = [+$40] (used reg = )
26535 7521           B0                     25  mov	al,*$25
26536 7523           A2         0040            mov	[$40],al
26537                                           !BCC_EOS
26538                                           ! 4532   do {
26539                       00007526            .663:
26540                                           ! 4533     val8 = inb(0x03f4);
26541                                           ! Debug: list int = const $3F4 (used reg = )
26542 7526           B8                   03F4  mov	ax,#$3F4
26543 7529           50                         push	ax
26544                                           ! Debug: func () unsigned char = inb+0 (used reg = )
26545 752A           E8         8FCB            call	_inb
26546 752D           44                         inc	sp
26547 752E           44                         inc	sp
26548                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
26549 752F           8846         FF            mov	-1[bp],al
26550                                           !BCC_EOS
26551                                           ! 4534   } while ( (val8 & 0xc0) != 0x80 );
26552                       00007532            .662:
26553                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+6-3] (used reg = )
26554 7532           8A46         FF            mov	al,-1[bp]
26555 7535           24                     C0  and	al,#$C0
26556                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
26557 7537           3C                     80  cmp	al,#$80
26558 7539           75           EB            jne	.663
26559                       0000753B            .664:
26560                                           !BCC_EOS
26561                                           ! 4535   if (prev_reset == 0) {
26562                       0000753B            .661:
26563                                           ! Debug: logeq int = const 0 to unsigned char prev_reset = [S+6-5] (used reg = )
26564 753B           8A46         FD            mov	al,-3[bp]
26565 753E           84C0                       test	al,al
26566 7540           75           1F            jne 	.665
26567                       00007542            .666:
26568                                           ! 4536 #asm
26569                                           !BCC_EOS
26570                                           !BCC_ASM
26571                       00000002            _floppy_prepare_controller.dor	set	2
26572                       FFFFFFFE            .floppy_prepare_controller.dor	set	-2
26573                       00000001            _floppy_prepare_controller.prev_reset	set	1
26574                       FFFFFFFD            .floppy_prepare_controller.prev_reset	set	-3
26575                       00000003            _floppy_prepare_controller.val8	set	3
26576                       FFFFFFFF            .floppy_prepare_controller.val8	set	-1
26577                       00000008            _floppy_prepare_controller.drive	set	8
26578                       00000004            .floppy_prepare_controller.drive	set	4
26579 7542           FB                             sti
26580                                           ! 4538 endasm
26581                                           !BCC_ENDASM
26582                                           !BCC_EOS
26583                                           ! 4539     do {
26584                       00007543            .669:
26585                                           ! 4540       val8 = *((Bit8u *)(0x003e));
26586                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+6-3] (used reg = )
26587 7543           A0         003E            mov	al,[$3E]
26588 7546           8846         FF            mov	-1[bp],al
26589                                           !BCC_EOS
26590                                           ! 4541     } while ( (val8 & 0x80) == 0 );
26591                       00007549            .668:
26592                                           ! Debug: and int = const $80 to unsigned char val8 = [S+6-3] (used reg = )
26593 7549           8A46         FF            mov	al,-1[bp]
26594 754C           24                     80  and	al,#$80
26595                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
26596 754E           84C0                       test	al,al
26597 7550           74           F1            je 	.669
26598                       00007552            .66A:
26599                                           !BCC_EOS
26600                                           ! 4542     val8 &= 0x7f;
26601                       00007552            .667:
26602                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
26603 7552           8A46         FF            mov	al,-1[bp]
26604 7555           24                     7F  and	al,*$7F
26605 7557           8846         FF            mov	-1[bp],al
26606                                           !BCC_EOS
26607                                           ! 4543 #asm
26608                                           !BCC_EOS
26609                                           !BCC_ASM
26610                       00000002            _floppy_prepare_controller.dor	set	2
26611                       FFFFFFFE            .floppy_prepare_controller.dor	set	-2
26612                       00000001            _floppy_prepare_controller.prev_reset	set	1
26613                       FFFFFFFD            .floppy_prepare_controller.prev_reset	set	-3
26614                       00000003            _floppy_prepare_controller.val8	set	3
26615                       FFFFFFFF            .floppy_prepare_controller.val8	set	-1
26616                       00000008            _floppy_prepare_controller.drive	set	8
26617                       00000004            .floppy_prepare_controller.drive	set	4
26618 755A           FA                             cli
26619                                           ! 4545 endasm
26620                                           !BCC_ENDASM
26621                                           !BCC_EOS
26622                                           ! 4546     *((Bit8u *)(0x003e)) = (val8);
26623                                           ! Debug: eq unsigned char val8 = [S+6-3] to unsigned char = [+$3E] (used reg = )
26624 755B           8A46         FF            mov	al,-1[bp]
26625 755E           A2         003E            mov	[$3E],al
26626                                           !BCC_EOS
26627                                           ! 4547   }
26628                                           ! 4548 }
26629                       00007561            .665:
26630 7561           89EC                       mov	sp,bp
26631 7563           5D                         pop	bp
26632 7564           C3                         ret
26633                                           ! 4549   bx_bool
26634                                           ! 4550 floppy_media_known(drive)
26635                                           ! 4551   Bit16u drive;
26636                                           export	_floppy_media_known
26637                       00007565            _floppy_media_known:
26638                                           !BCC_EOS
26639                                           ! 4552 {
26640                                           ! 4553   Bit8u val8;
26641                                           !BCC_EOS
26642                                           ! 4554   Bit16u media_state_offset;
26643                                           !BCC_EOS
26644                                           ! 4555   val8 = *((Bit8u 
26645 7565           55                         push	bp
26646 7566           89E5                       mov	bp,sp
26647 7568           83C4                   FC  add	sp,*-4
26648                                           ! 4555 *)(0x003e));
26649                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+6-3] (used reg = )
26650 756B           A0         003E            mov	al,[$3E]
26651 756E           8846         FF            mov	-1[bp],al
26652                                           !BCC_EOS
26653                                           ! 4556   if (drive)
26654 7571           8B46         04            mov	ax,4[bp]
26655 7574           85C0                       test	ax,ax
26656 7576           74           0A            je  	.66B
26657                       00007578            .66C:
26658                                           ! 4557     val8 >>= 1;
26659                                           ! Debug: srab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
26660 7578           8A46         FF            mov	al,-1[bp]
26661 757B           30E4                       xor	ah,ah
26662 757D           D1E8                       shr	ax,*1
26663 757F           8846         FF            mov	-1[bp],al
26664                                           !BCC_EOS
26665                                           ! 4558   val8 &= 0x01;
26666                       00007582            .66B:
26667                                           ! Debug: andab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
26668 7582           8A46         FF            mov	al,-1[bp]
26669 7585           24                     01  and	al,*1
26670 7587           8846         FF            mov	-1[bp],al
26671                                           !BCC_EOS
26672                                           ! 4559   if (val8 == 0)
26673                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
26674 758A           8A46         FF            mov	al,-1[bp]
26675 758D           84C0                       test	al,al
26676 758F           75           06            jne 	.66D
26677                       00007591            .66E:
26678                                           ! 4560     return(0);
26679 7591           31C0                       xor	ax,ax
26680 7593           89EC                       mov	sp,bp
26681 7595           5D                         pop	bp
26682 7596           C3                         ret
26683                                           !BCC_EOS
26684                                           ! 4561   media_state_offset = 0x0090;
26685                       00007597            .66D:
26686                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+6-6] (used reg = )
26687 7597           B8                   0090  mov	ax,#$90
26688 759A           8946         FC            mov	-4[bp],ax
26689                                           !BCC_EOS
26690                                           ! 4562   if (drive)
26691 759D           8B46         04            mov	ax,4[bp]
26692 75A0           85C0                       test	ax,ax
26693 75A2           74           07            je  	.66F
26694                       000075A4            .670:
26695                                           ! 4563     media_state_offset += 1;
26696                                           ! Debug: addab int = const 1 to unsigned short media_state_offset = [S+6-6] (used reg = )
26697 75A4           8B46         FC            mov	ax,-4[bp]
26698 75A7           40                         inc	ax
26699 75A8           8946         FC            mov	-4[bp],ax
26700                                           !BCC_EOS
26701                                           ! 4564   val8 = *((Bit8u *)(media_state_offset));
26702                       000075AB            .66F:
26703 75AB           8B5E         FC            mov	bx,-4[bp]
26704                                           ! Debug: eq unsigned char = [bx+0] to unsigned char val8 = [S+6-3] (used reg = )
26705 75AE           8A07                       mov	al,[bx]
26706 75B0           8846         FF            mov	-1[bp],al
26707                                           !BCC_EOS
26708                                           ! 4565   val8 = (val8 >> 4) & 0x01;
26709                                           ! Debug: sr int = const 4 to unsigned char val8 = [S+6-3] (used reg = )
26710 75B3           8A46         FF            mov	al,-1[bp]
26711 75B6           30E4                       xor	ah,ah
26712 75B8           B1                     04  mov	cl,*4
26713 75BA           D3E8                       shr	ax,cl
26714                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
26715 75BC           24                     01  and	al,*1
26716                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
26717 75BE           8846         FF            mov	-1[bp],al
26718                                           !BCC_EOS
26719                                           ! 4566   if (val8 == 0)
26720                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
26721 75C1           8A46         FF            mov	al,-1[bp]
26722 75C4           84C0                       test	al,al
26723 75C6           75           06            jne 	.671
26724                       000075C8            .672:
26725                                           ! 4567     return(0);
26726 75C8           31C0                       xor	ax,ax
26727 75CA           89EC                       mov	sp,bp
26728 75CC           5D                         pop	bp
26729 75CD           C3                         ret
26730                                           !BCC_EOS
26731                                           ! 4568   return(1);
26732                       000075CE            .671:
26733 75CE           B8                   0001  mov	ax,*1
26734 75D1           89EC                       mov	sp,bp
26735 75D3           5D                         pop	bp
26736 75D4           C3                         ret
26737                                           !BCC_EOS
26738                                           ! 4569 }
26739                                           ! 4570   bx_bool
26740                                           ! Register BX used in function floppy_media_known
26741                                           ! 4571 floppy_media_sense(drive)
26742                                           ! 4572   Bit16u drive;
26743                                           export	_floppy_media_sense
26744                       000075D5            _floppy_media_sense:
26745                                           !BCC_EOS
26746                                           ! 4573 {
26747                                           ! 4574   bx_bool retval;
26748                                           !BCC_EOS
26749                                           ! 4575   Bit16u media_state_offset;
26750                                           !BCC_EOS
26751                                           ! 4576   Bit8u drive_type, config_data, media_state;
26752                                           !BCC_EOS
26753                                           ! 4577   if (floppy_drive_recal(drive) == 0) {
26754 75D5           55                         push	bp
26755 75D6           89E5                       mov	bp,sp
26756 75D8           83C4                   F8  add	sp,*-8
26757                                           ! Debug: list unsigned short drive = [S+$A+2] (used reg = )
26758 75DB           FF76         04            push	4[bp]
26759                                           ! Debug: func () unsigned short = floppy_drive_recal+0 (used reg = )
26760 75DE           E8         00E4            call	_floppy_drive_recal
26761 75E1           44                         inc	sp
26762 75E2           44                         inc	sp
26763                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
26764 75E3           85C0                       test	ax,ax
26765 75E5           75           06            jne 	.673
26766                       000075E7            .674:
26767                                           ! 4578     return(0);
26768 75E7           31C0                       xor	ax,ax
26769 75E9           89EC                       mov	sp,bp
26770 75EB           5D                         pop	bp
26771 75EC           C3                         ret
26772                                           !BCC_EOS
26773                                           ! 4579   }
26774                                           ! 4580   drive_type = inb_cmos(0x10);
26775                       000075ED            .673:
26776                                           ! Debug: list int = const $10 (used reg = )
26777 75ED           B8                   0010  mov	ax,*$10
26778 75F0           50                         push	ax
26779                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
26780 75F1           E8         8F49            call	_inb_cmos
26781 75F4           44                         inc	sp
26782 75F5           44                         inc	sp
26783                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$A-7] (used reg = )
26784 75F6           8846         FB            mov	-5[bp],al
26785                                           !BCC_EOS
26786                                           ! 4581   if (drive == 0)
26787                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
26788 75F9           8B46         04            mov	ax,4[bp]
26789 75FC           85C0                       test	ax,ax
26790 75FE           75           0E            jne 	.675
26791                       00007600            .676:
26792                                           ! 4582     drive_type >>= 4;
26793                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
26794 7600           8A46         FB            mov	al,-5[bp]
26795 7603           30E4                       xor	ah,ah
26796 7605           B1                     04  mov	cl,*4
26797 7607           D3E8                       shr	ax,cl
26798 7609           8846         FB            mov	-5[bp],al
26799                                           !BCC_EOS
26800                                           ! 4583   else
26801                                           ! 4584     drive_type &= 0x0f;
26802 760C           EB           08            jmp .677
26803                       0000760E            .675:
26804                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$A-7] (used reg = )
26805 760E           8A46         FB            mov	al,-5[bp]
26806 7611           24                     0F  and	al,*$F
26807 7613           8846         FB            mov	-5[bp],al
26808                                           !BCC_EOS
26809                                           ! 4585   switch(drive_type) {
26810                       00007616            .677:
26811 7616           8A46         FB            mov	al,-5[bp]
26812 7619           EB           5B            jmp .67A
26813                                           ! 4586     case 1:
26814                                           ! 4587     case 2:
26815                       0000761B            .67B:
26816                                           ! 4588       config_data = 0x00;
26817                       0000761B            .67C:
26818                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
26819 761B           30C0                       xor	al,al
26820 761D           8846         FA            mov	-6[bp],al
26821                                           !BCC_EOS
26822                                           ! 4589       media_state = 0x25;
26823                                           ! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
26824 7620           B0                     25  mov	al,*$25
26825 7622           8846         F9            mov	-7[bp],al
26826                                           !BCC_EOS
26827                                           ! 4590       retval = 1;
26828                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
26829 7625           B8                   0001  mov	ax,*1
26830 7628           8946         FE            mov	-2[bp],ax
26831                                           !BCC_EOS
26832                                           ! 4591       break;
26833 762B           EB           6E            jmp .678
26834                                           !BCC_EOS
26835                                           ! 4592     case 3:
26836                                           ! 4593     case 4:
26837                       0000762D            .67D:
26838                                           ! 4594       config_data = 0x00;
26839                       0000762D            .67E:
26840                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
26841 762D           30C0                       xor	al,al
26842 762F           8846         FA            mov	-6[bp],al
26843                                           !BCC_EOS
26844                                           ! 4595       media_state = 0x17;
26845                                           ! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
26846 7632           B0                     17  mov	al,*$17
26847 7634           8846         F9            mov	-7[bp],al
26848                                           !BCC_EOS
26849                                           ! 4596       retval = 1;
26850                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
26851 7637           B8                   0001  mov	ax,*1
26852 763A           8946         FE            mov	-2[bp],ax
26853                                           !BCC_EOS
26854                                           ! 4597       break;
26855 763D           EB           5C            jmp .678
26856                                           !BCC_EOS
26857                                           ! 4598     case 5:
26858                                           ! 4599       config_data = 0xCC;
26859                       0000763F            .67F:
26860                                           ! Debug: eq int = const $CC to unsigned char config_data = [S+$A-8] (used reg = )
26861 763F           B0                     CC  mov	al,#$CC
26862 7641           8846         FA            mov	-6[bp],al
26863                                           !BCC_EOS
26864                                           ! 4600       media_state = 0xD7;
26865                                           ! Debug: eq int = const $D7 to unsigned char media_state = [S+$A-9] (used reg = )
26866 7644           B0                     D7  mov	al,#$D7
26867 7646           8846         F9            mov	-7[bp],al
26868                                           !BCC_EOS
26869                                           ! 4601       retval = 1;
26870                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
26871 7649           B8                   0001  mov	ax,*1
26872 764C           8946         FE            mov	-2[bp],ax
26873                                           !BCC_EOS
26874                                           ! 4602       break;
26875 764F           EB           4A            jmp .678
26876                                           !BCC_EOS
26877                                           ! 4603     case 6:
26878                                           ! 4604     case 7:
26879                       00007651            .680:
26880                                           ! 4605     case 8:
26881                       00007651            .681:
26882                                           ! 4606       config_data = 0x00;
26883                       00007651            .682:
26884                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
26885 7651           30C0                       xor	al,al
26886 7653           8846         FA            mov	-6[bp],al
26887                                           !BCC_EOS
26888                                           ! 4607       media_state = 0x27;
26889                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
26890 7656           B0                     27  mov	al,*$27
26891 7658           8846         F9            mov	-7[bp],al
26892                                           !BCC_EOS
26893                                           ! 4608       retval = 1;
26894                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
26895 765B           B8                   0001  mov	ax,*1
26896 765E           8946         FE            mov	-2[bp],ax
26897                                           !BCC_EOS
26898                                           ! 4609       break;
26899 7661           EB           38            jmp .678
26900                                           !BCC_EOS
26901                                           ! 4610     default:
26902                                           ! 4611       config_data = 0x00;
26903                       00007663            .683:
26904                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
26905 7663           30C0                       xor	al,al
26906 7665           8846         FA            mov	-6[bp],al
26907                                           !BCC_EOS
26908                                           ! 4612       media_state = 0x00;
26909                                           ! Debug: eq int = const 0 to unsigned char media_state = [S+$A-9] (used reg = )
26910 7668           30C0                       xor	al,al
26911 766A           8846         F9            mov	-7[bp],al
26912                                           !BCC_EOS
26913                                           ! 4613       retval = 0;
26914                                           ! Debug: eq int = const 0 to unsigned short retval = [S+$A-4] (used reg = )
26915 766D           31C0                       xor	ax,ax
26916 766F           8946         FE            mov	-2[bp],ax
26917                                           !BCC_EOS
26918                                           ! 4614       break;
26919 7672           EB           27            jmp .678
26920                                           !BCC_EOS
26921                                           ! 4615   }
26922                                           ! 4616   if (drive == 0)
26923 7674           EB           25            jmp .678
26924                       00007676            .67A:
26925 7676           2C                     01  sub	al,*1
26926 7678           72           E9            jb 	.683
26927 767A           3C                     07  cmp	al,*7
26928 767C           77           1B            ja  	.684
26929 767E           30E4                       xor	ah,ah
26930 7680           D1E0                       shl	ax,*1
26931 7682           89C3                       mov	bx,ax
26932 7684           2E                         seg	cs
26933 7685           FFA7       7689            br	.685[bx]
26934                       00007689            .685:
26935 7689                      761B            .word	.67B
26936 768B                      761B            .word	.67C
26937 768D                      762D            .word	.67D
26938 768F                      762D            .word	.67E
26939 7691                      763F            .word	.67F
26940 7693                      7651            .word	.680
26941 7695                      7651            .word	.681
26942 7697                      7651            .word	.682
26943                       00007699            .684:
26944 7699           EB           C8            jmp	.683
26945                       0000769B            .678:
26946                       FFFFFFF6            ..FFDC	=	-$A
26947                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
26948 769B           8B46         04            mov	ax,4[bp]
26949 769E           85C0                       test	ax,ax
26950 76A0           75           08            jne 	.686
26951                       000076A2            .687:
26952                                           ! 4617     media_state_offset = 0x90;
26953                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+$A-6] (used reg = )
26954 76A2           B8                   0090  mov	ax,#$90
26955 76A5           8946         FC            mov	-4[bp],ax
26956                                           !BCC_EOS
26957                                           ! 4618   else
26958                                           ! 4619     media_state_offset = 0x91;
26959 76A8           EB           06            jmp .688
26960                       000076AA            .686:
26961                                           ! Debug: eq int = const $91 to unsigned short media_state_offset = [S+$A-6] (used reg = )
26962 76AA           B8                   0091  mov	ax,#$91
26963 76AD           8946         FC            mov	-4[bp],ax
26964                                           !BCC_EOS
26965                                           ! 4620   *((Bit8u *)(0x008B)) = (config_data);
26966                       000076B0            .688:
26967                                           ! Debug: eq unsigned char config_data = [S+$A-8] to unsigned char = [+$8B] (used reg = )
26968 76B0           8A46         FA            mov	al,-6[bp]
26969 76B3           A2         008B            mov	[$8B],al
26970                                           !BCC_EOS
26971                                           ! 4621   *((Bit8u *)(media_state_offset)) = (media_state);
26972 76B6           8B5E         FC            mov	bx,-4[bp]
26973                                           ! Debug: eq unsigned char media_state = [S+$A-9] to unsigned char = [bx+0] (used reg = )
26974 76B9           8A46         F9            mov	al,-7[bp]
26975 76BC           8807                       mov	[bx],al
26976                                           !BCC_EOS
26977                                           ! 4622   return(retval);
26978 76BE           8B46         FE            mov	ax,-2[bp]
26979 76C1           89EC                       mov	sp,bp
26980 76C3           5D                         pop	bp
26981 76C4           C3                         ret
26982                                           !BCC_EOS
26983                                           ! 4623 }
26984                                           ! 4624   bx_bool
26985                                           ! Register BX used in function floppy_media_sense
26986                                           ! 4625 floppy_drive_recal(drive)
26987                                           ! 4626   Bit16u drive;
26988                                           export	_floppy_drive_recal
26989                       000076C5            _floppy_drive_recal:
26990                                           !BCC_EOS
26991                                           ! 4627 {
26992                                           ! 4628   Bit8u val8;
26993                                           !BCC_EOS
26994                                           ! 4629   Bit16u curr_cyl_offset;
26995                                           !BCC_EOS
26996                                           ! 4630   floppy_prepare_controller(drive);
26997 76C5           55                         push	bp
26998 76C6           89E5                       mov	bp,sp
26999 76C8           83C4                   FC  add	sp,*-4
27000                                           ! Debug: list unsigned short drive = [S+6+2] (used reg = )
27001 76CB           FF76         04            push	4[bp]
27002                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
27003 76CE           E8         FDF4            call	_floppy_prepare_controller
27004 76D1           44                         inc	sp
27005 76D2           44                         inc	sp
27006                                           !BCC_EOS
27007                                           ! 4631   outb(0x03f5, 0x07);
27008                                           ! Debug: list int = const 7 (used reg = )
27009 76D3           B8                   0007  mov	ax,*7
27010 76D6           50                         push	ax
27011                                           ! Debug: list int = const $3F5 (used reg = )
27012 76D7           B8                   03F5  mov	ax,#$3F5
27013 76DA           50                         push	ax
27014                                           ! Debug: func () void = outb+0 (used reg = )
27015 76DB           E8         8E30            call	_outb
27016 76DE           83C4                   04  add	sp,*4
27017                                           !BCC_EOS
27018                                           ! 4632   outb(0x03f5, drive);
27019                                           ! Debug: list unsigned short drive = [S+6+2] (used reg = )
27020 76E1           FF76         04            push	4[bp]
27021                                           ! Debug: list int = const $3F5 (used reg = )
27022 76E4           B8                   03F5  mov	ax,#$3F5
27023 76E7           50                         push	ax
27024                                           ! Debug: func () void = outb+0 (used reg = )
27025 76E8           E8         8E23            call	_outb
27026 76EB           83C4                   04  add	sp,*4
27027                                           !BCC_EOS
27028                                           ! 4633 #asm
27029                                           !BCC_EOS
27030                                           !BCC_ASM
27031                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
27032                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
27033                       00000003            _floppy_drive_recal.val8	set	3
27034                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
27035                       00000008            _floppy_drive_recal.drive	set	8
27036                       00000004            .floppy_drive_recal.drive	set	4
27037 76EE           FB                           sti
27038                                           ! 4635 endasm
27039                                           !BCC_ENDASM
27040                                           !BCC_EOS
27041                                           ! 4636   do {
27042                       000076EF            .68B:
27043                                           ! 4637     val8 = (*((Bit8u *)(0x003e)) & 0x80);
27044                                           ! Debug: and int = const $80 to unsigned char = [+$3E] (used reg = )
27045 76EF           A0         003E            mov	al,[$3E]
27046 76F2           24                     80  and	al,#$80
27047                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
27048 76F4           8846         FF            mov	-1[bp],al
27049                                           !BCC_EOS
27050                                           ! 4638   } while ( val8 == 0 );
27051                       000076F7            .68A:
27052                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
27053 76F7           8A46         FF            mov	al,-1[bp]
27054 76FA           84C0                       test	al,al
27055 76FC           74           F1            je 	.68B
27056                       000076FE            .68C:
27057                                           !BCC_EOS
27058                                           ! 4639   val8 = 0;
27059                       000076FE            .689:
27060                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
27061 76FE           30C0                       xor	al,al
27062 7700           8846         FF            mov	-1[bp],al
27063                                           !BCC_EOS
27064                                           ! 4640 #asm
27065                                           !BCC_EOS
27066                                           !BCC_ASM
27067                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
27068                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
27069                       00000003            _floppy_drive_recal.val8	set	3
27070                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
27071                       00000008            _floppy_drive_recal.drive	set	8
27072                       00000004            .floppy_drive_recal.drive	set	4
27073 7703           FA                           cli
27074                                           ! 4642 endasm
27075                                           !BCC_ENDASM
27076                                           !BCC_EOS
27077                                           ! 4643   val8 = *((Bit8u *)(0x003e));
27078                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+6-3] (used reg = )
27079 7704           A0         003E            mov	al,[$3E]
27080 7707           8846         FF            mov	-1[bp],al
27081                                           !BCC_EOS
27082                                           ! 4644   val8 &= 0x7f;
27083                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
27084 770A           8A46         FF            mov	al,-1[bp]
27085 770D           24                     7F  and	al,*$7F
27086 770F           8846         FF            mov	-1[bp],al
27087                                           !BCC_EOS
27088                                           ! 4645   if (drive) {
27089 7712           8B46         04            mov	ax,4[bp]
27090 7715           85C0                       test	ax,ax
27091 7717           74           10            je  	.68D
27092                       00007719            .68E:
27093                                           ! 4646     val8 |= 0x02;
27094                                           ! Debug: orab int = const 2 to unsigned char val8 = [S+6-3] (used reg = )
27095 7719           8A46         FF            mov	al,-1[bp]
27096 771C           0C                     02  or	al,*2
27097 771E           8846         FF            mov	-1[bp],al
27098                                           !BCC_EOS
27099                                           ! 4647     curr_cyl_offset = 0x0095;
27100                                           ! Debug: eq int = const $95 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
27101 7721           B8                   0095  mov	ax,#$95
27102 7724           8946         FC            mov	-4[bp],ax
27103                                           !BCC_EOS
27104                                           ! 4648   } else {
27105 7727           EB           0E            jmp .68F
27106                       00007729            .68D:
27107                                           ! 4649     val8 |= 0x01;
27108                                           ! Debug: orab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
27109 7729           8A46         FF            mov	al,-1[bp]
27110 772C           0C                     01  or	al,*1
27111 772E           8846         FF            mov	-1[bp],al
27112                                           !BCC_EOS
27113                                           ! 4650     curr_cyl_offset = 0x0094;
27114                                           ! Debug: eq int = const $94 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
27115 7731           B8                   0094  mov	ax,#$94
27116 7734           8946         FC            mov	-4[bp],ax
27117                                           !BCC_EOS
27118                                           ! 4651   }
27119                                           ! 4652   *((Bit8u *)(0x003e)) = (val8);
27120                       00007737            .68F:
27121                                           ! Debug: eq unsigned char val8 = [S+6-3] to unsigned char = [+$3E] (used reg = )
27122 7737           8A46         FF            mov	al,-1[bp]
27123 773A           A2         003E            mov	[$3E],al
27124                                           !BCC_EOS
27125                                           ! 4653   *((Bit8u *)(curr_cyl_offset)) = (0);
27126 773D           8B5E         FC            mov	bx,-4[bp]
27127                                           ! Debug: eq int = const 0 to unsigned char = [bx+0] (used reg = )
27128 7740           30C0                       xor	al,al
27129 7742           8807                       mov	[bx],al
27130                                           !BCC_EOS
27131                                           ! 4654   return(1);
27132 7744           B8                   0001  mov	ax,*1
27133 7747           89EC                       mov	sp,bp
27134 7749           5D                         pop	bp
27135 774A           C3                         ret
27136                                           !BCC_EOS
27137                                           ! 4655 }
27138                                           ! 4656   bx_bool
27139                                           ! Register BX used in function floppy_drive_recal
27140                                           ! 4657 floppy_drive_exists(drive)
27141                                           ! 4658   Bit16u drive;
27142                                           export	_floppy_drive_exists
27143                       0000774B            _floppy_drive_exists:
27144                                           !BCC_EOS
27145                                           ! 4659 {
27146                                           ! 4660   Bit8u drive_type;
27147                                           !BCC_EOS
27148                                           ! 4661   drive_type = inb_cmos(0x10);
27149 774B           55                         push	bp
27150 774C           89E5                       mov	bp,sp
27151 774E           4C                         dec	sp
27152 774F           4C                         dec	sp
27153                                           ! Debug: list int = const $10 (used reg = )
27154 7750           B8                   0010  mov	ax,*$10
27155 7753           50                         push	ax
27156                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
27157 7754           E8         8DE6            call	_inb_cmos
27158 7757           44                         inc	sp
27159 7758           44                         inc	sp
27160                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+4-3] (used reg = )
27161 7759           8846         FF            mov	-1[bp],al
27162                                           !BCC_EOS
27163                                           ! 4662   if (drive == 0)
27164                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+4+2] (used reg = )
27165 775C           8B46         04            mov	ax,4[bp]
27166 775F           85C0                       test	ax,ax
27167 7761           75           0E            jne 	.690
27168                       00007763            .691:
27169                                           ! 4663     drive_type >>= 4;
27170                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+4-3] (used reg = )
27171 7763           8A46         FF            mov	al,-1[bp]
27172 7766           30E4                       xor	ah,ah
27173 7768           B1                     04  mov	cl,*4
27174 776A           D3E8                       shr	ax,cl
27175 776C           8846         FF            mov	-1[bp],al
27176                                           !BCC_EOS
27177                                           ! 4664   e
27178                                           ! 4664 lse
27179                                           ! 4665     drive_type &= 0x0f;
27180 776F           EB           08            jmp .692
27181                       00007771            .690:
27182                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+4-3] (used reg = )
27183 7771           8A46         FF            mov	al,-1[bp]
27184 7774           24                     0F  and	al,*$F
27185 7776           8846         FF            mov	-1[bp],al
27186                                           !BCC_EOS
27187                                           ! 4666   if ( drive_type == 0 )
27188                       00007779            .692:
27189                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+4-3] (used reg = )
27190 7779           8A46         FF            mov	al,-1[bp]
27191 777C           84C0                       test	al,al
27192 777E           75           08            jne 	.693
27193                       00007780            .694:
27194                                           ! 4667     return(0);
27195 7780           31C0                       xor	ax,ax
27196 7782           89EC                       mov	sp,bp
27197 7784           5D                         pop	bp
27198 7785           C3                         ret
27199                                           !BCC_EOS
27200                                           ! 4668   else
27201                                           ! 4669     return(1);
27202 7786           EB           07            jmp .695
27203                       00007788            .693:
27204 7788           B8                   0001  mov	ax,*1
27205 778B           89EC                       mov	sp,bp
27206 778D           5D                         pop	bp
27207 778E           C3                         ret
27208                                           !BCC_EOS
27209                                           ! 4670 }
27210                       0000778F            .695:
27211 778F           89EC                       mov	sp,bp
27212 7791           5D                         pop	bp
27213 7792           C3                         ret
27214                                           ! 4671   void
27215                                           ! 4672 int13_diskette_function(DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
27216                                           ! 4673   Bit16u DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
27217                                           export	_int13_diskette_function
27218                       00007793            _int13_diskette_function:
27219                                           !BCC_EOS
27220                                           ! 4674 {
27221                                           ! 4675   Bit8u drive, num_sectors, track, sector, head, status;
27222                                           !BCC_EOS
27223                                           ! 4676   Bit16u base_address, base_count, base_es;
27224                                           !BCC_EOS
27225                                           ! 4677   Bit8u page, mode_register, val8, dor;
27226                                           !BCC_EOS
27227                                           ! 4678   Bit8u return_status[7];
27228                                           !BCC_EOS
27229                                           ! 4679   Bit8u drive_type, num_floppies, ah, spt;
27230                                           !BCC_EOS
27231                                           ! 4680   Bit16u es, last_addr, maxCyl;
27232                                           !BCC_EOS
27233                                           ! 4681   ;
27234 7793           55                         push	bp
27235 7794           89E5                       mov	bp,sp
27236 7796           83C4                   DE  add	sp,*-$22
27237                                           !BCC_EOS
27238                                           ! 4682   ah = *(((Bit8u *)&AX)+1);
27239                                           ! Debug: eq unsigned char AX = [S+$24+$15] to unsigned char ah = [S+$24-$1C] (used reg = )
27240 7799           8A46         17            mov	al,$17[bp]
27241 779C           8846         E6            mov	-$1A[bp],al
27242                                           !BCC_EOS
27243                                           ! 4683   switch ( ah ) {
27244 779F           8A46         E6            mov	al,-$1A[bp]
27245 77A2           E9         0E59            br 	.698
27246                                           ! 4684     case 0x00:
27247                                           ! 4685 ;
27248                       000077A5            .699:
27249                                           !BCC_EOS
27250                                           ! 4686       drive = ( ELDX & 0x00ff );
27251                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
27252 77A5           8A46         0E            mov	al,$E[bp]
27253                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
27254 77A8           8846         FF            mov	-1[bp],al
27255                                           !BCC_EOS
27256                                           ! 4687       if (drive > 1) {
27257                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
27258 77AB           8A46         FF            mov	al,-1[bp]
27259 77AE           3C                     01  cmp	al,*1
27260 77B0           76           1A            jbe 	.69A
27261                       000077B2            .69B:
27262                                           ! 4688         *(((Bit8u *)&AX)+1) = (1);
27263                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
27264 77B2           B0                     01  mov	al,*1
27265 77B4           8846         17            mov	$17[bp],al
27266                                           !BCC_EOS
27267                                           ! 4689         set_diskette_ret_status(1);
27268                                           ! Debug: list int = const 1 (used reg = )
27269 77B7           B8                   0001  mov	ax,*1
27270 77BA           50                         push	ax
27271                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27272 77BB           E8         0E83            call	_set_diskette_ret_status
27273 77BE           44                         inc	sp
27274 77BF           44                         inc	sp
27275                                           !BCC_EOS
27276                                           ! 4690         FLAGS |= 0x0001;
27277                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27278 77C0           8B46         1C            mov	ax,$1C[bp]
27279 77C3           0C                     01  or	al,*1
27280 77C5           8946         1C            mov	$1C[bp],ax
27281                                           !BCC_EOS
27282                                           ! 4691         return;
27283 77C8           89EC                       mov	sp,bp
27284 77CA           5D                         pop	bp
27285 77CB           C3                         ret
27286                                           !BCC_EOS
27287                                           ! 4692       }
27288                                           ! 4693       drive_type = inb_cmos(0x10);
27289                       000077CC            .69A:
27290                                           ! Debug: list int = const $10 (used reg = )
27291 77CC           B8                   0010  mov	ax,*$10
27292 77CF           50                         push	ax
27293                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
27294 77D0           E8         8D6A            call	_inb_cmos
27295 77D3           44                         inc	sp
27296 77D4           44                         inc	sp
27297                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
27298 77D5           8846         E8            mov	-$18[bp],al
27299                                           !BCC_EOS
27300                                           ! 4694       if (drive == 0)
27301                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$24-3] (used reg = )
27302 77D8           8A46         FF            mov	al,-1[bp]
27303 77DB           84C0                       test	al,al
27304 77DD           75           0E            jne 	.69C
27305                       000077DF            .69D:
27306                                           ! 4695         drive_type >>= 4;
27307                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$24-$1A] (used reg = )
27308 77DF           8A46         E8            mov	al,-$18[bp]
27309 77E2           30E4                       xor	ah,ah
27310 77E4           B1                     04  mov	cl,*4
27311 77E6           D3E8                       shr	ax,cl
27312 77E8           8846         E8            mov	-$18[bp],al
27313                                           !BCC_EOS
27314                                           ! 4696       else
27315                                           ! 4697         drive_type &= 0x0f;
27316 77EB           EB           08            jmp .69E
27317                       000077ED            .69C:
27318                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$24-$1A] (used reg = )
27319 77ED           8A46         E8            mov	al,-$18[bp]
27320 77F0           24                     0F  and	al,*$F
27321 77F2           8846         E8            mov	-$18[bp],al
27322                                           !BCC_EOS
27323                                           ! 4698       if (drive_type == 0) {
27324                       000077F5            .69E:
27325                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
27326 77F5           8A46         E8            mov	al,-$18[bp]
27327 77F8           84C0                       test	al,al
27328 77FA           75           1A            jne 	.69F
27329                       000077FC            .6A0:
27330                                           ! 4699         *(((Bit8u *)&AX)+1) = (0x80);
27331                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
27332 77FC           B0                     80  mov	al,#$80
27333 77FE           8846         17            mov	$17[bp],al
27334                                           !BCC_EOS
27335                                           ! 4700         set_diskette_ret_status(0x80);
27336                                           ! Debug: list int = const $80 (used reg = )
27337 7801           B8                   0080  mov	ax,#$80
27338 7804           50                         push	ax
27339                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27340 7805           E8         0E39            call	_set_diskette_ret_status
27341 7808           44                         inc	sp
27342 7809           44                         inc	sp
27343                                           !BCC_EOS
27344                                           ! 4701         FLAGS |= 0x0001;
27345                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27346 780A           8B46         1C            mov	ax,$1C[bp]
27347 780D           0C                     01  or	al,*1
27348 780F           8946         1C            mov	$1C[bp],ax
27349                                           !BCC_EOS
27350                                           ! 4702         return;
27351 7812           89EC                       mov	sp,bp
27352 7814           5D                         pop	bp
27353 7815           C3                         ret
27354                                           !BCC_EOS
27355                                           ! 4703       }
27356                                           ! 4704       *(((Bit8u *)&AX)+1) = (0);
27357                       00007816            .69F:
27358                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
27359 7816           30C0                       xor	al,al
27360 7818           8846         17            mov	$17[bp],al
27361                                           !BCC_EOS
27362                                           ! 4705       set_diskette_ret_status(0);
27363                                           ! Debug: list int = const 0 (used reg = )
27364 781B           31C0                       xor	ax,ax
27365 781D           50                         push	ax
27366                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27367 781E           E8         0E20            call	_set_diskette_ret_status
27368 7821           44                         inc	sp
27369 7822           44                         inc	sp
27370                                           !BCC_EOS
27371                                           ! 4706       FLAGS &= 0xfffe;
27372                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27373 7823           8B46         1C            mov	ax,$1C[bp]
27374 7826           24                     FE  and	al,#$FE
27375 7828           8946         1C            mov	$1C[bp],ax
27376                                           !BCC_EOS
27377                                           ! 4707       set_diskette_current_cyl(drive, 0);
27378                                           ! Debug: list int = const 0 (used reg = )
27379 782B           31C0                       xor	ax,ax
27380 782D           50                         push	ax
27381                                           ! Debug: list unsigned char drive = [S+$26-3] (used reg = )
27382 782E           8A46         FF            mov	al,-1[bp]
27383 7831           30E4                       xor	ah,ah
27384 7833           50                         push	ax
27385                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
27386 7834           E8         0E22            call	_set_diskette_current_cyl
27387 7837           83C4                   04  add	sp,*4
27388                                           !BCC_EOS
27389                                           ! 4708       return;
27390 783A           89EC                       mov	sp,bp
27391 783C           5D                         pop	bp
27392 783D           C3                         ret
27393                                           !BCC_EOS
27394                                           ! 4709     case 0x01:
27395                                           ! 4710       FLAGS &= 0xfffe;
27396                       0000783E            .6A1:
27397                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27398 783E           8B46         1C            mov	ax,$1C[bp]
27399 7841           24                     FE  and	al,#$FE
27400 7843           8946         1C            mov	$1C[bp],ax
27401                                           !BCC_EOS
27402                                           ! 4711       val8 = *((Bit8u *)(0x0041));
27403                                           ! Debug: eq unsigned char = [+$41] to unsigned char val8 = [S+$24-$11] (used reg = )
27404 7846           A0         0041            mov	al,[$41]
27405 7849           8846         F1            mov	-$F[bp],al
27406                                           !BCC_EOS
27407                                           ! 4712       *(((Bit8u *)&AX)+1) = (val8);
27408                                           ! Debug: eq unsigned char val8 = [S+$24-$11] to unsigned char AX = [S+$24+$15] (used reg = )
27409 784C           8A46         F1            mov	al,-$F[bp]
27410 784F           8846         17            mov	$17[bp],al
27411                                           !BCC_EOS
27412                                           ! 4713       if (val8) {
27413 7852           8A46         F1            mov	al,-$F[bp]
27414 7855           84C0                       test	al,al
27415 7857           74           08            je  	.6A2
27416                       00007859            .6A3:
27417                                           ! 4714         FLAGS |= 0x0001;
27418                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27419 7859           8B46         1C            mov	ax,$1C[bp]
27420 785C           0C                     01  or	al,*1
27421 785E           8946         1C            mov	$1C[bp],ax
27422                                           !BCC_EOS
27423                                           ! 4715       }
27424                                           ! 4716       return;
27425                       00007861            .6A2:
27426 7861           89EC                       mov	sp,bp
27427 7863           5D                         pop	bp
27428 7864           C3                         ret
27429                                           !BCC_EOS
27430                                           ! 4717     case 0x02:
27431                                           ! 4718     case 0x03:
27432                       00007865            .6A4:
27433                                           ! 4719     case 0x04:
27434                       00007865            .6A5:
27435                                           ! 4720       num_sectors = ( AX & 0x00ff );
27436                       00007865            .6A6:
27437                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
27438 7865           8A46         16            mov	al,$16[bp]
27439                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$24-4] (used reg = )
27440 7868           8846         FE            mov	-2[bp],al
27441                                           !BCC_EOS
27442                                           ! 4721       track = *(((Bit8u *)&CX)+1);
27443                                           ! Debug: eq unsigned char CX = [S+$24+$13] to unsigned char track = [S+$24-5] (used reg = )
27444 786B           8A46         15            mov	al,$15[bp]
27445 786E           8846         FD            mov	-3[bp],al
27446                                           !BCC_EOS
27447                                           ! 4722       sector = ( CX & 0x00ff );
27448                                           ! Debug: and int = const $FF to unsigned short CX = [S+$24+$12] (used reg = )
27449 7871           8A46         14            mov	al,$14[bp]
27450                                           ! Debug: eq unsigned char = al+0 to unsigned char sector = [S+$24-6] (used reg = )
27451 7874           8846         FC            mov	-4[bp],al
27452                                           !BCC_EOS
27453                                           ! 4723       head = *(((Bit8u *)&DX)+1);
27454                                           ! Debug: eq unsigned char DX = [S+$24+$11] to unsigned char head = [S+$24-7] (used reg = )
27455 7877           8A46         13            mov	al,$13[bp]
27456 787A           8846         FB            mov	-5[bp],al
27457                                           !BCC_EOS
27458                                           ! 4724       drive = ( ELDX & 0x00ff );
27459                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
27460 787D           8A46         0E            mov	al,$E[bp]
27461                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
27462 7880           8846         FF            mov	-1[bp],al
27463                                           !BCC_EOS
27464                                           ! 4725       if ((drive > 1) || (head > 1) || (sector == 0) ||
27465                                           ! 4726           (num_sectors == 0) || (num_sectors > 72)) {
27466                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
27467 7883           8A46         FF            mov	al,-1[bp]
27468 7886           3C                     01  cmp	al,*1
27469 7888           77           1C            ja  	.6A8
27470                       0000788A            .6AC:
27471                                           ! Debug: gt int = const 1 to unsigned char head = [S+$24-7] (used reg = )
27472 788A           8A46         FB            mov	al,-5[bp]
27473 788D           3C                     01  cmp	al,*1
27474 788F           77           15            ja  	.6A8
27475                       00007891            .6AB:
27476                                           ! Debug: logeq int = const 0 to unsigned char sector = [S+$24-6] (used reg = )
27477 7891           8A46         FC            mov	al,-4[bp]
27478 7894           84C0                       test	al,al
27479 7896           74           0E            je  	.6A8
27480                       00007898            .6AA:
27481                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$24-4] (used reg = )
27482 7898           8A46         FE            mov	al,-2[bp]
27483 789B           84C0                       test	al,al
27484 789D           74           07            je  	.6A8
27485                       0000789F            .6A9:
27486                                           ! Debug: gt int = const $48 to unsigned char num_sectors = [S+$24-4] (used reg = )
27487 789F           8A46         FE            mov	al,-2[bp]
27488 78A2           3C                     48  cmp	al,*$48
27489 78A4           76           2D            jbe 	.6A7
27490                       000078A6            .6A8:
27491                                           ! 4727         bios_printf(4, "int13_diskette: read/write/verify: parameter out of range\n");
27492                                           ! Debug: list * char = .6AD+0 (used reg = )
27493 78A6           BB                   CE1E  mov	bx,#.6AD
27494 78A9           53                         push	bx
27495                                           ! Debug: list int = const 4 (used reg = )
27496 78AA           B8                   0004  mov	ax,*4
27497 78AD           50                         push	ax
27498                                           ! Debug: func () void = bios_printf+0 (used reg = )
27499 78AE           E8         908D            call	_bios_printf
27500 78B1           83C4                   04  add	sp,*4
27501                                           !BCC_EOS
27502                                           ! 4728         *(((Bit8u *)&AX)+1) = (1);
27503                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
27504 78B4           B0                     01  mov	al,*1
27505 78B6           8846         17            mov	$17[bp],al
27506                                           !BCC_EOS
27507                                           ! 4729         set_diskette_ret_status(1);
27508                                           ! Debug: list int = const 1 (used reg = )
27509 78B9           B8                   0001  mov	ax,*1
27510 78BC           50                         push	ax
27511                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27512 78BD           E8         0D81            call	_set_diskette_ret_status
27513 78C0           44                         inc	sp
27514 78C1           44                         inc	sp
27515                                           !BCC_EOS
27516                                           ! 4730         *((Bit8u *)&AX) = (0);
27517                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
27518 78C2           30C0                       xor	al,al
27519 78C4           8846         16            mov	$16[bp],al
27520                                           !BCC_EOS
27521                                           ! 4731         FLAGS |= 0x0001;
27522                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27523 78C7           8B46         1C            mov	ax,$1C[bp]
27524 78CA           0C                     01  or	al,*1
27525 78CC           8946         1C            mov	$1C[bp],ax
27526                                           !BCC_EOS
27527                                           ! 4732         return;
27528 78CF           89EC                       mov	sp,bp
27529 78D1           5D                         pop	bp
27530 78D2           C3                         ret
27531                                           !BCC_EOS
27532                                           ! 4733       }
27533                                           ! 4734       if (floppy_drive_exists(drive) == 0) {
27534                       000078D3            .6A7:
27535                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
27536 78D3           8A46         FF            mov	al,-1[bp]
27537 78D6           30E4                       xor	ah,ah
27538 78D8           50                         push	ax
27539                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
27540 78D9           E8         FE6F            call	_floppy_drive_exists
27541 78DC           44                         inc	sp
27542 78DD           44                         inc	sp
27543                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
27544 78DE           85C0                       test	ax,ax
27545 78E0           75           1F            jne 	.6AE
27546                       000078E2            .6AF:
27547                                           ! 4735         *(((Bit8u *)&AX)+1) = (0x80);
27548                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
27549 78E2           B0                     80  mov	al,#$80
27550 78E4           8846         17            mov	$17[bp],al
27551                                           !BCC_EOS
27552                                           ! 4736         set_diskette_ret_status(0x80);
27553                                           ! Debug: list int = const $80 (used reg = )
27554 78E7           B8                   0080  mov	ax,#$80
27555 78EA           50                         push	ax
27556                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27557 78EB           E8         0D53            call	_set_diskette_ret_status
27558 78EE           44                         inc	sp
27559 78EF           44                         inc	sp
27560                                           !BCC_EOS
27561                                           ! 4737         *((Bit8u *)&AX) = (0);
27562                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
27563 78F0           30C0                       xor	al,al
27564 78F2           8846         16            mov	$16[bp],al
27565                                           !BCC_EOS
27566                                           ! 4738  
27567                                           ! 4738        FLAGS |= 0x0001;
27568                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27569 78F5           8B46         1C            mov	ax,$1C[bp]
27570 78F8           0C                     01  or	al,*1
27571 78FA           8946         1C            mov	$1C[bp],ax
27572                                           !BCC_EOS
27573                                           ! 4739         return;
27574 78FD           89EC                       mov	sp,bp
27575 78FF           5D                         pop	bp
27576 7900           C3                         ret
27577                                           !BCC_EOS
27578                                           ! 4740       }
27579                                           ! 4741       if (floppy_media_known(drive) == 0) {
27580                       00007901            .6AE:
27581                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
27582 7901           8A46         FF            mov	al,-1[bp]
27583 7904           30E4                       xor	ah,ah
27584 7906           50                         push	ax
27585                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
27586 7907           E8         FC5B            call	_floppy_media_known
27587 790A           44                         inc	sp
27588 790B           44                         inc	sp
27589                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
27590 790C           85C0                       test	ax,ax
27591 790E           75           2E            jne 	.6B0
27592                       00007910            .6B1:
27593                                           ! 4742         if (floppy_media_sense(drive) == 0) {
27594                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
27595 7910           8A46         FF            mov	al,-1[bp]
27596 7913           30E4                       xor	ah,ah
27597 7915           50                         push	ax
27598                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
27599 7916           E8         FCBC            call	_floppy_media_sense
27600 7919           44                         inc	sp
27601 791A           44                         inc	sp
27602                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
27603 791B           85C0                       test	ax,ax
27604 791D           75           1F            jne 	.6B2
27605                       0000791F            .6B3:
27606                                           ! 4743           *(((Bit8u *)&AX)+1) = (0x0C);
27607                                           ! Debug: eq int = const $C to unsigned char AX = [S+$24+$15] (used reg = )
27608 791F           B0                     0C  mov	al,*$C
27609 7921           8846         17            mov	$17[bp],al
27610                                           !BCC_EOS
27611                                           ! 4744           set_diskette_ret_status(0x0C);
27612                                           ! Debug: list int = const $C (used reg = )
27613 7924           B8                   000C  mov	ax,*$C
27614 7927           50                         push	ax
27615                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27616 7928           E8         0D16            call	_set_diskette_ret_status
27617 792B           44                         inc	sp
27618 792C           44                         inc	sp
27619                                           !BCC_EOS
27620                                           ! 4745           *((Bit8u *)&AX) = (0);
27621                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
27622 792D           30C0                       xor	al,al
27623 792F           8846         16            mov	$16[bp],al
27624                                           !BCC_EOS
27625                                           ! 4746           FLAGS |= 0x0001;
27626                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27627 7932           8B46         1C            mov	ax,$1C[bp]
27628 7935           0C                     01  or	al,*1
27629 7937           8946         1C            mov	$1C[bp],ax
27630                                           !BCC_EOS
27631                                           ! 4747           return;
27632 793A           89EC                       mov	sp,bp
27633 793C           5D                         pop	bp
27634 793D           C3                         ret
27635                                           !BCC_EOS
27636                                           ! 4748         }
27637                                           ! 4749       }
27638                       0000793E            .6B2:
27639                                           ! 4750       if(ah == 0x04) {
27640                       0000793E            .6B0:
27641                                           ! Debug: logeq int = const 4 to unsigned char ah = [S+$24-$1C] (used reg = )
27642 793E           8A46         E6            mov	al,-$1A[bp]
27643 7941           3C                     04  cmp	al,*4
27644 7943           75           06            jne 	.6B4
27645                       00007945            .6B5:
27646                                           ! 4751         goto floppy_return_success;
27647 7945           83C4                   00  add	sp,#..FFDA-..FFDB
27648 7948           E9         034C            br 	.FFDA
27649                                           !BCC_EOS
27650                                           ! 4752       }
27651                                           ! 4753       page = (ES >> 12);
27652                       0000794B            .6B4:
27653                                           ! Debug: sr int = const $C to unsigned short ES = [S+$24+4] (used reg = )
27654 794B           8B46         06            mov	ax,6[bp]
27655 794E           88E0                       mov	al,ah
27656 7950           30E4                       xor	ah,ah
27657 7952           B1                     04  mov	cl,*4
27658 7954           D3E8                       shr	ax,cl
27659                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$24-$F] (used reg = )
27660 7956           8846         F3            mov	-$D[bp],al
27661                                           !BCC_EOS
27662                                           ! 4754       base_es = (ES << 4);
27663                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$24+4] (used reg = )
27664 7959           8B46         06            mov	ax,6[bp]
27665 795C           B1                     04  mov	cl,*4
27666 795E           D3E0                       shl	ax,cl
27667                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$24-$E] (used reg = )
27668 7960           8946         F4            mov	-$C[bp],ax
27669                                           !BCC_EOS
27670                                           ! 4755       base_address = base_es + BX;
27671                                           ! Debug: add unsigned short BX = [S+$24+$E] to unsigned short base_es = [S+$24-$E] (used reg = )
27672 7963           8B46         F4            mov	ax,-$C[bp]
27673 7966           0346         10            add	ax,$10[bp]
27674                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$24-$A] (used reg = )
27675 7969           8946         F8            mov	-8[bp],ax
27676                                           !BCC_EOS
27677                                           ! 4756       if ( base_address < base_es ) {
27678                                           ! Debug: lt unsigned short base_es = [S+$24-$E] to unsigned short base_address = [S+$24-$A] (used reg = )
27679 796C           8B46         F8            mov	ax,-8[bp]
27680 796F           3B46         F4            cmp	ax,-$C[bp]
27681 7972           73           07            jae 	.6B6
27682                       00007974            .6B7:
27683                                           ! 4757         page++;
27684                                           ! Debug: postinc unsigned char page = [S+$24-$F] (used reg = )
27685 7974           8A46         F3            mov	al,-$D[bp]
27686 7977           40                         inc	ax
27687 7978           8846         F3            mov	-$D[bp],al
27688                                           !BCC_EOS
27689                                           ! 4758       }
27690                                           ! 4759       base_count = (num_sectors * 512) - 1;
27691                       0000797B            .6B6:
27692                                           ! Debug: mul int = const $200 to unsigned char num_sectors = [S+$24-4] (used reg = )
27693 797B           8A46         FE            mov	al,-2[bp]
27694 797E           30E4                       xor	ah,ah
27695 7980           B9                   0200  mov	cx,#$200
27696 7983           F7E9                       imul	cx
27697                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
27698                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$24-$C] (used reg = )
27699 7985           48                         dec	ax
27700 7986           8946         F6            mov	-$A[bp],ax
27701                                           !BCC_EOS
27702                                           ! 4760       last_addr = base_address + base_count;
27703                                           ! Debug: add unsigned short base_count = [S+$24-$C] to unsigned short base_address = [S+$24-$A] (used reg = )
27704 7989           8B46         F8            mov	ax,-8[bp]
27705 798C           0346         F6            add	ax,-$A[bp]
27706                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$24-$22] (used reg = )
27707 798F           8946         E0            mov	-$20[bp],ax
27708                                           !BCC_EOS
27709                                           ! 4761       if (last_addr < base_address) {
27710                                           ! Debug: lt unsigned short base_address = [S+$24-$A] to unsigned short last_addr = [S+$24-$22] (used reg = )
27711 7992           8B46         E0            mov	ax,-$20[bp]
27712 7995           3B46         F8            cmp	ax,-8[bp]
27713 7998           73           1F            jae 	.6B8
27714                       0000799A            .6B9:
27715                                           ! 4762         *(((Bit8u *)&AX)+1) = (0x09);
27716                                           ! Debug: eq int = const 9 to unsigned char AX = [S+$24+$15] (used reg = )
27717 799A           B0                     09  mov	al,*9
27718 799C           8846         17            mov	$17[bp],al
27719                                           !BCC_EOS
27720                                           ! 4763         set_diskette_ret_status(0x09);
27721                                           ! Debug: list int = const 9 (used reg = )
27722 799F           B8                   0009  mov	ax,*9
27723 79A2           50                         push	ax
27724                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27725 79A3           E8         0C9B            call	_set_diskette_ret_status
27726 79A6           44                         inc	sp
27727 79A7           44                         inc	sp
27728                                           !BCC_EOS
27729                                           ! 4764         *((Bit8u *)&AX) = (0);
27730                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
27731 79A8           30C0                       xor	al,al
27732 79AA           8846         16            mov	$16[bp],al
27733                                           !BCC_EOS
27734                                           ! 4765         FLAGS |= 0x0001;
27735                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27736 79AD           8B46         1C            mov	ax,$1C[bp]
27737 79B0           0C                     01  or	al,*1
27738 79B2           8946         1C            mov	$1C[bp],ax
27739                                           !BCC_EOS
27740                                           ! 4766         return;
27741 79B5           89EC                       mov	sp,bp
27742 79B7           5D                         pop	bp
27743 79B8           C3                         ret
27744                                           !BCC_EOS
27745                                           ! 4767       }
27746                                           ! 4768       ;
27747                       000079B9            .6B8:
27748                                           !BCC_EOS
27749                                           ! 4769       outb(0x000a, 0x06);
27750                                           ! Debug: list int = const 6 (used reg = )
27751 79B9           B8                   0006  mov	ax,*6
27752 79BC           50                         push	ax
27753                                           ! Debug: list int = const $A (used reg = )
27754 79BD           B8                   000A  mov	ax,*$A
27755 79C0           50                         push	ax
27756                                           ! Debug: func () void = outb+0 (used reg = )
27757 79C1           E8         8B4A            call	_outb
27758 79C4           83C4                   04  add	sp,*4
27759                                           !BCC_EOS
27760                                           ! 4770   ;
27761                                           !BCC_EOS
27762                                           ! 4771       outb(0x000c, 0x00);
27763                                           ! Debug: list int = const 0 (used reg = )
27764 79C7           31C0                       xor	ax,ax
27765 79C9           50                         push	ax
27766                                           ! Debug: list int = const $C (used reg = )
27767 79CA           B8                   000C  mov	ax,*$C
27768 79CD           50                         push	ax
27769                                           ! Debug: func () void = outb+0 (used reg = )
27770 79CE           E8         8B3D            call	_outb
27771 79D1           83C4                   04  add	sp,*4
27772                                           !BCC_EOS
27773                                           ! 4772       outb(0x0004, base_address);
27774                                           ! Debug: list unsigned short base_address = [S+$24-$A] (used reg = )
27775 79D4           FF76         F8            push	-8[bp]
27776                                           ! Debug: list int = const 4 (used reg = )
27777 79D7           B8                   0004  mov	ax,*4
27778 79DA           50                         push	ax
27779                                           ! Debug: func () void = outb+0 (used reg = )
27780 79DB           E8         8B30            call	_outb
27781 79DE           83C4                   04  add	sp,*4
27782                                           !BCC_EOS
27783                                           ! 4773       outb(0x0004, *(((Bit8u *)&base_address)+1));
27784                                           ! Debug: list unsigned char base_address = [S+$24-9] (used reg = )
27785 79E1           8A46         F9            mov	al,-7[bp]
27786 79E4           30E4                       xor	ah,ah
27787 79E6           50                         push	ax
27788                                           ! Debug: list int = const 4 (used reg = )
27789 79E7           B8                   0004  mov	ax,*4
27790 79EA           50                         push	ax
27791                                           ! Debug: func () void = outb+0 (used reg = )
27792 79EB           E8         8B20            call	_outb
27793 79EE           83C4                   04  add	sp,*4
27794                                           !BCC_EOS
27795                                           ! 4774   ;
27796                                           !BCC_EOS
27797                                           ! 4775       outb(0x000c, 0x00);
27798                                           ! Debug: list int = const 0 (used reg = )
27799 79F1           31C0                       xor	ax,ax
27800 79F3           50                         push	ax
27801                                           ! Debug: list int = const $C (used reg = )
27802 79F4           B8                   000C  mov	ax,*$C
27803 79F7           50                         push	ax
27804                                           ! Debug: func () void = outb+0 (used reg = )
27805 79F8           E8         8B13            call	_outb
27806 79FB           83C4                   04  add	sp,*4
27807                                           !BCC_EOS
27808                                           ! 4776       outb(0x0005, base_count);
27809                                           ! Debug: list unsigned short base_count = [S+$24-$C] (used reg = )
27810 79FE           FF76         F6            push	-$A[bp]
27811                                           ! Debug: list int = const 5 (used reg = )
27812 7A01           B8                   0005  mov	ax,*5
27813 7A04           50                         push	ax
27814                                           ! Debug: func () void = outb+0 (used reg = )
27815 7A05           E8         8B06            call	_outb
27816 7A08           83C4                   04  add	sp,*4
27817                                           !BCC_EOS
27818                                           ! 4777       outb(0x0005, *(((Bit8u *)&base_count)+1));
27819                                           ! Debug: list unsigned char base_count = [S+$24-$B] (used reg = )
27820 7A0B           8A46         F7            mov	al,-9[bp]
27821 7A0E           30E4                       xor	ah,ah
27822 7A10           50                         push	ax
27823                                           ! Debug: list int = const 5 (used reg = )
27824 7A11           B8                   0005  mov	ax,*5
27825 7A14           50                         push	ax
27826                                           ! Debug: func () void = outb+0 (used reg = )
27827 7A15           E8         8AF6            call	_outb
27828 7A18           83C4                   04  add	sp,*4
27829                                           !BCC_EOS
27830                                           ! 4778       if (ah == 0x02) {
27831                                           ! Debug: logeq int = const 2 to unsigned char ah = [S+$24-$1C] (used reg = )
27832 7A1B           8A46         E6            mov	al,-$1A[bp]
27833 7A1E           3C                     02  cmp	al,*2
27834 7A20           75           5C            jne 	.6BA
27835                       00007A22            .6BB:
27836                                           ! 4779         mode_register = 0x46;
27837                                           ! Debug: eq int = const $46 to unsigned char mode_register = [S+$24-$10] (used reg = )
27838 7A22           B0                     46  mov	al,*$46
27839 7A24           8846         F2            mov	-$E[bp],al
27840                                           !BCC_EOS
27841                                           ! 4780   ;
27842                                           !BCC_EOS
27843                                           ! 4781         outb(0x000b, mode_register);
27844                                           ! Debug: list unsigned char mode_register = [S+$24-$10] (used reg = )
27845 7A27           8A46         F2            mov	al,-$E[bp]
27846 7A2A           30E4                       xor	ah,ah
27847 7A2C           50                         push	ax
27848                                           ! Debug: list int = const $B (used reg = )
27849 7A2D           B8                   000B  mov	ax,*$B
27850 7A30           50                         push	ax
27851                                           ! Debug: func () void = outb+0 (used reg = )
27852 7A31           E8         8ADA            call	_outb
27853 7A34           83C4                   04  add	sp,*4
27854                                           !BCC_EOS
27855                                           ! 4782   ;
27856                                           !BCC_EOS
27857                                           ! 4783         outb(0x0081, page);
27858                                           ! Debug: list unsigned char page = [S+$24-$F] (used reg = )
27859 7A37           8A46         F3            mov	al,-$D[bp]
27860 7A3A           30E4                       xor	ah,ah
27861 7A3C           50                         push	ax
27862                                           ! Debug: list int = const $81 (used reg = )
27863 7A3D           B8                   0081  mov	ax,#$81
27864 7A40           50                         push	ax
27865                                           ! Debug: func () void = outb+0 (used reg = )
27866 7A41           E8         8ACA            call	_outb
27867 7A44           83C4                   04  add	sp,*4
27868                                           !BCC_EOS
27869                                           ! 4784   ;
27870                                           !BCC_EOS
27871                                           ! 4785         outb(0x000a, 0x02);
27872                                           ! Debug: list int = const 2 (used reg = )
27873 7A47           B8                   0002  mov	ax,*2
27874 7A4A           50                         push	ax
27875                                           ! Debug: list int = const $A (used reg = )
27876 7A4B           B8                   000A  mov	ax,*$A
27877 7A4E           50                         push	ax
27878                                           ! Debug: func () void = outb+0 (used reg = )
27879 7A4F           E8         8ABC            call	_outb
27880 7A52           83C4                   04  add	sp,*4
27881                                           !BCC_EOS
27882                                           ! 4786         ;
27883                                           !BCC_EOS
27884                                           ! 4787         outb(0x000a, 0x02);
27885                                           ! Debug: list int = const 2 (used reg = )
27886 7A55           B8                   0002  mov	ax,*2
27887 7A58           50                         push	ax
27888                                           ! Debug: list int = const $A (used reg = )
27889 7A59           B8                   000A  mov	ax,*$A
27890 7A5C           50                         push	ax
27891                                           ! Debug: func () void = outb+0 (used reg = )
27892 7A5D           E8         8AAE            call	_outb
27893 7A60           83C4                   04  add	sp,*4
27894                                           !BCC_EOS
27895                                           ! 4788         floppy_prepare_controller(drive);
27896                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
27897 7A63           8A46         FF            mov	al,-1[bp]
27898 7A66           30E4                       xor	ah,ah
27899 7A68           50                         push	ax
27900                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
27901 7A69           E8         FA59            call	_floppy_prepare_controller
27902 7A6C           44                         inc	sp
27903 7A6D           44                         inc	sp
27904                                           !BCC_EOS
27905                                           ! 4789         outb(0x03f5, 0xe6);
27906                                           ! Debug: list int = const $E6 (used reg = )
27907 7A6E           B8                   00E6  mov	ax,#$E6
27908 7A71           50                         push	ax
27909                                           ! Debug: list int = const $3F5 (used reg = )
27910 7A72           B8                   03F5  mov	ax,#$3F5
27911 7A75           50                         push	ax
27912                                           ! Debug: func () void = outb+0 (used reg = )
27913 7A76           E8         8A95            call	_outb
27914 7A79           83C4                   04  add	sp,*4
27915                                           !BCC_EOS
27916                                           ! 4790       } else {
27917 7A7C           EB           4C            jmp .6BC
27918                       00007A7E            .6BA:
27919                                           ! 4791         mode_register = 0x4a;
27920                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$24-$10] (used reg = )
27921 7A7E           B0                     4A  mov	al,*$4A
27922 7A80           8846         F2            mov	-$E[bp],al
27923                                           !BCC_EOS
27924                                           ! 4792         outb(0x000b, mode_register);
27925                                           ! Debug: list unsigned char mode_register = [S+$24-$10] (used reg = )
27926 7A83           8A46         F2            mov	al,-$E[bp]
27927 7A86           30E4                       xor	ah,ah
27928 7A88           50                         push	ax
27929                                           ! Debug: list int = const $B (used reg = )
27930 7A89           B8                   000B  mov	ax,*$B
27931 7A8C           50                         push	ax
27932                                           ! Debug: func () void = outb+0 (used reg = )
27933 7A8D           E8         8A7E            call	_outb
27934 7A90           83C4                   04  add	sp,*4
27935                                           !BCC_EOS
27936                                           ! 4793         outb(0x0081, page);
27937                                           ! Debug: list unsigned char page = [S+$24-$F] (used reg = )
27938 7A93           8A46         F3            mov	al,-$D[bp]
27939 7A96           30E4                       xor	ah,ah
27940 7A98           50                         push	ax
27941                                           ! Debug: list int = const $81 (used reg = )
27942 7A99           B8                   0081  mov	ax,#$81
27943 7A9C           50                         push	ax
27944                                           ! Debug: func () void = outb+0 (used reg = )
27945 7A9D           E8         8A6E            call	_outb
27946 7AA0           83C4                   04  add	sp,*4
27947                                           !BCC_EOS
27948                                           ! 4794         ;
27949                                           !BCC_EOS
27950                                           ! 4795         outb(0x000a, 0x02);
27951                                           ! Debug: list int = const 2 (used reg = )
27952 7AA3           B8                   0002  mov	ax,*2
27953 7AA6           50                         push	ax
27954                                           ! Debug: list int = const $A (used reg = )
27955 7AA7           B8                   000A  mov	ax,*$A
27956 7AAA           50                         push	ax
27957                                           ! Debug: func () void = outb+0 (used reg = )
27958 7AAB           E8         8A60            call	_outb
27959 7AAE           83C4                   04  add	sp,*4
27960                                           !BCC_EOS
27961                                           ! 4796         floppy_prepare_controller(drive);
27962                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
27963 7AB1           8A46         FF            mov	al,-1[bp]
27964 7AB4           30E4                       xor	ah,ah
27965 7AB6           50                         push	ax
27966                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
27967 7AB7           E8         FA0B            call	_floppy_prepare_controller
27968 7ABA           44                         inc	sp
27969 7ABB           44                         inc	sp
27970                                           !BCC_EOS
27971                                           ! 4797         outb(0x03f5, 0xc5);
27972                                           ! Debug: list int = const $C5 (used reg = )
27973 7ABC           B8                   00C5  mov	ax,#$C5
27974 7ABF           50                         push	ax
27975                                           ! Debug: list int = const $3F5 (used reg = )
27976 7AC0           B8                   03F5  mov	ax,#$3F5
27977 7AC3           50                         push	ax
27978                                           ! Debug: func () void = outb+0 (used reg = )
27979 7AC4           E8         8A47            call	_outb
27980 7AC7           83C4                   04  add	sp,*4
27981                                           !BCC_EOS
27982                                           ! 4798       }
27983                                           ! 4799       outb(0x03f5, (head << 2) | drive);
27984                       00007ACA            .6BC:
27985                                           ! Debug: sl int = const 2 to unsigned char head = [S+$24-7] (used reg = )
27986 7ACA           8A46         FB            mov	al,-5[bp]
27987 7ACD           30E4                       xor	ah,ah
27988 7ACF           D1E0                       shl	ax,*1
27989 7AD1           D1E0                       shl	ax,*1
27990                                           ! Debug: or unsigned char drive = [S+$24-3] to unsigned int = ax+0 (used reg = )
27991 7AD3           0A46         FF            or	al,-1[bp]
27992                                           ! Debug: list unsigned int = ax+0 (used reg = )
27993 7AD6           50                         push	ax
27994                                           ! Debug: list int = const $3F5 (used reg = )
27995 7AD7           B8                   03F5  mov	ax,#$3F5
27996 7ADA           50                         push	ax
27997                                           ! Debug: func () void = outb+0 (used reg = )
27998 7ADB           E8         8A30            call	_outb
27999 7ADE           83C4                   04  add	sp,*4
28000                                           !BCC_EOS
28001                                           ! 4800       outb(0x03f5, track);
28002                                           ! Debug: list unsigned char track = [S+$24-5] (used reg = )
28003 7AE1           8A46         FD            mov	al,-3[bp]
28004 7AE4           30E4                       xor	ah,ah
28005 7AE6           50                         push	ax
28006                                           ! Debug: list int = const $3F5 (used reg = )
28007 7AE7           B8                   03F5  mov	ax,#$3F5
28008 7AEA           50                         push	ax
28009                                           ! Debug: func () void = outb+0 (used reg = )
28010 7AEB           E8         8A20            call	_outb
28011 7AEE           83C4                   04  add	sp,*4
28012                                           !BCC_EOS
28013                                           ! 4801       outb(0x03f5, head);
28014                                           ! Debug: list unsigned char head = [S+$24-7] (used reg = )
28015 7AF1           8A46         FB            mov	al,-5[bp]
28016 7AF4           30E4                       xor	ah,ah
28017 7AF6           50                         push	ax
28018                                           ! Debug: list int = const $3F5 (used reg = )
28019 7AF7           B8                   03F5  mov	ax,#$3F5
28020 7AFA           50                         push	ax
28021                                           ! Debug: func () void = outb+0 (used reg = )
28022 7AFB           E8         8A10            call	_outb
28023 7AFE           83C4                   04  add	sp,*4
28024                                           !BCC_EOS
28025                                           ! 4802       outb(0x03f5, sector);
28026                                           ! Debug: list unsigned char sector = [S+$24-6] (used reg = )
28027 7B01           8A46         FC            mov	al,-4[bp]
28028 7B04           30E4                       xor	ah,ah
28029 7B06           50                         push	ax
28030                                           ! Debug: list int = const $3F5 (used reg = )
28031 7B07           B8                   03F5  mov	ax,#$3F5
28032 7B0A           50                         push	ax
28033                                           ! Debug: func () void = outb+0 (used reg = )
28034 7B0B           E8         8A00            call	_outb
28035 7B0E           83C4                   04  add	sp,*4
28036                                           !BCC_EOS
28037                                           ! 4803       outb(0x03f5, 2);
28038                                           ! Debug: list int = const 2 (used reg = )
28039 7B11           B8                   0002  mov	ax,*2
28040 7B14           50                         push	ax
28041                                           ! Debug: list int = const $3F5 (used reg = )
28042 7B15           B8                   03F5  mov	ax,#$3F5
28043 7B18           50                         push	ax
28044                                           ! Debug: func () void = outb+0 (used reg = )
28045 7B19           E8         89F2            call	_outb
28046 7B1C           83C4                   04  add	sp,*4
28047                                           !BCC_EOS
28048                                           ! 4804       outb(0x03f5, sector + num_sectors - 1);
28049                                           ! Debug: add unsigned char num_sectors = [S+$24-4] to unsigned char sector = [S+$24-6] (used reg = )
28050 7B1F           8A46         FC            mov	al,-4[bp]
28051 7B22           30E4                       xor	ah,ah
28052 7B24           0246         FE            add	al,-2[bp]
28053 7B27           80D4                   00  adc	ah,*0
28054                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
28055                                           ! Debug: list unsigned int = ax-1 (used reg = )
28056 7B2A           48                         dec	ax
28057 7B2B           50                         push	ax
28058                                           ! Debug: list int = const $3F5 (used reg = )
28059 7B2C           B8                   03F5  mov	ax,#$3F5
28060 7B2F           50                         push	ax
28061                                           ! Debug: func () void = outb+0 (used reg = )
28062 7B30           E8         89DB            call	_outb
28063 7B33           83C4                   04  add	sp,*4
28064                                           !BCC_EOS
28065                                           ! 4805       outb(0x03f5, 0);
28066                                           ! Debug: list int = const 0 (used reg = )
28067 7B36           31C0                       xor	ax,ax
28068 7B38           50                         push	ax
28069                                           ! Debug: list int = const $3F5 (used reg = )
28070 7B39           B8                   03F5  mov	ax,#$3F5
28071 7B3C           50                         push	ax
28072                                           ! Debug: func () void = outb+0 (used reg = )
28073 7B3D           E8         89CE            call	_outb
28074 7B40           83C4                   04  add	sp,*4
28075                                           !BCC_EOS
28076                                           ! 4806       outb(0x03f5, 0xff);
28077                                           ! Debug: list int = const $FF (used reg = )
28078 7B43           B8                   00FF  mov	ax,#$FF
28079 7B46           50                         push	ax
28080                                           ! Debug: list int = const $3F5 (used reg = )
28081 7B47           B8                   03F5  mov	ax,#$3F5
28082 7B4A           50                         push	ax
28083                                           ! Debug: func () void = outb+0 (used reg = )
28084 7B4B           E8         89C0            call	_outb
28085 7B4E           83C4                   04  add	sp,*4
28086                                           !BCC_EOS
28087                                           ! 4807 #asm
28088                                           !BCC_EOS
28089                                           !BCC_ASM
28090                       0000002E            _int13_diskette_function.BP	set	$2E
28091                       0000000C            .int13_diskette_function.BP	set	$C
28092                       0000003C            _int13_diskette_function.CS	set	$3C
28093                       0000001A            .int13_diskette_function.CS	set	$1A
28094                       00000036            _int13_diskette_function.CX	set	$36
28095                       00000014            .int13_diskette_function.CX	set	$14
28096                       0000001A            _int13_diskette_function.base_address	set	$1A
28097                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
28098                       0000002A            _int13_diskette_function.DI	set	$2A
28099                       00000008            .int13_diskette_function.DI	set	8
28100                       0000003E            _int13_diskette_function.FLAGS	set	$3E
28101                       0000001C            .int13_diskette_function.FLAGS	set	$1C
28102                       00000018            _int13_diskette_function.base_count	set	$18
28103                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
28104                       0000001E            _int13_diskette_function.sector	set	$1E
28105                       FFFFFFFC            .int13_diskette_function.sector	set	-4
28106                       00000026            _int13_diskette_function.DS	set	$26
28107                       00000004            .int13_diskette_function.DS	set	4
28108                       0000001D            _int13_diskette_function.head	set	$1D
28109                       FFFFFFFB            .int13_diskette_function.head	set	-5
28110                       00000030            _int13_diskette_function.ELDX	set	$30
28111                       0000000E            .int13_diskette_function.ELDX	set	$E
28112                       00000012            _int13_diskette_function.dor	set	$12
28113                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
28114                       00000034            _int13_diskette_function.DX	set	$34
28115                       00000012            .int13_diskette_function.DX	set	$12
28116                       0000000B            _int13_diskette_function.return_status	set	$B
28117                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
28118                       00000004            _int13_diskette_function.es	set	4
28119                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
28120                       00000014            _int13_diskette_function.mode_register	set	$14
28121                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
28122                       00000028            _int13_diskette_function.ES	set	$28
28123                       00000006            .int13_diskette_function.ES	set	6
28124                       00000016            _int13_diskette_function.base_es	set	$16
28125                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
28126                       0000001F            _int13_diskette_function.track	set	$1F
28127                       FFFFFFFD            .int13_diskette_function.track	set	-3
28128                       0000002C            _int13_diskette_function.SI	set	$2C
28129                       0000000A            .int13_diskette_function.SI	set	$A
28130                       0000000A            _int13_diskette_function.drive_type	set	$A
28131                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
28132                       00000020            _int13_diskette_function.num_sectors	set	$20
28133                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
28134                       0000003A            _int13_diskette_function.IP	set	$3A
28135                       00000018            .int13_diskette_function.IP	set	$18
28136                       00000007            _int13_diskette_function.spt	set	7
28137                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
28138                       0000001C            _int13_diskette_function.status	set	$1C
28139                       FFFFFFFA            .int13_diskette_function.status	set	-6
28140                       00000000            _int13_diskette_function.maxCyl	set	0
28141                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
28142                       00000038            _int13_diskette_function.AX	set	$38
28143                       00000016            .int13_diskette_function.AX	set	$16
28144                       00000013            _int13_diskette_function.val8	set	$13
28145                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
28146                       00000002            _int13_diskette_function.last_addr	set	2
28147                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
28148                       00000015            _int13_diskette_function.page	set	$15
28149                       FFFFFFF3            .int13_diskette_function.page	set	-$D
28150                       00000008            _int13_diskette_function.ah	set	8
28151                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
28152                       00000021            _int13_diskette_function.drive	set	$21
28153                       FFFFFFFF            .int13_diskette_function.drive	set	-1
28154                       00000009            _int13_diskette_function.num_floppies	set	9
28155                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
28156                       00000032            _int13_diskette_function.BX	set	$32
28157                       00000010            .int13_diskette_function.BX	set	$10
28158 7B51           FB                               sti
28159                                           ! 4809 endasm
28160                                           !BCC_ENDASM
28161                                           !BCC_EOS
28162                                           ! 4810       do {
28163                       00007B52            .6BF:
28164                                           ! 4811         val8 = *((Bit8u *)(0x0040));
28165                                           ! Debug: eq unsigned char = [+$40] to unsigned char val8 = [S+$24-$11] (used reg = )
28166 7B52           A0         0040            mov	al,[$40]
28167 7B55           8846         F1            mov	-$F[bp],al
28168                                           !BCC_EOS
28169                                           ! 4812         if (val8 == 0) {
28170                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
28171 7B58           8A46         F1            mov	al,-$F[bp]
28172 7B5B           84C0                       test	al,al
28173 7B5D           75           22            jne 	.6C0
28174                       00007B5F            .6C1:
28175                                           ! 4813           floppy_reset_controller();
28176                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
28177 7B5F           E8         F915            call	_floppy_reset_controller
28178                                           !BCC_EOS
28179                                           ! 4814           *(((Bit8u *)&AX)+1) = (0x80);
28180                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
28181 7B62           B0                     80  mov	al,#$80
28182 7B64           8846         17            mov	$17[bp],al
28183                                           !BCC_EOS
28184                                           ! 4815           set_diskette_ret_status(0x80);
28185                                           ! Debug: list int = const $80 (used reg = )
28186 7B67           B8                   0080  mov	ax,#$80
28187 7B6A           50                         push	ax
28188                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28189 7B6B           E8         0AD3            call	_set_diskette_ret_status
28190 7B6E           44                         inc	sp
28191 7B6F           44                         inc	sp
28192                                           !BCC_EOS
28193                                           ! 4816           *((Bit8u *)&AX) 
28194                                           ! 4816 = (0);
28195                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
28196 7B70           30C0                       xor	al,al
28197 7B72           8846         16            mov	$16[bp],al
28198                                           !BCC_EOS
28199                                           ! 4817           FLAGS |= 0x0001;
28200                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28201 7B75           8B46         1C            mov	ax,$1C[bp]
28202 7B78           0C                     01  or	al,*1
28203 7B7A           8946         1C            mov	$1C[bp],ax
28204                                           !BCC_EOS
28205                                           ! 4818           return;
28206 7B7D           89EC                       mov	sp,bp
28207 7B7F           5D                         pop	bp
28208 7B80           C3                         ret
28209                                           !BCC_EOS
28210                                           ! 4819         }
28211                                           ! 4820         val8 = (*((Bit8u *)(0x003e)) & 0x80);
28212                       00007B81            .6C0:
28213                                           ! Debug: and int = const $80 to unsigned char = [+$3E] (used reg = )
28214 7B81           A0         003E            mov	al,[$3E]
28215 7B84           24                     80  and	al,#$80
28216                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
28217 7B86           8846         F1            mov	-$F[bp],al
28218                                           !BCC_EOS
28219                                           ! 4821       } while ( val8 == 0 );
28220                       00007B89            .6BE:
28221                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
28222 7B89           8A46         F1            mov	al,-$F[bp]
28223 7B8C           84C0                       test	al,al
28224 7B8E           74           C2            je 	.6BF
28225                       00007B90            .6C2:
28226                                           !BCC_EOS
28227                                           ! 4822       val8 = 0;
28228                       00007B90            .6BD:
28229                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
28230 7B90           30C0                       xor	al,al
28231 7B92           8846         F1            mov	-$F[bp],al
28232                                           !BCC_EOS
28233                                           ! 4823 #asm
28234                                           !BCC_EOS
28235                                           !BCC_ASM
28236                       0000002E            _int13_diskette_function.BP	set	$2E
28237                       0000000C            .int13_diskette_function.BP	set	$C
28238                       0000003C            _int13_diskette_function.CS	set	$3C
28239                       0000001A            .int13_diskette_function.CS	set	$1A
28240                       00000036            _int13_diskette_function.CX	set	$36
28241                       00000014            .int13_diskette_function.CX	set	$14
28242                       0000001A            _int13_diskette_function.base_address	set	$1A
28243                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
28244                       0000002A            _int13_diskette_function.DI	set	$2A
28245                       00000008            .int13_diskette_function.DI	set	8
28246                       0000003E            _int13_diskette_function.FLAGS	set	$3E
28247                       0000001C            .int13_diskette_function.FLAGS	set	$1C
28248                       00000018            _int13_diskette_function.base_count	set	$18
28249                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
28250                       0000001E            _int13_diskette_function.sector	set	$1E
28251                       FFFFFFFC            .int13_diskette_function.sector	set	-4
28252                       00000026            _int13_diskette_function.DS	set	$26
28253                       00000004            .int13_diskette_function.DS	set	4
28254                       0000001D            _int13_diskette_function.head	set	$1D
28255                       FFFFFFFB            .int13_diskette_function.head	set	-5
28256                       00000030            _int13_diskette_function.ELDX	set	$30
28257                       0000000E            .int13_diskette_function.ELDX	set	$E
28258                       00000012            _int13_diskette_function.dor	set	$12
28259                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
28260                       00000034            _int13_diskette_function.DX	set	$34
28261                       00000012            .int13_diskette_function.DX	set	$12
28262                       0000000B            _int13_diskette_function.return_status	set	$B
28263                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
28264                       00000004            _int13_diskette_function.es	set	4
28265                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
28266                       00000014            _int13_diskette_function.mode_register	set	$14
28267                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
28268                       00000028            _int13_diskette_function.ES	set	$28
28269                       00000006            .int13_diskette_function.ES	set	6
28270                       00000016            _int13_diskette_function.base_es	set	$16
28271                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
28272                       0000001F            _int13_diskette_function.track	set	$1F
28273                       FFFFFFFD            .int13_diskette_function.track	set	-3
28274                       0000002C            _int13_diskette_function.SI	set	$2C
28275                       0000000A            .int13_diskette_function.SI	set	$A
28276                       0000000A            _int13_diskette_function.drive_type	set	$A
28277                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
28278                       00000020            _int13_diskette_function.num_sectors	set	$20
28279                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
28280                       0000003A            _int13_diskette_function.IP	set	$3A
28281                       00000018            .int13_diskette_function.IP	set	$18
28282                       00000007            _int13_diskette_function.spt	set	7
28283                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
28284                       0000001C            _int13_diskette_function.status	set	$1C
28285                       FFFFFFFA            .int13_diskette_function.status	set	-6
28286                       00000000            _int13_diskette_function.maxCyl	set	0
28287                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
28288                       00000038            _int13_diskette_function.AX	set	$38
28289                       00000016            .int13_diskette_function.AX	set	$16
28290                       00000013            _int13_diskette_function.val8	set	$13
28291                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
28292                       00000002            _int13_diskette_function.last_addr	set	2
28293                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
28294                       00000015            _int13_diskette_function.page	set	$15
28295                       FFFFFFF3            .int13_diskette_function.page	set	-$D
28296                       00000008            _int13_diskette_function.ah	set	8
28297                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
28298                       00000021            _int13_diskette_function.drive	set	$21
28299                       FFFFFFFF            .int13_diskette_function.drive	set	-1
28300                       00000009            _int13_diskette_function.num_floppies	set	9
28301                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
28302                       00000032            _int13_diskette_function.BX	set	$32
28303                       00000010            .int13_diskette_function.BX	set	$10
28304 7B95           FA                               cli
28305                                           ! 4825 endasm
28306                                           !BCC_ENDASM
28307                                           !BCC_EOS
28308                                           ! 4826       val8 = *((Bit8u *)(0x003e));
28309                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+$24-$11] (used reg = )
28310 7B96           A0         003E            mov	al,[$3E]
28311 7B99           8846         F1            mov	-$F[bp],al
28312                                           !BCC_EOS
28313                                           ! 4827       val8 &= 0x7f;
28314                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$24-$11] (used reg = )
28315 7B9C           8A46         F1            mov	al,-$F[bp]
28316 7B9F           24                     7F  and	al,*$7F
28317 7BA1           8846         F1            mov	-$F[bp],al
28318                                           !BCC_EOS
28319                                           ! 4828       *((Bit8u *)(0x003e)) = (val8);
28320                                           ! Debug: eq unsigned char val8 = [S+$24-$11] to unsigned char = [+$3E] (used reg = )
28321 7BA4           8A46         F1            mov	al,-$F[bp]
28322 7BA7           A2         003E            mov	[$3E],al
28323                                           !BCC_EOS
28324                                           ! 4829       val8 = inb(0x03f4);
28325                                           ! Debug: list int = const $3F4 (used reg = )
28326 7BAA           B8                   03F4  mov	ax,#$3F4
28327 7BAD           50                         push	ax
28328                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28329 7BAE           E8         8947            call	_inb
28330 7BB1           44                         inc	sp
28331 7BB2           44                         inc	sp
28332                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
28333 7BB3           8846         F1            mov	-$F[bp],al
28334                                           !BCC_EOS
28335                                           ! 4830       if ( (val8 & 0xc0) != 0xc0 )
28336                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$24-$11] (used reg = )
28337 7BB6           8A46         F1            mov	al,-$F[bp]
28338 7BB9           24                     C0  and	al,#$C0
28339                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
28340 7BBB           3C                     C0  cmp	al,#$C0
28341 7BBD           74           0E            je  	.6C3
28342                       00007BBF            .6C4:
28343                                           ! 4831         bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
28344                                           ! Debug: list * char = .6C5+0 (used reg = )
28345 7BBF           BB                   CDFE  mov	bx,#.6C5
28346 7BC2           53                         push	bx
28347                                           ! Debug: list int = const 7 (used reg = )
28348 7BC3           B8                   0007  mov	ax,*7
28349 7BC6           50                         push	ax
28350                                           ! Debug: func () void = bios_printf+0 (used reg = )
28351 7BC7           E8         8D74            call	_bios_printf
28352 7BCA           83C4                   04  add	sp,*4
28353                                           !BCC_EOS
28354                                           ! 4832       return_status[0] = inb(0x03f5);
28355                       00007BCD            .6C3:
28356                                           ! Debug: list int = const $3F5 (used reg = )
28357 7BCD           B8                   03F5  mov	ax,#$3F5
28358 7BD0           50                         push	ax
28359                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28360 7BD1           E8         8924            call	_inb
28361 7BD4           44                         inc	sp
28362 7BD5           44                         inc	sp
28363                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$19] (used reg = )
28364 7BD6           8846         E9            mov	-$17[bp],al
28365                                           !BCC_EOS
28366                                           ! 4833       return_status[1] = inb(0x03f5);
28367                                           ! Debug: list int = const $3F5 (used reg = )
28368 7BD9           B8                   03F5  mov	ax,#$3F5
28369 7BDC           50                         push	ax
28370                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28371 7BDD           E8         8918            call	_inb
28372 7BE0           44                         inc	sp
28373 7BE1           44                         inc	sp
28374                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$18] (used reg = )
28375 7BE2           8846         EA            mov	-$16[bp],al
28376                                           !BCC_EOS
28377                                           ! 4834       return_status[2] = inb(0x03f5);
28378                                           ! Debug: list int = const $3F5 (used reg = )
28379 7BE5           B8                   03F5  mov	ax,#$3F5
28380 7BE8           50                         push	ax
28381                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28382 7BE9           E8         890C            call	_inb
28383 7BEC           44                         inc	sp
28384 7BED           44                         inc	sp
28385                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$17] (used reg = )
28386 7BEE           8846         EB            mov	-$15[bp],al
28387                                           !BCC_EOS
28388                                           ! 4835       return_status[3] = inb(0x03f5);
28389                                           ! Debug: list int = const $3F5 (used reg = )
28390 7BF1           B8                   03F5  mov	ax,#$3F5
28391 7BF4           50                         push	ax
28392                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28393 7BF5           E8         8900            call	_inb
28394 7BF8           44                         inc	sp
28395 7BF9           44                         inc	sp
28396                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$16] (used reg = )
28397 7BFA           8846         EC            mov	-$14[bp],al
28398                                           !BCC_EOS
28399                                           ! 4836       return_status[4] = inb(0x03f5);
28400                                           ! Debug: list int = const $3F5 (used reg = )
28401 7BFD           B8                   03F5  mov	ax,#$3F5
28402 7C00           50                         push	ax
28403                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28404 7C01           E8         88F4            call	_inb
28405 7C04           44                         inc	sp
28406 7C05           44                         inc	sp
28407                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$15] (used reg = )
28408 7C06           8846         ED            mov	-$13[bp],al
28409                                           !BCC_EOS
28410                                           ! 4837       return_status[5] = inb(0x03f5);
28411                                           ! Debug: list int = const $3F5 (used reg = )
28412 7C09           B8                   03F5  mov	ax,#$3F5
28413 7C0C           50                         push	ax
28414                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28415 7C0D           E8         88E8            call	_inb
28416 7C10           44                         inc	sp
28417 7C11           44                         inc	sp
28418                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$14] (used reg = )
28419 7C12           8846         EE            mov	-$12[bp],al
28420                                           !BCC_EOS
28421                                           ! 4838       return_status[6] = inb(0x03f5);
28422                                           ! Debug: list int = const $3F5 (used reg = )
28423 7C15           B8                   03F5  mov	ax,#$3F5
28424 7C18           50                         push	ax
28425                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28426 7C19           E8         88DC            call	_inb
28427 7C1C           44                         inc	sp
28428 7C1D           44                         inc	sp
28429                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$13] (used reg = )
28430 7C1E           8846         EF            mov	-$11[bp],al
28431                                           !BCC_EOS
28432                                           ! 4839       _memcpyb(0x0042,0x0040,return_status,get_SS(),7);
28433                                           ! Debug: list int = const 7 (used reg = )
28434 7C21           B8                   0007  mov	ax,*7
28435 7C24           50                         push	ax
28436                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
28437 7C25           E8         8A37            call	_get_SS
28438                                           ! Debug: list unsigned short = ax+0 (used reg = )
28439 7C28           50                         push	ax
28440                                           ! Debug: list * unsigned char return_status = S+$28-$19 (used reg = )
28441 7C29           8D5E         E9            lea	bx,-$17[bp]
28442 7C2C           53                         push	bx
28443                                           ! Debug: list int = const $40 (used reg = )
28444 7C2D           B8                   0040  mov	ax,*$40
28445 7C30           50                         push	ax
28446                                           ! Debug: list int = const $42 (used reg = )
28447 7C31           B8                   0042  mov	ax,*$42
28448 7C34           50                         push	ax
28449                                           ! Debug: func () void = _memcpyb+0 (used reg = )
28450 7C35           E8         83E3            call	__memcpyb
28451 7C38           83C4                   0A  add	sp,*$A
28452                                           !BCC_EOS
28453                                           ! 4840       if ( (return_status[0] & 0xc0) != 0 ) {
28454                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$24-$19] (used reg = )
28455 7C3B           8A46         E9            mov	al,-$17[bp]
28456 7C3E           24                     C0  and	al,#$C0
28457                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
28458 7C40           84C0                       test	al,al
28459 7C42           74           53            je  	.6C6
28460                       00007C44            .6C7:
28461                                           ! 4841         if (ah == 0x02) {
28462                                           ! Debug: logeq int = const 2 to unsigned char ah = [S+$24-$1C] (used reg = )
28463 7C44           8A46         E6            mov	al,-$1A[bp]
28464 7C47           3C                     02  cmp	al,*2
28465 7C49           75           21            jne 	.6C8
28466                       00007C4B            .6C9:
28467                                           ! 4842           *(((Bit8u *)&AX)+1) = (0x20);
28468                                           ! Debug: eq int = const $20 to unsigned char AX = [S+$24+$15] (used reg = )
28469 7C4B           B0                     20  mov	al,*$20
28470 7C4D           8846         17            mov	$17[bp],al
28471                                           !BCC_EOS
28472                                           ! 4843           set_diskette_ret_status(0x20);
28473                                           ! Debug: list int = const $20 (used reg = )
28474 7C50           B8                   0020  mov	ax,*$20
28475 7C53           50                         push	ax
28476                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28477 7C54           E8         09EA            call	_set_diskette_ret_status
28478 7C57           44                         inc	sp
28479 7C58           44                         inc	sp
28480                                           !BCC_EOS
28481                                           ! 4844           *((Bit8u *)&AX) = (0);
28482                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
28483 7C59           30C0                       xor	al,al
28484 7C5B           8846         16            mov	$16[bp],al
28485                                           !BCC_EOS
28486                                           ! 4845           FLAGS |= 0x0001;
28487                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28488 7C5E           8B46         1C            mov	ax,$1C[bp]
28489 7C61           0C                     01  or	al,*1
28490 7C63           8946         1C            mov	$1C[bp],ax
28491                                           !BCC_EOS
28492                                           ! 4846           return;
28493 7C66           89EC                       mov	sp,bp
28494 7C68           5D                         pop	bp
28495 7C69           C3                         ret
28496                                           !BCC_EOS
28497                                           ! 4847         } else {
28498 7C6A           EB           2B            jmp .6CA
28499                       00007C6C            .6C8:
28500                                           ! 4848           if ( (return_status[1] & 0x02) != 0 ) {
28501                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$24-$18] (used reg = )
28502 7C6C           8A46         EA            mov	al,-$16[bp]
28503 7C6F           24                     02  and	al,*2
28504                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
28505 7C71           84C0                       test	al,al
28506 7C73           74           14            je  	.6CB
28507                       00007C75            .6CC:
28508                                           ! 4849             AX = 0x0300;
28509                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$24+$14] (used reg = )
28510 7C75           B8                   0300  mov	ax,#$300
28511 7C78           8946         16            mov	$16[bp],ax
28512                                           !BCC_EOS
28513                                           ! 4850             FLAGS |= 0x0001;
28514                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28515 7C7B           8B46         1C            mov	ax,$1C[bp]
28516 7C7E           0C                     01  or	al,*1
28517 7C80           8946         1C            mov	$1C[bp],ax
28518                                           !BCC_EOS
28519                                           ! 4851             return;
28520 7C83           89EC                       mov	sp,bp
28521 7C85           5D                         pop	bp
28522 7C86           C3                         ret
28523                                           !BCC_EOS
28524                                           ! 4852           } else {
28525 7C87           EB           0E            jmp .6CD
28526                       00007C89            .6CB:
28527                                           ! 4853             bios_printf((2 | 4 | 1), "int13_diskette_function: write error\n");
28528                                           ! Debug: list * char = .6CE+0 (used reg = )
28529 7C89           BB                   CDD8  mov	bx,#.6CE
28530 7C8C           53                         push	bx
28531                                           ! Debug: list int = const 7 (used reg = )
28532 7C8D           B8                   0007  mov	ax,*7
28533 7C90           50                         push	ax
28534                                           ! Debug: func () void = bios_printf+0 (used reg = )
28535 7C91           E8         8CAA            call	_bios_printf
28536 7C94           83C4                   04  add	sp,*4
28537                                           !BCC_EOS
28538                                           ! 4854           }
28539                                           ! 4855         }
28540                       00007C97            .6CD:
28541                                           ! 4856       }
28542                       00007C97            .6CA:
28543                                           ! 4857 floppy_return_success:
28544                       00007C97            .6C6:
28545                       00007C97            .FFDA:
28546                                           ! 4858       set_diskette_current_cyl(drive, track);
28547                                           ! Debug: list unsigned char track = [S+$24-5] (used reg = )
28548 7C97           8A46         FD            mov	al,-3[bp]
28549 7C9A           30E4                       xor	ah,ah
28550 7C9C           50                         push	ax
28551                                           ! Debug: list unsigned char drive = [S+$26-3] (used reg = )
28552 7C9D           8A46         FF            mov	al,-1[bp]
28553 7CA0           30E4                       xor	ah,ah
28554 7CA2           50                         push	ax
28555                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
28556 7CA3           E8         09B3            call	_set_diskette_current_cyl
28557 7CA6           83C4                   04  add	sp,*4
28558                                           !BCC_EOS
28559                                           ! 4859       *(((Bit8u *)&AX)+1) = (0x00);
28560                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
28561 7CA9           30C0                       xor	al,al
28562 7CAB           8846         17            mov	$17[bp],al
28563                                           !BCC_EOS
28564                                           ! 4860       FLAGS &= 0xfffe;
28565                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28566 7CAE           8B46         1C            mov	ax,$1C[bp]
28567 7CB1           24                     FE  and	al,#$FE
28568 7CB3           8946         1C            mov	$1C[bp],ax
28569                                           !BCC_EOS
28570                                           ! 4861       break;
28571 7CB6           E9         0984            br 	.696
28572                                           !BCC_EOS
28573                                           ! 4862     case 0x05:
28574                                           ! 4863 ;
28575                       00007CB9            .6CF:
28576                                           !BCC_EOS
28577                                           ! 4864       num_sectors = ( AX & 0x00ff );
28578                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
28579 7CB9           8A46         16            mov	al,$16[bp]
28580                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$24-4] (used reg = )
28581 7CBC           8846         FE            mov	-2[bp],al
28582                                           !BCC_EOS
28583                                           ! 4865       track = *(((Bit8u *)&CX)+1);
28584                                           ! Debug: eq unsigned char CX = [S+$24+$13] to unsigned char track = [S+$24-5] (used reg = )
28585 7CBF           8A46         15            mov	al,$15[bp]
28586 7CC2           8846         FD            mov	-3[bp],al
28587                                           !BCC_EOS
28588                                           ! 4866       head = *(((Bit8u *)&DX)+1);
28589                                           ! Debug: eq unsigned char DX = [S+$24+$11] to unsigned char head = [S+$24-7] (used reg = )
28590 7CC5           8A46         13            mov	al,$13[bp]
28591 7CC8           8846         FB            mov	-5[bp],al
28592                                           !BCC_EOS
28593                                           ! 4867       drive = ( ELDX & 0x00ff );
28594                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
28595 7CCB           8A46         0E            mov	al,$E[bp]
28596                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
28597 7CCE           8846         FF            mov	-1[bp],al
28598                                           !BCC_EOS
28599                                           ! 4868       if ((drive > 1) || (head > 1) || (track > 79) ||
28600                                           ! 4869           (num_sectors == 0) || (num_sectors > 18)) {
28601                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
28602 7CD1           8A46         FF            mov	al,-1[bp]
28603 7CD4           3C                     01  cmp	al,*1
28604 7CD6           77           1C            ja  	.6D1
28605                       00007CD8            .6D5:
28606                                           ! Debug: gt int = const 1 to unsigned char head = [S+$24-7] (used reg = )
28607 7CD8           8A46         FB            mov	al,-5[bp]
28608 7CDB           3C                     01  cmp	al,*1
28609 7CDD           77           15            ja  	.6D1
28610                       00007CDF            .6D4:
28611                                           ! Debug: gt int = const $4F to unsigned char track = [S+$24-5] (used reg = )
28612 7CDF           8A46         FD            mov	al,-3[bp]
28613 7CE2           3C                     4F  cmp	al,*$4F
28614 7CE4           77           0E            ja  	.6D1
28615                       00007CE6            .6D3:
28616                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$24-4] (used reg = )
28617 7CE6           8A46         FE            mov	al,-2[bp]
28618 7CE9           84C0                       test	al,al
28619 7CEB           74           07            je  	.6D1
28620                       00007CED            .6D2:
28621                                           ! Debug: gt int = const $12 to unsigned char num_sectors = [S+$24-4] (used reg = )
28622 7CED           8A46         FE            mov	al,-2[bp]
28623 7CF0           3C                     12  cmp	al,*$12
28624 7CF2           76           16            jbe 	.6D0
28625                       00007CF4            .6D1:
28626                                           ! 4870         *(((Bit8u *)&AX)+1) = (1);
28627                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
28628 7CF4           B0                     01  mov	al,*1
28629 7CF6           8846         17            mov	$17[bp],al
28630                                           !BCC_EOS
28631                                           ! 4871         set_diskette_ret_status(1);
28632                                           ! Debug: list int = const 1 (used reg = )
28633 7CF9           B8                   0001  mov	ax,*1
28634 7CFC           50                         push	ax
28635                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28636 7CFD           E8         0941            call	_set_diskette_ret_status
28637 7D00           44                         inc	sp
28638 7D01           44                         inc	sp
28639                                           !BCC_EOS
28640                                           ! 4872         FLAGS |= 0x0001;
28641                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28642 7D02           8B46         1C            mov	ax,$1C[bp]
28643 7D05           0C                     01  or	al,*1
28644 7D07           8946         1C            mov	$1C[bp],ax
28645                                           !BCC_EOS
28646                                           ! 4873       }
28647                                           ! 4874       if (floppy_drive_exists(drive) == 0) {
28648                       00007D0A            .6D0:
28649                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
28650 7D0A           8A46         FF            mov	al,-1[bp]
28651 7D0D           30E4                       xor	ah,ah
28652 7D0F           50                         push	ax
28653                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
28654 7D10           E8         FA38            call	_floppy_drive_exists
28655 7D13           44                         inc	sp
28656 7D14           44                         inc	sp
28657                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
28658 7D15           85C0                       test	ax,ax
28659 7D17           75           1A            jne 	.6D6
28660                       00007D19            .6D7:
28661                                           ! 4875         *(((Bit8u *)&AX)+1) = (0x80);
28662                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
28663 7D19           B0                     80  mov	al,#$80
28664 7D1B           8846         17            mov	$17[bp],al
28665                                           !BCC_EOS
28666                                           ! 4876         set_diskette_ret_status(0x80);
28667                                           ! Debug: list int = const $80 (used reg = )
28668 7D1E           B8                   0080  mov	ax,#$80
28669 7D21           50                         push	ax
28670                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28671 7D22           E8         091C            call	_set_diskette_ret_status
28672 7D25           44                         inc	sp
28673 7D26           44                         inc	sp
28674                                           !BCC_EOS
28675                                           ! 4877         FLAGS |= 0x0001;
28676                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28677 7D27           8B46         1C            mov	ax,$1C[bp]
28678 7D2A           0C                     01  or	al,*1
28679 7D2C           8946         1C            mov	$1C[bp],ax
28680                                           !BCC_EOS
28681                                           ! 4878         return;
28682 7D2F           89EC                       mov	sp,bp
28683 7D31           5D                         pop	bp
28684 7D32           C3                         ret
28685                                           !BCC_EOS
28686                                           ! 4879       }
28687                                           ! 4880       if (floppy_media_known(drive) == 0) {
28688                       00007D33            .6D6:
28689                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
28690 7D33           8A46         FF            mov	al,-1[bp]
28691 7D36           30E4                       xor	ah,ah
28692 7D38           50                         push	ax
28693                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
28694 7D39           E8         F829            call	_floppy_media_known
28695 7D3C           44                         inc	sp
28696 7D3D           44                         inc	sp
28697                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
28698 7D3E           85C0                       test	ax,ax
28699 7D40           75           2E            jne 	.6D8
28700                       00007D42            .6D9:
28701                                           ! 4881         if (floppy_media_sense(drive) == 0) {
28702                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
28703 7D42           8A46         FF            mov	al,-1[bp]
28704 7D45           30E4                       xor	ah,ah
28705 7D47           50                         push	ax
28706                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
28707 7D48           E8         F88A            call	_floppy_media_sense
28708 7D4B           44                         inc	sp
28709 7D4C           44                         inc	sp
28710                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
28711 7D4D           85C0                       test	ax,ax
28712 7D4F           75           1F            jne 	.6DA
28713                       00007D51            .6DB:
28714                                           ! 4882           *(((Bit8u *)&AX)+1) = (0x0C);
28715                                           ! Debug: eq int = const $C to unsigned char AX = [S+$24+$15] (used reg = )
28716 7D51           B0                     0C  mov	al,*$C
28717 7D53           8846         17            mov	$17[bp],al
28718                                           !BCC_EOS
28719                                           ! 4883           set_d
28720                                           ! 4883 iskette_ret_status(0x0C);
28721                                           ! Debug: list int = const $C (used reg = )
28722 7D56           B8                   000C  mov	ax,*$C
28723 7D59           50                         push	ax
28724                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28725 7D5A           E8         08E4            call	_set_diskette_ret_status
28726 7D5D           44                         inc	sp
28727 7D5E           44                         inc	sp
28728                                           !BCC_EOS
28729                                           ! 4884           *((Bit8u *)&AX) = (0);
28730                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
28731 7D5F           30C0                       xor	al,al
28732 7D61           8846         16            mov	$16[bp],al
28733                                           !BCC_EOS
28734                                           ! 4885           FLAGS |= 0x0001;
28735                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28736 7D64           8B46         1C            mov	ax,$1C[bp]
28737 7D67           0C                     01  or	al,*1
28738 7D69           8946         1C            mov	$1C[bp],ax
28739                                           !BCC_EOS
28740                                           ! 4886           return;
28741 7D6C           89EC                       mov	sp,bp
28742 7D6E           5D                         pop	bp
28743 7D6F           C3                         ret
28744                                           !BCC_EOS
28745                                           ! 4887         }
28746                                           ! 4888       }
28747                       00007D70            .6DA:
28748                                           ! 4889       page = (ES >> 12);
28749                       00007D70            .6D8:
28750                                           ! Debug: sr int = const $C to unsigned short ES = [S+$24+4] (used reg = )
28751 7D70           8B46         06            mov	ax,6[bp]
28752 7D73           88E0                       mov	al,ah
28753 7D75           30E4                       xor	ah,ah
28754 7D77           B1                     04  mov	cl,*4
28755 7D79           D3E8                       shr	ax,cl
28756                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$24-$F] (used reg = )
28757 7D7B           8846         F3            mov	-$D[bp],al
28758                                           !BCC_EOS
28759                                           ! 4890       base_es = (ES << 4);
28760                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$24+4] (used reg = )
28761 7D7E           8B46         06            mov	ax,6[bp]
28762 7D81           B1                     04  mov	cl,*4
28763 7D83           D3E0                       shl	ax,cl
28764                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$24-$E] (used reg = )
28765 7D85           8946         F4            mov	-$C[bp],ax
28766                                           !BCC_EOS
28767                                           ! 4891       base_address = base_es + BX;
28768                                           ! Debug: add unsigned short BX = [S+$24+$E] to unsigned short base_es = [S+$24-$E] (used reg = )
28769 7D88           8B46         F4            mov	ax,-$C[bp]
28770 7D8B           0346         10            add	ax,$10[bp]
28771                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$24-$A] (used reg = )
28772 7D8E           8946         F8            mov	-8[bp],ax
28773                                           !BCC_EOS
28774                                           ! 4892       if ( base_address < base_es ) {
28775                                           ! Debug: lt unsigned short base_es = [S+$24-$E] to unsigned short base_address = [S+$24-$A] (used reg = )
28776 7D91           8B46         F8            mov	ax,-8[bp]
28777 7D94           3B46         F4            cmp	ax,-$C[bp]
28778 7D97           73           07            jae 	.6DC
28779                       00007D99            .6DD:
28780                                           ! 4893         page++;
28781                                           ! Debug: postinc unsigned char page = [S+$24-$F] (used reg = )
28782 7D99           8A46         F3            mov	al,-$D[bp]
28783 7D9C           40                         inc	ax
28784 7D9D           8846         F3            mov	-$D[bp],al
28785                                           !BCC_EOS
28786                                           ! 4894       }
28787                                           ! 4895       base_count = (num_sectors * 4) - 1;
28788                       00007DA0            .6DC:
28789                                           ! Debug: mul int = const 4 to unsigned char num_sectors = [S+$24-4] (used reg = )
28790 7DA0           8A46         FE            mov	al,-2[bp]
28791 7DA3           30E4                       xor	ah,ah
28792 7DA5           D1E0                       shl	ax,*1
28793 7DA7           D1E0                       shl	ax,*1
28794                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
28795                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$24-$C] (used reg = )
28796 7DA9           48                         dec	ax
28797 7DAA           8946         F6            mov	-$A[bp],ax
28798                                           !BCC_EOS
28799                                           ! 4896       last_addr = base_address + base_count;
28800                                           ! Debug: add unsigned short base_count = [S+$24-$C] to unsigned short base_address = [S+$24-$A] (used reg = )
28801 7DAD           8B46         F8            mov	ax,-8[bp]
28802 7DB0           0346         F6            add	ax,-$A[bp]
28803                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$24-$22] (used reg = )
28804 7DB3           8946         E0            mov	-$20[bp],ax
28805                                           !BCC_EOS
28806                                           ! 4897       if (last_addr < base_address) {
28807                                           ! Debug: lt unsigned short base_address = [S+$24-$A] to unsigned short last_addr = [S+$24-$22] (used reg = )
28808 7DB6           8B46         E0            mov	ax,-$20[bp]
28809 7DB9           3B46         F8            cmp	ax,-8[bp]
28810 7DBC           73           1F            jae 	.6DE
28811                       00007DBE            .6DF:
28812                                           ! 4898         *(((Bit8u *)&AX)+1) = (0x09);
28813                                           ! Debug: eq int = const 9 to unsigned char AX = [S+$24+$15] (used reg = )
28814 7DBE           B0                     09  mov	al,*9
28815 7DC0           8846         17            mov	$17[bp],al
28816                                           !BCC_EOS
28817                                           ! 4899         set_diskette_ret_status(0x09);
28818                                           ! Debug: list int = const 9 (used reg = )
28819 7DC3           B8                   0009  mov	ax,*9
28820 7DC6           50                         push	ax
28821                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28822 7DC7           E8         0877            call	_set_diskette_ret_status
28823 7DCA           44                         inc	sp
28824 7DCB           44                         inc	sp
28825                                           !BCC_EOS
28826                                           ! 4900         *((Bit8u *)&AX) = (0);
28827                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
28828 7DCC           30C0                       xor	al,al
28829 7DCE           8846         16            mov	$16[bp],al
28830                                           !BCC_EOS
28831                                           ! 4901         FLAGS |= 0x0001;
28832                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28833 7DD1           8B46         1C            mov	ax,$1C[bp]
28834 7DD4           0C                     01  or	al,*1
28835 7DD6           8946         1C            mov	$1C[bp],ax
28836                                           !BCC_EOS
28837                                           ! 4902         return;
28838 7DD9           89EC                       mov	sp,bp
28839 7DDB           5D                         pop	bp
28840 7DDC           C3                         ret
28841                                           !BCC_EOS
28842                                           ! 4903       }
28843                                           ! 4904       outb(0x000a, 0x06);
28844                       00007DDD            .6DE:
28845                                           ! Debug: list int = const 6 (used reg = )
28846 7DDD           B8                   0006  mov	ax,*6
28847 7DE0           50                         push	ax
28848                                           ! Debug: list int = const $A (used reg = )
28849 7DE1           B8                   000A  mov	ax,*$A
28850 7DE4           50                         push	ax
28851                                           ! Debug: func () void = outb+0 (used reg = )
28852 7DE5           E8         8726            call	_outb
28853 7DE8           83C4                   04  add	sp,*4
28854                                           !BCC_EOS
28855                                           ! 4905       outb(0x000c, 0x00);
28856                                           ! Debug: list int = const 0 (used reg = )
28857 7DEB           31C0                       xor	ax,ax
28858 7DED           50                         push	ax
28859                                           ! Debug: list int = const $C (used reg = )
28860 7DEE           B8                   000C  mov	ax,*$C
28861 7DF1           50                         push	ax
28862                                           ! Debug: func () void = outb+0 (used reg = )
28863 7DF2           E8         8719            call	_outb
28864 7DF5           83C4                   04  add	sp,*4
28865                                           !BCC_EOS
28866                                           ! 4906       outb(0x0004, base_address);
28867                                           ! Debug: list unsigned short base_address = [S+$24-$A] (used reg = )
28868 7DF8           FF76         F8            push	-8[bp]
28869                                           ! Debug: list int = const 4 (used reg = )
28870 7DFB           B8                   0004  mov	ax,*4
28871 7DFE           50                         push	ax
28872                                           ! Debug: func () void = outb+0 (used reg = )
28873 7DFF           E8         870C            call	_outb
28874 7E02           83C4                   04  add	sp,*4
28875                                           !BCC_EOS
28876                                           ! 4907       outb(0x0004, *(((Bit8u *)&base_address)+1));
28877                                           ! Debug: list unsigned char base_address = [S+$24-9] (used reg = )
28878 7E05           8A46         F9            mov	al,-7[bp]
28879 7E08           30E4                       xor	ah,ah
28880 7E0A           50                         push	ax
28881                                           ! Debug: list int = const 4 (used reg = )
28882 7E0B           B8                   0004  mov	ax,*4
28883 7E0E           50                         push	ax
28884                                           ! Debug: func () void = outb+0 (used reg = )
28885 7E0F           E8         86FC            call	_outb
28886 7E12           83C4                   04  add	sp,*4
28887                                           !BCC_EOS
28888                                           ! 4908       outb(0x000c, 0x00);
28889                                           ! Debug: list int = const 0 (used reg = )
28890 7E15           31C0                       xor	ax,ax
28891 7E17           50                         push	ax
28892                                           ! Debug: list int = const $C (used reg = )
28893 7E18           B8                   000C  mov	ax,*$C
28894 7E1B           50                         push	ax
28895                                           ! Debug: func () void = outb+0 (used reg = )
28896 7E1C           E8         86EF            call	_outb
28897 7E1F           83C4                   04  add	sp,*4
28898                                           !BCC_EOS
28899                                           ! 4909       outb(0x0005, base_count);
28900                                           ! Debug: list unsigned short base_count = [S+$24-$C] (used reg = )
28901 7E22           FF76         F6            push	-$A[bp]
28902                                           ! Debug: list int = const 5 (used reg = )
28903 7E25           B8                   0005  mov	ax,*5
28904 7E28           50                         push	ax
28905                                           ! Debug: func () void = outb+0 (used reg = )
28906 7E29           E8         86E2            call	_outb
28907 7E2C           83C4                   04  add	sp,*4
28908                                           !BCC_EOS
28909                                           ! 4910       outb(0x0005, *(((Bit8u *)&base_count)+1));
28910                                           ! Debug: list unsigned char base_count = [S+$24-$B] (used reg = )
28911 7E2F           8A46         F7            mov	al,-9[bp]
28912 7E32           30E4                       xor	ah,ah
28913 7E34           50                         push	ax
28914                                           ! Debug: list int = const 5 (used reg = )
28915 7E35           B8                   0005  mov	ax,*5
28916 7E38           50                         push	ax
28917                                           ! Debug: func () void = outb+0 (used reg = )
28918 7E39           E8         86D2            call	_outb
28919 7E3C           83C4                   04  add	sp,*4
28920                                           !BCC_EOS
28921                                           ! 4911       mode_register = 0x4a;
28922                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$24-$10] (used reg = )
28923 7E3F           B0                     4A  mov	al,*$4A
28924 7E41           8846         F2            mov	-$E[bp],al
28925                                           !BCC_EOS
28926                                           ! 4912       outb(0x000b, mode_register);
28927                                           ! Debug: list unsigned char mode_register = [S+$24-$10] (used reg = )
28928 7E44           8A46         F2            mov	al,-$E[bp]
28929 7E47           30E4                       xor	ah,ah
28930 7E49           50                         push	ax
28931                                           ! Debug: list int = const $B (used reg = )
28932 7E4A           B8                   000B  mov	ax,*$B
28933 7E4D           50                         push	ax
28934                                           ! Debug: func () void = outb+0 (used reg = )
28935 7E4E           E8         86BD            call	_outb
28936 7E51           83C4                   04  add	sp,*4
28937                                           !BCC_EOS
28938                                           ! 4913       outb(0x0081, page);
28939                                           ! Debug: list unsigned char page = [S+$24-$F] (used reg = )
28940 7E54           8A46         F3            mov	al,-$D[bp]
28941 7E57           30E4                       xor	ah,ah
28942 7E59           50                         push	ax
28943                                           ! Debug: list int = const $81 (used reg = )
28944 7E5A           B8                   0081  mov	ax,#$81
28945 7E5D           50                         push	ax
28946                                           ! Debug: func () void = outb+0 (used reg = )
28947 7E5E           E8         86AD            call	_outb
28948 7E61           83C4                   04  add	sp,*4
28949                                           !BCC_EOS
28950                                           ! 4914       outb(0x000a, 0x02);
28951                                           ! Debug: list int = const 2 (used reg = )
28952 7E64           B8                   0002  mov	ax,*2
28953 7E67           50                         push	ax
28954                                           ! Debug: list int = const $A (used reg = )
28955 7E68           B8                   000A  mov	ax,*$A
28956 7E6B           50                         push	ax
28957                                           ! Debug: func () void = outb+0 (used reg = )
28958 7E6C           E8         869F            call	_outb
28959 7E6F           83C4                   04  add	sp,*4
28960                                           !BCC_EOS
28961                                           ! 4915       floppy_prepare_controller(drive);
28962                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
28963 7E72           8A46         FF            mov	al,-1[bp]
28964 7E75           30E4                       xor	ah,ah
28965 7E77           50                         push	ax
28966                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
28967 7E78           E8         F64A            call	_floppy_prepare_controller
28968 7E7B           44                         inc	sp
28969 7E7C           44                         inc	sp
28970                                           !BCC_EOS
28971                                           ! 4916       outb(0x03f5, 0x4d);
28972                                           ! Debug: list int = const $4D (used reg = )
28973 7E7D           B8                   004D  mov	ax,*$4D
28974 7E80           50                         push	ax
28975                                           ! Debug: list int = const $3F5 (used reg = )
28976 7E81           B8                   03F5  mov	ax,#$3F5
28977 7E84           50                         push	ax
28978                                           ! Debug: func () void = outb+0 (used reg = )
28979 7E85           E8         8686            call	_outb
28980 7E88           83C4                   04  add	sp,*4
28981                                           !BCC_EOS
28982                                           ! 4917       outb(0x03f5, (head << 2) | drive);
28983                                           ! Debug: sl int = const 2 to unsigned char head = [S+$24-7] (used reg = )
28984 7E8B           8A46         FB            mov	al,-5[bp]
28985 7E8E           30E4                       xor	ah,ah
28986 7E90           D1E0                       shl	ax,*1
28987 7E92           D1E0                       shl	ax,*1
28988                                           ! Debug: or unsigned char drive = [S+$24-3] to unsigned int = ax+0 (used reg = )
28989 7E94           0A46         FF            or	al,-1[bp]
28990                                           ! Debug: list unsigned int = ax+0 (used reg = )
28991 7E97           50                         push	ax
28992                                           ! Debug: list int = const $3F5 (used reg = )
28993 7E98           B8                   03F5  mov	ax,#$3F5
28994 7E9B           50                         push	ax
28995                                           ! Debug: func () void = outb+0 (used reg = )
28996 7E9C           E8         866F            call	_outb
28997 7E9F           83C4                   04  add	sp,*4
28998                                           !BCC_EOS
28999                                           ! 4918       outb(0x03f5, 2);
29000                                           ! Debug: list int = const 2 (used reg = )
29001 7EA2           B8                   0002  mov	ax,*2
29002 7EA5           50                         push	ax
29003                                           ! Debug: list int = const $3F5 (used reg = )
29004 7EA6           B8                   03F5  mov	ax,#$3F5
29005 7EA9           50                         push	ax
29006                                           ! Debug: func () void = outb+0 (used reg = )
29007 7EAA           E8         8661            call	_outb
29008 7EAD           83C4                   04  add	sp,*4
29009                                           !BCC_EOS
29010                                           ! 4919       outb(0x03f5, num_sectors);
29011                                           ! Debug: list unsigned char num_sectors = [S+$24-4] (used reg = )
29012 7EB0           8A46         FE            mov	al,-2[bp]
29013 7EB3           30E4                       xor	ah,ah
29014 7EB5           50                         push	ax
29015                                           ! Debug: list int = const $3F5 (used reg = )
29016 7EB6           B8                   03F5  mov	ax,#$3F5
29017 7EB9           50                         push	ax
29018                                           ! Debug: func () void = outb+0 (used reg = )
29019 7EBA           E8         8651            call	_outb
29020 7EBD           83C4                   04  add	sp,*4
29021                                           !BCC_EOS
29022                                           ! 4920       outb(0x03f5, 0);
29023                                           ! Debug: list int = const 0 (used reg = )
29024 7EC0           31C0                       xor	ax,ax
29025 7EC2           50                         push	ax
29026                                           ! Debug: list int = const $3F5 (used reg = )
29027 7EC3           B8                   03F5  mov	ax,#$3F5
29028 7EC6           50                         push	ax
29029                                           ! Debug: func () void = outb+0 (used reg = )
29030 7EC7           E8         8644            call	_outb
29031 7ECA           83C4                   04  add	sp,*4
29032                                           !BCC_EOS
29033                                           ! 4921       outb(0x03f5, 0xf6);
29034                                           ! Debug: list int = const $F6 (used reg = )
29035 7ECD           B8                   00F6  mov	ax,#$F6
29036 7ED0           50                         push	ax
29037                                           ! Debug: list int = const $3F5 (used reg = )
29038 7ED1           B8                   03F5  mov	ax,#$3F5
29039 7ED4           50                         push	ax
29040                                           ! Debug: func () void = outb+0 (used reg = )
29041 7ED5           E8         8636            call	_outb
29042 7ED8           83C4                   04  add	sp,*4
29043                                           !BCC_EOS
29044                                           ! 4922 #asm
29045                                           !BCC_EOS
29046                                           !BCC_ASM
29047                       0000002E            _int13_diskette_function.BP	set	$2E
29048                       0000000C            .int13_diskette_function.BP	set	$C
29049                       0000003C            _int13_diskette_function.CS	set	$3C
29050                       0000001A            .int13_diskette_function.CS	set	$1A
29051                       00000036            _int13_diskette_function.CX	set	$36
29052                       00000014            .int13_diskette_function.CX	set	$14
29053                       0000001A            _int13_diskette_function.base_address	set	$1A
29054                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
29055                       0000002A            _int13_diskette_function.DI	set	$2A
29056                       00000008            .int13_diskette_function.DI	set	8
29057                       0000003E            _int13_diskette_function.FLAGS	set	$3E
29058                       0000001C            .int13_diskette_function.FLAGS	set	$1C
29059                       00000018            _int13_diskette_function.base_count	set	$18
29060                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
29061                       0000001E            _int13_diskette_function.sector	set	$1E
29062                       FFFFFFFC            .int13_diskette_function.sector	set	-4
29063                       00000026            _int13_diskette_function.DS	set	$26
29064                       00000004            .int13_diskette_function.DS	set	4
29065                       0000001D            _int13_diskette_function.head	set	$1D
29066                       FFFFFFFB            .int13_diskette_function.head	set	-5
29067                       00000030            _int13_diskette_function.ELDX	set	$30
29068                       0000000E            .int13_diskette_function.ELDX	set	$E
29069                       00000012            _int13_diskette_function.dor	set	$12
29070                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
29071                       00000034            _int13_diskette_function.DX	set	$34
29072                       00000012            .int13_diskette_function.DX	set	$12
29073                       0000000B            _int13_diskette_function.return_status	set	$B
29074                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
29075                       00000004            _int13_diskette_function.es	set	4
29076                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
29077                       00000014            _int13_diskette_function.mode_register	set	$14
29078                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
29079                       00000028            _int13_diskette_function.ES	set	$28
29080                       00000006            .int13_diskette_function.ES	set	6
29081                       00000016            _int13_diskette_function.base_es	set	$16
29082                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
29083                       0000001F            _int13_diskette_function.track	set	$1F
29084                       FFFFFFFD            .int13_diskette_function.track	set	-3
29085                       0000002C            _int13_diskette_function.SI	set	$2C
29086                       0000000A            .int13_diskette_function.SI	set	$A
29087                       0000000A            _int13_diskette_function.drive_type	set	$A
29088                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
29089                       00000020            _int13_diskette_function.num_sectors	set	$20
29090                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
29091                       0000003A            _int13_diskette_function.IP	set	$3A
29092                       00000018            .int13_diskette_function.IP	set	$18
29093                       00000007            _int13_diskette_function.spt	set	7
29094                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
29095                       0000001C            _int13_diskette_function.status	set	$1C
29096                       FFFFFFFA            .int13_diskette_function.status	set	-6
29097                       00000000            _int13_diskette_function.maxCyl	set	0
29098                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
29099                       00000038            _int13_diskette_function.AX	set	$38
29100                       00000016            .int13_diskette_function.AX	set	$16
29101                       00000013            _int13_diskette_function.val8	set	$13
29102                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
29103                       00000002            _int13_diskette_function.last_addr	set	2
29104                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
29105                       00000015            _int13_diskette_function.page	set	$15
29106                       FFFFFFF3            .int13_diskette_function.page	set	-$D
29107                       00000008            _int13_diskette_function.ah	set	8
29108                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
29109                       00000021            _int13_diskette_function.drive	set	$21
29110                       FFFFFFFF            .int13_diskette_function.drive	set	-1
29111                       00000009            _int13_diskette_function.num_floppies	set	9
29112                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
29113                       00000032            _int13_diskette_function.BX	set	$32
29114                       00000010            .int13_diskette_function.BX	set	$10
29115 7EDB           FB                               sti
29116                                           ! 4924 endasm
29117                                           !BCC_ENDASM
29118                                           !BCC_EOS
29119                                           ! 4925       do {
29120                       00007EDC            .6E2:
29121                                           ! 4926         val8 = *((Bit8u *)(0x0040));
29122                                           ! Debug: eq unsigned char = [+$40] to unsigned char val8 = [S+$24-$11] (used reg = )
29123 7EDC           A0         0040            mov	al,[$40]
29124 7EDF           8846         F1            mov	-$F[bp],al
29125                                           !BCC_EOS
29126                                           ! 4927         if (val8 == 0) {
29127                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
29128 7EE2           8A46         F1            mov	al,-$F[bp]
29129 7EE5           84C0                       test	al,al
29130 7EE7           75           1D            jne 	.6E3
29131                       00007EE9            .6E4:
29132                                           ! 4928           floppy_reset_controller();
29133                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
29134 7EE9           E8         F58B            call	_floppy_reset_controller
29135                                           !BCC_EOS
29136                                           ! 4929           *(((Bit8u *)&AX)+1) = (0x80);
29137                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
29138 7EEC           B0                     80  mov	al,#$80
29139 7EEE           8846         17            mov	$17[bp],al
29140                                           !BCC_EOS
29141                                           ! 4930           set_diskette_ret_status(0x80);
29142                                           ! Debug: list int = const $80 (used reg = )
29143 7EF1           B8                   0080  mov	ax,#$80
29144 7EF4           50                         push	ax
29145                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
29146 7EF5           E8         0749            call	_set_diskette_ret_status
29147 7EF8           44                         inc	sp
29148 7EF9           44                         inc	sp
29149                                           !BCC_EOS
29150                                           ! 4931           FLAGS |= 0x0001;
29151                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29152 7EFA           8B46         1C            mov	ax,$1C[bp]
29153 7EFD           0C                     01  or	al,*1
29154 7EFF           8946         1C            mov	$1C[bp],ax
29155                                           !BCC_EOS
29156                                           ! 4932           return;
29157 7F02           89EC                       mov	sp,bp
29158 7F04           5D                         pop	bp
29159 7F05           C3                         ret
29160                                           !BCC_EOS
29161                                           ! 4933         }
29162                                           ! 4934         val8 = (*((Bit8u *)(0x003e)) & 0x80);
29163                       00007F06            .6E3:
29164                                           ! Debug: and int = const $80 to unsigned char = [+$3E] (used reg = )
29165 7F06           A0         003E            mov	al,[$3E]
29166 7F09           24                     80  and	al,#$80
29167                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
29168 7F0B           8846         F1            mov	-$F[bp],al
29169                                           !BCC_EOS
29170                                           ! 4935       } while ( val8 == 0 );
29171                       00007F0E            .6E1:
29172                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
29173 7F0E           8A46         F1            mov	al,-$F[bp]
29174 7F11           84C0                       test	al,al
29175 7F13           74           C7            je 	.6E2
29176                       00007F15            .6E5:
29177                                           !BCC_EOS
29178                                           ! 4936       val8 = 0;
29179                       00007F15            .6E0:
29180                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
29181 7F15           30C0                       xor	al,al
29182 7F17           8846         F1            mov	-$F[bp],al
29183                                           !BCC_EOS
29184                                           ! 4937 #asm
29185                                           !BCC_EOS
29186                                           !BCC_ASM
29187                       0000002E            _int13_diskette_function.BP	set	$2E
29188                       0000000C            .int13_diskette_function.BP	set	$C
29189                       0000003C            _int13_diskette_function.CS	set	$3C
29190                       0000001A            .int13_diskette_function.CS	set	$1A
29191                       00000036            _int13_diskette_function.CX	set	$36
29192                       00000014            .int13_diskette_function.CX	set	$14
29193                       0000001A            _int13_diskette_function.base_address	set	$1A
29194                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
29195                       0000002A            _int13_diskette_function.DI	set	$2A
29196                       00000008            .int13_diskette_function.DI	set	8
29197                       0000003E            _int13_diskette_function.FLAGS	set	$3E
29198                       0000001C            .int13_diskette_function.FLAGS	set	$1C
29199                       00000018            _int13_diskette_function.base_count	set	$18
29200                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
29201                       0000001E            _int13_diskette_function.sector	set	$1E
29202                       FFFFFFFC            .int13_diskette_function.sector	set	-4
29203                       00000026            _int13_diskette_function.DS	set	$26
29204                       00000004            .int13_diskette_function.DS	set	4
29205                       0000001D            _int13_diskette_function.head	set	$1D
29206                       FFFFFFFB            .int13_diskette_function.head	set	-5
29207                       00000030            _int13_diskette_function.ELDX	set	$30
29208                       0000000E            .int13_diskette_function.ELDX	set	$E
29209                       00000012            _int13_diskette_function.dor	set	$12
29210                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
29211                       00000034            _int13_diskette_function.DX	set	$34
29212                       00000012            .int13_diskette_function.DX	set	$12
29213                       0000000B            _int13_diskette_function.return_status	set	$B
29214                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
29215                       00000004            _int13_diskette_function.es	set	4
29216                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
29217                       00000014            _int13_diskette_function.mode_register	set	$14
29218                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
29219                       00000028            _int13_diskette_function.ES	set	$28
29220                       00000006            .int13_diskette_function.ES	set	6
29221                       00000016            _int13_diskette_function.base_es	set	$16
29222                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
29223                       0000001F            _int13_diskette_function.track	set	$1F
29224                       FFFFFFFD            .int13_diskette_function.track	set	-3
29225                       0000002C            _int13_diskette_function.SI	set	$2C
29226                       0000000A            .int13_diskette_function.SI	set	$A
29227                       0000000A            _int13_diskette_function.drive_type	set	$A
29228                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
29229                       00000020            _int13_diskette_function.num_sectors	set	$20
29230                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
29231                       0000003A            _int13_diskette_function.IP	set	$3A
29232                       00000018            .int13_diskette_function.IP	set	$18
29233                       00000007            _int13_diskette_function.spt	set	7
29234                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
29235                       0000001C            _int13_diskette_function.status	set	$1C
29236                       FFFFFFFA            .int13_diskette_function.status	set	-6
29237                       00000000            _int13_diskette_function.maxCyl	set	0
29238                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
29239                       00000038            _int13_diskette_function.AX	set	$38
29240                       00000016            .int13_diskette_function.AX	set	$16
29241                       00000013            _int13_diskette_function.val8	set	$13
29242                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
29243                       00000002            _int13_diskette_function.last_addr	set	2
29244                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
29245                       00000015            _int13_diskette_function.page	set	$15
29246                       FFFFFFF3            .int13_diskette_function.page	set	-$D
29247                       00000008            _int13_diskette_function.ah	set	8
29248                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
29249                       00000021            _int13_diskette_function.drive	set	$21
29250                       FFFFFFFF            .int13_diskette_function.drive	set	-1
29251                       00000009            _int13_diskette_function.num_floppies	set	9
29252                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
29253                       00000032            _int13_diskette_function.BX	set	$32
29254                       00000010            .int13_diskette_function.BX	set	$10
29255 7F1A           FA                               cli
29256                                           ! 4939 endasm
29257                                           !BCC_ENDASM
29258                                           !BCC_EOS
29259                                           ! 4940       val8 = *((Bit8u *)(0x003e));
29260                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+$24-$11] (used reg = )
29261 7F1B           A0         003E            mov	al,[$3E]
29262 7F1E           8846         F1            mov	-$F[bp],al
29263                                           !BCC_EOS
29264                                           ! 4941       val8 &= 0x7f;
29265                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$24-$11] (used reg = )
29266 7F21           8A46         F1            mov	al,-$F[bp]
29267 7F24           24                     7F  and	al,*$7F
29268 7F26           8846         F1            mov	-$F[bp],al
29269                                           !BCC_EOS
29270                                           ! 4942       *((Bit8u *)(0x003e)) = (val8);
29271                                           ! Debug: eq unsigned char val8 = [S+$24-$11] to unsigned char = [+$3E] (used reg = )
29272 7F29           8A46         F1            mov	al,-$F[bp]
29273 7F2C           A2         003E            mov	[$3E],al
29274                                           !BCC_EOS
29275                                           ! 4943       val8 = inb(0x03f4);
29276                                           ! Debug: list int = const $3F4 (used reg = )
29277 7F2F           B8                   03F4  mov	ax,#$3F4
29278 7F32           50                         push	ax
29279                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29280 7F33           E8         85C2            call	_inb
29281 7F36           44                         inc	sp
29282 7F37           44                         inc	sp
29283                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
29284 7F38           8846         F1            mov	-$F[bp],al
29285                                           !BCC_EOS
29286                                           ! 4944       if ( (val8 & 0xc0) != 0xc0 )
29287                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$24-$11] (used reg = )
29288 7F3B           8A46         F1            mov	al,-$F[bp]
29289 7F3E           24                     C0  and	al,#$C0
29290                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
29291 7F40           3C                     C0  cmp	al,#$C0
29292 7F42           74           0E            je  	.6E6
29293                       00007F44            .6E7:
29294                                           ! 4945         bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
29295                                           ! Debug: list * char = .6E8+0 (used reg = )
29296 7F44           BB                   CDB8  mov	bx,#.6E8
29297 7F47           53                         push	bx
29298                                           ! Debug: list int = const 7 (used reg = )
29299 7F48           B8                   0007  mov	ax,*7
29300 7F4B           50                         push	ax
29301                                           ! Debug: func () void = bios_printf+0 (used reg = )
29302 7F4C           E8         89EF            call	_bios_printf
29303 7F4F           83C4                   04  add	sp,*4
29304                                           !BCC_EOS
29305                                           ! 4946       return_status[0] = inb(0x03f5);
29306                       00007F52            .6E6:
29307                                           ! Debug: list int = const $3F5 (used reg = )
29308 7F52           B8                   03F5  mov	ax,#$3F5
29309 7F55           50                         push	ax
29310                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29311 7F56           E8         859F            call	_inb
29312 7F59           44                         inc	sp
29313 7F5A           44                         inc	sp
29314                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$19] (used reg = )
29315 7F5B           8846         E9            mov	-$17[bp],al
29316                                           !BCC_EOS
29317                                           ! 4947       return_status[1] = inb(0x03f5);
29318                                           ! Debug: list int = const $3F5 (used reg = )
29319 7F5E           B8                   03F5  mov	ax,#$3F5
29320 7F61           50                         push	ax
29321                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29322 7F62           E8         8593            call	_inb
29323 7F65           44                         inc	sp
29324 7F66           44                         inc	sp
29325                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$18] (used reg = )
29326 7F67           8846         EA            mov	-$16[bp],al
29327                                           !BCC_EOS
29328                                           ! 4948       return_status[2] = inb(0x03f5);
29329                                           ! Debug: list int = const $3F5 (used reg = )
29330 7F6A           B8                   03F5  mov	ax,#$3F5
29331 7F6D           50                         push	ax
29332                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29333 7F6E           E8         8587            call	_inb
29334 7F71           44                         inc	sp
29335 7F72           44                         inc	sp
29336                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$17] (used reg = )
29337 7F73           8846         EB            mov	-$15[bp],al
29338                                           !BCC_EOS
29339                                           ! 4949       return_status[3] = inb(0x03f5);
29340                                           ! Debug: list int = const $3F5 (used reg = )
29341 7F76           B8                   03F5  mov	ax,#$3F5
29342 7F79           50                         push	ax
29343                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29344 7F7A           E8         857B            call	_inb
29345 7F7D           44                         inc	sp
29346 7F7E           44                         inc	sp
29347                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$16] (used reg = )
29348 7F7F           8846         EC            mov	-$14[bp],al
29349                                           !BCC_EOS
29350                                           ! 4950       return_status[4] = inb(0x03f5);
29351                                           ! Debug: list int = const $3F5 (used reg = )
29352 7F82           B8                   03F5  mov	ax,#$3F5
29353 7F85           50                         push	ax
29354                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29355 7F86           E8         856F            call	_inb
29356 7F89           44                         inc	sp
29357 7F8A           44                         inc	sp
29358                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$15] (used reg = )
29359 7F8B           8846         ED            mov	-$13[bp],al
29360                                           !BCC_EOS
29361                                           ! 4951       return_status[5] = inb(0x03f5);
29362                                           ! Debug: list int = const $3F5 (used reg = )
29363 7F8E           B8                   03F5  mov	ax,#$3F5
29364 7F91           50                         push	ax
29365                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29366 7F92           E8         8563            call	_inb
29367 7F95           44                         inc	sp
29368 7F96           44                         inc	sp
29369                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$14] (used reg = )
29370 7F97           8846         EE            mov	-$12[bp],al
29371                                           !BCC_EOS
29372                                           ! 4952       return_status[6] = inb(0x03f5);
29373                                           ! Debug: list int = const $3F5 (used reg = )
29374 7F9A           B8                   03F5  mov	ax,#$3F5
29375 7F9D           50                         push	ax
29376                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29377 7F9E           E8         8557            call	_inb
29378 7FA1           44                         inc	sp
29379 7FA2           44                         inc	sp
29380                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$13] (used reg = )
29381 7FA3           8846         EF            mov	-$11[bp],al
29382                                           !BCC_EOS
29383                                           ! 4953       _memcpyb(0x0042,0x0040,return_status,get_SS(),
29384                                           ! 4953 7);
29385                                           ! Debug: list int = const 7 (used reg = )
29386 7FA6           B8                   0007  mov	ax,*7
29387 7FA9           50                         push	ax
29388                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
29389 7FAA           E8         86B2            call	_get_SS
29390                                           ! Debug: list unsigned short = ax+0 (used reg = )
29391 7FAD           50                         push	ax
29392                                           ! Debug: list * unsigned char return_status = S+$28-$19 (used reg = )
29393 7FAE           8D5E         E9            lea	bx,-$17[bp]
29394 7FB1           53                         push	bx
29395                                           ! Debug: list int = const $40 (used reg = )
29396 7FB2           B8                   0040  mov	ax,*$40
29397 7FB5           50                         push	ax
29398                                           ! Debug: list int = const $42 (used reg = )
29399 7FB6           B8                   0042  mov	ax,*$42
29400 7FB9           50                         push	ax
29401                                           ! Debug: func () void = _memcpyb+0 (used reg = )
29402 7FBA           E8         805E            call	__memcpyb
29403 7FBD           83C4                   0A  add	sp,*$A
29404                                           !BCC_EOS
29405                                           ! 4954       if ( (return_status[0] & 0xc0) != 0 ) {
29406                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$24-$19] (used reg = )
29407 7FC0           8A46         E9            mov	al,-$17[bp]
29408 7FC3           24                     C0  and	al,#$C0
29409                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
29410 7FC5           84C0                       test	al,al
29411 7FC7           74           2B            je  	.6E9
29412                       00007FC9            .6EA:
29413                                           ! 4955         if ( (return_status[1] & 0x02) != 0 ) {
29414                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$24-$18] (used reg = )
29415 7FC9           8A46         EA            mov	al,-$16[bp]
29416 7FCC           24                     02  and	al,*2
29417                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
29418 7FCE           84C0                       test	al,al
29419 7FD0           74           14            je  	.6EB
29420                       00007FD2            .6EC:
29421                                           ! 4956           AX = 0x0300;
29422                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$24+$14] (used reg = )
29423 7FD2           B8                   0300  mov	ax,#$300
29424 7FD5           8946         16            mov	$16[bp],ax
29425                                           !BCC_EOS
29426                                           ! 4957           FLAGS |= 0x0001;
29427                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29428 7FD8           8B46         1C            mov	ax,$1C[bp]
29429 7FDB           0C                     01  or	al,*1
29430 7FDD           8946         1C            mov	$1C[bp],ax
29431                                           !BCC_EOS
29432                                           ! 4958           return;
29433 7FE0           89EC                       mov	sp,bp
29434 7FE2           5D                         pop	bp
29435 7FE3           C3                         ret
29436                                           !BCC_EOS
29437                                           ! 4959         } else {
29438 7FE4           EB           0E            jmp .6ED
29439                       00007FE6            .6EB:
29440                                           ! 4960           bios_printf((2 | 4 | 1), "int13_diskette_function: write error\n");
29441                                           ! Debug: list * char = .6EE+0 (used reg = )
29442 7FE6           BB                   CD92  mov	bx,#.6EE
29443 7FE9           53                         push	bx
29444                                           ! Debug: list int = const 7 (used reg = )
29445 7FEA           B8                   0007  mov	ax,*7
29446 7FED           50                         push	ax
29447                                           ! Debug: func () void = bios_printf+0 (used reg = )
29448 7FEE           E8         894D            call	_bios_printf
29449 7FF1           83C4                   04  add	sp,*4
29450                                           !BCC_EOS
29451                                           ! 4961         }
29452                                           ! 4962       }
29453                       00007FF4            .6ED:
29454                                           ! 4963       *(((Bit8u *)&AX)+1) = (0);
29455                       00007FF4            .6E9:
29456                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
29457 7FF4           30C0                       xor	al,al
29458 7FF6           8846         17            mov	$17[bp],al
29459                                           !BCC_EOS
29460                                           ! 4964       set_diskette_ret_status(0);
29461                                           ! Debug: list int = const 0 (used reg = )
29462 7FF9           31C0                       xor	ax,ax
29463 7FFB           50                         push	ax
29464                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
29465 7FFC           E8         0642            call	_set_diskette_ret_status
29466 7FFF           44                         inc	sp
29467 8000           44                         inc	sp
29468                                           !BCC_EOS
29469                                           ! 4965       set_diskette_current_cyl(drive, 0);
29470                                           ! Debug: list int = const 0 (used reg = )
29471 8001           31C0                       xor	ax,ax
29472 8003           50                         push	ax
29473                                           ! Debug: list unsigned char drive = [S+$26-3] (used reg = )
29474 8004           8A46         FF            mov	al,-1[bp]
29475 8007           30E4                       xor	ah,ah
29476 8009           50                         push	ax
29477                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
29478 800A           E8         064C            call	_set_diskette_current_cyl
29479 800D           83C4                   04  add	sp,*4
29480                                           !BCC_EOS
29481                                           ! 4966       FLAGS &= 0xfffe;
29482                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29483 8010           8B46         1C            mov	ax,$1C[bp]
29484 8013           24                     FE  and	al,#$FE
29485 8015           8946         1C            mov	$1C[bp],ax
29486                                           !BCC_EOS
29487                                           ! 4967       return;
29488 8018           89EC                       mov	sp,bp
29489 801A           5D                         pop	bp
29490 801B           C3                         ret
29491                                           !BCC_EOS
29492                                           ! 4968     case 0x08:
29493                                           ! 4969 ;
29494                       0000801C            .6EF:
29495                                           !BCC_EOS
29496                                           ! 4970       drive = ( ELDX & 0x00ff );
29497                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
29498 801C           8A46         0E            mov	al,$E[bp]
29499                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
29500 801F           8846         FF            mov	-1[bp],al
29501                                           !BCC_EOS
29502                                           ! 4971       if (drive > 1) {
29503                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
29504 8022           8A46         FF            mov	al,-1[bp]
29505 8025           3C                     01  cmp	al,*1
29506 8027           76           30            jbe 	.6F0
29507                       00008029            .6F1:
29508                                           ! 4972         AX = 0;
29509                                           ! Debug: eq int = const 0 to unsigned short AX = [S+$24+$14] (used reg = )
29510 8029           31C0                       xor	ax,ax
29511 802B           8946         16            mov	$16[bp],ax
29512                                           !BCC_EOS
29513                                           ! 4973         BX = 0;
29514                                           ! Debug: eq int = const 0 to unsigned short BX = [S+$24+$E] (used reg = )
29515 802E           31C0                       xor	ax,ax
29516 8030           8946         10            mov	$10[bp],ax
29517                                           !BCC_EOS
29518                                           ! 4974         CX = 0;
29519                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$24+$12] (used reg = )
29520 8033           31C0                       xor	ax,ax
29521 8035           8946         14            mov	$14[bp],ax
29522                                           !BCC_EOS
29523                                           ! 4975         DX = 0;
29524                                           ! Debug: eq int = const 0 to unsigned short DX = [S+$24+$10] (used reg = )
29525 8038           31C0                       xor	ax,ax
29526 803A           8946         12            mov	$12[bp],ax
29527                                           !BCC_EOS
29528                                           ! 4976         ES = 0;
29529                                           ! Debug: eq int = const 0 to unsigned short ES = [S+$24+4] (used reg = )
29530 803D           31C0                       xor	ax,ax
29531 803F           8946         06            mov	6[bp],ax
29532                                           !BCC_EOS
29533                                           ! 4977         DI = 0;
29534                                           ! Debug: eq int = const 0 to unsigned short DI = [S+$24+6] (used reg = )
29535 8042           31C0                       xor	ax,ax
29536 8044           8946         08            mov	8[bp],ax
29537                                           !BCC_EOS
29538                                           ! 4978         *((Bit8u *)&DX) = (num_floppies);
29539                                           ! Debug: eq unsigned char num_floppies = [S+$24-$1B] to unsigned char DX = [S+$24+$10] (used reg = )
29540 8047           8A46         E7            mov	al,-$19[bp]
29541 804A           8846         12            mov	$12[bp],al
29542                                           !BCC_EOS
29543                                           ! 4979         FLAGS |= 0x0001;
29544                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29545 804D           8B46         1C            mov	ax,$1C[bp]
29546 8050           0C                     01  or	al,*1
29547 8052           8946         1C            mov	$1C[bp],ax
29548                                           !BCC_EOS
29549                                           ! 4980         return;
29550 8055           89EC                       mov	sp,bp
29551 8057           5D                         pop	bp
29552 8058           C3                         ret
29553                                           !BCC_EOS
29554                                           ! 4981       }
29555                                           ! 4982       drive_type = inb_cmos(0x10);
29556                       00008059            .6F0:
29557                                           ! Debug: list int = const $10 (used reg = )
29558 8059           B8                   0010  mov	ax,*$10
29559 805C           50                         push	ax
29560                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
29561 805D           E8         84DD            call	_inb_cmos
29562 8060           44                         inc	sp
29563 8061           44                         inc	sp
29564                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29565 8062           8846         E8            mov	-$18[bp],al
29566                                           !BCC_EOS
29567                                           ! 4983       num_floppies = 0;
29568                                           ! Debug: eq int = const 0 to unsigned char num_floppies = [S+$24-$1B] (used reg = )
29569 8065           30C0                       xor	al,al
29570 8067           8846         E7            mov	-$19[bp],al
29571                                           !BCC_EOS
29572                                           ! 4984       if (drive_type & 0xf0)
29573                                           ! Debug: and int = const $F0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29574 806A           8A46         E8            mov	al,-$18[bp]
29575 806D           24                     F0  and	al,#$F0
29576 806F           84C0                       test	al,al
29577 8071           74           07            je  	.6F2
29578                       00008073            .6F3:
29579                                           ! 4985         num_floppies++;
29580                                           ! Debug: postinc unsigned char num_floppies = [S+$24-$1B] (used reg = )
29581 8073           8A46         E7            mov	al,-$19[bp]
29582 8076           40                         inc	ax
29583 8077           8846         E7            mov	-$19[bp],al
29584                                           !BCC_EOS
29585                                           ! 4986       if (drive_type & 0x0f)
29586                       0000807A            .6F2:
29587                                           ! Debug: and int = const $F to unsigned char drive_type = [S+$24-$1A] (used reg = )
29588 807A           8A46         E8            mov	al,-$18[bp]
29589 807D           24                     0F  and	al,*$F
29590 807F           84C0                       test	al,al
29591 8081           74           07            je  	.6F4
29592                       00008083            .6F5:
29593                                           ! 4987         num_floppies++;
29594                                           ! Debug: postinc unsigned char num_floppies = [S+$24-$1B] (used reg = )
29595 8083           8A46         E7            mov	al,-$19[bp]
29596 8086           40                         inc	ax
29597 8087           8846         E7            mov	-$19[bp],al
29598                                           !BCC_EOS
29599                                           ! 4988       if (drive == 0)
29600                       0000808A            .6F4:
29601                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$24-3] (used reg = )
29602 808A           8A46         FF            mov	al,-1[bp]
29603 808D           84C0                       test	al,al
29604 808F           75           0E            jne 	.6F6
29605                       00008091            .6F7:
29606                                           ! 4989         drive_type >>= 4;
29607                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29608 8091           8A46         E8            mov	al,-$18[bp]
29609 8094           30E4                       xor	ah,ah
29610 8096           B1                     04  mov	cl,*4
29611 8098           D3E8                       shr	ax,cl
29612 809A           8846         E8            mov	-$18[bp],al
29613                                           !BCC_EOS
29614                                           ! 4990       else
29615                                           ! 4991         drive_type &= 0x0f;
29616 809D           EB           08            jmp .6F8
29617                       0000809F            .6F6:
29618                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$24-$1A] (used reg = )
29619 809F           8A46         E8            mov	al,-$18[bp]
29620 80A2           24                     0F  and	al,*$F
29621 80A4           8846         E8            mov	-$18[bp],al
29622                                           !BCC_EOS
29623                                           ! 4992       *(((Bit8u *)&BX)+1) = (0);
29624                       000080A7            .6F8:
29625                                           ! Debug: eq int = const 0 to unsigned char BX = [S+$24+$F] (used reg = )
29626 80A7           30C0                       xor	al,al
29627 80A9           8846         11            mov	$11[bp],al
29628                                           !BCC_EOS
29629                                           ! 4993       *((Bit8u *)&BX) = (drive_type);
29630                                           ! Debug: eq unsigned char drive_type = [S+$24-$1A] to unsigned char BX = [S+$24+$E] (used reg = )
29631 80AC           8A46         E8            mov	al,-$18[bp]
29632 80AF           8846         10            mov	$10[bp],al
29633                                           !BCC_EOS
29634                                           ! 4994       *(((Bit8u *)&AX)+1) = (0);
29635                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
29636 80B2           30C0                       xor	al,al
29637 80B4           8846         17            mov	$17[bp],al
29638                                           !BCC_EOS
29639                                           ! 4995       *((Bit8u *)&AX) = (0);
29640                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
29641 80B7           30C0                       xor	al,al
29642 80B9           8846         16            mov	$16[bp],al
29643                                           !BCC_EOS
29644                                           ! 4996       *((Bit8u *)&DX) = (num_floppies);
29645                                           ! Debug: eq unsigned char num_floppies = [S+$24-$1B] to unsigned char DX = [S+$24+$10] (used reg = )
29646 80BC           8A46         E7            mov	al,-$19[bp]
29647 80BF           8846         12            mov	$12[bp],al
29648                                           !BCC_EOS
29649                                           ! 4997       switch (drive_type) {
29650 80C2           8A46         E8            mov	al,-$18[bp]
29651 80C5           E9         0087            br 	.6FB
29652                                           ! 4998         case 0:
29653                                           ! 4999           CX = 0;
29654                       000080C8            .6FC:
29655                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$24+$12] (used reg = )
29656 80C8           31C0                       xor	ax,ax
29657 80CA           8946         14            mov	$14[bp],ax
29658                                           !BCC_EOS
29659                                           ! 5000           *(((Bit8u *)&DX)+1) = (0);
29660                                           ! Debug: eq int = const 0 to unsigned char DX = [S+$24+$11] (used reg = )
29661 80CD           30C0                       xor	al,al
29662 80CF           8846         13            mov	$13[bp],al
29663                                           !BCC_EOS
29664                                           ! 5001           break;
29665 80D2           E9         00A1            br 	.6F9
29666                                           !BCC_EOS
29667                                           ! 5002         case 1:
29668                                           ! 5003           CX = 0x2709;
29669                       000080D5            .6FD:
29670                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$24+$12] (used reg = )
29671 80D5           B8                   2709  mov	ax,#$2709
29672 80D8           8946         14            mov	$14[bp],ax
29673                                           !BCC_EOS
29674                                           ! 5004           *(((Bit8u *)&DX)+1) = (1);
29675                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29676 80DB           B0                     01  mov	al,*1
29677 80DD           8846         13            mov	$13[bp],al
29678                                           !BCC_EOS
29679                                           ! 5005           break;
29680 80E0           E9         0093            br 	.6F9
29681                                           !BCC_EOS
29682                                           ! 5006         case 2:
29683                                           ! 5007           CX = 0x4f0f;
29684                       000080E3            .6FE:
29685                                           ! Debug: eq int = const $4F0F to unsigned short CX = [S+$24+$12] (used reg = )
29686 80E3           B8                   4F0F  mov	ax,#$4F0F
29687 80E6           8946         14            mov	$14[bp],ax
29688                                           !BCC_EOS
29689                                           ! 5008           *(((Bit8u *)&DX)+1) = (1);
29690                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29691 80E9           B0                     01  mov	al,*1
29692 80EB           8846         13            mov	$13[bp],al
29693                                           !BCC_EOS
29694                                           ! 5009           break;
29695 80EE           E9         0085            br 	.6F9
29696                                           !BCC_EOS
29697                                           ! 5010         case 3:
29698                                           ! 5011           CX = 0x4f09;
29699                       000080F1            .6FF:
29700                                           ! Debug: eq int = const $4F09 to unsigned short CX = [S+$24+$12] (used reg = )
29701 80F1           B8                   4F09  mov	ax,#$4F09
29702 80F4           8946         14            mov	$14[bp],ax
29703                                           !BCC_EOS
29704                                           ! 5012           *(((Bit8u *)&DX)+1) = (1);
29705                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29706 80F7           B0                     01  mov	al,*1
29707 80F9           8846         13            mov	$13[bp],al
29708                                           !BCC_EOS
29709                                           ! 5013           break;
29710 80FC           EB           78            jmp .6F9
29711                                           !BCC_EOS
29712                                           ! 5014         case 4:
29713                                           ! 5015           CX = 0x4f12;
29714                       000080FE            .700:
29715                                           ! Debug: eq int = const $4F12 to unsigned short CX = [S+$24+$12] (used reg = )
29716 80FE           B8                   4F12  mov	ax,#$4F12
29717 8101           8946         14            mov	$14[bp],ax
29718                                           !BCC_EOS
29719                                           ! 5016           *(((Bit8u *)&DX)+1) = (1);
29720                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29721 8104           B0                     01  mov	al,*1
29722 8106           8846         13            mov	$13[bp],al
29723                                           !BCC_EOS
29724                                           ! 5017           break;
29725 8109           EB           6B            jmp .6F9
29726                                           !BCC_EOS
29727                                           ! 5018         case 5:
29728                                           ! 5019           CX = 0x4f24;
29729                       0000810B            .701:
29730                                           ! Debug: eq int = const $4F24 to unsigned short CX = [S+$24+$12] (used reg = )
29731 810B           B8                   4F24  mov	ax,#$4F24
29732 810E           8946         14            mov	$14[bp],ax
29733                                           !BCC_EOS
29734                                           ! 5020           *(((Bit8u *)&DX)+1) = (1);
29735                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29736 8111           B0                     01  mov	al,*1
29737 8113           8846         13            mov	$13[bp],al
29738                                           !BCC_EOS
29739                                           ! 5021           break;
29740 8116           EB           5E            jmp .6F9
29741                                           !BCC_EOS
29742                                           ! 5022         case 6:
29743                                           ! 5023           CX = 0x2708;
29744                       00008118            .702:
29745                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$24+$12] (used reg = )
29746 8118           B8                   2708  mov	ax,#$2708
29747 811B           8946         14            mov	$14[bp],ax
29748                                           !BCC_EOS
29749                                           ! 5024           *(((Bit8u *)&DX)+1) = (0);
29750                                           ! Debug: eq int = const 0 to unsigned char DX = [S+$24+$11] (used reg = )
29751 811E           30C0                       xor	al,al
29752 8120           8846         13            mov	$13[bp],al
29753                                           !BCC_EOS
29754                                           ! 5025           break;
29755 8123           EB           51            jmp .6F9
29756                                           !BCC_EOS
29757                                           ! 5026         case 7:
29758                                           ! 5027           CX = 0x2709;
29759                       00008125            .703:
29760                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$24+$12] (used reg = )
29761 8125           B8                   2709  mov	ax,#$2709
29762 8128           8946         14            mov	$14[bp],ax
29763                                           !BCC_EOS
29764                                           ! 5028           *(((Bit8u *)&DX)+1) = (0);
29765                                           ! Debug: eq int = const 0 to unsigned char DX = [S+$24+$11] (used reg = )
29766 812B           30C0                       xor	al,al
29767 812D           8846         13            mov	$13[bp],al
29768                                           !BCC_EOS
29769                                           ! 5029           break;
29770 8130           EB           44            jmp .6F9
29771                                           !BCC_EOS
29772                                           ! 5030         case 8:
29773                                           ! 5031           CX = 0x2708;
29774                       00008132            .704:
29775                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$24+$12] (used reg = )
29776 8132           B8                   2708  mov	ax,#$2708
29777 8135           8946         14            mov	$14[bp],ax
29778                                           !BCC_EOS
29779                                           ! 5032           *(((Bit8u *)&DX)+1) = (1);
29780                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29781 8138           B0                     01  mov	al,*1
29782 813A           8846         13            mov	$13[bp],al
29783                                           !BCC_EOS
29784                                           ! 5033           break;
29785 813D           EB           37            jmp .6F9
29786                                           !BCC_EOS
29787                                           ! 5034         default:
29788                                           ! 5035           bios_printf((2 | 4 | 1), "floppy: int13: bad floppy
29789                       0000813F            .705:
29790                                           ! 5035  type\n");
29791                                           ! Debug: list * char = .706+0 (used reg = )
29792 813F           BB                   CD72  mov	bx,#.706
29793 8142           53                         push	bx
29794                                           ! Debug: list int = const 7 (used reg = )
29795 8143           B8                   0007  mov	ax,*7
29796 8146           50                         push	ax
29797                                           ! Debug: func () void = bios_printf+0 (used reg = )
29798 8147           E8         87F4            call	_bios_printf
29799 814A           83C4                   04  add	sp,*4
29800                                           !BCC_EOS
29801                                           ! 5036         }
29802                                           ! 5037 #asm
29803 814D           EB           27            jmp .6F9
29804                       0000814F            .6FB:
29805 814F           2C                     00  sub	al,*0
29806 8151           72           EC            jb 	.705
29807 8153           3C                     08  cmp	al,*8
29808 8155           77           1D            ja  	.707
29809 8157           30E4                       xor	ah,ah
29810 8159           D1E0                       shl	ax,*1
29811 815B           89C3                       mov	bx,ax
29812 815D           2E                         seg	cs
29813 815E           FFA7       8162            br	.708[bx]
29814                       00008162            .708:
29815 8162                      80C8            .word	.6FC
29816 8164                      80D5            .word	.6FD
29817 8166                      80E3            .word	.6FE
29818 8168                      80F1            .word	.6FF
29819 816A                      80FE            .word	.700
29820 816C                      810B            .word	.701
29821 816E                      8118            .word	.702
29822 8170                      8125            .word	.703
29823 8172                      8132            .word	.704
29824                       00008174            .707:
29825 8174           EB           C9            jmp	.705
29826                       00008176            .6F9:
29827                                           !BCC_EOS
29828                                           !BCC_ASM
29829                       0000002E            _int13_diskette_function.BP	set	$2E
29830                       0000000C            .int13_diskette_function.BP	set	$C
29831                       0000003C            _int13_diskette_function.CS	set	$3C
29832                       0000001A            .int13_diskette_function.CS	set	$1A
29833                       00000036            _int13_diskette_function.CX	set	$36
29834                       00000014            .int13_diskette_function.CX	set	$14
29835                       0000001A            _int13_diskette_function.base_address	set	$1A
29836                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
29837                       0000002A            _int13_diskette_function.DI	set	$2A
29838                       00000008            .int13_diskette_function.DI	set	8
29839                       0000003E            _int13_diskette_function.FLAGS	set	$3E
29840                       0000001C            .int13_diskette_function.FLAGS	set	$1C
29841                       00000018            _int13_diskette_function.base_count	set	$18
29842                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
29843                       0000001E            _int13_diskette_function.sector	set	$1E
29844                       FFFFFFFC            .int13_diskette_function.sector	set	-4
29845                       00000026            _int13_diskette_function.DS	set	$26
29846                       00000004            .int13_diskette_function.DS	set	4
29847                       0000001D            _int13_diskette_function.head	set	$1D
29848                       FFFFFFFB            .int13_diskette_function.head	set	-5
29849                       00000030            _int13_diskette_function.ELDX	set	$30
29850                       0000000E            .int13_diskette_function.ELDX	set	$E
29851                       00000012            _int13_diskette_function.dor	set	$12
29852                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
29853                       00000034            _int13_diskette_function.DX	set	$34
29854                       00000012            .int13_diskette_function.DX	set	$12
29855                       0000000B            _int13_diskette_function.return_status	set	$B
29856                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
29857                       00000004            _int13_diskette_function.es	set	4
29858                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
29859                       00000014            _int13_diskette_function.mode_register	set	$14
29860                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
29861                       00000028            _int13_diskette_function.ES	set	$28
29862                       00000006            .int13_diskette_function.ES	set	6
29863                       00000016            _int13_diskette_function.base_es	set	$16
29864                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
29865                       0000001F            _int13_diskette_function.track	set	$1F
29866                       FFFFFFFD            .int13_diskette_function.track	set	-3
29867                       0000002C            _int13_diskette_function.SI	set	$2C
29868                       0000000A            .int13_diskette_function.SI	set	$A
29869                       0000000A            _int13_diskette_function.drive_type	set	$A
29870                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
29871                       00000020            _int13_diskette_function.num_sectors	set	$20
29872                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
29873                       0000003A            _int13_diskette_function.IP	set	$3A
29874                       00000018            .int13_diskette_function.IP	set	$18
29875                       00000007            _int13_diskette_function.spt	set	7
29876                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
29877                       0000001C            _int13_diskette_function.status	set	$1C
29878                       FFFFFFFA            .int13_diskette_function.status	set	-6
29879                       00000000            _int13_diskette_function.maxCyl	set	0
29880                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
29881                       00000038            _int13_diskette_function.AX	set	$38
29882                       00000016            .int13_diskette_function.AX	set	$16
29883                       00000013            _int13_diskette_function.val8	set	$13
29884                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
29885                       00000002            _int13_diskette_function.last_addr	set	2
29886                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
29887                       00000015            _int13_diskette_function.page	set	$15
29888                       FFFFFFF3            .int13_diskette_function.page	set	-$D
29889                       00000008            _int13_diskette_function.ah	set	8
29890                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
29891                       00000021            _int13_diskette_function.drive	set	$21
29892                       FFFFFFFF            .int13_diskette_function.drive	set	-1
29893                       00000009            _int13_diskette_function.num_floppies	set	9
29894                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
29895                       00000032            _int13_diskette_function.BX	set	$32
29896                       00000010            .int13_diskette_function.BX	set	$10
29897 8176           55                               push bp
29898 8177           89E5                             mov bp, sp
29899 8179           B8                   EFDE        mov ax, #diskette_param_table2
29900 817C           8946         2C                  mov _int13_diskette_function.DI+2[bp], ax
29901 817F           8C4E         2A                  mov _int13_diskette_function.ES+2[bp], cs
29902 8182           5D                               pop bp
29903                                           ! 5044 endasm
29904                                           !BCC_ENDASM
29905                                           !BCC_EOS
29906                                           ! 5045       FLAGS &= 0xfffe;
29907                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29908 8183           8B46         1C            mov	ax,$1C[bp]
29909 8186           24                     FE  and	al,#$FE
29910 8188           8946         1C            mov	$1C[bp],ax
29911                                           !BCC_EOS
29912                                           ! 5046       return;
29913 818B           89EC                       mov	sp,bp
29914 818D           5D                         pop	bp
29915 818E           C3                         ret
29916                                           !BCC_EOS
29917                                           ! 5047     case 0x15:
29918                                           ! 5048 ;
29919                       0000818F            .709:
29920                                           !BCC_EOS
29921                                           ! 5049       drive = ( ELDX & 0x00ff );
29922                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
29923 818F           8A46         0E            mov	al,$E[bp]
29924                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
29925 8192           8846         FF            mov	-1[bp],al
29926                                           !BCC_EOS
29927                                           ! 5050       if (drive > 1) {
29928                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
29929 8195           8A46         FF            mov	al,-1[bp]
29930 8198           3C                     01  cmp	al,*1
29931 819A           76           11            jbe 	.70A
29932                       0000819C            .70B:
29933                                           ! 5051         *(((Bit8u *)&AX)+1) = (0);
29934                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
29935 819C           30C0                       xor	al,al
29936 819E           8846         17            mov	$17[bp],al
29937                                           !BCC_EOS
29938                                           ! 5052         FLAGS |= 0x0001;
29939                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29940 81A1           8B46         1C            mov	ax,$1C[bp]
29941 81A4           0C                     01  or	al,*1
29942 81A6           8946         1C            mov	$1C[bp],ax
29943                                           !BCC_EOS
29944                                           ! 5053         return;
29945 81A9           89EC                       mov	sp,bp
29946 81AB           5D                         pop	bp
29947 81AC           C3                         ret
29948                                           !BCC_EOS
29949                                           ! 5054       }
29950                                           ! 5055       drive_type = inb_cmos(0x10);
29951                       000081AD            .70A:
29952                                           ! Debug: list int = const $10 (used reg = )
29953 81AD           B8                   0010  mov	ax,*$10
29954 81B0           50                         push	ax
29955                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
29956 81B1           E8         8389            call	_inb_cmos
29957 81B4           44                         inc	sp
29958 81B5           44                         inc	sp
29959                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29960 81B6           8846         E8            mov	-$18[bp],al
29961                                           !BCC_EOS
29962                                           ! 5056       if (drive == 0)
29963                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$24-3] (used reg = )
29964 81B9           8A46         FF            mov	al,-1[bp]
29965 81BC           84C0                       test	al,al
29966 81BE           75           0E            jne 	.70C
29967                       000081C0            .70D:
29968                                           ! 5057         drive_type >>= 4;
29969                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29970 81C0           8A46         E8            mov	al,-$18[bp]
29971 81C3           30E4                       xor	ah,ah
29972 81C5           B1                     04  mov	cl,*4
29973 81C7           D3E8                       shr	ax,cl
29974 81C9           8846         E8            mov	-$18[bp],al
29975                                           !BCC_EOS
29976                                           ! 5058       else
29977                                           ! 5059         drive_type &= 0x0f;
29978 81CC           EB           08            jmp .70E
29979                       000081CE            .70C:
29980                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$24-$1A] (used reg = )
29981 81CE           8A46         E8            mov	al,-$18[bp]
29982 81D1           24                     0F  and	al,*$F
29983 81D3           8846         E8            mov	-$18[bp],al
29984                                           !BCC_EOS
29985                                           ! 5060       FLAGS &= 0xfffe;
29986                       000081D6            .70E:
29987                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29988 81D6           8B46         1C            mov	ax,$1C[bp]
29989 81D9           24                     FE  and	al,#$FE
29990 81DB           8946         1C            mov	$1C[bp],ax
29991                                           !BCC_EOS
29992                                           ! 5061       if (drive_type==0) {
29993                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29994 81DE           8A46         E8            mov	al,-$18[bp]
29995 81E1           84C0                       test	al,al
29996 81E3           75           07            jne 	.70F
29997                       000081E5            .710:
29998                                           ! 5062         *(((Bit8u *)&AX)+1) = (0);
29999                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30000 81E5           30C0                       xor	al,al
30001 81E7           8846         17            mov	$17[bp],al
30002                                           !BCC_EOS
30003                                           ! 5063       }
30004                                           ! 5064       else {
30005 81EA           EB           05            jmp .711
30006                       000081EC            .70F:
30007                                           ! 5065         *(((Bit8u *)&AX)+1) = (1);
30008                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
30009 81EC           B0                     01  mov	al,*1
30010 81EE           8846         17            mov	$17[bp],al
30011                                           !BCC_EOS
30012                                           ! 5066       }
30013                                           ! 5067       return;
30014                       000081F1            .711:
30015 81F1           89EC                       mov	sp,bp
30016 81F3           5D                         pop	bp
30017 81F4           C3                         ret
30018                                           !BCC_EOS
30019                                           ! 5068     case 0x16:
30020                                           ! 5069 ;
30021                       000081F5            .712:
30022                                           !BCC_EOS
30023                                           ! 5070       drive = ( ELDX & 0x00ff );
30024                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
30025 81F5           8A46         0E            mov	al,$E[bp]
30026                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
30027 81F8           8846         FF            mov	-1[bp],al
30028                                           !BCC_EOS
30029                                           ! 5071       if (drive > 1) {
30030                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
30031 81FB           8A46         FF            mov	al,-1[bp]
30032 81FE           3C                     01  cmp	al,*1
30033 8200           76           1A            jbe 	.713
30034                       00008202            .714:
30035                                           ! 5072         *(((Bit8u *)&AX)+1) = (0x01);
30036                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
30037 8202           B0                     01  mov	al,*1
30038 8204           8846         17            mov	$17[bp],al
30039                                           !BCC_EOS
30040                                           ! 5073         set_diskette_ret_status(0x01);
30041                                           ! Debug: list int = const 1 (used reg = )
30042 8207           B8                   0001  mov	ax,*1
30043 820A           50                         push	ax
30044                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30045 820B           E8         0433            call	_set_diskette_ret_status
30046 820E           44                         inc	sp
30047 820F           44                         inc	sp
30048                                           !BCC_EOS
30049                                           ! 5074         FLAGS |= 0x0001;
30050                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30051 8210           8B46         1C            mov	ax,$1C[bp]
30052 8213           0C                     01  or	al,*1
30053 8215           8946         1C            mov	$1C[bp],ax
30054                                           !BCC_EOS
30055                                           ! 5075         return;
30056 8218           89EC                       mov	sp,bp
30057 821A           5D                         pop	bp
30058 821B           C3                         ret
30059                                           !BCC_EOS
30060                                           ! 5076       }
30061                                           ! 5077       *(((Bit8u *)&AX)+1) = (0x06);
30062                       0000821C            .713:
30063                                           ! Debug: eq int = const 6 to unsigned char AX = [S+$24+$15] (used reg = )
30064 821C           B0                     06  mov	al,*6
30065 821E           8846         17            mov	$17[bp],al
30066                                           !BCC_EOS
30067                                           ! 5078       set_diskette_ret_status(0x06);
30068                                           ! Debug: list int = const 6 (used reg = )
30069 8221           B8                   0006  mov	ax,*6
30070 8224           50                         push	ax
30071                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30072 8225           E8         0419            call	_set_diskette_ret_status
30073 8228           44                         inc	sp
30074 8229           44                         inc	sp
30075                                           !BCC_EOS
30076                                           ! 5079       FLAGS |= 0x0001;
30077                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30078 822A           8B46         1C            mov	ax,$1C[bp]
30079 822D           0C                     01  or	al,*1
30080 822F           8946         1C            mov	$1C[bp],ax
30081                                           !BCC_EOS
30082                                           ! 5080       return;
30083 8232           89EC                       mov	sp,bp
30084 8234           5D                         pop	bp
30085 8235           C3                         ret
30086                                           !BCC_EOS
30087                                           ! 5081     case 0x17:
30088                                           ! 5082 ;
30089                       00008236            .715:
30090                                           !BCC_EOS
30091                                           ! 5083       drive = ( ELDX & 0x00ff );
30092                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
30093 8236           8A46         0E            mov	al,$E[bp]
30094                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
30095 8239           8846         FF            mov	-1[bp],al
30096                                           !BCC_EOS
30097                                           ! 5084       drive_type = ( AX & 0x00ff );
30098                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
30099 823C           8A46         16            mov	al,$16[bp]
30100                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
30101 823F           8846         E8            mov	-$18[bp],al
30102                                           !BCC_EOS
30103                                           ! 5085       if (drive > 1) {
30104                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
30105 8242           8A46         FF            mov	al,-1[bp]
30106 8245           3C                     01  cmp	al,*1
30107 8247           76           1A            jbe 	.716
30108                       00008249            .717:
30109                                           ! 5086         *(((Bit8u *)&AX)+1) = (0x01);
30110                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
30111 8249           B0                     01  mov	al,*1
30112 824B           8846         17            mov	$17[bp],al
30113                                           !BCC_EOS
30114                                           ! 5087         set_diskette_ret_status(1);
30115                                           ! Debug: list int = const 1 (used reg = )
30116 824E           B8                   0001  mov	ax,*1
30117 8251           50                         push	ax
30118                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30119 8252           E8         03EC            call	_set_diskette_ret_status
30120 8255           44                         inc	sp
30121 8256           44                         inc	sp
30122                                           !BCC_EOS
30123                                           ! 5088         FLAGS |= 0x0001;
30124                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30125 8257           8B46         1C            mov	ax,$1C[bp]
30126 825A           0C                     01  or	al,*1
30127 825C           8946         1C            mov	$1C[bp],ax
30128                                           !BCC_EOS
30129                                           ! 5089         return;
30130 825F           89EC                       mov	sp,bp
30131 8261           5D                         pop	bp
30132 8262           C3                         ret
30133                                           !BCC_EOS
30134                                           ! 5090       }
30135                                           ! 5091       if (floppy_drive_exists(drive) == 0) {
30136                       00008263            .716:
30137                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
30138 8263           8A46         FF            mov	al,-1[bp]
30139 8266           30E4                       xor	ah,ah
30140 8268           50                         push	ax
30141                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
30142 8269           E8         F4DF            call	_floppy_drive_exists
30143 826C           44                         inc	sp
30144 826D           44                         inc	sp
30145                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
30146 826E           85C0                       test	ax,ax
30147 8270           75           1A            jne 	.718
30148                       00008272            .719:
30149                                           ! 5092         *(((Bit8u *)&AX)+1) = (0x80);
30150                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
30151 8272           B0                     80  mov	al,#$80
30152 8274           8846         17            mov	$17[bp],al
30153                                           !BCC_EOS
30154                                           ! 5093         set_diskette_ret_status(0x80);
30155                                           ! Debug: list int = const $80 (used reg = )
30156 8277           B8                   0080  mov	ax,#$80
30157 827A           50                         push	ax
30158                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30159 827B           E8         03C3            call	_set_diskette_ret_status
30160 827E           44                         inc	sp
30161 827F           44                         inc	sp
30162                                           !BCC_EOS
30163                                           ! 5094         FLAGS |= 0x0001;
30164                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30165 8280           8B46         1C            mov	ax,$1C[bp]
30166 8283           0C                     01  or	al,*1
30167 8285           8946         1C            mov	$1C[bp],ax
30168                                           !BCC_EOS
30169                                           ! 5095         return;
30170 8288           89EC                       mov	sp,bp
30171 828A           5D                         pop	bp
30172 828B           C3                         ret
30173                                           !BCC_EOS
30174                                           ! 5096       }
30175                                           ! 5097       base_address = (drive) ? 0x0091 : 0x0090;
30176                       0000828C            .718:
30177 828C           8A46         FF            mov	al,-1[bp]
30178 828F           84C0                       test	al,al
30179 8291           74           04            je  	.71A
30180                       00008293            .71B:
30181 8293           B0                     91  mov	al,#$91
30182 8295           EB           02            jmp .71C
30183                       00008297            .71A:
30184 8297           B0                     90  mov	al,#$90
30185                       00008299            .71C:
30186                                           ! Debug: eq char = al+0 to unsigned short base_address = [S+$24-$A] (used reg = )
30187 8299           30E4                       xor	ah,ah
30188 829B           8946         F8            mov	-8[bp],ax
30189                                           !BCC_EOS
30190                                           ! 5098       status = *((Bit8u *)(base_address));
30191 829E           8B5E         F8            mov	bx,-8[bp]
30192                                           ! Debug: eq unsigned char = [bx+0] to unsigned char status = [S+$24-8] (used reg = )
30193 82A1           8A07                       mov	al,[bx]
30194 82A3           8846         FA            mov	-6[bp],al
30195                                           !BCC_EOS
30196                                           ! 5099       val8 = status & 0x0f;
30197                                           ! Debug: and int = const $F to unsigned char status = [S+$24-8] (used reg = )
30198 82A6           8A46         FA            mov	al,-6[bp]
30199 82A9           24                     0F  and	al,*$F
30200                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
30201 82AB           8846         F1            mov	-$F[bp],al
30202                                           !BCC_EOS
30203                                           ! 5100       switch(drive_type) {
30204 82AE           8A46         E8            mov	al,-$18[bp]
30205 82B1           EB           6A            jmp .71F
30206                                           ! 5101         case 1:
30207                                           ! 5102           val8 |= 0x90;
30208                       000082B3            .720:
30209                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30210 82B3           8A46         F1            mov	al,-$F[bp]
30211 82B6           0C                     90  or	al,#$90
30212 82B8           8846         F1            mov	-$F[bp],al
30213                                           !BCC_EOS
30214                                           ! 5103           break;
30215 82BB           EB           72            jmp .71D
30216                                           !BCC_EOS
30217                                           ! 5104         case 2:
30218                                           ! 5105           val8 |= 0x70;
30219                       000082BD            .721:
30220                                           ! Debug: orab int = const $70 to unsigned char val8 = [S+$24-$11] (used reg = )
30221 82BD           8A46         F1            mov	al,-$F[bp]
30222 82C0           0C                     70  or	al,*$70
30223 82C2           8846         F1            mov	-$F[bp],al
30224                                           !BCC_EOS
30225                                           ! 5106           break;
30226 82C5           EB           68            jmp .71D
30227                                           !BCC_EOS
30228                                           ! 5107         case 3:
30229                                           ! 5108           val8 |= 0x10;
30230                       000082C7            .722:
30231                                           ! Debug: orab int = const $10 to unsigned char val8 = [S+$24-$11] (used reg = )
30232 82C7           8A46         F1            mov	al,-$F[bp]
30233 82CA           0C                     10  or	al,*$10
30234 82CC           8846         F1            mov	-$F[bp],al
30235                                           !BCC_EOS
30236                                           ! 5109           break;
30237 82CF           EB           5E            jmp .71D
30238                                           !BCC_EOS
30239                                           ! 5110         case 4:
30240                                           ! 5111           if (((status >> 4) & 0x01) && ((status >> 1) & 0x01))
30241                       000082D1            .723:
30242                                           ! Debug: sr int = const 4 to unsigned char status = [S+$24-8] (used reg = )
30243 82D1           8A46         FA            mov	al,-6[bp]
30244 82D4           30E4                       xor	ah,ah
30245 82D6           B1                     04  mov	cl,*4
30246 82D8           D3E8                       shr	ax,cl
30247                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
30248 82DA           24                     01  and	al,*1
30249 82DC           84C0                       test	al,al
30250 82DE           74           17            je  	.724
30251                       000082E0            .726:
30252                                           ! Debug: sr int = const 1 to unsigned char status = [S+$24-8] (used reg = )
30253 82E0           8A46         FA            mov	al,-6[bp]
30254 82E3           30E4                       xor	ah,ah
30255 82E5           D1E8                       shr	ax,*1
30256                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
30257 82E7           24                     01  and	al,*1
30258 82E9           84C0                       test	al,al
30259 82EB           74           0A            je  	.724
30260                       000082ED            .725:
30261                                           ! 5112           {
30262                                           ! 5113             val8 |= 0x50;
30263                                           ! Debug: orab int = const $50 to unsigned char val8 = [S+$24-$11] (used reg = )
30264 82ED           8A46         F1            mov	al,-$F[bp]
30265 82F0           0C                     50  or	al,*$50
30266 82F2           8846         F1            mov	-$F[bp],al
30267                                           !BCC_EOS
30268                                           ! 5114           }
30269                                           ! 5115           else
30270                                           ! 5116           {
30271 82F5           EB           08            jmp .727
30272                       000082F7            .724:
30273                                           ! 5117             val8 |= 0x90;
30274                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30275 82F7           8A46         F1            mov	al,-$F[bp]
30276 82FA           0C                     90  or	al,#$90
30277 82FC           8846         F1            mov	-$F[bp],al
30278                                           !BCC_EOS
30279                                           ! 5118           }
30280                                           ! 5119           break;
30281                       000082FF            .727:
30282 82FF           EB           2E            jmp .71D
30283                                           !BCC_EOS
30284                                           ! 5120         default:
30285                                           ! 5121           *(((Bit8u *)&AX)+1) = (0x01);
30286                       00008301            .728:
30287                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
30288 8301           B0                     01  mov	al,*1
30289 8303           8846         17            mov	$17[bp],al
30290                                           !BCC_EOS
30291                                           ! 5122           set_diskette_ret_status(1);
30292                                           ! Debug: list int = const 1 (used reg = )
30293 8306           B8                   0001  mov	ax,*1
30294 8309           50                         push	ax
30295                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30296 830A           E8         0334            call	_set_diskette_ret_status
30297 830D           44                         inc	sp
30298 830E           44                         inc	sp
30299                                           !BCC_EOS
30300                                           ! 5123           FLAGS |= 0x0
30301                                           ! 5123 001;
30302                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30303 830F           8B46         1C            mov	ax,$1C[bp]
30304 8312           0C                     01  or	al,*1
30305 8314           8946         1C            mov	$1C[bp],ax
30306                                           !BCC_EOS
30307                                           ! 5124           return;
30308 8317           89EC                       mov	sp,bp
30309 8319           5D                         pop	bp
30310 831A           C3                         ret
30311                                           !BCC_EOS
30312                                           ! 5125       }
30313                                           ! 5126 ;
30314 831B           EB           12            jmp .71D
30315                       0000831D            .71F:
30316 831D           2C                     01  sub	al,*1
30317 831F           74           92            je 	.720
30318 8321           2C                     01  sub	al,*1
30319 8323           74           98            je 	.721
30320 8325           2C                     01  sub	al,*1
30321 8327           74           9E            je 	.722
30322 8329           2C                     01  sub	al,*1
30323 832B           74           A4            je 	.723
30324 832D           EB           D2            jmp	.728
30325                       0000832F            .71D:
30326                                           !BCC_EOS
30327                                           ! 5127       *((Bit8u *)(base_address)) = (val8);
30328 832F           8B5E         F8            mov	bx,-8[bp]
30329                                           ! Debug: eq unsigned char val8 = [S+$24-$11] to unsigned char = [bx+0] (used reg = )
30330 8332           8A46         F1            mov	al,-$F[bp]
30331 8335           8807                       mov	[bx],al
30332                                           !BCC_EOS
30333                                           ! 5128       *(((Bit8u *)&AX)+1) = (0);
30334                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30335 8337           30C0                       xor	al,al
30336 8339           8846         17            mov	$17[bp],al
30337                                           !BCC_EOS
30338                                           ! 5129       set_diskette_ret_status(0);
30339                                           ! Debug: list int = const 0 (used reg = )
30340 833C           31C0                       xor	ax,ax
30341 833E           50                         push	ax
30342                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30343 833F           E8         02FF            call	_set_diskette_ret_status
30344 8342           44                         inc	sp
30345 8343           44                         inc	sp
30346                                           !BCC_EOS
30347                                           ! 5130       FLAGS &= 0xfffe;
30348                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30349 8344           8B46         1C            mov	ax,$1C[bp]
30350 8347           24                     FE  and	al,#$FE
30351 8349           8946         1C            mov	$1C[bp],ax
30352                                           !BCC_EOS
30353                                           ! 5131       return;
30354 834C           89EC                       mov	sp,bp
30355 834E           5D                         pop	bp
30356 834F           C3                         ret
30357                                           !BCC_EOS
30358                                           ! 5132     case 0x18:
30359                                           ! 5133 ;
30360                       00008350            .729:
30361                                           !BCC_EOS
30362                                           ! 5134       drive = ( ELDX & 0x00ff );
30363                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
30364 8350           8A46         0E            mov	al,$E[bp]
30365                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
30366 8353           8846         FF            mov	-1[bp],al
30367                                           !BCC_EOS
30368                                           ! 5135       val8 = ( CX & 0x00ff );
30369                                           ! Debug: and int = const $FF to unsigned short CX = [S+$24+$12] (used reg = )
30370 8356           8A46         14            mov	al,$14[bp]
30371                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
30372 8359           8846         F1            mov	-$F[bp],al
30373                                           !BCC_EOS
30374                                           ! 5136       spt = val8 & 0x3f;
30375                                           ! Debug: and int = const $3F to unsigned char val8 = [S+$24-$11] (used reg = )
30376 835C           8A46         F1            mov	al,-$F[bp]
30377 835F           24                     3F  and	al,*$3F
30378                                           ! Debug: eq unsigned char = al+0 to unsigned char spt = [S+$24-$1D] (used reg = )
30379 8361           8846         E5            mov	-$1B[bp],al
30380                                           !BCC_EOS
30381                                           ! 5137       maxCyl = ((val8 >> 6) << 8) + *(((Bit8u *)&CX)+1);
30382                                           ! Debug: sr int = const 6 to unsigned char val8 = [S+$24-$11] (used reg = )
30383 8364           8A46         F1            mov	al,-$F[bp]
30384 8367           30E4                       xor	ah,ah
30385 8369           B1                     06  mov	cl,*6
30386 836B           D3E8                       shr	ax,cl
30387                                           ! Debug: sl int = const 8 to unsigned int = ax+0 (used reg = )
30388 836D           88C4                       mov	ah,al
30389 836F           30C0                       xor	al,al
30390                                           ! Debug: add unsigned char CX = [S+$24+$13] to unsigned int = ax+0 (used reg = )
30391 8371           0246         15            add	al,$15[bp]
30392 8374           80D4                   00  adc	ah,*0
30393                                           ! Debug: eq unsigned int = ax+0 to unsigned short maxCyl = [S+$24-$24] (used reg = )
30394 8377           8946         DE            mov	-$22[bp],ax
30395                                           !BCC_EOS
30396                                           ! 5138 ;
30397                                           !BCC_EOS
30398                                           ! 5139       if (drive > 1) {
30399                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
30400 837A           8A46         FF            mov	al,-1[bp]
30401 837D           3C                     01  cmp	al,*1
30402 837F           76           1A            jbe 	.72A
30403                       00008381            .72B:
30404                                           ! 5140         *(((Bit8u *)&AX)+1) = (0x01);
30405                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
30406 8381           B0                     01  mov	al,*1
30407 8383           8846         17            mov	$17[bp],al
30408                                           !BCC_EOS
30409                                           ! 5141         set_diskette_ret_status(1);
30410                                           ! Debug: list int = const 1 (used reg = )
30411 8386           B8                   0001  mov	ax,*1
30412 8389           50                         push	ax
30413                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30414 838A           E8         02B4            call	_set_diskette_ret_status
30415 838D           44                         inc	sp
30416 838E           44                         inc	sp
30417                                           !BCC_EOS
30418                                           ! 5142         FLAGS |= 0x0001;
30419                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30420 838F           8B46         1C            mov	ax,$1C[bp]
30421 8392           0C                     01  or	al,*1
30422 8394           8946         1C            mov	$1C[bp],ax
30423                                           !BCC_EOS
30424                                           ! 5143         return;
30425 8397           89EC                       mov	sp,bp
30426 8399           5D                         pop	bp
30427 839A           C3                         ret
30428                                           !BCC_EOS
30429                                           ! 5144       }
30430                                           ! 5145       if (floppy_drive_exists(drive) == 0) {
30431                       0000839B            .72A:
30432                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
30433 839B           8A46         FF            mov	al,-1[bp]
30434 839E           30E4                       xor	ah,ah
30435 83A0           50                         push	ax
30436                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
30437 83A1           E8         F3A7            call	_floppy_drive_exists
30438 83A4           44                         inc	sp
30439 83A5           44                         inc	sp
30440                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
30441 83A6           85C0                       test	ax,ax
30442 83A8           75           1A            jne 	.72C
30443                       000083AA            .72D:
30444                                           ! 5146         *(((Bit8u *)&AX)+1) = (0x80);
30445                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
30446 83AA           B0                     80  mov	al,#$80
30447 83AC           8846         17            mov	$17[bp],al
30448                                           !BCC_EOS
30449                                           ! 5147         set_diskette_ret_status(0x80);
30450                                           ! Debug: list int = const $80 (used reg = )
30451 83AF           B8                   0080  mov	ax,#$80
30452 83B2           50                         push	ax
30453                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30454 83B3           E8         028B            call	_set_diskette_ret_status
30455 83B6           44                         inc	sp
30456 83B7           44                         inc	sp
30457                                           !BCC_EOS
30458                                           ! 5148         FLAGS |= 0x0001;
30459                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30460 83B8           8B46         1C            mov	ax,$1C[bp]
30461 83BB           0C                     01  or	al,*1
30462 83BD           8946         1C            mov	$1C[bp],ax
30463                                           !BCC_EOS
30464                                           ! 5149         return;
30465 83C0           89EC                       mov	sp,bp
30466 83C2           5D                         pop	bp
30467 83C3           C3                         ret
30468                                           !BCC_EOS
30469                                           ! 5150       }
30470                                           ! 5151       if (floppy_media_known(drive) == 0) {
30471                       000083C4            .72C:
30472                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
30473 83C4           8A46         FF            mov	al,-1[bp]
30474 83C7           30E4                       xor	ah,ah
30475 83C9           50                         push	ax
30476                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
30477 83CA           E8         F198            call	_floppy_media_known
30478 83CD           44                         inc	sp
30479 83CE           44                         inc	sp
30480                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
30481 83CF           85C0                       test	ax,ax
30482 83D1           75           29            jne 	.72E
30483                       000083D3            .72F:
30484                                           ! 5152         if (floppy_media_sense(drive) == 0) {
30485                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
30486 83D3           8A46         FF            mov	al,-1[bp]
30487 83D6           30E4                       xor	ah,ah
30488 83D8           50                         push	ax
30489                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
30490 83D9           E8         F1F9            call	_floppy_media_sense
30491 83DC           44                         inc	sp
30492 83DD           44                         inc	sp
30493                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
30494 83DE           85C0                       test	ax,ax
30495 83E0           75           1A            jne 	.730
30496                       000083E2            .731:
30497                                           ! 5153           *(((Bit8u *)&AX)+1) = (0x0C);
30498                                           ! Debug: eq int = const $C to unsigned char AX = [S+$24+$15] (used reg = )
30499 83E2           B0                     0C  mov	al,*$C
30500 83E4           8846         17            mov	$17[bp],al
30501                                           !BCC_EOS
30502                                           ! 5154           set_diskette_ret_status(0x0C);
30503                                           ! Debug: list int = const $C (used reg = )
30504 83E7           B8                   000C  mov	ax,*$C
30505 83EA           50                         push	ax
30506                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30507 83EB           E8         0253            call	_set_diskette_ret_status
30508 83EE           44                         inc	sp
30509 83EF           44                         inc	sp
30510                                           !BCC_EOS
30511                                           ! 5155           FLAGS |= 0x0001;
30512                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30513 83F0           8B46         1C            mov	ax,$1C[bp]
30514 83F3           0C                     01  or	al,*1
30515 83F5           8946         1C            mov	$1C[bp],ax
30516                                           !BCC_EOS
30517                                           ! 5156           return;
30518 83F8           89EC                       mov	sp,bp
30519 83FA           5D                         pop	bp
30520 83FB           C3                         ret
30521                                           !BCC_EOS
30522                                           ! 5157         }
30523                                           ! 5158       }
30524                       000083FC            .730:
30525                                           ! 5159       drive_type = inb_cmos(0x10);
30526                       000083FC            .72E:
30527                                           ! Debug: list int = const $10 (used reg = )
30528 83FC           B8                   0010  mov	ax,*$10
30529 83FF           50                         push	ax
30530                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
30531 8400           E8         813A            call	_inb_cmos
30532 8403           44                         inc	sp
30533 8404           44                         inc	sp
30534                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
30535 8405           8846         E8            mov	-$18[bp],al
30536                                           !BCC_EOS
30537                                           ! 5160       if (drive == 0)
30538                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$24-3] (used reg = )
30539 8408           8A46         FF            mov	al,-1[bp]
30540 840B           84C0                       test	al,al
30541 840D           75           0E            jne 	.732
30542                       0000840F            .733:
30543                                           ! 5161         drive_type >>= 4;
30544                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$24-$1A] (used reg = )
30545 840F           8A46         E8            mov	al,-$18[bp]
30546 8412           30E4                       xor	ah,ah
30547 8414           B1                     04  mov	cl,*4
30548 8416           D3E8                       shr	ax,cl
30549 8418           8846         E8            mov	-$18[bp],al
30550                                           !BCC_EOS
30551                                           ! 5162       else
30552                                           ! 5163         drive_type &= 0x0f;
30553 841B           EB           08            jmp .734
30554                       0000841D            .732:
30555                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$24-$1A] (used reg = )
30556 841D           8A46         E8            mov	al,-$18[bp]
30557 8420           24                     0F  and	al,*$F
30558 8422           8846         E8            mov	-$18[bp],al
30559                                           !BCC_EOS
30560                                           ! 5164       base_address = (drive) ? 0x0091 : 0x0090;
30561                       00008425            .734:
30562 8425           8A46         FF            mov	al,-1[bp]
30563 8428           84C0                       test	al,al
30564 842A           74           04            je  	.735
30565                       0000842C            .736:
30566 842C           B0                     91  mov	al,#$91
30567 842E           EB           02            jmp .737
30568                       00008430            .735:
30569 8430           B0                     90  mov	al,#$90
30570                       00008432            .737:
30571                                           ! Debug: eq char = al+0 to unsigned short base_address = [S+$24-$A] (used reg = )
30572 8432           30E4                       xor	ah,ah
30573 8434           8946         F8            mov	-8[bp],ax
30574                                           !BCC_EOS
30575                                           ! 5165       status = *((Bit8u *)(base_address));
30576 8437           8B5E         F8            mov	bx,-8[bp]
30577                                           ! Debug: eq unsigned char = [bx+0] to unsigned char status = [S+$24-8] (used reg = )
30578 843A           8A07                       mov	al,[bx]
30579 843C           8846         FA            mov	-6[bp],al
30580                                           !BCC_EOS
30581                                           ! 5166       val8 = status & 0x0f;
30582                                           ! Debug: and int = const $F to unsigned char status = [S+$24-8] (used reg = )
30583 843F           8A46         FA            mov	al,-6[bp]
30584 8442           24                     0F  and	al,*$F
30585                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
30586 8444           8846         F1            mov	-$F[bp],al
30587                                           !BCC_EOS
30588                                           ! 5167       *(((Bit8u *)&AX)+1) = (0x0C);
30589                                           ! Debug: eq int = const $C to unsigned char AX = [S+$24+$15] (used reg = )
30590 8447           B0                     0C  mov	al,*$C
30591 8449           8846         17            mov	$17[bp],al
30592                                           !BCC_EOS
30593                                           ! 5168       switch (drive_type) {
30594 844C           8A46         E8            mov	al,-$18[bp]
30595 844F           E9         010E            br 	.73A
30596                                           ! 5169         case 0:
30597                                           ! 5170           break;
30598                       00008452            .73B:
30599 8452           E9         0132            br 	.738
30600                                           !BCC_EOS
30601                                           ! 5171         case 1:
30602                                           ! 5172         case 6:
30603                       00008455            .73C:
30604                                           ! 5173         case 7:
30605                       00008455            .73D:
30606                                           ! 5174         case 8:
30607                       00008455            .73E:
30608                                           ! 5175           if (maxCyl == 39 && (spt == 8 || spt == 9))
30609                       00008455            .73F:
30610                                           ! Debug: logeq int = const $27 to unsigned short maxCyl = [S+$24-$24] (used reg = )
30611 8455           8B46         DE            mov	ax,-$22[bp]
30612 8458           3D                   0027  cmp	ax,*$27
30613 845B           75           1B            jne 	.740
30614                       0000845D            .742:
30615                                           ! Debug: logeq int = const 8 to unsigned char spt = [S+$24-$1D] (used reg = )
30616 845D           8A46         E5            mov	al,-$1B[bp]
30617 8460           3C                     08  cmp	al,*8
30618 8462           74           07            je  	.741
30619                       00008464            .743:
30620                                           ! Debug: logeq int = const 9 to unsigned char spt = [S+$24-$1D] (used reg = )
30621 8464           8A46         E5            mov	al,-$1B[bp]
30622 8467           3C                     09  cmp	al,*9
30623 8469           75           0D            jne 	.740
30624                       0000846B            .741:
30625                                           ! 5176           {
30626                                           ! 5177             val8 |= 0x90;
30627                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30628 846B           8A46         F1            mov	al,-$F[bp]
30629 846E           0C                     90  or	al,#$90
30630 8470           8846         F1            mov	-$F[bp],al
30631                                           !BCC_EOS
30632                                           ! 5178             *(((Bit8u *)&AX)+1) = (0);
30633                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30634 8473           30C0                       xor	al,al
30635 8475           8846         17            mov	$17[bp],al
30636                                           !BCC_EOS
30637                                           ! 5179           }
30638                                           ! 5180           break;
30639                       00008478            .740:
30640 8478           E9         010C            br 	.738
30641                                           !BCC_EOS
30642                                           ! 5181         case 2:
30643                                           ! 5182           if (maxCyl == 39 && (spt == 8 || spt == 9))
30644                       0000847B            .744:
30645                                           ! Debug: logeq int = const $27 to unsigned short maxCyl = [S+$24-$24] (used reg = )
30646 847B           8B46         DE            mov	ax,-$22[bp]
30647 847E           3D                   0027  cmp	ax,*$27
30648 8481           75           1D            jne 	.745
30649                       00008483            .747:
30650                                           ! Debug: logeq int = const 8 to unsigned char spt = [S+$24-$1D] (used reg = )
30651 8483           8A46         E5            mov	al,-$1B[bp]
30652 8486           3C                     08  cmp	al,*8
30653 8488           74           07            je  	.746
30654                       0000848A            .748:
30655                                           ! Debug: logeq int = const 9 to unsigned char spt = [S+$24-$1D] (used reg = )
30656 848A           8A46         E5            mov	al,-$1B[bp]
30657 848D           3C                     09  cmp	al,*9
30658 848F           75           0F            jne 	.745
30659                       00008491            .746:
30660                                           ! 5183           {
30661                                           ! 5184             val8 |= 0x70;
30662                                           ! Debug: orab int = const $70 to unsigned char val8 = [S+$24-$11] (used reg = )
30663 8491           8A46         F1            mov	al,-$F[bp]
30664 8494           0C                     70  or	al,*$70
30665 8496           8846         F1            mov	-$F[bp],al
30666                                           !BCC_EOS
30667                                           ! 5185             *(((Bit8u *)&AX)+1) = (0);
30668                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30669 8499           30C0                       xor	al,al
30670 849B           8846         17            mov	$17[bp],al
30671                                           !BCC_EOS
30672                                           ! 5186           }
30673                                           ! 5187           else if (maxCyl == 79 && spt == 15)
30674 849E           EB           1C            jmp .749
30675                       000084A0            .745:
30676                                           ! Debug: logeq int = const $4F to unsigned short maxCyl = [S+$24-$24] (used reg = )
30677 84A0           8B46         DE            mov	ax,-$22[bp]
30678 84A3           3D                   004F  cmp	ax,*$4F
30679 84A6           75           14            jne 	.74A
30680                       000084A8            .74C:
30681                                           ! Debug: logeq int = const $F to unsigned char spt = [S+$24-$1D] (used reg = )
30682 84A8           8A46         E5            mov	al,-$1B[bp]
30683 84AB           3C                     0F  cmp	al,*$F
30684 84AD           75           0D            jne 	.74A
30685                       000084AF            .74B:
30686                                           ! 5188           {
30687                                           ! 5189             val8 |= 0x10;
30688                                           ! Debug: orab int = const $10 to unsigned char val8 = [S+$24-$11] (used reg = )
30689 84AF           8A46         F1            mov	al,-$F[bp]
30690 84B2           0C                     10  or	al,*$10
30691 84B4           8846         F1            mov	-$F[bp],al
30692                                           !BCC_EOS
30693                                           ! 5190             *(((Bit8u *)&AX)+1) = (0);
30694                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30695 84B7           30C0                       xor	al,al
30696 84B9           8846         17            mov	$17[bp],al
30697                                           !BCC_EOS
30698                                           ! 5191           }
30699                                           ! 5192           break;
30700                       000084BC            .74A:
30701                       000084BC            .749:
30702 84BC           E9         00C8            br 	.738
30703                                           !BCC_EOS
30704                                           ! 5193         case 3:
30705                                           ! 5194           if (maxCyl == 79 && spt == 9)
30706                       000084BF            .74D:
30707                                           ! Debug: logeq int = const $4F to unsigned short maxCyl = [S+$24-$24] (used reg = )
30708 84BF           8B46         DE            mov	ax,-$22[bp]
30709 84C2           3D                   004F  cmp	ax,*$4F
30710 84C5           75           14            jne 	.74E
30711                       000084C7            .750:
30712                                           ! Debug: logeq int = const 9 to unsigned char spt = [S+$24-$1D] (used reg = )
30713 84C7           8A46         E5            mov	al,-$1B[bp]
30714 84CA           3C                     09  cmp	al,*9
30715 84CC           75           0D            jne 	.74E
30716                       000084CE            .74F:
30717                                           ! 5195           {
30718                                           ! 5196             val8 |= 0x90;
30719                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30720 84CE           8A46         F1            mov	al,-$F[bp]
30721 84D1           0C                     90  or	al,#$90
30722 84D3           8846         F1            mov	-$F[bp],al
30723                                           !BCC_EOS
30724                                           ! 5197             *(((Bit8u *)&AX)+1) = (0);
30725                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30726 84D6           30C0                       xor	al,al
30727 84D8           8846         17            mov	$17[bp],al
30728                                           !BCC_EOS
30729                                           ! 5198           }
30730                                           ! 5199           break;
30731                       000084DB            .74E:
30732 84DB           E9         00A9            br 	.738
30733                                           !BCC_EOS
30734                                           ! 5200         case 4:
30735                                           ! 5201           if (maxCyl == 79)
30736                       000084DE            .751:
30737                                           ! Debug: logeq int = const $4F to unsigned short maxCyl = [S+$24-$24] (used reg = )
30738 84DE           8B46         DE            mov	ax,-$22[bp]
30739 84E1           3D                   004F  cmp	ax,*$4F
30740 84E4           75           2A            jne 	.752
30741                       000084E6            .753:
30742                                           ! 5202           {
30743                                           ! 5203             if (spt == 9)
30744                                           ! Debug: logeq int = const 9 to unsigned char spt = [S+$24-$1D] (used reg = )
30745 84E6           8A46         E5            mov	al,-$1B[bp]
30746 84E9           3C                     09  cmp	al,*9
30747 84EB           75           0F            jne 	.754
30748                       000084ED            .755:
30749                                           ! 5204             {
30750                                           ! 5205               val8 |= 
30751                                           ! 5205 0x90;
30752                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30753 84ED           8A46         F1            mov	al,-$F[bp]
30754 84F0           0C                     90  or	al,#$90
30755 84F2           8846         F1            mov	-$F[bp],al
30756                                           !BCC_EOS
30757                                           ! 5206               *(((Bit8u *)&AX)+1) = (0);
30758                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30759 84F5           30C0                       xor	al,al
30760 84F7           8846         17            mov	$17[bp],al
30761                                           !BCC_EOS
30762                                           ! 5207             }
30763                                           ! 5208             else if (spt == 18)
30764 84FA           EB           14            jmp .756
30765                       000084FC            .754:
30766                                           ! Debug: logeq int = const $12 to unsigned char spt = [S+$24-$1D] (used reg = )
30767 84FC           8A46         E5            mov	al,-$1B[bp]
30768 84FF           3C                     12  cmp	al,*$12
30769 8501           75           0D            jne 	.757
30770                       00008503            .758:
30771                                           ! 5209             {
30772                                           ! 5210               val8 |= 0x10;
30773                                           ! Debug: orab int = const $10 to unsigned char val8 = [S+$24-$11] (used reg = )
30774 8503           8A46         F1            mov	al,-$F[bp]
30775 8506           0C                     10  or	al,*$10
30776 8508           8846         F1            mov	-$F[bp],al
30777                                           !BCC_EOS
30778                                           ! 5211               *(((Bit8u *)&AX)+1) = (0);
30779                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30780 850B           30C0                       xor	al,al
30781 850D           8846         17            mov	$17[bp],al
30782                                           !BCC_EOS
30783                                           ! 5212             }
30784                                           ! 5213           }
30785                       00008510            .757:
30786                       00008510            .756:
30787                                           ! 5214           break;
30788                       00008510            .752:
30789 8510           EB           75            jmp .738
30790                                           !BCC_EOS
30791                                           ! 5215         case 5:
30792                                           ! 5216           if (maxCyl == 79)
30793                       00008512            .759:
30794                                           ! Debug: logeq int = const $4F to unsigned short maxCyl = [S+$24-$24] (used reg = )
30795 8512           8B46         DE            mov	ax,-$22[bp]
30796 8515           3D                   004F  cmp	ax,*$4F
30797 8518           75           40            jne 	.75A
30798                       0000851A            .75B:
30799                                           ! 5217           {
30800                                           ! 5218             if (spt == 9)
30801                                           ! Debug: logeq int = const 9 to unsigned char spt = [S+$24-$1D] (used reg = )
30802 851A           8A46         E5            mov	al,-$1B[bp]
30803 851D           3C                     09  cmp	al,*9
30804 851F           75           0F            jne 	.75C
30805                       00008521            .75D:
30806                                           ! 5219             {
30807                                           ! 5220               val8 |= 0x90;
30808                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30809 8521           8A46         F1            mov	al,-$F[bp]
30810 8524           0C                     90  or	al,#$90
30811 8526           8846         F1            mov	-$F[bp],al
30812                                           !BCC_EOS
30813                                           ! 5221               *(((Bit8u *)&AX)+1) = (0);
30814                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30815 8529           30C0                       xor	al,al
30816 852B           8846         17            mov	$17[bp],al
30817                                           !BCC_EOS
30818                                           ! 5222             }
30819                                           ! 5223             else if (spt == 18)
30820 852E           EB           2A            jmp .75E
30821                       00008530            .75C:
30822                                           ! Debug: logeq int = const $12 to unsigned char spt = [S+$24-$1D] (used reg = )
30823 8530           8A46         E5            mov	al,-$1B[bp]
30824 8533           3C                     12  cmp	al,*$12
30825 8535           75           0F            jne 	.75F
30826                       00008537            .760:
30827                                           ! 5224             {
30828                                           ! 5225               val8 |= 0x10;
30829                                           ! Debug: orab int = const $10 to unsigned char val8 = [S+$24-$11] (used reg = )
30830 8537           8A46         F1            mov	al,-$F[bp]
30831 853A           0C                     10  or	al,*$10
30832 853C           8846         F1            mov	-$F[bp],al
30833                                           !BCC_EOS
30834                                           ! 5226               *(((Bit8u *)&AX)+1) = (0);
30835                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30836 853F           30C0                       xor	al,al
30837 8541           8846         17            mov	$17[bp],al
30838                                           !BCC_EOS
30839                                           ! 5227             }
30840                                           ! 5228             else if (spt == 36)
30841 8544           EB           14            jmp .761
30842                       00008546            .75F:
30843                                           ! Debug: logeq int = const $24 to unsigned char spt = [S+$24-$1D] (used reg = )
30844 8546           8A46         E5            mov	al,-$1B[bp]
30845 8549           3C                     24  cmp	al,*$24
30846 854B           75           0D            jne 	.762
30847                       0000854D            .763:
30848                                           ! 5229             {
30849                                           ! 5230               val8 |= 0xD0;
30850                                           ! Debug: orab int = const $D0 to unsigned char val8 = [S+$24-$11] (used reg = )
30851 854D           8A46         F1            mov	al,-$F[bp]
30852 8550           0C                     D0  or	al,#$D0
30853 8552           8846         F1            mov	-$F[bp],al
30854                                           !BCC_EOS
30855                                           ! 5231               *(((Bit8u *)&AX)+1) = (0);
30856                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30857 8555           30C0                       xor	al,al
30858 8557           8846         17            mov	$17[bp],al
30859                                           !BCC_EOS
30860                                           ! 5232             }
30861                                           ! 5233           }
30862                       0000855A            .762:
30863                       0000855A            .761:
30864                       0000855A            .75E:
30865                                           ! 5234           break;
30866                       0000855A            .75A:
30867 855A           EB           2B            jmp .738
30868                                           !BCC_EOS
30869                                           ! 5235         default:
30870                                           ! 5236           break;
30871                       0000855C            .764:
30872 855C           EB           29            jmp .738
30873                                           !BCC_EOS
30874                                           ! 5237       }
30875                                           ! 5238       if (0 != *(((Bit8u *)&AX)+1))
30876 855E           EB           27            jmp .738
30877                       00008560            .73A:
30878 8560           2C                     00  sub	al,*0
30879 8562           72           F8            jb 	.764
30880 8564           3C                     08  cmp	al,*8
30881 8566           77           1D            ja  	.765
30882 8568           30E4                       xor	ah,ah
30883 856A           D1E0                       shl	ax,*1
30884 856C           89C3                       mov	bx,ax
30885 856E           2E                         seg	cs
30886 856F           FFA7       8573            br	.766[bx]
30887                       00008573            .766:
30888 8573                      8452            .word	.73B
30889 8575                      8455            .word	.73C
30890 8577                      847B            .word	.744
30891 8579                      84BF            .word	.74D
30892 857B                      84DE            .word	.751
30893 857D                      8512            .word	.759
30894 857F                      8455            .word	.73D
30895 8581                      8455            .word	.73E
30896 8583                      8455            .word	.73F
30897                       00008585            .765:
30898 8585           EB           D5            jmp	.764
30899                       00008587            .738:
30900                                           ! Debug: ne unsigned char AX = [S+$24+$15] to int = const 0 (used reg = )
30901                                           ! Debug: expression subtree swapping
30902 8587           8A46         17            mov	al,$17[bp]
30903 858A           84C0                       test	al,al
30904 858C           74           17            je  	.767
30905                       0000858E            .768:
30906                                           ! 5239       {
30907                                           ! 5240         set_diskette_ret_status(*(((Bit8u *)&AX)+1));
30908                                           ! Debug: list unsigned char AX = [S+$24+$15] (used reg = )
30909 858E           8A46         17            mov	al,$17[bp]
30910 8591           30E4                       xor	ah,ah
30911 8593           50                         push	ax
30912                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30913 8594           E8         00AA            call	_set_diskette_ret_status
30914 8597           44                         inc	sp
30915 8598           44                         inc	sp
30916                                           !BCC_EOS
30917                                           ! 5241         FLAGS |= 0x0001;
30918                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30919 8599           8B46         1C            mov	ax,$1C[bp]
30920 859C           0C                     01  or	al,*1
30921 859E           8946         1C            mov	$1C[bp],ax
30922                                           !BCC_EOS
30923                                           ! 5242         return;
30924 85A1           89EC                       mov	sp,bp
30925 85A3           5D                         pop	bp
30926 85A4           C3                         ret
30927                                           !BCC_EOS
30928                                           ! 5243       }
30929                                           ! 5244 ;
30930                       000085A5            .767:
30931                                           !BCC_EOS
30932                                           ! 5245       *((Bit8u *)(base_address)) = (val8);
30933 85A5           8B5E         F8            mov	bx,-8[bp]
30934                                           ! Debug: eq unsigned char val8 = [S+$24-$11] to unsigned char = [bx+0] (used reg = )
30935 85A8           8A46         F1            mov	al,-$F[bp]
30936 85AB           8807                       mov	[bx],al
30937                                           !BCC_EOS
30938                                           ! 5246 #asm
30939                                           !BCC_EOS
30940                                           !BCC_ASM
30941                       0000002E            _int13_diskette_function.BP	set	$2E
30942                       0000000C            .int13_diskette_function.BP	set	$C
30943                       0000003C            _int13_diskette_function.CS	set	$3C
30944                       0000001A            .int13_diskette_function.CS	set	$1A
30945                       00000036            _int13_diskette_function.CX	set	$36
30946                       00000014            .int13_diskette_function.CX	set	$14
30947                       0000001A            _int13_diskette_function.base_address	set	$1A
30948                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
30949                       0000002A            _int13_diskette_function.DI	set	$2A
30950                       00000008            .int13_diskette_function.DI	set	8
30951                       0000003E            _int13_diskette_function.FLAGS	set	$3E
30952                       0000001C            .int13_diskette_function.FLAGS	set	$1C
30953                       00000018            _int13_diskette_function.base_count	set	$18
30954                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
30955                       0000001E            _int13_diskette_function.sector	set	$1E
30956                       FFFFFFFC            .int13_diskette_function.sector	set	-4
30957                       00000026            _int13_diskette_function.DS	set	$26
30958                       00000004            .int13_diskette_function.DS	set	4
30959                       0000001D            _int13_diskette_function.head	set	$1D
30960                       FFFFFFFB            .int13_diskette_function.head	set	-5
30961                       00000030            _int13_diskette_function.ELDX	set	$30
30962                       0000000E            .int13_diskette_function.ELDX	set	$E
30963                       00000012            _int13_diskette_function.dor	set	$12
30964                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
30965                       00000034            _int13_diskette_function.DX	set	$34
30966                       00000012            .int13_diskette_function.DX	set	$12
30967                       0000000B            _int13_diskette_function.return_status	set	$B
30968                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
30969                       00000004            _int13_diskette_function.es	set	4
30970                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
30971                       00000014            _int13_diskette_function.mode_register	set	$14
30972                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
30973                       00000028            _int13_diskette_function.ES	set	$28
30974                       00000006            .int13_diskette_function.ES	set	6
30975                       00000016            _int13_diskette_function.base_es	set	$16
30976                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
30977                       0000001F            _int13_diskette_function.track	set	$1F
30978                       FFFFFFFD            .int13_diskette_function.track	set	-3
30979                       0000002C            _int13_diskette_function.SI	set	$2C
30980                       0000000A            .int13_diskette_function.SI	set	$A
30981                       0000000A            _int13_diskette_function.drive_type	set	$A
30982                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
30983                       00000020            _int13_diskette_function.num_sectors	set	$20
30984                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
30985                       0000003A            _int13_diskette_function.IP	set	$3A
30986                       00000018            .int13_diskette_function.IP	set	$18
30987                       00000007            _int13_diskette_function.spt	set	7
30988                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
30989                       0000001C            _int13_diskette_function.status	set	$1C
30990                       FFFFFFFA            .int13_diskette_function.status	set	-6
30991                       00000000            _int13_diskette_function.maxCyl	set	0
30992                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
30993                       00000038            _int13_diskette_function.AX	set	$38
30994                       00000016            .int13_diskette_function.AX	set	$16
30995                       00000013            _int13_diskette_function.val8	set	$13
30996                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
30997                       00000002            _int13_diskette_function.last_addr	set	2
30998                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
30999                       00000015            _int13_diskette_function.page	set	$15
31000                       FFFFFFF3            .int13_diskette_function.page	set	-$D
31001                       00000008            _int13_diskette_function.ah	set	8
31002                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
31003                       00000021            _int13_diskette_function.drive	set	$21
31004                       FFFFFFFF            .int13_diskette_function.drive	set	-1
31005                       00000009            _int13_diskette_function.num_floppies	set	9
31006                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
31007                       00000032            _int13_diskette_function.BX	set	$32
31008                       00000010            .int13_diskette_function.BX	set	$10
31009 85AD           55                               push bp
31010 85AE           89E5                             mov bp, sp
31011 85B0           B8                   EFDE        mov ax, #diskette_param_table2
31012 85B3           8946         2C                  mov _int13_diskette_function.DI+2[bp], ax
31013 85B6           8C4E         2A                  mov _int13_diskette_function.ES+2[bp], cs
31014 85B9           5D                               pop bp
31015                                           ! 5253 endasm
31016                                           !BCC_ENDASM
31017                                           !BCC_EOS
31018                                           ! 5254       set_diskette_ret_status(0);
31019                                           ! Debug: list int = const 0 (used reg = )
31020 85BA           31C0                       xor	ax,ax
31021 85BC           50                         push	ax
31022                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31023 85BD           E8         0081            call	_set_diskette_ret_status
31024 85C0           44                         inc	sp
31025 85C1           44                         inc	sp
31026                                           !BCC_EOS
31027                                           ! 5255       FLAGS &= 0xfffe;
31028                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
31029 85C2           8B46         1C            mov	ax,$1C[bp]
31030 85C5           24                     FE  and	al,#$FE
31031 85C7           8946         1C            mov	$1C[bp],ax
31032                                           !BCC_EOS
31033                                           ! 5256       return;
31034 85CA           89EC                       mov	sp,bp
31035 85CC           5D                         pop	bp
31036 85CD           C3                         ret
31037                                           !BCC_EOS
31038                                           ! 5257     default:
31039                                           ! 5258         bios_printf(4, "int13_diskette: unsupported AH=%02x\n", *(((Bit8u *)&AX)+1));
31040                       000085CE            .769:
31041                                           ! Debug: list unsigned char AX = [S+$24+$15] (used reg = )
31042 85CE           8A46         17            mov	al,$17[bp]
31043 85D1           30E4                       xor	ah,ah
31044 85D3           50                         push	ax
31045                                           ! Debug: list * char = .76A+0 (used reg = )
31046 85D4           BB                   CD4D  mov	bx,#.76A
31047 85D7           53                         push	bx
31048                                           ! Debug: list int = const 4 (used reg = )
31049 85D8           B8                   0004  mov	ax,*4
31050 85DB           50                         push	ax
31051                                           ! Debug: func () void = bios_printf+0 (used reg = )
31052 85DC           E8         835F            call	_bios_printf
31053 85DF           83C4                   06  add	sp,*6
31054                                           !BCC_EOS
31055                                           ! 5259         *(((Bit8u *)&AX)+1) = (0x01);
31056                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
31057 85E2           B0                     01  mov	al,*1
31058 85E4           8846         17            mov	$17[bp],al
31059                                           !BCC_EOS
31060                                           ! 5260         set_diskette_ret_status(1);
31061                                           ! Debug: list int = const 1 (used reg = )
31062 85E7           B8                   0001  mov	ax,*1
31063 85EA           50                         push	ax
31064                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31065 85EB           E8         0053            call	_set_diskette_ret_status
31066 85EE           44                         inc	sp
31067 85EF           44                         inc	sp
31068                                           !BCC_EOS
31069                                           ! 5261         FLAGS |= 0x0001;
31070                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
31071 85F0           8B46         1C            mov	ax,$1C[bp]
31072 85F3           0C                     01  or	al,*1
31073 85F5           8946         1C            mov	$1C[bp],ax
31074                                           !BCC_EOS
31075                                           ! 5262         return;
31076 85F8           89EC                       mov	sp,bp
31077 85FA           5D                         pop	bp
31078 85FB           C3                         ret
31079                                           !BCC_EOS
31080                                           ! 5263     }
31081                                           ! 5264 }
31082 85FC           EB           3F            jmp .696
31083                       000085FE            .698:
31084 85FE           2C                     00  sub	al,*0
31085 8600           72           CC            jb 	.769
31086 8602           3C                     08  cmp	al,*8
31087 8604           77           1D            ja  	.76B
31088 8606           30E4                       xor	ah,ah
31089 8608           D1E0                       shl	ax,*1
31090 860A           89C3                       mov	bx,ax
31091 860C           2E                         seg	cs
31092 860D           FFA7       8611            br	.76C[bx]
31093                       00008611            .76C:
31094 8611                      77A5            .word	.699
31095 8613                      783E            .word	.6A1
31096 8615                      7865            .word	.6A4
31097 8617                      7865            .word	.6A5
31098 8619                      7865            .word	.6A6
31099 861B                      7CB9            .word	.6CF
31100 861D                      85CE            .word	.769
31101 861F                      85CE            .word	.769
31102 8621                      801C            .word	.6EF
31103                       00008623            .76B:
31104 8623           2C                     15  sub	al,*$15
31105 8625         0F84         FB66            beq 	.709
31106 8629           2C                     01  sub	al,*1
31107 862B         0F84         FBC6            beq 	.712
31108 862F           2C                     01  sub	al,*1
31109 8631         0F84         FC01            beq 	.715
31110 8635           2C                     01  sub	al,*1
31111 8637         0F84         FD15            beq 	.729
31112 863B           EB           91            jmp	.769
31113                       0000863D            .696:
31114                       FFFFFFDC            ..FFDB	=	-$24
31115                       FFFFFFDC            ..FFDA	=	-$24
31116 863D           89EC                       mov	sp,bp
31117 863F           5D                         pop	bp
31118 8640           C3                         ret
31119                                           ! 5265  void
31120                                           ! Register BX used in function int13_diskette_function
31121                                           ! 5266 set_diskette_ret_status(value)
31122                                           ! 5267   Bit8u value;
31123                                           export	_set_diskette_ret_status
31124                       00008641            _set_diskette_ret_status:
31125                                           !BCC_EOS
31126                                           ! 5268 {
31127                                           ! 5269   _write_byte(value, 0x0041, 0x0040);
31128 8641           55                         push	bp
31129 8642           89E5                       mov	bp,sp
31130                                           ! Debug: list int = const $40 (used reg = )
31131 8644           B8                   0040  mov	ax,*$40
31132 8647           50                         push	ax
31133                                           ! Debug: list int = const $41 (used reg = )
31134 8648           B8                   0041  mov	ax,*$41
31135 864B           50                         push	ax
31136                                           ! Debug: list unsigned char value = [S+6+2] (used reg = )
31137 864C           8A46         04            mov	al,4[bp]
31138 864F           30E4                       xor	ah,ah
31139 8651           50                         push	ax
31140                                           ! Debug: func () void = _write_byte+0 (used reg = )
31141 8652           E8         7FAB            call	__write_byte
31142 8655           89EC                       mov	sp,bp
31143                                           !BCC_EOS
31144                                           ! 5270 }
31145 8657           5D                         pop	bp
31146 8658           C3                         ret
31147                                           ! 5271   void
31148                                           ! 5272 set_diskette_current_cyl(drive, cyl)
31149                                           ! 5273   Bit8u drive;
31150                                           export	_set_diskette_current_cyl
31151                       00008659            _set_diskette_current_cyl:
31152                                           !BCC_EOS
31153                                           ! 5274   Bit8u cyl;
31154                                           !BCC_EOS
31155                                           ! 5275 {
31156                                           ! 5276   if (drive > 1)
31157 8659           55                         push	bp
31158 865A           89E5                       mov	bp,sp
31159                                           ! Debug: gt int = const 1 to unsigned char drive = [S+2+2] (used reg = )
31160 865C           8A46         04            mov	al,4[bp]
31161 865F           3C                     01  cmp	al,*1
31162 8661           76           0D            jbe 	.76D
31163                       00008663            .76E:
31164                                           ! 5277     bios_printf((2 | 4 | 1), "set_diskette_current_cyl(): drive > 1\n");
31165                                           ! Debug: list * char = .76F+0 (used reg = )
31166 8663           BB                   CD26  mov	bx,#.76F
31167 8666           53                         push	bx
31168                                           ! Debug: list int = const 7 (used reg = )
31169 8667           B8                   0007  mov	ax,*7
31170 866A           50                         push	ax
31171                                           ! Debug: func () void = bios_printf+0 (used reg = )
31172 866B           E8         82D0            call	_bios_printf
31173 866E           89EC                       mov	sp,bp
31174                                           !BCC_EOS
31175                                           ! 5278   _write_byte(cyl, 0x0094+drive, 0x0040);
31176                       00008670            .76D:
31177                                           ! Debug: list int = const $40 (used reg = )
31178 8670           B8                   0040  mov	ax,*$40
31179 8673           50                         push	ax
31180                                           ! Debug: add unsigned char drive = [S+4+2] to int = const $94 (used reg = )
31181                                           ! Debug: expression subtree swapping
31182 8674           8A46         04            mov	al,4[bp]
31183 8677           30E4                       xor	ah,ah
31184                                           ! Debug: list unsigned int = ax+$94 (used reg = )
31185 8679           05                   0094  add	ax,#$94
31186 867C           50                         push	ax
31187                                           ! Debug: list unsigned char cyl = [S+6+4] (used reg = )
31188 867D           8A46         06            mov	al,6[bp]
31189 8680           30E4                       xor	ah,ah
31190 8682           50                         push	ax
31191                                           ! Debug: func () void = _write_byte+0 (used reg = )
31192 8683           E8         7F7A            call	__write_byte
31193 8686           89EC                       mov	sp,bp
31194                                           !BCC_EOS
31195                                           ! 5279 }
31196 8688           5D                         pop	bp
31197 8689           C3                         ret
31198                                           ! 5280   void
31199                                           ! Register BX used in function set_diskette_current_cyl
31200                                           ! 5281 determine_floppy_media(drive)
31201                                           ! 5282   Bit16u drive;
31202                                           export	_determine_floppy_media
31203                       0000868A            _determine_floppy_media:
31204                                           !BCC_EOS
31205                                           ! 5283 {
31206                                           ! 5284 }
31207 868A           C3                         ret
31208                                           ! 5285   void
31209                                           ! 5286 int17_function(regs, ds, iret_addr)
31210                                           ! 5287   pusha_regs_t regs;
31211                                           export	_int17_function
31212                       0000868B            _int17_function:
31213                                           !BCC_EOS
31214                                           ! 5288   Bit16u ds;
31215                                           !BCC_EOS
31216                                           ! 5289   iret_addr_t iret_addr;
31217                                           !BCC_EOS
31218                                           ! 5290 {
31219                                           ! 5291   Bit16u addr,timeout;
31220                                           !BCC_EOS
31221                                           ! 5292   Bit8u val8;
31222                                           !BCC_EOS
31223                                           ! 5293 #asm
31224 868B           55                         push	bp
31225 868C           89E5                       mov	bp,sp
31226 868E           83C4                   FA  add	sp,*-6
31227                                           !BCC_EOS
31228                                           !BCC_ASM
31229                       0000001A            _int17_function.ds	set	$1A
31230                       00000014            .int17_function.ds	set	$14
31231                       00000002            _int17_function.timeout	set	2
31232                       FFFFFFFC            .int17_function.timeout	set	-4
31233                       00000001            _int17_function.val8	set	1
31234                       FFFFFFFB            .int17_function.val8	set	-5
31235                       0000001C            _int17_function.iret_addr	set	$1C
31236                       00000016            .int17_function.iret_addr	set	$16
31237                       00000004            _int17_function.addr	set	4
31238                       FFFFFFFE            .int17_function.addr	set	-2
31239                       0000000A            _int17_function.regs	set	$A
31240                       00000004            .int17_function.regs	set	4
31241 8691           FB                           sti
31242                                           ! 5295 endasm
31243                                           !BCC_ENDASM
31244                                           !BCC_EOS
31245                                           ! 5296   addr = *((Bit16u *)(0x0400 + (regs.u.r16.dx << 1) + 8));
31246                                           ! Debug: sl int = const 1 to unsigned short regs = [S+8+$C] (used reg = )
31247 8692           8B46         0E            mov	ax,$E[bp]
31248 8695           D1E0                       shl	ax,*1
31249                                           ! Debug: add unsigned int = ax+0 to int = const $400 (used reg = )
31250                                           ! Debug: expression subtree swapping
31251                                           ! Debug: add int = const 8 to unsigned int = ax+$400 (used reg = )
31252                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$408 (used reg = )
31253 8697           89C3                       mov	bx,ax
31254                                           ! Debug: eq unsigned short = [bx+$408] to unsigned short addr = [S+8-4] (used reg = )
31255 8699           8B9F       0408            mov	bx,$408[bx]
31256 869D           895E         FE            mov	-2[bp],bx
31257                                           !BCC_EOS
31258                                           ! 5297   if ((regs.u.r8.ah < 3) && (regs.u.r16.dx < 3) && (addr > 0)) {
31259                                           ! Debug: lt int = const 3 to unsigned char regs = [S+8+$11] (used reg = )
31260 86A0           8A46         13            mov	al,$13[bp]
31261 86A3           3C                     03  cmp	al,*3
31262 86A5         0F83         00FD            bhis	.770
31263                       000086A9            .773:
31264                                           ! Debug: lt int = const 3 to unsigned short regs = [S+8+$C] (used reg = )
31265 86A9           8B46         0E            mov	ax,$E[bp]
31266 86AC           3D                   0003  cmp	ax,*3
31267 86AF         0F83         00F3            bhis	.770
31268                       000086B3            .772:
31269                                           ! Debug: gt int = const 0 to unsigned short addr = [S+8-4] (used reg = )
31270 86B3           8B46         FE            mov	ax,-2[bp]
31271 86B6           85C0                       test	ax,ax
31272 86B8         0F84         00EA            beq 	.770
31273                       000086BC            .771:
31274                                           ! 5298    
31275                                           ! 5298  *(((Bit8u *)&timeout)+1) = *((Bit8u *)(0x0478 + regs.u.r16.dx));
31276                                           ! Debug: add unsigned short regs = [S+8+$C] to int = const $478 (used reg = )
31277                                           ! Debug: expression subtree swapping
31278 86BC           8B46         0E            mov	ax,$E[bp]
31279                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$478 (used reg = )
31280 86BF           89C3                       mov	bx,ax
31281                                           ! Debug: eq unsigned char = [bx+$478] to unsigned char timeout = [S+8-5] (used reg = )
31282 86C1           8A87       0478            mov	al,$478[bx]
31283 86C5           8846         FD            mov	-3[bp],al
31284                                           !BCC_EOS
31285                                           ! 5299     *((Bit8u *)&timeout) = 0;
31286                                           ! Debug: eq int = const 0 to unsigned char timeout = [S+8-6] (used reg = )
31287 86C8           30C0                       xor	al,al
31288 86CA           8846         FC            mov	-4[bp],al
31289                                           !BCC_EOS
31290                                           ! 5300     if (regs.u.r8.ah == 0) {
31291                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+8+$11] (used reg = )
31292 86CD           8A46         13            mov	al,$13[bp]
31293 86D0           84C0                       test	al,al
31294 86D2           75           66            jne 	.774
31295                       000086D4            .775:
31296                                           ! 5301       outb(addr, regs.u.r8.al);
31297                                           ! Debug: list unsigned char regs = [S+8+$10] (used reg = )
31298 86D4           8A46         12            mov	al,$12[bp]
31299 86D7           30E4                       xor	ah,ah
31300 86D9           50                         push	ax
31301                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
31302 86DA           FF76         FE            push	-2[bp]
31303                                           ! Debug: func () void = outb+0 (used reg = )
31304 86DD           E8         7E2E            call	_outb
31305 86E0           83C4                   04  add	sp,*4
31306                                           !BCC_EOS
31307                                           ! 5302       val8 = inb(addr+2);
31308                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
31309 86E3           8B46         FE            mov	ax,-2[bp]
31310                                           ! Debug: list unsigned int = ax+2 (used reg = )
31311 86E6           40                         inc	ax
31312 86E7           40                         inc	ax
31313 86E8           50                         push	ax
31314                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31315 86E9           E8         7E0C            call	_inb
31316 86EC           44                         inc	sp
31317 86ED           44                         inc	sp
31318                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
31319 86EE           8846         FB            mov	-5[bp],al
31320                                           !BCC_EOS
31321                                           ! 5303       outb(addr+2, val8 | 0x01);
31322                                           ! Debug: or int = const 1 to unsigned char val8 = [S+8-7] (used reg = )
31323 86F1           8A46         FB            mov	al,-5[bp]
31324 86F4           0C                     01  or	al,*1
31325                                           ! Debug: list unsigned char = al+0 (used reg = )
31326 86F6           30E4                       xor	ah,ah
31327 86F8           50                         push	ax
31328                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
31329 86F9           8B46         FE            mov	ax,-2[bp]
31330                                           ! Debug: list unsigned int = ax+2 (used reg = )
31331 86FC           40                         inc	ax
31332 86FD           40                         inc	ax
31333 86FE           50                         push	ax
31334                                           ! Debug: func () void = outb+0 (used reg = )
31335 86FF           E8         7E0C            call	_outb
31336 8702           83C4                   04  add	sp,*4
31337                                           !BCC_EOS
31338                                           ! 5304 #asm
31339                                           !BCC_EOS
31340                                           !BCC_ASM
31341                       0000001A            _int17_function.ds	set	$1A
31342                       00000014            .int17_function.ds	set	$14
31343                       00000002            _int17_function.timeout	set	2
31344                       FFFFFFFC            .int17_function.timeout	set	-4
31345                       00000001            _int17_function.val8	set	1
31346                       FFFFFFFB            .int17_function.val8	set	-5
31347                       0000001C            _int17_function.iret_addr	set	$1C
31348                       00000016            .int17_function.iret_addr	set	$16
31349                       00000004            _int17_function.addr	set	4
31350                       FFFFFFFE            .int17_function.addr	set	-2
31351                       0000000A            _int17_function.regs	set	$A
31352                       00000004            .int17_function.regs	set	4
31353 8705           90                               nop
31354                                           ! 5306 endasm
31355                                           !BCC_ENDASM
31356                                           !BCC_EOS
31357                                           ! 5307       outb(addr+2, val8 & ~0x01);
31358                                           ! Debug: and int = const -2 to unsigned char val8 = [S+8-7] (used reg = )
31359 8706           8A46         FB            mov	al,-5[bp]
31360 8709           24                     FE  and	al,#$FE
31361                                           ! Debug: list unsigned char = al+0 (used reg = )
31362 870B           30E4                       xor	ah,ah
31363 870D           50                         push	ax
31364                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
31365 870E           8B46         FE            mov	ax,-2[bp]
31366                                           ! Debug: list unsigned int = ax+2 (used reg = )
31367 8711           40                         inc	ax
31368 8712           40                         inc	ax
31369 8713           50                         push	ax
31370                                           ! Debug: func () void = outb+0 (used reg = )
31371 8714           E8         7DF7            call	_outb
31372 8717           83C4                   04  add	sp,*4
31373                                           !BCC_EOS
31374                                           ! 5308       while (((inb(addr+1) & 0x40) == 0x40) && (timeout)) {
31375 871A           EB           07            jmp .777
31376                       0000871C            .778:
31377                                           ! 5309         timeout--;
31378                                           ! Debug: postdec unsigned short timeout = [S+8-6] (used reg = )
31379 871C           8B46         FC            mov	ax,-4[bp]
31380 871F           48                         dec	ax
31381 8720           8946         FC            mov	-4[bp],ax
31382                                           !BCC_EOS
31383                                           ! 5310       }
31384                                           ! 5311     }
31385                       00008723            .777:
31386                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
31387 8723           8B46         FE            mov	ax,-2[bp]
31388                                           ! Debug: list unsigned int = ax+1 (used reg = )
31389 8726           40                         inc	ax
31390 8727           50                         push	ax
31391                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31392 8728           E8         7DCD            call	_inb
31393 872B           44                         inc	sp
31394 872C           44                         inc	sp
31395                                           ! Debug: and int = const $40 to unsigned char = al+0 (used reg = )
31396 872D           24                     40  and	al,*$40
31397                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
31398 872F           3C                     40  cmp	al,*$40
31399 8731           75           07            jne 	.779
31400                       00008733            .77A:
31401 8733           8B46         FC            mov	ax,-4[bp]
31402 8736           85C0                       test	ax,ax
31403 8738           75           E2            jne	.778
31404                       0000873A            .779:
31405                       0000873A            .776:
31406                                           ! 5312     if (regs.u.r8.ah == 1) {
31407                       0000873A            .774:
31408                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
31409 873A           8A46         13            mov	al,$13[bp]
31410 873D           3C                     01  cmp	al,*1
31411 873F           75           37            jne 	.77B
31412                       00008741            .77C:
31413                                           ! 5313       val8 = inb(addr+2);
31414                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
31415 8741           8B46         FE            mov	ax,-2[bp]
31416                                           ! Debug: list unsigned int = ax+2 (used reg = )
31417 8744           40                         inc	ax
31418 8745           40                         inc	ax
31419 8746           50                         push	ax
31420                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31421 8747           E8         7DAE            call	_inb
31422 874A           44                         inc	sp
31423 874B           44                         inc	sp
31424                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
31425 874C           8846         FB            mov	-5[bp],al
31426                                           !BCC_EOS
31427                                           ! 5314       outb(addr+2, val8 & ~0x04);
31428                                           ! Debug: and int = const -5 to unsigned char val8 = [S+8-7] (used reg = )
31429 874F           8A46         FB            mov	al,-5[bp]
31430 8752           24                     FB  and	al,#$FB
31431                                           ! Debug: list unsigned char = al+0 (used reg = )
31432 8754           30E4                       xor	ah,ah
31433 8756           50                         push	ax
31434                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
31435 8757           8B46         FE            mov	ax,-2[bp]
31436                                           ! Debug: list unsigned int = ax+2 (used reg = )
31437 875A           40                         inc	ax
31438 875B           40                         inc	ax
31439 875C           50                         push	ax
31440                                           ! Debug: func () void = outb+0 (used reg = )
31441 875D           E8         7DAE            call	_outb
31442 8760           83C4                   04  add	sp,*4
31443                                           !BCC_EOS
31444                                           ! 5315 #asm
31445                                           !BCC_EOS
31446                                           !BCC_ASM
31447                       0000001A            _int17_function.ds	set	$1A
31448                       00000014            .int17_function.ds	set	$14
31449                       00000002            _int17_function.timeout	set	2
31450                       FFFFFFFC            .int17_function.timeout	set	-4
31451                       00000001            _int17_function.val8	set	1
31452                       FFFFFFFB            .int17_function.val8	set	-5
31453                       0000001C            _int17_function.iret_addr	set	$1C
31454                       00000016            .int17_function.iret_addr	set	$16
31455                       00000004            _int17_function.addr	set	4
31456                       FFFFFFFE            .int17_function.addr	set	-2
31457                       0000000A            _int17_function.regs	set	$A
31458                       00000004            .int17_function.regs	set	4
31459 8763           90                               nop
31460                                           ! 5317 endasm
31461                                           !BCC_ENDASM
31462                                           !BCC_EOS
31463                                           ! 5318       outb(addr+2, val8 | 0x04);
31464                                           ! Debug: or int = const 4 to unsigned char val8 = [S+8-7] (used reg = )
31465 8764           8A46         FB            mov	al,-5[bp]
31466 8767           0C                     04  or	al,*4
31467                                           ! Debug: list unsigned char = al+0 (used reg = )
31468 8769           30E4                       xor	ah,ah
31469 876B           50                         push	ax
31470                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
31471 876C           8B46         FE            mov	ax,-2[bp]
31472                                           ! Debug: list unsigned int = ax+2 (used reg = )
31473 876F           40                         inc	ax
31474 8770           40                         inc	ax
31475 8771           50                         push	ax
31476                                           ! Debug: func () void = outb+0 (used reg = )
31477 8772           E8         7D99            call	_outb
31478 8775           83C4                   04  add	sp,*4
31479                                           !BCC_EOS
31480                                           ! 5319     }
31481                                           ! 5320     val8 = inb(addr+1);
31482                       00008778            .77B:
31483                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
31484 8778           8B46         FE            mov	ax,-2[bp]
31485                                           ! Debug: list unsigned int = ax+1 (used reg = )
31486 877B           40                         inc	ax
31487 877C           50                         push	ax
31488                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31489 877D           E8         7D78            call	_inb
31490 8780           44                         inc	sp
31491 8781           44                         inc	sp
31492                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
31493 8782           8846         FB            mov	-5[bp],al
31494                                           !BCC_EOS
31495                                           ! 5321     regs.u.r8.ah = (val8 ^ 0x48);
31496                                           ! Debug: eor int = const $48 to unsigned char val8 = [S+8-7] (used reg = )
31497 8785           8A46         FB            mov	al,-5[bp]
31498 8788           34                     48  xor	al,*$48
31499                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+8+$11] (used reg = )
31500 878A           8846         13            mov	$13[bp],al
31501                                           !BCC_EOS
31502                                           ! 5322     if (!timeout) regs.u.r8.ah |= 0x01;
31503 878D           8B46         FC            mov	ax,-4[bp]
31504 8790           85C0                       test	ax,ax
31505 8792           75           08            jne 	.77D
31506                       00008794            .77E:
31507                                           ! Debug: orab int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
31508 8794           8A46         13            mov	al,$13[bp]
31509 8797           0C                     01  or	al,*1
31510 8799           8846         13            mov	$13[bp],al
31511                                           !BCC_EOS
31512                                           ! 5323     iret_addr.flags.u.r8.flagsl &= 0xfe;
31513                       0000879C            .77D:
31514                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+8+$18] (used reg = )
31515 879C           8A46         1A            mov	al,$1A[bp]
31516 879F           24                     FE  and	al,#$FE
31517 87A1           8846         1A            mov	$1A[bp],al
31518                                           !BCC_EOS
31519                                           ! 5324   } else {
31520 87A4           EB           08            jmp .77F
31521                       000087A6            .770:
31522                                           ! 5325     iret_addr.flags.u.r8.flagsl |= 0x01;
31523                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+8+$18] (used reg = )
31524 87A6           8A46         1A            mov	al,$1A[bp]
31525 87A9           0C                     01  or	al,*1
31526 87AB           8846         1A            mov	$1A[bp],al
31527                                           !BCC_EOS
31528                                           ! 5326   }
31529                                           ! 5327 }
31530                       000087AE            .77F:
31531 87AE           89EC                       mov	sp,bp
31532 87B0           5D                         pop	bp
31533 87B1           C3                         ret
31534                                           ! 5328 void
31535                                           ! Register BX used in function int17_function
31536                                           ! 5329 int19_function(seq_nr)
31537                                           ! 5330 Bit16u seq_nr;
31538                                           export	_int19_function
31539                       000087B2            _int19_function:
31540                                           !BCC_EOS
31541                                           ! 5331 {
31542                                           ! 5332   Bit16u ebda_seg=*((Bit16u *)(0x040E));
31543 87B2           55                         push	bp
31544 87B3           89E5                       mov	bp,sp
31545 87B5           4C                         dec	sp
31546 87B6           4C                         dec	sp
31547                                           ! Debug: eq unsigned short = [+$40E] to unsigned short ebda_seg = [S+4-4] (used reg = )
31548 87B7           A1         040E            mov	ax,[$40E]
31549 87BA           8946         FE            mov	-2[bp],ax
31550                                           !BCC_EOS
31551                                           ! 5333   Bit16u bootdev;
31552                                           !BCC_EOS
31553                                           ! 5334   Bit8u bootdrv;
31554                                           !BCC_EOS
31555                                           ! 5335   Bit8u bootchk;
31556                                           !BCC_EOS
31557                                           ! 5336   Bit16u bootseg;
31558                                           !BCC_EOS
31559                                           ! 5337   Bit16u bootip;
31560                                           !BCC_EOS
31561                                           ! 5338   Bit16u status;
31562                                           !BCC_EOS
31563                                           ! 5339   Bit16u bootfirst;
31564                                           !BCC_EOS
31565                                           ! 5340   ipl_entry_t e;
31566                                           !BCC_EOS
31567                                           ! 5341   bootdev = inb_cmos(0x3d);
31568 87BD           83C4                   E4  add	sp,*-$1C
31569                                           ! Debug: list int = const $3D (used reg = )
31570 87C0           B8                   003D  mov	ax,*$3D
31571 87C3           50                         push	ax
31572                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
31573 87C4           E8         7D76            call	_inb_cmos
31574 87C7           44                         inc	sp
31575 87C8           44                         inc	sp
31576                                           ! Debug: eq unsigned char = al+0 to unsigned short bootdev = [S+$20-6] (used reg = )
31577 87C9           30E4                       xor	ah,ah
31578 87CB           8946         FC            mov	-4[bp],ax
31579                                           !BCC_EOS
31580                                           ! 5342   bootdev |= ((inb_cmos(0x38) & 0xf0) << 4);
31581                                           ! Debug: list int = const $38 (used reg = )
31582 87CE           B8                   0038  mov	ax,*$38
31583 87D1           50                         push	ax
31584                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
31585 87D2           E8         7D68            call	_inb_cmos
31586 87D5           44                         inc	sp
31587 87D6           44                         inc	sp
31588                                           ! Debug: and int = const $F0 to unsigned char = al+0 (used reg = )
31589 87D7           24                     F0  and	al,#$F0
31590                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
31591 87D9           30E4                       xor	ah,ah
31592 87DB           B1                     04  mov	cl,*4
31593 87DD           D3E0                       shl	ax,cl
31594                                           ! Debug: orab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
31595 87DF           0B46         FC            or	ax,-4[bp]
31596 87E2           8946         FC            mov	-4[bp],ax
31597                                           !BCC_EOS
31598                                           ! 5343   bootdev >>= 4 * seq_nr;
31599                                           ! Debug: mul unsigned short seq_nr = [S+$20+2] to int = const 4 (used reg = )
31600                                           ! Debug: expression subtree swapping
31601 87E5           8B46         04            mov	ax,4[bp]
31602 87E8           D1E0                       shl	ax,*1
31603 87EA           D1E0                       shl	ax,*1
31604                                           ! Debug: srab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
31605 87EC           89C3                       mov	bx,ax
31606 87EE           8B46         FC            mov	ax,-4[bp]
31607 87F1           89D9                       mov	cx,bx
31608 87F3           D3E8                       shr	ax,cl
31609 87F5           8946         FC            mov	-4[bp],ax
31610                                           !BCC_EOS
31611                                           ! 5344   bootdev &= 0xf;
31612                                           ! Debug: andab int = const $F to unsigned short bootdev = [S+$20-6] (used reg = )
31613 87F8           8A46         FC            mov	al,-4[bp]
31614 87FB           24                     0F  and	al,*$F
31615 87FD           30E4                       xor	ah,ah
31616 87FF           8946         FC            mov	-4[bp],ax
31617                                           !BCC_EOS
31618                                           ! 5345   bootfirst = _read_word(0x0084, 0x9ff0);
31619                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
31620 8802           B8                   9FF0  mov	ax,#$9FF0
31621 8805           50                         push	ax
31622                                           ! Debug: list int = const $84 (used reg = )
31623 8806           B8                   0084  mov	ax,#$84
31624 8809           50                         push	ax
31625                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
31626 880A           E8         7DE5            call	__read_word
31627 880D           83C4                   04  add	sp,*4
31628                                           ! Debug: eq unsigned short = ax+0 to unsigned short bootfirst = [S+$20-$10] (used reg = )
31629 8810           8946         F2            mov	-$E[bp],ax
31630                                           !BCC_EOS
31631                                           ! 5346   if (bootfirst != 0xFFFF) {
31632                                           ! Debug: ne unsigned int = const $FFFF to unsigned short bootfirst = [S+$20-$10] (used reg = )
31633 8813           8B46         F2            mov	ax,-$E[bp]
31634 8816           3D                   FFFF  cmp	ax,#$FFFF
31635 8819           74           2C            je  	.780
31636                       0000881B            .781:
31637                                           ! 5347     bootdev = bootfirst;
31638                                           ! Debug: eq unsigned short bootfirst = [S+$20-$10] to unsigned short bootdev = [S+$20-6] (used reg = )
31639 881B           8B46         F2            mov	ax,-$E[bp]
31640 881E           8946         FC            mov	-4[bp],ax
31641                                           !BCC_EOS
31642                                           ! 5348     _write_word(0xFFFF, 0x0084, 0x9ff0);
31643                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
31644 8821           B8                   9FF0  mov	ax,#$9FF0
31645 8824           50                         push	ax
31646                                           ! Debug: list int = const $84 (used reg = )
31647 8825           B8                   0084  mov	ax,#$84
31648 8828           50                         push	ax
31649                                           ! Debug: list unsigned int = const $FFFF (used reg = )
31650 8829           B8                   FFFF  mov	ax,#$FFFF
31651 882C           50                         push	ax
31652                                           ! Debug: func () void = _write_word+0 (used reg = )
31653 882D           E8         7DE3            call	__write_word
31654 8830           83C4                   06  add	sp,*6
31655                                           !BCC_EOS
31656                                           ! 5349     _write_word(0xFFFF, 0x0082, 0x9ff0);
31657                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
31658 8833           B8                   9FF0  mov	ax,#$9FF0
31659 8836           50                         push	ax
31660                                           ! Debug: list int = const $82 (used reg = )
31661 8837           B8                   0082  mov	ax,#$82
31662 883A           50                         push	ax
31663                                           ! Debug: list unsigned int = const $FFFF (used reg = )
31664 883B           B8                   FFFF  mov	ax,#$FFFF
31665 883E           50                         push	ax
31666                                           ! Debug: func () void = _write_word+0 (used reg = )
31667 883F           E8         7DD1            call	__write_word
31668 8842           83C4                   06  add	sp,*6
31669                                           !BCC_EOS
31670                                           ! 5350   } else if (bootdev == 0) bios_printf((2 | 4 | 1), "No bootable device.\n");
31671 8845           EB           15            jmp .782
31672                       00008847            .780:
31673                                           ! Debug: logeq int = const 0 to unsigned short bootdev = [S+$20-6] (used reg = )
31674 8847           8B46         FC            mov	ax,-4[bp]
31675 884A           85C0                       test	ax,ax
31676 884C           75           0E            jne 	.783
31677                       0000884E            .784:
31678                                           ! Debug: list * char = .785+0 (used reg = )
31679 884E           BB                   CD11  mov	bx,#.785
31680 8851           53                         push	bx
31681                                           ! Debug: list int = const 7 (used reg = )
31682 8852           B8                   0007  mov	ax,*7
31683 8855           50                         push	ax
31684                                           ! Debug: func () void = bios_printf+0 (used reg = )
31685 8856           E8         80E5            call	_bios_printf
31686 8859           83C4                   04  add	sp,*4
31687                                           !BCC_EOS
31688                                           ! 5351   bootdev -= 1;
31689                       0000885C            .783:
31690                       0000885C            .782:
31691                                           ! Debug: subab int = const 1 to unsigned short bootdev = [S+$20-6] (used reg = )
31692 885C           8B46         FC            mov	ax,-4[bp]
31693 885F           48                         dec	ax
31694 8860           8946         FC            mov	-4[bp],ax
31695                                           !BCC_EOS
31696                                           ! 5352   if (get_boot_vector(bootdev, &e) == 0) {
31697                                           ! Debug: list * struct  e = S+$20-$20 (used reg = )
31698 8863           8D5E         E2            lea	bx,-$1E[bp]
31699 8866           53                         push	bx
31700                                           ! Debug: list unsigned short bootdev = [S+$22-6] (used reg = )
31701 8867           FF76         FC            push	-4[bp]
31702                                           ! Debug: func () unsigned char = get_boot_vector+0 (used reg = )
31703 886A           E8         8B03            call	_get_boot_vector
31704 886D           83C4                   04  add	sp,*4
31705                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
31706 8870           84C0                       test	al,al
31707 8872           75           15            jne 	.786
31708                       00008874            .787:
31709                                           ! 5353     bios_printf(4, "Invalid boot device (0x%x)\n", bootdev);
31710                                           ! Debug: list unsigned short bootdev = [S+$20-6] (used reg = )
31711 8874           FF76         FC            push	-4[bp]
31712                                           ! Debug: list * char = .788+0 (used reg = )
31713 8877           BB                   CCF5  mov	bx,#.788
31714 887A           53                         push	bx
31715                                           ! Debug: list int = const 4 (used reg = )
31716 887B           B8                   0004  mov	ax,*4
31717 887E           50                         push	ax
31718                                           ! Debug: func () void = bios_printf+0 (used reg = )
31719 887F           E8         80BC            call	_bios_printf
31720 8882           83C4                   06  add	sp,*6
31721                                           !BCC_EOS
31722                                           ! 5354     return;
31723 8885           89EC                       mov	sp,bp
31724 8887           5D                         pop	bp
31725 8888           C3                         ret
31726                                           !BCC_EOS
31727                                           ! 5355   }
31728                                           ! 5356   print_boot_device(&e);
31729                       00008889            .786:
31730                                           ! Debug: list * struct  e = S+$20-$20 (used reg = )
31731 8889           8D5E         E2            lea	bx,-$1E[bp]
31732 888C           53                         push	bx
31733                                           ! Debug: func () void = print_boot_device+0 (used reg = )
31734 888D           E8         8D29            call	_print_boot_device
31735 8890           44                         inc	sp
31736 8891           44                         inc	sp
31737                                           !BCC_EOS
31738                                           ! 5357   switch(e.type) {
31739 8892           8B46         E2            mov	ax,-$1E[bp]
31740 8895           E9         0106            br 	.78B
31741                                           ! 5358   case 0x01:
31742                                           ! 5359   case 0x02:
31743                       00008898            .78C:
31744                                           ! 5360     bootdrv = (e.type == 0x02) ? 0x80 : 0x00;
31745                       00008898            .78D:
31746                                           ! Debug: logeq int = const 2 to unsigned short e = [S+$20-$20] (used reg = )
31747 8898           8B46         E2            mov	ax,-$1E[bp]
31748 889B           3D                   0002  cmp	ax,*2
31749 889E           75           04            jne 	.78E
31750                       000088A0            .78F:
31751 88A0           B0                     80  mov	al,#$80
31752 88A2           EB           02            jmp .790
31753                       000088A4            .78E:
31754 88A4           30C0                       xor	al,al
31755                       000088A6            .790:
31756                                           ! Debug: eq char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
31757 88A6           8846         FB            mov	-5[bp],al
31758                                           !BCC_EOS
31759                                           ! 5361     bootseg = 0x07c0;
31760                                           ! Debug: eq int = const $7C0 to unsigned short bootseg = [S+$20-$A] (used reg = )
31761 88A9           B8                   07C0  mov	ax,#$7C0
31762 88AC           8946         F8            mov	-8[bp],ax
31763                                           !BCC_EOS
31764                                           ! 5362     status = 0;
31765                                           ! Debug: eq int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
31766 88AF           31C0                       xor	ax,ax
31767 88B1           8946         F4            mov	-$C[bp],ax
31768                                           !BCC_EOS
31769                                           ! 5363 #asm
31770                                           !BCC_EOS
31771                                           !BCC_ASM
31772                       00000014            _int19_function.bootip	set	$14
31773                       FFFFFFF6            .int19_function.bootip	set	-$A
31774                       00000022            _int19_function.seq_nr	set	$22
31775                       00000004            .int19_function.seq_nr	set	4
31776                       00000018            _int19_function.bootchk	set	$18
31777                       FFFFFFFA            .int19_function.bootchk	set	-6
31778                       00000016            _int19_function.bootseg	set	$16
31779                       FFFFFFF8            .int19_function.bootseg	set	-8
31780                       0000001C            _int19_function.ebda_seg	set	$1C
31781                       FFFFFFFE            .int19_function.ebda_seg	set	-2
31782                       00000012            _int19_function.status	set	$12
31783                       FFFFFFF4            .int19_function.status	set	-$C
31784                       00000010            _int19_function.bootfirst	set	$10
31785                       FFFFFFF2            .int19_function.bootfirst	set	-$E
31786                       00000019            _int19_function.bootdrv	set	$19
31787                       FFFFFFFB            .int19_function.bootdrv	set	-5
31788                       0000001A            _int19_function.bootdev	set	$1A
31789                       FFFFFFFC            .int19_function.bootdev	set	-4
31790                       00000000            _int19_function.e	set	0
31791                       FFFFFFE2            .int19_function.e	set	-$1E
31792 88B4           55                             push bp
31793 88B5           89E5                           mov bp, sp
31794 88B7           50                             push ax
31795 88B8           53                             push bx
31796 88B9           51                             push cx
31797 88BA           52                             push dx
31798 88BB           8A56         1B                mov dl, _int19_function.bootdrv + 2[bp]
31799 88BE           8B46         18                mov ax, _int19_function.bootseg + 2[bp]
31800 88C1           8EC0                           mov es, ax ;; segment
31801 88C3           31DB                           xor bx, bx ;; offset
31802 88C5           B4                     02      mov ah, #0x02 ;; function 2, read diskette sector
31803 88C7           B0                     01      mov al, #0x01 ;; read 1 sector
31804 88C9           B5                     00      mov ch, #0x00 ;; track 0
31805 88CB           B1                     01      mov cl, #0x01 ;; sector 1
31806 88CD           B6                     00      mov dh, #0x00 ;; head 0
31807 88CF           CD                     13      int #0x13 ;; read sector
31808 88D1           73           06                jnc int19_load_done
31809 88D3           B8                   0001      mov ax, #0x0001
31810 88D6           8946         14                mov _int19_function.status + 2[bp], ax
31811                       000088D9            int19_load_done:
31812 88D9           5A                             pop dx
31813 88DA           59                             pop cx
31814 88DB           5B                             pop bx
31815 88DC           58                             pop ax
31816 88DD           5D                             pop bp
31817                                           ! 5389 endasm
31818                                           !BCC_ENDASM
31819                                           !BCC_EOS
31820                                           ! 5390     if (status != 0) {
31821                                           ! Debug: ne int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
31822 88DE           8B46         F4            mov	ax,-$C[bp]
31823 88E1           85C0                       test	ax,ax
31824 88E3           74           11            je  	.791
31825                       000088E5            .792:
31826                                           ! 5391       print_boot_failure(e.type, 1);
31827                                           ! Debug: list int = const 1 (used reg = )
31828 88E5           B8                   0001  mov	ax,*1
31829 88E8           50                         push	ax
31830                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
31831 88E9           FF76         E2            push	-$1E[bp]
31832                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
31833 88EC           E8         8D94            call	_print_boot_failure
31834 88EF           83C4                   04  add	sp,*4
31835                                           !BCC_EOS
31836                                           ! 5392       return;
31837 88F2           89EC                       mov	sp,bp
31838 88F4           5D                         pop	bp
31839 88F5           C3                         ret
31840                                           !BCC_EOS
31841                                           ! 5393     }
31842                                           ! 5394     if ((e.type != 0x01) || !((inb_cmos(0x38) & 0x01))) {
31843                       000088F6            .791:
31844                                           ! Debug: ne int = const 1 to unsigned short e = [S+$20-$20] (used reg = )
31845 88F6           8B46         E2            mov	ax,-$1E[bp]
31846 88F9           3D                   0001  cmp	ax,*1
31847 88FC           75           0F            jne 	.794
31848                       000088FE            .795:
31849                                           ! Debug: list int = const $38 (used reg = )
31850 88FE           B8                   0038  mov	ax,*$38
31851 8901           50                         push	ax
31852                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
31853 8902           E8         7C38            call	_inb_cmos
31854 8905           44                         inc	sp
31855 8906           44                         inc	sp
31856                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
31857 8907           24                     01  and	al,*1
31858 8909           84C0                       test	al,al
31859 890B           75           22            jne 	.793
31860                       0000890D            .794:
31861                                           ! 5395       if (_read_word(0x1fe, bootseg) != 0xaa55) {
31862                                           ! Debug: list unsigned short bootseg = [S+$20-$A] (used reg = )
31863 890D           FF76         F8            push	-8[bp]
31864                                           ! Debug: list int = const $1FE (used reg = )
31865 8910           B8                   01FE  mov	ax,#$1FE
31866 8913           50                         push	ax
31867                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
31868 8914           E8         7CDB            call	__read_word
31869 8917           83C4                   04  add	sp,*4
31870                                           ! Debug: ne unsigned int = const $AA55 to unsigned short = ax+0 (used reg = )
31871 891A           3D                   AA55  cmp	ax,#$AA55
31872 891D           74           10            je  	.796
31873                       0000891F            .797:
31874                                           ! 5396         print_boot_failure(e.type, 0);
31875                                           ! Debug: list int = const 0 (used reg = )
31876 891F           31C0                       xor	ax,ax
31877 8921           50                         push	ax
31878                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
31879 8922           FF76         E2            push	-$1E[bp]
31880                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
31881 8925           E8         8D5B            call	_print_boot_failure
31882 8928           83C4                   04  add	sp,*4
31883                                           !BCC_EOS
31884                                           ! 5397         return;
31885 892B           89EC                       mov	sp,bp
31886 892D           5D                         pop	bp
31887 892E           C3                         ret
31888                                           !BCC_EOS
31889                                           ! 5398       }
31890                                           ! 5399     }
31891                       0000892F            .796:
31892                                           ! 5400     bootip = (bootseg & 0x0fff) << 4;
31893                       0000892F            .793:
31894                                           ! Debug: and int = const $FFF to unsigned short bootseg = [S+$20-$A] (used reg = )
31895 892F           8B46         F8            mov	ax,-8[bp]
31896 8932           25                   0FFF  and	ax,#$FFF
31897                                           ! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
31898 8935           B1                     04  mov	cl,*4
31899 8937           D3E0                       shl	ax,cl
31900                                           ! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$20-$C] (used reg = )
31901 8939           8946         F6            mov	-$A[bp],ax
31902                                           !BCC_EOS
31903                                           ! 5401     bootseg &= 0xf000;
31904                                           ! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$20-$A] (used reg = )
31905 893C           8B46         F8            mov	ax,-8[bp]
31906 893F           25                   F000  and	ax,#$F000
31907 8942           8946         F8            mov	-8[bp],ax
31908                                           !BCC_EOS
31909                                           ! 5402   break;
31910 8945           EB           71            jmp .789
31911                                           !BCC_EOS
31912                                           ! 5403   case 0x03:
31913                                           ! 5404     status = cdrom_boot();
31914                       00008947            .798:
31915                                           ! Debug: func () unsigned short = cdrom_boot+0 (used reg = )
31916 8947           E8         AC72            call	_cdrom_boot
31917                                           ! Debug: eq unsigned short = ax+0 to unsigned short status = [S+$20-$E] (used reg = )
31918 894A           8946         F4            mov	-$C[bp],ax
31919                                           !BCC_EOS
31920                                           ! 5405     if ( (status & 0x00ff) !=0 ) {
31921                                           ! Debug: and int = const $FF to unsigned short status = [S+$20-$E] (used reg = )
31922 894D           8A46         F4            mov	al,-$C[bp]
31923                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
31924 8950           84C0                       test	al,al
31925 8952           74           19            je  	.799
31926                       00008954            .79A:
31927                                           ! 5406       print_cdromboot_failure(status);
31928                                           ! Debug: list unsigned short status = [S+$20-$E] (used reg = )
31929 8954           FF76         F4            push	-$C[bp]
31930                                           ! Debug: func () void = print_cdromboot_failure+0 (used reg = )
31931 8957           E8         8D8F            call	_print_cdromboot_failure
31932 895A           44                         inc	sp
31933 895B           44                         inc	sp
31934                                           !BCC_EOS
31935                                           ! 5407       print_boot_failure(e.type, 1);
31936                                           ! Debug: list int = const 1 (used reg = )
31937 895C           B8                   0001  mov	ax,*1
31938 895F           50                         push	ax
31939                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
31940 8960           FF76         E2            push	-$1E[bp]
31941                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
31942 8963           E8         8D1D            call	_print_boot_failure
31943 8966           83C4                   04  add	sp,*4
31944                                           !BCC_EOS
31945                                           ! 5408       return;
31946 8969           89EC                       mov	sp,bp
31947 896B           5D                         pop	bp
31948 896C           C3                         ret
31949                                           !BCC_EOS
31950                                           ! 5409     }
31951                                           ! 5410     bootdrv = *(((Bit8u *)&status)+1);
31952                       0000896D            .799:
31953                                           ! Debug: eq unsigned char status = [S+$20-$D] to unsigned char bootdrv = [S+$20-7] (used reg = )
31954 896D           8A46         F5            mov	al,-$B[bp]
31955 8970           8846         FB            mov	-5[bp],al
31956                                           !BCC_EOS
31957                                           ! 5411     bootseg = _read_word(&((ebda_data_t *) 0)->cdemu.load_segment, ebda_seg);
31958                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
31959 8973           FF76         FE            push	-2[bp]
31960                                           ! Debug: list * unsigned short = const $266 (used reg = )
31961 8976           B8                   0266  mov	ax,#$266
31962 8979           50                         push	ax
31963                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
31964 897A           E8         7C75            call	__read_word
31965 897D           83C4                   04  add	sp,*4
31966                                           ! Debug: eq unsigned short = ax+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
31967 8980           8946         F8            mov	-8[bp],ax
31968                                           !BCC_EOS
31969                                           ! 5412     bootip = 0;
31970                                           ! Debug: eq int = const 0 to unsigned short bootip = [S+$20-$C] (used reg = )
31971 8983           31C0                       xor	ax,ax
31972 8985           8946         F6            mov	-$A[bp],ax
31973                                           !BCC_EOS
31974                                           ! 5413     break;
31975 8988           EB           2E            jmp .789
31976                                           !BCC_EOS
31977                                           ! 5414   case 0x80:
31978                                           ! 5415     bootseg = *(((Bit16u *)&e.vector)+1);
31979                       0000898A            .79B:
31980                                           ! Debug: eq unsigned short e = [S+$20-$1A] to unsigned short bootseg = [S+$20-$A] (used reg = )
31981 898A           8B46         E8            mov	ax,-$18[bp]
31982 898D           8946         F8            mov	-8[bp],ax
31983                                           !BCC_EOS
31984                                           ! 5416     bootip = *((Bit16u *)&e.vector);
31985                                           ! Debug: eq unsigned short e = [S+$20-$1C] to unsigned short bootip = [S+$20-$C] (used reg = )
31986 8990           8B46         E6            mov	ax,-$1A[bp]
31987 8993           8946         F6            mov	-$A[bp],ax
31988                                           !BCC_EOS
31989                                           ! 5417     break;
31990 8996           EB           20            jmp .789
31991                                           !BCC_EOS
31992                                           ! 5418   default: return;
31993                       00008998            .79C:
31994 8998           89EC                       mov	sp,bp
31995 899A           5D                         pop	bp
31996 899B           C3                         ret
31997                                           !BCC_EOS
31998                                           ! 5419   }
31999                                           ! 5420   bios_printf(4, "Booting from %x:%x\n", bootseg, bootip);
32000 899C           EB           1A            jmp .789
32001                       0000899E            .78B:
32002 899E           2D                   0001  sub	ax,*1
32003 89A1         0F84         FEF3            beq 	.78C
32004 89A5           2D                   0001  sub	ax,*1
32005 89A8         0F84         FEEC            beq 	.78D
32006 89AC           2D                   0001  sub	ax,*1
32007 89AF           74           96            je 	.798
32008 89B1           2D                   007D  sub	ax,*$7D
32009 89B4           74           D4            je 	.79B
32010 89B6           EB           E0            jmp	.79C
32011                       000089B8            .789:
32012                       FFFFFFE0            ..FFD9	=	-$20
32013                                           ! Debug: list unsigned short bootip = [S+$20-$C] (used reg = )
32014 89B8           FF76         F6            push	-$A[bp]
32015                                           ! Debug: list unsigned short bootseg = [S+$22-$A] (used reg = )
32016 89BB           FF76         F8            push	-8[bp]
32017                                           ! Debug: list * char = .79D+0 (used reg = )
32018 89BE           BB                   CCE1  mov	bx,#.79D
32019 89C1           53                         push	bx
32020                                           ! Debug: list int = const 4 (used reg = )
32021 89C2           B8                   0004  mov	ax,*4
32022 89C5           50                         push	ax
32023                                           ! Debug: func () void = bios_printf+0 (used reg = )
32024 89C6           E8         7F75            call	_bios_printf
32025 89C9           83C4                   08  add	sp,*8
32026                                           !BCC_EOS
32027                                           ! 5421 #asm
32028                                           !BCC_EOS
32029                                           !BCC_ASM
32030                       00000014            _int19_function.bootip	set	$14
32031                       FFFFFFF6            .int19_function.bootip	set	-$A
32032                       00000022            _int19_function.seq_nr	set	$22
32033                       00000004            .int19_function.seq_nr	set	4
32034                       00000018            _int19_function.bootchk	set	$18
32035                       FFFFFFFA            .int19_function.bootchk	set	-6
32036                       00000016            _int19_function.bootseg	set	$16
32037                       FFFFFFF8            .int19_function.bootseg	set	-8
32038                       0000001C            _int19_function.ebda_seg	set	$1C
32039                       FFFFFFFE            .int19_function.ebda_seg	set	-2
32040                       00000012            _int19_function.status	set	$12
32041                       FFFFFFF4            .int19_function.status	set	-$C
32042                       00000010            _int19_function.bootfirst	set	$10
32043                       FFFFFFF2            .int19_function.bootfirst	set	-$E
32044                       00000019            _int19_function.bootdrv	set	$19
32045                       FFFFFFFB            .int19_function.bootdrv	set	-5
32046                       0000001A            _int19_function.bootdev	set	$1A
32047                       FFFFFFFC            .int19_function.bootdev	set	-4
32048                       00000000            _int19_function.e	set	0
32049                       FFFFFFE2            .int19_function.e	set	-$1E
32050 89CC           89E5                           mov bp, sp
32051 89CE           0E                             push cs
32052 89CF           68                   9282      push #int18_handler
32053                                               ;; Build an iret stack frame that will take us to the boot vector.
32054                                               ;; iret pops ip, then cs, then flags, so push them in the opposite order.
32055 89D2           9C                             pushf
32056 89D3           8B46         16                mov ax, _int19_function.bootseg + 0[bp]
32057 89D6           50                             push ax
32058 89D7           8B46         14                mov ax, _int19_function.bootip + 0[bp]
32059 89DA           50                             push ax
32060                                               ;; Set the magic number in ax and the boot drive in dl.
32061 89DB           B8                   AA55      mov ax, #0xaa55
32062 89DE           8A56         19                mov dl, _int19_function.bootdrv + 0[bp]
32063                                               ;; Zero some of the other registers.
32064 89E1           31DB                           xor bx, bx
32065 89E3           8EDB                           mov ds, bx
32066 89E5           8EC3                           mov es, bx
32067 89E7           89DD                           mov bp, bx
32068                                               ;; Go!
32069 89E9           CF                             iret
32070                                           ! 5442 endasm
32071                                           !BCC_ENDASM
32072                                           !BCC_EOS
32073                                           ! 5443 }
32074 89EA           89EC                       mov	sp,bp
32075 89EC           5D                         pop	bp
32076 89ED           C3                         ret
32077                                           ! 5444   void
32078                                           ! Register BX used in function int19_function
32079                                           ! 5445 int1a_function(regs, ds, iret_addr)
32080                                           ! 5446   pusha_regs_t regs;
32081                                           export	_int1a_function
32082                       000089EE            _int1a_function:
32083                                           !BCC_EOS
32084                                           ! 5447   Bit16u ds;
32085                                           !BCC_EOS
32086                                           ! 5448   iret_addr_t iret_addr;
32087                                           !BCC_EOS
32088                                           ! 5449 {
32089                                           ! 5450   Bit8u val8,hr;
32090                                           !BCC_EOS
32091                                           ! 5451   ;
32092 89EE           55                         push	bp
32093 89EF           89E5                       mov	bp,sp
32094 89F1           4C                         dec	sp
32095 89F2           4C                         dec	sp
32096                                           !BCC_EOS
32097                                           ! 5452 #asm
32098                                           !BCC_EOS
32099                                           !BCC_ASM
32100                       00000016            _int1a_function.ds	set	$16
32101                       00000014            .int1a_function.ds	set	$14
32102                       00000000            _int1a_function.hr	set	0
32103                       FFFFFFFE            .int1a_function.hr	set	-2
32104                       00000001            _int1a_function.val8	set	1
32105                       FFFFFFFF            .int1a_function.val8	set	-1
32106                       00000018            _int1a_function.iret_addr	set	$18
32107                       00000016            .int1a_function.iret_addr	set	$16
32108                       00000006            _int1a_function.regs	set	6
32109                       00000004            .int1a_function.regs	set	4
32110 89F3           FB                           sti
32111                                           ! 5454 endasm
32112                                           !BCC_ENDASM
32113                                           !BCC_EOS
32114                                           ! 5455   switch (regs.u.r8.ah) {
32115 89F4           8A46         13            mov	al,$13[bp]
32116 89F7           E9         069C            br 	.7A0
32117                                           ! 5456     case 0:
32118                                           ! 5457 #asm
32119                       000089FA            .7A1:
32120                                           !BCC_EOS
32121                                           !BCC_ASM
32122                       00000016            _int1a_function.ds	set	$16
32123                       00000014            .int1a_function.ds	set	$14
32124                       00000000            _int1a_function.hr	set	0
32125                       FFFFFFFE            .int1a_function.hr	set	-2
32126                       00000001            _int1a_function.val8	set	1
32127                       FFFFFFFF            .int1a_function.val8	set	-1
32128                       00000018            _int1a_function.iret_addr	set	$18
32129                       00000016            .int1a_function.iret_addr	set	$16
32130                       00000006            _int1a_function.regs	set	6
32131                       00000004            .int1a_function.regs	set	4
32132 89FA           FA                               cli
32133                                           ! 5459 endasm
32134                                           !BCC_ENDASM
32135                                           !BCC_EOS
32136                                           ! 5460       regs.u.r16.cx = ((bios_data_t *) 0)->ticks_high;
32137                                           ! Debug: eq unsigned short = [+$46E] to unsigned short regs = [S+4+$E] (used reg = )
32138 89FB           A1         046E            mov	ax,[$46E]
32139 89FE           8946         10            mov	$10[bp],ax
32140                                           !BCC_EOS
32141                                           ! 5461       regs.u.r16.dx = ((bios_data_t *) 0)->ticks_low;
32142                                           ! Debug: eq unsigned short = [+$46C] to unsigned short regs = [S+4+$C] (used reg = )
32143 8A01           A1         046C            mov	ax,[$46C]
32144 8A04           8946         0E            mov	$E[bp],ax
32145                                           !BCC_EOS
32146                                           ! 5462       regs.u.r8.al = ((bios_data_t *) 0)->midnight_flag;
32147                                           ! Debug: eq unsigned char = [+$470] to unsigned char regs = [S+4+$10] (used reg = )
32148 8A07           A0         0470            mov	al,[$470]
32149 8A0A           8846         12            mov	$12[bp],al
32150                                           !BCC_EOS
32151                                           ! 5463       ((bios_data_t *) 0)->midnight_flag = 0;
32152                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
32153 8A0D           30C0                       xor	al,al
32154 8A0F           A2         0470            mov	[$470],al
32155                                           !BCC_EOS
32156                                           ! 5464 #asm
32157                                           !BCC_EOS
32158                                           !BCC_ASM
32159                       00000016            _int1a_function.ds	set	$16
32160                       00000014            .int1a_function.ds	set	$14
32161                       00000000            _int1a_function.hr	set	0
32162                       FFFFFFFE            .int1a_function.hr	set	-2
32163                       00000001            _int1a_function.val8	set	1
32164                       FFFFFFFF            .int1a_function.val8	set	-1
32165                       00000018            _int1a_function.iret_addr	set	$18
32166                       00000016            .int1a_function.iret_addr	set	$16
32167                       00000006            _int1a_function.regs	set	6
32168                       00000004            .int1a_function.regs	set	4
32169 8A12           FB                               sti
32170                                           ! 5466 endasm
32171                                           !BCC_ENDASM
32172                                           !BCC_EOS
32173                                           ! 5467       iret_addr.flags.u.r8.flagsl &= 0xfe;
32174                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32175 8A13           8A46         1A            mov	al,$1A[bp]
32176 8A16           24                     FE  and	al,#$FE
32177 8A18           8846         1A            mov	$1A[bp],al
32178                                           !BCC_EOS
32179                                           ! 5468       brea
32180                                           ! 5468 k;
32181 8A1B           E9         06A3            br 	.79E
32182                                           !BCC_EOS
32183                                           ! 5469     case 1:
32184                                           ! 5470 #asm
32185                       00008A1E            .7A2:
32186                                           !BCC_EOS
32187                                           !BCC_ASM
32188                       00000016            _int1a_function.ds	set	$16
32189                       00000014            .int1a_function.ds	set	$14
32190                       00000000            _int1a_function.hr	set	0
32191                       FFFFFFFE            .int1a_function.hr	set	-2
32192                       00000001            _int1a_function.val8	set	1
32193                       FFFFFFFF            .int1a_function.val8	set	-1
32194                       00000018            _int1a_function.iret_addr	set	$18
32195                       00000016            .int1a_function.iret_addr	set	$16
32196                       00000006            _int1a_function.regs	set	6
32197                       00000004            .int1a_function.regs	set	4
32198 8A1E           FA                               cli
32199                                           ! 5472 endasm
32200                                           !BCC_ENDASM
32201                                           !BCC_EOS
32202                                           ! 5473       ((bios_data_t *) 0)->ticks_high = regs.u.r16.cx;
32203                                           ! Debug: eq unsigned short regs = [S+4+$E] to unsigned short = [+$46E] (used reg = )
32204 8A1F           8B46         10            mov	ax,$10[bp]
32205 8A22           A3         046E            mov	[$46E],ax
32206                                           !BCC_EOS
32207                                           ! 5474       ((bios_data_t *) 0)->ticks_low = regs.u.r16.dx;
32208                                           ! Debug: eq unsigned short regs = [S+4+$C] to unsigned short = [+$46C] (used reg = )
32209 8A25           8B46         0E            mov	ax,$E[bp]
32210 8A28           A3         046C            mov	[$46C],ax
32211                                           !BCC_EOS
32212                                           ! 5475       ((bios_data_t *) 0)->midnight_flag = 0;
32213                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
32214 8A2B           30C0                       xor	al,al
32215 8A2D           A2         0470            mov	[$470],al
32216                                           !BCC_EOS
32217                                           ! 5476 #asm
32218                                           !BCC_EOS
32219                                           !BCC_ASM
32220                       00000016            _int1a_function.ds	set	$16
32221                       00000014            .int1a_function.ds	set	$14
32222                       00000000            _int1a_function.hr	set	0
32223                       FFFFFFFE            .int1a_function.hr	set	-2
32224                       00000001            _int1a_function.val8	set	1
32225                       FFFFFFFF            .int1a_function.val8	set	-1
32226                       00000018            _int1a_function.iret_addr	set	$18
32227                       00000016            .int1a_function.iret_addr	set	$16
32228                       00000006            _int1a_function.regs	set	6
32229                       00000004            .int1a_function.regs	set	4
32230 8A30           FB                               sti
32231                                           ! 5478 endasm
32232                                           !BCC_ENDASM
32233                                           !BCC_EOS
32234                                           ! 5479       regs.u.r8.ah = 0;
32235                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
32236 8A31           30C0                       xor	al,al
32237 8A33           8846         13            mov	$13[bp],al
32238                                           !BCC_EOS
32239                                           ! 5480       iret_addr.flags.u.r8.flagsl &= 0xfe;
32240                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32241 8A36           8A46         1A            mov	al,$1A[bp]
32242 8A39           24                     FE  and	al,#$FE
32243 8A3B           8846         1A            mov	$1A[bp],al
32244                                           !BCC_EOS
32245                                           ! 5481       break;
32246 8A3E           E9         0680            br 	.79E
32247                                           !BCC_EOS
32248                                           ! 5482     case 2:
32249                                           ! 5483       if (rtc_updating()) {
32250                       00008A41            .7A3:
32251                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
32252 8A41           E8         7B36            call	_rtc_updating
32253 8A44           85C0                       test	ax,ax
32254 8A46           74           0B            je  	.7A4
32255                       00008A48            .7A5:
32256                                           ! 5484         iret_addr.flags.u.r8.flagsl |= 0x01;
32257                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
32258 8A48           8A46         1A            mov	al,$1A[bp]
32259 8A4B           0C                     01  or	al,*1
32260 8A4D           8846         1A            mov	$1A[bp],al
32261                                           !BCC_EOS
32262                                           ! 5485         break;
32263 8A50           E9         066E            br 	.79E
32264                                           !BCC_EOS
32265                                           ! 5486       }
32266                                           ! 5487       val8 = inb_cmos(0x0b);
32267                       00008A53            .7A4:
32268                                           ! Debug: list int = const $B (used reg = )
32269 8A53           B8                   000B  mov	ax,*$B
32270 8A56           50                         push	ax
32271                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32272 8A57           E8         7AE3            call	_inb_cmos
32273 8A5A           44                         inc	sp
32274 8A5B           44                         inc	sp
32275                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
32276 8A5C           8846         FF            mov	-1[bp],al
32277                                           !BCC_EOS
32278                                           ! 5488       if(val8&0x04){
32279                                           ! Debug: and int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
32280 8A5F           8A46         FF            mov	al,-1[bp]
32281 8A62           24                     04  and	al,*4
32282 8A64           84C0                       test	al,al
32283 8A66         0F84         0085            beq 	.7A6
32284                       00008A6A            .7A7:
32285                                           ! 5489         regs.u.r8.dh = bin2bcd(inb_cmos(0x00));
32286                                           ! Debug: list int = const 0 (used reg = )
32287 8A6A           31C0                       xor	ax,ax
32288 8A6C           50                         push	ax
32289                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32290 8A6D           E8         7ACD            call	_inb_cmos
32291 8A70           44                         inc	sp
32292 8A71           44                         inc	sp
32293                                           ! Debug: list unsigned char = al+0 (used reg = )
32294 8A72           30E4                       xor	ah,ah
32295 8A74           50                         push	ax
32296                                           ! Debug: func () unsigned char = bin2bcd+0 (used reg = )
32297 8A75           E8         7B36            call	_bin2bcd
32298 8A78           44                         inc	sp
32299 8A79           44                         inc	sp
32300                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
32301 8A7A           8846         0F            mov	$F[bp],al
32302                                           !BCC_EOS
32303                                           ! 5490         regs.u.r8.cl = bin2bcd(inb_cmos(0x02));
32304                                           ! Debug: list int = const 2 (used reg = )
32305 8A7D           B8                   0002  mov	ax,*2
32306 8A80           50                         push	ax
32307                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32308 8A81           E8         7AB9            call	_inb_cmos
32309 8A84           44                         inc	sp
32310 8A85           44                         inc	sp
32311                                           ! Debug: list unsigned char = al+0 (used reg = )
32312 8A86           30E4                       xor	ah,ah
32313 8A88           50                         push	ax
32314                                           ! Debug: func () unsigned char = bin2bcd+0 (used reg = )
32315 8A89           E8         7B22            call	_bin2bcd
32316 8A8C           44                         inc	sp
32317 8A8D           44                         inc	sp
32318                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
32319 8A8E           8846         10            mov	$10[bp],al
32320                                           !BCC_EOS
32321                                           ! 5491         hr = inb_cmos(0x04);
32322                                           ! Debug: list int = const 4 (used reg = )
32323 8A91           B8                   0004  mov	ax,*4
32324 8A94           50                         push	ax
32325                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32326 8A95           E8         7AA5            call	_inb_cmos
32327 8A98           44                         inc	sp
32328 8A99           44                         inc	sp
32329                                           ! Debug: eq unsigned char = al+0 to unsigned char hr = [S+4-4] (used reg = )
32330 8A9A           8846         FE            mov	-2[bp],al
32331                                           !BCC_EOS
32332                                           ! 5492         if((val8&0x02)&&(hr&0x80)) hr = (hr & 0x7f) + 12;
32333                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
32334 8A9D           8A46         FF            mov	al,-1[bp]
32335 8AA0           24                     02  and	al,*2
32336 8AA2           84C0                       test	al,al
32337 8AA4           74           16            je  	.7A8
32338                       00008AA6            .7AA:
32339                                           ! Debug: and int = const $80 to unsigned char hr = [S+4-4] (used reg = )
32340 8AA6           8A46         FE            mov	al,-2[bp]
32341 8AA9           24                     80  and	al,#$80
32342 8AAB           84C0                       test	al,al
32343 8AAD           74           0D            je  	.7A8
32344                       00008AAF            .7A9:
32345                                           ! Debug: and int = const $7F to unsigned char hr = [S+4-4] (used reg = )
32346 8AAF           8A46         FE            mov	al,-2[bp]
32347 8AB2           24                     7F  and	al,*$7F
32348                                           ! Debug: add int = const $C to unsigned char = al+0 (used reg = )
32349 8AB4           30E4                       xor	ah,ah
32350                                           ! Debug: eq unsigned int = ax+$C to unsigned char hr = [S+4-4] (used reg = )
32351 8AB6           05                   000C  add	ax,*$C
32352 8AB9           8846         FE            mov	-2[bp],al
32353                                           !BCC_EOS
32354                                           ! 5493         if((val8&0x02)&&(!(hr%12))) hr -= 12;
32355                       00008ABC            .7A8:
32356                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
32357 8ABC           8A46         FF            mov	al,-1[bp]
32358 8ABF           24                     02  and	al,*2
32359 8AC1           84C0                       test	al,al
32360 8AC3           74           1A            je  	.7AB
32361                       00008AC5            .7AD:
32362                                           ! Debug: mod int = const $C to unsigned char hr = [S+4-4] (used reg = )
32363 8AC5           8A46         FE            mov	al,-2[bp]
32364 8AC8           30E4                       xor	ah,ah
32365 8ACA           BB                   000C  mov	bx,*$C
32366 8ACD           E8         7695            call	imodu
32367 8AD0           85C0                       test	ax,ax
32368 8AD2           75           0B            jne 	.7AB
32369                       00008AD4            .7AC:
32370                                           ! Debug: subab int = const $C to unsigned char hr = [S+4-4] (used reg = )
32371 8AD4           8A46         FE            mov	al,-2[bp]
32372 8AD7           30E4                       xor	ah,ah
32373 8AD9           05                   FFF4  add	ax,*-$C
32374 8ADC           8846         FE            mov	-2[bp],al
32375                                           !BCC_EOS
32376                                           ! 5494         regs.u.r8.ch = bin2bcd(hr);
32377                       00008ADF            .7AB:
32378                                           ! Debug: list unsigned char hr = [S+4-4] (used reg = )
32379 8ADF           8A46         FE            mov	al,-2[bp]
32380 8AE2           30E4                       xor	ah,ah
32381 8AE4           50                         push	ax
32382                                           ! Debug: func () unsigned char = bin2bcd+0 (used reg = )
32383 8AE5           E8         7AC6            call	_bin2bcd
32384 8AE8           44                         inc	sp
32385 8AE9           44                         inc	sp
32386                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
32387 8AEA           8846         11            mov	$11[bp],al
32388                                           !BCC_EOS
32389                                           ! 5495       }else{
32390 8AED           EB           6B            jmp .7AE
32391                       00008AEF            .7A6:
32392                                           ! 5496         regs.u.r8.dh = inb_cmos(0x00);
32393                                           ! Debug: list int = const 0 (used reg = )
32394 8AEF           31C0                       xor	ax,ax
32395 8AF1           50                         push	ax
32396                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32397 8AF2           E8         7A48            call	_inb_cmos
32398 8AF5           44                         inc	sp
32399 8AF6           44                         inc	sp
32400                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
32401 8AF7           8846         0F            mov	$F[bp],al
32402                                           !BCC_EOS
32403                                           ! 5497         regs.u.r8.cl = inb_cmos(0x02);
32404                                           ! Debug: list int = const 2 (used reg = )
32405 8AFA           B8                   0002  mov	ax,*2
32406 8AFD           50                         push	ax
32407                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32408 8AFE           E8         7A3C            call	_inb_cmos
32409 8B01           44                         inc	sp
32410 8B02           44                         inc	sp
32411                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
32412 8B03           8846         10            mov	$10[bp],al
32413                                           !BCC_EOS
32414                                           ! 5498         hr = inb_cmos(0x04);
32415                                           ! Debug: list int = const 4 (used reg = )
32416 8B06           B8                   0004  mov	ax,*4
32417 8B09           50                         push	ax
32418                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32419 8B0A           E8         7A30            call	_inb_cmos
32420 8B0D           44                         inc	sp
32421 8B0E           44                         inc	sp
32422                                           ! Debug: eq unsigned char = al+0 to unsigned char hr = [S+4-4] (used reg = )
32423 8B0F           8846         FE            mov	-2[bp],al
32424                                           !BCC_EOS
32425                                           ! 5499         if((val8&0x02)&&(hr&0x80)) hr = (hr & 0x7f) + 0x12;
32426                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
32427 8B12           8A46         FF            mov	al,-1[bp]
32428 8B15           24                     02  and	al,*2
32429 8B17           84C0                       test	al,al
32430 8B19           74           16            je  	.7AF
32431                       00008B1B            .7B1:
32432                                           ! Debug: and int = const $80 to unsigned char hr = [S+4-4] (used reg = )
32433 8B1B           8A46         FE            mov	al,-2[bp]
32434 8B1E           24                     80  and	al,#$80
32435 8B20           84C0                       test	al,al
32436 8B22           74           0D            je  	.7AF
32437                       00008B24            .7B0:
32438                                           ! Debug: and int = const $7F to unsigned char hr = [S+4-4] (used reg = )
32439 8B24           8A46         FE            mov	al,-2[bp]
32440 8B27           24                     7F  and	al,*$7F
32441                                           ! Debug: add int = const $12 to unsigned char = al+0 (used reg = )
32442 8B29           30E4                       xor	ah,ah
32443                                           ! Debug: eq unsigned int = ax+$12 to unsigned char hr = [S+4-4] (used reg = )
32444 8B2B           05                   0012  add	ax,*$12
32445 8B2E           8846         FE            mov	-2[bp],al
32446                                           !BCC_EOS
32447                                           ! 5500         if((val8&0x02)&&(!(hr%0x12))) hr -= 0x12;
32448                       00008B31            .7AF:
32449                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
32450 8B31           8A46         FF            mov	al,-1[bp]
32451 8B34           24                     02  and	al,*2
32452 8B36           84C0                       test	al,al
32453 8B38           74           1A            je  	.7B2
32454                       00008B3A            .7B4:
32455                                           ! Debug: mod int = const $12 to unsigned char hr = [S+4-4] (used reg = )
32456 8B3A           8A46         FE            mov	al,-2[bp]
32457 8B3D           30E4                       xor	ah,ah
32458 8B3F           BB                   0012  mov	bx,*$12
32459 8B42           E8         7620            call	imodu
32460 8B45           85C0                       test	ax,ax
32461 8B47           75           0B            jne 	.7B2
32462                       00008B49            .7B3:
32463                                           ! Debug: subab int = const $12 to unsigned char hr = [S+4-4] (used reg = )
32464 8B49           8A46         FE            mov	al,-2[bp]
32465 8B4C           30E4                       xor	ah,ah
32466 8B4E           05                   FFEE  add	ax,*-$12
32467 8B51           8846         FE            mov	-2[bp],al
32468                                           !BCC_EOS
32469                                           ! 5501         regs.u.r8.ch = hr;
32470                       00008B54            .7B2:
32471                                           ! Debug: eq unsigned char hr = [S+4-4] to unsigned char regs = [S+4+$F] (used reg = )
32472 8B54           8A46         FE            mov	al,-2[bp]
32473 8B57           8846         11            mov	$11[bp],al
32474                                           !BCC_EOS
32475                                           ! 5502       }
32476                                           ! 5503       regs.u.r8.dl = val8 & 0x01;
32477                       00008B5A            .7AE:
32478                                           ! Debug: and int = const 1 to unsigned char val8 = [S+4-3] (used reg = )
32479 8B5A           8A46         FF            mov	al,-1[bp]
32480 8B5D           24                     01  and	al,*1
32481                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
32482 8B5F           8846         0E            mov	$E[bp],al
32483                                           !BCC_EOS
32484                                           ! 5504       regs.u.r8.ah = 0;
32485                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
32486 8B62           30C0                       xor	al,al
32487 8B64           8846         13            mov	$13[bp],al
32488                                           !BCC_EOS
32489                                           ! 5505       regs.u.r8.al = regs.u.r8.ch;
32490                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
32491 8B67           8A46         11            mov	al,$11[bp]
32492 8B6A           8846         12            mov	$12[bp],al
32493                                           !BCC_EOS
32494                                           ! 5506       iret_addr.flags.u.r8.flagsl &= 0xfe;
32495                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32496 8B6D           8A46         1A            mov	al,$1A[bp]
32497 8B70           24                     FE  and	al,#$FE
32498 8B72           8846         1A            mov	$1A[bp],al
32499                                           !BCC_EOS
32500                                           ! 5507       break;
32501 8B75           E9         0549            br 	.79E
32502                                           !BCC_EOS
32503                                           ! 5508     case 3:
32504                                           ! 5509       if (rtc_updating()) {
32505                       00008B78            .7B5:
32506                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
32507 8B78           E8         79FF            call	_rtc_updating
32508 8B7B           85C0                       test	ax,ax
32509 8B7D           74           03            je  	.7B6
32510                       00008B7F            .7B7:
32511                                           ! 5510         init_rtc();
32512                                           ! Debug: func () void = init_rtc+0 (used reg = )
32513 8B7F           E8         79C7            call	_init_rtc
32514                                           !BCC_EOS
32515                                           ! 5511       }
32516                                           ! 5512       val8 = inb_cmos(0x0b);
32517                       00008B82            .7B6:
32518                                           ! Debug: list int = const $B (used reg = )
32519 8B82           B8                   000B  mov	ax,*$B
32520 8B85           50                         push	ax
32521                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32522 8B86           E8         79B4            call	_inb_cmos
32523 8B89           44                         inc	sp
32524 8B8A           44                         inc	sp
32525                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
32526 8B8B           8846         FF            mov	-1[bp],al
32527                                           !BCC_EOS
32528                                           ! 5513       if(val8 & 0x04){
32529                                           ! Debug: and int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
32530 8B8E           8A46         FF            mov	al,-1[bp]
32531 8B91           24                     04  and	al,*4
32532 8B93           84C0                       test	al,al
32533 8B95           74           7C            je  	.7B8
32534                       00008B97            .7B9:
32535                                           ! 5514         hr = bcd2bin(regs.u.r8.ch);
32536                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
32537 8B97           8A46         11            mov	al,$11[bp]
32538 8B9A           30E4                       xor	ah,ah
32539 8B9C           50                         push	ax
32540                                           ! Debug: func () unsigned char = bcd2bin+0 (used reg = )
32541 8B9D           E8         7A2B            call	_bcd2bin
32542 8BA0           44                         inc	sp
32543 8BA1           44                         inc	sp
32544                                           ! Debug: eq unsigned char = al+0 to unsigned char hr = [S+4-4] (used reg = )
32545 8BA2           8846         FE            mov	-2[bp],al
32546                                           !BCC_EOS
32547                                           ! 5515         if((val8&0x02)&&(hr>=12)) hr |= 0x80;
32548                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
32549 8BA5           8A46         FF            mov	al,-1[bp]
32550 8BA8           24                     02  and	al,*2
32551 8BAA           84C0                       test	al,al
32552 8BAC           74           0F            je  	.7BA
32553                       00008BAE            .7BC:
32554                                           ! Debug: ge int = const $C to unsigned char hr = [S+4-4] (used reg = )
32555 8BAE           8A46         FE            mov	al,-2[bp]
32556 8BB1           3C                     0C  cmp	al,*$C
32557 8BB3           72           08            jb  	.7BA
32558                       00008BB5            .7BB:
32559                                           ! Debug: orab int = const $80 to unsigned char hr = [S+4-4] (used reg = )
32560 8BB5           8A46         FE            mov	al,-2[bp]
32561 8BB8           0C                     80  or	al,#$80
32562 8BBA           8846         FE            mov	-2[bp],al
32563                                           !BCC_EOS
32564                                           ! 5516         if((val8&0x02)&&(hr==00)) hr = 12;
32565                       00008BBD            .7BA:
32566                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
32567 8BBD           8A46         FF            mov	al,-1[bp]
32568 8BC0           24                     02  and	al,*2
32569 8BC2           84C0                       test	al,al
32570 8BC4           74           0C            je  	.7BD
32571                       00008BC6            .7BF:
32572                                           ! Debug: logeq int = const 0 to unsigned char hr = [S+4-4] (used reg = )
32573 8BC6           8A46         FE            mov	al,-2[bp]
32574 8BC9           84C0                       test	al,al
32575 8BCB           75           05            jne 	.7BD
32576                       00008BCD            .7BE:
32577                                           ! Debug: eq int = const $C to unsigned char hr = [S+4-4] (used reg = )
32578 8BCD           B0                     0C  mov	al,*$C
32579 8BCF           8846         FE            mov	-2[bp],al
32580                                           !BCC_EOS
32581                                           ! 5517         outb_cmos(0x00, bcd2bin(regs.u.r8.dh));
32582                       00008BD2            .7BD:
32583                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
32584 8BD2           8A46         0F            mov	al,$F[bp]
32585 8BD5           30E4                       xor	ah,ah
32586 8BD7           50                         push	ax
32587                                           ! Debug: func () unsigned char = bcd2bin+0 (used reg = )
32588 8BD8           E8         79F0            call	_bcd2bin
32589 8BDB           44                         inc	sp
32590 8BDC           44                         inc	sp
32591                                           ! Debug: list unsigned char = al+0 (used reg = )
32592 8BDD           30E4                       xor	ah,ah
32593 8BDF           50                         push	ax
32594                                           ! Debug: list int = const 0 (used reg = )
32595 8BE0           31C0                       xor	ax,ax
32596 8BE2           50                         push	ax
32597                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32598 8BE3           E8         7948            call	_outb_cmos
32599 8BE6           83C4                   04  add	sp,*4
32600                                           !BCC_EOS
32601                                           ! 5518         outb_cmos(0x02, bcd2bin(regs.u.r8.cl));
32602                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
32603 8BE9           8A46         10            mov	al,$10[bp]
32604 8BEC           30E4                       xor	ah,ah
32605 8BEE           50                         push	ax
32606                                           ! Debug: func () unsigned char = bcd2bin+0 (used reg = )
32607 8BEF           E8         79D9            call	_bcd2bin
32608 8BF2           44                         inc	sp
32609 8BF3           44                         inc	sp
32610                                           ! Debug: list unsigned char = al+0 (used reg = )
32611 8BF4           30E4                       xor	ah,ah
32612 8BF6           50                         push	ax
32613                                           ! Debug: list int = const 2 (used reg = )
32614 8BF7           B8                   0002  mov	ax,*2
32615 8BFA           50                         push	ax
32616                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32617 8BFB           E8         7930            call	_outb_cmos
32618 8BFE           83C4                   04  add	sp,*4
32619                                           !BCC_EOS
32620                                           ! 5519         outb_cmos(0x04, hr);
32621                                           ! Debug: list unsigned char hr = [S+4-4] (used reg = )
32622 8C01           8A46         FE            mov	al,-2[bp]
32623 8C04           30E4                       xor	ah,ah
32624 8C06           50                         push	ax
32625                                           ! Debug: list int = const 4 (used reg = )
32626 8C07           B8                   0004  mov	ax,*4
32627 8C0A           50                         push	ax
32628                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32629 8C0B           E8         7920            call	_outb_cmos
32630 8C0E           83C4                   04  add	sp,*4
32631                                           !BCC_EOS
32632                                           ! 5520       }else{
32633 8C11           EB           62            jmp .7C0
32634                       00008C13            .7B8:
32635                                           ! 5521         hr = regs.u.r8.ch;
32636                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char hr = [S+4-4] (used reg = )
32637 8C13           8A46         11            mov	al,$11[bp]
32638 8C16           8846         FE            mov	-2[bp],al
32639                                           !BCC_EOS
32640                                           ! 5522         if((val8&0x02)&&(hr>=0x12)) hr |= 0x80;
32641                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
32642 8C19           8A46         FF            mov	al,-1[bp]
32643 8C1C           24                     02  and	al,*2
32644 8C1E           84C0                       test	al,al
32645 8C20           74           0F            je  	.7C1
32646                       00008C22            .7C3:
32647                                           ! Debug: ge int = const $12 to unsigned char hr = [S+4-4] (used reg = )
32648 8C22           8A46         FE            mov	al,-2[bp]
32649 8C25           3C                     12  cmp	al,*$12
32650 8C27           72           08            jb  	.7C1
32651                       00008C29            .7C2:
32652                                           ! Debug: orab int = const $80 to unsigned char hr = [S+4-4] (used reg = )
32653 8C29           8A46         FE            mov	al,-2[bp]
32654 8C2C           0C                     80  or	al,#$80
32655 8C2E           8846         FE            mov	-2[bp],al
32656                                           !BCC_EOS
32657                                           ! 5523         if((val8&0x02)&&(hr==0x00)) hr = 0x12;
32658                       00008C31            .7C1:
32659                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
32660 8C31           8A46         FF            mov	al,-1[bp]
32661 8C34           24                     02  and	al,*2
32662 8C36           84C0                       test	al,al
32663 8C38           74           0C            je  	.7C4
32664                       00008C3A            .7C6:
32665                                           ! Debug: logeq int = const 0 to unsigned char hr = [S+4-4] (used reg = )
32666 8C3A           8A46         FE            mov	al,-2[bp]
32667 8C3D           84C0                       test	al,al
32668 8C3F           75           05            jne 	.7C4
32669                       00008C41            .7C5:
32670                                           ! Debug: eq int = const $12 to unsigned char hr = [S+4-4] (used reg = )
32671 8C41           B0                     12  mov	al,*$12
32672 8C43           8846         FE            mov	-2[bp],al
32673                                           !BCC_EOS
32674                                           ! 5524         outb_cmos(0x00, regs.u.r8.dh);
32675                       00008C46            .7C4:
32676                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
32677 8C46           8A46         0F            mov	al,$F[bp]
32678 8C49           30E4                       xor	ah,ah
32679 8C4B           50                         push	ax
32680                                           ! Debug: list int = const 0 (used reg = )
32681 8C4C           31C0                       xor	ax,ax
32682 8C4E           50                         push	ax
32683                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32684 8C4F           E8         78DC            call	_outb_cmos
32685 8C52           83C4                   04  add	sp,*4
32686                                           !BCC_EOS
32687                                           ! 5525         outb_cmos(0x02, regs.u.r8.cl);
32688                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
32689 8C55           8A46         10            mov	al,$10[bp]
32690 8C58           30E4                       xor	ah,ah
32691 8C5A           50                         push	ax
32692                                           ! Debug: list int = const 2 (used reg = )
32693 8C5B           B8                   0002  mov	ax,*2
32694 8C5E           50                         push	ax
32695                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32696 8C5F           E8         78CC            call	_outb_cmos
32697 8C62           83C4                   04  add	sp,*4
32698                                           !BCC_EOS
32699                                           ! 5526         outb_cmos(0x04, hr);
32700                                           ! Debug: list unsigned char hr = [S+4-4] (used reg = )
32701 8C65           8A46         FE            mov	al,-2[bp]
32702 8C68           30E4                       xor	ah,ah
32703 8C6A           50                         push	ax
32704                                           ! Debug: list int = const 4 (used reg = )
32705 8C6B           B8                   0004  mov	ax,*4
32706 8C6E           50                         push	ax
32707                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32708 8C6F           E8         78BC            call	_outb_cmos
32709 8C72           83C4                   04  add	sp,*4
32710                                           !BCC_EOS
32711                                           ! 5527       }
32712                                           ! 5528       val8 = (val8 & 0x66) | (regs.u.r8.dl & 0x01);
32713                       00008C75            .7C0:
32714                                           ! Debug: and int = const 1 to unsigned char regs = [S+4+$C] (used reg = )
32715 8C75           8A46         0E            mov	al,$E[bp]
32716 8C78           24                     01  and	al,*1
32717 8C7A           50                         push	ax
32718                                           ! Debug: and int = const $66 to unsigned char val8 = [S+6-3] (used reg = )
32719 8C7B           8A46         FF            mov	al,-1[bp]
32720 8C7E           24                     66  and	al,*$66
32721                                           ! Debug: or unsigned char (temp) = [S+6-6] to unsigned char = al+0 (used reg = )
32722 8C80           0A46         FC            or	al,0+..FFD8[bp]
32723 8C83           44                         inc	sp
32724 8C84           44                         inc	sp
32725                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
32726 8C85           8846         FF            mov	-1[bp],al
32727                                           !BCC_EOS
32728                                           ! 5529       outb_cmos(0x0b, val8);
32729                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
32730 8C88           8A46         FF            mov	al,-1[bp]
32731 8C8B           30E4                       xor	ah,ah
32732 8C8D           50                         push	ax
32733                                           ! Debug: list int = const $B (used reg = )
32734 8C8E           B8                   000B  mov	ax,*$B
32735 8C91           50                         push	ax
32736                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32737 8C92           E8         7899            call	_outb_cmos
32738 8C95           83C4                   04  add	sp,*4
32739                                           !BCC_EOS
32740                                           ! 5530       regs.u.r8.ah = 0;
32741                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
32742 8C98           30C0                       xor	al,al
32743 8C9A           8846         13            mov	$13[bp],al
32744                                           !BCC_EOS
32745                                           ! 5531       regs.u.r8.al = val8;
32746                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
32747 8C9D           8A46         FF            mov	al,-1[bp]
32748 8CA0           8846         12            mov	$12[bp],al
32749                                           !BCC_EOS
32750                                           ! 5532       iret_addr.flags.u.r8.flagsl &= 0xfe;
32751                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32752 8CA3           8A46         1A            mov	al,$1A[bp]
32753 8CA6           24                     FE  and	al,#$FE
32754 8CA8           8846         1A            mov	$1A[bp],al
32755                                           !BCC_EOS
32756                                           ! 5533       break;
32757 8CAB           E9         0413            br 	.79E
32758                                           !BCC_EOS
32759                                           ! 5534     case 4:
32760                                           ! 5535       regs.u.r8.ah = 0;
32761                       00008CAE            .7C7:
32762                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
32763 8CAE           30C0                       xor	al,al
32764 8CB0           8846         13            mov	$13[bp],al
32765                                           !BCC_EOS
32766                                           ! 5536       if (rtc_updating()) {
32767                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
32768 8CB3           E8         78C4            call	_rtc_updating
32769 8CB6           85C0                       test	ax,ax
32770 8CB8           74           0B            je  	.7C8
32771                       00008CBA            .7C9:
32772                                           ! 5537         iret_addr.flags.u.r8.flagsl |= 0x01
32773                                           ! 5537 ;
32774                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
32775 8CBA           8A46         1A            mov	al,$1A[bp]
32776 8CBD           0C                     01  or	al,*1
32777 8CBF           8846         1A            mov	$1A[bp],al
32778                                           !BCC_EOS
32779                                           ! 5538         break;
32780 8CC2           E9         03FC            br 	.79E
32781                                           !BCC_EOS
32782                                           ! 5539       }
32783                                           ! 5540       val8 = inb_cmos(0x0b);
32784                       00008CC5            .7C8:
32785                                           ! Debug: list int = const $B (used reg = )
32786 8CC5           B8                   000B  mov	ax,*$B
32787 8CC8           50                         push	ax
32788                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32789 8CC9           E8         7871            call	_inb_cmos
32790 8CCC           44                         inc	sp
32791 8CCD           44                         inc	sp
32792                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
32793 8CCE           8846         FF            mov	-1[bp],al
32794                                           !BCC_EOS
32795                                           ! 5541       if(val8 & 0x04){
32796                                           ! Debug: and int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
32797 8CD1           8A46         FF            mov	al,-1[bp]
32798 8CD4           24                     04  and	al,*4
32799 8CD6           84C0                       test	al,al
32800 8CD8           74           52            je  	.7CA
32801                       00008CDA            .7CB:
32802                                           ! 5542         regs.u.r8.cl = bin2bcd(inb_cmos(0x09));
32803                                           ! Debug: list int = const 9 (used reg = )
32804 8CDA           B8                   0009  mov	ax,*9
32805 8CDD           50                         push	ax
32806                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32807 8CDE           E8         785C            call	_inb_cmos
32808 8CE1           44                         inc	sp
32809 8CE2           44                         inc	sp
32810                                           ! Debug: list unsigned char = al+0 (used reg = )
32811 8CE3           30E4                       xor	ah,ah
32812 8CE5           50                         push	ax
32813                                           ! Debug: func () unsigned char = bin2bcd+0 (used reg = )
32814 8CE6           E8         78C5            call	_bin2bcd
32815 8CE9           44                         inc	sp
32816 8CEA           44                         inc	sp
32817                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
32818 8CEB           8846         10            mov	$10[bp],al
32819                                           !BCC_EOS
32820                                           ! 5543         regs.u.r8.dh = bin2bcd(inb_cmos(0x08));
32821                                           ! Debug: list int = const 8 (used reg = )
32822 8CEE           B8                   0008  mov	ax,*8
32823 8CF1           50                         push	ax
32824                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32825 8CF2           E8         7848            call	_inb_cmos
32826 8CF5           44                         inc	sp
32827 8CF6           44                         inc	sp
32828                                           ! Debug: list unsigned char = al+0 (used reg = )
32829 8CF7           30E4                       xor	ah,ah
32830 8CF9           50                         push	ax
32831                                           ! Debug: func () unsigned char = bin2bcd+0 (used reg = )
32832 8CFA           E8         78B1            call	_bin2bcd
32833 8CFD           44                         inc	sp
32834 8CFE           44                         inc	sp
32835                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
32836 8CFF           8846         0F            mov	$F[bp],al
32837                                           !BCC_EOS
32838                                           ! 5544         regs.u.r8.dl = bin2bcd(inb_cmos(0x07));
32839                                           ! Debug: list int = const 7 (used reg = )
32840 8D02           B8                   0007  mov	ax,*7
32841 8D05           50                         push	ax
32842                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32843 8D06           E8         7834            call	_inb_cmos
32844 8D09           44                         inc	sp
32845 8D0A           44                         inc	sp
32846                                           ! Debug: list unsigned char = al+0 (used reg = )
32847 8D0B           30E4                       xor	ah,ah
32848 8D0D           50                         push	ax
32849                                           ! Debug: func () unsigned char = bin2bcd+0 (used reg = )
32850 8D0E           E8         789D            call	_bin2bcd
32851 8D11           44                         inc	sp
32852 8D12           44                         inc	sp
32853                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
32854 8D13           8846         0E            mov	$E[bp],al
32855                                           !BCC_EOS
32856                                           ! 5545         regs.u.r8.ch = bin2bcd(inb_cmos(0x32));
32857                                           ! Debug: list int = const $32 (used reg = )
32858 8D16           B8                   0032  mov	ax,*$32
32859 8D19           50                         push	ax
32860                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32861 8D1A           E8         7820            call	_inb_cmos
32862 8D1D           44                         inc	sp
32863 8D1E           44                         inc	sp
32864                                           ! Debug: list unsigned char = al+0 (used reg = )
32865 8D1F           30E4                       xor	ah,ah
32866 8D21           50                         push	ax
32867                                           ! Debug: func () unsigned char = bin2bcd+0 (used reg = )
32868 8D22           E8         7889            call	_bin2bcd
32869 8D25           44                         inc	sp
32870 8D26           44                         inc	sp
32871                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
32872 8D27           8846         11            mov	$11[bp],al
32873                                           !BCC_EOS
32874                                           ! 5546       }else{
32875 8D2A           EB           30            jmp .7CC
32876                       00008D2C            .7CA:
32877                                           ! 5547         regs.u.r8.cl = inb_cmos(0x09);
32878                                           ! Debug: list int = const 9 (used reg = )
32879 8D2C           B8                   0009  mov	ax,*9
32880 8D2F           50                         push	ax
32881                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32882 8D30           E8         780A            call	_inb_cmos
32883 8D33           44                         inc	sp
32884 8D34           44                         inc	sp
32885                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
32886 8D35           8846         10            mov	$10[bp],al
32887                                           !BCC_EOS
32888                                           ! 5548         regs.u.r8.dh = inb_cmos(0x08);
32889                                           ! Debug: list int = const 8 (used reg = )
32890 8D38           B8                   0008  mov	ax,*8
32891 8D3B           50                         push	ax
32892                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32893 8D3C           E8         77FE            call	_inb_cmos
32894 8D3F           44                         inc	sp
32895 8D40           44                         inc	sp
32896                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
32897 8D41           8846         0F            mov	$F[bp],al
32898                                           !BCC_EOS
32899                                           ! 5549         regs.u.r8.dl = inb_cmos(0x07);
32900                                           ! Debug: list int = const 7 (used reg = )
32901 8D44           B8                   0007  mov	ax,*7
32902 8D47           50                         push	ax
32903                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32904 8D48           E8         77F2            call	_inb_cmos
32905 8D4B           44                         inc	sp
32906 8D4C           44                         inc	sp
32907                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
32908 8D4D           8846         0E            mov	$E[bp],al
32909                                           !BCC_EOS
32910                                           ! 5550         regs.u.r8.ch = inb_cmos(0x32);
32911                                           ! Debug: list int = const $32 (used reg = )
32912 8D50           B8                   0032  mov	ax,*$32
32913 8D53           50                         push	ax
32914                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32915 8D54           E8         77E6            call	_inb_cmos
32916 8D57           44                         inc	sp
32917 8D58           44                         inc	sp
32918                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
32919 8D59           8846         11            mov	$11[bp],al
32920                                           !BCC_EOS
32921                                           ! 5551       }
32922                                           ! 5552       regs.u.r8.al = regs.u.r8.ch;
32923                       00008D5C            .7CC:
32924                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
32925 8D5C           8A46         11            mov	al,$11[bp]
32926 8D5F           8846         12            mov	$12[bp],al
32927                                           !BCC_EOS
32928                                           ! 5553       iret_addr.flags.u.r8.flagsl &= 0xfe;
32929                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32930 8D62           8A46         1A            mov	al,$1A[bp]
32931 8D65           24                     FE  and	al,#$FE
32932 8D67           8846         1A            mov	$1A[bp],al
32933                                           !BCC_EOS
32934                                           ! 5554       break;
32935 8D6A           E9         0354            br 	.79E
32936                                           !BCC_EOS
32937                                           ! 5555     case 5:
32938                                           ! 5556       if (rtc_updating()) {
32939                       00008D6D            .7CD:
32940                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
32941 8D6D           E8         780A            call	_rtc_updating
32942 8D70           85C0                       test	ax,ax
32943 8D72           74           0E            je  	.7CE
32944                       00008D74            .7CF:
32945                                           ! 5557         init_rtc();
32946                                           ! Debug: func () void = init_rtc+0 (used reg = )
32947 8D74           E8         77D2            call	_init_rtc
32948                                           !BCC_EOS
32949                                           ! 5558         iret_addr.flags.u.r8.flagsl |= 0x01;
32950                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
32951 8D77           8A46         1A            mov	al,$1A[bp]
32952 8D7A           0C                     01  or	al,*1
32953 8D7C           8846         1A            mov	$1A[bp],al
32954                                           !BCC_EOS
32955                                           ! 5559         break;
32956 8D7F           E9         033F            br 	.79E
32957                                           !BCC_EOS
32958                                           ! 5560         }
32959                                           ! 5561       val8=inb_cmos(0x0b);
32960                       00008D82            .7CE:
32961                                           ! Debug: list int = const $B (used reg = )
32962 8D82           B8                   000B  mov	ax,*$B
32963 8D85           50                         push	ax
32964                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32965 8D86           E8         77B4            call	_inb_cmos
32966 8D89           44                         inc	sp
32967 8D8A           44                         inc	sp
32968                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
32969 8D8B           8846         FF            mov	-1[bp],al
32970                                           !BCC_EOS
32971                                           ! 5562       if(val8&0x04){
32972                                           ! Debug: and int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
32973 8D8E           8A46         FF            mov	al,-1[bp]
32974 8D91           24                     04  and	al,*4
32975 8D93           84C0                       test	al,al
32976 8D95           74           62            je  	.7D0
32977                       00008D97            .7D1:
32978                                           ! 5563         outb_cmos(0x09, bcd2bin(regs.u.r8.cl));
32979                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
32980 8D97           8A46         10            mov	al,$10[bp]
32981 8D9A           30E4                       xor	ah,ah
32982 8D9C           50                         push	ax
32983                                           ! Debug: func () unsigned char = bcd2bin+0 (used reg = )
32984 8D9D           E8         782B            call	_bcd2bin
32985 8DA0           44                         inc	sp
32986 8DA1           44                         inc	sp
32987                                           ! Debug: list unsigned char = al+0 (used reg = )
32988 8DA2           30E4                       xor	ah,ah
32989 8DA4           50                         push	ax
32990                                           ! Debug: list int = const 9 (used reg = )
32991 8DA5           B8                   0009  mov	ax,*9
32992 8DA8           50                         push	ax
32993                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32994 8DA9           E8         7782            call	_outb_cmos
32995 8DAC           83C4                   04  add	sp,*4
32996                                           !BCC_EOS
32997                                           ! 5564         outb_cmos(0x08, bcd2bin(regs.u.r8.dh));
32998                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
32999 8DAF           8A46         0F            mov	al,$F[bp]
33000 8DB2           30E4                       xor	ah,ah
33001 8DB4           50                         push	ax
33002                                           ! Debug: func () unsigned char = bcd2bin+0 (used reg = )
33003 8DB5           E8         7813            call	_bcd2bin
33004 8DB8           44                         inc	sp
33005 8DB9           44                         inc	sp
33006                                           ! Debug: list unsigned char = al+0 (used reg = )
33007 8DBA           30E4                       xor	ah,ah
33008 8DBC           50                         push	ax
33009                                           ! Debug: list int = const 8 (used reg = )
33010 8DBD           B8                   0008  mov	ax,*8
33011 8DC0           50                         push	ax
33012                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33013 8DC1           E8         776A            call	_outb_cmos
33014 8DC4           83C4                   04  add	sp,*4
33015                                           !BCC_EOS
33016                                           ! 5565         outb_cmos(0x07, bcd2bin(regs.u.r8.dl));
33017                                           ! Debug: list unsigned char regs = [S+4+$C] (used reg = )
33018 8DC7           8A46         0E            mov	al,$E[bp]
33019 8DCA           30E4                       xor	ah,ah
33020 8DCC           50                         push	ax
33021                                           ! Debug: func () unsigned char = bcd2bin+0 (used reg = )
33022 8DCD           E8         77FB            call	_bcd2bin
33023 8DD0           44                         inc	sp
33024 8DD1           44                         inc	sp
33025                                           ! Debug: list unsigned char = al+0 (used reg = )
33026 8DD2           30E4                       xor	ah,ah
33027 8DD4           50                         push	ax
33028                                           ! Debug: list int = const 7 (used reg = )
33029 8DD5           B8                   0007  mov	ax,*7
33030 8DD8           50                         push	ax
33031                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33032 8DD9           E8         7752            call	_outb_cmos
33033 8DDC           83C4                   04  add	sp,*4
33034                                           !BCC_EOS
33035                                           ! 5566         outb_cmos(0x32, bcd2bin(regs.u.r8.ch));
33036                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
33037 8DDF           8A46         11            mov	al,$11[bp]
33038 8DE2           30E4                       xor	ah,ah
33039 8DE4           50                         push	ax
33040                                           ! Debug: func () unsigned char = bcd2bin+0 (used reg = )
33041 8DE5           E8         77E3            call	_bcd2bin
33042 8DE8           44                         inc	sp
33043 8DE9           44                         inc	sp
33044                                           ! Debug: list unsigned char = al+0 (used reg = )
33045 8DEA           30E4                       xor	ah,ah
33046 8DEC           50                         push	ax
33047                                           ! Debug: list int = const $32 (used reg = )
33048 8DED           B8                   0032  mov	ax,*$32
33049 8DF0           50                         push	ax
33050                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33051 8DF1           E8         773A            call	_outb_cmos
33052 8DF4           83C4                   04  add	sp,*4
33053                                           !BCC_EOS
33054                                           ! 5567       }else{
33055 8DF7           EB           40            jmp .7D2
33056                       00008DF9            .7D0:
33057                                           ! 5568         outb_cmos(0x09, regs.u.r8.cl);
33058                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
33059 8DF9           8A46         10            mov	al,$10[bp]
33060 8DFC           30E4                       xor	ah,ah
33061 8DFE           50                         push	ax
33062                                           ! Debug: list int = const 9 (used reg = )
33063 8DFF           B8                   0009  mov	ax,*9
33064 8E02           50                         push	ax
33065                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33066 8E03           E8         7728            call	_outb_cmos
33067 8E06           83C4                   04  add	sp,*4
33068                                           !BCC_EOS
33069                                           ! 5569         outb_cmos(0x08, regs.u.r8.dh);
33070                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
33071 8E09           8A46         0F            mov	al,$F[bp]
33072 8E0C           30E4                       xor	ah,ah
33073 8E0E           50                         push	ax
33074                                           ! Debug: list int = const 8 (used reg = )
33075 8E0F           B8                   0008  mov	ax,*8
33076 8E12           50                         push	ax
33077                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33078 8E13           E8         7718            call	_outb_cmos
33079 8E16           83C4                   04  add	sp,*4
33080                                           !BCC_EOS
33081                                           ! 5570         outb_cmos(0x07, regs.u.r8.dl);
33082                                           ! Debug: list unsigned char regs = [S+4+$C] (used reg = )
33083 8E19           8A46         0E            mov	al,$E[bp]
33084 8E1C           30E4                       xor	ah,ah
33085 8E1E           50                         push	ax
33086                                           ! Debug: list int = const 7 (used reg = )
33087 8E1F           B8                   0007  mov	ax,*7
33088 8E22           50                         push	ax
33089                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33090 8E23           E8         7708            call	_outb_cmos
33091 8E26           83C4                   04  add	sp,*4
33092                                           !BCC_EOS
33093                                           ! 5571         outb_cmos(0x32, regs.u.r8.ch);
33094                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
33095 8E29           8A46         11            mov	al,$11[bp]
33096 8E2C           30E4                       xor	ah,ah
33097 8E2E           50                         push	ax
33098                                           ! Debug: list int = const $32 (used reg = )
33099 8E2F           B8                   0032  mov	ax,*$32
33100 8E32           50                         push	ax
33101                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33102 8E33           E8         76F8            call	_outb_cmos
33103 8E36           83C4                   04  add	sp,*4
33104                                           !BCC_EOS
33105                                           ! 5572       }
33106                                           ! 5573       val8 = val8 & 0x7f;
33107                       00008E39            .7D2:
33108                                           ! Debug: and int = const $7F to unsigned char val8 = [S+4-3] (used reg = )
33109 8E39           8A46         FF            mov	al,-1[bp]
33110 8E3C           24                     7F  and	al,*$7F
33111                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
33112 8E3E           8846         FF            mov	-1[bp],al
33113                                           !BCC_EOS
33114                                           ! 5574       outb_cmos(0x0b, val8);
33115                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
33116 8E41           8A46         FF            mov	al,-1[bp]
33117 8E44           30E4                       xor	ah,ah
33118 8E46           50                         push	ax
33119                                           ! Debug: list int = const $B (used reg = )
33120 8E47           B8                   000B  mov	ax,*$B
33121 8E4A           50                         push	ax
33122                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33123 8E4B           E8         76E0            call	_outb_cmos
33124 8E4E           83C4                   04  add	sp,*4
33125                                           !BCC_EOS
33126                                           ! 5575       regs.u.r8.ah = 0;
33127                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
33128 8E51           30C0                       xor	al,al
33129 8E53           8846         13            mov	$13[bp],al
33130                                           !BCC_EOS
33131                                           ! 5576       regs.u.r8.al = val8;
33132                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
33133 8E56           8A46         FF            mov	al,-1[bp]
33134 8E59           8846         12            mov	$12[bp],al
33135                                           !BCC_EOS
33136                                           ! 5577       iret_addr.flags.u.r8.flagsl &= 0xfe;
33137                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
33138 8E5C           8A46         1A            mov	al,$1A[bp]
33139 8E5F           24                     FE  and	al,#$FE
33140 8E61           8846         1A            mov	$1A[bp],al
33141                                           !BCC_EOS
33142                                           ! 5578       break;
33143 8E64           E9         025A            br 	.79E
33144                                           !BCC_EOS
33145                                           ! 5579     case 6:
33146                                           ! 5580       val8 = inb_cmos(0x0b);
33147                       00008E67            .7D3:
33148                                           ! Debug: list int = const $B (used reg = )
33149 8E67           B8                   000B  mov	ax,*$B
33150 8E6A           50                         push	ax
33151                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
33152 8E6B           E8         76CF            call	_inb_cmos
33153 8E6E           44                         inc	sp
33154 8E6F           44                         inc	sp
33155                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
33156 8E70           8846         FF            mov	-1[bp],al
33157                                           !BCC_EOS
33158                                           ! 5581       regs.u.r16.ax = 0;
33159                                           ! Debug: eq int = const 0 to unsigned short regs = [S+4+$10] (used reg = )
33160 8E73           31C0                       xor	ax,ax
33161 8E75           8946         12            mov	$12[bp],ax
33162                                           !BCC_EOS
33163                                           ! 5582       if (val8 & 0x20) {
33164                                           ! Debug: and int = const $20 to unsigned char val8 = [S+4-3] (used reg = )
33165 8E78           8A46         FF            mov	al,-1[bp]
33166 8E7B           24                     20  and	al,*$20
33167 8E7D           84C0                       test	al,al
33168 8E7F           74           0B            je  	.7D4
33169                       00008E81            .7D5:
33170                                           ! 5583         iret_addr.flags.u.r8.flagsl |= 0x01;
33171                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
33172 8E81           8A46         1A            mov	al,$1A[bp]
33173 8E84           0C                     01  or	al,*1
33174 8E86           8846         1A            mov	$1A[bp],al
33175                                           !BCC_EOS
33176                                           ! 5584         break;
33177 8E89           E9         0235            br 	.79E
33178                                           !BCC_EOS
33179                                           ! 5585       }
33180                                           ! 5586       if (rtc_updating()) {
33181                       00008E8C            .7D4:
33182                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
33183 8E8C           E8         76EB            call	_rtc_updating
33184 8E8F           85C0                       test	ax,ax
33185 8E91           74           03            je  	.7D6
33186                       00008E93            .7D7:
33187                                           ! 5587         init_rtc();
33188                                           ! Debug: func () void = init_rtc+0 (used reg = )
33189 8E93           E8         76B3            call	_init_rtc
33190                                           !BCC_EOS
33191                                           ! 5588       }
33192                                           ! 5589       if(val8&0x04){
33193                       00008E96            .7D6:
33194                                           ! Debug: and int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
33195 8E96           8A46         FF            mov	al,-1[bp]
33196 8E99           24                     04  and	al,*4
33197 8E9B           84C0                       test	al,al
33198 8E9D   7503    E9         007D            je  	.7D8
33199                       00008EA2            .7D9:
33200                                           ! 5590         hr = bcd2bin(regs.u.r8.ch);
33201                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
33202 8EA2           8A46         11            mov	al,$11[bp]
33203 8EA5           30E4                       xor	ah,ah
33204 8EA7           50                         push	ax
33205                                           ! Debug: func () unsigned char = bcd2bin+0 (used reg = )
33206 8EA8           E8         7720            call	_bcd2bin
33207 8EAB           44                         inc	sp
33208 8EAC           44                         inc	sp
33209                                           ! Debug: eq unsigned char = al+0 to unsigned char hr = [S+4-4] (used reg = )
33210 8EAD           8846         FE            mov	-2[bp],al
33211                                           !BCC_EOS
33212                                           ! 5591         outb_cmos(0x01, bcd2bin(regs.u.r8.dh));
33213                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
33214 8EB0           8A46         0F            mov	al,$F[bp]
33215 8EB3           30E4                       xor	ah,ah
33216 8EB5           50                         push	ax
33217                                           ! Debug: func () unsigned char = bcd2bin+0 (used reg = )
33218 8EB6           E8         7712            call	_bcd2bin
33219 8EB9           44                         inc	sp
33220 8EBA           44                         inc	sp
33221                                           ! Debug: list unsigned char = al+0 (used reg = )
33222 8EBB           30E4                       xor	ah,ah
33223 8EBD           50                         push	ax
33224                                           ! Debug: list int = const 1 (used reg = )
33225 8EBE           B8                   0001  mov	ax,*1
33226 8EC1           50                         push	ax
33227                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33228 8EC2           E8         7669            call	_outb_cmos
33229 8EC5           83C4                   04  add	sp,*4
33230                                           !BCC_EOS
33231                                           ! 5592         outb_cmos(0x03, bcd2bin(regs.u.r8.cl));
33232                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
33233 8EC8           8A46         10            mov	al,$10[bp]
33234 8ECB           30E4                       xor	ah,ah
33235 8ECD           50                         push	ax
33236                                           ! Debug: func () unsigned char = bcd2bin+0 (used reg = )
33237 8ECE           E8         76FA            call	_bcd2bin
33238 8ED1           44                         inc	sp
33239 8ED2           44                         inc	sp
33240                                           ! Debug: list unsigned char = al+0 (used reg = )
33241 8ED3           30E4                       xor	ah,ah
33242 8ED5           50                         push	ax
33243                                           ! Debug: list int = const 3 (used reg = )
33244 8ED6           B8                   0003  mov	ax,*3
33245 8ED9           50                         push	ax
33246                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33247 8EDA           E8         7651            call	_outb_cmos
33248 8EDD           83C4                   04  add	sp,*4
33249                                           !BCC_EOS
33250                                           ! 5593         if((val8&0x02)&&(hr>=12)) hr |= 0x80;
33251                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
33252 8EE0           8A46         FF            mov	al,-1[bp]
33253 8EE3           24                     02  and	al,*2
33254 8EE5           84C0                       test	al,al
33255 8EE7           74           0F            je  	.7DA
33256                       00008EE9            .7DC:
33257                                           ! Debug: ge int = const $C to unsigned char hr = [S+4-4] (used reg = )
33258 8EE9           8A46         FE            mov	al,-2[bp]
33259 8EEC           3C                     0C  cmp	al,*$C
33260 8EEE           72           08            jb  	.7DA
33261                       00008EF0            .7DB:
33262                                           ! Debug: orab int = const $80 to unsigned char hr = [S+4-4] (used reg = )
33263 8EF0           8A46         FE            mov	al,-2[bp]
33264 8EF3           0C                     80  or	al,#$80
33265 8EF5           8846         FE            mov	-2[bp],al
33266                                           !BCC_EOS
33267                                           ! 5594         if((val8&0x02)&&(hr==00)) hr = 12;
33268                       00008EF8            .7DA:
33269                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
33270 8EF8           8A46         FF            mov	al,-1[bp]
33271 8EFB           24                     02  and	al,*2
33272 8EFD           84C0                       test	al,al
33273 8EFF           74           0C            je  	.7DD
33274                       00008F01            .7DF:
33275                                           ! Debug: logeq int = const 0 to unsigned char hr = [S+4-4] (used reg = )
33276 8F01           8A46         FE            mov	al,-2[bp]
33277 8F04           84C0                       test	al,al
33278 8F06           75           05            jne 	.7DD
33279                       00008F08            .7DE:
33280                                           ! Debug: eq int = const $C to unsigned char hr = [S+4-4] (used reg = )
33281 8F08           B0                     0C  mov	al,*$C
33282 8F0A           8846         FE            mov	-2[bp],al
33283                                           !BCC_EOS
33284                                           ! 5595         outb_cmos(0x05, hr);
33285                       00008F0D            .7DD:
33286                                           ! Debug: list unsigned char hr = [S+4-4] (used reg = )
33287 8F0D           8A46         FE            mov	al,-2[bp]
33288 8F10           30E4                       xor	ah,ah
33289 8F12           50                         push	ax
33290                                           ! Debug: list int = const 5 (used reg = )
33291 8F13           B8                   0005  mov	ax,*5
33292 8F16           50                         push	ax
33293                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33294 8F17           E8         7614            call	_outb_cmos
33295 8F1A           83C4                   04  add	sp,*4
33296                                           !BCC_EOS
33297                                           ! 5596       }else{
33298 8F1D           EB           63            jmp .7E0
33299                       00008F1F            .7D8:
33300                                           ! 5597         hr = regs.u.r8.ch;
33301                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char hr = [S+4-4] (used reg = )
33302 8F1F           8A46         11            mov	al,$11[bp]
33303 8F22           8846         FE            mov	-2[bp],al
33304                                           !BCC_EOS
33305                                           ! 5598         outb_cmos(0x01, regs.u.r8.dh);
33306                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
33307 8F25           8A46         0F            mov	al,$F[bp]
33308 8F28           30E4                       xor	ah,ah
33309 8F2A           50                         push	ax
33310                                           ! Debug: list int = const 1 (used reg = )
33311 8F2B           B8                   0001  mov	ax,*1
33312 8F2E           50                         push	ax
33313                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33314 8F2F           E8         75FC            call	_outb_cmos
33315 8F32           83C4                   04  add	sp,*4
33316                                           !BCC_EOS
33317                                           ! 5599         outb_cmos(0x03, regs.u.r8.cl);
33318                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
33319 8F35           8A46         10            mov	al,$10[bp]
33320 8F38           30E4                       xor	ah,ah
33321 8F3A           50                         push	ax
33322                                           ! Debug: list int = const 3 (used reg = )
33323 8F3B           B8                   0003  mov	ax,*3
33324 8F3E           50                         push	ax
33325                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33326 8F3F           E8         75EC            call	_outb_cmos
33327 8F42           83C4                   04  add	sp,*4
33328                                           !BCC_EOS
33329                                           ! 5600         if((val8&0x02)&&(hr>=0x12)) hr |= 0x80;
33330                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
33331 8F45           8A46         FF            mov	al,-1[bp]
33332 8F48           24                     02  and	al,*2
33333 8F4A           84C0                       test	al,al
33334 8F4C           74           0F            je  	.7E1
33335                       00008F4E            .7E3:
33336                                           ! Debug: ge int = const $12 to unsigned char hr = [S+4-4] (used reg = )
33337 8F4E           8A46         FE            mov	al,-2[bp]
33338 8F51           3C                     12  cmp	al,*$12
33339 8F53           72           08            jb  	.7E1
33340                       00008F55            .7E2:
33341                                           ! Debug: orab int = const $80 to unsigned char hr = [S+4-4] (used reg = )
33342 8F55           8A46         FE            mov	al,-2[bp]
33343 8F58           0C                     80  or	al,#$80
33344 8F5A           8846         FE            mov	-2[bp],al
33345                                           !BCC_EOS
33346                                           ! 5601         if((val8&0x02)&&(hr==0x00)) hr = 0x12;
33347                       00008F5D            .7E1:
33348                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
33349 8F5D           8A46         FF            mov	al,-1[bp]
33350 8F60           24                     02  and	al,*2
33351 8F62           84C0                       test	al,al
33352 8F64           74           0C            je  	.7E4
33353                       00008F66            .7E6:
33354                                           ! Debug: logeq int = const 0 to unsigned char hr = [S+4-4] (used reg = )
33355 8F66           8A46         FE            mov	al,-2[bp]
33356 8F69           84C0                       test	al,al
33357 8F6B           75           05            jne 	.7E4
33358                       00008F6D            .7E5:
33359                                           ! Debug: eq int = const $12 to unsigned char hr = [S+4-4] (used reg = )
33360 8F6D           B0                     12  mov	al,*$12
33361 8F6F           8846         FE            mov	-2[bp],al
33362                                           !BCC_EOS
33363                                           ! 5602         outb_cmos(0x05, hr);
33364                       00008F72            .7E4:
33365                                           ! Debug: list unsigned char hr = [S+4-4] (used reg = )
33366 8F72           8A46         FE            mov	al,-2[bp]
33367 8F75           30E4                       xor	ah,ah
33368 8F77           50                         push	ax
33369                                           ! Debug: list int = const 5 (used reg = )
33370 8F78           B8                   0005  mov	ax,*5
33371 8F7B           50                         push	ax
33372                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33373 8F7C           E8         75AF            call	_outb_cmos
33374 8F7F           83C4                   04  add	sp,*4
33375                                           !BCC_EOS
33376                                           ! 5603       }
33377                                           ! 5604       outb(0x00a1, inb(0x00a1) & 0xfe);
33378                       00008F82            .7E0:
33379                                           ! Debug: list int = const $A1 (used reg = )
33380 8F82           B8                   00A1  mov	ax,#$A1
33381 8F85           50                         push	ax
33382                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33383 8F86           E8         756F            call	_inb
33384 8F89           44                         inc	sp
33385 8F8A           44                         inc	sp
33386                                           ! Debug: and int = const $FE to unsigned char = al+0 (used reg = )
33387 8F8B           24                     FE  and	al,#$FE
33388                                           ! Debug: list unsigned char = al+0 (used reg = )
33389 8F8D           30E4                       xor	ah,ah
33390 8F8F           50                         push	ax
33391                                           ! Debug: list int = const $A1 (used reg = )
33392 8F90           B8                   00A1  mov	ax,#$A1
33393 8F93           50                         push	ax
33394                                           ! Debug: func () void = outb+0 (used reg = )
33395 8F94           E8         7577            call	_outb
33396 8F97           83C4                   04  add	sp,*4
33397                                           !BCC_EOS
33398                                           ! 5605       outb_cmos(0x0b, (val
33399                                           ! 5605 8 & 0x7f) | 0x20);
33400                                           ! Debug: and int = const $7F to unsigned char val8 = [S+4-3] (used reg = )
33401 8F9A           8A46         FF            mov	al,-1[bp]
33402 8F9D           24                     7F  and	al,*$7F
33403                                           ! Debug: or int = const $20 to unsigned char = al+0 (used reg = )
33404 8F9F           0C                     20  or	al,*$20
33405                                           ! Debug: list unsigned char = al+0 (used reg = )
33406 8FA1           30E4                       xor	ah,ah
33407 8FA3           50                         push	ax
33408                                           ! Debug: list int = const $B (used reg = )
33409 8FA4           B8                   000B  mov	ax,*$B
33410 8FA7           50                         push	ax
33411                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33412 8FA8           E8         7583            call	_outb_cmos
33413 8FAB           83C4                   04  add	sp,*4
33414                                           !BCC_EOS
33415                                           ! 5606       iret_addr.flags.u.r8.flagsl &= 0xfe;
33416                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
33417 8FAE           8A46         1A            mov	al,$1A[bp]
33418 8FB1           24                     FE  and	al,#$FE
33419 8FB3           8846         1A            mov	$1A[bp],al
33420                                           !BCC_EOS
33421                                           ! 5607       break;
33422 8FB6           E9         0108            br 	.79E
33423                                           !BCC_EOS
33424                                           ! 5608     case 7:
33425                                           ! 5609       val8 = inb_cmos(0x0b);
33426                       00008FB9            .7E7:
33427                                           ! Debug: list int = const $B (used reg = )
33428 8FB9           B8                   000B  mov	ax,*$B
33429 8FBC           50                         push	ax
33430                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
33431 8FBD           E8         757D            call	_inb_cmos
33432 8FC0           44                         inc	sp
33433 8FC1           44                         inc	sp
33434                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
33435 8FC2           8846         FF            mov	-1[bp],al
33436                                           !BCC_EOS
33437                                           ! 5610       outb_cmos(0x0b, val8 & 0x57);
33438                                           ! Debug: and int = const $57 to unsigned char val8 = [S+4-3] (used reg = )
33439 8FC5           8A46         FF            mov	al,-1[bp]
33440 8FC8           24                     57  and	al,*$57
33441                                           ! Debug: list unsigned char = al+0 (used reg = )
33442 8FCA           30E4                       xor	ah,ah
33443 8FCC           50                         push	ax
33444                                           ! Debug: list int = const $B (used reg = )
33445 8FCD           B8                   000B  mov	ax,*$B
33446 8FD0           50                         push	ax
33447                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33448 8FD1           E8         755A            call	_outb_cmos
33449 8FD4           83C4                   04  add	sp,*4
33450                                           !BCC_EOS
33451                                           ! 5611       regs.u.r8.ah = 0;
33452                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
33453 8FD7           30C0                       xor	al,al
33454 8FD9           8846         13            mov	$13[bp],al
33455                                           !BCC_EOS
33456                                           ! 5612       regs.u.r8.al = val8;
33457                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
33458 8FDC           8A46         FF            mov	al,-1[bp]
33459 8FDF           8846         12            mov	$12[bp],al
33460                                           !BCC_EOS
33461                                           ! 5613       iret_addr.flags.u.r8.flagsl &= 0xfe;
33462                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
33463 8FE2           8A46         1A            mov	al,$1A[bp]
33464 8FE5           24                     FE  and	al,#$FE
33465 8FE7           8846         1A            mov	$1A[bp],al
33466                                           !BCC_EOS
33467                                           ! 5614       break;
33468 8FEA           E9         00D4            br 	.79E
33469                                           !BCC_EOS
33470                                           ! 5615     case 0xb1:
33471                                           ! 5616       if (regs.u.r8.bl == 0xff) {
33472                       00008FED            .7E8:
33473                                           ! Debug: logeq int = const $FF to unsigned char regs = [S+4+$A] (used reg = )
33474 8FED           8A46         0C            mov	al,$C[bp]
33475 8FF0           3C                     FF  cmp	al,#$FF
33476 8FF2           75           10            jne 	.7E9
33477                       00008FF4            .7EA:
33478                                           ! 5617         bios_printf(4, "PCI BIOS: PCI not present\n");
33479                                           ! Debug: list * char = .7EB+0 (used reg = )
33480 8FF4           BB                   CCC6  mov	bx,#.7EB
33481 8FF7           53                         push	bx
33482                                           ! Debug: list int = const 4 (used reg = )
33483 8FF8           B8                   0004  mov	ax,*4
33484 8FFB           50                         push	ax
33485                                           ! Debug: func () void = bios_printf+0 (used reg = )
33486 8FFC           E8         793F            call	_bios_printf
33487 8FFF           83C4                   04  add	sp,*4
33488                                           !BCC_EOS
33489                                           ! 5618       } else if (regs.u.r8.bl == 0x81) {
33490 9002           EB           78            jmp .7EC
33491                       00009004            .7E9:
33492                                           ! Debug: logeq int = const $81 to unsigned char regs = [S+4+$A] (used reg = )
33493 9004           8A46         0C            mov	al,$C[bp]
33494 9007           3C                     81  cmp	al,#$81
33495 9009           75           16            jne 	.7ED
33496                       0000900B            .7EE:
33497                                           ! 5619         bios_printf(4, "unsupported PCI BIOS function 0x%02x\n", regs.u.r8.al);
33498                                           ! Debug: list unsigned char regs = [S+4+$10] (used reg = )
33499 900B           8A46         12            mov	al,$12[bp]
33500 900E           30E4                       xor	ah,ah
33501 9010           50                         push	ax
33502                                           ! Debug: list * char = .7EF+0 (used reg = )
33503 9011           BB                   CCA0  mov	bx,#.7EF
33504 9014           53                         push	bx
33505                                           ! Debug: list int = const 4 (used reg = )
33506 9015           B8                   0004  mov	ax,*4
33507 9018           50                         push	ax
33508                                           ! Debug: func () void = bios_printf+0 (used reg = )
33509 9019           E8         7922            call	_bios_printf
33510 901C           83C4                   06  add	sp,*6
33511                                           !BCC_EOS
33512                                           ! 5620       } else if (regs.u.r8.bl == 0x83) {
33513 901F           EB           5B            jmp .7F0
33514                       00009021            .7ED:
33515                                           ! Debug: logeq int = const $83 to unsigned char regs = [S+4+$A] (used reg = )
33516 9021           8A46         0C            mov	al,$C[bp]
33517 9024           3C                     83  cmp	al,#$83
33518 9026           75           13            jne 	.7F1
33519                       00009028            .7F2:
33520                                           ! 5621         bios_printf(4, "bad PCI vendor ID %04x\n", regs.u.r16.dx);
33521                                           ! Debug: list unsigned short regs = [S+4+$C] (used reg = )
33522 9028           FF76         0E            push	$E[bp]
33523                                           ! Debug: list * char = .7F3+0 (used reg = )
33524 902B           BB                   CC88  mov	bx,#.7F3
33525 902E           53                         push	bx
33526                                           ! Debug: list int = const 4 (used reg = )
33527 902F           B8                   0004  mov	ax,*4
33528 9032           50                         push	ax
33529                                           ! Debug: func () void = bios_printf+0 (used reg = )
33530 9033           E8         7908            call	_bios_printf
33531 9036           83C4                   06  add	sp,*6
33532                                           !BCC_EOS
33533                                           ! 5622       } else if (regs.u.r8.bl == 0x86) {
33534 9039           EB           41            jmp .7F4
33535                       0000903B            .7F1:
33536                                           ! Debug: logeq int = const $86 to unsigned char regs = [S+4+$A] (used reg = )
33537 903B           8A46         0C            mov	al,$C[bp]
33538 903E           3C                     86  cmp	al,#$86
33539 9040           75           3A            jne 	.7F5
33540                       00009042            .7F6:
33541                                           ! 5623         if (regs.u.r8.al == 0x02) {
33542                                           ! Debug: logeq int = const 2 to unsigned char regs = [S+4+$10] (used reg = )
33543 9042           8A46         12            mov	al,$12[bp]
33544 9045           3C                     02  cmp	al,*2
33545 9047           75           19            jne 	.7F7
33546                       00009049            .7F8:
33547                                           ! 5624           bios_printf(4, "PCI device %04x:%04x not found at index %d\n", regs.u.r16.dx, regs.u.r16.cx, regs.u.r16.si);
33548                                           ! Debug: list unsigned short regs = [S+4+4] (used reg = )
33549 9049           FF76         06            push	6[bp]
33550                                           ! Debug: list unsigned short regs = [S+6+$E] (used reg = )
33551 904C           FF76         10            push	$10[bp]
33552                                           ! Debug: list unsigned short regs = [S+8+$C] (used reg = )
33553 904F           FF76         0E            push	$E[bp]
33554                                           ! Debug: list * char = .7F9+0 (used reg = )
33555 9052           BB                   CC5C  mov	bx,#.7F9
33556 9055           53                         push	bx
33557                                           ! Debug: list int = const 4 (used reg = )
33558 9056           B8                   0004  mov	ax,*4
33559 9059           50                         push	ax
33560                                           ! Debug: func () void = bios_printf+0 (used reg = )
33561 905A           E8         78E1            call	_bios_printf
33562 905D           83C4                   0A  add	sp,*$A
33563                                           !BCC_EOS
33564                                           ! 5625         } else {
33565 9060           EB           1A            jmp .7FA
33566                       00009062            .7F7:
33567                                           ! 5626           bios_printf(4, "no PCI device with class code 0x%02x%04x found at index %d\n", regs.u.r8.cl, regs.u.r16.dx, regs.u.r16.si);
33568                                           ! Debug: list unsigned short regs = [S+4+4] (used reg = )
33569 9062           FF76         06            push	6[bp]
33570                                           ! Debug: list unsigned short regs = [S+6+$C] (used reg = )
33571 9065           FF76         0E            push	$E[bp]
33572                                           ! Debug: list unsigned char regs = [S+8+$E] (used reg = )
33573 9068           8A46         10            mov	al,$10[bp]
33574 906B           30E4                       xor	ah,ah
33575 906D           50                         push	ax
33576                                           ! Debug: list * char = .7FB+0 (used reg = )
33577 906E           BB                   CC20  mov	bx,#.7FB
33578 9071           53                         push	bx
33579                                           ! Debug: list int = const 4 (used reg = )
33580 9072           B8                   0004  mov	ax,*4
33581 9075           50                         push	ax
33582                                           ! Debug: func () void = bios_printf+0 (used reg = )
33583 9076           E8         78C5            call	_bios_printf
33584 9079           83C4                   0A  add	sp,*$A
33585                                           !BCC_EOS
33586                                           ! 5627         }
33587                                           ! 5628       }
33588                       0000907C            .7FA:
33589                                           ! 5629       regs.u.r8.ah = regs.u.r8.bl;
33590                       0000907C            .7F5:
33591                       0000907C            .7F4:
33592                       0000907C            .7F0:
33593                       0000907C            .7EC:
33594                                           ! Debug: eq unsigned char regs = [S+4+$A] to unsigned char regs = [S+4+$11] (used reg = )
33595 907C           8A46         0C            mov	al,$C[bp]
33596 907F           8846         13            mov	$13[bp],al
33597                                           !BCC_EOS
33598                                           ! 5630       iret_addr.flags.u.r8.flagsl |= 0x01;
33599                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
33600 9082           8A46         1A            mov	al,$1A[bp]
33601 9085           0C                     01  or	al,*1
33602 9087           8846         1A            mov	$1A[bp],al
33603                                           !BCC_EOS
33604                                           ! 5631       break;
33605 908A           EB           35            jmp .79E
33606                                           !BCC_EOS
33607                                           ! 5632     default:
33608                                           ! 5633       iret_addr.flags.u.r8.flagsl |= 0x01;
33609                       0000908C            .7FC:
33610                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
33611 908C           8A46         1A            mov	al,$1A[bp]
33612 908F           0C                     01  or	al,*1
33613 9091           8846         1A            mov	$1A[bp],al
33614                                           !BCC_EOS
33615                                           ! 5634   }
33616                                           ! 5635 }
33617 9094           EB           2B            jmp .79E
33618                       00009096            .7A0:
33619 9096           2C                     00  sub	al,*0
33620 9098           72           F2            jb 	.7FC
33621 909A           3C                     07  cmp	al,*7
33622 909C           77           1B            ja  	.7FD
33623 909E           30E4                       xor	ah,ah
33624 90A0           D1E0                       shl	ax,*1
33625 90A2           89C3                       mov	bx,ax
33626 90A4           2E                         seg	cs
33627 90A5           FFA7       90A9            br	.7FE[bx]
33628                       000090A9            .7FE:
33629 90A9                      89FA            .word	.7A1
33630 90AB                      8A1E            .word	.7A2
33631 90AD                      8A41            .word	.7A3
33632 90AF                      8B78            .word	.7B5
33633 90B1                      8CAE            .word	.7C7
33634 90B3                      8D6D            .word	.7CD
33635 90B5                      8E67            .word	.7D3
33636 90B7                      8FB9            .word	.7E7
33637                       000090B9            .7FD:
33638 90B9           2C                     B1  sub	al,#$B1
33639 90BB         0F84         FF2E            beq 	.7E8
33640 90BF           EB           CB            jmp	.7FC
33641                       000090C1            .79E:
33642                       FFFFFFFC            ..FFD8	=	-4
33643 90C1           89EC                       mov	sp,bp
33644 90C3           5D                         pop	bp
33645 90C4           C3                         ret
33646                                           ! 5636   void
33647                                           ! Register BX used in function int1a_function
33648                                           ! 5637 int70_function(regs, ds, iret_addr)
33649                                           ! 5638   pusha_regs_t regs;
33650                                           export	_int70_function
33651                       000090C5            _int70_function:
33652                                           !BCC_EOS
33653                                           ! 5639   Bit16u ds;
33654                                           !BCC_EOS
33655                                           ! 5640   iret_addr_t iret_addr;
33656                                           !BCC_EOS
33657                                           ! 5641 {
33658                                           ! 5642   Bit8u registerB = 0, registerC = 0;
33659 90C5           55                         push	bp
33660 90C6           89E5                       mov	bp,sp
33661 90C8           4C                         dec	sp
33662                                           ! Debug: eq int = const 0 to unsigned char registerB = [S+3-3] (used reg = )
33663 90C9           30C0                       xor	al,al
33664 90CB           8846         FF            mov	-1[bp],al
33665 90CE           4C                         dec	sp
33666                                           ! Debug: eq int = const 0 to unsigned char registerC = [S+4-4] (used reg = )
33667 90CF           30C0                       xor	al,al
33668 90D1           8846         FE            mov	-2[bp],al
33669                                           !BCC_EOS
33670                                           ! 5643   registerB = inb_cmos( 0xB );
33671                                           ! Debug: list int = const $B (used reg = )
33672 90D4           B8                   000B  mov	ax,*$B
33673 90D7           50                         push	ax
33674                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
33675 90D8           E8         7462            call	_inb_cmos
33676 90DB           44                         inc	sp
33677 90DC           44                         inc	sp
33678                                           ! Debug: eq unsigned char = al+0 to unsigned char registerB = [S+4-3] (used reg = )
33679 90DD           8846         FF            mov	-1[bp],al
33680                                           !BCC_EOS
33681                                           ! 5644   registerC = inb_cmos( 0xC );
33682                                           ! Debug: list int = const $C (used reg = )
33683 90E0           B8                   000C  mov	ax,*$C
33684 90E3           50                         push	ax
33685                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
33686 90E4           E8         7456            call	_inb_cmos
33687 90E7           44                         inc	sp
33688 90E8           44                         inc	sp
33689                                           ! Debug: eq unsigned char = al+0 to unsigned char registerC = [S+4-4] (used reg = )
33690 90E9           8846         FE            mov	-2[bp],al
33691                                           !BCC_EOS
33692                                           ! 5645   if( ( registerB & 0x60 ) != 0 ) {
33693                                           ! Debug: and int = const $60 to unsigned char registerB = [S+4-3] (used reg = )
33694 90EC           8A46         FF            mov	al,-1[bp]
33695 90EF           24                     60  and	al,*$60
33696                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
33697 90F1           84C0                       test	al,al
33698 90F3         0F84         00B2            beq 	.7FF
33699                       000090F7            .800:
33700                                           ! 5646     if( ( registerC & 0x20 ) != 0 ) {
33701                                           ! Debug: and int = const $20 to unsigned char registerC = [S+4-4] (used reg = )
33702 90F7           8A46         FE            mov	al,-2[bp]
33703 90FA           24                     20  and	al,*$20
33704                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
33705 90FC           84C0                       test	al,al
33706 90FE           74           04            je  	.801
33707                       00009100            .802:
33708                                           ! 5647 #asm
33709                                           !BCC_EOS
33710                                           !BCC_ASM
33711                       00000000            _int70_function.registerC	set	0
33712                       FFFFFFFE            .int70_function.registerC	set	-2
33713                       00000016            _int70_function.ds	set	$16
33714                       00000014            .int70_function.ds	set	$14
33715                       00000001            _int70_function.registerB	set	1
33716                       FFFFFFFF            .int70_function.registerB	set	-1
33717                       00000018            _int70_function.iret_addr	set	$18
33718                       00000016            .int70_function.iret_addr	set	$16
33719                       00000006            _int70_function.regs	set	6
33720                       00000004            .int70_function.regs	set	4
33721 9100           FB                               sti
33722 9101           CD                     4A        int #0x4a
33723 9103           FA                               cli
33724                                           ! 5651 endasm
33725                                           !BCC_ENDASM
33726                                           !BCC_EOS
33727                                           ! 5652     }
33728                                           ! 5653     if( ( registerC & 0x40 ) != 0 ) {
33729                       00009104            .801:
33730                                           ! Debug: and int = const $40 to unsigned char registerC = [S+4-4] (used reg = )
33731 9104           8A46         FE            mov	al,-2[bp]
33732 9107           24                     40  and	al,*$40
33733                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
33734 9109           84C0                       test	al,al
33735 910B         0F84         009A            beq 	.803
33736                       0000910F            .804:
33737                                           ! 5654       if( *((Bit8u *)(0x4A0)) != 0 ) {
33738                                           ! Debug: ne int = const 0 to unsigned char = [+$4A0] (used reg = )
33739 910F           A0         04A0            mov	al,[$4A0]
33740 9112           84C0                       test	al,al
33741 9114         0F84         0091            beq 	.805
33742                       00009118            .806:
33743                                           ! 5655         Bit32u time, toggle;
33744                                           !BCC_EOS
33745                                           ! 5656         time = *((Bit32u *)(0x49C));
33746 9118           83C4                   F8  add	sp,*-8
33747                                           ! Debug: eq unsigned long = [+$49C] to unsigned long time = [S+$C-8] (used reg = )
33748 911B           A1         049C            mov	ax,[$49C]
33749 911E           8B1E       049E            mov	bx,[$49E]
33750 9122           8946         FA            mov	-6[bp],ax
33751 9125           895E         FC            mov	-4[bp],bx
33752                                           !BCC_EOS
33753                                           ! 5657         if( time < 0x3D1 ) {
33754                                           ! Debug: lt unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
33755 9128           B8                   03D1  mov	ax,#$3D1
33756 912B           31DB                       xor	bx,bx
33757 912D           8D7E         FA            lea	di,-6[bp]
33758 9130           E8         6F69            call	lcmpul
33759 9133           76           48            jbe 	.807
33760                       00009135            .808:
33761                                           ! 5658           Bit16u segment, offset;
33762                                           !BCC_EOS
33763                                           ! 5659           segment = *((Bit16u *)(0x498));
33764 9135           83C4                   FC  add	sp,*-4
33765                                           ! Debug: eq unsigned short = [+$498] to unsigned short segment = [S+$10-$E] (used reg = )
33766 9138           A1         0498            mov	ax,[$498]
33767 913B           8946         F4            mov	-$C[bp],ax
33768                                           !BCC_EOS
33769                                           ! 5660           offset = *((Bit16u *)(0x49A));
33770                                           ! Debug: eq unsigned short = [+$49A] to unsigned short offset = [S+$10-$10] (used reg = )
33771 913E           A1         049A            mov	ax,[$49A]
33772 9141           8946         F2            mov	-$E[bp],ax
33773                                           !BCC_EOS
33774                                           ! 5661           *((Bit8u *)(0x4A0)) = (0);
33775                                           ! Debug: eq int = const 0 to unsigned char = [+$4A0] (used reg = )
33776 9144           30C0                       xor	al,al
33777 9146           A2         04A0            mov	[$4A0],al
33778                                           !BCC_EOS
33779                                           ! 5662           outb_cmos( 0xB, registerB & 0x37 );
33780                                           ! Debug: and int = const $37 to unsigned char registerB = [S+$10-3] (used reg = )
33781 9149           8A46         FF            mov	al,-1[bp]
33782 914C           24                     37  and	al,*$37
33783                                           ! Debug: list unsigned char = al+0 (used reg = )
33784 914E           30E4                       xor	ah,ah
33785 9150           50                         push	ax
33786                                           ! Debug: list int = const $B (used reg = )
33787 9151           B8                   000B  mov	ax,*$B
33788 9154           50                         push	ax
33789                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33790 9155           E8         73D6            call	_outb_cmos
33791 9158           83C4                   04  add	sp,*4
33792                                           !BCC_EOS
33793                                           ! 5663           _write_byte(_read_byte(offset, segment) | 0x80, offset, segment);
33794                                           ! Debug: list unsigned short segment = [S+$10-$E] (used reg = )
33795 915B           FF76         F4            push	-$C[bp]
33796                                           ! Debug: list unsigned short offset = [S+$12-$10] (used reg = )
33797 915E           FF76         F2            push	-$E[bp]
33798                                           ! Debug: list unsigned short segment = [S+$14-$E] (used reg = )
33799 9161           FF76         F4            push	-$C[bp]
33800                                           ! Debug: list unsigned short offset = [S+$16-$10] (used reg = )
33801 9164           FF76         F2            push	-$E[bp]
33802                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
33803 9167           E8         747A            call	__read_byte
33804 916A           83C4                   04  add	sp,*4
33805                                           ! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
33806 916D           0C                     80  or	al,#$80
33807                                           ! Debug: list unsigned char = al+0 (used reg = )
33808 916F           30E4                       xor	ah,ah
33809 9171           50                         push	ax
33810                                           ! Debug: func () void = _write_byte+0 (used reg = )
33811 9172           E8         748B            call	__write_byte
33812 9175           83C4                   06  add	sp,*6
33813                                           !BCC_EOS
33814                                           ! 5664         } else {
33815 9178           83C4                   04  add	sp,*4
33816 917B           EB           29            jmp .809
33817                       0000917D            .807:
33818                                           ! 5665           time -= 0x3D1;
33819                                           ! Debug: subab unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
33820 917D           B8                   03D1  mov	ax,#$3D1
33821 9180           31DB                       xor	bx,bx
33822 9182           53                         push	bx
33823 9183           50                         push	ax
33824 9184           8B46         FA            mov	ax,-6[bp]
33825 9187           8B5E         FC            mov	bx,-4[bp]
33826 918A           8D7E         F2            lea	di,-$E[bp]
33827 918D           E8         6F22            call	lsubul
33828 9190           8946         FA            mov	-6[bp],ax
33829 9193           895E         FC            mov	-4[bp],bx
33830 9196           83C4                   04  add	sp,*4
33831                                           !BCC_EOS
33832                                           ! 5666           *((Bit32u *)(0x49C)) = (time);
33833                                           ! Debug: eq unsigned long time = [S+$C-8] to unsigned long = [+$49C] (used reg = )
33834 9199           8B46         FA            mov	ax,-6[bp]
33835 919C           8B5E         FC            mov	bx,-4[bp]
33836 919F           A3         049C            mov	[$49C],ax
33837 91A2           891E       049E            mov	[$49E],bx
33838                                           !BCC_EOS
33839                                           ! 5667         }
33840                                           ! 5668       }
33841                       000091A6            .809:
33842 91A6           83C4                   08  add	sp,*8
33843                                           ! 5669     }
33844                       000091A9            .805:
33845                                           ! 5670   }
33846                       000091A9            .803:
33847                                           ! 5671 #asm
33848                       000091A9            .7FF:
33849                                           !BCC_EOS
33850                                           !BCC_ASM
33851                       00000000            _int70_function.registerC	set	0
33852                       FFFFFFFE            .int70_function.registerC	set	-2
33853                       00000016            _int70_function.ds	set	$16
33854                       00000014            .int70_function.ds	set	$14
33855                       00000001            _int70_function.registerB	set	1
33856                       FFFFFFFF            .int70_function.registerB	set	-1
33857                       00000018            _int70_function.iret_addr	set	$18
33858                       00000016            .int70_function.iret_addr	set	$16
33859                       00000006            _int70_function.regs	set	6
33860                       00000004            .int70_function.regs	set	4
33861 91A9           E8         042D              call eoi_both_pics
33862                                           ! 5673 endasm
33863                                           !BCC_ENDASM
33864                                           !BCC_EOS
33865                                           ! 5674 }
33866 91AC           89EC                       mov	sp,bp
33867 91AE           5D                         pop	bp
33868 91AF           C3                         ret
33869                                           ! 5675 #asm
33870                                           !BCC_ASM
33871                       00000012            _int70_function.ds	set	$12
33872                       00000014            _int70_function.iret_addr	set	$14
33873                       00000002            _int70_function.regs	set	2
33874                                           ;------------------------------------------
33875                                           ;- INT74h : PS/2 mouse hardware interrupt -
33876                                           ;------------------------------------------
33877                       000091B0            int74_handler:
33878 91B0           FB                           sti
33879 91B1           60                           pusha
33880 91B2           1E                           push ds ;; save DS
33881 91B3           6A                     00    push #0x00
33882 91B5           1F                           pop ds
33883 91B6           FF36       040E              push 0x040E ;; push 0000:040E (opcodes 0xff, 0x36, 0x0E, 0x04)
33884 91BA           1F                           pop ds
33885 91BB           6A                     00    push #0x00 ;; placeholder for status
33886 91BD           6A                     00    push #0x00 ;; placeholder for X
33887 91BF           6A                     00    push #0x00 ;; placeholder for Y
33888 91C1           6A                     00    push #0x00 ;; placeholder for Z
33889 91C3           6A                     00    push #0x00 ;; placeholder for make_far_call boolean
33890 91C5           E8         C845              call _int74_function
33891 91C8           59                           pop cx ;; remove make_far_call from stack
33892 91C9           E3           04              jcxz int74_done
33893                                             ;; make far call to EBDA:0022
33894 91CB           FF1E       0022              call far ptr[0x22]
33895                       000091CF            int74_done:
33896 91CF           FA                           cli
33897 91D0           E8         0406              call eoi_both_pics
33898 91D3           83C4                   08    add sp, #8 ;; pop status, x, y, z
33899 91D6           1F                           pop ds ;; restore DS
33900 91D7           61                           popa
33901 91D8           CF                           iret
33902                                           ;; This will perform an IRET, but will retain value of current CF
33903                                           ;; by altering flags on stack. Better than RETF #02.
33904                       000091D9            iret_modify_cf:
33905 91D9           72           09              jc carry_set
33906 91DB           55                           push bp
33907 91DC           89E5                         mov bp, sp
33908 91DE           8066         06        FE    and BYTE [bp + 0x06], #0xfe
33909 91E2           5D                           pop bp
33910 91E3           CF                           iret
33911                       000091E4            carry_set:
33912 91E4           55                           push bp
33913 91E5           89E5                         mov bp, sp
33914 91E7           804E         06        01    or BYTE [bp + 0x06], #0x01
33915 91EB           5D                           pop bp
33916 91EC           CF                           iret
33917                                           ;----------------------
33918                                           ;- INT13h (relocated) -
33919                                           ;----------------------
33920                                           ;
33921                                           ; int13_relocated is a little bit messed up since I played with it
33922                                           ; I have to rewrite it:
33923                                           ; - call a function that detect which function to call
33924                                           ; - make all called C function get the same parameters list
33925                                           ;
33926                       000091ED            int13_relocated:
33927                                             ;; check for an eltorito function
33928 91ED           80FC                   4A    cmp ah,#0x4a
33929 91F0           72           0E              jb int13_not_eltorito
33930 91F2           80FC                   4D    cmp ah,#0x4d
33931 91F5           77           09              ja int13_not_eltorito
33932 91F7           60                           pusha
33933 91F8           06                           push es
33934 91F9           1E                           push ds
33935 91FA           68                   927E    push #int13_out
33936 91FD           E9         DC03              jmp _int13_eltorito ;; ELDX not used
33937                       00009200            int13_not_eltorito:
33938 9200           50                           push ax
33939 9201           53                           push bx
33940 9202           51                           push cx
33941 9203           52                           push dx
33942                                             ;; check if emulation active
33943 9204           E8         A35F              call _cdemu_isactive
33944 9207           3C                     00    cmp al,#0x00
33945 9209           74           31              je int13_cdemu_inactive
33946                                             ;; check if access to the emulated drive
33947 920B           E8         A374              call _cdemu_emulated_drive
33948 920E           5A                           pop dx
33949 920F           52                           push dx
33950 9210           38D0                         cmp al,dl ;; int13 on emulated drive
33951 9212           75           15              jne int13_nocdemu
33952 9214           5A                           pop dx
33953 9215           59                           pop cx
33954 9216           5B                           pop bx
33955 9217           58                           pop ax
33956 9218           60                           pusha
33957 9219           06                           push es
33958 921A           1E                           push ds
33959 921B           6A                     40    push #0x40
33960 921D           1F                           pop ds
33961 921E           FF36       000E              push 0x000E
33962 9222           1F                           pop ds ;; Set DS to EBDA segment
33963 9223           68                   927E    push #int13_out
33964 9226           E9         DDDD              jmp _int13_cdemu ;; ELDX not used
33965                       00009229            int13_nocdemu:
33966 9229           80E2                   E0    and dl,#0xE0 ;; mask to get device class, including cdroms
33967 922C           38D0                         cmp al,dl ;; al is 0x00 or 0x80
33968 922E           75           0C              jne int13_cdemu_inactive ;; inactive for device class
33969 9230           5A                           pop dx
33970 9231           59                           pop cx
33971 9232           5B                           pop bx
33972 9233           58                           pop ax
33973 9234           50                           push ax
33974 9235           51                           push cx
33975 9236           52                           push dx
33976 9237           53                           push bx
33977 9238           FECA                         dec dl ;; real drive is dl - 1
33978 923A           EB           08              jmp int13_legacy
33979                       0000923C            int13_cdemu_inactive:
33980 923C           5A                           pop dx
33981 923D           59                           pop cx
33982 923E           5B                           pop bx
33983 923F           58                           pop ax
33984                       00009240            int13_noeltorito:
33985 9240           50                           push ax
33986 9241           51                           push cx
33987 9242           52                           push dx
33988 9243           53                           push bx
33989                       00009244            int13_legacy:
33990 9244           52                           push dx ;; push eltorito value of dx instead of sp
33991 9245           55                           push bp
33992 9246           56                           push si
33993 9247           57                           push di
33994 9248           06                           push es
33995 9249           1E                           push ds
33996 924A           6A                     40    push #0x40
33997 924C           1F                           pop ds ;; Set DS to 0x40
33998                                             ;; now the 16-bit registers can be restored with:
33999                                             ;; pop ds; pop es; popa; iret
34000                                             ;; arguments passed to functions should be
34001                                             ;; DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS
34002 924D           F6C2                   80    test dl, #0x80
34003 9250           75           06              jnz int13_notfloppy
34004 9252           68                   927E    push #int13_out
34005 9255           E9         E53B              jmp _int13_diskette_function
34006                       00009258            int13_notfloppy:
34007 9258           FF36       000E              push 0x000E
34008 925C           1F                           pop ds ;; Set DS to EBDA segment
34009 925D           80FA                   E0    cmp dl, #0xE0
34010 9260           72           0F              jb int13_notcdrom
34011 9262     66    C1EB                   10    shr ebx, #16
34012 9266           53                           push bx
34013 9267           E8         D6A4              call _int13_cdrom
34014 926A           5B                           pop bx
34015 926B     66    C1E3                   10    shl ebx, #16
34016 926F           EB           0D              jmp int13_out
34017                       00009271            int13_notcdrom:
34018                       00009271            int13_disk:
34019                                             ;; int13_harddisk modifies high word of EAX
34020 9271     66    C1E8                   10    shr eax, #16
34021 9275           50                           push ax
34022 9276           E8         CEE2              call _int13_harddisk
34023 9279           58                           pop ax
34024 927A     66    C1E0                   10    shl eax, #16
34025                       0000927E            int13_out:
34026 927E           1F                           pop ds
34027 927F           07                           pop es
34028 9280           61                           popa
34029 9281           CF                           iret
34030                                           ;----------
34031                                           ;- INT18h -
34032                                           ;----------
34033                       00009282            int18_handler: ;; Boot Failure recovery: try the next device.
34034                                             ;; Reset SP and SS
34035 9282           B8                   FFFE    mov ax, #0xfffe
34036 9285           89C4                         mov sp, ax
34037 9287           31C0                         xor ax, ax
34038 9289           8ED0                         mov ss, ax
34039                                             ;; Get the boot sequence number out of the IPL memory
34040 928B           BB                   9FF0    mov bx, #0x9ff0
34041 928E           8EDB                         mov ds, bx ;; Set segment
34042 9290           8B1E       0082              mov bx, 0x0082 ;; BX is now the sequence number
34043 9294           43                           inc bx ;; ++
34044 9295           891E       0082              mov 0x0082, bx ;; Write it back
34045 9299           8ED8                         mov ds, ax ;; and reset the segment to zero.
34046                                             ;; Carry on in the INT 19h handler, using the new sequence number
34047 929B           53                           push bx
34048 929C           EB           17              jmp int19_next_boot
34049                                           ;----------
34050                                           ;- INT19h -
34051                                           ;----------
34052                       0000929E            int19_relocated: ;; Boot function, relocated
34053                                             ;; int19 was beginning to be really complex, so now it
34054                                             ;; just calls a C function that does the work
34055 929E           55                           push bp
34056 929F           89E5                         mov bp, sp
34057                                             ;; Reset SS and SP
34058 92A1           B8                   FFFE    mov ax, #0xfffe
34059 92A4           89C4                         mov sp, ax
34060 92A6           31C0                         xor ax, ax
34061 92A8           8ED0                         mov ss, ax
34062                                             ;; Start from the first boot device (0, in AX)
34063 92AA           BB                   9FF0    mov bx, #0x9ff0
34064 92AD           8EDB                         mov ds, bx ;; Set segment to write to the IPL memory
34065 92AF           A3         0082              mov 0x0082, ax ;; Save the sequence number
34066 92B2           8ED8                         mov ds, ax ;; and reset the segment.
34067 92B4           50                           push ax
34068                       000092B5            int19_next_boot:
34069                                             ;; Call the C code for the next boot device
34070 92B5           E8         F4FA              call _int19_function
34071                                             ;; Boot failed: invoke the boot recovery function
34072 92B8           CD                     18    int #0x18
34073                                           ;----------------------
34074                                           ;- POST: Floppy Drive -
34075                                           ;----------------------
34076                       000092BA            floppy_drive_post:
34077 92BA           31C0                         xor ax, ax
34078 92BC           8ED8                         mov ds, ax
34079 92BE           B0                     00    mov al, #0x00
34080 92C0           A2         043E              mov 0x043e, al ;; drive 0 & 1 uncalibrated, no interrupt has occurred
34081 92C3           A2         043F              mov 0x043f, al ;; diskette motor status: read op, drive0, motors off
34082 92C6           A2         0440              mov 0x0440, al ;; diskette motor timeout counter: not active
34083 92C9           A2         0441              mov 0x0441, al ;; diskette controller status return code
34084 92CC           A2         0442              mov 0x0442, al ;; disk & diskette controller status register 0
34085 92CF           A2         0443              mov 0x0443, al ;; diskette controller status register 1
34086 92D2           A2         0444              mov 0x0444, al ;; diskette controller status register 2
34087 92D5           A2         0445              mov 0x0445, al ;; diskette controller cylinder number
34088 92D8           A2         0446              mov 0x0446, al ;; diskette controller head number
34089 92DB           A2         0447              mov 0x0447, al ;; diskette controller sector number
34090 92DE           A2         0448              mov 0x0448, al ;; diskette controller bytes written
34091 92E1           A2         048B              mov 0x048b, al ;; diskette configuration data
34092                                             ;; -----------------------------------------------------------------
34093                                             ;; (048F) diskette controller information
34094                                             ;;
34095 92E4           B0                     10    mov al, #0x10 ;; get CMOS diskette drive type
34096 92E6           E6                     70    out 0x0070, AL
34097 92E8           E4                     71    in AL, 0x0071
34098 92EA           88C4                         mov ah, al ;; save byte to AH
34099                       000092EC            look_drive0:
34100 92EC           C0E8                   04    shr al, #4 ;; look at top 4 bits for drive 0
34101 92EF           74           04              jz f0_missing ;; jump if no drive0
34102 92F1           B3                     07    mov bl, #0x07 ;; drive0 determined, multi-rate, has changed line
34103 92F3           EB           02              jmp look_drive1
34104                       000092F5            f0_missing:
34105 92F5           B3                     00    mov bl, #0x00 ;; no drive0
34106                       000092F7            look_drive1:
34107 92F7           88E0                         mov al, ah ;; restore from AH
34108 92F9           24                     0F    and al, #0x0f ;; look at bottom 4 bits for drive 1
34109 92FB           74           03              jz f1_missing ;; jump if no drive1
34110 92FD           80CB                   70    or bl, #0x70 ;; drive1 determined, multi-rate, has changed line
34111                       00009300            f1_missing:
34112                                                              ;; leave high bits in BL zerod
34113 9300           881E       048F              mov 0x048f, bl ;; put new val in BDA (diskette controller information)
34114                                             ;; -----------------------------------------------------------------
34115 9304           B0                     00    mov al, #0x00
34116 9306           A2         0490              mov 0x0490, al ;; diskette 0 media state
34117 9309           A2         0491              mov 0x0491, al ;; diskette 1 media state
34118                                                              ;; diskette 0,1 operational starting state
34119                                                              ;; drive type has not been determined,
34120                                                              ;; has no changed detection line
34121 930C           A2         0492              mov 0x0492, al
34122 930F           A2         0493              mov 0x0493, al
34123 9312           A2         0494              mov 0x0494, al ;; diskette 0 current cylinder
34124 9315           A2         0495              mov 0x0495, al ;; diskette 1 current cylinder
34125 9318           B0                     02    mov al, #0x02
34126 931A           E6                     0A    out 0x000a, al ;; clear DMA-1 channel 2 mask bit
34127                                             SET_INT_VECTOR(0x1E, #0xF000, #diskette_param_table2)
 +a   931C           B8                   EFDE    mov ax,  #diskette_param_table2
 +a   931F           A3         0078              mov 0x1E*4, ax
 +a   9322           B8                   F000    mov ax,  #0xF000
 +a   9325           A3         007A              mov 0x1E*4+2, ax
34128                                             SET_INT_VECTOR(0x40, #0xF000, #int13_diskette)
 +a   9328           B8                   EC59    mov ax,  #int13_diskette
 +a   932B           A3         0100              mov 0x40*4, ax
 +a   932E           B8                   F000    mov ax,  #0xF000
 +a   9331           A3         0102              mov 0x40*4+2, ax
34129                                             SET_INT_VECTOR(0x0E, #0xF000, #int0e_handler) ;; IRQ 6
 +a   9334           B8                   EF57    mov ax,  #int0e_handler
 +a   9337           A3         0038              mov 0x0E*4, ax
 +a   933A           B8                   F000    mov ax,  #0xF000
 +a   933D           A3         003A              mov 0x0E*4+2, ax
34130 9340           C3                           ret
34131                                           ;--------------------
34132                                           ;- POST: HARD DRIVE -
34133                                           ;--------------------
34134                                           ; relocated here because the primary POST area isnt big enough.
34135                       00009341            hard_drive_post:
34136 9341           B0                     0A    mov al, #0x0a ; 0000 1010 = reserved, disable IRQ 14
34137 9343           BA                   03F6    mov dx, #0x03f6
34138 9346           EE                           out dx, al
34139 9347           31C0                         xor ax, ax
34140 9349           8ED8                         mov ds, ax
34141 934B           A2         0474              mov 0x0474, al
34142 934E           A2         0477              mov 0x0477, al
34143 9351           A2         048C              mov 0x048c, al
34144 9354           A2         048D              mov 0x048d, al
34145 9357           A2         048E              mov 0x048e, al
34146 935A           B0                     01    mov al, #0x01
34147 935C           A2         0475              mov 0x0475, al
34148 935F           B0                     C0    mov al, #0xc0
34149 9361           A2         0476              mov 0x0476, al
34150                                             SET_INT_VECTOR(0x13, #0xF000, #int13_handler)
 +a   9364           B8                   E3FE    mov ax,  #int13_handler
 +a   9367           A3         004C              mov 0x13*4, ax
 +a   936A           B8                   F000    mov ax,  #0xF000
 +a   936D           A3         004E              mov 0x13*4+2, ax
34151                                             SET_INT_VECTOR(0x76, #0xF000, #int76_handler)
 +a   9370           B8                   9647    mov ax,  #int76_handler
 +a   9373           A3         01D8              mov 0x76*4, ax
 +a   9376           B8                   F000    mov ax,  #0xF000
 +a   9379           A3         01DA              mov 0x76*4+2, ax
34152                                             ;; INT 41h: hard disk 0 configuration pointer
34153                                             ;; INT 46h: hard disk 1 configuration pointer
34154                                             SET_INT_VECTOR(0x41, #0x9FC0, #0x003D)
 +a   937C           B8                   003D    mov ax,  #0x003D
 +a   937F           A3         0104              mov 0x41*4, ax
 +a   9382           B8                   9FC0    mov ax,  #0x9FC0
 +a   9385           A3         0106              mov 0x41*4+2, ax
34155                                             SET_INT_VECTOR(0x46, #0x9FC0, #0x004D)
 +a   9388           B8                   004D    mov ax,  #0x004D
 +a   938B           A3         0118              mov 0x46*4, ax
 +a   938E           B8                   9FC0    mov ax,  #0x9FC0
 +a   9391           A3         011A              mov 0x46*4+2, ax
34156                                             ;; move disk geometry data from CMOS to EBDA disk parameter table(s)
34157 9394           B0                     12    mov al, #0x12
34158 9396           E6                     70    out 0x0070, al
34159 9398           E4                     71    in al, 0x0071
34160 939A           24                     F0    and al, #0xf0
34161 939C           3C                     F0    cmp al, #0xf0
34162 939E           74           03              je post_d0_extended
34163 93A0           E9         00D4              jmp check_for_hd1
34164                       000093A3            post_d0_extended:
34165 93A3           B0                     19    mov al, #0x19
34166 93A5           E6                     70    out 0x0070, al
34167 93A7           E4                     71    in al, 0x0071
34168 93A9           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
34169 93AB           74           07              je post_d0_type47
34170                                             HALT(9217)
 +a   93AD           BA                   0400    mov dx,#0x400
 +a   93B0           B8                   2401    mov ax,#9217
 +a   93B3           EF                           out dx,ax
34171                       000093B4            post_d0_type47:
34172                                             ;; CMOS purpose param table offset
34173                                             ;; 1b cylinders low 0
34174                                             ;; 1c cylinders high 1
34175                                             ;; 1d heads 2
34176                                             ;; 1e write pre-comp low 5
34177                                             ;; 1f write pre-comp high 6
34178                                             ;; 20 retries/bad map/heads>8 8
34179                                             ;; 21 landing zone low C
34180                                             ;; 22 landing zone high D
34181                                             ;; 23 sectors/track E
34182 93B4           B8                   9FC0    mov ax, #0x9FC0
34183 93B7           8ED8                         mov ds, ax
34184                                             ;;; Filling EBDA table for hard disk 0.
34185 93B9           B0                     1F    mov al, #0x1f
34186 93BB           E6                     70    out 0x0070, al
34187 93BD           E4                     71    in al, 0x0071
34188 93BF           88C4                         mov ah, al
34189 93C1           B0                     1E    mov al, #0x1e
34190 93C3           E6                     70    out 0x0070, al
34191 93C5           E4                     71    in al, 0x0071
34192 93C7           A3         0042              mov (0x003d + 0x05), ax ;; write precomp word
34193 93CA           B0                     20    mov al, #0x20
34194 93CC           E6                     70    out 0x0070, al
34195 93CE           E4                     71    in al, 0x0071
34196 93D0           A2         0045              mov (0x003d + 0x08), al ;; drive control byte
34197 93D3           B0                     22    mov al, #0x22
34198 93D5           E6                     70    out 0x0070, al
34199 93D7           E4                     71    in al, 0x0071
34200 93D9           88C4                         mov ah, al
34201 93DB           B0                     21    mov al, #0x21
34202 93DD           E6                     70    out 0x0070, al
34203 93DF           E4                     71    in al, 0x0071
34204 93E1           A3         0049              mov (0x003d + 0x0C), ax ;; landing zone word
34205 93E4           B0                     1C    mov al, #0x1c ;; get cylinders word in AX
34206 93E6           E6                     70    out 0x0070, al
34207 93E8           E4                     71    in al, 0x0071 ;; high byte
34208 93EA           88C4                         mov ah, al
34209 93EC           B0                     1B    mov al, #0x1b
34210 93EE           E6                     70    out 0x0070, al
34211 93F0           E4                     71    in al, 0x0071 ;; low byte
34212 93F2           89C3                         mov bx, ax ;; BX = cylinders
34213 93F4           B0                     1D    mov al, #0x1d
34214 93F6           E6                     70    out 0x0070, al
34215 93F8           E4                     71    in al, 0x0071
34216 93FA           88C1                         mov cl, al ;; CL = heads
34217 93FC           B0                     23    mov al, #0x23
34218 93FE           E6                     70    out 0x0070, al
34219 9400           E4                     71    in al, 0x0071
34220 9402           88C2                         mov dl, al ;; DL = sectors
34221 9404           81FB                 0400    cmp bx, #1024
34222 9408           77           0E              jnbe hd0_post_logical_chs ;; if cylinders > 1024, use translated style CHS
34223                       0000940A            hd0_post_physical_chs:
34224                                             ;; no logical CHS mapping used, just physical CHS
34225                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
34226 940A           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
34227 940E           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
34228 9412           8816       004B              mov (0x003d + 0x0E), dl ;; number of physical sectors
34229 9416           EB           5F              jmp check_for_hd1
34230                       00009418            hd0_post_logical_chs:
34231                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
34232 9418           891E       0046              mov (0x003d + 0x09), bx ;; number of physical cylinders
34233 941C           880E       0048              mov (0x003d + 0x0b), cl ;; number of physical heads
34234 9420           8816       0041              mov (0x003d + 0x04), dl ;; number of physical sectors
34235 9424           8816       004B              mov (0x003d + 0x0e), dl ;; number of logical sectors (same)
34236 9428           B0                     A0    mov al, #0xa0
34237 942A           A2         0040              mov (0x003d + 0x03), al ;; A0h signature, indicates translated table
34238 942D           81FB                 0800    cmp bx, #2048
34239 9431           77           06              jnbe hd0_post_above_2048
34240                                             ;; 1024 < c <= 2048 cylinders
34241 9433           D1EB                         shr bx, #0x01
34242 9435           D0E1                         shl cl, #0x01
34243 9437           EB           22              jmp hd0_post_store_logical
34244                       00009439            hd0_post_above_2048:
34245 9439           81FB                 1000    cmp bx, #4096
34246 943D           77           08              jnbe hd0_post_above_4096
34247                                             ;; 2048 < c <= 4096 cylinders
34248 943F           C1EB                   02    shr bx, #0x02
34249 9442           C0E1                   02    shl cl, #0x02
34250 9445           EB           14              jmp hd0_post_store_logical
34251                       00009447            hd0_post_above_4096:
34252 9447           81FB                 2000    cmp bx, #8192
34253 944B           77           08              jnbe hd0_post_above_8192
34254                                             ;; 4096 < c <= 8192 cylinders
34255 944D           C1EB                   03    shr bx, #0x03
34256 9450           C0E1                   03    shl cl, #0x03
34257 9453           EB           06              jmp hd0_post_store_logical
34258                       00009455            hd0_post_above_8192:
34259                                             ;; 8192 < c <= 16384 cylinders
34260 9455           C1EB                   04    shr bx, #0x04
34261 9458           C0E1                   04    shl cl, #0x04
34262                       0000945B            hd0_post_store_logical:
34263 945B           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
34264 945F           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
34265                                             ;; checksum
34266 9463           B1                     0F    mov cl, #0x0f ;; repeat count
34267 9465           BE                   003D    mov si, #0x003d ;; offset to disk0 FDPT
34268 9468           B0                     00    mov al, #0x00 ;; sum
34269                       0000946A            hd0_post_checksum_loop:
34270 946A           0204                         add al, [si]
34271 946C           46                           inc si
34272 946D           FEC9                         dec cl
34273 946F           75           F9              jnz hd0_post_checksum_loop
34274 9471           F6D0                         not al ;; now take 2s complement
34275 9473           FEC0                         inc al
34276 9475           8804                         mov [si], al
34277                                           ;;; Done filling EBDA table for hard disk 0.
34278                       00009477            check_for_hd1:
34279                                             ;; is there really a second hard disk? if not, return now
34280 9477           B0                     12    mov al, #0x12
34281 9479           E6                     70    out 0x0070, al
34282 947B           E4                     71    in al, 0x0071
34283 947D           24                     0F    and al, #0x0f
34284 947F           75           01              jnz post_d1_exists
34285 9481           C3                           ret
34286                       00009482            post_d1_exists:
34287                                             ;; check that the hd type is really 0x0f.
34288 9482           3C                     0F    cmp al, #0x0f
34289 9484           74           07              jz post_d1_extended
34290                                             HALT(9354)
 +a   9486           BA                   0400    mov dx,#0x400
 +a   9489           B8                   248A    mov ax,#9354
 +a   948C           EF                           out dx,ax
34291                       0000948D            post_d1_extended:
34292                                             ;; check that the extended type is 47 - user definable
34293 948D           B0                     1A    mov al, #0x1a
34294 948F           E6                     70    out 0x0070, al
34295 9491           E4                     71    in al, 0x0071
34296 9493           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
34297 9495           74           07              je post_d1_type47
34298                                             HALT(9362)
 +a   9497           BA                   0400    mov dx,#0x400
 +a   949A           B8                   2492    mov ax,#9362
 +a   949D           EF                           out dx,ax
34299                       0000949E            post_d1_type47:
34300                                             ;; Table for disk1.
34301                                             ;; CMOS purpose param table offset
34302                                             ;; 0x24 cylinders low 0
34303                                             ;; 0x25 cylinders high 1
34304                                             ;; 0x26 heads 2
34305                                             ;; 0x27 write pre-comp low 5
34306                                             ;; 0x28 write pre-comp high 6
34307                                             ;; 0x29 heads>8 8
34308                                             ;; 0x2a landing zone low C
34309                                             ;; 0x2b landing zone high D
34310                                             ;; 0x2c sectors/track E
34311                                           ;;; Fill EBDA table for hard disk 1.
34312 949E           B8                   9FC0    mov ax, #0x9FC0
34313 94A1           8ED8                         mov ds, ax
34314 94A3           B0                     28    mov al, #0x28
34315 94A5           E6                     70    out 0x0070, al
34316 94A7           E4                     71    in al, 0x0071
34317 94A9           88C4                         mov ah, al
34318 94AB           B0                     27    mov al, #0x27
34319 94AD           E6                     70    out 0x0070, al
34320 94AF           E4                     71    in al, 0x0071
34321 94B1           A3         0052              mov (0x004d + 0x05), ax ;; write precomp word
34322 94B4           B0                     29    mov al, #0x29
34323 94B6           E6                     70    out 0x0070, al
34324 94B8           E4                     71    in al, 0x0071
34325 94BA           A2         0055              mov (0x004d + 0x08), al ;; drive control byte
34326 94BD           B0                     2B    mov al, #0x2b
34327 94BF           E6                     70    out 0x0070, al
34328 94C1           E4                     71    in al, 0x0071
34329 94C3           88C4                         mov ah, al
34330 94C5           B0                     2A    mov al, #0x2a
34331 94C7           E6                     70    out 0x0070, al
34332 94C9           E4                     71    in al, 0x0071
34333 94CB           A3         0059              mov (0x004d + 0x0C), ax ;; landing zone word
34334 94CE           B0                     25    mov al, #0x25 ;; get cylinders word in AX
34335 94D0           E6                     70    out 0x0070, al
34336 94D2           E4                     71    in al, 0x0071 ;; high byte
34337 94D4           88C4                         mov ah, al
34338 94D6           B0                     24    mov al, #0x24
34339 94D8           E6                     70    out 0x0070, al
34340 94DA           E4                     71    in al, 0x0071 ;; low byte
34341 94DC           89C3                         mov bx, ax ;; BX = cylinders
34342 94DE           B0                     26    mov al, #0x26
34343 94E0           E6                     70    out 0x0070, al
34344 94E2           E4                     71    in al, 0x0071
34345 94E4           88C1                         mov cl, al ;; CL = heads
34346 94E6           B0                     2C    mov al, #0x2c
34347 94E8           E6                     70    out 0x0070, al
34348 94EA           E4                     71    in al, 0x0071
34349 94EC           88C2                         mov dl, al ;; DL = sectors
34350 94EE           81FB                 0400    cmp bx, #1024
34351 94F2           77           0D              jnbe hd1_post_logical_chs ;; if cylinders > 1024, use translated style CHS
34352                       000094F4            hd1_post_physical_chs:
34353                                             ;; no logical CHS mapping used, just physical CHS
34354                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
34355 94F4           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
34356 94F8           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
34357 94FC           8816       005B              mov (0x004d + 0x0E), dl ;; number of physical sectors
34358 9500           C3                           ret
34359                       00009501            hd1_post_logical_chs:
34360                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
34361 9501           891E       0056              mov (0x004d + 0x09), bx ;; number of physical cylinders
34362 9505           880E       0058              mov (0x004d + 0x0b), cl ;; number of physical heads
34363 9509           8816       0051              mov (0x004d + 0x04), dl ;; number of physical sectors
34364 950D           8816       005B              mov (0x004d + 0x0e), dl ;; number of logical sectors (same)
34365 9511           B0                     A0    mov al, #0xa0
34366 9513           A2         0050              mov (0x004d + 0x03), al ;; A0h signature, indicates translated table
34367 9516           81FB                 0800    cmp bx, #2048
34368 951A           77           06              jnbe hd1_post_above_2048
34369                                             ;; 1024 < c <= 2048 cylinders
34370 951C           D1EB                         shr bx, #0x01
34371 951E           D0E1                         shl cl, #0x01
34372 9520           EB           22              jmp hd1_post_store_logical
34373                       00009522            hd1_post_above_2048:
34374 9522           81FB                 1000    cmp bx, #4096
34375 9526           77           08              jnbe hd1_post_above_4096
34376                                             ;; 2048 < c <= 4096 cylinders
34377 9528           C1EB                   02    shr bx, #0x02
34378 952B           C0E1                   02    shl cl, #0x02
34379 952E           EB           14              jmp hd1_post_store_logical
34380                       00009530            hd1_post_above_4096:
34381 9530           81FB                 2000    cmp bx, #8192
34382 9534           77           08              jnbe hd1_post_above_8192
34383                                             ;; 4096 < c <= 8192 cylinders
34384 9536           C1EB                   03    shr bx, #0x03
34385 9539           C0E1                   03    shl cl, #0x03
34386 953C           EB           06              jmp hd1_post_store_logical
34387                       0000953E            hd1_post_above_8192:
34388                                             ;; 8192 < c <= 16384 cylinders
34389 953E           C1EB                   04    shr bx, #0x04
34390 9541           C0E1                   04    shl cl, #0x04
34391                       00009544            hd1_post_store_logical:
34392 9544           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
34393 9548           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
34394                                             ;; checksum
34395 954C           B1                     0F    mov cl, #0x0f ;; repeat count
34396 954E           BE                   004D    mov si, #0x004d ;; offset to disk0 FDPT
34397 9551           B0                     00    mov al, #0x00 ;; sum
34398                       00009553            hd1_post_checksum_loop:
34399 9553           0204                         add al, [si]
34400 9555           46                           inc si
34401 9556           FEC9                         dec cl
34402 9558           75           F9              jnz hd1_post_checksum_loop
34403 955A           F6D0                         not al ;; now take 2s complement
34404 955C           FEC0                         inc al
34405 955E           8804                         mov [si], al
34406                                           ;;; Done filling EBDA table for hard disk 1.
34407 9560           C3                           ret
34408                                           ;--------------------
34409                                           ;- POST: EBDA segment
34410                                           ;--------------------
34411                                           ; relocated here because the primary POST area isnt big enough.
34412                       00009561            ebda_post:
34413 9561           B8                   9FC0    mov ax, #0x9FC0
34414 9564           8ED8                         mov ds, ax
34415 9566           C606       0000        01    mov byte ptr [0x0], #1
34416 956B           31C0                         xor ax, ax ; mov EBDA seg into 0x40E
34417 956D           8ED8                         mov ds, ax
34418 956F           C706       040E      9FC0    mov word ptr [0x40E], #0x9FC0
34419 9575           C3                           ret;;
34420                                           ;--------------------
34421                                           ;- POST: EOI + jmp via [0x40:67)
34422                                           ;--------------------
34423                                           ; relocated here because the primary POST area isnt big enough.
34424                       00009576            eoi_jmp_post:
34425 9576           B0                     11    mov al, #0x11 ; send initialisation commands
34426 9578           E6                     20    out 0x0020, al
34427 957A           E6                     A0    out 0x00a0, al
34428 957C           B0                     08    mov al, #0x08
34429 957E           E6                     21    out 0x0021, al
34430 9580           B0                     70    mov al, #0x70
34431 9582           E6                     A1    out 0x00a1, al
34432 9584           B0                     04    mov al, #0x04
34433 9586           E6                     21    out 0x0021, al
34434 9588           B0                     02    mov al, #0x02
34435 958A           E6                     A1    out 0x00a1, al
34436 958C           B0                     01    mov al, #0x01
34437 958E           E6                     21    out 0x0021, al
34438 9590           E6                     A1    out 0x00a1, al
34439 9592           B0                     B8    mov al, #0xb8
34440 9594           E6                     21    out 0x0021, AL ;master pic: unmask IRQ 0, 1, 2, 6
34441 9596           B0                     8F    mov al, #0x8f
34442 9598           E6                     A1    out 0x00a1, AL ;slave pic: unmask IRQ 12, 13, 14
34443 959A           B0                     20    mov al, #0x20
34444 959C           E6                     A0    out 0x00a0, al ;; slave PIC EOI
34445 959E           B0                     20    mov al, #0x20
34446 95A0           E6                     20    out 0x0020, al ;; master PIC EOI
34447                       000095A2            jmp_post_0x467:
34448 95A2           31C0                         xor ax, ax
34449 95A4           8ED8                         mov ds, ax
34450 95A6           FF2E       0467              jmp far ptr [0x467]
34451                       000095AA            iret_post_0x467:
34452 95AA           31C0                         xor ax, ax
34453 95AC           8ED8                         mov ds, ax
34454 95AE           8B26       0467              mov sp, [0x467]
34455 95B2           8E16       0469              mov ss, [0x469]
34456 95B6           CF                           iret
34457                       000095B7            retf_post_0x467:
34458 95B7           31C0                         xor ax, ax
34459 95B9           8ED8                         mov ds, ax
34460 95BB           8B26       0467              mov sp, [0x467]
34461 95BF           8E16       0469              mov ss, [0x469]
34462 95C3           CB                           retf
34463                       000095C4            s3_post:
34464 95C4           BC                   0FFE    mov sp, #0xffe
34465 95C7           E8         0796              call rombios32_init
34466 95CA           E8         81E1              call _s3_resume
34467 95CD           B3                     00    mov bl, #0x00
34468 95CF           21C0                         and ax, ax
34469 95D1   7503    E9         4ACD              jz normal_post
34470 95D6           E8         7BFD              call _s3_resume_panic
34471                                           ;--------------------
34472                       000095D9            eoi_both_pics:
34473 95D9           B0                     20    mov al, #0x20
34474 95DB           E6                     A0    out 0x00a0, al ;; slave PIC EOI
34475                       000095DD            eoi_master_pic:
34476 95DD           B0                     20    mov al, #0x20
34477 95DF           E6                     20    out 0x0020, al ;; master PIC EOI
34478 95E1           C3                           ret
34479                                           ;--------------------
34480                       000095E2            BcdToBin:
34481                                             ;; in: AL in BCD format
34482                                             ;; out: AL in binary format, AH will always be 0
34483                                             ;; trashes BX
34484 95E2           88C3                         mov bl, al
34485 95E4           80E3                   0F    and bl, #0x0f ;; bl has low digit
34486 95E7           C0E8                   04    shr al, #4 ;; al has high digit
34487 95EA           B7                     0A    mov bh, #10
34488 95EC           F6E7                         mul al, bh ;; multiply high digit by 10 (result in AX)
34489 95EE           00D8                         add al, bl ;; then add low digit
34490 95F0           C3                           ret
34491                                           ;--------------------
34492                       000095F1            timer_tick_post:
34493                                             ;; Setup the Timer Ticks Count (0x46C:dword) and
34494                                             ;; Timer Ticks Roller Flag (0x470:byte)
34495                                             ;; The Timer Ticks Count needs to be set according to
34496                                             ;; the current CMOS time, as if ticks have been occurring
34497                                             ;; at 18.2hz since midnight up to this point. Calculating
34498                                             ;; this is a little complicated. Here are the factors I gather
34499                                             ;; regarding this. 14,318,180 hz was the original clock speed,
34500                                             ;; chosen so it could be divided by either 3 to drive the 5Mhz CPU
34501                                             ;; at the time, or 4 to drive the CGA video adapter. The div3
34502                                             ;; source was divided again by 4 to feed a 1.193Mhz signal to
34503                                             ;; the timer. With a maximum 16bit timer count, this is again
34504                                             ;; divided down by 65536 to 18.2hz.
34505                                             ;;
34506                                             ;; 14,318,180 Hz clock
34507                                             ;; /3 = 4,772,726 Hz fed to original 5Mhz CPU
34508                                             ;; /4 = 1,193,181 Hz fed to timer
34509                                             ;; /65536 (maximum timer count) = 18.20650736 ticks/second
34510                                             ;; 1 second = 18.20650736 ticks
34511                                             ;; 1 minute = 1092.390442 ticks
34512                                             ;; 1 hour = 65543.42651 ticks
34513                                             ;;
34514                                             ;; Given the values in the CMOS clock, one could calculate
34515                                             ;; the number of ticks by the following:
34516                                             ;; ticks = (BcdToBin(seconds) * 18.206507) +
34517                                             ;; (BcdToBin(minutes) * 1092.3904)
34518                                             ;; (BcdToBin(hours) * 65543.427)
34519                                             ;; To get a little more accuracy, since Im using integer
34520                                             ;; arithmetic, I use:
34521                                             ;; ticks = (((BcdToBin(hours) * 60 + BcdToBin(minutes)) * 60 + BcdToBin(seconds)) * (18 * 4294967296 + 886942379)) / 4294967296
34522                                             ;; assuming DS=0000
34523                                             ;; get CMOS hours
34524 95F1     66    31C0                         xor eax, eax ;; clear EAX
34525 95F4           B0                     04    mov al, #0x04
34526 95F6           E6                     70    out 0x0070, al
34527 95F8           E4                     71    in al, 0x0071 ;; AL has CMOS hours in BCD
34528 95FA           E8         FFE5              call BcdToBin ;; EAX now has hours in binary
34529 95FD     66    6BC0                   3C    imul eax, #60
34530 9601     66    89C2                         mov edx, eax
34531                                             ;; get CMOS minutes
34532 9604     66    31C0                         xor eax, eax ;; clear EAX
34533 9607           B0                     02    mov al, #0x02
34534 9609           E6                     70    out 0x0070, al
34535 960B           E4                     71    in al, 0x0071 ;; AL has CMOS minutes in BCD
34536 960D           E8         FFD2              call BcdToBin ;; EAX now has minutes in binary
34537 9610     66    01D0                         add eax, edx
34538 9613     66    6BC0                   3C    imul eax, #60
34539 9617     66    89C2                         mov edx, eax
34540                                             ;; get CMOS seconds
34541 961A     66    31C0                         xor eax, eax ;; clear EAX
34542 961D           B0                     00    mov al, #0x00
34543 961F           E6                     70    out 0x0070, al
34544 9621           E4                     71    in al, 0x0071 ;; AL has CMOS seconds in BCD
34545 9623           E8         FFBC              call BcdToBin ;; EAX now has seconds in binary
34546 9626     66    01D0                         add eax, edx
34547                                             ;; multiplying 18.2065073649
34548 9629     66    89C1                         mov ecx, eax
34549 962C     66    6BC9                   12    imul ecx, #18
34550 9630     66    BA               34DDAAAB    mov edx, #886942379
34551 9636     66    F7E2                         mul edx
34552 9639     66    01D1                         add ecx, edx
34553 963C     66    890E       046C              mov 0x46C, ecx ;; Timer Ticks Count
34554 9641           30C0                         xor al, al
34555 9643           A2         0470              mov 0x470, al ;; Timer Ticks Rollover Flag
34556 9646           C3                           ret
34557                                           ;--------------------
34558                       00009647            int76_handler:
34559                                             ;; record completion in BIOS task complete flag
34560 9647           50                           push ax
34561 9648           1E                           push ds
34562 9649           B8                   0040    mov ax, #0x0040
34563 964C           8ED8                         mov ds, ax
34564 964E           C606       008E        FF    mov BYTE 0x008E, #0xff
34565 9653           E8         FF83              call eoi_both_pics
34566                                             ;; Notify fixed disk interrupt complete w/ int 15h, function AX=9100
34567 9656           B8                   9100    mov ax, #0x9100
34568 9659           CD                     15    int 0x15
34569 965B           1F                           pop ds
34570 965C           58                           pop ax
34571 965D           CF                           iret
34572                                           ;--------------------
34573                                           use32 386
34574                       0000965E            apm32_out_str:
34575 965E           50                           push eax
34576 965F           53                           push ebx
34577 9660           89C3                         mov ebx, eax
34578                       00009662            apm32_out_str1:
34579 9662           2E                           SEG CS
34580 9663   67      8A07                         mov al, byte ptr [bx]
34581 9666           3C                     00    cmp al, #0
34582 9668           74           04              je apm32_out_str2
34583 966A           EE                           outb dx, al
34584 966B           43                           inc ebx
34585 966C           EB           F4              jmp apm32_out_str1
34586                       0000966E            apm32_out_str2:
34587 966E           5B                           pop ebx
34588 966F           58                           pop eax
34589 9670           C3                           ret
34590                       00009671            apm32_07_poweroff_str:
34591 9671                        53              .ascii "Shutdown"
34592 9679                        00              db 0
34593                       0000967A            apm32_07_suspend_str:
34594 967A                        53              .ascii "Suspend"
34595 9681                        00              db 0
34596                       00009682            apm32_07_standby_str:
34597 9682                        53              .ascii "Standby"
34598 9689                        00              db 0
34599                       0000968A            _apm32_entry:
34600 968A     66    9C                           pushf
34601                                           ;-----------------
34602                                           ; APM interface disconnect
34603                       0000968C            apm32_04:
34604 968C           3C                     04    cmp al, #0x04
34605 968E           75           05              jne apm32_05
34606 9690           E9     000000A1              jmp apm32_ok
34607                                           ;-----------------
34608                                           ; APM cpu idle
34609                       00009695            apm32_05:
34610 9695           3C                     05    cmp al, #0x05
34611 9697           75           07              jne apm32_07
34612 9699           FB                           sti
34613 969A           F4                           hlt
34614 969B           E9     00000096              jmp apm32_ok
34615                                           ;-----------------
34616                                           ; APM Set Power State
34617                       000096A0            apm32_07:
34618 96A0           3C                     07    cmp al, #0x07
34619 96A2           75           52              jne apm32_08
34620 96A4     66    83FB                   01    cmp bx, #1
34621 96A8   7405    E9     00000087              jne apm32_ok
34622 96AF     66    83F9                   03    cmp cx, #3
34623 96B3           74           0E              je apm32_07_poweroff
34624 96B5     66    83F9                   02    cmp cx, #2
34625 96B9           74           19              je apm32_07_suspend
34626 96BB     66    83F9                   01    cmp cx, #1
34627 96BF           74           24              je apm32_07_standby
34628 96C1           75           73              jne apm32_ok
34629                       000096C3            apm32_07_poweroff:
34630 96C3           FA                           cli
34631 96C4     66    BA                   8900    mov dx, #0x8900
34632 96C8     66    B8                   9671    mov ax, #apm32_07_poweroff_str
34633 96CC           E8     FFFFFF8D              call apm32_out_str
34634                       000096D1            apm32_07_1:
34635 96D1           F4                           hlt
34636 96D2           EB           FD              jmp apm32_07_1
34637                       000096D4            apm32_07_suspend:
34638 96D4           52                           push edx
34639 96D5     66    BA                   8900    mov dx, #0x8900
34640 96D9     66    B8                   967A    mov ax, #apm32_07_suspend_str
34641 96DD           E8     FFFFFF7C              call apm32_out_str
34642 96E2           5A                           pop edx
34643 96E3           EB           51              jmp apm32_ok
34644                       000096E5            apm32_07_standby:
34645 96E5           52                           push edx
34646 96E6     66    BA                   8900    mov dx, #0x8900
34647 96EA     66    B8                   9682    mov ax, #apm32_07_standby_str
34648 96EE           E8     FFFFFF6B              call apm32_out_str
34649 96F3           5A                           pop edx
34650 96F4           EB           40              jmp apm32_ok
34651                                           ;-----------------
34652                                           ; APM Enable / Disable
34653                       000096F6            apm32_08:
34654 96F6           3C                     08    cmp al, #0x08
34655 96F8           75           02              jne apm32_0a
34656 96FA           EB           3A              jmp apm32_ok
34657                                           ;-----------------
34658                                           ; Get Power Status
34659                       000096FC            apm32_0a:
34660 96FC           3C                     0A    cmp al, #0x0a
34661 96FE           75           12              jne apm32_0b
34662 9700           B7                     01    mov bh, #0x01
34663 9702           B3                     FF    mov bl, #0xff
34664 9704           B5                     80    mov ch, #0x80
34665 9706           B1                     FF    mov cl, #0xff
34666 9708     66    BA                   FFFF    mov dx, #0xffff
34667 970C     66    BE                   0000    mov si, #0
34668 9710           EB           24              jmp apm32_ok
34669                                           ;-----------------
34670                                           ; Get PM Event
34671                       00009712            apm32_0b:
34672 9712           3C                     0B    cmp al, #0x0b
34673 9714           75           04              jne apm32_0e
34674 9716           B4                     80    mov ah, #0x80
34675 9718           EB           20              jmp apm32_error
34676                                           ;-----------------
34677                                           ; APM Driver Version
34678                       0000971A            apm32_0e:
34679 971A           3C                     0E    cmp al, #0x0e
34680 971C           75           06              jne apm32_0f
34681 971E           B4                     01    mov ah, #1
34682 9720           B0                     02    mov al, #2
34683 9722           EB           12              jmp apm32_ok
34684                                           ;-----------------
34685                                           ; APM Engage / Disengage
34686                       00009724            apm32_0f:
34687 9724           3C                     0F    cmp al, #0x0f
34688 9726           75           02              jne apm32_10
34689 9728           EB           0C              jmp apm32_ok
34690                                           ;-----------------
34691                                           ; APM Get Capabilities
34692                       0000972A            apm32_10:
34693 972A           3C                     10    cmp al, #0x10
34694 972C           75           0C              jne apm32_unimplemented
34695 972E           B3                     00    mov bl, #0
34696 9730     66    B9                   0000    mov cx, #0
34697 9734           EB           00              jmp apm32_ok
34698                                           ;-----------------
34699                       00009736            apm32_ok:
34700 9736     66    9D                           popf
34701 9738           F8                           clc
34702 9739           CB                           retf
34703                       0000973A            apm32_unimplemented:
34704                       0000973A            apm32_error:
34705 973A     66    9D                           popf
34706 973C           F9                           stc
34707 973D           CB                           retf
34708                                           use16 386
34709                       0000973E            apm16_out_str:
34710 973E     66    50                           push eax
34711 9740     66    53                           push ebx
34712 9742     66    89C3                         mov ebx, eax
34713                       00009745            apm16_out_str1:
34714 9745           2E                           SEG CS
34715 9746           8A07                         mov al, byte ptr [bx]
34716 9748           3C                     00    cmp al, #0
34717 974A           74           05              je apm16_out_str2
34718 974C           EE                           outb dx, al
34719 974D     66    43                           inc ebx
34720 974F           EB           F4              jmp apm16_out_str1
34721                       00009751            apm16_out_str2:
34722 9751     66    5B                           pop ebx
34723 9753     66    58                           pop eax
34724 9755           C3                           ret
34725                       00009756            apm16_07_poweroff_str:
34726 9756                        53              .ascii "Shutdown"
34727 975E                        00              db 0
34728                       0000975F            apm16_07_suspend_str:
34729 975F                        53              .ascii "Suspend"
34730 9766                        00              db 0
34731                       00009767            apm16_07_standby_str:
34732 9767                        53              .ascii "Standby"
34733 976E                        00              db 0
34734                       0000976F            _apm16_entry:
34735 976F           9C                           pushf
34736                                           ;-----------------
34737                                           ; APM interface disconnect
34738                       00009770            apm16_04:
34739 9770           3C                     04    cmp al, #0x04
34740 9772           75           03              jne apm16_05
34741 9774           E9         008B              jmp apm16_ok
34742                                           ;-----------------
34743                                           ; APM cpu idle
34744                       00009777            apm16_05:
34745 9777           3C                     05    cmp al, #0x05
34746 9779           75           05              jne apm16_07
34747 977B           FB                           sti
34748 977C           F4                           hlt
34749 977D           E9         0082              jmp apm16_ok
34750                                           ;-----------------
34751                                           ; APM Set Power State
34752                       00009780            apm16_07:
34753 9780           3C                     07    cmp al, #0x07
34754 9782           75           41              jne apm16_08
34755 9784           83FB                   01    cmp bx, #1
34756 9787           75           79              jne apm16_ok
34757 9789           83F9                   03    cmp cx, #3
34758 978C           74           0C              je apm16_07_poweroff
34759 978E           83F9                   02    cmp cx, #2
34760 9791           74           14              je apm16_07_suspend
34761 9793           83F9                   01    cmp cx, #1
34762 9796           74           1E              je apm16_07_standby
34763 9798           75           68              jne apm16_ok
34764                       0000979A            apm16_07_poweroff:
34765 979A           FA                           cli
34766 979B           BA                   8900    mov dx, #0x8900
34767 979E           B8                   9756    mov ax, #apm16_07_poweroff_str
34768 97A1           E8         FF9A              call apm16_out_str
34769                       000097A4            apm16_07_1:
34770 97A4           F4                           hlt
34771 97A5           EB           FD              jmp apm16_07_1
34772                       000097A7            apm16_07_suspend:
34773 97A7     66    52                           push edx
34774 97A9           BA                   8900    mov dx, #0x8900
34775 97AC           B8                   975F    mov ax, #apm16_07_suspend_str
34776 97AF           E8         FF8C              call apm16_out_str
34777 97B2     66    5A                           pop edx
34778 97B4           EB           4C              jmp apm16_ok
34779                       000097B6            apm16_07_standby:
34780 97B6     66    52                           push edx
34781 97B8           BA                   8900    mov dx, #0x8900
34782 97BB           B8                   9767    mov ax, #apm16_07_standby_str
34783 97BE           E8         FF7D              call apm16_out_str
34784 97C1     66    5A                           pop edx
34785 97C3           EB           3D              jmp apm16_ok
34786                                           ;-----------------
34787                                           ; APM Enable / Disable
34788                       000097C5            apm16_08:
34789 97C5           3C                     08    cmp al, #0x08
34790 97C7           75           02              jne apm16_0a
34791 97C9           EB           37              jmp apm16_ok
34792                                           ;-----------------
34793                                           ; Get Power Status
34794                       000097CB            apm16_0a:
34795 97CB           3C                     0A    cmp al, #0x0a
34796 97CD           75           10              jne apm16_0b
34797 97CF           B7                     01    mov bh, #0x01
34798 97D1           B3                     FF    mov bl, #0xff
34799 97D3           B5                     80    mov ch, #0x80
34800 97D5           B1                     FF    mov cl, #0xff
34801 97D7           BA                   FFFF    mov dx, #0xffff
34802 97DA           BE                   0000    mov si, #0
34803 97DD           EB           23              jmp apm16_ok
34804                                           ;-----------------
34805                                           ; Get PM Event
34806                       000097DF            apm16_0b:
34807 97DF           3C                     0B    cmp al, #0x0b
34808 97E1           75           04              jne apm16_0e
34809 97E3           B4                     80    mov ah, #0x80
34810 97E5           EB           1E              jmp apm16_error
34811                                           ;-----------------
34812                                           ; APM Driver Version
34813                       000097E7            apm16_0e:
34814 97E7           3C                     0E    cmp al, #0x0e
34815 97E9           75           06              jne apm16_0f
34816 97EB           B4                     01    mov ah, #1
34817 97ED           B0                     02    mov al, #2
34818 97EF           EB           11              jmp apm16_ok
34819                                           ;-----------------
34820                                           ; APM Engage / Disengage
34821                       000097F1            apm16_0f:
34822 97F1           3C                     0F    cmp al, #0x0f
34823 97F3           75           02              jne apm16_10
34824 97F5           EB           0B              jmp apm16_ok
34825                                           ;-----------------
34826                                           ; APM Get Capabilities
34827                       000097F7            apm16_10:
34828 97F7           3C                     10    cmp al, #0x10
34829 97F9           75           0A              jne apm16_unimplemented
34830 97FB           B3                     00    mov bl, #0
34831 97FD           B9                   0000    mov cx, #0
34832 9800           EB           00              jmp apm16_ok
34833                                           ;-----------------
34834                       00009802            apm16_ok:
34835 9802           9D                           popf
34836 9803           F8                           clc
34837 9804           CB                           retf
34838                       00009805            apm16_unimplemented:
34839                       00009805            apm16_error:
34840 9805           9D                           popf
34841 9806           F9                           stc
34842 9807           CB                           retf
34843                       00009808            apmreal_out_str:
34844 9808     66    50                           push eax
34845 980A     66    53                           push ebx
34846 980C     66    89C3                         mov ebx, eax
34847                       0000980F            apmreal_out_str1:
34848 980F           2E                           SEG CS
34849 9810           8A07                         mov al, byte ptr [bx]
34850 9812           3C                     00    cmp al, #0
34851 9814           74           05              je apmreal_out_str2
34852 9816           EE                           outb dx, al
34853 9817     66    43                           inc ebx
34854 9819           EB           F4              jmp apmreal_out_str1
34855                       0000981B            apmreal_out_str2:
34856 981B     66    5B                           pop ebx
34857 981D     66    58                           pop eax
34858 981F           C3                           ret
34859                       00009820            apmreal_07_poweroff_str:
34860 9820                        53              .ascii "Shutdown"
34861 9828                        00              db 0
34862                       00009829            apmreal_07_suspend_str:
34863 9829                        53              .ascii "Suspend"
34864 9830                        00              db 0
34865                       00009831            apmreal_07_standby_str:
34866 9831                        53              .ascii "Standby"
34867 9838                        00              db 0
34868 9839           9C                           pushf
34869                       0000983A            _apmreal_entry:
34870                                           ;-----------------
34871                                           ; APM installation check
34872                       0000983A            apmreal_00:
34873 983A           3C                     00    cmp al, #0x00
34874 983C           75           0E              jne apmreal_01
34875 983E           B4                     01    mov ah, #1
34876 9840           B0                     02    mov al, #2
34877 9842           B7                     50    mov bh, #0x50
34878 9844           B3                     4D    mov bl, #0x4d
34879 9846           B9                   0003    mov cx, #0x3
34880 9849           E9         00CE              jmp apmreal_ok
34881                                           ;-----------------
34882                                           ; APM real mode interface connect
34883                       0000984C            apmreal_01:
34884 984C           3C                     01    cmp al, #0x01
34885 984E           75           03              jne apmreal_02
34886 9850           E9         00C7              jmp apmreal_ok
34887                                           ;-----------------
34888                                           ; APM 16 bit protected mode interface connect
34889                       00009853            apmreal_02:
34890 9853           3C                     02    cmp al, #0x02
34891 9855           75           12              jne apmreal_03
34892 9857           BB                   976F    mov bx, #_apm16_entry
34893 985A           B8                   F000    mov ax, #0xf000
34894 985D           BE                   FFF0    mov si, #0xfff0
34895 9860           B9                   F000    mov cx, #0xf000
34896 9863           BF                   FFF0    mov di, #0xfff0
34897 9866           E9         00B1              jmp apmreal_ok
34898                                           ;-----------------
34899                                           ; APM 32 bit protected mode interface connect
34900                       00009869            apmreal_03:
34901 9869           3C                     03    cmp al, #0x03
34902 986B           75           1B              jne apmreal_04
34903 986D           B8                   F000    mov ax, #0xf000
34904 9870     66    BB               0000968A    mov ebx, #_apm32_entry
34905 9876           B9                   F000    mov cx, #0xf000
34906 9879     66    BE               FFF0FFF0    mov esi, #0xfff0fff0
34907 987F           BA                   F000    mov dx, #0xf000
34908 9882           BF                   FFF0    mov di, #0xfff0
34909 9885           E9         0092              jmp apmreal_ok
34910                                           ;-----------------
34911                                           ; APM interface disconnect
34912                       00009888            apmreal_04:
34913 9888           3C                     04    cmp al, #0x04
34914 988A           75           03              jne apmreal_05
34915 988C           E9         008B              jmp apmreal_ok
34916                                           ;-----------------
34917                                           ; APM cpu idle
34918                       0000988F            apmreal_05:
34919 988F           3C                     05    cmp al, #0x05
34920 9891           75           05              jne apmreal_07
34921 9893           FB                           sti
34922 9894           F4                           hlt
34923 9895           E9         0082              jmp apmreal_ok
34924                                           ;-----------------
34925                                           ; APM Set Power State
34926                       00009898            apmreal_07:
34927 9898           3C                     07    cmp al, #0x07
34928 989A           75           41              jne apmreal_08
34929 989C           83FB                   01    cmp bx, #1
34930 989F           75           79              jne apmreal_ok
34931 98A1           83F9                   03    cmp cx, #3
34932 98A4           74           0C              je apmreal_07_poweroff
34933 98A6           83F9                   02    cmp cx, #2
34934 98A9           74           14              je apmreal_07_suspend
34935 98AB           83F9                   01    cmp cx, #1
34936 98AE           74           1E              je apmreal_07_standby
34937 98B0           75           68              jne apmreal_ok
34938                       000098B2            apmreal_07_poweroff:
34939 98B2           FA                           cli
34940 98B3           BA                   8900    mov dx, #0x8900
34941 98B6           B8                   9820    mov ax, #apmreal_07_poweroff_str
34942 98B9           E8         FF4C              call apmreal_out_str
34943                       000098BC            apmreal_07_1:
34944 98BC           F4                           hlt
34945 98BD           EB           FD              jmp apmreal_07_1
34946                       000098BF            apmreal_07_suspend:
34947 98BF     66    52                           push edx
34948 98C1           BA                   8900    mov dx, #0x8900
34949 98C4           B8                   9829    mov ax, #apmreal_07_suspend_str
34950 98C7           E8         FF3E              call apmreal_out_str
34951 98CA     66    5A                           pop edx
34952 98CC           EB           4C              jmp apmreal_ok
34953                       000098CE            apmreal_07_standby:
34954 98CE     66    52                           push edx
34955 98D0           BA                   8900    mov dx, #0x8900
34956 98D3           B8                   9831    mov ax, #apmreal_07_standby_str
34957 98D6           E8         FF2F              call apmreal_out_str
34958 98D9     66    5A                           pop edx
34959 98DB           EB           3D              jmp apmreal_ok
34960                                           ;-----------------
34961                                           ; APM Enable / Disable
34962                       000098DD            apmreal_08:
34963 98DD           3C                     08    cmp al, #0x08
34964 98DF           75           02              jne apmreal_0a
34965 98E1           EB           37              jmp apmreal_ok
34966                                           ;-----------------
34967                                           ; Get Power Status
34968                       000098E3            apmreal_0a:
34969 98E3           3C                     0A    cmp al, #0x0a
34970 98E5           75           10              jne apmreal_0b
34971 98E7           B7                     01    mov bh, #0x01
34972 98E9           B3                     FF    mov bl, #0xff
34973 98EB           B5                     80    mov ch, #0x80
34974 98ED           B1                     FF    mov cl, #0xff
34975 98EF           BA                   FFFF    mov dx, #0xffff
34976 98F2           BE                   0000    mov si, #0
34977 98F5           EB           23              jmp apmreal_ok
34978                                           ;-----------------
34979                                           ; Get PM Event
34980                       000098F7            apmreal_0b:
34981 98F7           3C                     0B    cmp al, #0x0b
34982 98F9           75           04              jne apmreal_0e
34983 98FB           B4                     80    mov ah, #0x80
34984 98FD           EB           20              jmp apmreal_error
34985                                           ;-----------------
34986                                           ; APM Driver Version
34987                       000098FF            apmreal_0e:
34988 98FF           3C                     0E    cmp al, #0x0e
34989 9901           75           06              jne apmreal_0f
34990 9903           B4                     01    mov ah, #1
34991 9905           B0                     02    mov al, #2
34992 9907           EB           11              jmp apmreal_ok
34993                                           ;-----------------
34994                                           ; APM Engage / Disengage
34995                       00009909            apmreal_0f:
34996 9909           3C                     0F    cmp al, #0x0f
34997 990B           75           02              jne apmreal_10
34998 990D           EB           0B              jmp apmreal_ok
34999                                           ;-----------------
35000                                           ; APM Get Capabilities
35001                       0000990F            apmreal_10:
35002 990F           3C                     10    cmp al, #0x10
35003 9911           75           0C              jne apmreal_unimplemented
35004 9913           B3                     00    mov bl, #0
35005 9915           B9                   0000    mov cx, #0
35006 9918           EB           00              jmp apmreal_ok
35007                                           ;-----------------
35008                       0000991A            apmreal_ok:
35009 991A           9D                           popf
35010 991B           F8                           clc
35011 991C           E9         F8BA              jmp iret_modify_cf
35012                       0000991F            apmreal_unimplemented:
35013                       0000991F            apmreal_error:
35014 991F           9D                           popf
35015 9920           F9                           stc
35016 9921           E9         F8B5              jmp iret_modify_cf
35017                                           ;--------------------
35018                                           use32 386
35019 9924                  00000010            .align 16
35020                       00009930            bios32_structure:
35021 9930                        5F              db 0x5f, 0x33, 0x32, 0x5f ;; "_32_" signature
35022 9934                      9940              dw bios32_entry_point, 0xf ;; 32 bit physical address
35023 9938                        00              db 0 ;; revision level
35024                                             ;; length in paragraphs and checksum stored in a word to prevent errors
35025 9939                      F401              dw (~(((bios32_entry_point >> 8) + (bios32_entry_point & 0xff) + 0x32) & 0xff) << 8) + 0x01
35026 993B                        00              db 0,0,0,0,0 ;; reserved
35027 9940                  00000010            .align 16
35028                       00009940            bios32_entry_point:
35029 9940           9C                           pushfd
35030 9941           3D               49435024    cmp eax, #0x49435024 ;; "$PCI"
35031 9946           75           3E              jne unknown_service
35032 9948           B8               80000000    mov eax, #0x80000000
35033 994D     66    BA                   0CF8    mov dx, #0x0cf8
35034 9951           EF                           out dx, eax
35035 9952     66    BA                   0CFC    mov dx, #0x0cfc
35036 9956           ED                           in eax, dx
35037 9957           3D               12378086    cmp eax, #0x12378086 ;; i440FX PCI bridge
35038 995C           74           15              je pci_found
35039 995E           3D               01228086    cmp eax, #0x01228086 ;; i430FX PCI bridge
35040 9963           74           0E              je pci_found
35041 9965           3D               71908086    cmp eax, #0x71908086 ;; i440BX PCI bridge
35042 996A           74           07              je pci_found
35043                                             ;; say ok if a device is present
35044 996C           3D               FFFFFFFF    cmp eax, #0xffffffff
35045 9971           74           13              je unknown_service
35046                       00009973            pci_found:
35047 9973           BB               000F0000    mov ebx, #0x000f0000
35048 9978           B9               00010000    mov ecx, #0x10000
35049 997D           BA               00009990    mov edx, #pcibios_protected
35050 9982           30C0                         xor al, al
35051 9984           EB           02              jmp bios32_end
35052                       00009986            unknown_service:
35053 9986           B0                     80    mov al, #0x80
35054                       00009988            bios32_end:
35055 9988           9D                           popfd
35056 9989           CB                           retf
35057 998A                  00000010            .align 16
35058                       00009990            pcibios_protected:
35059 9990           9C                           pushfd
35060 9991           FA                           cli
35061 9992           56                           push esi
35062 9993           57                           push edi
35063 9994           3C                     01    cmp al, #0x01 ;; installation check
35064 9996           75           15              jne pci_pro_f02
35065 9998     66    BB                   0210    mov bx, #0x0210
35066 999C           E8     0000012E              call pci_pro_get_max_bus ;; sets CX
35067 99A1           BA               20494350    mov edx, #0x20494350 ;; "PCI "
35068 99A6           B0                     01    mov al, #0x01
35069 99A8           E9     0000011B              jmp pci_pro_ok
35070                       000099AD            pci_pro_f02: ;; find pci device
35071 99AD           3C                     02    cmp al, #0x02
35072 99AF           75           38              jne pci_pro_f03
35073 99B1           C1E1                   10    shl ecx, #16
35074 99B4     66    89D1                         mov cx, dx
35075 99B7     66    31DB                         xor bx, bx
35076 99BA     66    BF                   0000    mov di, #0x00
35077                       000099BE            pci_pro_devloop:
35078 99BE           E8     0000012D              call pci_pro_select_reg
35079 99C3     66    BA                   0CFC    mov dx, #0x0cfc
35080 99C7           ED                           in eax, dx
35081 99C8           39C8                         cmp eax, ecx
35082 99CA           75           0D              jne pci_pro_nextdev
35083 99CC     66    83FE                   00    cmp si, #0
35084 99D0   7505    E9     000000F1              je pci_pro_ok
35085 99D7     66    4E                           dec si
35086                       000099D9            pci_pro_nextdev:
35087 99D9     66    43                           inc bx
35088 99DB     66    81FB                 0200    cmp bx, #0x0200
35089 99E0           75           DC              jne pci_pro_devloop
35090 99E2           B4                     86    mov ah, #0x86
35091 99E4           E9     000000DA              jmp pci_pro_fail
35092                       000099E9            pci_pro_f03: ;; find class code
35093 99E9           3C                     03    cmp al, #0x03
35094 99EB           75           35              jne pci_pro_f08
35095 99ED     66    31DB                         xor bx, bx
35096 99F0     66    BF                   0008    mov di, #0x08
35097                       000099F4            pci_pro_devloop2:
35098 99F4           E8     000000F7              call pci_pro_select_reg
35099 99F9     66    BA                   0CFC    mov dx, #0x0cfc
35100 99FD           ED                           in eax, dx
35101 99FE           C1E8                   08    shr eax, #8
35102 9A01           39C8                         cmp eax, ecx
35103 9A03           75           0D              jne pci_pro_nextdev2
35104 9A05     66    83FE                   00    cmp si, #0
35105 9A09   7505    E9     000000B8              je pci_pro_ok
35106 9A10     66    4E                           dec si
35107                       00009A12            pci_pro_nextdev2:
35108 9A12     66    43                           inc bx
35109 9A14     66    81FB                 0200    cmp bx, #0x0200
35110 9A19           75           D9              jne pci_pro_devloop2
35111 9A1B           B4                     86    mov ah, #0x86
35112 9A1D           E9     000000A1              jmp pci_pro_fail
35113                       00009A22            pci_pro_f08: ;; read configuration byte
35114 9A22           3C                     08    cmp al, #0x08
35115 9A24           75           1B              jne pci_pro_f09
35116 9A26           E8     000000C5              call pci_pro_select_reg
35117 9A2B           52                           push edx
35118 9A2C     66    89FA                         mov dx, di
35119 9A2F     66    83E2                   03    and dx, #0x03
35120 9A33     66    81C2                 0CFC    add dx, #0x0cfc
35121 9A38           EC                           in al, dx
35122 9A39           5A                           pop edx
35123 9A3A           88C1                         mov cl, al
35124 9A3C           E9     00000087              jmp pci_pro_ok
35125                       00009A41            pci_pro_f09: ;; read configuration word
35126 9A41           3C                     09    cmp al, #0x09
35127 9A43           75           1A              jne pci_pro_f0a
35128 9A45           E8     000000A6              call pci_pro_select_reg
35129 9A4A           52                           push edx
35130 9A4B     66    89FA                         mov dx, di
35131 9A4E     66    83E2                   02    and dx, #0x02
35132 9A52     66    81C2                 0CFC    add dx, #0x0cfc
35133 9A57     66    ED                           in ax, dx
35134 9A59           5A                           pop edx
35135 9A5A     66    89C1                         mov cx, ax
35136 9A5D           EB           69              jmp pci_pro_ok
35137                       00009A5F            pci_pro_f0a: ;; read configuration dword
35138 9A5F           3C                     0A    cmp al, #0x0a
35139 9A61           75           10              jne pci_pro_f0b
35140 9A63           E8     00000088              call pci_pro_select_reg
35141 9A68           52                           push edx
35142 9A69     66    BA                   0CFC    mov dx, #0x0cfc
35143 9A6D           ED                           in eax, dx
35144 9A6E           5A                           pop edx
35145 9A6F           89C1                         mov ecx, eax
35146 9A71           EB           55              jmp pci_pro_ok
35147                       00009A73            pci_pro_f0b: ;; write configuration byte
35148 9A73           3C                     0B    cmp al, #0x0b
35149 9A75           75           18              jne pci_pro_f0c
35150 9A77           E8     00000074              call pci_pro_select_reg
35151 9A7C           52                           push edx
35152 9A7D     66    89FA                         mov dx, di
35153 9A80     66    83E2                   03    and dx, #0x03
35154 9A84     66    81C2                 0CFC    add dx, #0x0cfc
35155 9A89           88C8                         mov al, cl
35156 9A8B           EE                           out dx, al
35157 9A8C           5A                           pop edx
35158 9A8D           EB           39              jmp pci_pro_ok
35159                       00009A8F            pci_pro_f0c: ;; write configuration word
35160 9A8F           3C                     0C    cmp al, #0x0c
35161 9A91           75           1A              jne pci_pro_f0d
35162 9A93           E8     00000058              call pci_pro_select_reg
35163 9A98           52                           push edx
35164 9A99     66    89FA                         mov dx, di
35165 9A9C     66    83E2                   02    and dx, #0x02
35166 9AA0     66    81C2                 0CFC    add dx, #0x0cfc
35167 9AA5     66    89C8                         mov ax, cx
35168 9AA8     66    EF                           out dx, ax
35169 9AAA           5A                           pop edx
35170 9AAB           EB           1B              jmp pci_pro_ok
35171                       00009AAD            pci_pro_f0d: ;; write configuration dword
35172 9AAD           3C                     0D    cmp al, #0x0d
35173 9AAF           75           10              jne pci_pro_unknown
35174 9AB1           E8     0000003A              call pci_pro_select_reg
35175 9AB6           52                           push edx
35176 9AB7     66    BA                   0CFC    mov dx, #0x0cfc
35177 9ABB           89C8                         mov eax, ecx
35178 9ABD           EF                           out dx, eax
35179 9ABE           5A                           pop edx
35180 9ABF           EB           07              jmp pci_pro_ok
35181                       00009AC1            pci_pro_unknown:
35182 9AC1           B4                     81    mov ah, #0x81
35183                       00009AC3            pci_pro_fail:
35184 9AC3           5F                           pop edi
35185 9AC4           5E                           pop esi
35186 9AC5           9D                           popfd
35187 9AC6           F9                           stc
35188 9AC7           CB                           retf
35189                       00009AC8            pci_pro_ok:
35190 9AC8           30E4                         xor ah, ah
35191 9ACA           5F                           pop edi
35192 9ACB           5E                           pop esi
35193 9ACC           9D                           popfd
35194 9ACD           F8                           clc
35195 9ACE           CB                           retf
35196                       00009ACF            pci_pro_get_max_bus:
35197 9ACF           50                           push eax
35198 9AD0           B8               80000000    mov eax, #0x80000000
35199 9AD5     66    BA                   0CF8    mov dx, #0x0cf8
35200 9AD9           EF                           out dx, eax
35201 9ADA     66    BA                   0CFC    mov dx, #0x0cfc
35202 9ADE           ED                           in eax, dx
35203 9ADF     66    B9                   0000    mov cx, #0
35204 9AE3           3D               71908086    cmp eax, #0x71908086 ;; i440BX PCI bridge
35205 9AE8           75           04              jne pci_pro_no_i440bx
35206 9AEA     66    B9                   0001    mov cx, #0x0001
35207                       00009AEE            pci_pro_no_i440bx:
35208 9AEE           58                           pop eax
35209 9AEF           C3                           ret
35210                       00009AF0            pci_pro_select_reg:
35211 9AF0           52                           push edx
35212 9AF1           B8               00800000    mov eax, #0x800000
35213 9AF6     66    89D8                         mov ax, bx
35214 9AF9           C1E0                   08    shl eax, #8
35215 9AFC     66    81E7                 00FF    and di, #0xff
35216 9B01     66    09F8                         or ax, di
35217 9B04           24                     FC    and al, #0xfc
35218 9B06     66    BA                   0CF8    mov dx, #0x0cf8
35219 9B0A           EF                           out dx, eax
35220 9B0B           5A                           pop edx
35221 9B0C           C3                           ret
35222                                           use16 386
35223                       00009B0D            pcibios_real:
35224 9B0D     66    50                           push eax
35225 9B0F           52                           push dx
35226 9B10     66    B8               80000000    mov eax, #0x80000000
35227 9B16           BA                   0CF8    mov dx, #0x0cf8
35228 9B19     66    EF                           out dx, eax
35229 9B1B           BA                   0CFC    mov dx, #0x0cfc
35230 9B1E     66    ED                           in eax, dx
35231 9B20     66    3D               12378086    cmp eax, #0x12378086 ;; i440FX PCI bridge
35232 9B26           74           1F              je pci_present
35233 9B28     66    3D               01228086    cmp eax, #0x01228086 ;; i430FX PCI bridge
35234 9B2E           74           17              je pci_present
35235 9B30     66    3D               71908086    cmp eax, #0x71908086 ;; i440BX PCI bridge
35236 9B36           74           0F              je pci_present
35237                                             ;; say ok if a device is present
35238 9B38     66    3D               FFFFFFFF    cmp eax, #0xffffffff
35239 9B3E           75           07              jne pci_present
35240 9B40           5A                           pop dx
35241 9B41     66    58                           pop eax
35242 9B43           B4                     FF    mov ah, #0xff
35243 9B45           F9                           stc
35244 9B46           C3                           ret
35245                       00009B47            pci_present:
35246 9B47           5A                           pop dx
35247 9B48     66    58                           pop eax
35248 9B4A           3C                     01    cmp al, #0x01 ;; installation check
35249 9B4C           75           1A              jne pci_real_f02
35250 9B4E           B8                   0001    mov ax, #0x0001
35251 9B51           BB                   0210    mov bx, #0x0210
35252 9B54           E8         0145              call pci_real_get_max_bus ;; sets CX
35253 9B57     66    BA               20494350    mov edx, #0x20494350 ;; "PCI "
35254 9B5D     66    BF               000F0000    mov edi, #0xf0000
35255 9B63           BF                   9990    mov di, #pcibios_protected
35256 9B66           F8                           clc
35257 9B67           C3                           ret
35258                       00009B68            pci_real_f02: ;; find pci device
35259 9B68     66    56                           push esi
35260 9B6A     66    57                           push edi
35261 9B6C           3C                     02    cmp al, #0x02
35262 9B6E           75           34              jne pci_real_f03
35263 9B70     66    C1E1                   10    shl ecx, #16
35264 9B74           89D1                         mov cx, dx
35265 9B76           31DB                         xor bx, bx
35266 9B78           BF                   0000    mov di, #0x00
35267                       00009B7B            pci_real_devloop:
35268 9B7B           E8         0141              call pci_real_select_reg
35269 9B7E           BA                   0CFC    mov dx, #0x0cfc
35270 9B81     66    ED                           in eax, dx
35271 9B83     66    39C8                         cmp eax, ecx
35272 9B86           75           09              jne pci_real_nextdev
35273 9B88           83FE                   00    cmp si, #0
35274 9B8B   7503    E9         0104              je pci_real_ok
35275 9B90           4E                           dec si
35276                       00009B91            pci_real_nextdev:
35277 9B91           43                           inc bx
35278 9B92           81FB                 0200    cmp bx, #0x0200
35279 9B96           75           E3              jne pci_real_devloop
35280 9B98           89CA                         mov dx, cx
35281 9B9A     66    C1E9                   10    shr ecx, #16
35282 9B9E           B8                   8602    mov ax, #0x8602
35283 9BA1           E9         00EA              jmp pci_real_fail
35284                       00009BA4            pci_real_f03: ;; find class code
35285 9BA4           3C                     03    cmp al, #0x03
35286 9BA6           75           32              jne pci_real_f08
35287 9BA8           31DB                         xor bx, bx
35288 9BAA           BF                   0008    mov di, #0x08
35289                       00009BAD            pci_real_devloop2:
35290 9BAD           E8         010F              call pci_real_select_reg
35291 9BB0           BA                   0CFC    mov dx, #0x0cfc
35292 9BB3     66    ED                           in eax, dx
35293 9BB5     66    C1E8                   08    shr eax, #8
35294 9BB9     66    39C8                         cmp eax, ecx
35295 9BBC           75           09              jne pci_real_nextdev2
35296 9BBE           83FE                   00    cmp si, #0
35297 9BC1   7503    E9         00CE              je pci_real_ok
35298 9BC6           4E                           dec si
35299                       00009BC7            pci_real_nextdev2:
35300 9BC7           43                           inc bx
35301 9BC8           81FB                 0200    cmp bx, #0x0200
35302 9BCC           75           DF              jne pci_real_devloop2
35303 9BCE           89CA                         mov dx, cx
35304 9BD0     66    C1E9                   10    shr ecx, #16
35305 9BD4           B8                   8603    mov ax, #0x8603
35306 9BD7           E9         00B4              jmp pci_real_fail
35307                       00009BDA            pci_real_f08: ;; read configuration byte
35308 9BDA           3C                     08    cmp al, #0x08
35309 9BDC           75           14              jne pci_real_f09
35310 9BDE           E8         00DE              call pci_real_select_reg
35311 9BE1           52                           push dx
35312 9BE2           89FA                         mov dx, di
35313 9BE4           83E2                   03    and dx, #0x03
35314 9BE7           81C2                 0CFC    add dx, #0x0cfc
35315 9BEB           EC                           in al, dx
35316 9BEC           5A                           pop dx
35317 9BED           88C1                         mov cl, al
35318 9BEF           E9         00A2              jmp pci_real_ok
35319                       00009BF2            pci_real_f09: ;; read configuration word
35320 9BF2           3C                     09    cmp al, #0x09
35321 9BF4           75           14              jne pci_real_f0a
35322 9BF6           E8         00C6              call pci_real_select_reg
35323 9BF9           52                           push dx
35324 9BFA           89FA                         mov dx, di
35325 9BFC           83E2                   02    and dx, #0x02
35326 9BFF           81C2                 0CFC    add dx, #0x0cfc
35327 9C03           ED                           in ax, dx
35328 9C04           5A                           pop dx
35329 9C05           89C1                         mov cx, ax
35330 9C07           E9         008A              jmp pci_real_ok
35331                       00009C0A            pci_real_f0a: ;; read configuration dword
35332 9C0A           3C                     0A    cmp al, #0x0a
35333 9C0C           75           0F              jne pci_real_f0b
35334 9C0E           E8         00AE              call pci_real_select_reg
35335 9C11           52                           push dx
35336 9C12           BA                   0CFC    mov dx, #0x0cfc
35337 9C15     66    ED                           in eax, dx
35338 9C17           5A                           pop dx
35339 9C18     66    89C1                         mov ecx, eax
35340 9C1B           EB           77              jmp pci_real_ok
35341                       00009C1D            pci_real_f0b: ;; write configuration byte
35342 9C1D           3C                     0B    cmp al, #0x0b
35343 9C1F           75           13              jne pci_real_f0c
35344 9C21           E8         009B              call pci_real_select_reg
35345 9C24           52                           push dx
35346 9C25           89FA                         mov dx, di
35347 9C27           83E2                   03    and dx, #0x03
35348 9C2A           81C2                 0CFC    add dx, #0x0cfc
35349 9C2E           88C8                         mov al, cl
35350 9C30           EE                           out dx, al
35351 9C31           5A                           pop dx
35352 9C32           EB           60              jmp pci_real_ok
35353                       00009C34            pci_real_f0c: ;; write configuration word
35354 9C34           3C                     0C    cmp al, #0x0c
35355 9C36           75           13              jne pci_real_f0d
35356 9C38           E8         0084              call pci_real_select_reg
35357 9C3B           52                           push dx
35358 9C3C           89FA                         mov dx, di
35359 9C3E           83E2                   02    and dx, #0x02
35360 9C41           81C2                 0CFC    add dx, #0x0cfc
35361 9C45           89C8                         mov ax, cx
35362 9C47           EF                           out dx, ax
35363 9C48           5A                           pop dx
35364 9C49           EB           49              jmp pci_real_ok
35365                       00009C4B            pci_real_f0d: ;; write configuration dword
35366 9C4B           3C                     0D    cmp al, #0x0d
35367 9C4D           75           0F              jne pci_real_f0e
35368 9C4F           E8         006D              call pci_real_select_reg
35369 9C52           52                           push dx
35370 9C53           BA                   0CFC    mov dx, #0x0cfc
35371 9C56     66    89C8                         mov eax, ecx
35372 9C59     66    EF                           out dx, eax
35373 9C5B           5A                           pop dx
35374 9C5C           EB           36              jmp pci_real_ok
35375                       00009C5E            pci_real_f0e: ;; get irq routing options
35376 9C5E           3C                     0E    cmp al, #0x0e
35377 9C60           75           2A              jne pci_real_unknown
35378 9C62           50                           push ax
35379 9C63           B8                   0060    mov ax, #pci_routing_table_structure_end - pci_routing_table_structure_start
35380 9C66           26                           SEG ES
35381 9C67           3905                         cmp word ptr [di], ax
35382 9C69           72           1B              jb pci_real_too_small
35383 9C6B           AB                           stosw
35384 9C6C           9C                           pushf
35385 9C6D           06                           push es
35386 9C6E           51                           push cx
35387 9C6F           FC                           cld
35388 9C70           BE                   9D00    mov si, #pci_routing_table_structure_start
35389 9C73           0E                           push cs
35390 9C74           1F                           pop ds
35391 9C75           26                           SEG ES
35392 9C76           C47D         02              les di, [di+2]
35393 9C79           89C1                         mov cx, ax
35394 9C7B           F3                           rep
35395 9C7C           A4                               movsb
35396 9C7D           59                           pop cx
35397 9C7E           07                           pop es
35398 9C7F           9D                           popf
35399 9C80           58                           pop ax
35400 9C81           BB                   0A00    mov bx, #(1 << 9) | (1 << 11) ;; irq 9 and 11 are used
35401 9C84           EB           0E              jmp pci_real_ok
35402                       00009C86            pci_real_too_small:
35403 9C86           AB                           stosw
35404 9C87           58                           pop ax
35405 9C88           B4                     89    mov ah, #0x89
35406 9C8A           EB           02              jmp pci_real_fail
35407                       00009C8C            pci_real_unknown:
35408 9C8C           B4                     81    mov ah, #0x81
35409                       00009C8E            pci_real_fail:
35410 9C8E     66    5F                           pop edi
35411 9C90     66    5E                           pop esi
35412 9C92           F9                           stc
35413 9C93           C3                           ret
35414                       00009C94            pci_real_ok:
35415 9C94           30E4                         xor ah, ah
35416 9C96     66    5F                           pop edi
35417 9C98     66    5E                           pop esi
35418 9C9A           F8                           clc
35419 9C9B           C3                           ret
35420                       00009C9C            pci_real_get_max_bus:
35421 9C9C     66    50                           push eax
35422 9C9E     66    B8               80000000    mov eax, #0x80000000
35423 9CA4           BA                   0CF8    mov dx, #0x0cf8
35424 9CA7     66    EF                           out dx, eax
35425 9CA9           BA                   0CFC    mov dx, #0x0cfc
35426 9CAC     66    ED                           in eax, dx
35427 9CAE           B9                   0000    mov cx, #0
35428 9CB1     66    3D               71908086    cmp eax, #0x71908086 ;; i440BX PCI bridge
35429 9CB7           75           03              jne pci_real_no_i440bx
35430 9CB9           B9                   0001    mov cx, #0x0001
35431                       00009CBC            pci_real_no_i440bx:
35432 9CBC     66    58                           pop eax
35433 9CBE           C3                           ret
35434                       00009CBF            pci_real_select_reg:
35435 9CBF           52                           push dx
35436 9CC0     66    B8               00800000    mov eax, #0x800000
35437 9CC6           89D8                         mov ax, bx
35438 9CC8     66    C1E0                   08    shl eax, #8
35439 9CCC           81E7                 00FF    and di, #0xff
35440 9CD0           09F8                         or ax, di
35441 9CD2           24                     FC    and al, #0xfc
35442 9CD4           BA                   0CF8    mov dx, #0x0cf8
35443 9CD7     66    EF                           out dx, eax
35444 9CD9           5A                           pop dx
35445 9CDA           C3                           ret
35446 9CDB                  00000010            .align 16
35447                       00009CE0            pci_routing_table_structure:
35448 9CE0                        24              db 0x24, 0x50, 0x49, 0x52 ;; "$PIR" signature
35449 9CE4                        00              db 0, 1 ;; version
35450 9CE6                      0080              dw 32 + (6 * 16) ;; table size
35451 9CE8                        00              db 0 ;; PCI interrupt router bus
35452 9CE9                        08              db 0x08 ;; PCI interrupt router DevFunc
35453 9CEA                      0000              dw 0x0000 ;; PCI exclusive IRQs
35454 9CEC                      8086              dw 0x8086 ;; compatible PCI interrupt router vendor ID
35455 9CEE                      122E              dw 0x122e ;; compatible PCI interrupt router device ID
35456 9CF0                      0000              dw 0,0 ;; Miniport data
35457 9CF4                        00              db 0,0,0,0,0,0,0,0,0,0,0 ;; reserved
35458 9CFF                        37              db 0x37 ;; checksum
35459                       00009D00            pci_routing_table_structure_start:
35460                                             ;; first slot entry PCI-to-ISA (embedded)
35461 9D00                        00              db 0 ;; pci bus number
35462 9D01                        08              db 0x08 ;; pci device number (bit 7-3)
35463 9D02                        60              db 0x60 ;; link value INTA#: pointer into PCI2ISA config space
35464 9D03                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
35465 9D05                        61              db 0x61 ;; link value INTB#
35466 9D06                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
35467 9D08                        62              db 0x62 ;; link value INTC#
35468 9D09                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
35469 9D0B                        63              db 0x63 ;; link value INTD#
35470 9D0C                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
35471 9D0E                        00              db 0 ;; physical slot (0 = embedded)
35472 9D0F                        00              db 0 ;; reserved
35473                                             ;; second slot entry: 1st PCI slot
35474 9D10                        00              db 0 ;; pci bus number
35475 9D11                        10              db 0x10 ;; pci device number (bit 7-3)
35476 9D12                        61              db 0x61 ;; link value INTA#
35477 9D13                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
35478 9D15                        62              db 0x62 ;; link value INTB#
35479 9D16                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
35480 9D18                        63              db 0x63 ;; link value INTC#
35481 9D19                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
35482 9D1B                        60              db 0x60 ;; link value INTD#
35483 9D1C                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
35484 9D1E                        01              db 1 ;; physical slot (0 = embedded)
35485 9D1F                        00              db 0 ;; reserved
35486                                             ;; third slot entry: 2nd PCI slot
35487 9D20                        00              db 0 ;; pci bus number
35488 9D21                        18              db 0x18 ;; pci device number (bit 7-3)
35489 9D22                        62              db 0x62 ;; link value INTA#
35490 9D23                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
35491 9D25                        63              db 0x63 ;; link value INTB#
35492 9D26                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
35493 9D28                        60              db 0x60 ;; link value INTC#
35494 9D29                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
35495 9D2B                        61              db 0x61 ;; link value INTD#
35496 9D2C                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
35497 9D2E                        02              db 2 ;; physical slot (0 = embedded)
35498 9D2F                        00              db 0 ;; reserved
35499                                             ;; 4th slot entry: 3rd PCI slot
35500 9D30                        00              db 0 ;; pci bus number
35501 9D31                        20              db 0x20 ;; pci device number (bit 7-3)
35502 9D32                        63              db 0x63 ;; link value INTA#
35503 9D33                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
35504 9D35                        60              db 0x60 ;; link value INTB#
35505 9D36                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
35506 9D38                        61              db 0x61 ;; link value INTC#
35507 9D39                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
35508 9D3B                        62              db 0x62 ;; link value INTD#
35509 9D3C                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
35510 9D3E                        03              db 3 ;; physical slot (0 = embedded)
35511 9D3F                        00              db 0 ;; reserved
35512                                             ;; 5th slot entry: 4th PCI slot
35513 9D40                        00              db 0 ;; pci bus number
35514 9D41                        28              db 0x28 ;; pci device number (bit 7-3)
35515 9D42                        60              db 0x60 ;; link value INTA#
35516 9D43                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
35517 9D45                        61              db 0x61 ;; link value INTB#
35518 9D46                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
35519 9D48                        62              db 0x62 ;; link value INTC#
35520 9D49                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
35521 9D4B                        63              db 0x63 ;; link value INTD#
35522 9D4C                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
35523 9D4E                        04              db 4 ;; physical slot (0 = embedded)
35524 9D4F                        00              db 0 ;; reserved
35525                                             ;; 6th slot entry: 5th PCI slot
35526 9D50                        00              db 0 ;; pci bus number
35527 9D51                        30              db 0x30 ;; pci device number (bit 7-3)
35528 9D52                        61              db 0x61 ;; link value INTA#
35529 9D53                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
35530 9D55                        62              db 0x62 ;; link value INTB#
35531 9D56                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
35532 9D58                        63              db 0x63 ;; link value INTC#
35533 9D59                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
35534 9D5B                        60              db 0x60 ;; link value INTD#
35535 9D5C                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
35536 9D5E                        05              db 5 ;; physical slot (0 = embedded)
35537 9D5F                        00              db 0 ;; reserved
35538                       00009D60            pci_routing_table_structure_end:
35539                       00009D60            rombios32_init:
35540                                             ;; save a20 and enable it
35541 9D60           E4                     92    in al, 0x0092
35542 9D62           50                           push ax
35543 9D63           0C                     02    or al, #0x02
35544 9D65           E6                     92    out 0x0092, al
35545                                             ;; save SS:SP to the BDA
35546 9D67           31C0                         xor ax, ax
35547 9D69           8ED8                         mov ds, ax
35548 9D6B           8C16       0469              mov 0x0469, ss
35549 9D6F           8926       0467              mov 0x0467, sp
35550 9D73           2E                           SEG CS
35551 9D74         0F011E       F8AB                lidt [pmode_IDT_info]
35552 9D79           2E                           SEG CS
35553 9D7A         0F0116       9E01                lgdt [rombios32_gdt_48]
35554                                             ;; set PE bit in CR0
35555 9D7F         0F20C0                         mov eax, cr0
35556 9D82           0C                     01    or al, #0x01
35557 9D84         0F22C0                         mov cr0, eax
35558                                             ;; start protected mode code: ljmpl 0x10:rombios32_init1
35559 9D87                        66              db 0x66, 0xea
35560 9D89                      9D8F              dw rombios32_05
35561 9D8B                      000F              dw 0x000f ;; high 16 bit address
35562 9D8D                      0010              dw 0x0010
35563                                           use32 386
35564                       00009D8F            rombios32_05:
35565                                             ;; init data segments
35566 9D8F           B8               00000018    mov eax, #0x18
35567 9D94           8ED8                         mov ds, ax
35568 9D96           8EC0                         mov es, ax
35569 9D98           8ED0                         mov ss, ax
35570 9D9A           31C0                         xor eax, eax
35571 9D9C           8EE0                         mov fs, ax
35572 9D9E           8EE8                         mov gs, ax
35573 9DA0           FC                           cld
35574                                             ;; init the stack pointer to point below EBDA
35575 9DA1   6766    A1         040E              mov ax, [0x040e]
35576 9DA6           C1E0                   04    shl eax, #4
35577 9DA9           BC               FFFFFFF0    mov esp, #-0x10
35578 9DAE           01C4                         add esp, eax
35579                                             ;; pass pointer to s3_resume_flag and s3_resume_vector to rombios32
35580 9DB0           68               000004B0    push #0x04b0
35581 9DB5           68               000004B2    push #0x04b2
35582                                             ;; call rombios32 code
35583 9DBA           B8               000E0000    mov eax, #0x000e0000
35584 9DBF           FFD0                         call eax
35585                                             ;; return to 16 bit protected mode first
35586 9DC1                        EA              db 0xea
35587 9DC2                  00009DC8              dd rombios32_10
35588 9DC6                      0020              dw 0x20
35589                                           use16 386
35590                       00009DC8            rombios32_10:
35591                                             ;; restore data segment limits to 0xffff
35592 9DC8           B8                   0028    mov ax, #0x28
35593 9DCB           8ED8                         mov ds, ax
35594 9DCD           8EC0                         mov es, ax
35595 9DCF           8ED0                         mov ss, ax
35596 9DD1           8EE0                         mov fs, ax
35597 9DD3           8EE8                         mov gs, ax
35598                                             ;; reset PE bit in CR0
35599 9DD5         0F20C0                         mov eax, cr0
35600 9DD8           24                     FE    and al, #0xFE
35601 9DDA         0F22C0                         mov cr0, eax
35602                                             ;; far jump to flush CPU queue after transition to real mode
35603                                             JMP_AP(0xf000, rombios32_real_mode)
 +a   9DDD                        EA              db 0xea
 +a   9DDE                      9DE2              dw  rombios32_real_mode
 +a   9DE0                      F000              dw 0xf000
35604                       00009DE2            rombios32_real_mode:
35605                                             ;; restore IDT to normal real-mode defaults
35606 9DE2           2E                           SEG CS
35607 9DE3         0F011E       F8B1                lidt [rmode_IDT_info]
35608 9DE8           31C0                         xor ax, ax
35609 9DEA           8ED8                         mov ds, ax
35610 9DEC           8EC0                         mov es, ax
35611 9DEE           8EE0                         mov fs, ax
35612 9DF0           8EE8                         mov gs, ax
35613                                             ;; restore SS:SP from the BDA
35614 9DF2           8E16       0469              mov ss, 0x0469
35615 9DF6     66    31E4                         xor esp, esp
35616 9DF9           8B26       0467              mov sp, 0x0467
35617                                             ;; restore a20
35618 9DFD           58                           pop ax
35619 9DFE           E6                     92    out 0x0092, al
35620 9E00           C3                           ret
35621                       00009E01            rombios32_gdt_48:
35622 9E01                      0030              dw 0x30
35623 9E03                      9E07              dw rombios32_gdt
35624 9E05                      000F              dw 0x000f
35625                       00009E07            rombios32_gdt:
35626 9E07                      0000              dw 0, 0, 0, 0
35627 9E0F                      0000              dw 0, 0, 0, 0
35628 9E17                      FFFF              dw 0xffff, 0, 0x9b00, 0x00cf ; 32 bit flat code segment (0x10)
35629 9E1F                      FFFF              dw 0xffff, 0, 0x9300, 0x00cf ; 32 bit flat data segment (0x18)
35630 9E27                      FFFF              dw 0xffff, 0, 0x9b0f, 0x0000 ; 16 bit code segment base=0xf0000 limit=0xffff
35631 9E2F                      FFFF              dw 0xffff, 0, 0x9300, 0x0000 ; 16 bit data segment base=0x0 limit=0xffff
35632                                           ; parallel port detection: base address in DX, index in BX, timeout in CL
35633                       00009E37            detect_parport:
35634 9E37           52                           push dx
35635 9E38           83C2                   02    add dx, #2
35636 9E3B           EC                           in al, dx
35637 9E3C           24                     DF    and al, #0xdf ; clear input mode
35638 9E3E           EE                           out dx, al
35639 9E3F           5A                           pop dx
35640 9E40           B0                     AA    mov al, #0xaa
35641 9E42           EE                           out dx, al
35642 9E43           EC                           in al, dx
35643 9E44           3C                     AA    cmp al, #0xaa
35644 9E46           75           0D              jne no_parport
35645 9E48           53                           push bx
35646 9E49           D1E3                         shl bx, #1
35647 9E4B           8997       0408              mov [bx+0x408], dx ; Parallel I/O address
35648 9E4F           5B                           pop bx
35649 9E50           888F       0478              mov [bx+0x478], cl ; Parallel printer timeout
35650 9E54           43                           inc bx
35651                       00009E55            no_parport:
35652 9E55           C3                           ret
35653                                           ; serial port detection: base address in DX, index in BX, timeout in CL
35654                       00009E56            detect_serial:
35655 9E56           52                           push dx
35656 9E57           42                           inc dx
35657 9E58           B0                     02    mov al, #0x02
35658 9E5A           EE                           out dx, al
35659 9E5B           EC                           in al, dx
35660 9E5C           3C                     02    cmp al, #0x02
35661 9E5E           75           19              jne no_serial
35662 9E60           42                           inc dx
35663 9E61           EC                           in al, dx
35664 9E62           3C                     02    cmp al, #0x02
35665 9E64           75           13              jne no_serial
35666 9E66           4A                           dec dx
35667 9E67           30C0                         xor al, al
35668 9E69           EE                           out dx, al
35669 9E6A           5A                           pop dx
35670 9E6B           53                           push bx
35671 9E6C           D1E3                         shl bx, #1
35672 9E6E           8997       0400              mov [bx+0x400], dx ; Serial I/O address
35673 9E72           5B                           pop bx
35674 9E73           888F       047C              mov [bx+0x47c], cl ; Serial timeout
35675 9E77           43                           inc bx
35676 9E78           C3                           ret
35677                       00009E79            no_serial:
35678 9E79           5A                           pop dx
35679 9E7A           C3                           ret
35680                       00009E7B            rom_checksum:
35681 9E7B           60                           pusha
35682 9E7C           1E                           push ds
35683 9E7D           31C0                         xor ax, ax
35684 9E7F           31DB                         xor bx, bx
35685 9E81           31C9                         xor cx, cx
35686 9E83           31D2                         xor dx, dx
35687 9E85           8A2E       0002              mov ch, [2]
35688 9E89           D1E1                         shl cx, #1
35689 9E8B           73           05              jnc checksum_loop
35690 9E8D           74           03              jz checksum_loop
35691 9E8F           87CA                         xchg dx, cx
35692 9E91           49                           dec cx
35693                       00009E92            checksum_loop:
35694 9E92           0207                         add al, [bx]
35695 9E94           43                           inc bx
35696 9E95           E2           FB              loop checksum_loop
35697 9E97           85D2                         test dx, dx
35698 9E99           74           11              je checksum_out
35699 9E9B           0207                         add al, [bx]
35700 9E9D           89D1                         mov cx, dx
35701 9E9F           8CDA                         mov dx, ds
35702 9EA1           80C6                   10    add dh, #0x10
35703 9EA4           8EDA                         mov ds, dx
35704 9EA6           31D2                         xor dx, dx
35705 9EA8           31DB                         xor bx, bx
35706 9EAA           EB           E6              jmp checksum_loop
35707                       00009EAC            checksum_out:
35708 9EAC           24                     FF    and al, #0xff
35709 9EAE           1F                           pop ds
35710 9EAF           61                           popa
35711 9EB0           C3                           ret
35712 9EB1                  00000010            .align 16
35713                       00009EC0            pnpbios_structure:
35714 9EC0                        24              .ascii "$PnP"
35715 9EC4                        10              db 0x10 ;; version
35716 9EC5                        21              db 0x21 ;; length
35717 9EC6                      0000              dw 0x0 ;; control field
35718 9EC8                        D1              db 0xd1 ;; checksum
35719 9EC9                  000F0000              dd 0xf0000 ;; event notification flag address
35720 9ECD                      9EE8              dw pnpbios_real ;; real mode 16 bit offset
35721 9ECF                      F000              dw 0xf000 ;; real mode 16 bit segment
35722 9ED1                      9EE1              dw pnpbios_prot ;; 16 bit protected mode offset
35723 9ED3                  000F0000              dd 0xf0000 ;; 16 bit protected mode segment base
35724 9ED7                  00000000              dd 0x0 ;; OEM device identifier
35725 9EDB                      F000              dw 0xf000 ;; real mode 16 bit data segment
35726 9EDD                  000F0000              dd 0xf0000 ;; 16 bit protected mode segment base
35727                       00009EE1            pnpbios_prot:
35728 9EE1     66    55                           push ebp
35729 9EE3     66    89E5                         mov ebp, esp
35730 9EE6           EB           06              jmp pnpbios_code
35731                       00009EE8            pnpbios_real:
35732 9EE8     66    55                           push ebp
35733 9EEA     66  0FB7EC                         movzx ebp, sp
35734                       00009EEE            pnpbios_code:
35735 9EEE   67      8B45         08              mov ax, 8[ebp]
35736 9EF2           3D                   0060    cmp ax, #0x60 ;; Get Version and Installation Check
35737 9EF5           75           10              jnz pnpbios_00
35738 9EF7           06                           push es
35739 9EF8           57                           push di
35740 9EF9   67      C47D         0A              les di, 10[ebp]
35741 9EFD           B8                   0101    mov ax, #0x0101
35742 9F00           AB                           stosw
35743 9F01           5F                           pop di
35744 9F02           07                           pop es
35745 9F03           31C0                         xor ax, ax ;; SUCCESS
35746 9F05           EB           1F              jmp pnpbios_exit
35747                       00009F07            pnpbios_00:
35748 9F07           3D                   0000    cmp ax, #0x00 ;; Get Number of System Device Nodes
35749 9F0A           75           17              jnz pnpbios_fail
35750 9F0C           06                           push es
35751 9F0D           57                           push di
35752 9F0E   67      C47D         0A              les di, 10[ebp]
35753 9F12           B0                     00    mov al, #0x00
35754 9F14           AA                           stosb
35755 9F15   67      C47D         0E              les di, 14[ebp]
35756 9F19           B8                   0000    mov ax, #0x0000
35757 9F1C           AB                           stosw
35758 9F1D           5F                           pop di
35759 9F1E           07                           pop es
35760 9F1F           31C0                         xor ax, ax ;; SUCCESS
35761 9F21           EB           03              jmp pnpbios_exit
35762                       00009F23            pnpbios_fail:
35763 9F23           B8                   0082    mov ax, #0x82 ;; FUNCTION_NOT_SUPPORTED
35764                       00009F26            pnpbios_exit:
35765 9F26     66    5D                           pop ebp
35766 9F28           CB                           retf
35767                       00009F29            rom_scan:
35768                                             ;; Scan for existence of valid expansion ROMS.
35769                                             ;; Video ROM: from 0xC0000..0xC7FFF in 2k increments
35770                                             ;; General ROM: from 0xC8000..0xDFFFF in 2k increments
35771                                             ;; System ROM: only 0xE0000
35772                                             ;;
35773                                             ;; Header:
35774                                             ;; Offset Value
35775                                             ;; 0 0x55
35776                                             ;; 1 0xAA
35777                                             ;; 2 ROM length in 512-byte blocks
35778                                             ;; 3 ROM initialization entry point (FAR CALL)
35779                       00009F29            rom_scan_loop:
35780 9F29           50                           push ax ;; Save AX
35781 9F2A           8ED9                         mov ds, cx
35782 9F2C           B8                   0004    mov ax, #0x0004 ;; start with increment of 4 (512-byte) blocks = 2k
35783 9F2F           813E       0000      AA55    cmp [0], #0xAA55 ;; look for signature
35784 9F35   7403    E9         009E              jne rom_scan_increment
35785 9F3A           E8         FF3E              call rom_checksum
35786 9F3D   7403    E9         0096              jnz rom_scan_increment
35787 9F42           A0         0002              mov al, [2] ;; change increment to ROM length in 512-byte blocks
35788                                             ;; We want our increment in 512-byte quantities, rounded to
35789                                             ;; the nearest 2k quantity, since we only scan at 2k intervals.
35790 9F45           A8                     03    test al, #0x03
35791 9F47           74           04              jz block_count_rounded
35792 9F49           24                     FC    and al, #0xfc ;; needs rounding up
35793 9F4B           04                     04    add al, #0x04
35794                       00009F4D            block_count_rounded:
35795 9F4D           31DB                         xor bx, bx ;; Restore DS back to 0000:
35796 9F4F           8EDB                         mov ds, bx
35797 9F51           50                           push ax ;; Save AX
35798 9F52           57                           push di ;; Save DI
35799                                             ;; Push addr of ROM entry point
35800 9F53           51                           push cx ;; Push seg
35801 9F54           6A                     03    push #0x0003 ;; Push offset
35802                                             ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
35803                                             ;; That should stop it grabbing INT 19h; we will use its BEV instead.
35804 9F56           B8                   F000    mov ax, #0xf000
35805 9F59           8EC0                         mov es, ax
35806 9F5B           8D3E       9EC0              lea di, pnpbios_structure
35807 9F5F           89E5                         mov bp, sp ;; Call ROM init routine using seg:off on stack
35808 9F61                        FF              db 0xff ;; call_far ss:[bp+0]
35809 9F62                        5E              db 0x5e
35810 9F63                        00              db 0
35811 9F64           FA                           cli ;; In case expansion ROM BIOS turns IF on
35812 9F65           83C4                   02    add sp, #2 ;; Pop offset value
35813 9F68           59                           pop cx ;; Pop seg value (restore CX)
35814                                             ;; Look at the ROM's PnP Expansion header.  Properly, we're supposed
35815                                             ;; to init all the ROMs and then go back and build an IPL table of
35816                                             ;; all the bootable devices, but we can get away with one pass.
35817 9F69           8ED9                         mov ds, cx ;; ROM base
35818 9F6B           8B1E       001A              mov bx, 0x001a ;; 0x1A is the offset into ROM header that contains...
35819 9F6F           8B07                         mov ax, [bx] ;; the offset of PnP expansion header, where...
35820 9F71           3D                   5024    cmp ax, #0x5024 ;; we look for signature "$PnP"
35821 9F74           75           60              jne no_bev
35822 9F76           8B47         02              mov ax, 2[bx]
35823 9F79           3D                   506E    cmp ax, #0x506e
35824 9F7C           75           58              jne no_bev
35825 9F7E           8B47         16              mov ax, 0x16[bx] ;; 0x16 is the offset of Boot Connection Vector
35826 9F81           3D                   0000    cmp ax, #0x0000
35827 9F84           74           17              je no_bcv
35828                                             ;; Option ROM has BCV. Run it now.
35829 9F86           51                           push cx ;; Push seg
35830 9F87           50                           push ax ;; Push offset
35831                                             ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
35832 9F88           BB                   F000    mov bx, #0xf000
35833 9F8B           8EC3                         mov es, bx
35834 9F8D           8D3E       9EC0              lea di, pnpbios_structure
35835 9F91           89E5                         mov bp, sp ;; Call ROM BCV routine using seg:off on stack
35836 9F93                        FF              db 0xff ;; call_far ss:[bp+0]
35837 9F94                        5E              db 0x5e
35838 9F95                        00              db 0
35839 9F96           FA                           cli ;; In case expansion ROM BIOS turns IF on
35840 9F97           83C4                   02    add sp, #2 ;; Pop offset value
35841 9F9A           59                           pop cx ;; Pop seg value (restore CX)
35842 9F9B           EB           39              jmp no_bev
35843                       00009F9D            no_bcv:
35844 9F9D           8B47         1A              mov ax, 0x1a[bx] ;; 0x1A is also the offset into the expansion header of...
35845 9FA0           3D                   0000    cmp ax, #0x0000 ;; the Bootstrap Entry Vector, or zero if there is 0 .
35846 9FA3           74           31              je no_bev
35847                                             ;; Found a device that thinks it can boot the system. Record its BEV and product name string.
35848 9FA5           8B7F         10              mov di, 0x10[bx] ;; Pointer to the product name string or zero if 0
35849 9FA8           BB                   9FF0    mov bx, #0x9ff0 ;; Go to the segment where the IPL table lives
35850 9FAB           8EDB                         mov ds, bx
35851 9FAD           8B1E       0080              mov bx, 0x0080 ;; Read the number of entries so far
35852 9FB1           83FB                   08    cmp bx, #8
35853 9FB4           74           20              je no_bev ;; Get out if the table is full
35854 9FB6           C1E3                   04    shl bx, #0x4 ;; Turn count into offset (entries are 16 bytes)
35855 9FB9           C707                 0080    mov 0[bx], #0x80 ;; This entry is a BEV device
35856 9FBD           894F         06              mov 6[bx], cx ;; Build a far pointer from the segment...
35857 9FC0           8947         04              mov 4[bx], ax ;; and the offset
35858 9FC3           83FF                   00    cmp di, #0x0000
35859 9FC6           74           06              je no_prod_str
35860 9FC8           894F         0A              mov 0xA[bx], cx ;; Build a far pointer from the segment...
35861 9FCB           897F         08              mov 8[bx], di ;; and the offset
35862                       00009FCE            no_prod_str:
35863 9FCE           C1EB                   04    shr bx, #0x4 ;; Turn the offset back into a count
35864 9FD1           43                           inc bx ;; We have one more entry now
35865 9FD2           891E       0080              mov 0x0080, bx ;; Remember that.
35866                       00009FD6            no_bev:
35867 9FD6           5F                           pop di ;; Restore DI
35868 9FD7           58                           pop ax ;; Restore AX
35869                       00009FD8            rom_scan_increment:
35870 9FD8           C1E0                   05    shl ax, #5 ;; convert 512-bytes blocks to 16-byte increments
35871                                                           ;; because the segment selector is shifted left 4 bits.
35872 9FDB           01C1                         add cx, ax
35873 9FDD           58                           pop ax ;; Restore AX
35874 9FDE           39C1                         cmp cx, ax
35875 9FE0   7703    E9         FF44              jbe rom_scan_loop
35876 9FE5           31C0                         xor ax, ax ;; Restore DS back to 0000:
35877 9FE7           8ED8                         mov ds, ax
35878 9FE9           C3                           ret
35879                       00009FEA            post_init_pic:
35880 9FEA           B0                     11    mov al, #0x11 ; send initialisation commands
35881 9FEC           E6                     20    out 0x0020, al
35882 9FEE           E6                     A0    out 0x00a0, al
35883 9FF0           B0                     08    mov al, #0x08
35884 9FF2           E6                     21    out 0x0021, al
35885 9FF4           B0                     70    mov al, #0x70
35886 9FF6           E6                     A1    out 0x00a1, al
35887 9FF8           B0                     04    mov al, #0x04
35888 9FFA           E6                     21    out 0x0021, al
35889 9FFC           B0                     02    mov al, #0x02
35890 9FFE           E6                     A1    out 0x00a1, al
35891 A000           B0                     01    mov al, #0x01
35892 A002           E6                     21    out 0x0021, al
35893 A004           E6                     A1    out 0x00a1, al
35894 A006           B0                     B8    mov al, #0xb8
35895 A008           E6                     21    out 0x0021, AL ;master pic: unmask IRQ 0, 1, 2, 6
35896 A00A           B0                     8F    mov al, #0x8f
35897 A00C           E6                     A1    out 0x00a1, AL ;slave pic: unmask IRQ 12, 13, 14
35898 A00E           C3                           ret
35899                       0000A00F            post_init_ivt:
35900                                             ;; set first 120 interrupts to default handler
35901 A00F           31FF                         xor di, di ;; offset index
35902 A011           B9                   0078    mov cx, #0x0078 ;; counter (120 interrupts)
35903 A014           B8                   F000    mov ax, #0xF000
35904 A017     66    C1E0                   10    shl eax, #16
35905 A01B           B8                   FF53    mov ax, #dummy_iret_handler
35906 A01E           FC                           cld
35907 A01F           F3                           rep
35908 A020     66    AB                             stosd
35909                                             ;; Master PIC vector
35910 A022           BB                   0020    mov bx, #0x0020
35911 A025           B1                     08    mov cl, #0x08
35912 A027           B8                   E9E6    mov ax, #dummy_master_pic_irq_handler
35913                       0000A02A            post_default_master_pic_ints:
35914 A02A           8907                         mov [bx], ax
35915 A02C           83C3                   04    add bx, #4
35916 A02F           E2           F9              loop post_default_master_pic_ints
35917                                             ;; Slave PIC vector
35918 A031           81C3                 0180    add bx, #0x0180
35919 A035           B1                     08    mov cl, #0x08
35920 A037           B8                   E9EC    mov ax, #dummy_slave_pic_irq_handler
35921                       0000A03A            post_default_slave_pic_ints:
35922 A03A           8907                         mov [bx], ax
35923 A03C           83C3                   04    add bx, #4
35924 A03F           E2           F9              loop post_default_slave_pic_ints
35925                                             ;; Printer Services vector
35926                                             SET_INT_VECTOR(0x17, #0xF000, #int17_handler)
 +a   A041           B8                   EFD2    mov ax,  #int17_handler
 +a   A044           A3         005C              mov 0x17*4, ax
 +a   A047           B8                   F000    mov ax,  #0xF000
 +a   A04A           A3         005E              mov 0x17*4+2, ax
35927                                             ;; Bootstrap failure vector
35928                                             SET_INT_VECTOR(0x18, #0xF000, #int18_handler)
 +a   A04D           B8                   9282    mov ax,  #int18_handler
 +a   A050           A3         0060              mov 0x18*4, ax
 +a   A053           B8                   F000    mov ax,  #0xF000
 +a   A056           A3         0062              mov 0x18*4+2, ax
35929                                             ;; Bootstrap Loader vector
35930                                             SET_INT_VECTOR(0x19, #0xF000, #int19_handler)
 +a   A059           B8                   E6F2    mov ax,  #int19_handler
 +a   A05C           A3         0064              mov 0x19*4, ax
 +a   A05F           B8                   F000    mov ax,  #0xF000
 +a   A062           A3         0066              mov 0x19*4+2, ax
35931                                             ;; Memory Size Check vector
35932                                             SET_INT_VECTOR(0x12, #0xF000, #int12_handler)
 +a   A065           B8                   F841    mov ax,  #int12_handler
 +a   A068           A3         0048              mov 0x12*4, ax
 +a   A06B           B8                   F000    mov ax,  #0xF000
 +a   A06E           A3         004A              mov 0x12*4+2, ax
35933                                             ;; Equipment Configuration Check vector
35934                                             SET_INT_VECTOR(0x11, #0xF000, #int11_handler)
 +a   A071           B8                   F84D    mov ax,  #int11_handler
 +a   A074           A3         0044              mov 0x11*4, ax
 +a   A077           B8                   F000    mov ax,  #0xF000
 +a   A07A           A3         0046              mov 0x11*4+2, ax
35935                                             ;; System Services
35936                                             SET_INT_VECTOR(0x15, #0xF000, #int15_handler)
 +a   A07D           B8                   F859    mov ax,  #int15_handler
 +a   A080           A3         0054              mov 0x15*4, ax
 +a   A083           B8                   F000    mov ax,  #0xF000
 +a   A086           A3         0056              mov 0x15*4+2, ax
35937                                             ;; MDA/CGA Video Parameter Table is not available
35938                                             SET_INT_VECTOR(0x1D, #0, #0)
 +a   A089           B8                   0000    mov ax,  #0
 +a   A08C           A3         0074              mov 0x1D*4, ax
 +a   A08F           B8                   0000    mov ax,  #0
 +a   A092           A3         0076              mov 0x1D*4+2, ax
35939                                             ;; Character Font for upper 128 characters is not available
35940                                             SET_INT_VECTOR(0x1F, #0, #0)
 +a   A095           B8                   0000    mov ax,  #0
 +a   A098           A3         007C              mov 0x1F*4, ax
 +a   A09B           B8                   0000    mov ax,  #0
 +a   A09E           A3         007E              mov 0x1F*4+2, ax
35941                                             ;; set vectors 0x60 - 0x67h to zero (0:180..0:19f)
35942 A0A1           31C0                         xor ax, ax
35943 A0A3           B9                   0010    mov cx, #0x0010 ;; 16 words
35944 A0A6           BF                   0180    mov di, #0x0180
35945 A0A9           FC                           cld
35946 A0AA           F3                           rep
35947 A0AB           AB                             stosw
35948                                             ;; set vector 0x78 and above to zero
35949 A0AC     66    31C0                         xor eax, eax
35950 A0AF           B1                     88    mov cl, #0x88 ;; 136 dwords
35951 A0B1           BF                   01E0    mov di, #0x1e0
35952 A0B4           F3                           rep
35953 A0B5     66    AB                             stosd
35954 A0B7           C3                           ret
35955                                           ;; the following area can be used to write dynamically generated tables
35956 A0B8                  00000010              .align 16
35957                       0000A0C0            bios_table_area_start:
35958 A0C0                  AAFB4442              dd 0xaafb4442
35959 A0C4                  00002B38              dd bios_table_area_end - bios_table_area_start - 8;
35960                                           ;--------
35961                                           ;- POST -
35962                                           ;--------
35963 E05B                                      .org 0xe05b ; POST Entry Point
35964                       0000E05B            post:
35965 E05B           31C0                         xor ax, ax
35966                                             ;; first reset the DMA controllers
35967 E05D           E6                     0D    out 0x000d,al
35968 E05F           E6                     DA    out 0x00da,al
35969                                             ;; then initialize the DMA controllers
35970 E061           B0                     C0    mov al, #0xC0
35971 E063           E6                     D6    out 0x00d6, al ; cascade mode of channel 4 enabled
35972 E065           B0                     00    mov al, #0x00
35973 E067           E6                     D4    out 0x00d4, al ; unmask channel 4
35974                                             ;; Examine CMOS shutdown status.
35975 E069           B0                     0F    mov AL, #0x0f
35976 E06B           E6                     70    out 0x0070, AL
35977 E06D           E4                     71    in AL, 0x0071
35978                                             ;; backup status
35979 E06F           88C3                         mov bl, al
35980                                             ;; Reset CMOS shutdown status.
35981 E071           B0                     0F    mov AL, #0x0f
35982 E073           E6                     70    out 0x0070, AL ; select CMOS register Fh
35983 E075           B0                     00    mov AL, #0x00
35984 E077           E6                     71    out 0x0071, AL ; set shutdown action to normal
35985                                             ;; Examine CMOS shutdown status.
35986 E079           88D8                         mov al, bl
35987                                             ;; 0x00, 0x0D+ = normal startup
35988 E07B           3C                     00    cmp AL, #0x00
35989 E07D           74           24              jz normal_post
35990 E07F           3C                     0D    cmp AL, #0x0d
35991 E081           73           20              jae normal_post
35992                                             ;; 0x05 = eoi + jmp via [0x40:0x67] jump
35993 E083           3C                     05    cmp al, #0x05
35994 E085   7503    E9         B4EC              je eoi_jmp_post
35995                                             ;; 0x0A = jmp via [0x40:0x67] jump
35996 E08A           3C                     0A    cmp al, #0x0a
35997 E08C   7503    E9         B511              je jmp_post_0x467
35998                                             ;; 0x0B = iret via [0x40:0x67]
35999 E091           3C                     0B    cmp al, #0x0b
36000 E093   7503    E9         B512              je iret_post_0x467
36001                                             ;; 0x0C = retf via [0x40:0x67]
36002 E098           3C                     0C    cmp al, #0x0c
36003 E09A   7503    E9         B518              je retf_post_0x467
36004                                             ;; Examine CMOS shutdown status.
36005                                             ;; 0x01,0x02,0x03,0x04,0x06,0x07,0x08,0x09 = Unimplemented shutdown status.
36006 E09F           53                           push bx
36007 E0A0           E8         311B              call _shutdown_status_panic
36008                       0000E0A3            normal_post:
36009                                             ; case 0: normal startup
36010 E0A3           FA                           cli
36011 E0A4           B8                   FFFE    mov ax, #0xfffe
36012 E0A7           89C4                         mov sp, ax
36013 E0A9           31C0                         xor ax, ax
36014 E0AB           8ED8                         mov ds, ax
36015 E0AD           8ED0                         mov ss, ax
36016                                             ;; Save shutdown status
36017 E0AF           881E       04B0              mov 0x04b0, bl
36018 E0B3           80FB                   FE    cmp bl, #0xfe
36019 E0B6   7503    E9         B509              jz s3_post
36020                                             ;; zero out BIOS data area (40:00..40:ff)
36021 E0BB           8EC0                         mov es, ax
36022 E0BD           B9                   0080    mov cx, #0x0080 ;; 128 words
36023 E0C0           BF                   0400    mov di, #0x0400
36024 E0C3           FC                           cld
36025 E0C4           F3                           rep
36026 E0C5           AB                             stosw
36027 E0C6           E8         3659              call _log_bios_start
36028 E0C9           E8         BF43              call post_init_ivt
36029                                             ;; base memory in K 40:13 (word)
36030 E0CC           B8                   027F    mov ax, #(640 - 1)
36031 E0CF           A3         0413              mov 0x0413, ax
36032                                             ;; Manufacturing Test 40:12
36033                                             ;; zerod out above
36034                                             ;; Warm Boot Flag 0040:0072
36035                                             ;; value of 1234h = skip memory checks
36036                                             ;; zerod out above
36037                                             ;; EBDA setup
36038 E0D2           E8         B48C              call ebda_post
36039                                             ;; PIT setup
36040                                             SET_INT_VECTOR(0x08, #0xF000, #int08_handler)
 +a   E0D5           B8                   FEA5    mov ax,  #int08_handler
 +a   E0D8           A3         0020              mov 0x08*4, ax
 +a   E0DB           B8                   F000    mov ax,  #0xF000
 +a   E0DE           A3         0022              mov 0x08*4+2, ax
36041                                             ;; int 1C already points at dummy_iret_handler (above)
36042 E0E1           B0                     34    mov al, #0x34 ; timer0: binary count, 16bit count, mode 2
36043 E0E3           E6                     43    out 0x0043, al
36044 E0E5           B0                     00    mov al, #0x00 ; maximum count of 0000H = 18.2Hz
36045 E0E7           E6                     40    out 0x0040, al
36046 E0E9           E6                     40    out 0x0040, al
36047                                             ;; Keyboard
36048                                             SET_INT_VECTOR(0x09, #0xF000, #int09_handler)
 +a   E0EB           B8                   E987    mov ax,  #int09_handler
 +a   E0EE           A3         0024              mov 0x09*4, ax
 +a   E0F1           B8                   F000    mov ax,  #0xF000
 +a   E0F4           A3         0026              mov 0x09*4+2, ax
36049                                             SET_INT_VECTOR(0x16, #0xF000, #int16_handler)
 +a   E0F7           B8                   E82E    mov ax,  #int16_handler
 +a   E0FA           A3         0058              mov 0x16*4, ax
 +a   E0FD           B8                   F000    mov ax,  #0xF000
 +a   E100           A3         005A              mov 0x16*4+2, ax
36050 E103           31C0                         xor ax, ax
36051 E105           8ED8                         mov ds, ax
36052 E107           A2         0417              mov 0x0417, al
36053 E10A           A2         0418              mov 0x0418, al
36054 E10D           A2         0419              mov 0x0419, al
36055 E110           A2         0471              mov 0x0471, al
36056 E113           A2         0497              mov 0x0497, al
36057 E116           B0                     10    mov al, #0x10
36058 E118           A2         0496              mov 0x0496, al
36059 E11B           BB                   001E    mov bx, #0x001E
36060 E11E           891E       041A              mov 0x041A, bx
36061 E122           891E       041C              mov 0x041C, bx
36062 E126           BB                   001E    mov bx, #0x001E
36063 E129           891E       0480              mov 0x0480, bx
36064 E12D           BB                   003E    mov bx, #0x003E
36065 E130           891E       0482              mov 0x0482, bx
36066 E134           E8         2B2C              call _keyboard_init
36067                                             ;; mov CMOS Equipment Byte to BDA Equipment Word
36068 E137           A1         0410              mov ax, 0x0410
36069 E13A           B0                     14    mov al, #0x14
36070 E13C           E6                     70    out 0x0070, al
36071 E13E           E4                     71    in al, 0x0071
36072 E140           A3         0410              mov 0x0410, ax
36073                                             ;; Parallel setup
36074 E143           31C0                         xor ax, ax
36075 E145           8ED8                         mov ds, ax
36076 E147           31DB                         xor bx, bx
36077 E149           B1                     14    mov cl, #0x14 ; timeout value
36078 E14B           BA                   0378    mov dx, #0x378 ; Parallel I/O address, port 1
36079 E14E           E8         BCE6              call detect_parport
36080 E151           BA                   0278    mov dx, #0x278 ; Parallel I/O address, port 2
36081 E154           E8         BCE0              call detect_parport
36082 E157           C1E3                   0E    shl bx, #0x0e
36083 E15A           A1         0410              mov ax, 0x410 ; Equipment word bits 14..15 determine # parallel ports
36084 E15D           25                   3FFF    and ax, #0x3fff
36085 E160           09D8                         or ax, bx ; set number of parallel ports
36086 E162           A3         0410              mov 0x410, ax
36087                                             ;; Serial setup
36088                                             SET_INT_VECTOR(0x14, #0xF000, #int14_handler)
 +a   E165           B8                   E739    mov ax,  #int14_handler
 +a   E168           A3         0050              mov 0x14*4, ax
 +a   E16B           B8                   F000    mov ax,  #0xF000
 +a   E16E           A3         0052              mov 0x14*4+2, ax
36089 E171           31DB                         xor bx, bx
36090 E173           B1                     0A    mov cl, #0x0a ; timeout value
36091 E175           BA                   03F8    mov dx, #0x03f8 ; Serial I/O address, port 1
36092 E178           E8         BCDB              call detect_serial
36093 E17B           BA                   02F8    mov dx, #0x02f8 ; Serial I/O address, port 2
36094 E17E           E8         BCD5              call detect_serial
36095 E181           BA                   03E8    mov dx, #0x03e8 ; Serial I/O address, port 3
36096 E184           E8         BCCF              call detect_serial
36097 E187           BA                   02E8    mov dx, #0x02e8 ; Serial I/O address, port 4
36098 E18A           E8         BCC9              call detect_serial
36099 E18D           C1E3                   09    shl bx, #0x09
36100 E190           A1         0410              mov ax, 0x410 ; Equipment word bits 9..11 determine # serial ports
36101 E193           25                   F1FF    and ax, #0xf1ff
36102 E196           09D8                         or ax, bx ; set number of serial port
36103 E198           A3         0410              mov 0x410, ax
36104                                             ;; CMOS RTC
36105                                             SET_INT_VECTOR(0x1A, #0xF000, #int1a_handler)
 +a   E19B           B8                   FE6E    mov ax,  #int1a_handler
 +a   E19E           A3         0068              mov 0x1A*4, ax
 +a   E1A1           B8                   F000    mov ax,  #0xF000
 +a   E1A4           A3         006A              mov 0x1A*4+2, ax
36106                                             SET_INT_VECTOR(0x4A, #0xF000, #dummy_iret_handler)
 +a   E1A7           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E1AA           A3         0128              mov 0x4A*4, ax
 +a   E1AD           B8                   F000    mov ax,  #0xF000
 +a   E1B0           A3         012A              mov 0x4A*4+2, ax
36107                                             SET_INT_VECTOR(0x70, #0xF000, #int70_handler)
 +a   E1B3           B8                   FE93    mov ax,  #int70_handler
 +a   E1B6           A3         01C0              mov 0x70*4, ax
 +a   E1B9           B8                   F000    mov ax,  #0xF000
 +a   E1BC           A3         01C2              mov 0x70*4+2, ax
36108                                             ;; BIOS DATA AREA 0x4CE ???
36109 E1BF           E8         B42F              call timer_tick_post
36110                                             ;; IRQ9 (IRQ2 redirect) setup
36111                                             SET_INT_VECTOR(0x71, #0xF000, #int71_handler)
 +a   E1C2           B8                   E9DD    mov ax,  #int71_handler
 +a   E1C5           A3         01C4              mov 0x71*4, ax
 +a   E1C8           B8                   F000    mov ax,  #0xF000
 +a   E1CB           A3         01C6              mov 0x71*4+2, ax
36112                                             ;; PS/2 mouse setup
36113                                             SET_INT_VECTOR(0x74, #0xF000, #int74_handler)
 +a   E1CE           B8                   91B0    mov ax,  #int74_handler
 +a   E1D1           A3         01D0              mov 0x74*4, ax
 +a   E1D4           B8                   F000    mov ax,  #0xF000
 +a   E1D7           A3         01D2              mov 0x74*4+2, ax
36114                                             ;; IRQ13 (FPU exception) setup
36115                                             SET_INT_VECTOR(0x75, #0xF000, #int75_handler)
 +a   E1DA           B8                   E2C7    mov ax,  #int75_handler
 +a   E1DD           A3         01D4              mov 0x75*4, ax
 +a   E1E0           B8                   F000    mov ax,  #0xF000
 +a   E1E3           A3         01D6              mov 0x75*4+2, ax
36116                                             ;; Video setup
36117                                             SET_INT_VECTOR(0x10, #0xF000, #int10_handler)
 +a   E1E6           B8                   F065    mov ax,  #int10_handler
 +a   E1E9           A3         0040              mov 0x10*4, ax
 +a   E1EC           B8                   F000    mov ax,  #0xF000
 +a   E1EF           A3         0042              mov 0x10*4+2, ax
36118                                             ;; PIC
36119 E1F2           E8         BDF5              call post_init_pic
36120 E1F5           E8         BB68              call rombios32_init
36121 E1F8           B9                   C000    mov cx, #0xc000 ;; init vga bios
36122 E1FB           B8                   C780    mov ax, #0xc780
36123 E1FE           E8         BD28              call rom_scan
36124                                             ;; Hack fix: SeaVGABIOS does not setup a video mode
36125 E201           BA                   03D4    mov dx, #0x03d4
36126 E204           B0                     00    mov al, #0x00
36127 E206           EE                           out dx, al
36128 E207           42                           inc dx
36129 E208           EC                           in al, dx
36130 E209           84C0                         test al, al
36131 E20B           75           05              jnz vga_init_ok
36132 E20D           B8                   0003    mov ax, #0x0003
36133 E210           CD                     10    int #0x10
36134                       0000E212            vga_init_ok:
36135 E212           E8         2FD3              call _print_bios_banner
36136                                             ;;
36137                                             ;; Floppy setup
36138                                             ;;
36139 E215           E8         B0A2              call floppy_drive_post
36140                                             ;;
36141                                             ;; Hard Drive setup
36142                                             ;;
36143 E218           E8         B126              call hard_drive_post
36144                                             ;;
36145                                             ;; ATA/ATAPI driver setup
36146                                             ;;
36147 E21B           E8         3633              call _ata_init
36148 E21E           E8         3972              call _ata_detect
36149                                             ;;
36150                                             ;;
36151                                             ;; eltorito floppy/harddisk emulation from cd
36152                                             ;;
36153 E221           E8         5323              call _cdemu_init
36154                                             ;;
36155 E224           E8         301A              call _init_boot_vectors
36156 E227           B9                   C800    mov cx, #0xc800 ;; init option roms
36157 E22A           B8                   E000    mov ax, #0xe000
36158 E22D           E8         BCF9              call rom_scan
36159 E230           E8         318A              call _interactive_bootkey
36160 E233           FB                           sti ;; enable interrupts
36161 E234           CD                     19    int #0x19
36162 E2C3                                      .org 0xe2c3 ; NMI Handler Entry Point
36163                       0000E2C3            nmi:
36164                                             ;; FIXME the NMI handler should not panic
36165                                             ;; but iret when called from int75 (fpu exception)
36166 E2C3           E8         3438              call _nmi_handler_msg
36167 E2C6           CF                           iret
36168                       0000E2C7            int75_handler:
36169 E2C7           E6                     F0    out 0xf0, al
36170 E2C9           E8         B30D              call eoi_both_pics
36171 E2CC           CD                     02    int 2
36172 E2CE           CF                           iret
36173                                           ;-------------------------------------------
36174                                           ;- INT 13h Fixed Disk Services Entry Point -
36175                                           ;-------------------------------------------
36176 E3FE                                      .org 0xe3fe ; INT 13h Fixed Disk Services Entry Point
36177                       0000E3FE            int13_handler:
36178 E3FE           E9         ADEC              jmp int13_relocated
36179 E401                                      .org 0xe401 ; Fixed Disk Parameter Table
36180                                           ;----------
36181                                           ;- INT19h -
36182                                           ;----------
36183 E6F2                                      .org 0xe6f2 ; INT 19h Boot Load Service Entry Point
36184                       0000E6F2            int19_handler:
36185 E6F2           E9         ABA9              jmp int19_relocated
36186                                           ;-------------------------------------------
36187                                           ;- System BIOS Configuration Data Table
36188                                           ;-------------------------------------------
36189 E6F5                                      .org 0xe6f5
36190 E6F5                        08            db 0x08 ; Table size (bytes) -Lo
36191 E6F6                        00            db 0x00 ; Table size (bytes) -Hi
36192 E6F7                        FC            db 0xFC
36193 E6F8                        00            db 0x00
36194 E6F9                        01            db 1
36195                                           ; Feature byte 1
36196                                           ; b7: 1=DMA channel 3 used by hard disk
36197                                           ; b6: 1=2 interrupt controllers present
36198                                           ; b5: 1=RTC present
36199                                           ; b4: 1=BIOS calls int 15h/4Fh every key
36200                                           ; b3: 1=wait for extern event supported (Int 15h/41h)
36201                                           ; b2: 1=extended BIOS data area used
36202                                           ; b1: 0=AT or ESDI bus, 1=MicroChannel
36203                                           ; b0: 1=Dual bus (MicroChannel + ISA)
36204 E6FA                        74            db (0 << 7) | (1 << 6) | (1 << 5) | (1 << 4) | (0 << 3) | (1 << 2) | (0 << 1) | (0 << 0)
36205                                           ; Feature byte 2
36206                                           ; b7: 1=32-bit DMA supported
36207                                           ; b6: 1=int16h, function 9 supported
36208                                           ; b5: 1=int15h/C6h (get POS data) supported
36209                                           ; b4: 1=int15h/C7h (get mem map info) supported
36210                                           ; b3: 1=int15h/C8h (en/dis CPU) supported
36211                                           ; b2: 1=non-8042 kb controller
36212                                           ; b1: 1=data streaming supported
36213                                           ; b0: reserved
36214 E6FB                        40            db (0 << 7) | (1 << 6) | (0 << 5) | (0 << 4) | (0 << 3) | (0 << 2) | (0 << 1) | (0 << 0)
36215                                           ; Feature byte 3
36216                                           ; b7: not used
36217                                           ; b6: reserved
36218                                           ; b5: reserved
36219                                           ; b4: POST supports ROM-to-RAM enable/disable
36220                                           ; b3: SCSI on system board
36221                                           ; b2: info panel installed
36222                                           ; b1: Initial Machine Load (IML) system - BIOS on disk
36223                                           ; b0: SCSI supported in IML
36224 E6FC                        00            db 0x00
36225                                           ; Feature byte 4
36226                                           ; b7: IBM private
36227                                           ; b6: EEPROM present
36228                                           ; b5-3: ABIOS presence (011 = not supported)
36229                                           ; b2: private
36230                                           ; b1: memory split above 16Mb supported
36231                                           ; b0: POSTEXT directly supported by POST
36232 E6FD                        00            db 0x00
36233                                           ; Feature byte 5 (IBM)
36234                                           ; b1: enhanced mouse
36235                                           ; b0: flash EPROM
36236 E6FE                        00            db 0x00
36237 E729                                      .org 0xe729 ; Baud Rate Generator Table
36238                                           ;----------
36239                                           ;- INT14h -
36240                                           ;----------
36241 E739                                      .org 0xe739 ; INT 14h Serial Communications Service Entry Point
36242                       0000E739            int14_handler:
36243 E739           1E                           push ds
36244 E73A           60                           pusha
36245 E73B           31C0                         xor ax, ax
36246 E73D           8ED8                         mov ds, ax
36247 E73F           E8         5359              call _int14_function
36248 E742           61                           popa
36249 E743           1F                           pop ds
36250 E744           CF                           iret
36251                                           ;----------------------------------------
36252                                           ;- INT 16h Keyboard Service Entry Point -
36253                                           ;----------------------------------------
36254 E82E                                      .org 0xe82e
36255                       0000E82E            int16_handler:
36256 E82E           FB                           sti
36257 E82F           1E                           push ds
36258 E830           9C                           pushf
36259 E831           60                           pusha
36260 E832           6A                     40    push #0x40
36261 E834           1F                           pop ds
36262 E835           80FC                   00    cmp ah, #0x00
36263 E838           74           1F              je int16_F00
36264 E83A           80FC                   10    cmp ah, #0x10
36265 E83D           74           1A              je int16_F00
36266 E83F           E8         6558              call _int16_function
36267 E842           61                           popa
36268 E843           9D                           popf
36269 E844           1F                           pop ds
36270 E845           74           09              jz int16_zero_set
36271                       0000E847            int16_zero_clear:
36272 E847           55                           push bp
36273 E848           89E5                         mov bp, sp
36274 E84A           8066         06        BF    and BYTE [bp + 0x06], #0xbf
36275 E84E           5D                           pop bp
36276 E84F           CF                           iret
36277                       0000E850            int16_zero_set:
36278 E850           55                           push bp
36279 E851           89E5                         mov bp, sp
36280 E853           804E         06        40    or BYTE [bp + 0x06], #0x40
36281 E857           5D                           pop bp
36282 E858           CF                           iret
36283                       0000E859            int16_F00:
36284 E859           FA                           cli
36285 E85A           A1         001A              mov ax, 0x001a
36286 E85D           3B06       001C              cmp ax, 0x001c
36287 E861           75           13              jne int16_key_found
36288 E863           FB                           sti
36289                                             ;; no key yet, call int 15h, function AX=9002
36290 E864           B8                   9002    mov ax, #0x9002
36291 E867           CD                     15    int #0x15
36292                       0000E869            int16_wait_for_key:
36293 E869           FA                           cli
36294 E86A           A1         001A              mov ax, 0x001a
36295 E86D           3B06       001C              cmp ax, 0x001c
36296 E871           75           03              jne int16_key_found
36297 E873           FB                           sti
36298 E874           EB           F3              jmp int16_wait_for_key
36299                       0000E876            int16_key_found:
36300 E876           E8         6521              call _int16_function
36301 E879           61                           popa
36302 E87A           9D                           popf
36303 E87B           1F                           pop ds
36304 E87C           CF                           iret
36305                                           ;-------------------------------------------------
36306                                           ;- INT09h : Keyboard Hardware Service Entry Point -
36307                                           ;-------------------------------------------------
36308 E987                                      .org 0xe987
36309                       0000E987            int09_handler:
36310 E987           FA                           cli
36311 E988           50                           push ax
36312 E989           B0                     AD    mov al, #0xAD ;;disable keyboard
36313 E98B           E6                     64    out 0x0064, al
36314 E98D           B0                     0B    mov al, #0x0B
36315 E98F           E6                     20    out 0x0020, al
36316 E991           E4                     20    in al, 0x0020
36317 E993           24                     02    and al, #0x02
36318 E995           74           40              jz int09_finish
36319 E997           E4                     60    in al, 0x0060 ;;read key from keyboard controller
36320 E999           FB                           sti
36321 E99A           1E                           push ds
36322 E99B           60                           pusha
36323 E99C           B4                     4F    mov ah, #0x4f ;; allow for keyboard intercept
36324 E99E           F9                           stc
36325 E99F           CD                     15    int #0x15
36326 E9A1           55                           push bp
36327 E9A2           89E5                         mov bp, sp
36328 E9A4           8846         10              mov [bp + 0x10], al
36329 E9A7           5D                           pop bp
36330 E9A8           73           22              jnc int09_done
36331                                             ;; check for extended key
36332 E9AA           6A                     40    push #0x40
36333 E9AC           1F                           pop ds
36334 E9AD           3C                     E0    cmp al, #0xe0
36335 E9AF           75           0A              jne int09_check_pause
36336 E9B1           A0         0096              mov al, BYTE [0x96] ;; mf2_state |= 0x02
36337 E9B4           0C                     02    or al, #0x02
36338 E9B6           A2         0096              mov BYTE [0x96], al
36339 E9B9           EB           11              jmp int09_done
36340                       0000E9BB            int09_check_pause: ;; check for pause key
36341 E9BB           3C                     E1    cmp al, #0xe1
36342 E9BD           75           0A              jne int09_process_key
36343 E9BF           A0         0096              mov al, BYTE [0x96] ;; mf2_state |= 0x01
36344 E9C2           0C                     01    or al, #0x01
36345 E9C4           A2         0096              mov BYTE [0x96], al
36346 E9C7           EB           03              jmp int09_done
36347                       0000E9C9            int09_process_key:
36348 E9C9           E8         6A4B              call _int09_function
36349                       0000E9CC            int09_done:
36350 E9CC           61                           popa
36351 E9CD           1F                           pop ds
36352 E9CE           FA                           cli
36353 E9CF           E8         AC0B              call eoi_master_pic
36354                                             ;; Notify keyboard interrupt complete w/ int 15h, function AX=9102
36355 E9D2           B8                   9102    mov ax, #0x9102
36356 E9D5           CD                     15    int #0x15
36357                       0000E9D7            int09_finish:
36358 E9D7           B0                     AE    mov al, #0xAE ;;enable keyboard
36359 E9D9           E6                     64    out 0x0064, al
36360 E9DB           58                           pop ax
36361 E9DC           CF                           iret
36362                                           ; IRQ9 handler(Redirect to IRQ2)
36363                                           ;--------------------
36364                       0000E9DD            int71_handler:
36365 E9DD           50                           push ax
36366 E9DE           B0                     20    mov al, #0x20
36367 E9E0           E6                     A0    out 0x00a0, al ;; slave PIC EOI
36368 E9E2           58                           pop ax
36369 E9E3           CD                     0A    int #0x0A
36370 E9E5           CF                           iret
36371                                           ;--------------------
36372                       0000E9E6            dummy_master_pic_irq_handler:
36373 E9E6           50                           push ax
36374 E9E7           E8         ABF3              call eoi_master_pic
36375 E9EA           58                           pop ax
36376 E9EB           CF                           iret
36377                                           ;--------------------
36378                       0000E9EC            dummy_slave_pic_irq_handler:
36379 E9EC           50                           push ax
36380 E9ED           E8         ABE9              call eoi_both_pics
36381 E9F0           58                           pop ax
36382 E9F1           CF                           iret
36383                                           ;----------------------------------------
36384                                           ;- INT 13h Diskette Service Entry Point -
36385                                           ;----------------------------------------
36386 EC59                                      .org 0xec59
36387                       0000EC59            int13_diskette:
36388 EC59           E9         A5E4              jmp int13_noeltorito
36389                                           ;---------------------------------------------
36390                                           ;- INT 0Eh Diskette Hardware ISR Entry Point -
36391                                           ;---------------------------------------------
36392 EF57                                      .org 0xef57 ; INT 0Eh Diskette Hardware ISR Entry Point
36393                       0000EF57            int0e_handler:
36394 EF57           50                           push ax
36395 EF58           52                           push dx
36396 EF59           BA                   03F4    mov dx, #0x03f4
36397 EF5C           EC                           in al, dx
36398 EF5D           24                     C0    and al, #0xc0
36399 EF5F           3C                     C0    cmp al, #0xc0
36400 EF61           74           1E              je int0e_normal
36401 EF63           BA                   03F5    mov dx, #0x03f5
36402 EF66           B0                     08    mov al, #0x08 ; sense interrupt status
36403 EF68           EE                           out dx, al
36404                       0000EF69            int0e_loop1:
36405 EF69           BA                   03F4    mov dx, #0x03f4
36406 EF6C           EC                           in al, dx
36407 EF6D           24                     C0    and al, #0xc0
36408 EF6F           3C                     C0    cmp al, #0xc0
36409 EF71           75           F6              jne int0e_loop1
36410                       0000EF73            int0e_loop2:
36411 EF73           BA                   03F5    mov dx, #0x03f5
36412 EF76           EC                           in al, dx
36413 EF77           BA                   03F4    mov dx, #0x03f4
36414 EF7A           EC                           in al, dx
36415 EF7B           24                     C0    and al, #0xc0
36416 EF7D           3C                     C0    cmp al, #0xc0
36417 EF7F           74           F2              je int0e_loop2
36418                       0000EF81            int0e_normal:
36419 EF81           1E                           push ds
36420 EF82           31C0                         xor ax, ax ;; segment 0000
36421 EF84           8ED8                         mov ds, ax
36422 EF86           E8         A654              call eoi_master_pic
36423 EF89           A0         043E              mov al, 0x043e
36424 EF8C           0C                     80    or al, #0x80 ;; diskette interrupt has occurred
36425 EF8E           A2         043E              mov 0x043e, al
36426 EF91           1F                           pop ds
36427                                             ;; Notify diskette interrupt complete w/ int 15h, function AX=9101
36428 EF92           B8                   9101    mov ax, #0x9101
36429 EF95           CD                     15    int #0x15
36430 EF97           5A                           pop dx
36431 EF98           58                           pop ax
36432 EF99           CF                           iret
36433 EFC7                                      .org 0xefc7 ; Diskette Controller Parameter Table
36434                       0000EFC7            diskette_param_table:
36435                                           ;; Since no provisions are made for multiple drive types, most
36436                                           ;; values in this table are ignored. I set parameters for 1.44M
36437                                           ;; floppy here
36438 EFC7                        AF            db 0xAF
36439 EFC8                        02            db 0x02 ;; head load time 0000001, DMA used
36440 EFC9                        25            db 0x25
36441 EFCA                        02            db 0x02
36442 EFCB                        12            db 18
36443 EFCC                        1B            db 0x1B
36444 EFCD                        FF            db 0xFF
36445 EFCE                        6C            db 0x6C
36446 EFCF                        F6            db 0xF6
36447 EFD0                        0F            db 0x0F
36448 EFD1                        08            db 0x08
36449                                           ;----------------------------------------
36450                                           ;- INT17h : Printer Service Entry Point -
36451                                           ;----------------------------------------
36452 EFD2                                      .org 0xefd2
36453                       0000EFD2            int17_handler:
36454 EFD2           1E                           push ds
36455 EFD3           60                           pusha
36456 EFD4           31C0                         xor ax, ax
36457 EFD6           8ED8                         mov ds, ax
36458 EFD8           E8         96B0              call _int17_function
36459 EFDB           61                           popa
36460 EFDC           1F                           pop ds
36461 EFDD           CF                           iret
36462                       0000EFDE            diskette_param_table2:
36463                                           ;; New diskette parameter table adding 3 parameters from IBM
36464                                           ;; Since no provisions are made for multiple drive types, most
36465                                           ;; values in this table are ignored. I set parameters for 1.44M
36466                                           ;; floppy here
36467 EFDE                        AF            db 0xAF
36468 EFDF                        02            db 0x02 ;; head load time 0000001, DMA used
36469 EFE0                        25            db 0x25
36470 EFE1                        02            db 0x02
36471 EFE2                        12            db 18
36472 EFE3                        1B            db 0x1B
36473 EFE4                        FF            db 0xFF
36474 EFE5                        6C            db 0x6C
36475 EFE6                        F6            db 0xF6
36476 EFE7                        0F            db 0x0F
36477 EFE8                        08            db 0x08
36478 EFE9                        4F            db 79 ;; maximum track
36479 EFEA                        00            db 0 ;; data transfer rate
36480 EFEB                        04            db 4 ;; drive type in cmos
36481 F045                                      .org 0xf045 ; INT 10 Functions 0-Fh Entry Point
36482                                             HALT(11645)
 +a   F045           BA                   0400    mov dx,#0x400
 +a   F048           B8                   2D7D    mov ax,#11645
 +a   F04B           EF                           out dx,ax
36483 F04C           CF                           iret
36484                                           ;----------
36485                                           ;- INT10h -
36486                                           ;----------
36487 F065                                      .org 0xf065 ; INT 10h Video Support Service Entry Point
36488                       0000F065            int10_handler:
36489                                             ;; dont do anything, since the VGA BIOS handles int10h requests
36490 F065           CF                           iret
36491 F0A4                                      .org 0xf0a4 ; MDA/CGA Video Parameter Table (INT 1Dh)
36492                                           ;----------
36493                                           ;- INT12h -
36494                                           ;----------
36495 F841                                      .org 0xf841 ; INT 12h Memory Size Service Entry Point
36496                                           ; ??? different for Pentium (machine check)?
36497                       0000F841            int12_handler:
36498 F841           1E                           push ds
36499 F842           B8                   0040    mov ax, #0x0040
36500 F845           8ED8                         mov ds, ax
36501 F847           A1         0013              mov ax, 0x0013
36502 F84A           1F                           pop ds
36503 F84B           CF                           iret
36504                                           ;----------
36505                                           ;- INT11h -
36506                                           ;----------
36507 F84D                                      .org 0xf84d ; INT 11h Equipment List Service Entry Point
36508                       0000F84D            int11_handler:
36509 F84D           1E                           push ds
36510 F84E           B8                   0040    mov ax, #0x0040
36511 F851           8ED8                         mov ds, ax
36512 F853           A1         0010              mov ax, 0x0010
36513 F856           1F                           pop ds
36514 F857           CF                           iret
36515                                           ;----------
36516                                           ;- INT15h -
36517                                           ;----------
36518 F859                                      .org 0xf859 ; INT 15h System Services Entry Point
36519                       0000F859            int15_handler:
36520 F859           80FC                   80    cmp ah, #0x80 ; Device open
36521 F85C           74           39              je int15_stub
36522 F85E           80FC                   81    cmp ah, #0x81 ; Device close
36523 F861           74           34              je int15_stub
36524 F863           80FC                   82    cmp ah, #0x82 ; Program termination
36525 F866           74           2F              je int15_stub
36526 F868           80FC                   90    cmp ah, #0x90 ; Device busy interrupt. Called by Int 16h when no key available
36527 F86B           74           2A              je int15_stub
36528 F86D           80FC                   91    cmp ah, #0x91 ; Interrupt complete. Called by IRQ handlers
36529 F870           74           25              je int15_stub
36530 F872           9C                           pushf
36531 F873           80FC                   53    cmp ah, #0x53
36532 F876           74           1C              je apm_call
36533 F878           1E                           push ds
36534 F879           06                           push es
36535 F87A           80FC                   86    cmp ah, #0x86
36536 F87D           74           23              je int15_handler32
36537 F87F           80FC                   E8    cmp ah, #0xE8
36538 F882           74           1E              je int15_handler32
36539 F884           60                           pusha
36540 F885           80FC                   C2    cmp ah, #0xC2
36541 F888           74           13              je int15_handler_mouse
36542 F88A           E8         443B              call _int15_function
36543                       0000F88D            int15_handler_mouse_ret:
36544 F88D           61                           popa
36545                       0000F88E            int15_handler32_ret:
36546 F88E           07                           pop es
36547 F88F           1F                           pop ds
36548 F890           9D                           popf
36549 F891           E9         9945              jmp iret_modify_cf
36550                       0000F894            apm_call:
36551 F894           E9         9FA3              jmp _apmreal_entry
36552                       0000F897            int15_stub:
36553 F897           30E4                         xor ah, ah ; "operation success"
36554 F899           F8                           clc
36555 F89A           E9         993C              jmp iret_modify_cf
36556                       0000F89D            int15_handler_mouse:
36557 F89D           E8         4912              call _int15_function_mouse
36558 F8A0           EB           EB              jmp int15_handler_mouse_ret
36559                       0000F8A2            int15_handler32:
36560 F8A2     66    60                           pushad
36561 F8A4           E8         502E              call _int15_function32
36562 F8A7     66    61                           popad
36563 F8A9           EB           E3              jmp int15_handler32_ret
36564                                           ;; Protected mode IDT descriptor
36565                                           ;;
36566                                           ;; I just make the limit 0, so the machine will shutdown
36567                                           ;; if an exception occurs during protected mode memory
36568                                           ;; transfers.
36569                                           ;;
36570                                           ;; Set base to f0000 to correspond to beginning of BIOS,
36571                                           ;; in case I actually define an IDT later
36572                                           ;; Set limit to 0
36573                       0000F8AB            pmode_IDT_info:
36574 F8AB                      0000            dw 0x0000 ;; limit 15:00
36575 F8AD                      0000            dw 0x0000 ;; base 15:00
36576 F8AF                        0F            db 0x0f ;; base 23:16
36577 F8B0                        00            db 0x00 ;; base 31:24
36578                                           ;; Real mode IDT descriptor
36579                                           ;;
36580                                           ;; Set to typical real-mode values.
36581                                           ;; base = 000000
36582                                           ;; limit = 03ff
36583                       0000F8B1            rmode_IDT_info:
36584 F8B1                      03FF            dw 0x03ff ;; limit 15:00
36585 F8B3                      0000            dw 0x0000 ;; base 15:00
36586 F8B5                        00            db 0x00 ;; base 23:16
36587 F8B6                        00            db 0x00 ;; base 31:24
36588                                           ;----------
36589                                           ;- INT1Ah -
36590                                           ;----------
36591 FE6E                                      .org 0xfe6e ; INT 1Ah Time-of-day Service Entry Point
36592                       0000FE6E            int1a_handler:
36593 FE6E           80FC                   B1    cmp ah, #0xb1
36594 FE71           75           14              jne int1a_normal
36595 FE73           E8         9C97              call pcibios_real
36596 FE76           72           03              jc pcibios_error
36597 FE78           CA                   0002    retf 2
36598                       0000FE7B            pcibios_error:
36599 FE7B           88E3                         mov bl, ah
36600 FE7D           B4                     B1    mov ah, #0xb1
36601 FE7F           1E                           push ds
36602 FE80           60                           pusha
36603 FE81           8CD0                         mov ax, ss ; set readable descriptor to ds, for calling pcibios
36604 FE83           8ED8                         mov ds, ax ; on 16bit protected mode.
36605 FE85           EB           06              jmp int1a_callfunction
36606                       0000FE87            int1a_normal:
36607 FE87           1E                           push ds
36608 FE88           60                           pusha
36609 FE89           31C0                         xor ax, ax
36610 FE8B           8ED8                         mov ds, ax
36611                       0000FE8D            int1a_callfunction:
36612 FE8D           E8         8B5E              call _int1a_function
36613 FE90           61                           popa
36614 FE91           1F                           pop ds
36615 FE92           CF                           iret
36616                                           ;;
36617                                           ;; int70h: IRQ8 - CMOS RTC
36618                                           ;;
36619                       0000FE93            int70_handler:
36620 FE93           1E                           push ds
36621 FE94     66    60                           pushad
36622 FE96           31C0                         xor ax, ax
36623 FE98           8ED8                         mov ds, ax
36624 FE9A           E8         9228              call _int70_function
36625 FE9D     66    61                           popad
36626 FE9F           1F                           pop ds
36627 FEA0           CF                           iret
36628                                           ;---------
36629                                           ;- INT08 -
36630                                           ;---------
36631 FEA5                                      .org 0xfea5 ; INT 08h System Timer ISR Entry Point
36632                       0000FEA5            int08_handler:
36633 FEA5           FB                           sti
36634 FEA6     66    50                           push eax
36635 FEA8           1E                           push ds
36636 FEA9           31C0                         xor ax, ax
36637 FEAB           8ED8                         mov ds, ax
36638                                             ;; time to turn off drive(s)?
36639 FEAD           A0         0440              mov al,0x0440
36640 FEB0           08C0                         or al,al
36641 FEB2           74           10              jz int08_floppy_off
36642 FEB4           FEC8                         dec al
36643 FEB6           A2         0440              mov 0x0440,al
36644 FEB9           75           09              jnz int08_floppy_off
36645                                             ;; turn motor(s) off
36646 FEBB           52                           push dx
36647 FEBC           BA                   03F2    mov dx,#0x03f2
36648 FEBF           EC                           in al,dx
36649 FEC0           24                     CF    and al,#0xcf
36650 FEC2           EE                           out dx,al
36651 FEC3           5A                           pop dx
36652                       0000FEC4            int08_floppy_off:
36653 FEC4     66    A1         046C              mov eax, 0x046c ;; get ticks dword
36654 FEC8     66    40                           inc eax
36655                                             ;; compare eax to one days worth of timer ticks at 18.2 hz
36656 FECA     66    3D               001800B0    cmp eax, #0x001800B0
36657 FED0           72           07              jb int08_store_ticks
36658                                             ;; there has been a midnight rollover at this point
36659 FED2     66    31C0                         xor eax, eax ;; zero out counter
36660 FED5           FE06       0470              inc BYTE 0x0470 ;; increment rollover flag
36661                       0000FED9            int08_store_ticks:
36662 FED9     66    A3         046C              mov 0x046c, eax ;; store new ticks dword
36663                                             ;; chain to user timer tick INT #0x1c
36664 FEDD           CD                     1C    int #0x1c
36665 FEDF           FA                           cli
36666 FEE0           E8         96FA              call eoi_master_pic
36667 FEE3           1F                           pop ds
36668 FEE4     66    58                           pop eax
36669 FEE6           CF                           iret
36670 FEF3                                      .org 0xfef3 ; Initial Interrupt Vector Offsets Loaded by POST
36671                       0000FEF3            initial_int_vector_offset_08_1f:
36672 FEF3                      FEA5              dw int08_handler
36673 FEF5                      E987              dw int09_handler
36674 FEF7                      E9E6              dw dummy_master_pic_irq_handler
36675 FEF9                      E9E6              dw dummy_master_pic_irq_handler
36676 FEFB                      E9E6              dw dummy_master_pic_irq_handler
36677 FEFD                      E9E6              dw dummy_master_pic_irq_handler
36678 FEFF                      EF57              dw int0e_handler
36679 FF01                      E9E6              dw dummy_master_pic_irq_handler
36680 FF03                      F065              dw int10_handler
36681 FF05                      F84D              dw int11_handler
36682 FF07                      F841              dw int12_handler
36683 FF09                      E3FE              dw int13_handler
36684 FF0B                      E739              dw int14_handler
36685 FF0D                      F859              dw int15_handler
36686 FF0F                      E82E              dw int16_handler
36687 FF11                      EFD2              dw int17_handler
36688 FF13                      9282              dw int18_handler
36689 FF15                      E6F2              dw int19_handler
36690 FF17                      FE6E              dw int1a_handler
36691 FF19                      FF53              dw dummy_iret_handler
36692 FF1B                      FF53              dw dummy_iret_handler
36693 FF1D                      0000              dw 0
36694 FF1F                      EFDE              dw diskette_param_table2
36695 FF21                      0000              dw 0
36696                                           ;------------------------------------------------
36697                                           ;- IRET Instruction for Dummy Interrupt Handler -
36698                                           ;------------------------------------------------
36699 FF53                                      .org 0xff53 ; IRET Instruction for Dummy Interrupt Handler
36700                       0000FF53            dummy_iret_handler:
36701 FF53           CF                           iret
36702 FF54                                      .org 0xff54 ; INT 05h Print Screen Service Entry Point
36703                                             HALT(11900)
 +a   FF54           BA                   0400    mov dx,#0x400
 +a   FF57           B8                   2E7C    mov ax,#11900
 +a   FF5A           EF                           out dx,ax
36704 FF5B           CF                           iret
36705 FFF0                                      .org 0xfff0 ; Power-up Entry Point
36706 FFF0           EA         E05B      F000    jmp 0xf000:post
36707 FFF5                                      .org 0xfff5 ; ASCII Date ROM was built - 8 characters in MM/DD/YY
36708 FFF5                        30            .ascii "08/01/21"
36709 FFFE                                      .org 0xfffe ; System Model ID
36710 FFFE                        FC            db 0xFC
36711 FFFF                        00            db 0x00 ; filler
36712 FA6E                                      .org 0xfa6e ;; Character Font for 320x200 & 640x200 Graphics (lower 128 characters)
36713                                           ! 8515 endasm
36714                                           !BCC_ENDASM
36715                                           ! 8516 static Bit8u vgafont8[128
36716                                           ! Register BX used in function int70_function
36717                                           ! 8516 *8]=
36718                                           ! 8517 {
36719                                           
36720                       0000FA6E            _vgafont8:
36721                                           ! 8518  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
36722 FA6E                        00            .byte	0
36723 FA6F                        00            .byte	0
36724 FA70                        00            .byte	0
36725 FA71                        00            .byte	0
36726 FA72                        00            .byte	0
36727 FA73                        00            .byte	0
36728 FA74                        00            .byte	0
36729 FA75                        00            .byte	0
36730                                           ! 8519  0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,
36731 FA76                        7E            .byte	$7E
36732 FA77                        81            .byte	$81
36733 FA78                        A5            .byte	$A5
36734 FA79                        81            .byte	$81
36735 FA7A                        BD            .byte	$BD
36736 FA7B                        99            .byte	$99
36737 FA7C                        81            .byte	$81
36738 FA7D                        7E            .byte	$7E
36739                                           ! 8520  0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,
36740 FA7E                        7E            .byte	$7E
36741 FA7F                        FF            .byte	$FF
36742 FA80                        DB            .byte	$DB
36743 FA81                        FF            .byte	$FF
36744 FA82                        C3            .byte	$C3
36745 FA83                        E7            .byte	$E7
36746 FA84                        FF            .byte	$FF
36747 FA85                        7E            .byte	$7E
36748                                           ! 8521  0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
36749 FA86                        6C            .byte	$6C
36750 FA87                        FE            .byte	$FE
36751 FA88                        FE            .byte	$FE
36752 FA89                        FE            .byte	$FE
36753 FA8A                        7C            .byte	$7C
36754 FA8B                        38            .byte	$38
36755 FA8C                        10            .byte	$10
36756 FA8D                        00            .byte	0
36757                                           ! 8522  0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
36758 FA8E                        10            .byte	$10
36759 FA8F                        38            .byte	$38
36760 FA90                        7C            .byte	$7C
36761 FA91                        FE            .byte	$FE
36762 FA92                        7C            .byte	$7C
36763 FA93                        38            .byte	$38
36764 FA94                        10            .byte	$10
36765 FA95                        00            .byte	0
36766                                           ! 8523  0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,
36767 FA96                        38            .byte	$38
36768 FA97                        7C            .byte	$7C
36769 FA98                        38            .byte	$38
36770 FA99                        FE            .byte	$FE
36771 FA9A                        FE            .byte	$FE
36772 FA9B                        7C            .byte	$7C
36773 FA9C                        38            .byte	$38
36774 FA9D                        7C            .byte	$7C
36775                                           ! 8524  0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,
36776 FA9E                        10            .byte	$10
36777 FA9F                        10            .byte	$10
36778 FAA0                        38            .byte	$38
36779 FAA1                        7C            .byte	$7C
36780 FAA2                        FE            .byte	$FE
36781 FAA3                        7C            .byte	$7C
36782 FAA4                        38            .byte	$38
36783 FAA5                        7C            .byte	$7C
36784                                           ! 8525  0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,
36785 FAA6                        00            .byte	0
36786 FAA7                        00            .byte	0
36787 FAA8                        18            .byte	$18
36788 FAA9                        3C            .byte	$3C
36789 FAAA                        3C            .byte	$3C
36790 FAAB                        18            .byte	$18
36791 FAAC                        00            .byte	0
36792 FAAD                        00            .byte	0
36793                                           ! 8526  0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,
36794 FAAE                        FF            .byte	$FF
36795 FAAF                        FF            .byte	$FF
36796 FAB0                        E7            .byte	$E7
36797 FAB1                        C3            .byte	$C3
36798 FAB2                        C3            .byte	$C3
36799 FAB3                        E7            .byte	$E7
36800 FAB4                        FF            .byte	$FF
36801 FAB5                        FF            .byte	$FF
36802                                           ! 8527  0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,
36803 FAB6                        00            .byte	0
36804 FAB7                        3C            .byte	$3C
36805 FAB8                        66            .byte	$66
36806 FAB9                        42            .byte	$42
36807 FABA                        42            .byte	$42
36808 FABB                        66            .byte	$66
36809 FABC                        3C            .byte	$3C
36810 FABD                        00            .byte	0
36811                                           ! 8528  0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,
36812 FABE                        FF            .byte	$FF
36813 FABF                        C3            .byte	$C3
36814 FAC0                        99            .byte	$99
36815 FAC1                        BD            .byte	$BD
36816 FAC2                        BD            .byte	$BD
36817 FAC3                        99            .byte	$99
36818 FAC4                        C3            .byte	$C3
36819 FAC5                        FF            .byte	$FF
36820                                           ! 8529  0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,
36821 FAC6                        0F            .byte	$F
36822 FAC7                        07            .byte	7
36823 FAC8                        0F            .byte	$F
36824 FAC9                        7D            .byte	$7D
36825 FACA                        CC            .byte	$CC
36826 FACB                        CC            .byte	$CC
36827 FACC                        CC            .byte	$CC
36828 FACD                        78            .byte	$78
36829                                           ! 8530  0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,
36830 FACE                        3C            .byte	$3C
36831 FACF                        66            .byte	$66
36832 FAD0                        66            .byte	$66
36833 FAD1                        66            .byte	$66
36834 FAD2                        3C            .byte	$3C
36835 FAD3                        18            .byte	$18
36836 FAD4                        7E            .byte	$7E
36837 FAD5                        18            .byte	$18
36838                                           ! 8531  0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,
36839 FAD6                        3F            .byte	$3F
36840 FAD7                        33            .byte	$33
36841 FAD8                        3F            .byte	$3F
36842 FAD9                        30            .byte	$30
36843 FADA                        30            .byte	$30
36844 FADB                        70            .byte	$70
36845 FADC                        F0            .byte	$F0
36846 FADD                        E0            .byte	$E0
36847                                           ! 8532  0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,
36848 FADE                        7F            .byte	$7F
36849 FADF                        63            .byte	$63
36850 FAE0                        7F            .byte	$7F
36851 FAE1                        63            .byte	$63
36852 FAE2                        63            .byte	$63
36853 FAE3                        67            .byte	$67
36854 FAE4                        E6            .byte	$E6
36855 FAE5                        C0            .byte	$C0
36856                                           ! 8533  0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,
36857 FAE6                        99            .byte	$99
36858 FAE7                        5A            .byte	$5A
36859 FAE8                        3C            .byte	$3C
36860 FAE9                        E7            .byte	$E7
36861 FAEA                        E7            .byte	$E7
36862 FAEB                        3C            .byte	$3C
36863 FAEC                        5A            .byte	$5A
36864 FAED                        99            .byte	$99
36865                                           ! 8534  0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00,
36866 FAEE                        80            .byte	$80
36867 FAEF                        E0            .byte	$E0
36868 FAF0                        F8            .byte	$F8
36869 FAF1                        FE            .byte	$FE
36870 FAF2                        F8            .byte	$F8
36871 FAF3                        E0            .byte	$E0
36872 FAF4                        80            .byte	$80
36873 FAF5                        00            .byte	0
36874                                           ! 8535  0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,
36875 FAF6                        02            .byte	2
36876 FAF7                        0E            .byte	$E
36877 FAF8                        3E            .byte	$3E
36878 FAF9                        FE            .byte	$FE
36879 FAFA                        3E            .byte	$3E
36880 FAFB                        0E            .byte	$E
36881 FAFC                        02            .byte	2
36882 FAFD                        00            .byte	0
36883                                           ! 8536  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,
36884 FAFE                        18            .byte	$18
36885 FAFF                        3C            .byte	$3C
36886 FB00                        7E            .byte	$7E
36887 FB01                        18            .byte	$18
36888 FB02                        18            .byte	$18
36889 FB03                        7E            .byte	$7E
36890 FB04                        3C            .byte	$3C
36891 FB05                        18            .byte	$18
36892                                           ! 8537  0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
36893 FB06                        66            .byte	$66
36894 FB07                        66            .byte	$66
36895 FB08                        66            .byte	$66
36896 FB09                        66            .byte	$66
36897 FB0A                        66            .byte	$66
36898 FB0B                        00            .byte	0
36899 FB0C                        66            .byte	$66
36900 FB0D                        00            .byte	0
36901                                           ! 8538  0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,
36902 FB0E                        7F            .byte	$7F
36903 FB0F                        DB            .byte	$DB
36904 FB10                        DB            .byte	$DB
36905 FB11                        7B            .byte	$7B
36906 FB12                        1B            .byte	$1B
36907 FB13                        1B            .byte	$1B
36908 FB14                        1B            .byte	$1B
36909 FB15                        00            .byte	0
36910                                           ! 8539  0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,
36911 FB16                        3E            .byte	$3E
36912 FB17                        63            .byte	$63
36913 FB18                        38            .byte	$38
36914 FB19                        6C            .byte	$6C
36915 FB1A                        6C            .byte	$6C
36916 FB1B                        38            .byte	$38
36917 FB1C                        CC            .byte	$CC
36918 FB1D                        78            .byte	$78
36919                                           ! 8540  0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,
36920 FB1E                        00            .byte	0
36921 FB1F                        00            .byte	0
36922 FB20                        00            .byte	0
36923 FB21                        00            .byte	0
36924 FB22                        7E            .byte	$7E
36925 FB23                        7E            .byte	$7E
36926 FB24                        7E            .byte	$7E
36927 FB25                        00            .byte	0
36928                                           ! 8541  0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,
36929 FB26                        18            .byte	$18
36930 FB27                        3C            .byte	$3C
36931 FB28                        7E            .byte	$7E
36932 FB29                        18            .byte	$18
36933 FB2A                        7E            .byte	$7E
36934 FB2B                        3C            .byte	$3C
36935 FB2C                        18            .byte	$18
36936 FB2D                        FF            .byte	$FF
36937                                           ! 8542  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,
36938 FB2E                        18            .byte	$18
36939 FB2F                        3C            .byte	$3C
36940 FB30                        7E            .byte	$7E
36941 FB31                        18            .byte	$18
36942 FB32                        18            .byte	$18
36943 FB33                        18            .byte	$18
36944 FB34                        18            .byte	$18
36945 FB35                        00            .byte	0
36946                                           ! 8543  0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
36947 FB36                        18            .byte	$18
36948 FB37                        18            .byte	$18
36949 FB38                        18            .byte	$18
36950 FB39                        18            .byte	$18
36951 FB3A                        7E            .byte	$7E
36952 FB3B                        3C            .byte	$3C
36953 FB3C                        18            .byte	$18
36954 FB3D                        00            .byte	0
36955                                           ! 8544  0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,
36956 FB3E                        00            .byte	0
36957 FB3F                        18            .byte	$18
36958 FB40                        0C            .byte	$C
36959 FB41                        FE            .byte	$FE
36960 FB42                        0C            .byte	$C
36961 FB43                        18            .byte	$18
36962 FB44                        00            .byte	0
36963 FB45                        00            .byte	0
36964                                           ! 8545  0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,
36965 FB46                        00            .byte	0
36966 FB47                        30            .byte	$30
36967 FB48                        60            .byte	$60
36968 FB49                        FE            .byte	$FE
36969 FB4A                        60            .byte	$60
36970 FB4B                        30            .byte	$30
36971 FB4C                        00            .byte	0
36972 FB4D                        00            .byte	0
36973                                           ! 8546  0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,
36974 FB4E                        00            .byte	0
36975 FB4F                        00            .byte	0
36976 FB50                        C0            .byte	$C0
36977 FB51                        C0            .byte	$C0
36978 FB52                        C0            .byte	$C0
36979 FB53                        FE            .byte	$FE
36980 FB54                        00            .byte	0
36981 FB55                        00            .byte	0
36982                                           ! 8547  0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,
36983 FB56                        00            .byte	0
36984 FB57                        24            .byte	$24
36985 FB58                        66            .byte	$66
36986 FB59                        FF            .byte	$FF
36987 FB5A                        66            .byte	$66
36988 FB5B                        24            .byte	$24
36989 FB5C                        00            .byte	0
36990 FB5D                        00            .byte	0
36991                                           ! 8548  0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,
36992 FB5E                        00            .byte	0
36993 FB5F                        18            .byte	$18
36994 FB60                        3C            .byte	$3C
36995 FB61                        7E            .byte	$7E
36996 FB62                        FF            .byte	$FF
36997 FB63                        FF            .byte	$FF
36998 FB64                        00            .byte	0
36999 FB65                        00            .byte	0
37000                                           ! 8549  0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,
37001 FB66                        00            .byte	0
37002 FB67                        FF            .byte	$FF
37003 FB68                        FF            .byte	$FF
37004 FB69                        7E            .byte	$7E
37005 FB6A                        3C            .byte	$3C
37006 FB6B                        18            .byte	$18
37007 FB6C                        00            .byte	0
37008 FB6D                        00            .byte	0
37009                                           ! 8550  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
37010 FB6E                        00            .byte	0
37011 FB6F                        00            .byte	0
37012 FB70                        00            .byte	0
37013 FB71                        00            .byte	0
37014 FB72                        00            .byte	0
37015 FB73                        00            .byte	0
37016 FB74                        00            .byte	0
37017 FB75                        00            .byte	0
37018                                           ! 8551  0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
37019 FB76                        30            .byte	$30
37020 FB77                        78            .byte	$78
37021 FB78                        78            .byte	$78
37022 FB79                        30            .byte	$30
37023 FB7A                        30            .byte	$30
37024 FB7B                        00            .byte	0
37025 FB7C                        30            .byte	$30
37026 FB7D                        00            .byte	0
37027                                           ! 8552  0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
37028 FB7E                        6C            .byte	$6C
37029 FB7F                        6C            .byte	$6C
37030 FB80                        6C            .byte	$6C
37031 FB81                        00            .byte	0
37032 FB82                        00            .byte	0
37033 FB83                        00            .byte	0
37034 FB84                        00            .byte	0
37035 FB85                        00            .byte	0
37036                                           ! 8553  0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
37037 FB86                        6C            .byte	$6C
37038 FB87                        6C            .byte	$6C
37039 FB88                        FE            .byte	$FE
37040 FB89                        6C            .byte	$6C
37041 FB8A                        FE            .byte	$FE
37042 FB8B                        6C            .byte	$6C
37043 FB8C                        6C            .byte	$6C
37044 FB8D                        00            .byte	0
37045                                           ! 8554  0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,
37046 FB8E                        30            .byte	$30
37047 FB8F                        7C            .byte	$7C
37048 FB90                        C0            .byte	$C0
37049 FB91                        78            .byte	$78
37050 FB92                        0C            .byte	$C
37051 FB93                        F8            .byte	$F8
37052 FB94                        30            .byte	$30
37053 FB95                        00            .byte	0
37054                                           ! 8555  0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,
37055 FB96                        00            .byte	0
37056 FB97                        C6            .byte	$C6
37057 FB98                        CC            .byte	$CC
37058 FB99                        18            .byte	$18
37059 FB9A                        30            .byte	$30
37060 FB9B                        66            .byte	$66
37061 FB9C                        C6            .byte	$C6
37062 FB9D                        00            .byte	0
37063                                           ! 8556  0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,
37064 FB9E                        38            .byte	$38
37065 FB9F                        6C            .byte	$6C
37066 FBA0                        38            .byte	$38
37067 FBA1                        76            .byte	$76
37068 FBA2                        DC            .byte	$DC
37069 FBA3                        CC            .byte	$CC
37070 FBA4                        76            .byte	$76
37071 FBA5                        00            .byte	0
37072                                           ! 8557  0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
37073 FBA6                        60            .byte	$60
37074 FBA7                        60            .byte	$60
37075 FBA8                        C0            .byte	$C0
37076 FBA9                        00            .byte	0
37077 FBAA                        00            .byte	0
37078 FBAB                        00            .byte	0
37079 FBAC                        00            .byte	0
37080 FBAD                        00            .byte	0
37081                                           ! 8558  0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
37082 FBAE                        18            .byte	$18
37083 FBAF                        30            .byte	$30
37084 FBB0                        60            .byte	$60
37085 FBB1                        60            .byte	$60
37086 FBB2                        60            .byte	$60
37087 FBB3                        30            .byte	$30
37088 FBB4                        18            .byte	$18
37089 FBB5                        00            .byte	0
37090                                           ! 8559  0x60, 0x30, 0x18, 0x18, 0x18, 0
37091 FBB6                        60            .byte	$60
37092 FBB7                        30            .byte	$30
37093 FBB8                        18            .byte	$18
37094 FBB9                        18            .byte	$18
37095 FBBA                        18            .byte	$18
37096                                           ! 8559 x30, 0x60, 0x00,
37097 FBBB                        30            .byte	$30
37098 FBBC                        60            .byte	$60
37099 FBBD                        00            .byte	0
37100                                           ! 8560  0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
37101 FBBE                        00            .byte	0
37102 FBBF                        66            .byte	$66
37103 FBC0                        3C            .byte	$3C
37104 FBC1                        FF            .byte	$FF
37105 FBC2                        3C            .byte	$3C
37106 FBC3                        66            .byte	$66
37107 FBC4                        00            .byte	0
37108 FBC5                        00            .byte	0
37109                                           ! 8561  0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,
37110 FBC6                        00            .byte	0
37111 FBC7                        30            .byte	$30
37112 FBC8                        30            .byte	$30
37113 FBC9                        FC            .byte	$FC
37114 FBCA                        30            .byte	$30
37115 FBCB                        30            .byte	$30
37116 FBCC                        00            .byte	0
37117 FBCD                        00            .byte	0
37118                                           ! 8562  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
37119 FBCE                        00            .byte	0
37120 FBCF                        00            .byte	0
37121 FBD0                        00            .byte	0
37122 FBD1                        00            .byte	0
37123 FBD2                        00            .byte	0
37124 FBD3                        30            .byte	$30
37125 FBD4                        30            .byte	$30
37126 FBD5                        60            .byte	$60
37127                                           ! 8563  0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
37128 FBD6                        00            .byte	0
37129 FBD7                        00            .byte	0
37130 FBD8                        00            .byte	0
37131 FBD9                        FC            .byte	$FC
37132 FBDA                        00            .byte	0
37133 FBDB                        00            .byte	0
37134 FBDC                        00            .byte	0
37135 FBDD                        00            .byte	0
37136                                           ! 8564  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
37137 FBDE                        00            .byte	0
37138 FBDF                        00            .byte	0
37139 FBE0                        00            .byte	0
37140 FBE1                        00            .byte	0
37141 FBE2                        00            .byte	0
37142 FBE3                        30            .byte	$30
37143 FBE4                        30            .byte	$30
37144 FBE5                        00            .byte	0
37145                                           ! 8565  0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,
37146 FBE6                        06            .byte	6
37147 FBE7                        0C            .byte	$C
37148 FBE8                        18            .byte	$18
37149 FBE9                        30            .byte	$30
37150 FBEA                        60            .byte	$60
37151 FBEB                        C0            .byte	$C0
37152 FBEC                        80            .byte	$80
37153 FBED                        00            .byte	0
37154                                           ! 8566  0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,
37155 FBEE                        7C            .byte	$7C
37156 FBEF                        C6            .byte	$C6
37157 FBF0                        CE            .byte	$CE
37158 FBF1                        DE            .byte	$DE
37159 FBF2                        F6            .byte	$F6
37160 FBF3                        E6            .byte	$E6
37161 FBF4                        7C            .byte	$7C
37162 FBF5                        00            .byte	0
37163                                           ! 8567  0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,
37164 FBF6                        30            .byte	$30
37165 FBF7                        70            .byte	$70
37166 FBF8                        30            .byte	$30
37167 FBF9                        30            .byte	$30
37168 FBFA                        30            .byte	$30
37169 FBFB                        30            .byte	$30
37170 FBFC                        FC            .byte	$FC
37171 FBFD                        00            .byte	0
37172                                           ! 8568  0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,
37173 FBFE                        78            .byte	$78
37174 FBFF                        CC            .byte	$CC
37175 FC00                        0C            .byte	$C
37176 FC01                        38            .byte	$38
37177 FC02                        60            .byte	$60
37178 FC03                        CC            .byte	$CC
37179 FC04                        FC            .byte	$FC
37180 FC05                        00            .byte	0
37181                                           ! 8569  0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,
37182 FC06                        78            .byte	$78
37183 FC07                        CC            .byte	$CC
37184 FC08                        0C            .byte	$C
37185 FC09                        38            .byte	$38
37186 FC0A                        0C            .byte	$C
37187 FC0B                        CC            .byte	$CC
37188 FC0C                        78            .byte	$78
37189 FC0D                        00            .byte	0
37190                                           ! 8570  0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,
37191 FC0E                        1C            .byte	$1C
37192 FC0F                        3C            .byte	$3C
37193 FC10                        6C            .byte	$6C
37194 FC11                        CC            .byte	$CC
37195 FC12                        FE            .byte	$FE
37196 FC13                        0C            .byte	$C
37197 FC14                        1E            .byte	$1E
37198 FC15                        00            .byte	0
37199                                           ! 8571  0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,
37200 FC16                        FC            .byte	$FC
37201 FC17                        C0            .byte	$C0
37202 FC18                        F8            .byte	$F8
37203 FC19                        0C            .byte	$C
37204 FC1A                        0C            .byte	$C
37205 FC1B                        CC            .byte	$CC
37206 FC1C                        78            .byte	$78
37207 FC1D                        00            .byte	0
37208                                           ! 8572  0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,
37209 FC1E                        38            .byte	$38
37210 FC1F                        60            .byte	$60
37211 FC20                        C0            .byte	$C0
37212 FC21                        F8            .byte	$F8
37213 FC22                        CC            .byte	$CC
37214 FC23                        CC            .byte	$CC
37215 FC24                        78            .byte	$78
37216 FC25                        00            .byte	0
37217                                           ! 8573  0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,
37218 FC26                        FC            .byte	$FC
37219 FC27                        CC            .byte	$CC
37220 FC28                        0C            .byte	$C
37221 FC29                        18            .byte	$18
37222 FC2A                        30            .byte	$30
37223 FC2B                        30            .byte	$30
37224 FC2C                        30            .byte	$30
37225 FC2D                        00            .byte	0
37226                                           ! 8574  0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00,
37227 FC2E                        78            .byte	$78
37228 FC2F                        CC            .byte	$CC
37229 FC30                        CC            .byte	$CC
37230 FC31                        78            .byte	$78
37231 FC32                        CC            .byte	$CC
37232 FC33                        CC            .byte	$CC
37233 FC34                        78            .byte	$78
37234 FC35                        00            .byte	0
37235                                           ! 8575  0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,
37236 FC36                        78            .byte	$78
37237 FC37                        CC            .byte	$CC
37238 FC38                        CC            .byte	$CC
37239 FC39                        7C            .byte	$7C
37240 FC3A                        0C            .byte	$C
37241 FC3B                        18            .byte	$18
37242 FC3C                        70            .byte	$70
37243 FC3D                        00            .byte	0
37244                                           ! 8576  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00,
37245 FC3E                        00            .byte	0
37246 FC3F                        30            .byte	$30
37247 FC40                        30            .byte	$30
37248 FC41                        00            .byte	0
37249 FC42                        00            .byte	0
37250 FC43                        30            .byte	$30
37251 FC44                        30            .byte	$30
37252 FC45                        00            .byte	0
37253                                           ! 8577  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
37254 FC46                        00            .byte	0
37255 FC47                        30            .byte	$30
37256 FC48                        30            .byte	$30
37257 FC49                        00            .byte	0
37258 FC4A                        00            .byte	0
37259 FC4B                        30            .byte	$30
37260 FC4C                        30            .byte	$30
37261 FC4D                        60            .byte	$60
37262                                           ! 8578  0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,
37263 FC4E                        18            .byte	$18
37264 FC4F                        30            .byte	$30
37265 FC50                        60            .byte	$60
37266 FC51                        C0            .byte	$C0
37267 FC52                        60            .byte	$60
37268 FC53                        30            .byte	$30
37269 FC54                        18            .byte	$18
37270 FC55                        00            .byte	0
37271                                           ! 8579  0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,
37272 FC56                        00            .byte	0
37273 FC57                        00            .byte	0
37274 FC58                        FC            .byte	$FC
37275 FC59                        00            .byte	0
37276 FC5A                        00            .byte	0
37277 FC5B                        FC            .byte	$FC
37278 FC5C                        00            .byte	0
37279 FC5D                        00            .byte	0
37280                                           ! 8580  0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
37281 FC5E                        60            .byte	$60
37282 FC5F                        30            .byte	$30
37283 FC60                        18            .byte	$18
37284 FC61                        0C            .byte	$C
37285 FC62                        18            .byte	$18
37286 FC63                        30            .byte	$30
37287 FC64                        60            .byte	$60
37288 FC65                        00            .byte	0
37289                                           ! 8581  0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,
37290 FC66                        78            .byte	$78
37291 FC67                        CC            .byte	$CC
37292 FC68                        0C            .byte	$C
37293 FC69                        18            .byte	$18
37294 FC6A                        30            .byte	$30
37295 FC6B                        00            .byte	0
37296 FC6C                        30            .byte	$30
37297 FC6D                        00            .byte	0
37298                                           ! 8582  0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,
37299 FC6E                        7C            .byte	$7C
37300 FC6F                        C6            .byte	$C6
37301 FC70                        DE            .byte	$DE
37302 FC71                        DE            .byte	$DE
37303 FC72                        DE            .byte	$DE
37304 FC73                        C0            .byte	$C0
37305 FC74                        78            .byte	$78
37306 FC75                        00            .byte	0
37307                                           ! 8583  0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,
37308 FC76                        30            .byte	$30
37309 FC77                        78            .byte	$78
37310 FC78                        CC            .byte	$CC
37311 FC79                        CC            .byte	$CC
37312 FC7A                        FC            .byte	$FC
37313 FC7B                        CC            .byte	$CC
37314 FC7C                        CC            .byte	$CC
37315 FC7D                        00            .byte	0
37316                                           ! 8584  0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,
37317 FC7E                        FC            .byte	$FC
37318 FC7F                        66            .byte	$66
37319 FC80                        66            .byte	$66
37320 FC81                        7C            .byte	$7C
37321 FC82                        66            .byte	$66
37322 FC83                        66            .byte	$66
37323 FC84                        FC            .byte	$FC
37324 FC85                        00            .byte	0
37325                                           ! 8585  0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,
37326 FC86                        3C            .byte	$3C
37327 FC87                        66            .byte	$66
37328 FC88                        C0            .byte	$C0
37329 FC89                        C0            .byte	$C0
37330 FC8A                        C0            .byte	$C0
37331 FC8B                        66            .byte	$66
37332 FC8C                        3C            .byte	$3C
37333 FC8D                        00            .byte	0
37334                                           ! 8586  0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
37335 FC8E                        F8            .byte	$F8
37336 FC8F                        6C            .byte	$6C
37337 FC90                        66            .byte	$66
37338 FC91                        66            .byte	$66
37339 FC92                        66            .byte	$66
37340 FC93                        6C            .byte	$6C
37341 FC94                        F8            .byte	$F8
37342 FC95                        00            .byte	0
37343                                           ! 8587  0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,
37344 FC96                        FE            .byte	$FE
37345 FC97                        62            .byte	$62
37346 FC98                        68            .byte	$68
37347 FC99                        78            .byte	$78
37348 FC9A                        68            .byte	$68
37349 FC9B                        62            .byte	$62
37350 FC9C                        FE            .byte	$FE
37351 FC9D                        00            .byte	0
37352                                           ! 8588  0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,
37353 FC9E                        FE            .byte	$FE
37354 FC9F                        62            .byte	$62
37355 FCA0                        68            .byte	$68
37356 FCA1                        78            .byte	$78
37357 FCA2                        68            .byte	$68
37358 FCA3                        60            .byte	$60
37359 FCA4                        F0            .byte	$F0
37360 FCA5                        00            .byte	0
37361                                           ! 8589  0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,
37362 FCA6                        3C            .byte	$3C
37363 FCA7                        66            .byte	$66
37364 FCA8                        C0            .byte	$C0
37365 FCA9                        C0            .byte	$C0
37366 FCAA                        CE            .byte	$CE
37367 FCAB                        66            .byte	$66
37368 FCAC                        3E            .byte	$3E
37369 FCAD                        00            .byte	0
37370                                           ! 8590  0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,
37371 FCAE                        CC            .byte	$CC
37372 FCAF                        CC            .byte	$CC
37373 FCB0                        CC            .byte	$CC
37374 FCB1                        FC            .byte	$FC
37375 FCB2                        CC            .byte	$CC
37376 FCB3                        CC            .byte	$CC
37377 FCB4                        CC            .byte	$CC
37378 FCB5                        00            .byte	0
37379                                           ! 8591  0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
37380 FCB6                        78            .byte	$78
37381 FCB7                        30            .byte	$30
37382 FCB8                        30            .byte	$30
37383 FCB9                        30            .byte	$30
37384 FCBA                        30            .byte	$30
37385 FCBB                        30            .byte	$30
37386 FCBC                        78            .byte	$78
37387 FCBD                        00            .byte	0
37388                                           ! 8592  0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
37389 FCBE                        1E            .byte	$1E
37390 FCBF                        0C            .byte	$C
37391 FCC0                        0C            .byte	$C
37392 FCC1                        0C            .byte	$C
37393 FCC2                        CC            .byte	$CC
37394 FCC3                        CC            .byte	$CC
37395 FCC4                        78            .byte	$78
37396 FCC5                        00            .byte	0
37397                                           ! 8593  0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
37398 FCC6                        E6            .byte	$E6
37399 FCC7                        66            .byte	$66
37400 FCC8                        6C            .byte	$6C
37401 FCC9                        78            .byte	$78
37402 FCCA                        6C            .byte	$6C
37403 FCCB                        66            .byte	$66
37404 FCCC                        E6            .byte	$E6
37405 FCCD                        00            .byte	0
37406                                           ! 8594  0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
37407 FCCE                        F0            .byte	$F0
37408 FCCF                        60            .byte	$60
37409 FCD0                        60            .byte	$60
37410 FCD1                        60            .byte	$60
37411 FCD2                        62            .byte	$62
37412 FCD3                        66            .byte	$66
37413 FCD4                        FE            .byte	$FE
37414 FCD5                        00            .byte	0
37415                                           ! 8595  0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
37416 FCD6                        C6            .byte	$C6
37417 FCD7                        EE            .byte	$EE
37418 FCD8                        FE            .byte	$FE
37419 FCD9                        FE            .byte	$FE
37420 FCDA                        D6            .byte	$D6
37421 FCDB                        C6            .byte	$C6
37422 FCDC                        C6            .byte	$C6
37423 FCDD                        00            .byte	0
37424                                           ! 8596  0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
37425 FCDE                        C6            .byte	$C6
37426 FCDF                        E6            .byte	$E6
37427 FCE0                        F6            .byte	$F6
37428 FCE1                        DE            .byte	$DE
37429 FCE2                        CE            .byte	$CE
37430 FCE3                        C6            .byte	$C6
37431 FCE4                        C6            .byte	$C6
37432 FCE5                        00            .byte	0
37433                                           ! 8597  0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
37434 FCE6                        38            .byte	$38
37435 FCE7                        6C            .byte	$6C
37436 FCE8                        C6            .byte	$C6
37437 FCE9                        C6            .byte	$C6
37438 FCEA                        C6            .byte	$C6
37439 FCEB                        6C            .byte	$6C
37440 FCEC                        38            .byte	$38
37441 FCED                        00            .byte	0
37442                                           ! 8598  0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
37443 FCEE                        FC            .byte	$FC
37444 FCEF                        66            .byte	$66
37445 FCF0                        66            .byte	$66
37446 FCF1                        7C            .byte	$7C
37447 FCF2                        60            .byte	$60
37448 FCF3                        60            .byte	$60
37449 FCF4                        F0            .byte	$F0
37450 FCF5                        00            .byte	0
37451                                           ! 8599  0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,
37452 FCF6                        78            .byte	$78
37453 FCF7                        CC            .byte	$CC
37454 FCF8                        CC            .byte	$CC
37455 FCF9                        CC            .byte	$CC
37456 FCFA                        DC            .byte	$DC
37457 FCFB                        78            .byte	$78
37458 FCFC                        1C            .byte	$1C
37459 FCFD                        00            .byte	0
37460                                           ! 8600  0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,
37461 FCFE                        FC            .byte	$FC
37462 FCFF                        66            .byte	$66
37463 FD00                        66            .byte	$66
37464 FD01                        7C            .byte	$7C
37465 FD02                        6C            .byte	$6C
37466 FD03                        66            .byte	$66
37467 FD04                        E6            .byte	$E6
37468 FD05                        00            .byte	0
37469                                           ! 8601  0x78, 0xcc, 0xe0, 0x7
37470 FD06                        78            .byte	$78
37471 FD07                        CC            .byte	$CC
37472 FD08                        E0            .byte	$E0
37473                                           ! 8601 0, 0x1c, 0xcc, 0x78, 0x00,
37474 FD09                        70            .byte	$70
37475 FD0A                        1C            .byte	$1C
37476 FD0B                        CC            .byte	$CC
37477 FD0C                        78            .byte	$78
37478 FD0D                        00            .byte	0
37479                                           ! 8602  0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
37480 FD0E                        FC            .byte	$FC
37481 FD0F                        B4            .byte	$B4
37482 FD10                        30            .byte	$30
37483 FD11                        30            .byte	$30
37484 FD12                        30            .byte	$30
37485 FD13                        30            .byte	$30
37486 FD14                        78            .byte	$78
37487 FD15                        00            .byte	0
37488                                           ! 8603  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,
37489 FD16                        CC            .byte	$CC
37490 FD17                        CC            .byte	$CC
37491 FD18                        CC            .byte	$CC
37492 FD19                        CC            .byte	$CC
37493 FD1A                        CC            .byte	$CC
37494 FD1B                        CC            .byte	$CC
37495 FD1C                        FC            .byte	$FC
37496 FD1D                        00            .byte	0
37497                                           ! 8604  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
37498 FD1E                        CC            .byte	$CC
37499 FD1F                        CC            .byte	$CC
37500 FD20                        CC            .byte	$CC
37501 FD21                        CC            .byte	$CC
37502 FD22                        CC            .byte	$CC
37503 FD23                        78            .byte	$78
37504 FD24                        30            .byte	$30
37505 FD25                        00            .byte	0
37506                                           ! 8605  0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
37507 FD26                        C6            .byte	$C6
37508 FD27                        C6            .byte	$C6
37509 FD28                        C6            .byte	$C6
37510 FD29                        D6            .byte	$D6
37511 FD2A                        FE            .byte	$FE
37512 FD2B                        EE            .byte	$EE
37513 FD2C                        C6            .byte	$C6
37514 FD2D                        00            .byte	0
37515                                           ! 8606  0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
37516 FD2E                        C6            .byte	$C6
37517 FD2F                        C6            .byte	$C6
37518 FD30                        6C            .byte	$6C
37519 FD31                        38            .byte	$38
37520 FD32                        38            .byte	$38
37521 FD33                        6C            .byte	$6C
37522 FD34                        C6            .byte	$C6
37523 FD35                        00            .byte	0
37524                                           ! 8607  0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,
37525 FD36                        CC            .byte	$CC
37526 FD37                        CC            .byte	$CC
37527 FD38                        CC            .byte	$CC
37528 FD39                        78            .byte	$78
37529 FD3A                        30            .byte	$30
37530 FD3B                        30            .byte	$30
37531 FD3C                        78            .byte	$78
37532 FD3D                        00            .byte	0
37533                                           ! 8608  0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,
37534 FD3E                        FE            .byte	$FE
37535 FD3F                        C6            .byte	$C6
37536 FD40                        8C            .byte	$8C
37537 FD41                        18            .byte	$18
37538 FD42                        32            .byte	$32
37539 FD43                        66            .byte	$66
37540 FD44                        FE            .byte	$FE
37541 FD45                        00            .byte	0
37542                                           ! 8609  0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
37543 FD46                        78            .byte	$78
37544 FD47                        60            .byte	$60
37545 FD48                        60            .byte	$60
37546 FD49                        60            .byte	$60
37547 FD4A                        60            .byte	$60
37548 FD4B                        60            .byte	$60
37549 FD4C                        78            .byte	$78
37550 FD4D                        00            .byte	0
37551                                           ! 8610  0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,
37552 FD4E                        C0            .byte	$C0
37553 FD4F                        60            .byte	$60
37554 FD50                        30            .byte	$30
37555 FD51                        18            .byte	$18
37556 FD52                        0C            .byte	$C
37557 FD53                        06            .byte	6
37558 FD54                        02            .byte	2
37559 FD55                        00            .byte	0
37560                                           ! 8611  0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
37561 FD56                        78            .byte	$78
37562 FD57                        18            .byte	$18
37563 FD58                        18            .byte	$18
37564 FD59                        18            .byte	$18
37565 FD5A                        18            .byte	$18
37566 FD5B                        18            .byte	$18
37567 FD5C                        78            .byte	$78
37568 FD5D                        00            .byte	0
37569                                           ! 8612  0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
37570 FD5E                        10            .byte	$10
37571 FD5F                        38            .byte	$38
37572 FD60                        6C            .byte	$6C
37573 FD61                        C6            .byte	$C6
37574 FD62                        00            .byte	0
37575 FD63                        00            .byte	0
37576 FD64                        00            .byte	0
37577 FD65                        00            .byte	0
37578                                           ! 8613  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
37579 FD66                        00            .byte	0
37580 FD67                        00            .byte	0
37581 FD68                        00            .byte	0
37582 FD69                        00            .byte	0
37583 FD6A                        00            .byte	0
37584 FD6B                        00            .byte	0
37585 FD6C                        00            .byte	0
37586 FD6D                        FF            .byte	$FF
37587                                           ! 8614  0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
37588 FD6E                        30            .byte	$30
37589 FD6F                        30            .byte	$30
37590 FD70                        18            .byte	$18
37591 FD71                        00            .byte	0
37592 FD72                        00            .byte	0
37593 FD73                        00            .byte	0
37594 FD74                        00            .byte	0
37595 FD75                        00            .byte	0
37596                                           ! 8615  0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,
37597 FD76                        00            .byte	0
37598 FD77                        00            .byte	0
37599 FD78                        78            .byte	$78
37600 FD79                        0C            .byte	$C
37601 FD7A                        7C            .byte	$7C
37602 FD7B                        CC            .byte	$CC
37603 FD7C                        76            .byte	$76
37604 FD7D                        00            .byte	0
37605                                           ! 8616  0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00,
37606 FD7E                        E0            .byte	$E0
37607 FD7F                        60            .byte	$60
37608 FD80                        60            .byte	$60
37609 FD81                        7C            .byte	$7C
37610 FD82                        66            .byte	$66
37611 FD83                        66            .byte	$66
37612 FD84                        DC            .byte	$DC
37613 FD85                        00            .byte	0
37614                                           ! 8617  0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,
37615 FD86                        00            .byte	0
37616 FD87                        00            .byte	0
37617 FD88                        78            .byte	$78
37618 FD89                        CC            .byte	$CC
37619 FD8A                        C0            .byte	$C0
37620 FD8B                        CC            .byte	$CC
37621 FD8C                        78            .byte	$78
37622 FD8D                        00            .byte	0
37623                                           ! 8618  0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
37624 FD8E                        1C            .byte	$1C
37625 FD8F                        0C            .byte	$C
37626 FD90                        0C            .byte	$C
37627 FD91                        7C            .byte	$7C
37628 FD92                        CC            .byte	$CC
37629 FD93                        CC            .byte	$CC
37630 FD94                        76            .byte	$76
37631 FD95                        00            .byte	0
37632                                           ! 8619  0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
37633 FD96                        00            .byte	0
37634 FD97                        00            .byte	0
37635 FD98                        78            .byte	$78
37636 FD99                        CC            .byte	$CC
37637 FD9A                        FC            .byte	$FC
37638 FD9B                        C0            .byte	$C0
37639 FD9C                        78            .byte	$78
37640 FD9D                        00            .byte	0
37641                                           ! 8620  0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,
37642 FD9E                        38            .byte	$38
37643 FD9F                        6C            .byte	$6C
37644 FDA0                        60            .byte	$60
37645 FDA1                        F0            .byte	$F0
37646 FDA2                        60            .byte	$60
37647 FDA3                        60            .byte	$60
37648 FDA4                        F0            .byte	$F0
37649 FDA5                        00            .byte	0
37650                                           ! 8621  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
37651 FDA6                        00            .byte	0
37652 FDA7                        00            .byte	0
37653 FDA8                        76            .byte	$76
37654 FDA9                        CC            .byte	$CC
37655 FDAA                        CC            .byte	$CC
37656 FDAB                        7C            .byte	$7C
37657 FDAC                        0C            .byte	$C
37658 FDAD                        F8            .byte	$F8
37659                                           ! 8622  0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,
37660 FDAE                        E0            .byte	$E0
37661 FDAF                        60            .byte	$60
37662 FDB0                        6C            .byte	$6C
37663 FDB1                        76            .byte	$76
37664 FDB2                        66            .byte	$66
37665 FDB3                        66            .byte	$66
37666 FDB4                        E6            .byte	$E6
37667 FDB5                        00            .byte	0
37668                                           ! 8623  0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
37669 FDB6                        30            .byte	$30
37670 FDB7                        00            .byte	0
37671 FDB8                        70            .byte	$70
37672 FDB9                        30            .byte	$30
37673 FDBA                        30            .byte	$30
37674 FDBB                        30            .byte	$30
37675 FDBC                        78            .byte	$78
37676 FDBD                        00            .byte	0
37677                                           ! 8624  0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
37678 FDBE                        0C            .byte	$C
37679 FDBF                        00            .byte	0
37680 FDC0                        0C            .byte	$C
37681 FDC1                        0C            .byte	$C
37682 FDC2                        0C            .byte	$C
37683 FDC3                        CC            .byte	$CC
37684 FDC4                        CC            .byte	$CC
37685 FDC5                        78            .byte	$78
37686                                           ! 8625  0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,
37687 FDC6                        E0            .byte	$E0
37688 FDC7                        60            .byte	$60
37689 FDC8                        66            .byte	$66
37690 FDC9                        6C            .byte	$6C
37691 FDCA                        78            .byte	$78
37692 FDCB                        6C            .byte	$6C
37693 FDCC                        E6            .byte	$E6
37694 FDCD                        00            .byte	0
37695                                           ! 8626  0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
37696 FDCE                        70            .byte	$70
37697 FDCF                        30            .byte	$30
37698 FDD0                        30            .byte	$30
37699 FDD1                        30            .byte	$30
37700 FDD2                        30            .byte	$30
37701 FDD3                        30            .byte	$30
37702 FDD4                        78            .byte	$78
37703 FDD5                        00            .byte	0
37704                                           ! 8627  0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,
37705 FDD6                        00            .byte	0
37706 FDD7                        00            .byte	0
37707 FDD8                        CC            .byte	$CC
37708 FDD9                        FE            .byte	$FE
37709 FDDA                        FE            .byte	$FE
37710 FDDB                        D6            .byte	$D6
37711 FDDC                        C6            .byte	$C6
37712 FDDD                        00            .byte	0
37713                                           ! 8628  0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
37714 FDDE                        00            .byte	0
37715 FDDF                        00            .byte	0
37716 FDE0                        F8            .byte	$F8
37717 FDE1                        CC            .byte	$CC
37718 FDE2                        CC            .byte	$CC
37719 FDE3                        CC            .byte	$CC
37720 FDE4                        CC            .byte	$CC
37721 FDE5                        00            .byte	0
37722                                           ! 8629  0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
37723 FDE6                        00            .byte	0
37724 FDE7                        00            .byte	0
37725 FDE8                        78            .byte	$78
37726 FDE9                        CC            .byte	$CC
37727 FDEA                        CC            .byte	$CC
37728 FDEB                        CC            .byte	$CC
37729 FDEC                        78            .byte	$78
37730 FDED                        00            .byte	0
37731                                           ! 8630  0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,
37732 FDEE                        00            .byte	0
37733 FDEF                        00            .byte	0
37734 FDF0                        DC            .byte	$DC
37735 FDF1                        66            .byte	$66
37736 FDF2                        66            .byte	$66
37737 FDF3                        7C            .byte	$7C
37738 FDF4                        60            .byte	$60
37739 FDF5                        F0            .byte	$F0
37740                                           ! 8631  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,
37741 FDF6                        00            .byte	0
37742 FDF7                        00            .byte	0
37743 FDF8                        76            .byte	$76
37744 FDF9                        CC            .byte	$CC
37745 FDFA                        CC            .byte	$CC
37746 FDFB                        7C            .byte	$7C
37747 FDFC                        0C            .byte	$C
37748 FDFD                        1E            .byte	$1E
37749                                           ! 8632  0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,
37750 FDFE                        00            .byte	0
37751 FDFF                        00            .byte	0
37752 FE00                        DC            .byte	$DC
37753 FE01                        76            .byte	$76
37754 FE02                        66            .byte	$66
37755 FE03                        60            .byte	$60
37756 FE04                        F0            .byte	$F0
37757 FE05                        00            .byte	0
37758                                           ! 8633  0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,
37759 FE06                        00            .byte	0
37760 FE07                        00            .byte	0
37761 FE08                        7C            .byte	$7C
37762 FE09                        C0            .byte	$C0
37763 FE0A                        78            .byte	$78
37764 FE0B                        0C            .byte	$C
37765 FE0C                        F8            .byte	$F8
37766 FE0D                        00            .byte	0
37767                                           ! 8634  0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,
37768 FE0E                        10            .byte	$10
37769 FE0F                        30            .byte	$30
37770 FE10                        7C            .byte	$7C
37771 FE11                        30            .byte	$30
37772 FE12                        30            .byte	$30
37773 FE13                        34            .byte	$34
37774 FE14                        18            .byte	$18
37775 FE15                        00            .byte	0
37776                                           ! 8635  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
37777 FE16                        00            .byte	0
37778 FE17                        00            .byte	0
37779 FE18                        CC            .byte	$CC
37780 FE19                        CC            .byte	$CC
37781 FE1A                        CC            .byte	$CC
37782 FE1B                        CC            .byte	$CC
37783 FE1C                        76            .byte	$76
37784 FE1D                        00            .byte	0
37785                                           ! 8636  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
37786 FE1E                        00            .byte	0
37787 FE1F                        00            .byte	0
37788 FE20                        CC            .byte	$CC
37789 FE21                        CC            .byte	$CC
37790 FE22                        CC            .byte	$CC
37791 FE23                        78            .byte	$78
37792 FE24                        30            .byte	$30
37793 FE25                        00            .byte	0
37794                                           ! 8637  0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,
37795 FE26                        00            .byte	0
37796 FE27                        00            .byte	0
37797 FE28                        C6            .byte	$C6
37798 FE29                        D6            .byte	$D6
37799 FE2A                        FE            .byte	$FE
37800 FE2B                        FE            .byte	$FE
37801 FE2C                        6C            .byte	$6C
37802 FE2D                        00            .byte	0
37803                                           ! 8638  0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
37804 FE2E                        00            .byte	0
37805 FE2F                        00            .byte	0
37806 FE30                        C6            .byte	$C6
37807 FE31                        6C            .byte	$6C
37808 FE32                        38            .byte	$38
37809 FE33                        6C            .byte	$6C
37810 FE34                        C6            .byte	$C6
37811 FE35                        00            .byte	0
37812                                           ! 8639  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
37813 FE36                        00            .byte	0
37814 FE37                        00            .byte	0
37815 FE38                        CC            .byte	$CC
37816 FE39                        CC            .byte	$CC
37817 FE3A                        CC            .byte	$CC
37818 FE3B                        7C            .byte	$7C
37819 FE3C                        0C            .byte	$C
37820 FE3D                        F8            .byte	$F8
37821                                           ! 8640  0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,
37822 FE3E                        00            .byte	0
37823 FE3F                        00            .byte	0
37824 FE40                        FC            .byte	$FC
37825 FE41                        98            .byte	$98
37826 FE42                        30            .byte	$30
37827 FE43                        64            .byte	$64
37828 FE44                        FC            .byte	$FC
37829 FE45                        00            .byte	0
37830                                           ! 8641  0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,
37831 FE46                        1C            .byte	$1C
37832 FE47                        30            .byte	$30
37833 FE48                        30            .byte	$30
37834 FE49                        E0            .byte	$E0
37835 FE4A                        30            .byte	$30
37836 FE4B                        30            .byte	$30
37837 FE4C                        1C            .byte	$1C
37838 FE4D                        00            .byte	0
37839                                           ! 8642  0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
37840 FE4E                        18            .byte	$18
37841 FE4F                        18            .byte	$18
37842 FE50                        18            .byte	$18
37843 FE51                        00            .byte	0
37844 FE52                        18            .byte	$18
37845 FE53                        18            .byte	$18
37846 FE54                        18            .byte	$18
37847 FE55                        00            .byte	0
37848                                           ! 8643  0xe0, 0x30,
37849 FE56                        E0            .byte	$E0
37850                                           ! 8643  0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,
37851 FE57                        30            .byte	$30
37852 FE58                        30            .byte	$30
37853 FE59                        1C            .byte	$1C
37854 FE5A                        30            .byte	$30
37855 FE5B                        30            .byte	$30
37856 FE5C                        E0            .byte	$E0
37857 FE5D                        00            .byte	0
37858                                           ! 8644  0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
37859 FE5E                        76            .byte	$76
37860 FE5F                        DC            .byte	$DC
37861 FE60                        00            .byte	0
37862 FE61                        00            .byte	0
37863 FE62                        00            .byte	0
37864 FE63                        00            .byte	0
37865 FE64                        00            .byte	0
37866 FE65                        00            .byte	0
37867                                           ! 8645  0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,
37868 FE66                        00            .byte	0
37869 FE67                        10            .byte	$10
37870 FE68                        38            .byte	$38
37871 FE69                        6C            .byte	$6C
37872 FE6A                        C6            .byte	$C6
37873 FE6B                        C6            .byte	$C6
37874 FE6C                        FE            .byte	$FE
37875 FE6D                        00            .byte	0
37876                                           ! 8646 };
37877                                           !BCC_EOS
37878                                           ! 8647 #asm
37879                                           !BCC_ASM
37880 CC00                                      .org 0xcc00
37881                       0000CC00            bios_table_area_end:
37882 CC00                        28            .ascii "(c) 2001-2021  The Bochs Project"
37883                                           ! 8651 endasm
37884                                           !BCC_ENDASM
37885                                           ! 8652 
37886                       0000CC20            .7FB:
37887                       0000CC20            .80A:
37888 CC20                        6E            .ascii	"no PCI device with class code 0x%02x%04x"
37889 CC48                        20            .ascii	" found at index %d"
37890 CC5A                        0A            .byte	$A
37891 CC5B                        00            .byte	0
37892                       0000CC5C            .7F9:
37893                       0000CC5C            .80B:
37894 CC5C                        50            .ascii	"PCI device %04x:%04x not found at index "
37895 CC84                        25            .ascii	"%d"
37896 CC86                        0A            .byte	$A
37897 CC87                        00            .byte	0
37898                       0000CC88            .7F3:
37899                       0000CC88            .80C:
37900 CC88                        62            .ascii	"bad PCI vendor ID %04x"
37901 CC9E                        0A            .byte	$A
37902 CC9F                        00            .byte	0
37903                       0000CCA0            .7EF:
37904                       0000CCA0            .80D:
37905 CCA0                        75            .ascii	"unsupported PCI BIOS function 0x%02x"
37906 CCC4                        0A            .byte	$A
37907 CCC5                        00            .byte	0
37908                       0000CCC6            .7EB:
37909                       0000CCC6            .80E:
37910 CCC6                        50            .ascii	"PCI BIOS: PCI not present"
37911 CCDF                        0A            .byte	$A
37912 CCE0                        00            .byte	0
37913                       0000CCE1            .79D:
37914                       0000CCE1            .80F:
37915 CCE1                        42            .ascii	"Booting from %x:%x"
37916 CCF3                        0A            .byte	$A
37917 CCF4                        00            .byte	0
37918                       0000CCF5            .788:
37919                       0000CCF5            .810:
37920 CCF5                        49            .ascii	"Invalid boot device (0x%x)"
37921 CD0F                        0A            .byte	$A
37922 CD10                        00            .byte	0
37923                       0000CD11            .785:
37924                       0000CD11            .811:
37925 CD11                        4E            .ascii	"No bootable device."
37926 CD24                        0A            .byte	$A
37927 CD25                        00            .byte	0
37928                       0000CD26            .76F:
37929                       0000CD26            .812:
37930 CD26                        73            .ascii	"set_diskette_current_cyl(): drive > 1"
37931 CD4B                        0A            .byte	$A
37932 CD4C                        00            .byte	0
37933                       0000CD4D            .76A:
37934                       0000CD4D            .813:
37935 CD4D                        69            .ascii	"int13_diskette: unsupported AH=%02x"
37936 CD70                        0A            .byte	$A
37937 CD71                        00            .byte	0
37938                       0000CD72            .706:
37939                       0000CD72            .814:
37940 CD72                        66            .ascii	"floppy: int13: bad floppy type"
37941 CD90                        0A            .byte	$A
37942 CD91                        00            .byte	0
37943                       0000CD92            .6EE:
37944                       0000CD92            .815:
37945 CD92                        69            .ascii	"int13_diskette_function: write error"
37946 CDB6                        0A            .byte	$A
37947 CDB7                        00            .byte	0
37948                       0000CDB8            .6E8:
37949                       0000CDB8            .816:
37950 CDB8                        69            .ascii	"int13_diskette: ctrl not ready"
37951 CDD6                        0A            .byte	$A
37952 CDD7                        00            .byte	0
37953                       0000CDD8            .6CE:
37954                       0000CDD8            .817:
37955 CDD8                        69            .ascii	"int13_diskette_function: write error"
37956 CDFC                        0A            .byte	$A
37957 CDFD                        00            .byte	0
37958                       0000CDFE            .6C5:
37959                       0000CDFE            .818:
37960 CDFE                        69            .ascii	"int13_diskette: ctrl not ready"
37961 CE1C                        0A            .byte	$A
37962 CE1D                        00            .byte	0
37963                       0000CE1E            .6AD:
37964                       0000CE1E            .819:
37965 CE1E                        69            .ascii	"int13_diskette: read/write/verify: param"
37966 CE46                        65            .ascii	"eter out of range"
37967 CE57                        0A            .byte	$A
37968 CE58                        00            .byte	0
37969                       0000CE59            .655:
37970                       0000CE59            .81A:
37971 CE59                        69            .ascii	"int13_cdemu function AH=%02x unsupported"
37972 CE81                        2C            .ascii	", returns fail"
37973 CE8F                        0A            .byte	$A
37974 CE90                        00            .byte	0
37975                       0000CE91            .63D:
37976                       0000CE91            .81B:
37977 CE91                        69            .ascii	"int13_cdemu: function %02x, error %02x !"
37978 CEB9                        0A            .byte	$A
37979 CEBA                        00            .byte	0
37980                       0000CEBB            .61F:
37981                       0000CEBB            .81C:
37982 CEBB                        69            .ascii	"int13_cdemu: function %02x, emulation no"
37983 CEE3                        74            .ascii	"t active for DL= %02x"
37984 CEF8                        0A            .byte	$A
37985 CEF9                        00            .byte	0
37986                       0000CEFA            .61B:
37987                       0000CEFA            .81D:
37988 CEFA                        69            .ascii	"int13_eltorito: unsupported AH=%02x"
37989 CF1D                        0A            .byte	$A
37990 CF1E                        00            .byte	0
37991                       0000CF1F            .616:
37992                       0000CF1F            .81E:
37993 CF1F                        49            .ascii	"Int13 eltorito call with AX=%04x. Please"
37994 CF47                        20            .ascii	" report"
37995 CF4E                        0A            .byte	$A
37996 CF4F                        00            .byte	0
37997                       0000CF50            .60B:
37998                       0000CF50            .81F:
37999 CF50                        69            .ascii	"int13_cdrom: unsupported AH=%02x"
38000 CF70                        0A            .byte	$A
38001 CF71                        00            .byte	0
38002                       0000CF72            .5DD:
38003                       0000CF72            .820:
38004 CF72                        69            .ascii	"int13_cdrom: function %02x, status %02x "
38005 CF9A                        21            .ascii	"!"
38006 CF9B                        0A            .byte	$A
38007 CF9C                        00            .byte	0
38008                       0000CF9D            .5D7:
38009                       0000CF9D            .821:
38010 CF9D                        69            .ascii	"int13_cdrom: function %02x. Can't use 64"
38011 CFC5                        62            .ascii	"bits lba"
38012 CFCD                        0A            .byte	$A
38013 CFCE                        00            .byte	0
38014                       0000CFCF            .5BD:
38015                       0000CFCF            .822:
38016 CFCF                        69            .ascii	"int13_cdrom: function %02x, unmapped dev"
38017 CFF7                        69            .ascii	"ice for ELDL=%02x"
38018 D008                        0A            .byte	$A
38019 D009                        00            .byte	0
38020                       0000D00A            .5BA:
38021                       0000D00A            .823:
38022 D00A                        69            .ascii	"int13_cdrom: function %02x, ELDL out of "
38023 D032                        72            .ascii	"range %02x"
38024 D03C                        0A            .byte	$A
38025 D03D                        00            .byte	0
38026                       0000D03E            .5B2:
38027                       0000D03E            .824:
38028 D03E                        69            .ascii	"int13_harddisk: function %02xh unsupport"
38029 D066                        65            .ascii	"ed, returns fail"
38030 D076                        0A            .byte	$A
38031 D077                        00            .byte	0
38032                       0000D078            .5AC:
38033                       0000D078            .825:
38034 D078                        69            .ascii	"int13_harddisk: function %02xh unimpleme"
38035 D0A0                        6E            .ascii	"nted, returns success"
38036 D0B5                        0A            .byte	$A
38037 D0B6                        00            .byte	0
38038                       0000D0B7            .597:
38039                       0000D0B7            .826:
38040 D0B7                        69            .ascii	"int13_harddisk: function %02x, error %02"
38041 D0DF                        78            .ascii	"x !"
38042 D0E2                        0A            .byte	$A
38043 D0E3                        00            .byte	0
38044                       0000D0E4            .58E:
38045                       0000D0E4            .827:
38046 D0E4                        69            .ascii	"int13_harddisk: function %02x. LBA out o"
38047 D10C                        66            .ascii	"f range"
38048 D113                        0A            .byte	$A
38049 D114                        00            .byte	0
38050                       0000D115            .58A:
38051                       0000D115            .828:
38052 D115                        69            .ascii	"int13_harddisk: function %02x. LBA out o"
38053 D13D                        66            .ascii	"f range"
38054 D144                        0A            .byte	$A
38055 D145                        00            .byte	0
38056                       0000D146            .57C:
38057                       0000D146            .829:
38058 D146                        66            .ascii	"format disk track called"
38059 D15E                        0A            .byte	$A
38060 D15F                        00            .byte	0
38061                       0000D160            .57A:
38062                       0000D160            .82A:
38063 D160                        69            .ascii	"int13_harddisk: function %02x, error %02"
38064 D188                        78            .ascii	"x !"
38065 D18B                        0A            .byte	$A
38066 D18C                        00            .byte	0
38067                       0000D18D            .56F:
38068                       0000D18D            .82B:
38069 D18D                        69            .ascii	"int13_harddisk: function %02x, parameter"
38070 D1B5                        73            .ascii	"s out of range %04x/%04x/%04x!"
38071 D1D3                        0A            .byte	$A
38072 D1D4                        00            .byte	0
38073                       0000D1D5            .56A:
38074                       0000D1D5            .82C:
38075 D1D5                        69            .ascii	"int13_harddisk: function %02x, parameter"
38076 D1FD                        20            .ascii	" out of range!"
38077 D20B                        0A            .byte	$A
38078 D20C                        00            .byte	0
38079                       0000D20D            .55A:
38080                       0000D20D            .82D:
38081 D20D                        69            .ascii	"int13_harddisk: function %02x, unmapped "
38082 D235                        64            .ascii	"device for ELDL=%02x"
38083 D249                        0A            .byte	$A
38084 D24A                        00            .byte	0
38085                       0000D24B            .557:
38086                       0000D24B            .82E:
38087 D24B                        69            .ascii	"int13_harddisk: function %02x, ELDL out "
38088 D273                        6F            .ascii	"of range %02x"
38089 D280                        0A            .byte	$A
38090 D281                        00            .byte	0
38091                       0000D282            .4F9:
38092                       0000D282            .82F:
38093 D282                        4B            .ascii	"KBD: int09h_handler(): scancode & asciic"
38094 D2AA                        6F            .ascii	"ode are zero?"
38095 D2B7                        0A            .byte	$A
38096 D2B8                        00            .byte	0
38097                       0000D2B9            .4DD:
38098                       0000D2B9            .830:
38099 D2B9                        4B            .ascii	"KBD: int09h_handler(): unknown scancode "
38100 D2E1                        72            .ascii	"read: 0x%02x!"
38101 D2EE                        0A            .byte	$A
38102 D2EF                        00            .byte	0
38103                       0000D2F0            .4A8:
38104                       0000D2F0            .831:
38105 D2F0                        4B            .ascii	"KBD: int09 handler: AL=0"
38106 D308                        0A            .byte	$A
38107 D309                        00            .byte	0
38108                       0000D30A            .4A5:
38109                       0000D30A            .832:
38110 D30A                        73            .ascii	"setkbdcomm"
38111 D314                        00            .byte	0
38112                       0000D315            .49E:
38113                       0000D315            .833:
38114 D315                        73            .ascii	"sendmouse"
38115 D31E                        00            .byte	0
38116                       0000D31F            .49B:
38117                       0000D31F            .834:
38118 D31F                        65            .ascii	"enabmouse"
38119 D328                        00            .byte	0
38120                       0000D329            .494:
38121                       0000D329            .835:
38122 D329                        65            .ascii	"enabmouse"
38123 D332                        00            .byte	0
38124                       0000D333            .491:
38125                       0000D333            .836:
38126 D333                        69            .ascii	"inhibmouse"
38127 D33D                        00            .byte	0
38128                       0000D33E            .48A:
38129                       0000D33E            .837:
38130 D33E                        69            .ascii	"inhibmouse"
38131 D348                        00            .byte	0
38132                       0000D349            .47D:
38133                       0000D349            .838:
38134 D349                        4B            .ascii	"KBD: unsupported int 16h function %02x"
38135 D36F                        0A            .byte	$A
38136 D370                        00            .byte	0
38137                       0000D371            .46C:
38138                       0000D371            .839:
38139 D371                        4B            .ascii	"KBD: int16h: out of keyboard input"
38140 D393                        0A            .byte	$A
38141 D394                        00            .byte	0
38142                       0000D395            .43E:
38143                       0000D395            .83A:
38144 D395                        4B            .ascii	"KBD: int16h: out of keyboard input"
38145 D3B7                        0A            .byte	$A
38146 D3B8                        00            .byte	0
38147                       0000D3B9            .42B:
38148                       0000D3B9            .83B:
38149 D3B9                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
38150 D3E1                        74            .ascii	"t yet supported!"
38151 D3F1                        0A            .byte	$A
38152 D3F2                        00            .byte	0
38153                       0000D3F3            .400:
38154                       0000D3F3            .83C:
38155 D3F3                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
38156 D41B                        74            .ascii	"t yet supported!"
38157 D42B                        0A            .byte	$A
38158 D42C                        00            .byte	0
38159                       0000D42D            .3F4:
38160                       0000D42D            .83D:
38161 D42D                        49            .ascii	"INT 15h C2 AL=6, BH=%02x"
38162 D445                        0A            .byte	$A
38163 D446                        00            .byte	0
38164                       0000D447            .3DE:
38165                       0000D447            .83E:
38166 D447                        4D            .ascii	"Mouse status returned %02x (should be ac"
38167 D46F                        6B            .ascii	"k)"
38168 D471                        0A            .byte	$A
38169 D472                        00            .byte	0
38170                       0000D473            .3CE:
38171                       0000D473            .83F:
38172 D473                        4D            .ascii	"Mouse status returned %02x (should be ac"
38173 D49B                        6B            .ascii	"k)"
38174 D49D                        0A            .byte	$A
38175 D49E                        00            .byte	0
38176                       0000D49F            .3CB:
38177                       0000D49F            .840:
38178 D49F                        4D            .ascii	"Mouse status returned %02x (should be ac"
38179 D4C7                        6B            .ascii	"k)"
38180 D4C9                        0A            .byte	$A
38181 D4CA                        00            .byte	0
38182                       0000D4CB            .3A9:
38183                       0000D4CB            .841:
38184 D4CB                        4D            .ascii	"Mouse reset returned %02x (should be ack"
38185 D4F3                        29            .ascii	")"
38186 D4F4                        0A            .byte	$A
38187 D4F5                        00            .byte	0
38188                       0000D4F6            .381:
38189                       0000D4F6            .842:
38190 D4F6                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
38191 D51E                        74            .ascii	"t yet supported!"
38192 D52E                        0A            .byte	$A
38193 D52F                        00            .byte	0
38194                       0000D530            .37F:
38195                       0000D530            .843:
38196 D530                        45            .ascii	"EISA BIOS not present"
38197 D545                        0A            .byte	$A
38198 D546                        00            .byte	0
38199                       0000D547            .37B:
38200                       0000D547            .844:
38201 D547                        2A            .ascii	"*** int 15h function AH=bf not yet suppo"
38202 D56F                        72            .ascii	"rted!"
38203 D574                        0A            .byte	$A
38204 D575                        00            .byte	0
38205                       0000D576            .365:
38206                       0000D576            .845:
38207 D576                        69            .ascii	"int15: Func 24h, subfunc %02xh, A20 gate"
38208 D59E                        20            .ascii	" control not supported"
38209 D5B4                        0A            .byte	$A
38210 D5B5                        00            .byte	0
38211                       0000D5B6            .2FF:
38212                       0000D5B6            .846:
38213 D5B6                        61            .ascii	"ata_is_ready returned %d"
38214 D5CE                        0A            .byte	$A
38215 D5CF                        00            .byte	0
38216                       0000D5D0            .2E9:
38217                       0000D5D0            .847:
38218 D5D0                        25            .ascii	"%dMB medium detected"
38219 D5E4                        0A            .byte	$A
38220 D5E5                        00            .byte	0
38221                       0000D5E6            .2E4:
38222                       0000D5E6            .848:
38223 D5E6                        55            .ascii	"Unsupported sector size %u"
38224 D600                        0A            .byte	$A
38225 D601                        00            .byte	0
38226                       0000D602            .2DF:
38227                       0000D602            .849:
38228 D602                        57            .ascii	"Waiting for device to detect medium... "
38229 D629                        00            .byte	0
38230                       0000D62A            .2D1:
38231                       0000D62A            .84A:
38232 D62A                        6E            .ascii	"not implemented for non-ATAPI device"
38233 D64E                        0A            .byte	$A
38234 D64F                        00            .byte	0
38235                       0000D650            .297:
38236                       0000D650            .84B:
38237 D650                        61            .ascii	"ata_cmd_packet: DATA_OUT not supported y"
38238 D678                        65            .ascii	"et"
38239 D67A                        0A            .byte	$A
38240 D67B                        00            .byte	0
38241                       0000D67C            .255:
38242                       0000D67C            .84C:
38243 D67C                        0A            .byte	$A
38244 D67D                        00            .byte	0
38245                       0000D67E            .250:
38246                       0000D67E            .84D:
38247 D67E                        6D            .ascii	"master"
38248 D684                        00            .byte	0
38249                       0000D685            .24F:
38250                       0000D685            .84E:
38251 D685                        20            .ascii	" slave"
38252 D68B                        00            .byte	0
38253                       0000D68C            .24E:
38254                       0000D68C            .84F:
38255 D68C                        61            .ascii	"ata%d %s: Unknown device"
38256 D6A4                        0A            .byte	$A
38257 D6A5                        00            .byte	0
38258                       0000D6A6            .24C:
38259                       0000D6A6            .850:
38260 D6A6                        20            .ascii	" ATAPI-%d Device"
38261 D6B6                        0A            .byte	$A
38262 D6B7                        00            .byte	0
38263                       0000D6B8            .24A:
38264                       0000D6B8            .851:
38265 D6B8                        20            .ascii	" ATAPI-%d CD-Rom/DVD-Rom"
38266 D6D0                        0A            .byte	$A
38267 D6D1                        00            .byte	0
38268                       0000D6D2            .246:
38269                       0000D6D2            .852:
38270 D6D2                        25            .ascii	"%c"
38271 D6D4                        00            .byte	0
38272                       0000D6D5            .23F:
38273                       0000D6D5            .853:
38274 D6D5                        6D            .ascii	"master"
38275 D6DB                        00            .byte	0
38276                       0000D6DC            .23E:
38277                       0000D6DC            .854:
38278 D6DC                        20            .ascii	" slave"
38279 D6E2                        00            .byte	0
38280                       0000D6E3            .23D:
38281                       0000D6E3            .855:
38282 D6E3                        61            .ascii	"ata%d %s: "
38283 D6ED                        00            .byte	0
38284                       0000D6EE            .23B:
38285                       0000D6EE            .856:
38286 D6EE                        20            .ascii	" ATA-%d Hard-Disk (%4u GBytes)"
38287 D70C                        0A            .byte	$A
38288 D70D                        00            .byte	0
38289                       0000D70E            .239:
38290                       0000D70E            .857:
38291 D70E                        20            .ascii	" ATA-%d Hard-Disk (%4u MBytes)"
38292 D72C                        0A            .byte	$A
38293 D72D                        00            .byte	0
38294                       0000D72E            .235:
38295                       0000D72E            .858:
38296 D72E                        25            .ascii	"%c"
38297 D730                        00            .byte	0
38298                       0000D731            .22E:
38299                       0000D731            .859:
38300 D731                        6D            .ascii	"master"
38301 D737                        00            .byte	0
38302                       0000D738            .22D:
38303                       0000D738            .85A:
38304 D738                        20            .ascii	" slave"
38305 D73E                        00            .byte	0
38306                       0000D73F            .22C:
38307                       0000D73F            .85B:
38308 D73F                        61            .ascii	"ata%d %s: "
38309 D749                        00            .byte	0
38310                       0000D74A            .1FB:
38311                       0000D74A            .85C:
38312 D74A                        61            .ascii	"ata-detect: Failed to detect ATAPI devic"
38313 D772                        65            .ascii	"e"
38314 D773                        0A            .byte	$A
38315 D774                        00            .byte	0
38316                       0000D775            .1F6:
38317                       0000D775            .85D:
38318 D775                        20            .ascii	" LCHS=%d/%d/%d"
38319 D783                        0A            .byte	$A
38320 D784                        00            .byte	0
38321                       0000D785            .1D6:
38322                       0000D785            .85E:
38323 D785                        72            .ascii	"r-echs"
38324 D78B                        00            .byte	0
38325                       0000D78C            .1D4:
38326                       0000D78C            .85F:
38327 D78C                        6C            .ascii	"large"
38328 D791                        00            .byte	0
38329                       0000D792            .1D2:
38330                       0000D792            .860:
38331 D792                        6C            .ascii	"lba"
38332 D795                        00            .byte	0
38333                       0000D796            .1D0:
38334                       0000D796            .861:
38335 D796                        6E            .ascii	"none"
38336 D79A                        00            .byte	0
38337                       0000D79B            .1C6:
38338                       0000D79B            .862:
38339 D79B                        61            .ascii	"ata%d-%d: PCHS=%u/%d/%d translation="
38340 D7BF                        00            .byte	0
38341                       0000D7C0            .1BF:
38342                       0000D7C0            .863:
38343 D7C0                        61            .ascii	"ata-detect: Failed to detect ATA device"
38344 D7E7                        0A            .byte	$A
38345 D7E8                        00            .byte	0
38346                       0000D7E9            .19E:
38347                       0000D7E9            .864:
38348 D7E9                        49            .ascii	"IDE time out"
38349 D7F5                        0A            .byte	$A
38350 D7F6                        00            .byte	0
38351                       0000D7F7            .162:
38352                       0000D7F7            .865:
38353 D7F7                        53            .ascii	"S3 resume jump to %x:%x"
38354 D80E                        0A            .byte	$A
38355 D80F                        00            .byte	0
38356                       0000D810            .15E:
38357                       0000D810            .866:
38358 D810                        53            .ascii	"S3 resume called %x 0x%lx"
38359 D829                        0A            .byte	$A
38360 D82A                        00            .byte	0
38361                       0000D82B            .158:
38362                       0000D82B            .867:
38363 D82B                        25            .ascii	"%s"
38364 D82D                        0A            .byte	$A
38365 D82E                        00            .byte	0
38366                       0000D82F            .157:
38367                       0000D82F            .868:
38368 D82F                        49            .ascii	"INT18: BOOT FAILURE"
38369 D842                        0A            .byte	$A
38370 D843                        00            .byte	0
38371                       0000D844            .156:
38372                       0000D844            .869:
38373 D844                        4E            .ascii	"NMI Handler called"
38374 D856                        0A            .byte	$A
38375 D857                        00            .byte	0
38376                       0000D858            .155:
38377                       0000D858            .86A:
38378 D858                        43            .ascii	"CDROM boot failure code : %04x"
38379 D876                        0A            .byte	$A
38380 D877                        00            .byte	0
38381                       0000D878            .154:
38382                       0000D878            .86B:
38383 D878                        0A            .byte	$A,$A
38384 D87A                        00            .byte	0
38385                       0000D87B            .153:
38386                       0000D87B            .86C:
38387 D87B                        3A            .ascii	": could not read the boot disk"
38388 D899                        00            .byte	0
38389                       0000D89A            .151:
38390                       0000D89A            .86D:
38391 D89A                        3A            .ascii	": not a bootable disk"
38392 D8AF                        00            .byte	0
38393                       0000D8B0            .14C:
38394                       0000D8B0            .86E:
38395 D8B0                        42            .ascii	"Boot failed"
38396 D8BB                        00            .byte	0
38397                       0000D8BC            .14B:
38398                       0000D8BC            .86F:
38399 D8BC                        42            .ascii	"Bad drive type"
38400 D8CA                        0A            .byte	$A
38401 D8CB                        00            .byte	0
38402                       0000D8CC            .147:
38403                       0000D8CC            .870:
38404 D8CC                        2E            .ascii	"..."
38405 D8CF                        0A            .byte	$A
38406 D8D0                        00            .byte	0
38407                       0000D8D1            .146:
38408                       0000D8D1            .871:
38409 D8D1                        20            .ascii	" [%S]"
38410 D8D6                        00            .byte	0
38411                       0000D8D7            .142:
38412                       0000D8D7            .872:
38413 D8D7                        42            .ascii	"Booting from %s"
38414 D8E6                        00            .byte	0
38415                       0000D8E7            .141:
38416                       0000D8E7            .873:
38417 D8E7                        42            .ascii	"Bad drive type"
38418 D8F5                        0A            .byte	$A
38419 D8F6                        00            .byte	0
38420                       0000D8F7            .13B:
38421                       0000D8F7            .874:
38422 D8F7                        0A            .byte	$A
38423 D8F8                        00            .byte	0
38424                       0000D8F9            .12F:
38425                       0000D8F9            .875:
38426 D8F9                        0A            .byte	$A
38427 D8FA                        00            .byte	0
38428                       0000D8FB            .12E:
38429                       0000D8FB            .876:
38430 D8FB                        20            .ascii	" [%S]"
38431 D900                        00            .byte	0
38432                       0000D901            .12B:
38433                       0000D901            .877:
38434 D901                        25            .ascii	"%s"
38435 D903                        00            .byte	0
38436                       0000D904            .129:
38437                       0000D904            .878:
38438 D904                        25            .ascii	"%s"
38439 D906                        0A            .byte	$A
38440 D907                        00            .byte	0
38441                       0000D908            .122:
38442                       0000D908            .879:
38443 D908                        25            .ascii	"%d. "
38444 D90C                        00            .byte	0
38445                       0000D90D            .11D:
38446                       0000D90D            .87A:
38447 D90D                        53            .ascii	"Select boot device:"
38448 D920                        0A            .byte	$A,$A
38449 D922                        00            .byte	0
38450                       0000D923            .114:
38451                       0000D923            .87B:
38452 D923                        50            .ascii	"Press F12 for boot menu."
38453 D93B                        0A            .byte	$A,$A
38454 D93D                        00            .byte	0
38455                       0000D93E            .106:
38456                       0000D93E            .87C:
38457 D93E                        61            .ascii	"apmbios pcibios pnpbios eltorito rombios"
38458 D966                        33            .ascii	"32 "
38459 D969                        0A            .byte	$A,$A
38460 D96B                        00            .byte	0
38461                       0000D96C            .105:
38462                       0000D96C            .87D:
38463 D96C                        30            .ascii	"08/01/21"
38464 D974                        00            .byte	0
38465                       0000D975            .104:
38466                       0000D975            .87E:
38467 D975                        42            .ascii	"Bochs 2.7.svn BIOS - build: %s"
38468 D993                        0A            .byte	$A
38469 D994                        25            .ascii	"%s"
38470 D996                        0A            .byte	$A
38471 D997                        4F            .ascii	"Options: "
38472 D9A0                        00            .byte	0
38473                       0000D9A1            .103:
38474                       0000D9A1            .87F:
38475 D9A1                        52            .ascii	"Returned from s3_resume."
38476 D9B9                        0A            .byte	$A
38477 D9BA                        00            .byte	0
38478                       0000D9BB            .102:
38479                       0000D9BB            .880:
38480 D9BB                        55            .ascii	"Unimplemented shutdown status: %02x"
38481 D9DE                        0A            .byte	$A
38482 D9DF                        00            .byte	0
38483                       0000D9E0            .101:
38484                       0000D9E0            .881:
38485 D9E0                        4B            .ascii	"Keyboard error:%u"
38486 D9F1                        0A            .byte	$A
38487 D9F2                        00            .byte	0
38488                       0000D9F3            .7C:
38489                       0000D9F3            .882:
38490 D9F3                        62            .ascii	"bios_printf: unknown format"
38491 DA0E                        0A            .byte	$A
38492 DA0F                        00            .byte	0
38493                       0000DA10            .38:
38494                       0000DA10            .883:
38495 DA10                        46            .ascii	"FATAL: "
38496 DA17                        00            .byte	0
38497 DA18                                      .bss
38498                                           
38499                                           ! 0 errors detected

Symbols:
..FFD8                       0 FFFC A   
..FFD9                       0 FFE0 A   
..FFDA                       0 FFDC A   
..FFDB                       0 FFDC A   
..FFDC                       0 FFF6 A   
..FFDD                       0 FFC6 A   
..FFDE                       0 FFC6 A   
..FFDF                       0 FFC6 A   
..FFE0                       0 FFC6 A   
..FFE1                       0 FFC6 A   
..FFE2                       0 FFC6 A   
..FFE3                       0 FFFC A   
..FFE4                       0 FFFC A   
..FFE5                       0 FFFC A   
..FFE6                       0 FFE0 A   
..FFE7                       0 FFE0 A   
..FFE8                       0 FFE0 A   
..FFE9                       0 FFE0 A   
..FFEA                       0 FFE0 A   
..FFEB                       0 FFE0 A   
..FFEC                       0 FFDA A   
..FFED                       0 FFDA A   
..FFEE                       0 FFDA A   
..FFEF                       0 FFDA A   
..FFF0                       0 FFDA A   
..FFF1                       0 FFDA A   
..FFF2                       0 FFF8 A   
..FFF3                       0 FFF4 A   
..FFF4                       0 FFF0 A   
..FFF5                       0 FFF0 A   
..FFF6                       0 FFF0 A   
..FFF7                       0 FFEA A   
..FFF8                       0 FFF6 A   
..FFF9                       0 F7E0 A   
..FFFA                       0 FFD4 A   
..FFFB                       0 FDB6 A   
..FFFC                       0 FDB6 A   
..FFFD                       0 FDD8 A   
..FFFE                       0 FDD8 A   
..FFFF                       0 FFC4 A   
.1                           0 016C A   
.10                          0 0712 A   
.100                         0 118E A   
.101                         0 D9E0 A   
.102                         0 D9BB A   
.103                         0 D9A1 A   
.104                         0 D975 A   
.105                         0 D96C A   
.106                         0 D93E A   
.107                         0 120F A   
.108                         0 1219 A   
.109                         0 1223 A   
.10A                         0 122D A   
.10B                         0 1237 A   
.10C                         0 139B A   
.10D                         0 1395 A   
.10E                         0 13DC A   
.10F                         0 13D5 A   
.11                          0 06FC A   
.110                         0 13D2 A   
.111                         0 13DC A   
.112                         0 13EF A   
.113                         0 13EB A   
.114                         0 D923 A   
.115                         0 15B5 A   
.116                         0 1414 A   
.117                         0 15B5 A   
.118                         0 1423 A   
.119                         0 142F A   
.11A                         0 1428 A   
.11B                         0 1425 A   
.11C                         0 142F A   
.11D                         0 D90D A   
.11E                         0 154E A   
.11F                         0 153B A   
.12                          0 0740 A   
.120                         0 1542 A   
.121                         0 1456 A   
.122                         0 D908 A   
.123                         0 153B A   
.125                         0 151F A   
.126                         0 1490 A   
.127                         0 1490 A   
.128                         0 1490 A   
.129                         0 D904 A   
.12A                         0 14B3 A   
.12B                         0 D901 A   
.12C                         0 150D A   
.12D                         0 14DC A   
.12E                         0 D8FB A   
.12F                         0 D8F9 A   
.13                          0 072C A   
.130                         0 154E A   
.131                         0 15A7 A   
.132                         0 15A0 A   
.133                         0 1557 A   
.134                         0 1573 A   
.135                         0 156B A   
.136                         0 1564 A   
.137                         0 15A0 A   
.138                         0 15A0 A   
.139                         0 157D A   
.13A                         0 15A7 A   
.13B                         0 D8F7 A   
.13C                         0 15DB A   
.13D                         0 15D5 A   
.13E                         0 15F8 A   
.13F                         0 15EA A   
.14                          0 0721 A   
.140                         0 15E2 A   
.141                         0 D8E7 A   
.142                         0 D8D7 A   
.143                         0 1671 A   
.144                         0 163A A   
.145                         0 1620 A   
.146                         0 D8D1 A   
.147                         0 D8CC A   
.148                         0 16A2 A   
.149                         0 1695 A   
.14A                         0 168D A   
.14B                         0 D8BC A   
.14C                         0 D8B0 A   
.14D                         0 16DA A   
.14E                         0 16B7 A   
.14F                         0 16CD A   
.15                          0 0714 A   
.150                         0 16BE A   
.151                         0 D89A A   
.152                         0 16DA A   
.153                         0 D87B A   
.154                         0 D878 A   
.155                         0 D858 A   
.156                         0 D844 A   
.157                         0 D82F A   
.158                         0 D82B A   
.159                         0 1764 A   
.15A                         0 1750 A   
.15B                         0 1776 A   
.15C                         0 1783 A   
.15D                         0 1785 A   
.15E                         0 D810 A   
.15F                         0 17FB A   
.16                          0 072C A   
.160                         0 17F5 A   
.161                         0 17E8 A   
.162                         0 D7F7 A   
.163                         0 18BC A   
.164                         0 18AE A   
.165                         0 18B5 A   
.166                         0 186A A   
.167                         0 18BC A   
.168                         0 19EE A   
.169                         0 19DE A   
.16A                         0 19E5 A   
.16B                         0 18C4 A   
.16C                         0 19EE A   
.16D                         0 1A1D A   
.16E                         0 1A0F A   
.16F                         0 1A16 A   
.17                          0 0740 A   
.170                         0 19F5 A   
.171                         0 1A1D A   
.172                         0 1B7E A   
.173                         0 1B7B A   
.174                         0 1A5E A   
.175                         0 1A8D A   
.176                         0 1A82 A   
.177                         0 1B21 A   
.178                         0 1AA9 A   
.179                         0 1A94 A   
.17A                         0 1AA1 A   
.17B                         0 1A9D A   
.17C                         0 1AA3 A   
.17D                         0 1B21 A   
.17E                         0 1ACD A   
.17F                         0 1AB0 A   
.18                          0 0733 A   
.180                         0 1AC6 A   
.181                         0 1AC2 A   
.182                         0 1AB9 A   
.183                         0 1AC8 A   
.184                         0 1B21 A   
.185                         0 1AF1 A   
.186                         0 1AD4 A   
.187                         0 1AEA A   
.188                         0 1AE6 A   
.189                         0 1ADD A   
.18A                         0 1AEC A   
.18B                         0 1B21 A   
.18C                         0 1B15 A   
.18D                         0 1AF8 A   
.18E                         0 1B0E A   
.18F                         0 1B0A A   
.19                          0 07AD A   
.190                         0 1B01 A   
.191                         0 1B10 A   
.192                         0 1B21 A   
.193                         0 1B21 A   
.194                         0 1B1C A   
.195                         0 1B2E A   
.196                         0 1B28 A   
.197                         0 1B3C A   
.198                         0 1B36 A   
.199                         0 1B4C A   
.19A                         0 1B45 A   
.19B                         0 1B7B A   
.19C                         0 1B79 A   
.19D                         0 1B53 A   
.19E                         0 D7E9 A   
.19F                         0 2827 A   
.1A                          0 0794 A   
.1A0                         0 2817 A   
.1A1                         0 281E A   
.1A2                         0 1C0F A   
.1A3                         0 1C6E A   
.1A4                         0 1C6A A   
.1A5                         0 1C70 A   
.1A6                         0 1E35 A   
.1A7                         0 1D1F A   
.1A8                         0 1D15 A   
.1A9                         0 1D48 A   
.1AA                         0 1D44 A   
.1AB                         0 1D4A A   
.1AC                         0 1E35 A   
.1AD                         0 1D90 A   
.1AE                         0 1D86 A   
.1AF                         0 1DE7 A   
.1B                          0 07DB A   
.1B0                         0 1DD3 A   
.1B1                         0 1DCB A   
.1B2                         0 1E35 A   
.1B3                         0 1E13 A   
.1B4                         0 1DFF A   
.1B5                         0 1DF7 A   
.1B6                         0 1DEF A   
.1B7                         0 1E35 A   
.1B8                         0 1E35 A   
.1B9                         0 1E23 A   
.1BA                         0 1E1B A   
.1BB                         0 231D A   
.1BC                         0 1E51 A   
.1BD                         0 1EBF A   
.1BE                         0 1EB1 A   
.1BF                         0 D7C0 A   
.1C                          0 07C7 A   
.1C0                         0 1EE7 A   
.1C1                         0 1EE3 A   
.1C2                         0 1EE9 A   
.1C3                         0 1F60 A   
.1C4                         0 1F36 A   
.1C5                         0 1F80 A   
.1C6                         0 D79B A   
.1C7                         0 20AB A   
.1C8                         0 209A A   
.1C9                         0 20A3 A   
.1CA                         0 208C A   
.1CB                         0 20AB A   
.1CC                         0 2121 A   
.1CE                         0 2111 A   
.1CF                         0 20CF A   
.1D                          0 07BC A   
.1D0                         0 D796 A   
.1D1                         0 20DF A   
.1D2                         0 D792 A   
.1D3                         0 20EF A   
.1D4                         0 D78C A   
.1D5                         0 20FF A   
.1D6                         0 D785 A   
.1D7                         0 229F A   
.1D9                         0 2289 A   
.1DA                         0 2128 A   
.1DB                         0 212B A   
.1DC                         0 2182 A   
.1DD                         0 2179 A   
.1DE                         0 21BF A   
.1DF                         0 2194 A   
.1E                          0 07AF A   
.1E0                         0 218B A   
.1E1                         0 21BF A   
.1E2                         0 21A6 A   
.1E3                         0 219D A   
.1E4                         0 21BF A   
.1E5                         0 21B8 A   
.1E6                         0 21AF A   
.1E7                         0 21BF A   
.1E8                         0 21E0 A   
.1E9                         0 225B A   
.1EA                         0 21E9 A   
.1EB                         0 2214 A   
.1EC                         0 220D A   
.1ED                         0 225B A   
.1EE                         0 2285 A   
.1EF                         0 227C A   
.1F                          0 07C7 A   
.1F0                         0 225D A   
.1F1                         0 227C A   
.1F2                         0 227A A   
.1F3                         0 2285 A   
.1F4                         0 22AF A   
.1F5                         0 22A8 A   
.1F6                         0 D775 A   
.1F7                         0 2445 A   
.1F8                         0 2326 A   
.1F9                         0 2394 A   
.1FA                         0 2386 A   
.1FB                         0 D74A A   
.1FC                         0 23B8 A   
.1FD                         0 23B4 A   
.1FE                         0 23BA A   
.1FF                         0 23D0 A   
.2                           0 05A7 A   
.20                          0 07DB A   
.200                         0 23CC A   
.201                         0 23D2 A   
.202                         0 266D A   
.204                         0 2661 A   
.205                         0 244E A   
.206                         0 248A A   
.208                         0 247E A   
.209                         0 2454 A   
.20A                         0 2462 A   
.20B                         0 2470 A   
.20C                         0 24EA A   
.20D                         0 2541 A   
.20E                         0 2530 A   
.20F                         0 2539 A   
.21                          0 07CE A   
.210                         0 2517 A   
.211                         0 2530 A   
.212                         0 252E A   
.213                         0 2541 A   
.214                         0 25BA A   
.215                         0 25A9 A   
.216                         0 25B2 A   
.217                         0 2549 A   
.218                         0 25BA A   
.219                         0 2615 A   
.21A                         0 2604 A   
.21B                         0 260D A   
.21C                         0 25D0 A   
.21D                         0 2602 A   
.21E                         0 25E8 A   
.21F                         0 2604 A   
.22                          0 084E A   
.220                         0 2615 A   
.221                         0 265D A   
.222                         0 261D A   
.223                         0 265D A   
.224                         0 264C A   
.225                         0 2655 A   
.226                         0 2633 A   
.227                         0 265D A   
.228                         0 2811 A   
.22A                         0 2801 A   
.22B                         0 2673 A   
.22C                         0 D73F A   
.22D                         0 D738 A   
.22E                         0 D731 A   
.22F                         0 2680 A   
.23                          0 083B A   
.230                         0 267B A   
.231                         0 2683 A   
.232                         0 26D8 A   
.233                         0 26B6 A   
.234                         0 26A1 A   
.235                         0 D72E A   
.236                         0 26D8 A   
.237                         0 2701 A   
.238                         0 26E6 A   
.239                         0 D70E A   
.23A                         0 272D A   
.23B                         0 D6EE A   
.23C                         0 2730 A   
.23D                         0 D6E3 A   
.23E                         0 D6DC A   
.23F                         0 D6D5 A   
.24                          0 0825 A   
.240                         0 273D A   
.241                         0 2738 A   
.242                         0 2740 A   
.243                         0 2795 A   
.244                         0 2773 A   
.245                         0 275E A   
.246                         0 D6D2 A   
.247                         0 2795 A   
.248                         0 27C0 A   
.249                         0 27A9 A   
.24A                         0 D6B8 A   
.24B                         0 27D5 A   
.24C                         0 D6A6 A   
.24D                         0 27D7 A   
.24E                         0 D68C A   
.24F                         0 D685 A   
.25                          0 084E A   
.250                         0 D67E A   
.251                         0 27E4 A   
.252                         0 27DF A   
.253                         0 27E7 A   
.254                         0 2827 A   
.255                         0 D67C A   
.256                         0 296D A   
.257                         0 28E9 A   
.258                         0 28F4 A   
.259                         0 28F0 A   
.25A                         0 28F6 A   
.25B                         0 295C A   
.25C                         0 2931 A   
.25D                         0 292A A   
.25E                         0 294B A   
.25F                         0 2938 A   
.26                          0 08F0 A   
.260                         0 295C A   
.261                         0 29EC A   
.262                         0 29E4 A   
.263                         0 29DC A   
.264                         0 29FD A   
.265                         0 2A10 A   
.266                         0 2A04 A   
.267                         0 2A18 A   
.268                         0 2A4C A   
.269                         0 2A45 A   
.26A                         0 2B5B A   
.26B                         0 2A66 A   
.26C                         0 2B2D A   
.26D                         0 2AA7 A   
.26E                         0 2A88 A   
.26F                         0 2A7D A   
.27                          0 08E4 A   
.270                         0 2A71 A   
.271                         0 2A73 A   
.273                         0 2BB9 A   
.274                         0 2BB5 A   
.275                         0 2BBB A   
.276                         0 2C10 A   
.277                         0 2C07 A   
.278                         0 2C20 A   
.279                         0 2C20 A   
.27A                         0 2C19 A   
.27B                         0 2D37 A   
.27C                         0 2D34 A   
.27D                         0 2C21 A   
.27E                         0 2C5E A   
.27F                         0 2C28 A   
.28                          0 0876 A   
.280                         0 2C94 A   
.281                         0 2CC2 A   
.282                         0 2CB1 A   
.283                         0 2D07 A   
.284                         0 2CD8 A   
.285                         0 2CF3 A   
.286                         0 2CDF A   
.287                         0 2CEF A   
.288                         0 2CE8 A   
.289                         0 2D05 A   
.28A                         0 2D03 A   
.28B                         0 2CFC A   
.28C                         0 2D34 A   
.28D                         0 2D22 A   
.28E                         0 2D0E A   
.28F                         0 2D1E A   
.29                          0 08B8 A   
.290                         0 2D17 A   
.291                         0 2D34 A   
.292                         0 2D32 A   
.293                         0 2D2B A   
.294                         0 2D37 A   
.295                         0 2D88 A   
.296                         0 2D73 A   
.297                         0 D650 A   
.298                         0 2D98 A   
.299                         0 2D91 A   
.29A                         0 2DEE A   
.29B                         0 2DE9 A   
.29C                         0 2DFA A   
.29D                         0 2DF5 A   
.29E                         0 2E3B A   
.29F                         0 2E34 A   
.2A                          0 0892 A   
.2A0                         0 2EA6 A   
.2A1                         0 2EA2 A   
.2A2                         0 2EA8 A   
.2A3                         0 2EFB A   
.2A4                         0 2EF2 A   
.2A5                         0 2F0B A   
.2A6                         0 2F0B A   
.2A7                         0 2F04 A   
.2A8                         0 2F62 A   
.2A9                         0 2F3F A   
.2AA                         0 31D1 A   
.2AB                         0 31CE A   
.2AC                         0 31CB A   
.2AD                         0 2F6B A   
.2AE                         0 2F94 A   
.2AF                         0 2F72 A   
.2B                          0 08D8 A   
.2B0                         0 2FA5 A   
.2B1                         0 2FE6 A   
.2B2                         0 2FE3 A   
.2B3                         0 2FDA A   
.2B4                         0 2FF6 A   
.2B5                         0 2FEF A   
.2B6                         0 3049 A   
.2B7                         0 3033 A   
.2B8                         0 305D A   
.2B9                         0 308A A   
.2BA                         0 306A A   
.2BB                         0 30AB A   
.2BC                         0 30C5 A   
.2BD                         0 30C0 A   
.2BE                         0 30D3 A   
.2BF                         0 30CE A   
.2C                          0 08D8 A   
.2C0                         0 30E1 A   
.2C1                         0 30DC A   
.2C2                         0 3108 A   
.2C3                         0 30EA A   
.2C4                         0 3108 A   
.2C5                         0 3101 A   
.2C6                         0 30F8 A   
.2C7                         0 312F A   
.2C8                         0 310F A   
.2C9                         0 3147 A   
.2CA                         0 31CE A   
.2CB                         0 31E1 A   
.2CC                         0 31DA A   
.2CD                         0 3253 A   
.2CE                         0 324C A   
.2CF                         0 32BA A   
.2D                          0 08C6 A   
.2D0                         0 32A5 A   
.2D1                         0 D62A A   
.2D2                         0 33AC A   
.2D3                         0 339C A   
.2D4                         0 32F1 A   
.2D5                         0 3326 A   
.2D6                         0 3320 A   
.2D7                         0 3380 A   
.2D8                         0 333F A   
.2D9                         0 334D A   
.2DA                         0 3346 A   
.2DB                         0 3380 A   
.2DC                         0 3362 A   
.2DD                         0 335B A   
.2DE                         0 3354 A   
.2DF                         0 D602 A   
.2E                          0 08F0 A   
.2E0                         0 33AC A   
.2E1                         0 3416 A   
.2E2                         0 33FB A   
.2E3                         0 33E3 A   
.2E4                         0 D5E6 A   
.2E5                         0 3476 A   
.2E6                         0 3464 A   
.2E7                         0 34BC A   
.2E8                         0 3498 A   
.2E9                         0 D5D0 A   
.2EA                         0 34F8 A   
.2EB                         0 34F2 A   
.2EC                         0 351C A   
.2ED                         0 3516 A   
.2EE                         0 3540 A   
.2EF                         0 353A A   
.2F                          0 093A A   
.2F0                         0 359E A   
.2F1                         0 35A4 A   
.2F2                         0 35F6 A   
.2F3                         0 35E5 A   
.2F4                         0 35EE A   
.2F5                         0 35D3 A   
.2F6                         0 35E5 A   
.2F7                         0 35E3 A   
.2F8                         0 35F6 A   
.2F9                         0 3605 A   
.2FA                         0 35FE A   
.2FB                         0 3637 A   
.2FC                         0 3625 A   
.2FD                         0 3619 A   
.2FE                         0 361B A   
.2FF                         0 D5B6 A   
.3                           0 059C A   
.30                          0 092B A   
.300                         0 36AE A   
.301                         0 36A7 A   
.302                         0 36BD A   
.303                         0 36B6 A   
.304                         0 3709 A   
.305                         0 36F7 A   
.306                         0 3700 A   
.307                         0 36C5 A   
.308                         0 36F7 A   
.309                         0 36F0 A   
.30A                         0 3709 A   
.30B                         0 3757 A   
.30C                         0 3745 A   
.30D                         0 374E A   
.30E                         0 3711 A   
.30F                         0 3745 A   
.31                          0 0932 A   
.310                         0 373E A   
.311                         0 3757 A   
.312                         0 37E6 A   
.313                         0 37DF A   
.314                         0 37F5 A   
.315                         0 37EE A   
.316                         0 3804 A   
.317                         0 37FD A   
.318                         0 3813 A   
.319                         0 380C A   
.31A                         0 3822 A   
.31B                         0 381B A   
.31C                         0 3831 A   
.31D                         0 382A A   
.31E                         0 3852 A   
.31F                         0 384B A   
.32                          0 091A A   
.320                         0 3866 A   
.321                         0 3861 A   
.322                         0 385A A   
.323                         0 3866 A   
.324                         0 3893 A   
.325                         0 388C A   
.326                         0 3980 A   
.327                         0 3971 A   
.328                         0 3A37 A   
.32A                         0 3A21 A   
.32B                         0 3986 A   
.32C                         0 399B A   
.32D                         0 39B0 A   
.32E                         0 39C4 A   
.32F                         0 3A71 A   
.33                          0 092B A   
.330                         0 3A3E A   
.331                         0 3A68 A   
.332                         0 3A45 A   
.333                         0 3A71 A   
.334                         0 3A7D A   
.335                         0 3A78 A   
.336                         0 3CBC A   
.337                         0 3ACF A   
.338                         0 3AC6 A   
.339                         0 3CBA A   
.33B                         0 3CA2 A   
.33C                         0 3AD5 A   
.33D                         0 3B1A A   
.33E                         0 3AFC A   
.33F                         0 3B51 A   
.34                          0 0929 A   
.340                         0 3B8F A   
.341                         0 3BCB A   
.342                         0 3BB2 A   
.343                         0 3B97 A   
.344                         0 3BB2 A   
.345                         0 3BA5 A   
.346                         0 3BCB A   
.347                         0 3BC4 A   
.348                         0 3BF2 A   
.349                         0 3BD2 A   
.34A                         0 3BF7 A   
.34B                         0 3C02 A   
.34C                         0 3C3E A   
.34D                         0 3C25 A   
.34E                         0 3C0A A   
.34F                         0 3C25 A   
.35                          0 093A A   
.350                         0 3C18 A   
.351                         0 3C3E A   
.352                         0 3C37 A   
.353                         0 3C61 A   
.354                         0 3C45 A   
.355                         0 3C66 A   
.356                         0 3C70 A   
.357                         0 3C98 A   
.358                         0 3CC4 A   
.359                         0 41AE A   
.35B                         0 4164 A   
.35C                         0 3CDC A   
.35D                         0 3D68 A   
.35F                         0 3D56 A   
.36                          0 0987 A   
.360                         0 3CE2 A   
.361                         0 3CE2 A   
.362                         0 3CFD A   
.363                         0 3D1E A   
.364                         0 3D33 A   
.365                         0 D576 A   
.366                         0 3D6B A   
.367                         0 3D7B A   
.368                         0 3D86 A   
.369                         0 3D96 A   
.36A                         0 3E25 A   
.36B                         0 3DA8 A   
.36C                         0 3E16 A   
.36D                         0 3DB3 A   
.36E                         0 3E23 A   
.36F                         0 3E6D A   
.37                          0 096C A   
.370                         0 3E59 A   
.371                         0 3E2C A   
.372                         0 3E6D A   
.373                         0 3E70 A   
.374                         0 3EAB A   
.375                         0 3EA4 A   
.376                         0 3FF8 A   
.377                         0 401E A   
.378                         0 4018 A   
.379                         0 4029 A   
.37A                         0 40D7 A   
.37B                         0 D547 A   
.37C                         0 40F5 A   
.37D                         0 4111 A   
.37E                         0 4122 A   
.37F                         0 D530 A   
.38                          0 DA10 A   
.380                         0 413F A   
.381                         0 D4F6 A   
.382                         0 4833 A   
.384                         0 482B A   
.385                         0 41C6 A   
.386                         0 4804 A   
.388                         0 47DF A   
.389                         0 41CC A   
.38A                         0 42C9 A   
.38C                         0 42BB A   
.38D                         0 41D2 A   
.38E                         0 4213 A   
.38F                         0 41E8 A   
.39                          0 0C4A A   
.390                         0 4213 A   
.391                         0 4202 A   
.392                         0 41FB A   
.393                         0 4228 A   
.394                         0 4252 A   
.395                         0 4241 A   
.396                         0 4296 A   
.397                         0 4268 A   
.398                         0 4296 A   
.399                         0 4282 A   
.39A                         0 427B A   
.39B                         0 42A8 A   
.39C                         0 42CC A   
.39D                         0 42CC A   
.39E                         0 4345 A   
.39F                         0 42D5 A   
.3A                          0 0C3C A   
.3A0                         0 42F4 A   
.3A1                         0 42E3 A   
.3A2                         0 42DC A   
.3A3                         0 43E4 A   
.3A4                         0 435D A   
.3A5                         0 437C A   
.3A6                         0 4370 A   
.3A7                         0 4397 A   
.3A8                         0 4383 A   
.3A9                         0 D4CB A   
.3AA                         0 43E4 A   
.3AB                         0 439E A   
.3AC                         0 43E4 A   
.3AD                         0 43B1 A   
.3AE                         0 43E4 A   
.3AF                         0 43C4 A   
.3B                          0 098A A   
.3B0                         0 43F6 A   
.3B1                         0 4457 A   
.3B3                         0 4434 A   
.3B4                         0 43FB A   
.3B5                         0 4402 A   
.3B6                         0 4409 A   
.3B7                         0 4410 A   
.3B8                         0 4417 A   
.3B9                         0 441E A   
.3BA                         0 4425 A   
.3BB                         0 442D A   
.3BC                         0 4455 A   
.3BD                         0 4447 A   
.3BE                         0 44B5 A   
.3BF                         0 445E A   
.3C                          0 099F A   
.3C0                         0 44A6 A   
.3C1                         0 4471 A   
.3C2                         0 44B3 A   
.3C3                         0 44C2 A   
.3C4                         0 44C5 A   
.3C5                         0 4561 A   
.3C6                         0 44D4 A   
.3C7                         0 4552 A   
.3C8                         0 44E7 A   
.3C9                         0 450E A   
.3CA                         0 44FA A   
.3CB                         0 D49F A   
.3CC                         0 4543 A   
.3CD                         0 452F A   
.3CE                         0 D473 A   
.3CF                         0 455F A   
.3D                          0 0991 A   
.3D0                         0 456E A   
.3D1                         0 457C A   
.3D2                         0 45BF A   
.3D3                         0 4592 A   
.3D4                         0 45CC A   
.3D5                         0 45CF A   
.3D6                         0 4743 A   
.3D8                         0 472F A   
.3D9                         0 45D5 A   
.3DA                         0 4685 A   
.3DB                         0 45F0 A   
.3DC                         0 4617 A   
.3DD                         0 4603 A   
.3DE                         0 D447 A   
.3DF                         0 4685 A   
.3E                          0 0C35 A   
.3E0                         0 461E A   
.3E1                         0 4685 A   
.3E2                         0 4631 A   
.3E3                         0 4685 A   
.3E4                         0 4644 A   
.3E5                         0 4685 A   
.3E6                         0 4657 A   
.3E7                         0 46A2 A   
.3E8                         0 46A2 A   
.3E9                         0 46BD A   
.3EA                         0 46AF A   
.3EB                         0 46C9 A   
.3EC                         0 46E9 A   
.3ED                         0 46D0 A   
.3EE                         0 46E4 A   
.3EF                         0 46E6 A   
.3F                          0 0C26 A   
.3F0                         0 46FF A   
.3F1                         0 46F0 A   
.3F2                         0 470C A   
.3F3                         0 4719 A   
.3F4                         0 D42D A   
.3F5                         0 4746 A   
.3F6                         0 47A6 A   
.3F7                         0 4790 A   
.3F8                         0 4789 A   
.3F9                         0 47A4 A   
.3FA                         0 4799 A   
.3FB                         0 47AE A   
.3FC                         0 47D0 A   
.3FD                         0 4802 A   
.3FE                         0 47F2 A   
.3FF                         0 4806 A   
.4                           0 0587 A   
.40                          0 09A8 A   
.400                         0 D3F3 A   
.401                         0 4D96 A   
.403                         0 4D88 A   
.404                         0 4901 A   
.405                         0 4947 A   
.406                         0 4D61 A   
.408                         0 4D55 A   
.409                         0 494D A   
.40A                         0 4CF3 A   
.40B                         0 4968 A   
.40C                         0 49B6 A   
.40D                         0 49AA A   
.40E                         0 4A4B A   
.40F                         0 49FB A   
.41                          0 09D7 A   
.410                         0 4CD2 A   
.412                         0 4CAD A   
.413                         0 4A7A A   
.414                         0 4AAC A   
.415                         0 4ADF A   
.416                         0 4B1E A   
.417                         0 4B11 A   
.418                         0 4B29 A   
.419                         0 4B2C A   
.41A                         0 4B6F A   
.41B                         0 4BDB A   
.41C                         0 4C1D A   
.41D                         0 4C64 A   
.41E                         0 4C57 A   
.41F                         0 4C4C A   
.42                          0 09B6 A   
.420                         0 4C6E A   
.421                         0 4C70 A   
.422                         0 4CA3 A   
.423                         0 4CD0 A   
.424                         0 4CC0 A   
.425                         0 4CF8 A   
.426                         0 4CFA A   
.427                         0 4D28 A   
.428                         0 4D22 A   
.429                         0 4D4E A   
.42A                         0 4D63 A   
.42B                         0 D3B9 A   
.42C                         0 4E5D A   
.42D                         0 4DC8 A   
.42E                         0 4DF6 A   
.42F                         0 4DE7 A   
.43                          0 09AF A   
.430                         0 4DD9 A   
.431                         0 4DF6 A   
.432                         0 4E5C A   
.433                         0 4E03 A   
.434                         0 4E4D A   
.435                         0 4E3E A   
.436                         0 4E30 A   
.437                         0 4E4D A   
.438                         0 5146 A   
.43A                         0 50FF A   
.43B                         0 4E63 A   
.43C                         0 4E87 A   
.43D                         0 4E79 A   
.43E                         0 D395 A   
.43F                         0 4E9C A   
.44                          0 0C24 A   
.440                         0 4E95 A   
.441                         0 4E8E A   
.442                         0 4EA8 A   
.443                         0 4EA8 A   
.444                         0 4EA3 A   
.445                         0 4EBA A   
.446                         0 4EDB A   
.447                         0 4ECF A   
.448                         0 4EF0 A   
.449                         0 4EE9 A   
.44A                         0 4EE2 A   
.44B                         0 4EFC A   
.44C                         0 4EFC A   
.44D                         0 4EF7 A   
.44E                         0 4F16 A   
.44F                         0 4F25 A   
.45                          0 0A57 A   
.450                         0 4F42 A   
.451                         0 4F3B A   
.452                         0 4F47 A   
.453                         0 4F4A A   
.454                         0 4F52 A   
.455                         0 4F99 A   
.456                         0 4F7F A   
.457                         0 4F72 A   
.458                         0 4F99 A   
.459                         0 4F8E A   
.45A                         0 500D A   
.45B                         0 4FA0 A   
.45C                         0 500D A   
.45D                         0 4FAD A   
.45E                         0 500D A   
.45F                         0 5002 A   
.46                          0 09F3 A   
.460                         0 4FAD A   
.461                         0 4FDC A   
.462                         0 4FC2 A   
.463                         0 4FB5 A   
.464                         0 4FDC A   
.465                         0 4FD1 A   
.466                         0 5002 A   
.467                         0 4FE3 A   
.468                         0 500D A   
.469                         0 5016 A   
.46A                         0 503A A   
.46B                         0 502C A   
.46C                         0 D371 A   
.46D                         0 504D A   
.46E                         0 5048 A   
.46F                         0 5041 A   
.47                          0 0A00 A   
.470                         0 505F A   
.471                         0 5080 A   
.472                         0 5074 A   
.473                         0 5093 A   
.474                         0 508E A   
.475                         0 5087 A   
.476                         0 50AD A   
.477                         0 50D4 A   
.478                         0 50DB A   
.479                         0 50DD A   
.47A                         0 50E9 A   
.47B                         0 50E4 A   
.47C                         0 50E9 A   
.47D                         0 D349 A   
.47E                         0 5138 A   
.47F                         0 5112 A   
.48                          0 09FA A   
.480                         0 51CD A   
.481                         0 5170 A   
.482                         0 51C4 A   
.483                         0 51A8 A   
.484                         0 51BE A   
.485                         0 51B8 A   
.486                         0 51D3 A   
.487                         0 51D7 A   
.488                         0 521D A   
.489                         0 520B A   
.48A                         0 D33E A   
.48B                         0 523C A   
.48C                         0 522D A   
.48D                         0 522D A   
.48E                         0 523C A   
.48F                         0 526F A   
.49                          0 0A54 A   
.490                         0 525D A   
.491                         0 D333 A   
.492                         0 52CA A   
.493                         0 52B8 A   
.494                         0 D329 A   
.495                         0 52E9 A   
.496                         0 52DA A   
.497                         0 52DA A   
.498                         0 52E9 A   
.499                         0 5316 A   
.49A                         0 5304 A   
.49B                         0 D31F A   
.49C                         0 536E A   
.49D                         0 535C A   
.49E                         0 D315 A   
.49F                         0 53A8 A   
.4A                          0 0A46 A   
.4A0                         0 5399 A   
.4A1                         0 5399 A   
.4A2                         0 53A8 A   
.4A3                         0 53EC A   
.4A4                         0 53DB A   
.4A5                         0 D30A A   
.4A6                         0 543C A   
.4A7                         0 542A A   
.4A8                         0 D2F0 A   
.4A9                         0 5966 A   
.4AB                         0 590F A   
.4AC                         0 5459 A   
.4AD                         0 5478 A   
.4AE                         0 5489 A   
.4AF                         0 549A A   
.4B                          0 0A4D A   
.4B0                         0 54AB A   
.4B1                         0 54BC A   
.4B2                         0 54CD A   
.4B3                         0 550B A   
.4B4                         0 54D6 A   
.4B5                         0 54FD A   
.4B6                         0 54ED A   
.4B7                         0 550B A   
.4B8                         0 550E A   
.4B9                         0 554C A   
.4BA                         0 5517 A   
.4BB                         0 553E A   
.4BC                         0 552E A   
.4BD                         0 554C A   
.4BE                         0 554F A   
.4BF                         0 5576 A   
.4C                          0 0A09 A   
.4C0                         0 5566 A   
.4C1                         0 5584 A   
.4C2                         0 5587 A   
.4C3                         0 55AE A   
.4C4                         0 559E A   
.4C5                         0 55BC A   
.4C6                         0 55BF A   
.4C7                         0 55E4 A   
.4C8                         0 55C8 A   
.4C9                         0 55E7 A   
.4CA                         0 55FE A   
.4CB                         0 55F0 A   
.4CC                         0 5601 A   
.4CD                         0 5645 A   
.4CE                         0 561C A   
.4CF                         0 560A A   
.4D                          0 0A30 A   
.4D0                         0 5613 A   
.4D1                         0 5661 A   
.4D2                         0 5664 A   
.4D3                         0 5681 A   
.4D4                         0 567F A   
.4D5                         0 566D A   
.4D6                         0 5676 A   
.4D7                         0 568F A   
.4D8                         0 5692 A   
.4D9                         0 569E A   
.4DA                         0 569B A   
.4DB                         0 56BD A   
.4DC                         0 56A5 A   
.4DD                         0 D2B9 A   
.4DE                         0 56D8 A   
.4DF                         0 56C4 A   
.4E                          0 0A28 A   
.4E0                         0 56D8 A   
.4E1                         0 56CD A   
.4E2                         0 5727 A   
.4E3                         0 56EA A   
.4E4                         0 58D4 A   
.4E5                         0 576D A   
.4E6                         0 5730 A   
.4E7                         0 58D4 A   
.4E8                         0 57A8 A   
.4E9                         0 5784 A   
.4EA                         0 5776 A   
.4EB                         0 577D A   
.4EC                         0 58D4 A   
.4ED                         0 5845 A   
.4EE                         0 57B3 A   
.4EF                         0 5808 A   
.4F                          0 0A3C A   
.4F0                         0 57D2 A   
.4F1                         0 5842 A   
.4F2                         0 58D4 A   
.4F3                         0 58A0 A   
.4F4                         0 5864 A   
.4F5                         0 58D4 A   
.4F6                         0 58F9 A   
.4F7                         0 58EB A   
.4F8                         0 58E4 A   
.4F9                         0 D282 A   
.4FA                         0 5977 A   
.4FB                         0 596F A   
.4FC                         0 59CF A   
.4FD                         0 59C9 A   
.4FE                         0 59E5 A   
.4FF                         0 59D7 A   
.5                           0 059C A   
.50                          0 0A54 A   
.500                         0 5A31 A   
.501                         0 5A2D A   
.502                         0 5A56 A   
.503                         0 5A52 A   
.504                         0 5AD5 A   
.505                         0 5A7B A   
.506                         0 5AA2 A   
.507                         0 5A82 A   
.508                         0 5ABA A   
.509                         0 5AD3 A   
.50A                         0 5ACD A   
.50B                         0 5ADC A   
.50C                         0 5B23 A   
.50D                         0 5B25 A   
.50E                         0 5B39 A   
.50F                         0 5B32 A   
.51                          0 0C1F A   
.510                         0 5D1E A   
.511                         0 5B43 A   
.512                         0 5C4E A   
.513                         0 5B73 A   
.514                         0 5C48 A   
.515                         0 5C3B A   
.516                         0 5BEB A   
.517                         0 5C2C A   
.518                         0 5C2E A   
.51A                         0 5C4E A   
.51B                         0 5C85 A   
.51C                         0 5C55 A   
.51D                         0 5EE4 A   
.51E                         0 5D28 A   
.51F                         0 5DDA A   
.52                          0 0A73 A   
.520                         0 5DD6 A   
.521                         0 5DDC A   
.522                         0 5E3E A   
.523                         0 5DEF A   
.524                         0 5DFA A   
.525                         0 5DF6 A   
.526                         0 5DFC A   
.527                         0 5E13 A   
.528                         0 5E0F A   
.529                         0 5E15 A   
.52A                         0 5E2E A   
.52B                         0 5E2A A   
.52C                         0 5E30 A   
.52D                         0 5E55 A   
.52E                         0 5E45 A   
.52F                         0 5ED0 A   
.53                          0 0A5E A   
.530                         0 5EC2 A   
.531                         0 5EC9 A   
.532                         0 5EAC A   
.533                         0 5ED0 A   
.534                         0 6155 A   
.535                         0 5EEE A   
.536                         0 5F3D A   
.537                         0 5F39 A   
.538                         0 5F3F A   
.539                         0 5F92 A   
.53A                         0 5F68 A   
.53B                         0 5F92 A   
.53C                         0 5FED A   
.53D                         0 5F9B A   
.53E                         0 6044 A   
.53F                         0 6044 A   
.54                          0 0C1F A   
.540                         0 5FF4 A   
.541                         0 6071 A   
.542                         0 604B A   
.543                         0 6071 A   
.544                         0 60CE A   
.545                         0 60B0 A   
.546                         0 60E1 A   
.547                         0 60D5 A   
.548                         0 60EB A   
.549                         0 6128 A   
.54A                         0 610F A   
.54B                         0 6116 A   
.54C                         0 60F7 A   
.54D                         0 6128 A   
.54E                         0 6121 A   
.54F                         0 611D A   
.55                          0 0B7E A   
.550                         0 6123 A   
.551                         0 6147 A   
.552                         0 613A A   
.553                         0 6152 A   
.554                         0 61A0 A   
.555                         0 6180 A   
.556                         0 6179 A   
.557                         0 D24B A   
.558                         0 61D8 A   
.559                         0 61B8 A   
.55A                         0 D20D A   
.55B                         0 68C7 A   
.55D                         0 684C A   
.55E                         0 61DE A   
.55F                         0 61F2 A   
.56                          0 0A7C A   
.560                         0 6229 A   
.561                         0 6221 A   
.562                         0 622F A   
.563                         0 6232 A   
.564                         0 6232 A   
.565                         0 6232 A   
.566                         0 62A2 A   
.567                         0 6288 A   
.568                         0 6281 A   
.569                         0 627A A   
.56A                         0 D1D5 A   
.56B                         0 6316 A   
.56C                         0 62F3 A   
.56D                         0 62EB A   
.56E                         0 62E3 A   
.56F                         0 D18D A   
.57                          0 0AED A   
.570                         0 6323 A   
.571                         0 631D A   
.572                         0 63CB A   
.573                         0 6359 A   
.574                         0 6351 A   
.575                         0 6408 A   
.576                         0 63D2 A   
.577                         0 643D A   
.578                         0 646F A   
.579                         0 644A A   
.57A                         0 D160 A   
.57B                         0 6478 A   
.57C                         0 D146 A   
.57D                         0 6493 A   
.57E                         0 6513 A   
.57F                         0 6541 A   
.58                          0 0AAB A   
.580                         0 6539 A   
.581                         0 654C A   
.582                         0 654F A   
.583                         0 65CE A   
.584                         0 65E8 A   
.585                         0 65E8 A   
.586                         0 65E8 A   
.587                         0 65E8 A   
.588                         0 666E A   
.589                         0 6654 A   
.58A                         0 D115 A   
.58B                         0 66D8 A   
.58C                         0 66BE A   
.58D                         0 66A2 A   
.58E                         0 D0E4 A   
.58F                         0 66EC A   
.59                          0 0AD5 A   
.590                         0 66E6 A   
.591                         0 66DF A   
.592                         0 6729 A   
.593                         0 66F3 A   
.594                         0 675E A   
.595                         0 67A2 A   
.596                         0 677D A   
.597                         0 D0B7 A   
.598                         0 67AB A   
.599                         0 67AB A   
.59A                         0 67B4 A   
.59B                         0 67C2 A   
.59C                         0 67DE A   
.59D                         0 67D8 A   
.59E                         0 67E7 A   
.59F                         0 680E A   
.5A                          0 0AB5 A   
.5A1                         0 67FC A   
.5A2                         0 67EC A   
.5A3                         0 67EC A   
.5A4                         0 67EC A   
.5A5                         0 67EC A   
.5A6                         0 67F4 A   
.5A7                         0 6811 A   
.5A8                         0 6811 A   
.5A9                         0 6811 A   
.5AA                         0 6811 A   
.5AB                         0 6811 A   
.5AC                         0 D078 A   
.5AD                         0 682E A   
.5AE                         0 682E A   
.5AF                         0 682E A   
.5B                          0 0AEA A   
.5B0                         0 682E A   
.5B1                         0 682E A   
.5B2                         0 D03E A   
.5B3                         0 6891 A   
.5B4                         0 685F A   
.5B5                         0 68C4 A   
.5B6                         0 68A4 A   
.5B7                         0 6953 A   
.5B8                         0 6933 A   
.5B9                         0 692C A   
.5BA                         0 D00A A   
.5BB                         0 698B A   
.5BC                         0 696B A   
.5BD                         0 CFCF A   
.5BE                         0 6DBC A   
.5C                          0 0B7B A   
.5C0                         0 6D41 A   
.5C1                         0 6991 A   
.5C2                         0 6991 A   
.5C3                         0 6991 A   
.5C4                         0 6991 A   
.5C5                         0 6991 A   
.5C6                         0 6991 A   
.5C7                         0 6991 A   
.5C8                         0 6991 A   
.5C9                         0 699A A   
.5CA                         0 699A A   
.5CB                         0 699A A   
.5CC                         0 69A8 A   
.5CD                         0 69DF A   
.5CE                         0 69D7 A   
.5CF                         0 69E5 A   
.5D                          0 0B0B A   
.5D0                         0 69E8 A   
.5D1                         0 69F6 A   
.5D2                         0 6A10 A   
.5D3                         0 6A10 A   
.5D4                         0 6A10 A   
.5D5                         0 6A91 A   
.5D6                         0 6A77 A   
.5D7                         0 CF9D A   
.5D8                         0 6ABD A   
.5D9                         0 6AB7 A   
.5DA                         0 6AB0 A   
.5DB                         0 6B98 A   
.5DC                         0 6B73 A   
.5DD                         0 CF72 A   
.5DE                         0 6BA1 A   
.5DF                         0 6BAE A   
.5E                          0 0AF4 A   
.5E0                         0 6BA8 A   
.5E1                         0 6C6A A   
.5E3                         0 6C5C A   
.5E4                         0 6BC7 A   
.5E5                         0 6BDE A   
.5E6                         0 6BCE A   
.5E7                         0 6C02 A   
.5E8                         0 6C19 A   
.5E9                         0 6C09 A   
.5EA                         0 6C41 A   
.5EB                         0 6C3D A   
.5EC                         0 6C43 A   
.5ED                         0 6C48 A   
.5EE                         0 6C53 A   
.5EF                         0 6C4F A   
.5F                          0 0B7B A   
.5F0                         0 6C55 A   
.5F1                         0 6C73 A   
.5F2                         0 6C98 A   
.5F3                         0 6C8D A   
.5F4                         0 6CBD A   
.5F5                         0 6CB2 A   
.5F6                         0 6CC6 A   
.5F7                         0 6CE2 A   
.5F8                         0 6CDC A   
.5F9                         0 6CEB A   
.5FA                         0 6CF9 A   
.5FB                         0 6D20 A   
.5FD                         0 6D0E A   
.5FE                         0 6CFE A   
.5FF                         0 6CFE A   
.6                           0 0596 A   
.60                          0 0B7B A   
.600                         0 6CFE A   
.601                         0 6CFE A   
.602                         0 6D06 A   
.603                         0 6D23 A   
.604                         0 6D23 A   
.605                         0 6D23 A   
.606                         0 6D23 A   
.607                         0 6D23 A   
.608                         0 6D23 A   
.609                         0 6D23 A   
.60A                         0 6D23 A   
.60B                         0 CF50 A   
.60C                         0 6D86 A   
.60D                         0 6D54 A   
.60E                         0 6DB9 A   
.60F                         0 6D99 A   
.61                          0 0B14 A   
.610                         0 6FBF A   
.612                         0 6FA5 A   
.613                         0 6E14 A   
.614                         0 6E14 A   
.615                         0 6E14 A   
.616                         0 CF1F A   
.617                         0 6E2E A   
.618                         0 6F81 A   
.619                         0 6F71 A   
.61A                         0 6F88 A   
.61B                         0 CEFA A   
.61C                         0 7066 A   
.61D                         0 7046 A   
.61E                         0 703D A   
.61F                         0 CEBB A   
.62                          0 0B21 A   
.620                         0 7430 A   
.622                         0 73B5 A   
.623                         0 706C A   
.624                         0 706C A   
.625                         0 706C A   
.626                         0 706C A   
.627                         0 706C A   
.628                         0 706C A   
.629                         0 706C A   
.62A                         0 706C A   
.62B                         0 7075 A   
.62C                         0 7075 A   
.62D                         0 7083 A   
.62E                         0 70BA A   
.62F                         0 70B2 A   
.63                          0 0B1B A   
.630                         0 70C0 A   
.631                         0 70C3 A   
.632                         0 70C3 A   
.633                         0 7126 A   
.634                         0 7120 A   
.635                         0 7144 A   
.636                         0 713E A   
.637                         0 7136 A   
.638                         0 712E A   
.639                         0 7151 A   
.63A                         0 714B A   
.63B                         0 72FC A   
.63C                         0 72D2 A   
.63D                         0 CE91 A   
.63E                         0 7305 A   
.63F                         0 7373 A   
.64                          0 0B7B A   
.641                         0 7367 A   
.642                         0 7350 A   
.643                         0 7357 A   
.644                         0 735E A   
.645                         0 7389 A   
.646                         0 7397 A   
.647                         0 7397 A   
.648                         0 7397 A   
.649                         0 7397 A   
.64A                         0 7397 A   
.64B                         0 7397 A   
.64C                         0 7397 A   
.64D                         0 7397 A   
.64E                         0 7397 A   
.64F                         0 7397 A   
.65                          0 0B6D A   
.650                         0 7397 A   
.651                         0 7397 A   
.652                         0 7397 A   
.653                         0 7397 A   
.654                         0 7397 A   
.655                         0 CE59 A   
.656                         0 73FA A   
.657                         0 73C8 A   
.658                         0 742D A   
.659                         0 740D A   
.65A                         0 74C1 A   
.65B                         0 74B8 A   
.65C                         0 74AC A   
.65D                         0 74C1 A   
.65E                         0 74FB A   
.65F                         0 74F4 A   
.66                          0 0B74 A   
.660                         0 7500 A   
.661                         0 753B A   
.662                         0 7532 A   
.663                         0 7526 A   
.664                         0 753B A   
.665                         0 7561 A   
.666                         0 7542 A   
.667                         0 7552 A   
.668                         0 7549 A   
.669                         0 7543 A   
.66A                         0 7552 A   
.66B                         0 7582 A   
.66C                         0 7578 A   
.66D                         0 7597 A   
.66E                         0 7591 A   
.66F                         0 75AB A   
.67                          0 0B2A A   
.670                         0 75A4 A   
.671                         0 75CE A   
.672                         0 75C8 A   
.673                         0 75ED A   
.674                         0 75E7 A   
.675                         0 760E A   
.676                         0 7600 A   
.677                         0 7616 A   
.678                         0 769B A   
.67A                         0 7676 A   
.67B                         0 761B A   
.67C                         0 761B A   
.67D                         0 762D A   
.67E                         0 762D A   
.67F                         0 763F A   
.68                          0 0B57 A   
.680                         0 7651 A   
.681                         0 7651 A   
.682                         0 7651 A   
.683                         0 7663 A   
.684                         0 7699 A   
.685                         0 7689 A   
.686                         0 76AA A   
.687                         0 76A2 A   
.688                         0 76B0 A   
.689                         0 76FE A   
.68A                         0 76F7 A   
.68B                         0 76EF A   
.68C                         0 76FE A   
.68D                         0 7729 A   
.68E                         0 7719 A   
.68F                         0 7737 A   
.69                          0 0B4F A   
.690                         0 7771 A   
.691                         0 7763 A   
.692                         0 7779 A   
.693                         0 7788 A   
.694                         0 7780 A   
.695                         0 778F A   
.696                         0 863D A   
.698                         0 85FE A   
.699                         0 77A5 A   
.69A                         0 77CC A   
.69B                         0 77B2 A   
.69C                         0 77ED A   
.69D                         0 77DF A   
.69E                         0 77F5 A   
.69F                         0 7816 A   
.6A                          0 0B63 A   
.6A0                         0 77FC A   
.6A1                         0 783E A   
.6A2                         0 7861 A   
.6A3                         0 7859 A   
.6A4                         0 7865 A   
.6A5                         0 7865 A   
.6A6                         0 7865 A   
.6A7                         0 78D3 A   
.6A8                         0 78A6 A   
.6A9                         0 789F A   
.6AA                         0 7898 A   
.6AB                         0 7891 A   
.6AC                         0 788A A   
.6AD                         0 CE1E A   
.6AE                         0 7901 A   
.6AF                         0 78E2 A   
.6B                          0 0B7B A   
.6B0                         0 793E A   
.6B1                         0 7910 A   
.6B2                         0 793E A   
.6B3                         0 791F A   
.6B4                         0 794B A   
.6B5                         0 7945 A   
.6B6                         0 797B A   
.6B7                         0 7974 A   
.6B8                         0 79B9 A   
.6B9                         0 799A A   
.6BA                         0 7A7E A   
.6BB                         0 7A22 A   
.6BC                         0 7ACA A   
.6BD                         0 7B90 A   
.6BE                         0 7B89 A   
.6BF                         0 7B52 A   
.6C                          0 0C1F A   
.6C0                         0 7B81 A   
.6C1                         0 7B5F A   
.6C2                         0 7B90 A   
.6C3                         0 7BCD A   
.6C4                         0 7BBF A   
.6C5                         0 CDFE A   
.6C6                         0 7C97 A   
.6C7                         0 7C44 A   
.6C8                         0 7C6C A   
.6C9                         0 7C4B A   
.6CA                         0 7C97 A   
.6CB                         0 7C89 A   
.6CC                         0 7C75 A   
.6CD                         0 7C97 A   
.6CE                         0 CDD8 A   
.6CF                         0 7CB9 A   
.6D                          0 0BBD A   
.6D0                         0 7D0A A   
.6D1                         0 7CF4 A   
.6D2                         0 7CED A   
.6D3                         0 7CE6 A   
.6D4                         0 7CDF A   
.6D5                         0 7CD8 A   
.6D6                         0 7D33 A   
.6D7                         0 7D19 A   
.6D8                         0 7D70 A   
.6D9                         0 7D42 A   
.6DA                         0 7D70 A   
.6DB                         0 7D51 A   
.6DC                         0 7DA0 A   
.6DD                         0 7D99 A   
.6DE                         0 7DDD A   
.6DF                         0 7DBE A   
.6E                          0 0B85 A   
.6E0                         0 7F15 A   
.6E1                         0 7F0E A   
.6E2                         0 7EDC A   
.6E3                         0 7F06 A   
.6E4                         0 7EE9 A   
.6E5                         0 7F15 A   
.6E6                         0 7F52 A   
.6E7                         0 7F44 A   
.6E8                         0 CDB8 A   
.6E9                         0 7FF4 A   
.6EA                         0 7FC9 A   
.6EB                         0 7FE6 A   
.6EC                         0 7FD2 A   
.6ED                         0 7FF4 A   
.6EE                         0 CD92 A   
.6EF                         0 801C A   
.6F                          0 0BA9 A   
.6F0                         0 8059 A   
.6F1                         0 8029 A   
.6F2                         0 807A A   
.6F3                         0 8073 A   
.6F4                         0 808A A   
.6F5                         0 8083 A   
.6F6                         0 809F A   
.6F7                         0 8091 A   
.6F8                         0 80A7 A   
.6F9                         0 8176 A   
.6FB                         0 814F A   
.6FC                         0 80C8 A   
.6FD                         0 80D5 A   
.6FE                         0 80E3 A   
.6FF                         0 80F1 A   
.7                           0 05A7 A   
.70                          0 0B8F A   
.700                         0 80FE A   
.701                         0 810B A   
.702                         0 8118 A   
.703                         0 8125 A   
.704                         0 8132 A   
.705                         0 813F A   
.706                         0 CD72 A   
.707                         0 8174 A   
.708                         0 8162 A   
.709                         0 818F A   
.70A                         0 81AD A   
.70B                         0 819C A   
.70C                         0 81CE A   
.70D                         0 81C0 A   
.70E                         0 81D6 A   
.70F                         0 81EC A   
.71                          0 0BBB A   
.710                         0 81E5 A   
.711                         0 81F1 A   
.712                         0 81F5 A   
.713                         0 821C A   
.714                         0 8202 A   
.715                         0 8236 A   
.716                         0 8263 A   
.717                         0 8249 A   
.718                         0 828C A   
.719                         0 8272 A   
.71A                         0 8297 A   
.71B                         0 8293 A   
.71C                         0 8299 A   
.71D                         0 832F A   
.71F                         0 831D A   
.72                          0 0C1F A   
.720                         0 82B3 A   
.721                         0 82BD A   
.722                         0 82C7 A   
.723                         0 82D1 A   
.724                         0 82F7 A   
.725                         0 82ED A   
.726                         0 82E0 A   
.727                         0 82FF A   
.728                         0 8301 A   
.729                         0 8350 A   
.72A                         0 839B A   
.72B                         0 8381 A   
.72C                         0 83C4 A   
.72D                         0 83AA A   
.72E                         0 83FC A   
.72F                         0 83D3 A   
.73                          0 0BD6 A   
.730                         0 83FC A   
.731                         0 83E2 A   
.732                         0 841D A   
.733                         0 840F A   
.734                         0 8425 A   
.735                         0 8430 A   
.736                         0 842C A   
.737                         0 8432 A   
.738                         0 8587 A   
.73A                         0 8560 A   
.73B                         0 8452 A   
.73C                         0 8455 A   
.73D                         0 8455 A   
.73E                         0 8455 A   
.73F                         0 8455 A   
.74                          0 0BC4 A   
.740                         0 8478 A   
.741                         0 846B A   
.742                         0 845D A   
.743                         0 8464 A   
.744                         0 847B A   
.745                         0 84A0 A   
.746                         0 8491 A   
.747                         0 8483 A   
.748                         0 848A A   
.749                         0 84BC A   
.74A                         0 84BC A   
.74B                         0 84AF A   
.74C                         0 84A8 A   
.74D                         0 84BF A   
.74E                         0 84DB A   
.74F                         0 84CE A   
.75                          0 0C1F A   
.750                         0 84C7 A   
.751                         0 84DE A   
.752                         0 8510 A   
.753                         0 84E6 A   
.754                         0 84FC A   
.755                         0 84ED A   
.756                         0 8510 A   
.757                         0 8510 A   
.758                         0 8503 A   
.759                         0 8512 A   
.75A                         0 855A A   
.75B                         0 851A A   
.75C                         0 8530 A   
.75D                         0 8521 A   
.75E                         0 855A A   
.75F                         0 8546 A   
.76                          0 0BFC A   
.760                         0 8537 A   
.761                         0 855A A   
.762                         0 855A A   
.763                         0 854D A   
.764                         0 855C A   
.765                         0 8585 A   
.766                         0 8573 A   
.767                         0 85A5 A   
.768                         0 858E A   
.769                         0 85CE A   
.76A                         0 CD4D A   
.76B                         0 8623 A   
.76C                         0 8611 A   
.76D                         0 8670 A   
.76E                         0 8663 A   
.76F                         0 CD26 A   
.77                          0 0BDD A   
.770                         0 87A6 A   
.771                         0 86BC A   
.772                         0 86B3 A   
.773                         0 86A9 A   
.774                         0 873A A   
.775                         0 86D4 A   
.776                         0 873A A   
.777                         0 8723 A   
.778                         0 871C A   
.779                         0 873A A   
.77A                         0 8733 A   
.77B                         0 8778 A   
.77C                         0 8741 A   
.77D                         0 879C A   
.77E                         0 8794 A   
.77F                         0 87AE A   
.78                          0 0C1F A   
.780                         0 8847 A   
.781                         0 881B A   
.782                         0 885C A   
.783                         0 885C A   
.784                         0 884E A   
.785                         0 CD11 A   
.786                         0 8889 A   
.787                         0 8874 A   
.788                         0 CCF5 A   
.789                         0 89B8 A   
.78B                         0 899E A   
.78C                         0 8898 A   
.78D                         0 8898 A   
.78E                         0 88A4 A   
.78F                         0 88A0 A   
.79                          0 0C11 A   
.790                         0 88A6 A   
.791                         0 88F6 A   
.792                         0 88E5 A   
.793                         0 892F A   
.794                         0 890D A   
.795                         0 88FE A   
.796                         0 892F A   
.797                         0 891F A   
.798                         0 8947 A   
.799                         0 896D A   
.79A                         0 8954 A   
.79B                         0 898A A   
.79C                         0 8998 A   
.79D                         0 CCE1 A   
.79E                         0 90C1 A   
.7A                          0 0C03 A   
.7A0                         0 9096 A   
.7A1                         0 89FA A   
.7A2                         0 8A1E A   
.7A3                         0 8A41 A   
.7A4                         0 8A53 A   
.7A5                         0 8A48 A   
.7A6                         0 8AEF A   
.7A7                         0 8A6A A   
.7A8                         0 8ABC A   
.7A9                         0 8AAF A   
.7AA                         0 8AA6 A   
.7AB                         0 8ADF A   
.7AC                         0 8AD4 A   
.7AD                         0 8AC5 A   
.7AE                         0 8B5A A   
.7AF                         0 8B31 A   
.7B                          0 0C1F A   
.7B0                         0 8B24 A   
.7B1                         0 8B1B A   
.7B2                         0 8B54 A   
.7B3                         0 8B49 A   
.7B4                         0 8B3A A   
.7B5                         0 8B78 A   
.7B6                         0 8B82 A   
.7B7                         0 8B7F A   
.7B8                         0 8C13 A   
.7B9                         0 8B97 A   
.7BA                         0 8BBD A   
.7BB                         0 8BB5 A   
.7BC                         0 8BAE A   
.7BD                         0 8BD2 A   
.7BE                         0 8BCD A   
.7BF                         0 8BC6 A   
.7C                          0 D9F3 A   
.7C0                         0 8C75 A   
.7C1                         0 8C31 A   
.7C2                         0 8C29 A   
.7C3                         0 8C22 A   
.7C4                         0 8C46 A   
.7C5                         0 8C41 A   
.7C6                         0 8C3A A   
.7C7                         0 8CAE A   
.7C8                         0 8CC5 A   
.7C9                         0 8CBA A   
.7CA                         0 8D2C A   
.7CB                         0 8CDA A   
.7CC                         0 8D5C A   
.7CD                         0 8D6D A   
.7CE                         0 8D82 A   
.7CF                         0 8D74 A   
.7D                          0 0C35 A   
.7D0                         0 8DF9 A   
.7D1                         0 8D97 A   
.7D2                         0 8E39 A   
.7D3                         0 8E67 A   
.7D4                         0 8E8C A   
.7D5                         0 8E81 A   
.7D6                         0 8E96 A   
.7D7                         0 8E93 A   
.7D8                         0 8F1F A   
.7D9                         0 8EA2 A   
.7DA                         0 8EF8 A   
.7DB                         0 8EF0 A   
.7DC                         0 8EE9 A   
.7DD                         0 8F0D A   
.7DE                         0 8F08 A   
.7DF                         0 8F01 A   
.7E                          0 0C4A A   
.7E0                         0 8F82 A   
.7E1                         0 8F5D A   
.7E2                         0 8F55 A   
.7E3                         0 8F4E A   
.7E4                         0 8F72 A   
.7E5                         0 8F6D A   
.7E6                         0 8F66 A   
.7E7                         0 8FB9 A   
.7E8                         0 8FED A   
.7E9                         0 9004 A   
.7EA                         0 8FF4 A   
.7EB                         0 CCC6 A   
.7EC                         0 907C A   
.7ED                         0 9021 A   
.7EE                         0 900B A   
.7EF                         0 CCA0 A   
.7F                          0 0C57 A   
.7F0                         0 907C A   
.7F1                         0 903B A   
.7F2                         0 9028 A   
.7F3                         0 CC88 A   
.7F4                         0 907C A   
.7F5                         0 907C A   
.7F6                         0 9042 A   
.7F7                         0 9062 A   
.7F8                         0 9049 A   
.7F9                         0 CC5C A   
.7FA                         0 907C A   
.7FB                         0 CC20 A   
.7FC                         0 908C A   
.7FD                         0 90B9 A   
.7FE                         0 90A9 A   
.7FF                         0 91A9 A   
.8                           0 06A6 A   
.80                          0 0C53 A   
.800                         0 90F7 A   
.801                         0 9104 A   
.802                         0 9100 A   
.803                         0 91A9 A   
.804                         0 910F A   
.805                         0 91A9 A   
.806                         0 9118 A   
.807                         0 917D A   
.808                         0 9135 A   
.809                         0 91A6 A   
.80A                         0 CC20 A   
.80B                         0 CC5C A   
.80C                         0 CC88 A   
.80D                         0 CCA0 A   
.80E                         0 CCC6 A   
.80F                         0 CCE1 A   
.81                          0 0C97 A   
.810                         0 CCF5 A   
.811                         0 CD11 A   
.812                         0 CD26 A   
.813                         0 CD4D A   
.814                         0 CD72 A   
.815                         0 CD92 A   
.816                         0 CDB8 A   
.817                         0 CDD8 A   
.818                         0 CDFE A   
.819                         0 CE1E A   
.81A                         0 CE59 A   
.81B                         0 CE91 A   
.81C                         0 CEBB A   
.81D                         0 CEFA A   
.81E                         0 CF1F A   
.81F                         0 CF50 A   
.82                          0 0C7D A   
.820                         0 CF72 A   
.821                         0 CF9D A   
.822                         0 CFCF A   
.823                         0 D00A A   
.824                         0 D03E A   
.825                         0 D078 A   
.826                         0 D0B7 A   
.827                         0 D0E4 A   
.828                         0 D115 A   
.829                         0 D146 A   
.82A                         0 D160 A   
.82B                         0 D18D A   
.82C                         0 D1D5 A   
.82D                         0 D20D A   
.82E                         0 D24B A   
.82F                         0 D282 A   
.83                          0 0C70 A   
.830                         0 D2B9 A   
.831                         0 D2F0 A   
.832                         0 D30A A   
.833                         0 D315 A   
.834                         0 D31F A   
.835                         0 D329 A   
.836                         0 D333 A   
.837                         0 D33E A   
.838                         0 D349 A   
.839                         0 D371 A   
.83A                         0 D395 A   
.83B                         0 D3B9 A   
.83C                         0 D3F3 A   
.83D                         0 D42D A   
.83E                         0 D447 A   
.83F                         0 D473 A   
.84                          0 0C97 A   
.840                         0 D49F A   
.841                         0 D4CB A   
.842                         0 D4F6 A   
.843                         0 D530 A   
.844                         0 D547 A   
.845                         0 D576 A   
.846                         0 D5B6 A   
.847                         0 D5D0 A   
.848                         0 D5E6 A   
.849                         0 D602 A   
.84A                         0 D62A A   
.84B                         0 D650 A   
.84C                         0 D67C A   
.84D                         0 D67E A   
.84E                         0 D685 A   
.84F                         0 D68C A   
.85                          0 0C8C A   
.850                         0 D6A6 A   
.851                         0 D6B8 A   
.852                         0 D6D2 A   
.853                         0 D6D5 A   
.854                         0 D6DC A   
.855                         0 D6E3 A   
.856                         0 D6EE A   
.857                         0 D70E A   
.858                         0 D72E A   
.859                         0 D731 A   
.85A                         0 D738 A   
.85B                         0 D73F A   
.85C                         0 D74A A   
.85D                         0 D775 A   
.85E                         0 D785 A   
.85F                         0 D78C A   
.86                          0 0CD5 A   
.860                         0 D792 A   
.861                         0 D796 A   
.862                         0 D79B A   
.863                         0 D7C0 A   
.864                         0 D7E9 A   
.865                         0 D7F7 A   
.866                         0 D810 A   
.867                         0 D82B A   
.868                         0 D82F A   
.869                         0 D844 A   
.86A                         0 D858 A   
.86B                         0 D878 A   
.86C                         0 D87B A   
.86D                         0 D89A A   
.86E                         0 D8B0 A   
.86F                         0 D8BC A   
.87                          0 0CCA A   
.870                         0 D8CC A   
.871                         0 D8D1 A   
.872                         0 D8D7 A   
.873                         0 D8E7 A   
.874                         0 D8F7 A   
.875                         0 D8F9 A   
.876                         0 D8FB A   
.877                         0 D901 A   
.878                         0 D904 A   
.879                         0 D908 A   
.87A                         0 D90D A   
.87B                         0 D923 A   
.87C                         0 D93E A   
.87D                         0 D96C A   
.87E                         0 D975 A   
.87F                         0 D9A1 A   
.88                          0 0C9F A   
.880                         0 D9BB A   
.881                         0 D9E0 A   
.882                         0 D9F3 A   
.883                         0 DA10 A   
.89                          0 0CCA A   
.8A                          0 0CBB A   
.8B                          0 0CD5 A   
.8C                          0 0D12 A   
.8D                          0 0CF8 A   
.8E                          0 0CEB A   
.8F                          0 0D12 A   
.9                           0 0697 A   
.90                          0 0D07 A   
.91                          0 0D21 A   
.92                          0 0D19 A   
.93                          0 0D51 A   
.94                          0 0D37 A   
.95                          0 0D29 A   
.96                          0 0D51 A   
.97                          0 0D46 A   
.98                          0 0D61 A   
.99                          0 0D58 A   
.9A                          0 0D77 A   
.9B                          0 0D6E A   
.9C                          0 0DB5 A   
.9D                          0 0D9B A   
.9E                          0 0D8D A   
.9F                          0 0DB5 A   
.A                           0 06BE A   
.A0                          0 0DAA A   
.A1                          0 0DC5 A   
.A2                          0 0DBC A   
.A3                          0 0DF5 A   
.A4                          0 0DDB A   
.A5                          0 0DCD A   
.A6                          0 0DF5 A   
.A7                          0 0DEA A   
.A8                          0 0E05 A   
.A9                          0 0DFC A   
.AA                          0 0E1B A   
.AB                          0 0E12 A   
.AC                          0 0E59 A   
.AD                          0 0E3F A   
.AE                          0 0E31 A   
.AF                          0 0E59 A   
.B                           0 06AF A   
.B0                          0 0E4E A   
.B1                          0 0E69 A   
.B2                          0 0E60 A   
.B3                          0 0EA9 A   
.B4                          0 0E8D A   
.B5                          0 0E7F A   
.B6                          0 0EA9 A   
.B7                          0 0E9E A   
.B8                          0 0EB9 A   
.B9                          0 0EB0 A   
.BA                          0 0EF7 A   
.BB                          0 0EDD A   
.BC                          0 0ECF A   
.BD                          0 0EF7 A   
.BE                          0 0EEC A   
.BF                          0 0F07 A   
.C                           0 06E2 A   
.C0                          0 0EFE A   
.C1                          0 0F37 A   
.C2                          0 0F1D A   
.C3                          0 0F0F A   
.C4                          0 0F37 A   
.C5                          0 0F2C A   
.C6                          0 0F47 A   
.C7                          0 0F3E A   
.C8                          0 0F5D A   
.C9                          0 0F54 A   
.CA                          0 0F8D A   
.CB                          0 0F73 A   
.CC                          0 0F65 A   
.CD                          0 0F8D A   
.CE                          0 0F82 A   
.CF                          0 0F9D A   
.D                           0 06C7 A   
.D0                          0 0F94 A   
.D1                          0 0FB3 A   
.D2                          0 0FAA A   
.D3                          0 0FF1 A   
.D4                          0 0FD7 A   
.D5                          0 0FC9 A   
.D6                          0 0FF1 A   
.D7                          0 0FE6 A   
.D8                          0 1001 A   
.D9                          0 0FF8 A   
.DA                          0 1031 A   
.DB                          0 1017 A   
.DC                          0 1009 A   
.DD                          0 1031 A   
.DE                          0 1026 A   
.DF                          0 1041 A   
.E                           0 06D7 A   
.E0                          0 1038 A   
.E1                          0 1057 A   
.E2                          0 104E A   
.E3                          0 1095 A   
.E4                          0 107B A   
.E5                          0 106D A   
.E6                          0 1095 A   
.E7                          0 108A A   
.E8                          0 10A5 A   
.E9                          0 109C A   
.EA                          0 10E3 A   
.EB                          0 10C9 A   
.EC                          0 10BB A   
.ED                          0 10E3 A   
.EE                          0 10D8 A   
.EF                          0 10F3 A   
.F                           0 06CE A   
.F0                          0 10EA A   
.F1                          0 1131 A   
.F2                          0 1117 A   
.F3                          0 1109 A   
.F4                          0 1131 A   
.F5                          0 1126 A   
.F6                          0 1141 A   
.F7                          0 1138 A   
.F8                          0 1171 A   
.F9                          0 1157 A   
.FA                          0 1149 A   
.FB                          0 1171 A   
.FC                          0 1166 A   
.FD                          0 1181 A   
.FE                          0 1178 A   
.FF                          0 1197 A   
.FFDA                        0 7C97 A   
.FFDD                        0 745A A   
.FFDE                        0 7449 A   
.FFDF                        0 7435 A   
.FFE0                        0 7455 A   
.FFE2                        0 7430 A   
.FFE3                        0 6FE4 A   
.FFE4                        0 6FBF A   
.FFE6                        0 6DE6 A   
.FFE7                        0 6DD5 A   
.FFE8                        0 6DC1 A   
.FFE9                        0 6DE1 A   
.FFEB                        0 6DBC A   
.FFEC                        0 68CC A   
.FFED                        0 68F1 A   
.FFEE                        0 68E0 A   
.FFEF                        0 68EC A   
.FFF1                        0 68C7 A   
.FFF4                        0 4D63 A   
.FFFA                        0 33B3 A   
BcdToBin                     0 95E2 A   
__memcpyb                    0 001B A E 
__memcpyd                    0 0038 A E 
__memsetb                    0 0000 A E 
__read_byte                  0 05E4 A E 
__read_dword                 0 0056 A E 
__read_word                  0 05F2 A E 
__write_byte                 0 0600 A E 
__write_byte_SS              0 063C A E 
__write_dword                0 0067 A E 
__write_word                 0 0613 A E 
__write_word_SS              0 064C A E 
_apm16_entry                 0 976F A   
_apm32_entry                 0 968A A   
_apmreal_entry               0 983A A   
_ata_cmd_data_io             0 2989 A E 
_ata_cmd_non_data            0 2982 A E 
_ata_cmd_packet              0 2D4E A E 
_ata_detect                  0 1B93 A E 
_ata_init                    0 1851 A E 
_ata_reset                   0 2862 A E 
_atapi_get_sense             0 31F8 A E 
_atapi_is_cdrom              0 34E0 A E 
_atapi_is_ready              0 327D A E 
_await_ide                   0 1A33 A   
_bcd2bin                     0 05CB A E 
_bin2bcd                     0 05AE A E 
_bios_printf                 0 093E A E 
_bios_svn_version_string     0 016C A   
_cdemu_emulated_drive        0 3582 A E 
_cdemu_init                  0 3547 A E 
_cdemu_isactive              0 3566 A E 
_cdrom_boot                  0 35BC A E 
_check_for_keystroke         0 08F7 A E 
_debugger_off                0 179D A E 
_debugger_on                 0 178B A E 
_delay_ticks                 0 0852 A E 
_delay_ticks_and_check_for+  0 090D A E 
_dequeue_key                 0 514A A E 
_determine_floppy_media      0 868A A E 
_drivetypes                  0 120F A   
_eltorito                    0 35A4 A   
_enable_mouse_int_and_even+  0 52A4 A E 
_enqueue_key                 0 5989 A E 
_floppy_drive_exists         0 774B A E 
_floppy_drive_recal          0 76C5 A E 
_floppy_media_known          0 7565 A E 
_floppy_media_sense          0 75D5 A E 
_floppy_prepare_controller   0 74C5 A E 
_floppy_reset_controller     0 7477 A E 
_get_CS                      0 065C A E 
_get_SS                      0 065F A E 
_get_boot_vector             0 1370 A   
_get_ebda_seg                0 066C A E 
_get_keystroke               0 0905 A E 
_get_mouse_data              0 5392 A E 
_inb                         0 04F8 A E 
_inb_cmos                    0 053D A E 
_inhibit_mouse_int_and_eve+  0 51F7 A E 
_init_boot_vectors           0 1241 A   
_init_rtc                    0 0549 A E 
_int09_function              0 5417 A E 
_int13_cdemu                 0 7006 A E 
_int13_cdrom                 0 690E A E 
_int13_diskette_function     0 7793 A E 
_int13_edd                   0 5AE6 A E 
_int13_eltorito              0 6E03 A E 
_int13_harddisk              0 615B A E 
_int14_function              0 3A9B A E 
_int15_function              0 3CC8 A E 
_int15_function32            0 48D5 A E 
_int15_function_mouse        0 41B2 A E 
_int16_function              0 4D9A A E 
_int17_function              0 868B A E 
_int18_panic_msg             0 1710 A E 
_int19_function              0 87B2 A E 
_int1a_function              0 89EE A E 
_int70_function              0 90C5 A E 
_int74_function              0 5A0D A E 
_interactive_bootkey         0 13BD A E 
_inw                         0 0503 A E 
_isotag                      0 359E A   
_keyboard_init               0 0C63 A E 
_keyboard_panic              0 11A9 A E 
_log_bios_start              0 1722 A E 
_nmi_handler_msg             0 16FE A E 
_outb                        0 050E A E 
_outb_cmos                   0 052E A E 
_outw                        0 051E A E 
_panic_msg_keyb_buffer_ful+  0 51D7 A   
_print_bios_banner           0 11E8 A E 
_print_boot_device           0 15B9 A E 
_print_boot_failure          0 1683 A E 
_print_cdromboot_failure     0 16E9 A E 
_put_luint                   0 0767 A E 
_put_str                     0 081E A E 
_put_uint                    0 06E4 A E 
_read_byte_SS                0 0626 A E 
_read_dword_SS               0 007E A E 
_read_word_SS                0 0631 A E 
_rtc_updating                0 057A A E 
_s3_resume                   0 17AE A E 
_s3_resume_panic             0 11D6 A E 
_scan_to_scanascii           0 017E A   
_send                        0 068B A E 
_send_to_mouse_ctrl          0 5348 A E 
_set_DS                      0 0662 A E 
_set_diskette_current_cyl    0 8659 A E 
_set_diskette_ret_status     0 8641 A E 
_set_e820_range              0 4837 A E 
_set_enable_a20              0 1738 A E 
_set_kbd_command_byte        0 53C9 A E 
_shutdown_status_panic       0 11BE A E 
_vgafont8                    0 FA6E A   
_wrch                        0 067B A E 
apm16_04                     0 9770 A   
apm16_05                     0 9777 A   
apm16_07                     0 9780 A   
apm16_07_1                   0 97A4 A   
apm16_07_poweroff            0 979A A   
apm16_07_poweroff_str        0 9756 A   
apm16_07_standby             0 97B6 A   
apm16_07_standby_str         0 9767 A   
apm16_07_suspend             0 97A7 A   
apm16_07_suspend_str         0 975F A   
apm16_08                     0 97C5 A   
apm16_0a                     0 97CB A   
apm16_0b                     0 97DF A   
apm16_0e                     0 97E7 A   
apm16_0f                     0 97F1 A   
apm16_10                     0 97F7 A   
apm16_error                  0 9805 A   
apm16_ok                     0 9802 A   
apm16_out_str                0 973E A   
apm16_out_str1               0 9745 A   
apm16_out_str2               0 9751 A   
apm16_unimplemented          0 9805 A   
apm32_04                     0 968C A   
apm32_05                     0 9695 A   
apm32_07                     0 96A0 A   
apm32_07_1                   0 96D1 A   
apm32_07_poweroff            0 96C3 A   
apm32_07_poweroff_str        0 9671 A   
apm32_07_standby             0 96E5 A   
apm32_07_standby_str         0 9682 A   
apm32_07_suspend             0 96D4 A   
apm32_07_suspend_str         0 967A A   
apm32_08                     0 96F6 A   
apm32_0a                     0 96FC A   
apm32_0b                     0 9712 A   
apm32_0e                     0 971A A   
apm32_0f                     0 9724 A   
apm32_10                     0 972A A   
apm32_error                  0 973A A   
apm32_ok                     0 9736 A   
apm32_out_str                0 965E A   
apm32_out_str1               0 9662 A   
apm32_out_str2               0 966E A   
apm32_unimplemented          0 973A A   
apm_call                     0 F894 A   
apmreal_00                   0 983A A   
apmreal_01                   0 984C A   
apmreal_02                   0 9853 A   
apmreal_03                   0 9869 A   
apmreal_04                   0 9888 A   
apmreal_05                   0 988F A   
apmreal_07                   0 9898 A   
apmreal_07_1                 0 98BC A   
apmreal_07_poweroff          0 98B2 A   
apmreal_07_poweroff_str      0 9820 A   
apmreal_07_standby           0 98CE A   
apmreal_07_standby_str       0 9831 A   
apmreal_07_suspend           0 98BF A   
apmreal_07_suspend_str       0 9829 A   
apmreal_08                   0 98DD A   
apmreal_0a                   0 98E3 A   
apmreal_0b                   0 98F7 A   
apmreal_0e                   0 98FF A   
apmreal_0f                   0 9909 A   
apmreal_10                   0 990F A   
apmreal_error                0 991F A   
apmreal_ok                   0 991A A   
apmreal_out_str              0 9808 A   
apmreal_out_str1             0 980F A   
apmreal_out_str2             0 981B A   
apmreal_unimplemented        0 991F A   
ata_in_16                    0 2C4E A   
ata_in_32                    0 2C52 A   
ata_in_adjust                0 2C3A A   
ata_in_done                  0 2C55 A   
ata_in_no_adjust             0 2C41 A   
ata_out_16                   0 2C84 A   
ata_out_32                   0 2C89 A   
ata_out_adjust               0 2C70 A   
ata_out_done                 0 2C8D A   
ata_out_no_adjust            0 2C77 A   
ata_packet_after             0 3183 A   
ata_packet_done              0 319D A   
ata_packet_in_16             0 317C A   
ata_packet_in_32             0 3180 A   
ata_packet_in_after_16       0 3190 A   
ata_packet_in_after_32       0 3195 A   
ata_packet_in_after_32_loo+  0 3197 A   
ata_packet_in_before_16      0 315A A   
ata_packet_in_before_32      0 315F A   
ata_packet_in_before_32_lo+  0 3161 A   
ata_packet_no_before         0 3167 A   
bios32_end                   0 9988 A   
bios32_entry_point           0 9940 A   
bios32_structure             0 9930 A   
bios_table_area_end          0 CC00 A   
bios_table_area_start        0 A0C0 A   
block_count_rounded          0 9F4D A   
carry_set                    0 91E4 A   
check_for_hd1                0 9477 A   
checksum_loop                0 9E92 A   
checksum_out                 0 9EAC A   
detect_parport               0 9E37 A   
detect_serial                0 9E56 A   
diskette_param_table         0 EFC7 A   
diskette_param_table2        0 EFDE A   
done                         0 0904 A   
dummy_iret_handler           0 FF53 A   
dummy_master_pic_irq_handl+  0 E9E6 A   
dummy_slave_pic_irq_handle+  0 E9EC A   
ebda_post                    0 9561 A   
eoi_both_pics                0 95D9 A   
eoi_jmp_post                 0 9576 A   
eoi_master_pic               0 95DD A   
f0_missing                   0 92F5 A   
f1_missing                   0 9300 A   
floppy_drive_post            0 92BA A   
halt2_loop                   0 0C54 A   
hard_drive_post              0 9341 A   
hd0_post_above_2048          0 9439 A   
hd0_post_above_4096          0 9447 A   
hd0_post_above_8192          0 9455 A   
hd0_post_checksum_loop       0 946A A   
hd0_post_logical_chs         0 9418 A   
hd0_post_physical_chs        0 940A A   
hd0_post_store_logical       0 945B A   
hd1_post_above_2048          0 9522 A   
hd1_post_above_4096          0 9530 A   
hd1_post_above_8192          0 953E A   
hd1_post_checksum_loop       0 9553 A   
hd1_post_logical_chs         0 9501 A   
hd1_post_physical_chs        0 94F4 A   
hd1_post_store_logical       0 9544 A   
idiv_                        0 0136 A   
idiv_u                       0 013A A   
imodu                        0 0165 A   
initial_int_vector_offset_+  0 FEF3 A   
int08_floppy_off             0 FEC4 A   
int08_handler                0 FEA5 A   
int08_store_ticks            0 FED9 A   
int09_check_pause            0 E9BB A   
int09_done                   0 E9CC A   
int09_finish                 0 E9D7 A   
int09_handler                0 E987 A   
int09_process_key            0 E9C9 A   
int0e_handler                0 EF57 A   
int0e_loop1                  0 EF69 A   
int0e_loop2                  0 EF73 A   
int0e_normal                 0 EF81 A   
int10_handler                0 F065 A   
int11_handler                0 F84D A   
int12_handler                0 F841 A   
int13_cdemu_inactive         0 923C A   
int13_cdrom_rme_end          0 6CAA A   
int13_disk                   0 9271 A   
int13_diskette               0 EC59 A   
int13_handler                0 E3FE A   
int13_legacy                 0 9244 A   
int13_nocdemu                0 9229 A   
int13_noeltorito             0 9240 A   
int13_not_eltorito           0 9200 A   
int13_notcdrom               0 9271 A   
int13_notfloppy              0 9258 A   
int13_out                    0 927E A   
int13_relocated              0 91ED A   
int14_handler                0 E739 A   
int1586_tick                 0 4936 A   
int1586_tick_end             0 4944 A   
int15_handler                0 F859 A   
int15_handler32              0 F8A2 A   
int15_handler32_ret          0 F88E A   
int15_handler_mouse          0 F89D A   
int15_handler_mouse_ret      0 F88D A   
int15_stub                   0 F897 A   
int16_F00                    0 E859 A   
int16_handler                0 E82E A   
int16_key_found              0 E876 A   
int16_wait_for_key           0 E869 A   
int16_zero_clear             0 E847 A   
int16_zero_set               0 E850 A   
int17_handler                0 EFD2 A   
int18_handler                0 9282 A   
int19_handler                0 E6F2 A   
int19_load_done              0 88D9 A   
int19_next_boot              0 92B5 A   
int19_relocated              0 929E A   
int1a_callfunction           0 FE8D A   
int1a_handler                0 FE6E A   
int1a_normal                 0 FE87 A   
int70_handler                0 FE93 A   
int71_handler                0 E9DD A   
int74_done                   0 91CF A   
int74_handler                0 91B0 A   
int75_handler                0 E2C7 A   
int76_handler                0 9647 A   
iret_modify_cf               0 91D9 A   
iret_post_0x467              0 95AA A   
jmp_post_0x467               0 95A2 A   
laddl                        0 0094 A   
laddul                       0 0094 A   
landl                        0 008C A   
landul                       0 008C A   
lcmpl                        0 009C A   
lcmpul                       0 009C A   
ldecl                        0 00D3 A   
ldecul                       0 00D3 A   
ldivul                       0 013F A   
lincl                        0 00E0 A   
lincul                       0 00E0 A   
lmull                        0 00BA A   
lmulul                       0 00BA A   
look_drive0                  0 92EC A   
look_drive1                  0 92F7 A   
lorl                         0 00D8 A   
lorul                        0 00D8 A   
lsl_exit                     0 0135 A   
lsl_loop                     0 0129 A   
lsll                         0 0118 A   
lslul                        0 0118 A   
lsr_exit                     0 0117 A   
lsr_loop                     0 010B A   
lsrul                        0 00FA A   
lsubl                        0 00B2 A   
lsubul                       0 00B2 A   
ltstl                        0 00E5 A   
ltstul                       0 00E5 A   
memcpyb_end                  0 0031 A   
memcpyd_end                  0 004F A   
memsetb_end                  0 0015 A   
nmi                          0 E2C3 A   
no_bcv                       0 9F9D A   
no_bev                       0 9FD6 A   
no_key                       0 0902 A   
no_parport                   0 9E55 A   
no_prod_str                  0 9FCE A   
no_serial                    0 9E79 A   
normal_post                  0 E0A3 A   
pci_found                    0 9973 A   
pci_present                  0 9B47 A   
pci_pro_devloop              0 99BE A   
pci_pro_devloop2             0 99F4 A   
pci_pro_f02                  0 99AD A   
pci_pro_f03                  0 99E9 A   
pci_pro_f08                  0 9A22 A   
pci_pro_f09                  0 9A41 A   
pci_pro_f0a                  0 9A5F A   
pci_pro_f0b                  0 9A73 A   
pci_pro_f0c                  0 9A8F A   
pci_pro_f0d                  0 9AAD A   
pci_pro_fail                 0 9AC3 A   
pci_pro_get_max_bus          0 9ACF A   
pci_pro_nextdev              0 99D9 A   
pci_pro_nextdev2             0 9A12 A   
pci_pro_no_i440bx            0 9AEE A   
pci_pro_ok                   0 9AC8 A   
pci_pro_select_reg           0 9AF0 A   
pci_pro_unknown              0 9AC1 A   
pci_real_devloop             0 9B7B A   
pci_real_devloop2            0 9BAD A   
pci_real_f02                 0 9B68 A   
pci_real_f03                 0 9BA4 A   
pci_real_f08                 0 9BDA A   
pci_real_f09                 0 9BF2 A   
pci_real_f0a                 0 9C0A A   
pci_real_f0b                 0 9C1D A   
pci_real_f0c                 0 9C34 A   
pci_real_f0d                 0 9C4B A   
pci_real_f0e                 0 9C5E A   
pci_real_fail                0 9C8E A   
pci_real_get_max_bus         0 9C9C A   
pci_real_nextdev             0 9B91 A   
pci_real_nextdev2            0 9BC7 A   
pci_real_no_i440bx           0 9CBC A   
pci_real_ok                  0 9C94 A   
pci_real_select_reg          0 9CBF A   
pci_real_too_small           0 9C86 A   
pci_real_unknown             0 9C8C A   
pci_routing_table_structur+  0 9CE0 A   
pci_routing_table_structur+  0 9D60 A   
pci_routing_table_structur+  0 9D00 A   
pcibios_error                0 FE7B A   
pcibios_protected            0 9990 A   
pcibios_real                 0 9B0D A   
pmode_IDT_info               0 F8AB A   
pnpbios_00                   0 9F07 A   
pnpbios_code                 0 9EEE A   
pnpbios_exit                 0 9F26 A   
pnpbios_fail                 0 9F23 A   
pnpbios_prot                 0 9EE1 A   
pnpbios_real                 0 9EE8 A   
pnpbios_structure            0 9EC0 A   
post                         0 E05B A   
post_d0_extended             0 93A3 A   
post_d0_type47               0 93B4 A   
post_d1_exists               0 9482 A   
post_d1_extended             0 948D A   
post_d1_type47               0 949E A   
post_default_master_pic_in+  0 A02A A   
post_default_slave_pic_int+  0 A03A A   
post_init_ivt                0 A00F A   
post_init_pic                0 9FEA A   
protected_mode               0 3FA1 A   
protmode_switch              0 40B3 A   
real_mode                    0 3FCB A   
retf_post_0x467              0 95B7 A   
rmode_IDT_info               0 F8B1 A   
rom_checksum                 0 9E7B A   
rom_scan                     0 9F29 A   
rom_scan_increment           0 9FD8 A   
rom_scan_loop                0 9F29 A   
rombios32_05                 0 9D8F A   
rombios32_10                 0 9DC8 A   
rombios32_gdt                0 9E07 A   
rombios32_gdt_48             0 9E01 A   
rombios32_init               0 9D60 A   
rombios32_real_mode          0 9DE2 A   
s3_post                      0 95C4 A   
timer_tick_post              0 95F1 A   
unknown_service              0 9986 A   
vga_init_ok                  0 E212 A   

00000 errors
00000 warnings
