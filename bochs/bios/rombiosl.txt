00001                                           ! 1 
00002                                           ! 1 # 1 "_rombiosl_.c"
00003                                           ! 1 #asm
00004                                           !BCC_ASM
00005 0000                                      .rom
00006 0000                                      .org 0x0000
00007                                           use16 386
00008                                           MACRO HALT
00009                                             ;; the HALT macro is called with the line number of the HALT call.
00010                                             ;; The line number is then sent to the 0x400, causing Bochs/Plex
00011                                             ;; to print a BX_PANIC message. This will normally halt the simulation
00012                                             ;; with a message such as "BIOS panic at rombios.c, line 4091".
00013                                             ;; However, users can choose to make panics non-fatal and continue.
00014                                             mov dx,#0x400
00015                                             mov ax,#?1
00016                                             out dx,ax
00017                                           MEND
00018                                           MACRO JMP_AP
00019                                             db 0xea
00020                                             dw ?2
00021                                             dw ?1
00022                                           MEND
00023                                           MACRO SET_INT_VECTOR
00024                                             mov ax, ?3
00025                                             mov ?1*4, ax
00026                                             mov ax, ?2
00027                                             mov ?1*4+2, ax
00028                                           MEND
00029                                           ! 26 endasm
00030                                           !BCC_ENDASM
00031                                           ! 27 typedef unsigned char Bit8u;
00032                                           !BCC_EOS
00033                                           ! 28 typedef unsigned short Bit16u;
00034                                           !BCC_EOS
00035                                           ! 29 typedef unsigned short bx_bool;
00036                                           !BCC_EOS
00037                                           ! 30 typedef unsigned long Bit32u;
00038                                           !BCC_EOS
00039                                           ! 31   void _memsetb(value,offset,seg,count);
00040                                           !BCC_EOS
00041                                           ! 32   void _memcpyb(doffset,dseg,soffset,sseg,count);
00042                                           !BCC_EOS
00043                                           ! 33   void _memcpyd(doffset,dseg,soffset,sseg,count);
00044                                           !BCC_EOS
00045                                           ! 34     void
00046                                           ! 35   _memsetb(value,offset,seg,count)
00047                                           ! 36     Bit16u value;
00048                                           export	__memsetb
00049                       00000000            __memsetb:
00050                                           !BCC_EOS
00051                                           ! 37     Bit16u offset;
00052                                           !BCC_EOS
00053                                           ! 38     Bit16u seg;
00054                                           !BCC_EOS
00055                                           ! 39     Bit16u count;
00056                                           !BCC_EOS
00057                                           ! 40   {
00058                                           ! 41 #asm
00059                                           !BCC_ASM
00060                       00000008            __memsetb.count	set	8
00061                       00000006            __memsetb.seg	set	6
00062                       00000002            __memsetb.value	set	2
00063                       00000004            __memsetb.offset	set	4
00064 0000           55                             push bp
00065 0001           89E5                           mov bp, sp
00066 0003           50                               push ax
00067 0004           51                               push cx
00068 0005           06                               push es
00069 0006           57                               push di
00070 0007           8B4E         0A                  mov cx, 10[bp] ; count
00071 000A           E3           09                  jcxz memsetb_end
00072 000C           C47E         06                  les di, 6[bp] ; segment & offset
00073 000F           8A46         04                  mov al, 4[bp] ; value
00074 0012           FC                               cld
00075 0013           F3                               rep
00076 0014           AA                                stosb
00077                       00000015              memsetb_end:
00078 0015           5F                               pop di
00079 0016           07                               pop es
00080 0017           59                               pop cx
00081 0018           58                               pop ax
00082 0019           5D                             pop bp
00083                                           ! 61 endasm
00084                                           !BCC_ENDASM
00085                                           ! 62   }
00086 001A           C3                         ret
00087                                           ! 63     void
00088                                           ! 64   _memcpyb(doffset,dseg,soffset,sseg,count)
00089                                           ! 65     Bit16u doffset;
00090                                           export	__memcpyb
00091                       0000001B            __memcpyb:
00092                                           !BCC_EOS
00093                                           ! 66     Bit16u dseg;
00094                                           !BCC_EOS
00095                                           ! 67     Bit16u soffset;
00096                                           !BCC_EOS
00097                                           ! 68     Bit16u sseg;
00098                                           !BCC_EOS
00099                                           ! 69     Bit16u count;
00100                                           !BCC_EOS
00101                                           ! 70   {
00102                                           ! 71 #asm
00103                                           !BCC_ASM
00104                       0000000A            __memcpyb.count	set	$A
00105                       00000008            __memcpyb.sseg	set	8
00106                       00000006            __memcpyb.soffset	set	6
00107                       00000004            __memcpyb.dseg	set	4
00108                       00000002            __memcpyb.doffset	set	2
00109 001B           55                             push bp
00110 001C           89E5                           mov bp, sp
00111 001E           51                               push cx
00112 001F           06                               push es
00113 0020           57                               push di
00114 0021           1E                               push ds
00115 0022           56                               push si
00116 0023           8B4E         0C                  mov cx, 12[bp] ; count
00117 0026           E3           09                  jcxz memcpyb_end
00118 0028           C47E         04                  les di, 4[bp] ; dsegment & doffset
00119 002B           C576         08                  lds si, 8[bp] ; ssegment & soffset
00120 002E           FC                               cld
00121 002F           F3                               rep
00122 0030           A4                                movsb
00123                       00000031              memcpyb_end:
00124 0031           5E                               pop si
00125 0032           1F                               pop ds
00126 0033           5F                               pop di
00127 0034           07                               pop es
00128 0035           59                               pop cx
00129 0036           5D                             pop bp
00130                                           ! 93 endasm
00131                                           !BCC_ENDASM
00132                                           ! 94   }
00133 0037           C3                         ret
00134                                           ! 95     void
00135                                           ! 96   _memcpyd(doffset,dseg,soffset,sseg,count)
00136                                           ! 97     Bit16u doffset;
00137                                           export	__memcpyd
00138                       00000038            __memcpyd:
00139                                           !BCC_EOS
00140                                           ! 98     Bit16u dseg;
00141                                           !BCC_EOS
00142                                           ! 99     Bit16u soffset;
00143                                           !BCC_EOS
00144                                           ! 100     Bit16u sseg;
00145                                           !BCC_EOS
00146                                           ! 101     Bit16u count;
00147                                           !BCC_EOS
00148                                           ! 102   {
00149                                           ! 103 #asm
00150                                           !BCC_ASM
00151                       0000000A            __memcpyd.count	set	$A
00152                       00000008            __memcpyd.sseg	set	8
00153                       00000006            __memcpyd.soffset	set	6
00154                       00000004            __memcpyd.dseg	set	4
00155                       00000002            __memcpyd.doffset	set	2
00156 0038           55                             push bp
00157 0039           89E5                           mov bp, sp
00158 003B           51                               push cx
00159 003C           06                               push es
00160 003D           57                               push di
00161 003E           1E                               push ds
00162 003F           56                               push si
00163 0040           8B4E         0C                  mov cx, 12[bp] ; count
00164 0043           E3           0A                  jcxz memcpyd_end
00165 0045           C47E         04                  les di, 4[bp] ; dsegment & doffset
00166 0048           C576         08                  lds si, 8[bp] ; ssegment & soffset
00167 004B           FC                               cld
00168 004C           F3                               rep
00169 004D     66    A5                                movsd
00170                       0000004F              memcpyd_end:
00171 004F           5E                               pop si
00172 0050           1F                               pop ds
00173 0051           5F                               pop di
00174 0052           07                               pop es
00175 0053           59                               pop cx
00176 0054           5D                             pop bp
00177                                           ! 125 endasm
00178                                           !BCC_ENDASM
00179                                           ! 126   }
00180 0055           C3                         ret
00181                                           ! 127   static Bit32u _read_dword();
00182                                           !BCC_EOS
00183                                           ! 128   static void _write_dword();
00184                                           !BCC_EOS
00185                                           ! 129   static Bit32u read_dword_SS();
00186                                           !BCC_EOS
00187                                           ! 130     Bit32u
00188                                           ! 131   _read_dword(offset, seg)
00189                                           ! 132     Bit16u seg;
00190                                           export	__read_dword
00191                       00000056            __read_dword:
00192                                           !BCC_EOS
00193                                           ! 133     Bit16u offset;
00194                                           !BCC_EOS
00195                                           ! 134   {
00196                                           ! 135 #asm
00197                                           !BCC_ASM
00198                       00000004            __read_dword.seg	set	4
00199                       00000002            __read_dword.offset	set	2
00200 0056           55                             push bp
00201 0057           89E5                           mov bp, sp
00202 0059           53                               push bx
00203 005A           1E                               push ds
00204 005B           C55E         04                  lds bx, 4[bp] ; segment & offset
00205 005E           8B07                             mov ax, [bx]
00206 0060           8B57         02                  mov dx, 2[bx]
00207                                                 ;; ax = return value (word)
00208                                                 ;; dx = return value (word)
00209 0063           1F                               pop ds
00210 0064           5B                               pop bx
00211 0065           5D                             pop bp
00212                                           ! 148 endasm
00213                                           !BCC_ENDASM
00214                                           ! 149   }
00215 0066           C3                         ret
00216                                           ! 150     void
00217                                           ! 151   _write_dword(data, offset, seg)
00218                                           ! 152     Bit32u data;
00219                                           export	__write_dword
00220                       00000067            __write_dword:
00221                                           !BCC_EOS
00222                                           ! 153     Bit16u offset;
00223                                           !BCC_EOS
00224                                           ! 154     Bit16u seg;
00225                                           !BCC_EOS
00226                                           ! 155   {
00227                                           ! 156 #asm
00228                                           !BCC_ASM
00229                       00000008            __write_dword.seg	set	8
00230                       00000002            __write_dword.data	set	2
00231                       00000006            __write_dword.offset	set	6
00232 0067           55                             push bp
00233 0068           89E5                           mov bp, sp
00234 006A     66    50                               push eax
00235 006C           53                               push bx
00236 006D           1E                               push ds
00237 006E           C55E         08                  lds bx, 8[bp] ; segment & offset
00238 0071     66    8B46         04                  mov eax, 4[bp] ; data dword
00239 0075     66    8907                             mov [bx], eax ; write data dword
00240 0078           1F                               pop ds
00241 0079           5B                               pop bx
00242 007A     66    58                               pop eax
00243 007C           5D                             pop bp
00244                                           ! 169 endasm
00245                                           !BCC_ENDASM
00246                                           ! 170   }
00247 007D           C3                         ret
00248                                           ! 171     Bit32u
00249                                           ! 172   read_dword_SS(offset)
00250                                           ! 173     Bit16u offset;
00251                                           export	_read_dword_SS
00252                       0000007E            _read_dword_SS:
00253                                           !BCC_EOS
00254                                           ! 174   {
00255                                           ! 175 #asm
00256                                           !BCC_ASM
00257                       00000002            _read_dword_SS.offset	set	2
00258 007E           55                             push bp
00259 007F           89E5                           mov bp, sp
00260 0081           8B6E         04                mov bp, 4[bp] ; offset
00261 0084           8B46         00                mov ax, [bp]
00262 0087           8B56         02                mov dx, 2[bp]
00263                                               ;; ax = return value (word)
00264                                               ;; dx = return value (word)
00265 008A           5D                             pop bp
00266                                           ! 184 endasm
00267                                           !BCC_ENDASM
00268                                           ! 185   }
00269 008B           C3                         ret
00270                                           ! 186 #asm
00271                                           !BCC_ASM
00272                       00000002            _read_dword_SS.offset	set	2
00273                                             ;; and function
00274                       0000008C              landl:
00275                       0000008C              landul:
00276 008C           36                             SEG SS
00277 008D           2305                             and ax,[di]
00278 008F           36                             SEG SS
00279 0090           235D         02                  and bx,2[di]
00280 0093           C3                             ret
00281                                             ;; add function
00282                       00000094              laddl:
00283                       00000094              laddul:
00284 0094           36                             SEG SS
00285 0095           0305                             add ax,[di]
00286 0097           36                             SEG SS
00287 0098           135D         02                  adc bx,2[di]
00288 009B           C3                             ret
00289                                             ;; cmp function
00290                       0000009C              lcmpl:
00291                       0000009C              lcmpul:
00292 009C     66    25               0000FFFF      and eax, #0x0000FFFF
00293 00A2     66    C1E3                   10      shl ebx, #16
00294 00A6     66    09D8                           or eax, ebx
00295 00A9     66    C1EB                   10      shr ebx, #16
00296 00AD           36                             SEG SS
00297 00AE     66    3B05                             cmp eax, dword ptr [di]
00298 00B1           C3                             ret
00299                                             ;; sub function
00300                       000000B2              lsubl:
00301                       000000B2              lsubul:
00302 00B2           36                             SEG SS
00303 00B3           2B05                           sub ax,[di]
00304 00B5           36                             SEG SS
00305 00B6           1B5D         02                sbb bx,2[di]
00306 00B9           C3                             ret
00307                                             ;; mul function
00308                       000000BA              lmull:
00309                       000000BA              lmulul:
00310 00BA     66    25               0000FFFF      and eax, #0x0000FFFF
00311 00C0     66    C1E3                   10      shl ebx, #16
00312 00C4     66    09D8                           or eax, ebx
00313 00C7           36                             SEG SS
00314 00C8     66    F725                           mul eax, dword ptr [di]
00315 00CB     66    89C3                           mov ebx, eax
00316 00CE     66    C1EB                   10      shr ebx, #16
00317 00D2           C3                             ret
00318                                             ;; dec function
00319                       000000D3              ldecl:
00320                       000000D3              ldecul:
00321 00D3           36                             SEG SS
00322 00D4     66    FF0F                           dec dword ptr [bx]
00323 00D7           C3                             ret
00324                                             ;; or function
00325                       000000D8              lorl:
00326                       000000D8              lorul:
00327 00D8           36                             SEG SS
00328 00D9           0B05                           or ax,[di]
00329 00DB           36                             SEG SS
00330 00DC           0B5D         02                or bx,2[di]
00331 00DF           C3                             ret
00332                                             ;; inc function
00333                       000000E0              lincl:
00334                       000000E0              lincul:
00335 00E0           36                             SEG SS
00336 00E1     66    FF07                           inc dword ptr [bx]
00337 00E4           C3                             ret
00338                                             ;; tst function
00339                       000000E5              ltstl:
00340                       000000E5              ltstul:
00341 00E5     66    25               0000FFFF      and eax, #0x0000FFFF
00342 00EB     66    C1E3                   10      shl ebx, #16
00343 00EF     66    09D8                           or eax, ebx
00344 00F2     66    C1EB                   10      shr ebx, #16
00345 00F6     66    85C0                           test eax, eax
00346 00F9           C3                             ret
00347                                             ;; sr function
00348                       000000FA              lsrul:
00349 00FA           89F9                           mov cx,di
00350 00FC           E3           19                jcxz lsr_exit
00351 00FE     66    25               0000FFFF      and eax, #0x0000FFFF
00352 0104     66    C1E3                   10      shl ebx, #16
00353 0108     66    09D8                           or eax, ebx
00354                       0000010B              lsr_loop:
00355 010B     66    D1E8                           shr eax, #1
00356 010E           E2           FB                loop lsr_loop
00357 0110     66    89C3                           mov ebx, eax
00358 0113     66    C1EB                   10      shr ebx, #16
00359                       00000117              lsr_exit:
00360 0117           C3                             ret
00361                                             ;; sl function
00362                       00000118              lsll:
00363                       00000118              lslul:
00364 0118           89F9                           mov cx,di
00365 011A           E3           19                jcxz lsl_exit
00366 011C     66    25               0000FFFF      and eax, #0x0000FFFF
00367 0122     66    C1E3                   10      shl ebx, #16
00368 0126     66    09D8                           or eax, ebx
00369                       00000129              lsl_loop:
00370 0129     66    D1E0                           shl eax, #1
00371 012C           E2           FB                loop lsl_loop
00372 012E     66    89C3                           mov ebx, eax
00373 0131     66    C1EB                   10      shr ebx, #16
00374                       00000135              lsl_exit:
00375 0135           C3                             ret
00376                       00000136              idiv_:
00377 0136           99                             cwd
00378 0137           F7FB                           idiv bx
00379 0139           C3                             ret
00380                       0000013A              idiv_u:
00381 013A           31D2                           xor dx,dx
00382 013C           F7F3                           div bx
00383 013E           C3                             ret
00384                       0000013F              ldivul:
00385 013F     66    25               0000FFFF      and eax, #0x0000FFFF
00386 0145     66    C1E3                   10      shl ebx, #16
00387 0149     66    09D8                           or eax, ebx
00388 014C     66    31D2                           xor edx, edx
00389 014F           36                             SEG SS
00390 0150           8B5D         02                mov bx, 2[di]
00391 0153     66    C1E3                   10      shl ebx, #16
00392 0157           36                             SEG SS
00393 0158           8B1D                           mov bx, [di]
00394 015A     66    F7F3                           div ebx
00395 015D     66    89C3                           mov ebx, eax
00396 0160     66    C1EB                   10      shr ebx, #16
00397 0164           C3                             ret
00398                       00000165              imodu:
00399 0165           F6F3                           div bl
00400 0167           88E0                           mov al, ah
00401 0169           30E4                           xor ah, ah
00402 016B           C3                             ret
00403                                           ! 317 endasm
00404                                           !BCC_ENDASM
00405                                           ! 318 typedef struct {
00406                                           ! 319   unsigned char filler1[0x400];
00407                                           !BCC_EOS
00408                                           ! 320   unsigned char filler2[0x6c];
00409                                           !BCC_EOS
00410                                           ! 321   Bit16u ticks_low;
00411                                           !BCC_EOS
00412                                           ! 322   Bit16u ticks_high;
00413                                           !BCC_EOS
00414                                           ! 323   Bit8u midnight_flag;
00415                                           !BCC_EOS
00416                                           ! 324 } bios_data_t;
00417                                           !BCC_EOS
00418                                           ! 325   typedef struct {
00419                                           ! 326     Bit16u heads;
00420                                           !BCC_EOS
00421                                           ! 327     Bit16u cylinders;
00422                                           !BCC_EOS
00423                                           ! 328     Bit16u spt;
00424                                           !BCC_EOS
00425                                           ! 329   } chs_t;
00426                                           !BCC_EOS
00427                                           ! 330   typedef struct {
00428                                           ! 331     Bit16u iobase1;
00429                                           !BCC_EOS
00430                                           ! 332     Bit16u iobase2;
00431                                           !BCC_EOS
00432                                           ! 333     Bit8u prefix;
00433                                           !BCC_EOS
00434                                           ! 334     Bit8u unused;
00435                                           !BCC_EOS
00436                                           ! 335     Bit8u irq;
00437                                           !BCC_EOS
00438                                           ! 336     Bit8u blkcount;
00439                                           !BCC_EOS
00440                                           ! 337     Bit8u dma;
00441                                           !BCC_EOS
00442                                           ! 338     Bit8u pio;
00443                                           !BCC_EOS
00444                                           ! 339     Bit16u options;
00445                                           !BCC_EOS
00446                                           ! 340     Bit16u reserved;
00447                                           !BCC_EOS
00448                                           ! 341     Bit8u revision;
00449                                           !BCC_EOS
00450                                           ! 342     Bit8u checksum;
00451                                           !BCC_EOS
00452                                           ! 343   } dpte_t;
00453                                           !BCC_EOS
00454                                           ! 344   typedef struct {
00455                                           ! 345     Bit8u iface;
00456                                           !BCC_EOS
00457                                           ! 346     Bit16u iobase1;
00458                                           !BCC_EOS
00459                                           ! 347     Bit16u iobase2;
00460                                           !BCC_EOS
00461                                           ! 348     Bit8u irq;
00462                                           !BCC_EOS
00463                                           ! 349   } ata_channel_t;
00464                                           !BCC_EOS
00465                                           ! 350   typedef struct {
00466                                           ! 351     Bit8u type;
00467                                           !BCC_EOS
00468                                           ! 352     Bit8u device;
00469                                           !BCC_EOS
00470                                           ! 353     Bit8u removable;
00471                                           !BCC_EOS
00472                                           ! 354     Bit8u lock;
00473                                           !BCC_EOS
00474                                           ! 355     Bit8u mode;
00475                                           !BCC_EOS
00476                                           ! 356     Bit16u blksize;
00477                                           !BCC_EOS
00478                                           ! 357     Bit8u translation;
00479                                           !BCC_EOS
00480                                           ! 358     chs_t lchs;
00481                                           !BCC_EOS
00482                                           ! 359     chs_t pchs;
00483                                           !BCC_EOS
00484                                           ! 360     Bit32u sectors_low;
00485                                           !BCC_EOS
00486                                           ! 361     Bit32u sectors_high;
00487                                           !BCC_EOS
00488                                           ! 362   } ata_device_t;
00489                                           !BCC_EOS
00490                                           ! 363   typedef struct {
00491                                           ! 364     ata_channel_t channels[4];
00492                                           !BCC_EOS
00493                                           ! 365     ata_device_t devices[(4*2)];
00494                                           !BCC_EOS
00495                                           ! 366     Bit8
00496                                           ! 366 u hdcount, hdidmap[(4*2)];
00497                                           !BCC_EOS
00498                                           ! 367     Bit8u cdcount, cdidmap[(4*2)];
00499                                           !BCC_EOS
00500                                           ! 368     dpte_t dpte;
00501                                           !BCC_EOS
00502                                           ! 369     Bit16u trsfsectors;
00503                                           !BCC_EOS
00504                                           ! 370     Bit32u trsfbytes;
00505                                           !BCC_EOS
00506                                           ! 371   } ata_t;
00507                                           !BCC_EOS
00508                                           ! 372   typedef struct {
00509                                           ! 373     Bit8u active;
00510                                           !BCC_EOS
00511                                           ! 374     Bit8u media;
00512                                           !BCC_EOS
00513                                           ! 375     Bit8u emulated_drive;
00514                                           !BCC_EOS
00515                                           ! 376     Bit8u controller_index;
00516                                           !BCC_EOS
00517                                           ! 377     Bit16u device_spec;
00518                                           !BCC_EOS
00519                                           ! 378     Bit32u ilba;
00520                                           !BCC_EOS
00521                                           ! 379     Bit16u buffer_segment;
00522                                           !BCC_EOS
00523                                           ! 380     Bit16u load_segment;
00524                                           !BCC_EOS
00525                                           ! 381     Bit16u sector_count;
00526                                           !BCC_EOS
00527                                           ! 382     chs_t vdevice;
00528                                           !BCC_EOS
00529                                           ! 383   } cdemu_t;
00530                                           !BCC_EOS
00531                                           ! 384   typedef struct {
00532                                           ! 385     Bit8u size;
00533                                           !BCC_EOS
00534                                           ! 386     unsigned char filler0[0x21];
00535                                           !BCC_EOS
00536                                           ! 387     Bit16u mouse_driver_offset;
00537                                           !BCC_EOS
00538                                           ! 388     Bit16u mouse_driver_seg;
00539                                           !BCC_EOS
00540                                           ! 389     Bit8u mouse_flag1;
00541                                           !BCC_EOS
00542                                           ! 390     Bit8u mouse_flag2;
00543                                           !BCC_EOS
00544                                           ! 391     Bit8u mouse_data[0x08];
00545                                           !BCC_EOS
00546                                           ! 392     unsigned char filler1[0x0D];
00547                                           !BCC_EOS
00548                                           ! 393     unsigned char fdpt0[0x10];
00549                                           !BCC_EOS
00550                                           ! 394     unsigned char fdpt1[0x10];
00551                                           !BCC_EOS
00552                                           ! 395     unsigned char filler2[0xC4];
00553                                           !BCC_EOS
00554                                           ! 396     ata_t ata;
00555                                           !BCC_EOS
00556                                           ! 397     cdemu_t cdemu;
00557                                           !BCC_EOS
00558                                           ! 398   } ebda_data_t;
00559                                           !BCC_EOS
00560                                           ! 399   typedef struct {
00561                                           ! 400     Bit8u size;
00562                                           !BCC_EOS
00563                                           ! 401     Bit8u reserved;
00564                                           !BCC_EOS
00565                                           ! 402     Bit16u count;
00566                                           !BCC_EOS
00567                                           ! 403     Bit16u offset;
00568                                           !BCC_EOS
00569                                           ! 404     Bit16u segment;
00570                                           !BCC_EOS
00571                                           ! 405     Bit32u lba1;
00572                                           !BCC_EOS
00573                                           ! 406     Bit32u lba2;
00574                                           !BCC_EOS
00575                                           ! 407   } int13ext_t;
00576                                           !BCC_EOS
00577                                           ! 408   typedef struct {
00578                                           ! 409     Bit16u size;
00579                                           !BCC_EOS
00580                                           ! 410     Bit16u infos;
00581                                           !BCC_EOS
00582                                           ! 411     Bit32u cylinders;
00583                                           !BCC_EOS
00584                                           ! 412     Bit32u heads;
00585                                           !BCC_EOS
00586                                           ! 413     Bit32u spt;
00587                                           !BCC_EOS
00588                                           ! 414     Bit32u sector_count1;
00589                                           !BCC_EOS
00590                                           ! 415     Bit32u sector_count2;
00591                                           !BCC_EOS
00592                                           ! 416     Bit16u blksize;
00593                                           !BCC_EOS
00594                                           ! 417     Bit16u dpte_offset;
00595                                           !BCC_EOS
00596                                           ! 418     Bit16u dpte_segment;
00597                                           !BCC_EOS
00598                                           ! 419     union {
00599                                           ! 420       struct {
00600                                           ! 421         Bit16u key;
00601                                           !BCC_EOS
00602                                           ! 422         Bit8u dpi_length;
00603                                           !BCC_EOS
00604                                           ! 423         Bit8u reserved1;
00605                                           !BCC_EOS
00606                                           ! 424         Bit16u reserved2;
00607                                           !BCC_EOS
00608                                           ! 425         Bit8u host_bus[4];
00609                                           !BCC_EOS
00610                                           ! 426         Bit8u iface_type[8];
00611                                           !BCC_EOS
00612                                           ! 427         Bit8u iface_path[8];
00613                                           !BCC_EOS
00614                                           ! 428         Bit8u device_path[8];
00615                                           !BCC_EOS
00616                                           ! 429         Bit8u reserved3;
00617                                           !BCC_EOS
00618                                           ! 430         Bit8u checksum;
00619                                           !BCC_EOS
00620                                           ! 431       } phoenix;
00621                                           !BCC_EOS
00622                                           ! 432       struct {
00623                                           ! 433         Bit16u key;
00624                                           !BCC_EOS
00625                                           ! 434         Bit8u dpi_length;
00626                                           !BCC_EOS
00627                                           ! 435         Bit8u reserved1;
00628                                           !BCC_EOS
00629                                           ! 436         Bit16u reserved2;
00630                                           !BCC_EOS
00631                                           ! 437         Bit8u host_bus[4];
00632                                           !BCC_EOS
00633                                           ! 438         Bit8u iface_type[8];
00634                                           !BCC_EOS
00635                                           ! 439         Bit8u iface_path[8];
00636                                           !BCC_EOS
00637                                           ! 440         Bit8u device_path[16];
00638                                           !BCC_EOS
00639                                           ! 441         Bit8u reserved3;
00640                                           !BCC_EOS
00641                                           ! 442         Bit8u checksum;
00642                                           !BCC_EOS
00643                                           ! 443       } t13;
00644                                           !BCC_EOS
00645                                           ! 444     } dpi;
00646                                           !BCC_EOS
00647                                           ! 445   } dpt_t;
00648                                           !BCC_EOS
00649                                           ! 446 typedef struct {
00650                                           ! 447   union {
00651                                           ! 448     struct {
00652                                           ! 449       Bit16u di, si, bp, sp;
00653                                           !BCC_EOS
00654                                           ! 450       Bit16u bx, dx, cx, ax;
00655                                           !BCC_EOS
00656                                           ! 451     } r16;
00657                                           !BCC_EOS
00658                                           ! 452     struct {
00659                                           ! 453       Bit16u filler[4];
00660                                           !BCC_EOS
00661                                           ! 454       Bit8u bl, bh, dl, dh, cl, ch, al, ah;
00662                                           !BCC_EOS
00663                                           ! 455     } r8;
00664                                           !BCC_EOS
00665                                           ! 456   } u;
00666                                           !BCC_EOS
00667                                           ! 457 } pusha_regs_t;
00668                                           !BCC_EOS
00669                                           ! 458 typedef struct {
00670                                           ! 459  union {
00671                                           ! 460   struct {
00672                                           ! 461   
00673                                           ! 461   Bit32u edi, esi, ebp, esp;
00674                                           !BCC_EOS
00675                                           ! 462     Bit32u ebx, edx, ecx, eax;
00676                                           !BCC_EOS
00677                                           ! 463   } r32;
00678                                           !BCC_EOS
00679                                           ! 464   struct {
00680                                           ! 465     Bit16u di, filler1, si, filler2, bp, filler3, sp, filler4;
00681                                           !BCC_EOS
00682                                           ! 466     Bit16u bx, filler5, dx, filler6, cx, filler7, ax, filler8;
00683                                           !BCC_EOS
00684                                           ! 467   } r16;
00685                                           !BCC_EOS
00686                                           ! 468   struct {
00687                                           ! 469     Bit32u filler[4];
00688                                           !BCC_EOS
00689                                           ! 470     Bit8u bl, bh;
00690                                           !BCC_EOS
00691                                           ! 471     Bit16u filler1;
00692                                           !BCC_EOS
00693                                           ! 472     Bit8u dl, dh;
00694                                           !BCC_EOS
00695                                           ! 473     Bit16u filler2;
00696                                           !BCC_EOS
00697                                           ! 474     Bit8u cl, ch;
00698                                           !BCC_EOS
00699                                           ! 475     Bit16u filler3;
00700                                           !BCC_EOS
00701                                           ! 476     Bit8u al, ah;
00702                                           !BCC_EOS
00703                                           ! 477     Bit16u filler4;
00704                                           !BCC_EOS
00705                                           ! 478   } r8;
00706                                           !BCC_EOS
00707                                           ! 479  } u;
00708                                           !BCC_EOS
00709                                           ! 480 } pushad_regs_t;
00710                                           !BCC_EOS
00711                                           ! 481 typedef struct {
00712                                           ! 482   union {
00713                                           ! 483     struct {
00714                                           ! 484       Bit16u flags;
00715                                           !BCC_EOS
00716                                           ! 485     } r16;
00717                                           !BCC_EOS
00718                                           ! 486     struct {
00719                                           ! 487       Bit8u flagsl;
00720                                           !BCC_EOS
00721                                           ! 488       Bit8u flagsh;
00722                                           !BCC_EOS
00723                                           ! 489     } r8;
00724                                           !BCC_EOS
00725                                           ! 490   } u;
00726                                           !BCC_EOS
00727                                           ! 491 } flags_t;
00728                                           !BCC_EOS
00729                                           ! 492 typedef struct {
00730                                           ! 493   Bit16u ip;
00731                                           !BCC_EOS
00732                                           ! 494   Bit16u cs;
00733                                           !BCC_EOS
00734                                           ! 495   flags_t flags;
00735                                           !BCC_EOS
00736                                           ! 496 } iret_addr_t;
00737                                           !BCC_EOS
00738                                           ! 497 typedef struct {
00739                                           ! 498   Bit16u type;
00740                                           !BCC_EOS
00741                                           ! 499   Bit16u flags;
00742                                           !BCC_EOS
00743                                           ! 500   Bit32u vector;
00744                                           !BCC_EOS
00745                                           ! 501   Bit32u description;
00746                                           !BCC_EOS
00747                                           ! 502   Bit32u reserved;
00748                                           !BCC_EOS
00749                                           ! 503 } ipl_entry_t;
00750                                           !BCC_EOS
00751                                           ! 504 static Bit8u inb();
00752                                           !BCC_EOS
00753                                           ! 505 static Bit8u inb_cmos();
00754                                           !BCC_EOS
00755                                           ! 506 static void outb();
00756                                           !BCC_EOS
00757                                           ! 507 static void outb_cmos();
00758                                           !BCC_EOS
00759                                           ! 508 static Bit16u inw();
00760                                           !BCC_EOS
00761                                           ! 509 static void outw();
00762                                           !BCC_EOS
00763                                           ! 510 static void init_rtc();
00764                                           !BCC_EOS
00765                                           ! 511 static bx_bool rtc_updating();
00766                                           !BCC_EOS
00767                                           ! 512 static Bit8u bin2bcd();
00768                                           !BCC_EOS
00769                                           ! 513 static Bit8u bcd2bin();
00770                                           !BCC_EOS
00771                                           ! 514 static Bit8u _read_byte();
00772                                           !BCC_EOS
00773                                           ! 515 static Bit16u _read_word();
00774                                           !BCC_EOS
00775                                           ! 516 static void _write_byte();
00776                                           !BCC_EOS
00777                                           ! 517 static void _write_word();
00778                                           !BCC_EOS
00779                                           ! 518 static Bit8u read_byte_SS();
00780                                           !BCC_EOS
00781                                           ! 519 static Bit16u read_word_SS();
00782                                           !BCC_EOS
00783                                           ! 520 static void _write_byte_SS();
00784                                           !BCC_EOS
00785                                           ! 521 static void _write_word_SS();
00786                                           !BCC_EOS
00787                                           ! 522 static void bios_printf();
00788                                           !BCC_EOS
00789                                           ! 523 static Bit8u inhibit_mouse_int_and_events();
00790                                           !BCC_EOS
00791                                           ! 524 static void enable_mouse_int_and_events();
00792                                           !BCC_EOS
00793                                           ! 525 static Bit8u send_to_mouse_ctrl();
00794                                           !BCC_EOS
00795                                           ! 526 static Bit8u get_mouse_data();
00796                                           !BCC_EOS
00797                                           ! 527 static void set_kbd_command_byte();
00798                                           !BCC_EOS
00799                                           ! 528 static void int09_function();
00800                                           !BCC_EOS
00801                                           ! 529 static void int13_harddisk();
00802                                           !BCC_EOS
00803                                           ! 530 static void int13_cdrom();
00804                                           !BCC_EOS
00805                                           ! 531 static void int13_cdemu();
00806                                           !BCC_EOS
00807                                           ! 532 static void int13_eltorito();
00808                                           !BCC_EOS
00809                                           ! 533 static void int13_diskette_function();
00810                                           !BCC_EOS
00811                                           ! 534 static void int14_function();
00812                                           !BCC_EOS
00813                                           ! 535 static void int15_function();
00814                                           !BCC_EOS
00815                                           ! 536 static void int16_function();
00816                                           !BCC_EOS
00817                                           ! 537 static void int17_function();
00818                                           !BCC_EOS
00819                                           ! 538 static void int19_function();
00820                                           !BCC_EOS
00821                                           ! 539 static void int1a_function();
00822                                           !BCC_EOS
00823                                           ! 540 static void int70_function();
00824                                           !BCC_EOS
00825                                           ! 541 static void int74_function();
00826                                           !BCC_EOS
00827                                           ! 542 static Bit16u get_CS();
00828                                           !BCC_EOS
00829                                           ! 543 static Bit16u get_SS();
00830                                           !BCC_EOS
00831                                           ! 544 static Bit16u set_DS();
00832                                           !BCC_EOS
00833                                           ! 545 static unsigned int enqueue_key();
00834                                           !BCC_EOS
00835                                           ! 546 static unsigned int dequeue_key();
00836                                           !BCC_EOS
00837                                           ! 547 static void get_hd_geomet
00838                                           ! 547 ry();
00839                                           !BCC_EOS
00840                                           ! 548 static void set_diskette_ret_status();
00841                                           !BCC_EOS
00842                                           ! 549 static void set_diskette_current_cyl();
00843                                           !BCC_EOS
00844                                           ! 550 static void determine_floppy_media();
00845                                           !BCC_EOS
00846                                           ! 551 static bx_bool floppy_drive_exists();
00847                                           !BCC_EOS
00848                                           ! 552 static bx_bool floppy_drive_recal();
00849                                           !BCC_EOS
00850                                           ! 553 static bx_bool floppy_media_known();
00851                                           !BCC_EOS
00852                                           ! 554 static bx_bool floppy_media_sense();
00853                                           !BCC_EOS
00854                                           ! 555 static bx_bool set_enable_a20();
00855                                           !BCC_EOS
00856                                           ! 556 static void debugger_on();
00857                                           !BCC_EOS
00858                                           ! 557 static void debugger_off();
00859                                           !BCC_EOS
00860                                           ! 558 static void keyboard_init();
00861                                           !BCC_EOS
00862                                           ! 559 static void keyboard_panic();
00863                                           !BCC_EOS
00864                                           ! 560 static void shutdown_status_panic();
00865                                           !BCC_EOS
00866                                           ! 561 static void nmi_handler_msg();
00867                                           !BCC_EOS
00868                                           ! 562 static void delay_ticks();
00869                                           !BCC_EOS
00870                                           ! 563 static void delay_ticks_and_check_for_keystroke();
00871                                           !BCC_EOS
00872                                           ! 564 static void interactive_bootkey();
00873                                           !BCC_EOS
00874                                           ! 565 static void print_bios_banner();
00875                                           !BCC_EOS
00876                                           ! 566 static void print_boot_device();
00877                                           !BCC_EOS
00878                                           ! 567 static void print_boot_failure();
00879                                           !BCC_EOS
00880                                           ! 568 static void print_cdromboot_failure();
00881                                           !BCC_EOS
00882                                           ! 569 void ata_init();
00883                                           !BCC_EOS
00884                                           ! 570 void ata_detect();
00885                                           !BCC_EOS
00886                                           ! 571 void ata_reset();
00887                                           !BCC_EOS
00888                                           ! 572 Bit16u ata_cmd_non_data();
00889                                           !BCC_EOS
00890                                           ! 573 Bit16u ata_cmd_data_io();
00891                                           !BCC_EOS
00892                                           ! 574 Bit16u ata_cmd_packet();
00893                                           !BCC_EOS
00894                                           ! 575 Bit16u atapi_get_sense();
00895                                           !BCC_EOS
00896                                           ! 576 Bit16u atapi_is_ready();
00897                                           !BCC_EOS
00898                                           ! 577 Bit16u atapi_is_cdrom();
00899                                           !BCC_EOS
00900                                           ! 578 void cdemu_init();
00901                                           !BCC_EOS
00902                                           ! 579 Bit8u cdemu_isactive();
00903                                           !BCC_EOS
00904                                           ! 580 Bit8u cdemu_emulated_drive();
00905                                           !BCC_EOS
00906                                           ! 581 Bit16u cdrom_boot();
00907                                           !BCC_EOS
00908                                           ! 582 static char bios_svn_version_string[] = "$Revision$ $Date$";
00909                                           
00910                       0000016C            _bios_svn_version_string:
00911                       0000016C            .1:
00912 016C                        24            .ascii	"$Revision$ $Date$"
00913 017D                        00            .byte	0
00914                                           !BCC_EOS
00915                                           ! 583 static struct {
00916                                           ! 584   Bit16u normal;
00917                                           !BCC_EOS
00918                                           ! 585   Bit16u shift;
00919                                           !BCC_EOS
00920                                           ! 586   Bit16u control;
00921                                           !BCC_EOS
00922                                           ! 587   Bit16u alt;
00923                                           !BCC_EOS
00924                                           ! 588   Bit8u lock_flags;
00925                                           !BCC_EOS
00926                                           ! 589   } scan_to_scanascii[0x58 + 1] = {
00927                       0000017E            _scan_to_scanascii:
00928                                           ! 590       { 0, 0, 0, 0, 0 },
00929 017E                      0000            .word	0
00930 0180                      0000            .word	0
00931 0182                      0000            .word	0
00932 0184                      0000            .word	0
00933 0186                        00            .byte	0
00934 0187                  00000001            .blkb	1
00935                                           ! 591       { 0x011b, 0x011b, 0x011b, 0x0100, 0 },
00936 0188                      011B            .word	$11B
00937 018A                      011B            .word	$11B
00938 018C                      011B            .word	$11B
00939 018E                      0100            .word	$100
00940 0190                        00            .byte	0
00941 0191                  00000001            .blkb	1
00942                                           ! 592       { 0x0231, 0x0221, 0, 0x7800, 0 },
00943 0192                      0231            .word	$231
00944 0194                      0221            .word	$221
00945 0196                      0000            .word	0
00946 0198                      7800            .word	$7800
00947 019A                        00            .byte	0
00948 019B                  00000001            .blkb	1
00949                                           ! 593       { 0x0332, 0x0340, 0x0300, 0x7900, 0 },
00950 019C                      0332            .word	$332
00951 019E                      0340            .word	$340
00952 01A0                      0300            .word	$300
00953 01A2                      7900            .word	$7900
00954 01A4                        00            .byte	0
00955 01A5                  00000001            .blkb	1
00956                                           ! 594       { 0x0433, 0x0423, 0, 0x7a00, 0 },
00957 01A6                      0433            .word	$433
00958 01A8                      0423            .word	$423
00959 01AA                      0000            .word	0
00960 01AC                      7A00            .word	$7A00
00961 01AE                        00            .byte	0
00962 01AF                  00000001            .blkb	1
00963                                           ! 595       { 0x0534, 0x0524, 0, 0x7b00, 0 },
00964 01B0                      0534            .word	$534
00965 01B2                      0524            .word	$524
00966 01B4                      0000            .word	0
00967 01B6                      7B00            .word	$7B00
00968 01B8                        00            .byte	0
00969 01B9                  00000001            .blkb	1
00970                                           ! 596       { 0x0635, 0x0625, 0, 0x7c00, 0 },
00971 01BA                      0635            .word	$635
00972 01BC                      0625            .word	$625
00973 01BE                      0000            .word	0
00974 01C0                      7C00            .word	$7C00
00975 01C2                        00            .byte	0
00976 01C3                  00000001            .blkb	1
00977                                           ! 597       { 0x0736, 0x075e, 0x071e, 0x7d00, 0 },
00978 01C4                      0736            .word	$736
00979 01C6                      075E            .word	$75E
00980 01C8                      071E            .word	$71E
00981 01CA                      7D00            .word	$7D00
00982 01CC                        00            .byte	0
00983 01CD                  00000001            .blkb	1
00984                                           ! 598       { 0x0837, 0x0826, 0, 0x7e00, 0 },
00985 01CE                      0837            .word	$837
00986 01D0                      0826            .word	$826
00987 01D2                      0000            .word	0
00988 01D4                      7E00            .word	$7E00
00989 01D6                        00            .byte	0
00990 01D7                  00000001            .blkb	1
00991                                           ! 599       { 0x0938, 0x092a, 0, 0x7f00, 0 },
00992 01D8                      0938            .word	$938
00993 01DA                      092A            .word	$92A
00994 01DC                      0000            .word	0
00995 01DE                      7F00            .word	$7F00
00996 01E0                        00            .byte	0
00997 01E1                  00000001            .blkb	1
00998                                           ! 600       { 0x0a39, 0x0a28, 0, 0x8000, 0 },
00999 01E2                      0A39            .word	$A39
01000 01E4                      0A28            .word	$A28
01001 01E6                      0000            .word	0
01002 01E8                      8000            .word	$8000
01003 01EA                        00            .byte	0
01004 01EB                  00000001            .blkb	1
01005                                           ! 601       { 0x0b30, 0x0b29, 0, 0x8100, 0 },
01006 01EC                      0B30            .word	$B30
01007 01EE                      0B29            .word	$B29
01008 01F0                      0000            .word	0
01009 01F2                      8100            .word	$8100
01010 01F4                        00            .byte	0
01011 01F5                  00000001            .blkb	1
01012                                           ! 602       { 0x0c2d, 0x0c5f, 0x0c1f, 0x8200, 0 },
01013 01F6                      0C2D            .word	$C2D
01014 01F8                      0C5F            .word	$C5F
01015 01FA                      0C1F            .word	$C1F
01016 01FC                      8200            .word	$8200
01017 01FE                        00            .byte	0
01018 01FF                  00000001            .blkb	1
01019                                           ! 603       { 0x0d3d, 0x0d2b, 0, 0x8300, 0 },
01020 0200                      0D3D            .word	$D3D
01021 0202                      0D2B            .word	$D2B
01022 0204                      0000            .word	0
01023 0206                      8300            .word	$8300
01024 0208                        00            .byte	0
01025 0209                  00000001            .blkb	1
01026                                           ! 604       { 0x0e08, 0x0e08, 0x0e7f, 0, 0 },
01027 020A                      0E08            .word	$E08
01028 020C                      0E08            .word	$E08
01029 020E                      0E7F            .word	$E7F
01030 0210                      0000            .word	0
01031 0212                        00            .byte	0
01032 0213                  00000001            .blkb	1
01033                                           ! 605       { 0x0f09, 0x0f00, 0, 0, 0 },
01034 0214                      0F09            .word	$F09
01035 0216                      0F00            .word	$F00
01036 0218                      0000            .word	0
01037 021A                      0000            .word	0
01038 021C                        00            .byte	0
01039 021D                  00000001            .blkb	1
01040                                           ! 606       { 0x1071, 0x1051, 0x1011, 0x1000, 0x40 },
01041 021E                      1071            .word	$1071
01042 0220                      1051            .word	$1051
01043 0222                      1011            .word	$1011
01044 0224                      1000            .word	$1000
01045 0226                        40            .byte	$40
01046 0227                  00000001            .blkb	1
01047                                           ! 607       { 0x1177, 0x1157, 0x1117, 0x1100, 0x40 },
01048 0228                      1177            .word	$1177
01049 022A                      1157            .word	$1157
01050 022C                      1117            .word	$1117
01051 022E                      1100            .word	$1100
01052 0230                        40            .byte	$40
01053 0231                  00000001            .blkb	1
01054                                           ! 608       { 0x1265, 0x1245, 0x1205, 0x1200, 0x40 },
01055 0232                      1265            .word	$1265
01056 0234                      1245            .word	$1245
01057 0236                      1205            .word	$1205
01058 0238                      1200            .word	$1200
01059 023A                        40            .byte	$40
01060 023B                  00000001            .blkb	1
01061                                           ! 609       { 0x1372, 0x1352, 0
01062 023C                      1372            .word	$1372
01063 023E                      1352            .word	$1352
01064                                           ! 609 x1312, 0x1300, 0x40 },
01065 0240                      1312            .word	$1312
01066 0242                      1300            .word	$1300
01067 0244                        40            .byte	$40
01068 0245                  00000001            .blkb	1
01069                                           ! 610       { 0x1474, 0x1454, 0x1414, 0x1400, 0x40 },
01070 0246                      1474            .word	$1474
01071 0248                      1454            .word	$1454
01072 024A                      1414            .word	$1414
01073 024C                      1400            .word	$1400
01074 024E                        40            .byte	$40
01075 024F                  00000001            .blkb	1
01076                                           ! 611       { 0x1579, 0x1559, 0x1519, 0x1500, 0x40 },
01077 0250                      1579            .word	$1579
01078 0252                      1559            .word	$1559
01079 0254                      1519            .word	$1519
01080 0256                      1500            .word	$1500
01081 0258                        40            .byte	$40
01082 0259                  00000001            .blkb	1
01083                                           ! 612       { 0x1675, 0x1655, 0x1615, 0x1600, 0x40 },
01084 025A                      1675            .word	$1675
01085 025C                      1655            .word	$1655
01086 025E                      1615            .word	$1615
01087 0260                      1600            .word	$1600
01088 0262                        40            .byte	$40
01089 0263                  00000001            .blkb	1
01090                                           ! 613       { 0x1769, 0x1749, 0x1709, 0x1700, 0x40 },
01091 0264                      1769            .word	$1769
01092 0266                      1749            .word	$1749
01093 0268                      1709            .word	$1709
01094 026A                      1700            .word	$1700
01095 026C                        40            .byte	$40
01096 026D                  00000001            .blkb	1
01097                                           ! 614       { 0x186f, 0x184f, 0x180f, 0x1800, 0x40 },
01098 026E                      186F            .word	$186F
01099 0270                      184F            .word	$184F
01100 0272                      180F            .word	$180F
01101 0274                      1800            .word	$1800
01102 0276                        40            .byte	$40
01103 0277                  00000001            .blkb	1
01104                                           ! 615       { 0x1970, 0x1950, 0x1910, 0x1900, 0x40 },
01105 0278                      1970            .word	$1970
01106 027A                      1950            .word	$1950
01107 027C                      1910            .word	$1910
01108 027E                      1900            .word	$1900
01109 0280                        40            .byte	$40
01110 0281                  00000001            .blkb	1
01111                                           ! 616       { 0x1a5b, 0x1a7b, 0x1a1b, 0, 0 },
01112 0282                      1A5B            .word	$1A5B
01113 0284                      1A7B            .word	$1A7B
01114 0286                      1A1B            .word	$1A1B
01115 0288                      0000            .word	0
01116 028A                        00            .byte	0
01117 028B                  00000001            .blkb	1
01118                                           ! 617       { 0x1b5d, 0x1b7d, 0x1b1d, 0, 0 },
01119 028C                      1B5D            .word	$1B5D
01120 028E                      1B7D            .word	$1B7D
01121 0290                      1B1D            .word	$1B1D
01122 0292                      0000            .word	0
01123 0294                        00            .byte	0
01124 0295                  00000001            .blkb	1
01125                                           ! 618       { 0x1c0d, 0x1c0d, 0x1c0a, 0, 0 },
01126 0296                      1C0D            .word	$1C0D
01127 0298                      1C0D            .word	$1C0D
01128 029A                      1C0A            .word	$1C0A
01129 029C                      0000            .word	0
01130 029E                        00            .byte	0
01131 029F                  00000001            .blkb	1
01132                                           ! 619       { 0, 0, 0, 0, 0 },
01133 02A0                      0000            .word	0
01134 02A2                      0000            .word	0
01135 02A4                      0000            .word	0
01136 02A6                      0000            .word	0
01137 02A8                        00            .byte	0
01138 02A9                  00000001            .blkb	1
01139                                           ! 620       { 0x1e61, 0x1e41, 0x1e01, 0x1e00, 0x40 },
01140 02AA                      1E61            .word	$1E61
01141 02AC                      1E41            .word	$1E41
01142 02AE                      1E01            .word	$1E01
01143 02B0                      1E00            .word	$1E00
01144 02B2                        40            .byte	$40
01145 02B3                  00000001            .blkb	1
01146                                           ! 621       { 0x1f73, 0x1f53, 0x1f13, 0x1f00, 0x40 },
01147 02B4                      1F73            .word	$1F73
01148 02B6                      1F53            .word	$1F53
01149 02B8                      1F13            .word	$1F13
01150 02BA                      1F00            .word	$1F00
01151 02BC                        40            .byte	$40
01152 02BD                  00000001            .blkb	1
01153                                           ! 622       { 0x2064, 0x2044, 0x2004, 0x2000, 0x40 },
01154 02BE                      2064            .word	$2064
01155 02C0                      2044            .word	$2044
01156 02C2                      2004            .word	$2004
01157 02C4                      2000            .word	$2000
01158 02C6                        40            .byte	$40
01159 02C7                  00000001            .blkb	1
01160                                           ! 623       { 0x2166, 0x2146, 0x2106, 0x2100, 0x40 },
01161 02C8                      2166            .word	$2166
01162 02CA                      2146            .word	$2146
01163 02CC                      2106            .word	$2106
01164 02CE                      2100            .word	$2100
01165 02D0                        40            .byte	$40
01166 02D1                  00000001            .blkb	1
01167                                           ! 624       { 0x2267, 0x2247, 0x2207, 0x2200, 0x40 },
01168 02D2                      2267            .word	$2267
01169 02D4                      2247            .word	$2247
01170 02D6                      2207            .word	$2207
01171 02D8                      2200            .word	$2200
01172 02DA                        40            .byte	$40
01173 02DB                  00000001            .blkb	1
01174                                           ! 625       { 0x2368, 0x2348, 0x2308, 0x2300, 0x40 },
01175 02DC                      2368            .word	$2368
01176 02DE                      2348            .word	$2348
01177 02E0                      2308            .word	$2308
01178 02E2                      2300            .word	$2300
01179 02E4                        40            .byte	$40
01180 02E5                  00000001            .blkb	1
01181                                           ! 626       { 0x246a, 0x244a, 0x240a, 0x2400, 0x40 },
01182 02E6                      246A            .word	$246A
01183 02E8                      244A            .word	$244A
01184 02EA                      240A            .word	$240A
01185 02EC                      2400            .word	$2400
01186 02EE                        40            .byte	$40
01187 02EF                  00000001            .blkb	1
01188                                           ! 627       { 0x256b, 0x254b, 0x250b, 0x2500, 0x40 },
01189 02F0                      256B            .word	$256B
01190 02F2                      254B            .word	$254B
01191 02F4                      250B            .word	$250B
01192 02F6                      2500            .word	$2500
01193 02F8                        40            .byte	$40
01194 02F9                  00000001            .blkb	1
01195                                           ! 628       { 0x266c, 0x264c, 0x260c, 0x2600, 0x40 },
01196 02FA                      266C            .word	$266C
01197 02FC                      264C            .word	$264C
01198 02FE                      260C            .word	$260C
01199 0300                      2600            .word	$2600
01200 0302                        40            .byte	$40
01201 0303                  00000001            .blkb	1
01202                                           ! 629       { 0x273b, 0x273a, 0, 0, 0 },
01203 0304                      273B            .word	$273B
01204 0306                      273A            .word	$273A
01205 0308                      0000            .word	0
01206 030A                      0000            .word	0
01207 030C                        00            .byte	0
01208 030D                  00000001            .blkb	1
01209                                           ! 630       { 0x2827, 0x2822, 0, 0, 0 },
01210 030E                      2827            .word	$2827
01211 0310                      2822            .word	$2822
01212 0312                      0000            .word	0
01213 0314                      0000            .word	0
01214 0316                        00            .byte	0
01215 0317                  00000001            .blkb	1
01216                                           ! 631       { 0x2960, 0x297e, 0, 0, 0 },
01217 0318                      2960            .word	$2960
01218 031A                      297E            .word	$297E
01219 031C                      0000            .word	0
01220 031E                      0000            .word	0
01221 0320                        00            .byte	0
01222 0321                  00000001            .blkb	1
01223                                           ! 632       { 0, 0, 0, 0, 0 },
01224 0322                      0000            .word	0
01225 0324                      0000            .word	0
01226 0326                      0000            .word	0
01227 0328                      0000            .word	0
01228 032A                        00            .byte	0
01229 032B                  00000001            .blkb	1
01230                                           ! 633       { 0x2b5c, 0x2b7c, 0x2b1c, 0, 0 },
01231 032C                      2B5C            .word	$2B5C
01232 032E                      2B7C            .word	$2B7C
01233 0330                      2B1C            .word	$2B1C
01234 0332                      0000            .word	0
01235 0334                        00            .byte	0
01236 0335                  00000001            .blkb	1
01237                                           ! 634       { 0x2c7a, 0x2c5a, 0x2c1a, 0x2c00, 0x40 },
01238 0336                      2C7A            .word	$2C7A
01239 0338                      2C5A            .word	$2C5A
01240 033A                      2C1A            .word	$2C1A
01241 033C                      2C00            .word	$2C00
01242 033E                        40            .byte	$40
01243 033F                  00000001            .blkb	1
01244                                           ! 635       { 0x2d78, 0x2d58, 0x2d18, 0x2d00, 0x40 },
01245 0340                      2D78            .word	$2D78
01246 0342                      2D58            .word	$2D58
01247 0344                      2D18            .word	$2D18
01248 0346                      2D00            .word	$2D00
01249 0348                        40            .byte	$40
01250 0349                  00000001            .blkb	1
01251                                           ! 636       { 0x2e63, 0x2e43, 0x2e03, 0x2e00, 0x40 },
01252 034A                      2E63            .word	$2E63
01253 034C                      2E43            .word	$2E43
01254 034E                      2E03            .word	$2E03
01255 0350                      2E00            .word	$2E00
01256 0352                        40            .byte	$40
01257 0353                  00000001            .blkb	1
01258                                           ! 637       { 0x2f76, 0x2f56, 0x2f16, 0x2f00, 0x40 },
01259 0354                      2F76            .word	$2F76
01260 0356                      2F56            .word	$2F56
01261 0358                      2F16            .word	$2F16
01262 035A                      2F00            .word	$2F00
01263 035C                        40            .byte	$40
01264 035D                  00000001            .blkb	1
01265                                           ! 638       { 0x3062, 0x3042, 0x3002, 0x3000, 0x40 },
01266 035E                      3062            .word	$3062
01267 0360                      3042            .word	$3042
01268 0362                      3002            .word	$3002
01269 0364                      3000            .word	$3000
01270 0366                        40            .byte	$40
01271 0367                  00000001            .blkb	1
01272                                           ! 639       { 0x316e, 0x314e, 0x310e, 0x3100, 0x40 },
01273 0368                      316E            .word	$316E
01274 036A                      314E            .word	$314E
01275 036C                      310E            .word	$310E
01276 036E                      3100            .word	$3100
01277 0370                        40            .byte	$40
01278 0371                  00000001            .blkb	1
01279                                           ! 640       { 0x326d, 0x324d, 0x320d, 0x3200, 0x40 },
01280 0372                      326D            .word	$326D
01281 0374                      324D            .word	$324D
01282 0376                      320D            .word	$320D
01283 0378                      3200            .word	$3200
01284 037A                        40            .byte	$40
01285 037B                  00000001            .blkb	1
01286                                           ! 641       { 0x332c, 0x333c, 0, 0, 0 },
01287 037C                      332C            .word	$332C
01288 037E                      333C            .word	$333C
01289 0380                      0000            .word	0
01290 0382                      0000            .word	0
01291 0384                        00            .byte	0
01292 0385                  00000001            .blkb	1
01293                                           ! 642       { 0x342e, 0x343e, 0, 0, 0 },
01294 0386                      342E            .word	$342E
01295 0388                      343E            .word	$343E
01296 038A                      0000            .word	0
01297 038C                      0000            .word	0
01298 038E                        00            .byte	0
01299 038F                  00000001            .blkb	1
01300                                           ! 643       { 0x352f, 0x353f, 0, 0, 0 },
01301 0390                      352F            .word	$352F
01302 0392                      353F            .word	$353F
01303 0394                      0000            .word	0
01304 0396                      0000            .word	0
01305 0398                        00            .byte	0
01306 0399                  00000001            .blkb	1
01307                                           ! 644       { 0, 0, 0, 0, 0 },
01308 039A                      0000            .word	0
01309 039C                      0000            .word	0
01310 039E                      0000            .word	0
01311 03A0                      0000            .word	0
01312 03A2                        00            .byte	0
01313 03A3                  00000001            .blkb	1
01314                                           ! 645       { 0x372a, 0x372a, 0, 0, 0 },
01315 03A4                      372A            .word	$372A
01316 03A6                      372A            .word	$372A
01317 03A8                      0000            .word	0
01318 03AA                      0000            .word	0
01319 03AC                        00            .byte	0
01320 03AD                  00000001            .blkb	1
01321                                           ! 646       { 0, 0, 0, 0, 0 },
01322 03AE                      0000            .word	0
01323 03B0                      0000            .word	0
01324 03B2                      0000            .word	0
01325 03B4                      0000            .word	0
01326 03B6                        00            .byte	0
01327 03B7                  00000001            .blkb	1
01328                                           ! 647       { 0x3920, 0x3920, 0x3920, 0x3920, 0 },
01329 03B8                      3920            .word	$3920
01330 03BA                      3920            .word	$3920
01331 03BC                      3920            .word	$3920
01332 03BE                      3920            .word	$3920
01333 03C0                        00            .byte	0
01334 03C1                  00000001            .blkb	1
01335                                           ! 648       { 0, 0, 0, 0, 0 },
01336 03C2                      0000            .word	0
01337 03C4                      0000            .word	0
01338 03C6                      0000            .word	0
01339 03C8                      0000            .word	0
01340 03CA                        00            .byte	0
01341 03CB                  00000001            .blkb	1
01342                                           ! 649       { 0x3b00, 0x5400, 0x5e00, 0x6800, 0 },
01343 03CC                      3B00            .word	$3B00
01344 03CE                      5400            .word	$5400
01345 03D0                      5E00            .word	$5E00
01346 03D2                      6800            .word	$6800
01347 03D4                        00            .byte	0
01348 03D5                  00000001            .blkb	1
01349                                           ! 650       { 0x3c00, 0x5500, 0x5f00, 0x6900, 0 },
01350 03D6                      3C00            .word	$3C00
01351 03D8                      5500            .word	$5500
01352 03DA                      5F00            .word	$5F00
01353 03DC                      6900            .word	$6900
01354 03DE                        00            .byte	0
01355 03DF                  00000001            .blkb	1
01356                                           ! 651       { 0x3d00, 0x5600, 0x6000, 0x6a00, 0 },
01357 03E0                      3D00            .word	$3D00
01358 03E2                      5600            .word	$5600
01359 03E4                      6000            .word	$6000
01360 03E6                      6A00            .word	$6A00
01361 03E8                        00            .byte	0
01362 03E9                  00000001            .blkb	1
01363                                           ! 652       { 0x3e00, 0x5700, 0x6100, 0x6b00, 0 },
01364 03EA                      3E00            .word	$3E00
01365 03EC                      5700            .word	$5700
01366 03EE                      6100            .word	$6100
01367 03F0                      6B00            .word	$6B00
01368 03F2                        00            .byte	0
01369 03F3                  00000001            .blkb	1
01370                                           ! 653       { 0x3f00, 0x5800, 0x6200, 0x6c00, 0 },
01371 03F4                      3F00            .word	$3F00
01372 03F6                      5800            .word	$5800
01373 03F8                      6200            .word	$6200
01374 03FA                      6C00            .word	$6C00
01375 03FC                        00            .byte	0
01376 03FD                  00000001            .blkb	1
01377                                           ! 654       { 0x4000, 0x5900, 0x6300, 0x6d00, 0 },
01378 03FE                      4000            .word	$4000
01379 0400                      5900            .word	$5900
01380 0402                      6300            .word	$6300
01381 0404                      6D00            .word	$6D00
01382 0406                        00            .byte	0
01383 0407                  00000001            .blkb	1
01384                                           ! 655       { 0x4100, 0x5a00, 0x6400, 0x6e00, 0 },
01385 0408                      4100            .word	$4100
01386 040A                      5A00            .word	$5A00
01387 040C                      6400            .word	$6400
01388 040E                      6E00            .word	$6E00
01389 0410                        00            .byte	0
01390 0411                  00000001            .blkb	1
01391                                           ! 656       { 0x4200, 0x5b00, 0x6500, 0x6f00, 0 },
01392 0412                      4200            .word	$4200
01393 0414                      5B00            .word	$5B00
01394 0416                      6500            .word	$6500
01395 0418                      6F00            .word	$6F00
01396 041A                        00            .byte	0
01397 041B                  00000001            .blkb	1
01398                                           ! 657       { 0x4300, 0x5c00, 0x6600, 0x
01399 041C                      4300            .word	$4300
01400 041E                      5C00            .word	$5C00
01401 0420                      6600            .word	$6600
01402                                           ! 657 7000, 0 },
01403 0422                      7000            .word	$7000
01404 0424                        00            .byte	0
01405 0425                  00000001            .blkb	1
01406                                           ! 658       { 0x4400, 0x5d00, 0x6700, 0x7100, 0 },
01407 0426                      4400            .word	$4400
01408 0428                      5D00            .word	$5D00
01409 042A                      6700            .word	$6700
01410 042C                      7100            .word	$7100
01411 042E                        00            .byte	0
01412 042F                  00000001            .blkb	1
01413                                           ! 659       { 0, 0, 0, 0, 0 },
01414 0430                      0000            .word	0
01415 0432                      0000            .word	0
01416 0434                      0000            .word	0
01417 0436                      0000            .word	0
01418 0438                        00            .byte	0
01419 0439                  00000001            .blkb	1
01420                                           ! 660       { 0, 0, 0, 0, 0 },
01421 043A                      0000            .word	0
01422 043C                      0000            .word	0
01423 043E                      0000            .word	0
01424 0440                      0000            .word	0
01425 0442                        00            .byte	0
01426 0443                  00000001            .blkb	1
01427                                           ! 661       { 0x4700, 0x4737, 0x7700, 0, 0x20 },
01428 0444                      4700            .word	$4700
01429 0446                      4737            .word	$4737
01430 0448                      7700            .word	$7700
01431 044A                      0000            .word	0
01432 044C                        20            .byte	$20
01433 044D                  00000001            .blkb	1
01434                                           ! 662       { 0x4800, 0x4838, 0, 0, 0x20 },
01435 044E                      4800            .word	$4800
01436 0450                      4838            .word	$4838
01437 0452                      0000            .word	0
01438 0454                      0000            .word	0
01439 0456                        20            .byte	$20
01440 0457                  00000001            .blkb	1
01441                                           ! 663       { 0x4900, 0x4939, 0x8400, 0, 0x20 },
01442 0458                      4900            .word	$4900
01443 045A                      4939            .word	$4939
01444 045C                      8400            .word	$8400
01445 045E                      0000            .word	0
01446 0460                        20            .byte	$20
01447 0461                  00000001            .blkb	1
01448                                           ! 664       { 0x4a2d, 0x4a2d, 0, 0, 0 },
01449 0462                      4A2D            .word	$4A2D
01450 0464                      4A2D            .word	$4A2D
01451 0466                      0000            .word	0
01452 0468                      0000            .word	0
01453 046A                        00            .byte	0
01454 046B                  00000001            .blkb	1
01455                                           ! 665       { 0x4b00, 0x4b34, 0x7300, 0, 0x20 },
01456 046C                      4B00            .word	$4B00
01457 046E                      4B34            .word	$4B34
01458 0470                      7300            .word	$7300
01459 0472                      0000            .word	0
01460 0474                        20            .byte	$20
01461 0475                  00000001            .blkb	1
01462                                           ! 666       { 0x4c00, 0x4c35, 0, 0, 0x20 },
01463 0476                      4C00            .word	$4C00
01464 0478                      4C35            .word	$4C35
01465 047A                      0000            .word	0
01466 047C                      0000            .word	0
01467 047E                        20            .byte	$20
01468 047F                  00000001            .blkb	1
01469                                           ! 667       { 0x4d00, 0x4d36, 0x7400, 0, 0x20 },
01470 0480                      4D00            .word	$4D00
01471 0482                      4D36            .word	$4D36
01472 0484                      7400            .word	$7400
01473 0486                      0000            .word	0
01474 0488                        20            .byte	$20
01475 0489                  00000001            .blkb	1
01476                                           ! 668       { 0x4e2b, 0x4e2b, 0, 0, 0 },
01477 048A                      4E2B            .word	$4E2B
01478 048C                      4E2B            .word	$4E2B
01479 048E                      0000            .word	0
01480 0490                      0000            .word	0
01481 0492                        00            .byte	0
01482 0493                  00000001            .blkb	1
01483                                           ! 669       { 0x4f00, 0x4f31, 0x7500, 0, 0x20 },
01484 0494                      4F00            .word	$4F00
01485 0496                      4F31            .word	$4F31
01486 0498                      7500            .word	$7500
01487 049A                      0000            .word	0
01488 049C                        20            .byte	$20
01489 049D                  00000001            .blkb	1
01490                                           ! 670       { 0x5000, 0x5032, 0, 0, 0x20 },
01491 049E                      5000            .word	$5000
01492 04A0                      5032            .word	$5032
01493 04A2                      0000            .word	0
01494 04A4                      0000            .word	0
01495 04A6                        20            .byte	$20
01496 04A7                  00000001            .blkb	1
01497                                           ! 671       { 0x5100, 0x5133, 0x7600, 0, 0x20 },
01498 04A8                      5100            .word	$5100
01499 04AA                      5133            .word	$5133
01500 04AC                      7600            .word	$7600
01501 04AE                      0000            .word	0
01502 04B0                        20            .byte	$20
01503 04B1                  00000001            .blkb	1
01504                                           ! 672       { 0x5200, 0x5230, 0, 0, 0x20 },
01505 04B2                      5200            .word	$5200
01506 04B4                      5230            .word	$5230
01507 04B6                      0000            .word	0
01508 04B8                      0000            .word	0
01509 04BA                        20            .byte	$20
01510 04BB                  00000001            .blkb	1
01511                                           ! 673       { 0x5300, 0x532e, 0, 0, 0x20 },
01512 04BC                      5300            .word	$5300
01513 04BE                      532E            .word	$532E
01514 04C0                      0000            .word	0
01515 04C2                      0000            .word	0
01516 04C4                        20            .byte	$20
01517 04C5                  00000001            .blkb	1
01518                                           ! 674       { 0, 0, 0, 0, 0 },
01519 04C6                      0000            .word	0
01520 04C8                      0000            .word	0
01521 04CA                      0000            .word	0
01522 04CC                      0000            .word	0
01523 04CE                        00            .byte	0
01524 04CF                  00000001            .blkb	1
01525                                           ! 675       { 0, 0, 0, 0, 0 },
01526 04D0                      0000            .word	0
01527 04D2                      0000            .word	0
01528 04D4                      0000            .word	0
01529 04D6                      0000            .word	0
01530 04D8                        00            .byte	0
01531 04D9                  00000001            .blkb	1
01532                                           ! 676       { 0x565c, 0x567c, 0, 0, 0 },
01533 04DA                      565C            .word	$565C
01534 04DC                      567C            .word	$567C
01535 04DE                      0000            .word	0
01536 04E0                      0000            .word	0
01537 04E2                        00            .byte	0
01538 04E3                  00000001            .blkb	1
01539                                           ! 677       { 0x8500, 0x8700, 0x8900, 0x8b00, 0 },
01540 04E4                      8500            .word	$8500
01541 04E6                      8700            .word	$8700
01542 04E8                      8900            .word	$8900
01543 04EA                      8B00            .word	$8B00
01544 04EC                        00            .byte	0
01545 04ED                  00000001            .blkb	1
01546                                           ! 678       { 0x8600, 0x8800, 0x8a00, 0x8c00, 0 },
01547 04EE                      8600            .word	$8600
01548 04F0                      8800            .word	$8800
01549 04F2                      8A00            .word	$8A00
01550 04F4                      8C00            .word	$8C00
01551 04F6                        00            .byte	0
01552 04F7                  00000001            .blkb	1
01553                                           ! 679       };
01554                                           !BCC_EOS
01555                                           ! 680   Bit8u
01556                                           ! 681 inb(port)
01557                                           ! 682   Bit16u port;
01558                                           
01559                                           export	_inb
01560                       000004F8            _inb:
01561                                           !BCC_EOS
01562                                           ! 683 {
01563                                           ! 684 #asm
01564                                           !BCC_ASM
01565                       00000002            _inb.port	set	2
01566 04F8           55                           push bp
01567 04F9           89E5                         mov bp, sp
01568 04FB           52                             push dx
01569 04FC           8B56         04                mov dx, 4[bp]
01570 04FF           EC                             in al, dx
01571 0500           5A                             pop dx
01572 0501           5D                           pop bp
01573                                           ! 692 endasm
01574                                           !BCC_ENDASM
01575                                           ! 693 }
01576 0502           C3                         ret
01577                                           ! 694   Bit16u
01578                                           ! 695 inw(port)
01579                                           ! 696   Bit16u port;
01580                                           export	_inw
01581                       00000503            _inw:
01582                                           !BCC_EOS
01583                                           ! 697 {
01584                                           ! 698 #asm
01585                                           !BCC_ASM
01586                       00000002            _inw.port	set	2
01587 0503           55                           push bp
01588 0504           89E5                         mov bp, sp
01589 0506           52                             push dx
01590 0507           8B56         04                mov dx, 4[bp]
01591 050A           ED                             in ax, dx
01592 050B           5A                             pop dx
01593 050C           5D                           pop bp
01594                                           ! 706 endasm
01595                                           !BCC_ENDASM
01596                                           ! 707 }
01597 050D           C3                         ret
01598                                           ! 708   void
01599                                           ! 709 outb(port, val)
01600                                           ! 710   Bit16u port;
01601                                           export	_outb
01602                       0000050E            _outb:
01603                                           !BCC_EOS
01604                                           ! 711   Bit8u val;
01605                                           !BCC_EOS
01606                                           ! 712 {
01607                                           ! 713 #asm
01608                                           !BCC_ASM
01609                       00000004            _outb.val	set	4
01610                       00000002            _outb.port	set	2
01611 050E           55                           push bp
01612 050F           89E5                         mov bp, sp
01613 0511           50                             push ax
01614 0512           52                             push dx
01615 0513           8B56         04                mov dx, 4[bp]
01616 0516           8A46         06                mov al, 6[bp]
01617 0519           EE                             out dx, al
01618 051A           5A                             pop dx
01619 051B           58                             pop ax
01620 051C           5D                           pop bp
01621                                           ! 724 endasm
01622                                           !BCC_ENDASM
01623                                           ! 725 }
01624 051D           C3                         ret
01625                                           ! 726   void
01626                                           ! 727 outw(port, val)
01627                                           ! 728   Bit16u port;
01628                                           export	_outw
01629                       0000051E            _outw:
01630                                           !BCC_EOS
01631                                           ! 729   Bit16u val;
01632                                           !BCC_EOS
01633                                           ! 730 {
01634                                           ! 731 #asm
01635                                           !BCC_ASM
01636                       00000004            _outw.val	set	4
01637                       00000002            _outw.port	set	2
01638 051E           55                           push bp
01639 051F           89E5                         mov bp, sp
01640 0521           50                             push ax
01641 0522           52                             push dx
01642 0523           8B56         04                mov dx, 4[bp]
01643 0526           8B46         06                mov ax, 6[bp]
01644 0529           EF                             out dx, ax
01645 052A           5A                             pop dx
01646 052B           58                             pop ax
01647 052C           5D                           pop bp
01648                                           ! 742 endasm
01649                                           !BCC_ENDASM
01650                                           ! 743 }
01651 052D           C3                         ret
01652                                           ! 744   void
01653                                           ! 745 outb_cmos(cmos_reg, val)
01654                                           ! 746   Bit8u cmos_reg;
01655                                           export	_outb_cmos
01656                       0000052E            _outb_cmos:
01657                                           !BCC_EOS
01658                                           ! 747   Bit8u val;
01659                                           !BCC_EOS
01660                                           ! 748 {
01661                                           ! 749 #asm
01662                                           !BCC_ASM
01663                       00000002            _outb_cmos.cmos_reg	set	2
01664                       00000004            _outb_cmos.val	set	4
01665 052E           55                           push bp
01666 052F           89E5                         mov bp, sp
01667 0531           8A46         04                mov al, 4[bp] ;; cmos_reg
01668 0534           E6                     70      out 0x0070, al
01669 0536           8A46         06                mov al, 6[bp] ;; val
01670 0539           E6                     71      out 0x0071, al
01671 053B           5D                           pop bp
01672                                           ! 757 endasm
01673                                           !BCC_ENDASM
01674                                           ! 758 }
01675 053C           C3                         ret
01676                                           ! 759   Bit8u
01677                                           ! 760 inb_cmos(cmos_reg)
01678                                           ! 761   Bit8u cmos_reg;
01679                                           export	_inb_cmos
01680                       0000053D            _inb_cmos:
01681                                           !BCC_EOS
01682                                           ! 762 {
01683                                           ! 763 #asm
01684                                           !BCC_ASM
01685                       00000002            _inb_cmos.cmos_reg	set	2
01686 053D           55                           push bp
01687 053E           89E5                         mov bp, sp
01688 0540           8A46         04                mov al, 4[bp] ;; cmos_reg
01689 0543           E6                     70      out 0x0070, al
01690 0545           E4                     71      in al, 0x0071
01691 0547           5D                           pop bp
01692                                           ! 770 endasm
01693                                           !BCC_ENDASM
01694                                           ! 771 }
01695 0548           C3                         ret
01696                                           ! 772   void
01697                                           ! 773 init_rtc()
01698                                           ! 774 {
01699                                           export	_init_rtc
01700                       00000549            _init_rtc:
01701                                           ! 775   outb_cmos(0x0a, 0x26);
01702 0549           55                         push	bp
01703 054A           89E5                       mov	bp,sp
01704                                           ! Debug: list int = const $26 (used reg = )
01705 054C           B8                   0026  mov	ax,*$26
01706 054F           50                         push	ax
01707                                           ! Debug: list int = const $A (used reg = )
01708 0550           B8                   000A  mov	ax,*$A
01709 0553           50                         push	ax
01710                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01711 0554           E8         FFD7            call	_outb_cmos
01712 0557           89EC                       mov	sp,bp
01713                                           !BCC_EOS
01714                                           ! 776   outb_cmos(0x0b, 0x02);
01715                                           ! Debug: list int = const 2 (used reg = )
01716 0559           B8                   0002  mov	ax,*2
01717 055C           50                         push	ax
01718                                           ! Debug: list int = const $B (used reg = )
01719 055D           B8                   000B  mov	ax,*$B
01720 0560           50                         push	ax
01721                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01722 0561           E8         FFCA            call	_outb_cmos
01723 0564           89EC                       mov	sp,bp
01724                                           !BCC_EOS
01725                                           ! 777   inb_cmos(0x0c);
01726                                           ! Debug: list int = const $C (used reg = )
01727 0566           B8                   000C  mov	ax,*$C
01728 0569           50                         push	ax
01729                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01730 056A           E8         FFD0            call	_inb_cmos
01731 056D           89EC                       mov	sp,bp
01732                                           !BCC_EOS
01733                                           ! 778   inb_cmos(0x0d);
01734                                           ! Debug: list int = const $D (used reg = )
01735 056F           B8                   000D  mov	ax,*$D
01736 0572           50                         push	ax
01737                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01738 0573           E8         FFC7            call	_inb_cmos
01739 0576           89EC                       mov	sp,bp
01740                                           !BCC_EOS
01741                                           ! 779 }
01742 0578           5D                         pop	bp
01743 0579           C3                         ret
01744                                           ! 780   bx_bool
01745                                           ! 781 rtc_updating()
01746                                           ! 782 {
01747                                           export	_rtc_updating
01748                       0000057A            _rtc_updating:
01749                                           ! 783   Bit16u count;
01750                                           !BCC_EOS
01751                                           ! 784   count = 25000;
01752 057A           55                         push	bp
01753 057B           89E5                       mov	bp,sp
01754 057D           4C                         dec	sp
01755 057E           4C                         dec	sp
01756                                           ! Debug: eq int = const $61A8 to unsigned short count = [S+4-4] (used reg = )
01757 057F           B8                   61A8  mov	ax,#$61A8
01758 0582           8946         FE            mov	-2[bp],ax
01759                                           !BCC_EOS
01760                                           ! 785   while (--count != 0) {
01761 0585           EB           15            jmp .3
01762                       00000587            .4:
01763                                           ! 786     if ( (i
01764                                           ! 786 nb_cmos(0x0a) & 0x80) == 0 )
01765                                           ! Debug: list int = const $A (used reg = )
01766 0587           B8                   000A  mov	ax,*$A
01767 058A           50                         push	ax
01768                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01769 058B           E8         FFAF            call	_inb_cmos
01770 058E           44                         inc	sp
01771 058F           44                         inc	sp
01772                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
01773 0590           24                     80  and	al,#$80
01774                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
01775 0592           84C0                       test	al,al
01776 0594           75           06            jne 	.5
01777                       00000596            .6:
01778                                           ! 787       return(0);
01779 0596           31C0                       xor	ax,ax
01780 0598           89EC                       mov	sp,bp
01781 059A           5D                         pop	bp
01782 059B           C3                         ret
01783                                           !BCC_EOS
01784                                           ! 788     }
01785                       0000059C            .5:
01786                                           ! 789   return(1);
01787                       0000059C            .3:
01788                                           ! Debug: predec unsigned short count = [S+4-4] (used reg = )
01789 059C           8B46         FE            mov	ax,-2[bp]
01790 059F           48                         dec	ax
01791 05A0           8946         FE            mov	-2[bp],ax
01792                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
01793 05A3           85C0                       test	ax,ax
01794 05A5           75           E0            jne	.4
01795                       000005A7            .7:
01796                       000005A7            .2:
01797 05A7           B8                   0001  mov	ax,*1
01798 05AA           89EC                       mov	sp,bp
01799 05AC           5D                         pop	bp
01800 05AD           C3                         ret
01801                                           !BCC_EOS
01802                                           ! 790 }
01803                                           ! 791   Bit8u
01804                                           ! 792 bin2bcd(value)
01805                                           ! 793   Bit8u value;
01806                                           export	_bin2bcd
01807                       000005AE            _bin2bcd:
01808                                           !BCC_EOS
01809                                           ! 794 {
01810                                           ! 795 #asm
01811                                           !BCC_ASM
01812                       00000002            _bin2bcd.value	set	2
01813 05AE           55                           push bp
01814 05AF           89E5                         mov bp, sp
01815 05B1           52                             push dx
01816 05B2           88E6                           mov dh,ah
01817 05B4           8A26       0000                mov ah, 0
01818 05B8           8A46         04                mov al, 4[bp]
01819 05BB           8A16       000A                mov dl, 10
01820 05BF           F6F2                           div dl
01821 05C1           C0E0                   04      shl al, 4
01822 05C4           00E0                           add al, ah
01823 05C6           88F4                           mov ah, dh
01824 05C8           5A                             pop dx
01825 05C9           5D                           pop bp
01826                                           ! 809 endasm
01827                                           !BCC_ENDASM
01828                                           ! 810 }
01829 05CA           C3                         ret
01830                                           ! 811   Bit8u
01831                                           ! 812 bcd2bin(value)
01832                                           ! 813   Bit8u value;
01833                                           export	_bcd2bin
01834                       000005CB            _bcd2bin:
01835                                           !BCC_EOS
01836                                           ! 814 {
01837                                           ! 815 #asm
01838                                           !BCC_ASM
01839                       00000002            _bcd2bin.value	set	2
01840 05CB           55                           push bp
01841 05CC           89E5                         mov bp, sp
01842 05CE           52                             push dx
01843 05CF           88E6                           mov dh,ah
01844 05D1           8A66         04                mov ah, 4[bp]
01845 05D4           88E0                           mov al, ah
01846 05D6           2206       000F                and al,0x0f
01847 05DA           C0EC                   04      shr ah, 4
01848 05DD           00E0                           add al, ah
01849 05DF           88F4                           mov ah,dh
01850 05E1           5A                             pop dx
01851 05E2           5D                           pop bp
01852                                           ! 828 endasm
01853                                           !BCC_ENDASM
01854                                           ! 829 }
01855 05E3           C3                         ret
01856                                           ! 830   Bit8u
01857                                           ! 831 _read_byte(offset, seg)
01858                                           ! 832   Bit16u offset;
01859                                           export	__read_byte
01860                       000005E4            __read_byte:
01861                                           !BCC_EOS
01862                                           ! 833   Bit16u seg;
01863                                           !BCC_EOS
01864                                           ! 834 {
01865                                           ! 835 #asm
01866                                           !BCC_ASM
01867                       00000004            __read_byte.seg	set	4
01868                       00000002            __read_byte.offset	set	2
01869 05E4           55                           push bp
01870 05E5           89E5                         mov bp, sp
01871 05E7           53                             push bx
01872 05E8           1E                             push ds
01873 05E9           C55E         04                lds bx, 4[bp] ; segment & offset
01874 05EC           8A07                           mov al, [bx]
01875                                               ;; al = return value (byte)
01876 05EE           1F                             pop ds
01877 05EF           5B                             pop bx
01878 05F0           5D                           pop bp
01879                                           ! 846 endasm
01880                                           !BCC_ENDASM
01881                                           ! 847 }
01882 05F1           C3                         ret
01883                                           ! 848   Bit16u
01884                                           ! 849 _read_word(offset, seg)
01885                                           ! 850   Bit16u offset;
01886                                           export	__read_word
01887                       000005F2            __read_word:
01888                                           !BCC_EOS
01889                                           ! 851   Bit16u seg;
01890                                           !BCC_EOS
01891                                           ! 852 {
01892                                           ! 853 #asm
01893                                           !BCC_ASM
01894                       00000004            __read_word.seg	set	4
01895                       00000002            __read_word.offset	set	2
01896 05F2           55                           push bp
01897 05F3           89E5                         mov bp, sp
01898 05F5           53                             push bx
01899 05F6           1E                             push ds
01900 05F7           C55E         04                lds bx, 4[bp] ; segment & offset
01901 05FA           8B07                           mov ax, [bx]
01902                                               ;; ax = return value (word)
01903 05FC           1F                             pop ds
01904 05FD           5B                             pop bx
01905 05FE           5D                           pop bp
01906                                           ! 864 endasm
01907                                           !BCC_ENDASM
01908                                           ! 865 }
01909 05FF           C3                         ret
01910                                           ! 866   void
01911                                           ! 867 _write_byte(data, offset, seg)
01912                                           ! 868   Bit8u data;
01913                                           export	__write_byte
01914                       00000600            __write_byte:
01915                                           !BCC_EOS
01916                                           ! 869   Bit16u offset;
01917                                           !BCC_EOS
01918                                           ! 870   Bit16u seg;
01919                                           !BCC_EOS
01920                                           ! 871 {
01921                                           ! 872 #asm
01922                                           !BCC_ASM
01923                       00000006            __write_byte.seg	set	6
01924                       00000002            __write_byte.data	set	2
01925                       00000004            __write_byte.offset	set	4
01926 0600           55                           push bp
01927 0601           89E5                         mov bp, sp
01928 0603           50                             push ax
01929 0604           53                             push bx
01930 0605           1E                             push ds
01931 0606           C55E         06                lds bx, 6[bp] ; segment & offset
01932 0609           8A46         04                mov al, 4[bp] ; data byte
01933 060C           8807                           mov [bx], al ; write data byte
01934 060E           1F                             pop ds
01935 060F           5B                             pop bx
01936 0610           58                             pop ax
01937 0611           5D                           pop bp
01938                                           ! 885 endasm
01939                                           !BCC_ENDASM
01940                                           ! 886 }
01941 0612           C3                         ret
01942                                           ! 887   void
01943                                           ! 888 _write_word(data, offset, seg)
01944                                           ! 889   Bit16u data;
01945                                           export	__write_word
01946                       00000613            __write_word:
01947                                           !BCC_EOS
01948                                           ! 890   Bit16u offset;
01949                                           !BCC_EOS
01950                                           ! 891   Bit16u seg;
01951                                           !BCC_EOS
01952                                           ! 892 {
01953                                           ! 893 #asm
01954                                           !BCC_ASM
01955                       00000006            __write_word.seg	set	6
01956                       00000002            __write_word.data	set	2
01957                       00000004            __write_word.offset	set	4
01958 0613           55                           push bp
01959 0614           89E5                         mov bp, sp
01960 0616           50                             push ax
01961 0617           53                             push bx
01962 0618           1E                             push ds
01963 0619           C55E         06                lds bx, 6[bp] ; segment & offset
01964 061C           8B46         04                mov ax, 4[bp] ; data word
01965 061F           8907                           mov [bx], ax ; write data word
01966 0621           1F                             pop ds
01967 0622           5B                             pop bx
01968 0623           58                             pop ax
01969 0624           5D                           pop bp
01970                                           ! 906 endasm
01971                                           !BCC_ENDASM
01972                                           ! 907 }
01973 0625           C3                         ret
01974                                           ! 908   Bit8u
01975                                           ! 909 read_byte_SS(offset)
01976                                           ! 910   Bit16u offset;
01977                                           export	_read_byte_SS
01978                       00000626            _read_byte_SS:
01979                                           !BCC_EOS
01980                                           ! 911 {
01981                                           ! 912 #asm
01982                                           !BCC_ASM
01983                       00000002            _read_byte_SS.offset	set	2
01984 0626           55                           push bp
01985 0627           89E5                         mov bp, sp
01986 0629           8B6E         04              mov bp, 4[bp] ; offset
01987 062C           8A46         00              mov al, [bp]
01988                                             ;; al = return value (byte)
01989 062F           5D                           pop bp
01990                                           ! 919 endasm
01991                                           !BCC_ENDASM
01992                                           ! 920 }
01993 0630           C3                         ret
01994                                           ! 921   Bit16u
01995                                           ! 922 read_word_SS(offset)
01996                                           ! 923   Bit16u offset;
01997                                           export	_read_word_SS
01998                       00000631            _read_word_SS:
01999                                           !BCC_EOS
02000                                           ! 924 {
02001                                           ! 925 #asm
02002                                           !BCC_ASM
02003                       00000002            _read_word_SS.offset	set	2
02004 0631           55                           push bp
02005 0632           89E5                         mov bp, sp
02006 0634           8B6E         04              mov bp, 4[bp] ; offset
02007 0637           8B46         00              mov ax, [bp]
02008                                             ;; ax = return value (word)
02009 063A           5D                           pop bp
02010                                           ! 932 endasm
02011                                           !BCC_ENDASM
02012                                           ! 933 }
02013 063B           C3                         ret
02014                                           ! 934   void
02015                                           ! 935 _write_byte_SS(data, offset)
02016                                           ! 936   Bit8u data;
02017                                           export	__write_byte_SS
02018                       0000063C            __write_byte_SS:
02019                                           !BCC_EOS
02020                                           ! 937   Bit16u offset;
02021                                           !BCC_EOS
02022                                           ! 938 {
02023                                           ! 939 #asm
02024                                           !BCC_ASM
02025                       00000002            __write_byte_SS.data	set	2
02026                       00000004            __write_byte_SS.offset	set	4
02027 063C           55                           push bp
02028 063D           89E5                         mov bp, sp
02029 063F           50                           push ax
02030 0640           8A46         04              mov al, 4[bp] ; data byte
02031 0643           8B6E         06              mov bp, 6[bp] ; offset
02032 0646           8846         00              mov [bp], al ; write data byte
02033 0649           58                           pop ax
02034 064A           5D                           pop bp
02035                                           ! 948 endasm
02036                                           !BCC_ENDASM
02037                                           ! 949 }
02038 064B           C3                         ret
02039                                           ! 950   void
02040                                           ! 951 _write_word_SS(data, offset)
02041                                           ! 952   Bit16u data;
02042                                           export	__write_word_SS
02043                       0000064C            __write_word_SS:
02044                                           !BCC_EOS
02045                                           ! 953   Bit16u offset;
02046                                           !BCC_EOS
02047                                           ! 954 {
02048                                           ! 955 #asm
02049                                           !BCC_ASM
02050                       00000002            __write_word_SS.data	set	2
02051                       00000004            __write_word_SS.offset	set	4
02052 064C           55                           push bp
02053 064D           89E5                         mov bp, sp
02054 064F           50                           push ax
02055 0650           8B46         04              mov ax, 4[bp] ; data word
02056 0653           8B6E         06              mov bp, 6[bp] ; offset
02057 0656           8946         00              mov [bp], ax ; write data word
02058 0659           58                           pop ax
02059 065A           5D                           pop bp
02060                                           ! 964 endasm
02061                                           !BCC_ENDASM
02062                                           ! 965 }
02063 065B           C3                         ret
02064                                           ! 966   Bit16u
02065                                           ! 967 get_CS()
02066                                           ! 968 {
02067                                           export	_get_CS
02068                       0000065C            _get_CS:
02069                                           ! 969 #asm
02070                                           !BCC_ASM
02071 065C           8CC8                         mov ax, cs
02072                                           ! 971 endasm
02073                                           !BCC_ENDASM
02074                                           ! 972 }
02075 065E           C3                         ret
02076                                           ! 973   Bit16u
02077                                           ! 974 get_SS()
02078                                           ! 975 {
02079                                           export	_get_SS
02080                       0000065F            _get_SS:
02081                                           ! 976 #asm
02082                                           !BCC_ASM
02083 065F           8CD0                         mov ax, ss
02084                                           ! 978 endasm
02085                                           !BCC_ENDASM
02086                                           ! 979 }
02087 0661           C3                         ret
02088                                           ! 980   Bit16u
02089                                           ! 981 set_DS(seg)
02090                                           ! 982   Bit16u seg;
02091                                           export	_set_DS
02092                       00000662            _set_DS:
02093                                           !BCC_EOS
02094                                           ! 983 {
02095                                           ! 984 #asm
02096                                           !BCC_ASM
02097                       00000002            _set_DS.seg	set	2
02098 0662           55                           push bp
02099 0663           89E5                         mov bp, sp
02100 0665           1E                           push ds
02101 0666           8E5E         04              mov ds, 4[bp] ;; seg
02102 0669           58                           pop ax
02103 066A           5D                           pop bp
02104                                           ! 991 endasm
02105                                           !BCC_ENDASM
02106                                           ! 992 }
02107 066B           C3                         ret
02108                                           ! 993   Bit16u
02109                                           ! 994 get_ebda_seg()
02110                                           ! 995 {
02111                                           export	_get_ebda_seg
02112                       0000066C            _get_ebda_seg:
02113                                           ! 996 #asm
02114                                           !BCC_ASM
02115 066C           53                           push bx
02116 066D           1E                           push ds
02117 066E           B8                   0040    mov ax, #0x0040
02118 0671           8ED8                         mov ds, ax
02119 0673           BB                   000E    mov bx, #0x000e
02120 0676           8B07                         mov ax, [bx]
02121                                             ;; ax = return value (word)
02122 0678           1F                           pop ds
02123 0679           5B                           pop bx
02124                                           ! 1006 endasm
02125                                           !BCC_ENDASM
02126                                           ! 1007 }
02127 067A           C3                         ret
02128                                           ! 1008   void
02129                                           ! 1009 wrch(c)
02130                                           ! 1010   Bit8u c;
02131                                           export	_wrch
02132                       0000067B            _wrch:
02133                                           !BCC_EOS
02134                                           ! 1011 {
02135                                           ! 1012 #asm
02136                                           !BCC_ASM
02137                       00000002            _wrch.c	set	2
02138 067B           55                           push bp
02139 067C           89E5                         mov bp, sp
02140 067E           53                           push bx
02141 067F           B4                     0E    mov ah, #0x0e
02142 0681           8A46         04              mov al, 4[bp]
02143 0684           31DB                         xor bx,bx
02144 0686           CD                     10    int #0x10
02145 0688           5B                           pop bx
02146 0689           5D                           pop bp
02147                                           ! 1022 endasm
02148                                           !BCC_ENDASM
02149                                           ! 1023 }
02150 068A           C3                         ret
02151                                           ! 1024   void
02152                                           ! 1025 send(action, c)
02153                                           ! 1026   Bit16u action;
02154                                           export	_send
02155                       0000068B            _send:
02156                                           !BCC_EOS
02157                                           ! 1027   Bit8u c;
02158                                           !BCC_EOS
02159                                           ! 1028 {
02160                                           ! 1029   if (action & 8) outb(0x403, c);
02161 068B           55                         push	bp
02162 068C           89E5                       mov	bp,sp
02163                                           ! Debug: and int = const 8 to unsigned short action = [S+2+2] (used reg = )
02164 068E           8A46         04            mov	al,4[bp]
02165 0691           24                     08  and	al,*8
02166 0693           84C0                       test	al,al
02167 0695           74           0F            je  	.8
02168                       00000697            .9:
02169                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02170 0697           8A46         06            mov	al,6[bp]
02171 069A           30E4                       xor	ah,ah
02172 069C           50                         push	ax
02173                                           ! Debug: list int = const $403 (used reg = )
02174 069D           B8                   0403  mov	ax,#$403
02175 06A0           50                         push	ax
02176                                           ! Debug: func () void = outb+0 (used reg = )
02177 06A1           E8         FE6A            call	_outb
02178 06A4           89EC                       mov	sp,bp
02179                                           !BCC_EOS
02180                                           ! 1030   if (action & 4) outb(0x402, c);
02181                       000006A6            .8:
02182                                           ! Debug: and int = const 4 to unsigned short action = [S+2+2] (used reg = )
02183 06A6           8A46         04            mov	al,4[bp]
02184 06A9           24                     04  and	al,*4
02185 06AB           84C0                       test	al,al
02186 06AD           74           0F            je  	.A
02187                       000006AF            .B:
02188                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02189 06AF           8A46         06            mov	al,6[bp]
02190 06B2           30E4                       xor	ah,ah
02191 06B4           50                         push	ax
02192                                           ! Debug: list int = const $402 (used reg = )
02193 06B5           B8                   0402  mov	ax,#$402
02194 06B8           50                         push	ax
02195                                           ! Debug: func () void = outb+0 (used reg = )
02196 06B9           E8         FE52            call	_outb
02197 06BC           89EC                       mov	sp,bp
02198                                           !BCC_EOS
02199                                           ! 1031   if (action & 2) {
02200                       000006BE            .A:
02201                                           ! Debug: and int = const 2 to unsigned short action = [S+2+2] (used reg = )
02202 06BE           8A46         04            mov	al,4[bp]
02203 06C1           24                     02  and	al,*2
02204 06C3           84C0                       test	al,al
02205 06C5           74           1B            je  	.C
02206                       000006C7            .D:
02207                                           ! 1032     if (c == '\n') wrch('\r');
02208                                           ! Debug: logeq int = const $A to unsigned char c = [S+2+4] (used reg = )
02209 06C7           8A46         06            mov	al,6[bp]
02210 06CA           3C                     0A  cmp	al,*$A
02211 06CC           75           09            jne 	.E
02212                       000006CE            .F:
02213                                           ! Debug: list int = const $D (used reg = )
02214 06CE           B8                   000D  mov	ax,*$D
02215 06D1           50                         push	ax
02216                                           ! Debug: func () void = wrch+0 (used reg = )
02217 06D2           E8         FFA6            call	_wrch
02218 06D5           89EC                       mov	sp,bp
02219                                           !BCC_EOS
02220                                           ! 1033     wrch(c);
02221                       000006D7            .E:
02222                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02223 06D7           8A46         06            mov	al,6[bp]
02224 06DA           30E4                       xor	ah,ah
02225 06DC           50                         push	ax
02226                                           ! Debug: func () void = wrch+0 (used reg = )
02227 06DD           E8         FF9B            call	_wrch
02228 06E0           89EC                       mov	sp,bp
02229                                           !BCC_EOS
02230                                           ! 1034   }
02231                                           ! 1035 }
02232                       000006E2            .C:
02233 06E2           5D                         pop	bp
02234 06E3           C3                         ret
02235                                           ! 1036   void
02236                                           ! 1037 put_uint(action, val, width, neg)
02237                                           ! 1038   Bit16u action;
02238                                           export	_put_uint
02239                       000006E4            _put_uint:
02240                                           !BCC_EOS
02241                                           ! 1039   unsigned short val;
02242                                           !BCC_EOS
02243                                           ! 1040   short width;
02244                                           !BCC_EOS
02245                                           ! 1041   bx_bool neg;
02246                                           !BCC_EOS
02247                                           ! 1042 {
02248                                           ! 1043   unsigned short nval = val / 10;
02249 06E4           55                         push	bp
02250 06E5           89E5                       mov	bp,sp
02251 06E7           4C                         dec	sp
02252 06E8           4C                         dec	sp
02253                                           ! Debug: div int = const $A to unsigned short val = [S+4+4] (used reg = )
02254 06E9           8B46         06            mov	ax,6[bp]
02255 06EC           BB                   000A  mov	bx,*$A
02256 06EF           E8         FA48            call	idiv_u
02257                                           ! Debug: eq unsigned int = ax+0 to unsigned short nval = [S+4-4] (used reg = )
02258 06F2           8946         FE            mov	-2[bp],ax
02259                                           !BCC_EOS
02260                                           ! 1044   if (nval)
02261 06F5           8B46         FE            mov	ax,-2[bp]
02262 06F8           85C0                       test	ax,ax
02263 06FA           74           16            je  	.10
02264                       000006FC            .11:
02265                                           ! 1045     put_uint(action, nval, width - 1, neg);
02266                                           ! Debug: list unsigned short neg = [S+4+8] (used reg = )
02267 06FC           FF76         0A            push	$A[bp]
02268                                           ! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
02269 06FF           8B46         08            mov	ax,8[bp]
02270                                           ! Debug: list int = ax-1 (used reg = )
02271 0702           48                         dec	ax
02272 0703           50                         push	ax
02273                                           ! Debug: list unsigned short nval = [S+8-4] (used reg = )
02274 0704           FF76         FE            push	-2[bp]
02275                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02276 0707           FF76         04            push	4[bp]
02277                                           ! Debug: func () void = put_uint+0 (used reg = )
02278 070A           E8         FFD7            call	_put_uint
02279 070D           83C4                   08  add	sp,*8
02280                                           !BCC_EOS
02281                                           ! 1046   else {
02282 0710           EB           2E            jmp .12
02283                       00000712            .10:
02284                                           ! 1047     while (--width > 0) send(action, ' ');
02285 0712           EB           0D            jmp .14
02286                       00000714            .15:
02287                                           ! Debug: list int = const $20 (used reg = )
02288 0714           B8                   0020  mov	ax,*$20
02289 0717           50                         push	ax
02290                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02291 0718           FF76         04            push	4[bp]
02292                                           ! Debug: func () void = send+0 (used reg = )
02293 071B           E8         FF6D            call	_send
02294 071E           83C4                   04  add	sp,*4
02295                                           !BCC_EOS
02296                                           ! 1048     if (neg) send(action, '-');
02297                       00000721            .14:
02298                                           ! Debug: predec short width = [S+4+6] (used reg = )
02299 0721           8B46         08            mov	ax,8[bp]
02300 0724           48                         dec	ax
02301 0725           8946         08            mov	8[bp],ax
02302                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02303 0728           85C0                       test	ax,ax
02304 072A           7F           E8            jg 	.15
02305                       0000072C            .16:
02306                       0000072C            .13:
02307 072C           8B46         0A            mov	ax,$A[bp]
02308 072F           85C0                       test	ax,ax
02309 0731           74           0D            je  	.17
02310                       00000733            .18:
02311                                           ! Debug: list int = const $2D (used reg = )
02312 0733           B8                   002D  mov	ax,*$2D
02313 0736           50                         push	ax
02314                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02315 0737           FF76         04            push	4[bp]
02316                                           ! Debug: func () void = send+0 (used reg = )
02317 073A           E8         FF4E            call	_send
02318 073D           83C4                   04  add	sp,*4
02319                                           !BCC_EOS
02320                                           ! 1049   }
02321                       00000740            .17:
02322                                           ! 1050   send(action, val - (nval * 10) + '0');
02323                       00000740            .12:
02324                                           ! Debug: mul int = const $A to unsigned short nval = [S+4-4] (used reg = )
02325 0740           8B46         FE            mov	ax,-2[bp]
02326 0743           89C2                       mov	dx,ax
02327 0745           D1E0                       shl	ax,*1
02328 0747           D1E0                       shl	ax,*1
02329 0749           01D0                       add	ax,dx
02330 074B           D1E0                       shl	ax,*1
02331                                           ! Debug: sub unsigned int = ax+0 to unsigned short val = [S+4+4] (used reg = )
02332 074D           50                         push	ax
02333 074E           8B46         06            mov	ax,6[bp]
02334 0751           2B46         FC            sub	ax,-4[bp]
02335 0754           44                         inc	sp
02336 0755           44                         inc	sp
02337                                           ! Debug: add int = const $30 to unsigned int = ax+0 (used reg = )
02338                                           ! Debug: list unsigned int = ax+$30 (used reg = )
02339 0756           05                   0030  add	ax,*$30
02340 0759           50                         push	ax
02341                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02342 075A           FF76         04            push	4[bp]
02343                                           ! Debug: func () void = send+0 (used reg = )
02344 075D           E8         FF2B            call	_send
02345 0760           83C4                   04  add	sp,*4
02346                                           !BCC_EOS
02347                                           ! 1051 }
02348 0763           89EC                       mov	sp,bp
02349 0765           5D                         pop	bp
02350 0766           C3                         ret
02351                                           ! 1052   void
02352                                           ! Register BX used in function put_uint
02353                                           ! 1053 put_luint(action, val, width, neg)
02354                                           ! 1054   Bit16u action;
02355                                           export	_put_luint
02356                       00000767            _put_luint:
02357                                           !BCC_EOS
02358                                           ! 1055   unsigned long val;
02359                                           !BCC_EOS
02360                                           ! 1056   short width;
02361                                           !BCC_EOS
02362                                           ! 1057   bx_bool neg;
02363                                           !BCC_EOS
02364                                           ! 1058 {
02365                                           ! 1059   unsigned long nval = val / 10;
02366 0767           55                         push	bp
02367 0768           89E5                       mov	bp,sp
02368 076A           83C4                   FC  add	sp,*-4
02369                                           ! Debug: div unsigned long = const $A to unsigned long val = [S+6+4] (used reg = )
02370 076D           B8                   000A  mov	ax,*$A
02371 0770           31DB                       xor	bx,bx
02372 0772           53                         push	bx
02373 0773           50                         push	ax
02374 0774           8B46         06            mov	ax,6[bp]
02375 0777           8B5E         08            mov	bx,8[bp]
02376 077A           8D7E         F8            lea	di,-8[bp]
02377 077D           E8         F9BF            call	ldivul
02378 0780           83C4                   04  add	sp,*4
02379                                           ! Debug: eq unsigned long = bx+0 to unsigned long nval = [S+6-6] (used reg = )
02380 0783           8946         FC            mov	-4[bp],ax
02381 0786           895E         FE            mov	-2[bp],bx
02382                                           !BCC_EOS
02383                                           ! 1060   if (nval)
02384 0789           8B46         FC            mov	ax,-4[bp]
02385 078C           8B5E         FE            mov	bx,-2[bp]
02386 078F           E8         F953            call	ltstl
02387 0792           74           19            je  	.19
02388                       00000794            .1A:
02389                                           ! 1061     put_luint(action, nval, width - 1, neg);
02390                                           ! Debug: list unsigned short neg = [S+6+$A] (used reg = )
02391 0794           FF76         0C            push	$C[bp]
02392                                           ! Debug: sub int = const 1 to short width = [S+8+8] (used reg = )
02393 0797           8B46         0A            mov	ax,$A[bp]
02394                                           ! Debug: list int = ax-1 (used reg = )
02395 079A           48                         dec	ax
02396 079B           50                         push	ax
02397                                           ! Debug: list unsigned long nval = [S+$A-6] (used reg = )
02398 079C           FF76         FE            push	-2[bp]
02399 079F           FF76         FC            push	-4[bp]
02400                                           ! Debug: list unsigned short action = [S+$E+2] (used reg = )
02401 07A2           FF76         04            push	4[bp]
02402                                           ! Debug: func () void = put_luint+0 (used reg = )
02403 07A5           E8         FFBF            call	_put_luint
02404 07A8           83C4                   0A  add	sp,*$A
02405                                           !BCC_EOS
02406                                           ! 1062   else {
02407 07AB           EB           2E            jmp .1B
02408                       000007AD            .19:
02409                                           ! 1063     while (--width > 0) send(action, ' ');
02410 07AD           EB           0D            jmp .1D
02411                       000007AF            .1E:
02412                                           ! Debug: list int = const $20 (used reg = )
02413 07AF           B8                   0020  mov	ax,*$20
02414 07B2           50                         push	ax
02415                                           ! Debug: list unsigned short action = [S+8+2] (used reg = )
02416 07B3           FF76         04            push	4[bp]
02417                                           ! Debug: func () void = send+0 (used reg = )
02418 07B6           E8         FED2            call	_send
02419 07B9           83C4                   04  add	sp,*4
02420                                           !BCC_EOS
02421                                           ! 1064     if (neg) send(action, '-');
02422                       000007BC            .1D:
02423                                           ! Debug: predec short width = [S+6+8] (used reg = )
02424 07BC           8B46         0A            mov	ax,$A[bp]
02425 07BF           48                         dec	ax
02426 07C0           8946         0A            mov	$A[bp],ax
02427                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02428 07C3           85C0                       test	ax,ax
02429 07C5           7F           E8            jg 	.1E
02430                       000007C7            .1F:
02431                       000007C7            .1C:
02432 07C7           8B46         0C            mov	ax,$C[bp]
02433 07CA           85C0                       test	ax,ax
02434 07CC           74           0D            je  	.20
02435                       000007CE            .21:
02436                                           ! Debug: list int = const $2D (used reg = )
02437 07CE           B8                   002D  mov	ax,*$2D
02438 07D1           50                         push	ax
02439                                           ! Debug: list unsigned short action = [S+8+2] (used reg = )
02440 07D2           FF76         04            push	4[bp]
02441                                           ! Debug: func () void = send+0 (used reg = )
02442 07D5           E8         FEB3            call	_send
02443 07D8           83C4                   04  add	sp,*4
02444                                           !BCC_EOS
02445                                           ! 1065   }
02446                       000007DB            .20:
02447                                           ! 1066   send(action, val - (nval * 10) + '0');
02448                       000007DB            .1B:
02449                                           ! Debug: mul unsigned long = const $A to unsigned long nval = [S+6-6] (used reg = )
02450                                           ! Debug: expression subtree swapping
02451 07DB           B8                   000A  mov	ax,*$A
02452 07DE           31DB                       xor	bx,bx
02453 07E0           8D7E         FC            lea	di,-4[bp]
02454 07E3           E8         F8D4            call	lmulul
02455                                           ! Debug: sub unsigned long = bx+0 to unsigned long val = [S+6+4] (used reg = )
02456 07E6           53                         push	bx
02457 07E7           50                         push	ax
02458 07E8           8B46         06            mov	ax,6[bp]
02459 07EB           8B5E         08            mov	bx,8[bp]
02460 07EE           8D7E         F8            lea	di,-8[bp]
02461 07F1           E8         F8BE            call	lsubul
02462 07F4           83C4                   04  add	sp,*4
02463                                           ! Debug: add unsigned long = const $30 to unsigned long = bx+0 (used reg = )
02464 07F7           53                         push	bx
02465 07F8           50                         push	ax
02466 07F9           B8                   0030  mov	ax,*$30
02467 07FC           31DB                       xor	bx,bx
02468 07FE           53                         push	bx
02469 07FF           50                         push	ax
02470 0800           8B46         F8            mov	ax,-8[bp]
02471 0803           8B5E         FA            mov	bx,-6[bp]
02472 0806           8D7E         F4            lea	di,-$C[bp]
02473 0809           E8         F888            call	laddul
02474 080C           83C4                   08  add	sp,*8
02475                                           ! Debug: list unsigned long = bx+0 (used reg = )
02476 080F           53                         push	bx
02477 0810           50                         push	ax
02478                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02479 0811           FF76         04            push	4[bp]
02480                                           ! Debug: func () void = send+0 (used reg = )
02481 0814           E8         FE74            call	_send
02482 0817           83C4                   06  add	sp,*6
02483                                           !BCC_EOS
02484                                           ! 1067 }
02485 081A           89EC                       mov	sp,bp
02486 081C           5D                         pop	bp
02487 081D           C3                         ret
02488                                           ! 1068 void put_str(action, segment, offset)
02489                                           ! Register BX used in function put_luint
02490                                           ! 1069   Bit16u action;
02491                                           export	_put_str
02492                       0000081E            _put_str:
02493                                           !BCC_EOS
02494                                           ! 1070   Bit16u segment;
02495                                           !BCC_EOS
02496                                           ! 1071   Bit16u offset;
02497                                           !BCC_EOS
02498                                           ! 1072 {
02499                                           ! 1073   Bit8u c;
02500                                           !BCC_EOS
02501                                           ! 1074   while (c = _read_byte(offset, segment)) {
02502 081E           55                         push	bp
02503 081F           89E5                       mov	bp,sp
02504 0821           4C                         dec	sp
02505 0822           4C                         dec	sp
02506 0823           EB           16            jmp .23
02507                       00000825            .24:
02508                                           ! 1075     send(action, c);
02509                                           ! Debug: list unsigned char c = [S+4-3] (used reg = )
02510 0825           8A46         FF            mov	al,-1[bp]
02511 0828           30E4                       xor	ah,ah
02512 082A           50                         push	ax
02513                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02514 082B           FF76         04            push	4[bp]
02515                                           ! Debug: func () void = send+0 (used reg = )
02516 082E           E8         FE5A            call	_send
02517 0831           83C4                   04  add	sp,*4
02518                                           !BCC_EOS
02519                                           ! 1076     offset++;
02520                                           ! Debug: postinc unsigned short offset = [S+4+6] (used reg = )
02521 0834           8B46         08            mov	ax,8[bp]
02522 0837           40                         inc	ax
02523 0838           8946         08            mov	8[bp],ax
02524                                           !BCC_EOS
02525                                           ! 1077   }
02526                                           ! 1078 }
02527                       0000083B            .23:
02528                                           ! Debug: list unsigned short segment = [S+4+4] (used reg = )
02529 083B           FF76         06            push	6[bp]
02530                                           ! Debug: list unsigned short offset = [S+6+6] (used reg = )
02531 083E           FF76         08            push	8[bp]
02532                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
02533 0841           E8         FDA0            call	__read_byte
02534 0844           83C4                   04  add	sp,*4
02535                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+4-3] (used reg = )
02536 0847           8846         FF            mov	-1[bp],al
02537 084A           84C0                       test	al,al
02538 084C           75           D7            jne	.24
02539                       0000084E            .25:
02540                       0000084E            .22:
02541 084E           89EC                       mov	sp,bp
02542 0850           5D                         pop	bp
02543 0851           C3                         ret
02544                                           ! 1079   void
02545                                           ! 1080 delay_ticks(ticks)
02546                                           ! 1081   Bit16u ticks;
02547                                           export	_delay_ticks
02548                       00000852            _delay_ticks:
02549                                           !BCC_EOS
02550                                           ! 1082 {
02551                                           ! 1083   long ticks_to_wait, delta;
02552                                           !BCC_EOS
02553                                           ! 1084   Bit32u prev_ticks, t;
02554                                           !BCC_EOS
02555                                           ! 1085 #asm
02556 0852           55                         push	bp
02557 0853           89E5                       mov	bp,sp
02558 0855           83C4                   F0  add	sp,*-$10
02559                                           !BCC_EOS
02560                                           !BCC_ASM
02561                       00000014            _delay_ticks.ticks	set	$14
02562                       00000004            .delay_ticks.ticks	set	4
02563                       00000000            _delay_ticks.t	set	0
02564                       FFFFFFF0            .delay_ticks.t	set	-$10
02565                       00000004            _delay_ticks.prev_ticks	set	4
02566                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02567                       00000008            _delay_ticks.delta	set	8
02568                       FFFFFFF8            .delay_ticks.delta	set	-8
02569                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02570                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02571 0858           9C                           pushf
02572 0859           1E                           push ds
02573 085A           6A                     00    push #0x00
02574 085C           1F                           pop ds
02575 085D           FB                           sti
02576                                           ! 1091 endasm
02577                                           !BCC_ENDASM
02578                                           !BCC_EOS
02579                                           ! 1092   ticks_to_wait = ticks;
02580                                           ! Debug: eq unsigned short ticks = [S+$12+2] to long ticks_to_wait = [S+$12-6] (used reg = )
02581 085E           8B46         04            mov	ax,4[bp]
02582 0861           31DB                       xor	bx,bx
02583 0863           8946         FC            mov	-4[bp],ax
02584 0866           895E         FE            mov	-2[bp],bx
02585                                           !BCC_EOS
02586                                           ! 1093   prev_ticks = *((Bit32u *)(0x46c));
02587                                           ! Debug: eq unsigned long = [+$46C] to unsigned long prev_ticks = [S+$12-$E] (used reg = )
02588 0869           A1         046C            mov	ax,[$46C]
02589 086C           8B1E       046E            mov	bx,[$46E]
02590 0870           8946         F4            mov	-$C[bp],ax
02591 0873           895E         F6            mov	-$A[bp],bx
02592                                           !BCC_EOS
02593                                           ! 1094   do
02594                                           ! 1095   {
02595                       00000876            .28:
02596                                           ! 1096 #asm
02597                                           !BCC_EOS
02598                                           !BCC_ASM
02599                       00000014            _delay_ticks.ticks	set	$14
02600                       00000004            .delay_ticks.ticks	set	4
02601                       00000000            _delay_ticks.t	set	0
02602                       FFFFFFF0            .delay_ticks.t	set	-$10
02603                       00000004            _delay_ticks.prev_ticks	set	4
02604                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02605                       00000008            _delay_ticks.delta	set	8
02606                       FFFFFFF8            .delay_ticks.delta	set	-8
02607                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02608                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02609 0876           F4                             hlt
02610                                           ! 1098 endasm
02611                                           !BCC_ENDASM
02612                                           !BCC_EOS
02613                                           ! 1099     t = *((Bit32u *)(0x46c));
02614                                           ! Debug: eq unsigned long = [+$46C] to unsigned long t = [S+$12-$12] (used reg = )
02615 0877           A1         046C            mov	ax,[$46C]
02616 087A           8B1E       046E            mov	bx,[$46E]
02617 087E           8946         F0            mov	-$10[bp],ax
02618 0881           895E         F2            mov	-$E[bp],bx
02619                                           !BCC_EOS
02620                                           ! 1100     if (t > prev_ticks)
02621                                           ! Debug: gt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02622 0884           8B46         F4            mov	ax,-$C[bp]
02623 0887           8B5E         F6            mov	bx,-$A[bp]
02624 088A           8D7E         F0            lea	di,-$10[bp]
02625 088D           E8         F80C            call	lcmpul
02626 0890           73           26            jae 	.29
02627                       00000892            .2A:
02628                                           ! 1101     {
02629                                           ! 1102       delta = t - prev_ticks;
02630                                           ! Debug: sub unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02631 0892           8B46         F0            mov	ax,-$10[bp]
02632 0895           8B5E         F2            mov	bx,-$E[bp]
02633 0898           8D7E         F4            lea	di,-$C[bp]
02634 089B           E8         F814            call	lsubul
02635                                           ! Debug: eq unsigned long = bx+0 to long delta = [S+$12-$A] (used reg = )
02636 089E           8946         F8            mov	-8[bp],ax
02637 08A1           895E         FA            mov	-6[bp],bx
02638                                           !BCC_EOS
02639                                           ! 1103       ticks_to_wait -= delta;
02640                                           ! Debug: subab long delta = [S+$12-$A] to long ticks_to_wait = [S+$12-6] (used reg = )
02641 08A4           8B46         FC            mov	ax,-4[bp]
02642 08A7           8B5E         FE            mov	bx,-2[bp]
02643 08AA           8D7E         F8            lea	di,-8[bp]
02644 08AD           E8         F802            call	lsubl
02645 08B0           8946         FC            mov	-4[bp],ax
02646 08B3           895E         FE            mov	-2[bp],bx
02647                                           !BCC_EOS
02648                                           ! 1104     }
02649                                           ! 1105     else if (t < prev_ticks)
02650 08B6           EB           20            jmp .2B
02651                       000008B8            .29:
02652                                           ! Debug: lt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02653 08B8           8B46         F4            mov	ax,-$C[bp]
02654 08BB           8B5E         F6            mov	bx,-$A[bp]
02655 08BE           8D7E         F0            lea	di,-$10[bp]
02656 08C1           E8         F7D8            call	lcmpul
02657 08C4           76           12            jbe 	.2C
02658                       000008C6            .2D:
02659                                           ! 1106     {
02660                                           ! 1107       ticks_to_wait -= t;
02661                                           ! Debug: subab unsigned long t = [S+$12-$12] to long ticks_to_wait = [S+$12-6] (used reg = )
02662 08C6           8B46         FC            mov	ax,-4[bp]
02663 08C9           8B5E         FE            mov	bx,-2[bp]
02664 08CC           8D7E         F0            lea	di,-$10[bp]
02665 08CF           E8         F7E0            call	lsubul
02666 08D2           8946         FC            mov	-4[bp],ax
02667 08D5           895E         FE            mov	-2[bp],bx
02668                                           !BCC_EOS
02669                                           ! 1108     }
02670                                           ! 1109     prev_ticks = t;
02671                       000008D8            .2C:
02672                       000008D8            .2B:
02673                                           ! Debug: eq unsigned long t = [S+$12-$12] to unsigned long prev_ticks = [S+$12-$E] (used reg = )
02674 08D8           8B46         F0            mov	ax,-$10[bp]
02675 08DB           8B5E         F2            mov	bx,-$E[bp]
02676 08DE           8946         F4            mov	-$C[bp],ax
02677 08E1           895E         F6            mov	-$A[bp],bx
02678                                           !BCC_EOS
02679                                           ! 1110   } while (ticks_to_wait > 0);
02680                       000008E4            .27:
02681                                           ! Debug: gt long = const 0 to long ticks_to_wait = [S+$12-6] (used reg = )
02682 08E4           31C0                       xor	ax,ax
02683 08E6           31DB                       xor	bx,bx
02684 08E8           8D7E         FC            lea	di,-4[bp]
02685 08EB           E8         F7AE            call	lcmpl
02686 08EE           7C           86            jl 	.28
02687                       000008F0            .2E:
02688                                           !BCC_EOS
02689                                           ! 1111 #asm
02690                       000008F0            .26:
02691                                           !BCC_EOS
02692                                           !BCC_ASM
02693                       00000014            _delay_ticks.ticks	set	$14
02694                       00000004            .delay_ticks.ticks	set	4
02695                       00000000            _delay_ticks.t	set	0
02696                       FFFFFFF0            .delay_ticks.t	set	-$10
02697                       00000004            _delay_ticks.prev_ticks	set	4
02698                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02699                       00000008            _delay_ticks.delta	set	8
02700                       FFFFFFF8            .delay_ticks.delta	set	-8
02701                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02702                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02703 08F0           FA                           cli
02704 08F1           1F                           pop ds
02705 08F2           9D                           popf
02706                                           ! 1115 endasm
02707                                           !BCC_ENDASM
02708                                           !BCC_EOS
02709                                           ! 1116 }
02710 08F3           89EC                       mov	sp,bp
02711 08F5           5D                         pop	bp
02712 08F6           C3                         ret
02713                                           ! 1117   Bit8u
02714                                           ! Register BX used in function delay_ticks
02715                                           ! 1118 check_for_keystroke()
02716                                           ! 1119 {
02717                                           export	_check_for_keystroke
02718                       000008F7            _check_for_keystroke:
02719                                           ! 1120 #asm
02720                                           !BCC_ASM
02721 08F7           B8                   0100    mov ax, #0x100
02722 08FA           CD                     16    int #0x16
02723 08FC           74           04              jz no_key
02724 08FE           B0                     01    mov al, #1
02725 0900           EB           02              jmp done
02726                       00000902            no_key:
02727 0902           30C0                         xor al, al
02728                       00000904            done:
02729                                           ! 1129 endasm
02730                                           !BCC_ENDASM
02731                                           ! 1130 }
02732 0904           C3                         ret
02733                                           ! 1131   Bit8u
02734                                           ! 1132 get_keystroke()
02735                                           ! 1133 {
02736                                           export	_get_keystroke
02737                       00000905            _get_keystroke:
02738                                           ! 1134 #asm
02739                                           !BCC_ASM
02740 0905           B8                   0000    mov ax, #0x0
02741 0908           CD                     16    int #0x16
02742 090A           86C4                         xchg ah, al
02743                                           ! 1138 endasm
02744                                           !BCC_ENDASM
02745                                           ! 1139 }
02746 090C           C3                         ret
02747                                           ! 1140   void
02748                                           ! 1141 delay_ticks_and_check_for_keystroke(ticks, count)
02749                                           ! 1142   Bit16u ticks, count;
02750                                           export	_delay_ticks_and_check_for_keystroke
02751                       0000090D            _delay_ticks_and_check_for_keystroke:
02752                                           !BCC_EOS
02753                                           ! 1143 {
02754                                           ! 1144   Bit16u i;
02755                                           !BCC_EOS
02756                                           ! 1145   for (i = 1; i <= count; i++) {
02757 090D           55                         push	bp
02758 090E           89E5                       mov	bp,sp
02759 0910           4C                         dec	sp
02760 0911           4C                         dec	sp
02761                                           ! Debug: eq int = const 1 to unsigned short i = [S+4-4] (used reg = )
02762 0912           B8                   0001  mov	ax,*1
02763 0915           8946         FE            mov	-2[bp],ax
02764                                           !BCC_EOS
02765                                           !BCC_EOS
02766 0918           EB           18            jmp .31
02767                       0000091A            .32:
02768                                           ! 1146     delay_ticks(ticks);
02769                                           ! Debug: list unsigned short ticks = [S+4+2] (used reg = )
02770 091A           FF76         04            push	4[bp]
02771                                           ! Debug: func () void = delay_ticks+0 (used reg = )
02772 091D           E8         FF32            call	_delay_ticks
02773 0920           44                         inc	sp
02774 0921           44                         inc	sp
02775                                           !BCC_EOS
02776                                           ! 1147     if (check_for_keystroke())
02777                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
02778 0922           E8         FFD2            call	_check_for_keystroke
02779 0925           84C0                       test	al,al
02780 0927           74           02            je  	.33
02781                       00000929            .34:
02782                                           ! 1148       break;
02783 0929           EB           0F            jmp .2F
02784                                           !BCC_EOS
02785                                           ! 1149   }
02786                       0000092B            .33:
02787                                           ! 1150 }
02788                       0000092B            .30:
02789                                           ! Debug: postinc unsigned short i = [S+4-4] (used reg = )
02790 092B           8B46         FE            mov	ax,-2[bp]
02791 092E           40                         inc	ax
02792 092F           8946         FE            mov	-2[bp],ax
02793                       00000932            .31:
02794                                           ! Debug: le unsigned short count = [S+4+4] to unsigned short i = [S+4-4] (used reg = )
02795 0932           8B46         FE            mov	ax,-2[bp]
02796 0935           3B46         06            cmp	ax,6[bp]
02797 0938           76           E0            jbe	.32
02798                       0000093A            .35:
02799                       0000093A            .2F:
02800 093A           89EC                       mov	sp,bp
02801 093C           5D                         pop	bp
02802 093D           C3                         ret
02803                                           ! 1151   void
02804                                           ! 1152 bios_printf(action, s)
02805                                           ! 1153   Bit16u action;
02806                                           export	_bios_printf
02807                       0000093E            _bios_printf:
02808                                           !BCC_EOS
02809                                           ! 1154   Bit8u *s;
02810                                           !BCC_EOS
02811                                           ! 1155 {
02812                                           ! 1156   Bit8u c, format_char;
02813                                           !BCC_EOS
02814                                           ! 1157   bx_bool in_format;
02815                                           !BCC_EOS
02816                                           ! 1158   short i;
02817                                           !BCC_EOS
02818                                           ! 1159   Bit16u *arg_ptr;
02819                                           !BCC_EOS
02820                                           ! 1160   Bit16u arg, nibble, shift_count, format_width;
02821                                           !BCC_EOS
02822                                           ! 1161   Bit16u old_ds = set_DS(get_CS());
02823 093E           55                         push	bp
02824 093F           89E5                       mov	bp,sp
02825 0941           83C4                   EE  add	sp,*-$12
02826                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
02827 0944           E8         FD15            call	_get_CS
02828                                           ! Debug: list unsigned short = ax+0 (used reg = )
02829 0947           50                         push	ax
02830                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
02831 0948           E8         FD17            call	_set_DS
02832 094B           44                         inc	sp
02833 094C           44                         inc	sp
02834                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+$14-$14] (used reg = )
02835 094D           8946         EE            mov	-$12[bp],ax
02836                                           !BCC_EOS
02837                                           ! 1162   Bit32u lval;
02838                                           !BCC_EOS
02839                                           ! 1163   arg_ptr = &s;
02840 0950           83C4                   FC  add	sp,*-4
02841                                           ! Debug: eq * * unsigned char s = S+$18+4 to * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02842 0953           8D5E         06            lea	bx,6[bp]
02843 0956           895E         F8            mov	-8[bp],bx
02844                                           !BCC_EOS
02845                                           ! 1164   in_format = 0;
02846                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
02847 0959           31C0                       xor	ax,ax
02848 095B           8946         FC            mov	-4[bp],ax
02849                                           !BCC_EOS
02850                                           ! 1165   format_width = 0;
02851                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$12] (used reg = )
02852 095E           31C0                       xor	ax,ax
02853 0960           8946         F0            mov	-$10[bp],ax
02854                                           !BCC_EOS
02855                                           ! 1166   if ((action & (2 | 4 | 1)) == (2 | 4 | 1)) {
02856                                           ! Debug: and int = const 7 to unsigned short action = [S+$18+2] (used reg = )
02857 0963           8A46         04            mov	al,4[bp]
02858 0966           24                     07  and	al,*7
02859                                           ! Debug: logeq int = const 7 to unsigned char = al+0 (used reg = )
02860 0968           3C                     07  cmp	al,*7
02861 096A           75           1B            jne 	.36
02862                       0000096C            .37:
02863                                           ! 1167     outb(0x401, 0x00);
02864                                           ! Debug: list int = const 0 (used reg = )
02865 096C           31C0                       xor	ax,ax
02866 096E           50                         push	ax
02867                                           ! Debug: list int = const $401 (used reg = )
02868 096F           B8                   0401  mov	ax,#$401
02869 0972           50                         push	ax
02870                                           ! Debug: func () void = outb+0 (used reg = )
02871 0973           E8         FB98            call	_outb
02872 0976           83C4                   04  add	sp,*4
02873                                           !BCC_EOS
02874                                           ! 1168     bios_printf (2, "FATAL: ");
02875                                           ! Debug: list * char = .38+0 (used reg = )
02876 0979           BB                   DA06  mov	bx,#.38
02877 097C           53                         push	bx
02878                                           ! Debug: list int = const 2 (used reg = )
02879 097D           B8                   0002  mov	ax,*2
02880 0980           50                         push	ax
02881                                           ! Debug: func () void = bios_printf+0 (used reg = )
02882 0981           E8         FFBA            call	_bios_printf
02883 0984           83C4                   04  add	sp,*4
02884                                           !BCC_EOS
02885                                           ! 1169   }
02886                                           ! 1170   while (c = *((Bit8u *)(s))) {
02887                       00000987            .36:
02888 0987           E9         02B2            br 	.3A
02889                       0000098A            .3B:
02890                                           ! 1171     if ( c == '%' ) {
02891                                           ! Debug: logeq int = const $25 to unsigned char c = [S+$18-3] (used reg = )
02892 098A           8A46         FF            mov	al,-1[bp]
02893 098D           3C                     25  cmp	al,*$25
02894 098F           75           0E            jne 	.3C
02895                       00000991            .3D:
02896                                           ! 1172       in_format = 1;
02897                                           ! Debug: eq int = const 1 to unsigned short in_format = [S+$18-6] (used reg = )
02898 0991           B8                   0001  mov	ax,*1
02899 0994           8946         FC            mov	-4[bp],ax
02900                                           !BCC_EOS
02901                                           ! 1173       format_width = 0;
02902                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$12] (used reg = )
02903 0997           31C0                       xor	ax,ax
02904 0999           8946         F0            mov	-$10[bp],ax
02905                                           !BCC_EOS
02906                                           ! 1174     }
02907                                           ! 1175     else if (in_format) {
02908 099C           E9         0296            br 	.3E
02909                       0000099F            .3C:
02910 099F           8B46         FC            mov	ax,-4[bp]
02911 09A2           85C0                       test	ax,ax
02912 09A4         0F84         027E            beq 	.3F
02913                       000009A8            .40:
02914                                           ! 1176       if ( (c>='0') && (c<='9') ) {
02915                                           ! Debug: ge int = const $30 to unsigned char c = [S+$18-3] (used reg = )
02916 09A8           8A46         FF            mov	al,-1[bp]
02917 09AB           3C                     30  cmp	al,*$30
02918 09AD           72           28            jb  	.41
02919                       000009AF            .43:
02920                                           ! Debug: le int = const $39 to unsigned char c = [S+$18-3] (used reg = )
02921 09AF           8A46         FF            mov	al,-1[bp]
02922 09B2           3C                     39  cmp	al,*$39
02923 09B4           77           21            ja  	.41
02924                       000009B6            .42:
02925                                           ! 1177         format_width = (format_width * 10) + (c - '0');
02926                                           ! Debug: sub int = const $30 to unsigned char c = [S+$18-3] (used reg = )
02927 09B6           8A46         FF            mov	al,-1[bp]
02928 09B9           30E4                       xor	ah,ah
02929 09BB           05                   FFD0  add	ax,*-$30
02930 09BE           50                         push	ax
02931                                           ! Debug: mul int = const $A to unsigned short format_width = [S+$1A-$12] (used reg = )
02932 09BF           8B46         F0            mov	ax,-$10[bp]
02933 09C2           89C2                       mov	dx,ax
02934 09C4           D1E0                       shl	ax,*1
02935 09C6           D1E0                       shl	ax,*1
02936 09C8           01D0                       add	ax,dx
02937 09CA           D1E0                       shl	ax,*1
02938                                           ! Debug: add unsigned int (temp) = [S+$1A-$1A] to unsigned int = ax+0 (used reg = )
02939 09CC           0346         E8            add	ax,-$18[bp]
02940 09CF           44                         inc	sp
02941 09D0           44                         inc	sp
02942                                           ! Debug: eq unsigned int = ax+0 to unsigned short format_width = [S+$18-$12] (used reg = )
02943 09D1           8946         F0            mov	-$10[bp],ax
02944                                           !BCC_EOS
02945                                           ! 1178       }
02946                                           ! 1179       else {
02947 09D4           E9         024D            br 	.44
02948                       000009D7            .41:
02949                                           ! 1180         arg_ptr++;
02950                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02951 09D7           8B5E         F8            mov	bx,-8[bp]
02952 09DA           43                         inc	bx
02953 09DB           43                         inc	bx
02954 09DC           895E         F8            mov	-8[bp],bx
02955                                           !BCC_EOS
02956                                           ! 1181         arg = read_word_SS(arg_ptr);
02957                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02958 09DF           FF76         F8            push	-8[bp]
02959                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
02960 09E2           E8         FC4C            call	_read_word_SS
02961 09E5           44                         inc	sp
02962 09E6           44                         inc	sp
02963                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$C] (used reg = )
02964 09E7           8946         F6            mov	-$A[bp],ax
02965                                           !BCC_EOS
02966                                           ! 1182         if ((c & 0xdf) == 'X') {
02967                                           ! Debug: and int = const $DF to unsigned char c = [S+$18-3] (used reg = )
02968 09EA           8A46         FF            mov	al,-1[bp]
02969 09ED           24                     DF  and	al,#$DF
02970                                           ! Debug: logeq int = const $58 to unsigned char = al+0 (used reg = )
02971 09EF           3C                     58  cmp	al,*$58
02972 09F1           75           64            jne 	.45
02973                       000009F3            .46:
02974                                           ! 1183           if (format_width == 0)
02975                                           ! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$12] (used reg = )
02976 09F3           8B46         F0            mov	ax,-$10[bp]
02977 09F6           85C0                       test	ax,ax
02978 09F8           75           06            jne 	.47
02979                       000009FA            .48:
02980                                           ! 1184             format_width = 4;
02981                                           ! Debug: eq int = const 4 to unsigned short format_width = [S+$18-$12] (used reg = )
02982 09FA           B8                   0004  mov	ax,*4
02983 09FD           8946         F0            mov	-$10[bp],ax
02984                                           !BCC_EOS
02985                                           ! 1185           for (i=format_width-1; i>=0; i--) {
02986                       00000A00            .47:
02987                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$12] (used reg = )
02988 0A00           8B46         F0            mov	ax,-$10[bp]
02989                                           ! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
02990 0A03           48                         dec	ax
02991 0A04           8946         FA            mov	-6[bp],ax
02992                                           !BCC_EOS
02993                                           !BCC_EOS
02994 0A07           EB           44            jmp .4B
02995                       00000A09            .4C:
02996                                           ! 1186             nibble = (arg >> (4 * i)) & 0x000f;
02997                                           ! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
02998                                           ! Debug: expression subtree swapping
02999 0A09           8B46         FA            mov	ax,-6[bp]
03000 0A0C           D1E0                       shl	ax,*1
03001 0A0E           D1E0                       shl	ax,*1
03002                                           ! Debug: sr int = ax+0 to unsigned short arg = [S+$18-$C] (used reg = )
03003 0A10           89C3                       mov	bx,ax
03004 0A12           8B46         F6            mov	ax,-$A[bp]
03005 0A15           89D9                       mov	cx,bx
03006 0A17           D3E8                       shr	ax,cl
03007                                           ! Debug: and int = const $F to unsigned int = ax+0 (used reg = )
03008 0A19           24                     0F  and	al,*$F
03009                                           ! Debug: eq unsigned char = al+0 to unsigned short nibble = [S+$18-$E] (used reg = )
03010 0A1B           30E4                       xor	ah,ah
03011 0A1D           8946         F4            mov	-$C[bp],ax
03012                                           !BCC_EOS
03013                                           ! 1187             send (action, (nibble<=9)? (nibble+'0') : (nibble+c-33));
03014                                           ! Debug: le int = const 9 to unsigned short nibble = [S+$18-$E] (used reg = )
03015 0A20           8B46         F4            mov	ax,-$C[bp]
03016 0A23           3D                   0009  cmp	ax,*9
03017 0A26           77           08            ja  	.4D
03018                       00000A28            .4E:
03019                                           ! Debug: add int = const $30 to unsigned short nibble = [S+$18-$E] (used reg = )
03020 0A28           8B46         F4            mov	ax,-$C[bp]
03021 0A2B           05                   0030  add	ax,*$30
03022 0A2E           EB           0C            jmp .4F
03023                       00000A30            .4D:
03024                                           ! Debug: add unsigned char c = [S+$18-3] to unsigned short nibble = [S+$18-$E] (used reg = )
03025 0A30           8B46         F4            mov	ax,-$C[bp]
03026 0A33           0246         FF            add	al,-1[bp]
03027 0A36           80D4                   00  adc	ah,*0
03028                                           ! Debug: sub int = const $21 to unsigned int = ax+0 (used reg = )
03029 0A39           05                   FFDF  add	ax,*-$21
03030                       00000A3C            .4F:
03031                                           ! Debug: list unsigned int = ax+0 (used reg = )
03032 0A3C           50                         push	ax
03033                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03034 0A3D           FF76         04            push	4[bp]
03035                                           ! Debug: func () void = send+0 (used reg = )
03036 0A40           E8         FC48            call	_send
03037 0A43           83C4                   04  add	sp,*4
03038                                           !BCC_EOS
03039                                           ! 1188           }
03040                                           ! 1189         }
03041                       00000A46            .4A:
03042                                           ! Debug: postdec short i = [S+$18-8] (used reg = )
03043 0A46           8B46         FA            mov	ax,-6[bp]
03044 0A49           48                         dec	ax
03045 0A4A           8946         FA            mov	-6[bp],ax
03046                       00000A4D            .4B:
03047                                           ! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
03048 0A4D           8B46         FA            mov	ax,-6[bp]
03049 0A50           85C0                       test	ax,ax
03050 0A52           7D           B5            jge	.4C
03051                       00000A54            .50:
03052                       00000A54            .49:
03053                                           ! 1190         else if (c == 'u') {
03054 0A54           E9         01C8            br 	.51
03055                       00000A57            .45:
03056                                           ! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
03057 0A57           8A46         FF            mov	al,-1[bp]
03058 0A5A           3C                     75  cmp	al,*$75
03059 0A5C           75           15            jne 	.52
03060                       00000A5E            .53:
03061                                           ! 1191           put_uint(action, arg, format_width, 0);
03062                                           ! Debug: list int = const 0 (used reg = )
03063 0A5E           31C0                       xor	ax,ax
03064 0A60           50                         push	ax
03065                                           ! Debug: list unsigned short format_width = [S+$1A-$12] (used reg = )
03066 0A61           FF76         F0            push	-$10[bp]
03067                                           ! Debug: list unsigned short arg = [S+$1C-$C] (used reg = )
03068 0A64           FF76         F6            push	-$A[bp]
03069                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03070 0A67           FF76         04            push	4[bp]
03071                                           ! Debug: func () void = put_uint+0 (used reg = )
03072 0A6A           E8         FC77            call	_put_uint
03073 0A6D           83C4                   08  add	sp,*8
03074                                           !BCC_EOS
03075                                           ! 1192         }
03076                                           ! 1193         else if (c == 'l') {
03077 0A70           E9         01AC            br 	.54
03078                       00000A73            .52:
03079                                           ! Debug: logeq int = const $6C to unsigned char c = [S+$18-3] (used reg = )
03080 0A73           8A46         FF            mov	al,-1[bp]
03081 0A76           3C                     6C  cmp	al,*$6C
03082 0A78         0F85         0102            bne 	.55
03083                       00000A7C            .56:
03084                                           ! 1194           s++;
03085                                           ! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
03086 0A7C           8B5E         06            mov	bx,6[bp]
03087 0A7F           43                         inc	bx
03088 0A80           895E         06            mov	6[bp],bx
03089                                           !BCC_EOS
03090                                           ! 1195           c = *((Bit8u *)(s));
03091 0A83           8B5E         06            mov	bx,6[bp]
03092                                           ! Debug: eq unsigned char = [bx+0] to unsigned char c = [S+$18-3] (used reg = )
03093 0A86           8A07                       mov	al,[bx]
03094 0A88           8846         FF            mov	-1[bp],al
03095                                           !BCC_EOS
03096                                           ! 1196           arg_ptr++;
03097                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03098 0A8B           8B5E         F8            mov	bx,-8[bp]
03099 0A8E           43                         inc	bx
03100 0A8F           43                         inc	bx
03101 0A90           895E         F8            mov	-8[bp],bx
03102                                           !BCC_EOS
03103                                           ! 1197           *(((Bit16u *)&lval)+1) = read_word_SS(arg_ptr);
03104                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03105 0A93           FF76         F8            push	-8[bp]
03106                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
03107 0A96           E8         FB98            call	_read_word_SS
03108 0A99           44                         inc	sp
03109 0A9A           44                         inc	sp
03110                                           ! Debug: eq unsigned short = ax+0 to unsigned short lval = [S+$18-$16] (used reg = )
03111 0A9B           8946         EC            mov	-$14[bp],ax
03112                                           !BCC_EOS
03113                                           ! 1198     
03114                                           ! 1198       *((Bit16u *)&lval) = arg;
03115                                           ! Debug: eq unsigned short arg = [S+$18-$C] to unsigned short lval = [S+$18-$18] (used reg = )
03116 0A9E           8B46         F6            mov	ax,-$A[bp]
03117 0AA1           8946         EA            mov	-$16[bp],ax
03118                                           !BCC_EOS
03119                                           ! 1199           if (c == 'd') {
03120                                           ! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
03121 0AA4           8A46         FF            mov	al,-1[bp]
03122 0AA7           3C                     64  cmp	al,*$64
03123 0AA9           75           42            jne 	.57
03124                       00000AAB            .58:
03125                                           ! 1200             if (*(((Bit16u *)&lval)+1) & 0x8000)
03126                                           ! Debug: and unsigned int = const $8000 to unsigned short lval = [S+$18-$16] (used reg = )
03127 0AAB           8B46         EC            mov	ax,-$14[bp]
03128 0AAE           25                   8000  and	ax,#$8000
03129 0AB1           85C0                       test	ax,ax
03130 0AB3           74           20            je  	.59
03131                       00000AB5            .5A:
03132                                           ! 1201               put_luint(action, 0L-lval, format_width-1, 1);
03133                                           ! Debug: list int = const 1 (used reg = )
03134 0AB5           B8                   0001  mov	ax,*1
03135 0AB8           50                         push	ax
03136                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$12] (used reg = )
03137 0AB9           8B46         F0            mov	ax,-$10[bp]
03138                                           ! Debug: list unsigned int = ax-1 (used reg = )
03139 0ABC           48                         dec	ax
03140 0ABD           50                         push	ax
03141                                           ! Debug: sub unsigned long lval = [S+$1C-$18] to long = const 0 (used reg = )
03142 0ABE           31C0                       xor	ax,ax
03143 0AC0           31DB                       xor	bx,bx
03144 0AC2           8D7E         EA            lea	di,-$16[bp]
03145 0AC5           E8         F5EA            call	lsubul
03146                                           ! Debug: list unsigned long = bx+0 (used reg = )
03147 0AC8           53                         push	bx
03148 0AC9           50                         push	ax
03149                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03150 0ACA           FF76         04            push	4[bp]
03151                                           ! Debug: func () void = put_luint+0 (used reg = )
03152 0ACD           E8         FC97            call	_put_luint
03153 0AD0           83C4                   0A  add	sp,*$A
03154                                           !BCC_EOS
03155                                           ! 1202             else
03156                                           ! 1203               put_luint(action, lval, format_width, 0);
03157 0AD3           EB           15            jmp .5B
03158                       00000AD5            .59:
03159                                           ! Debug: list int = const 0 (used reg = )
03160 0AD5           31C0                       xor	ax,ax
03161 0AD7           50                         push	ax
03162                                           ! Debug: list unsigned short format_width = [S+$1A-$12] (used reg = )
03163 0AD8           FF76         F0            push	-$10[bp]
03164                                           ! Debug: list unsigned long lval = [S+$1C-$18] (used reg = )
03165 0ADB           FF76         EC            push	-$14[bp]
03166 0ADE           FF76         EA            push	-$16[bp]
03167                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03168 0AE1           FF76         04            push	4[bp]
03169                                           ! Debug: func () void = put_luint+0 (used reg = )
03170 0AE4           E8         FC80            call	_put_luint
03171 0AE7           83C4                   0A  add	sp,*$A
03172                                           !BCC_EOS
03173                                           ! 1204           }
03174                       00000AEA            .5B:
03175                                           ! 1205           else if (c == 'u') {
03176 0AEA           E9         008E            br 	.5C
03177                       00000AED            .57:
03178                                           ! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
03179 0AED           8A46         FF            mov	al,-1[bp]
03180 0AF0           3C                     75  cmp	al,*$75
03181 0AF2           75           17            jne 	.5D
03182                       00000AF4            .5E:
03183                                           ! 1206             put_luint(action, lval, format_width, 0);
03184                                           ! Debug: list int = const 0 (used reg = )
03185 0AF4           31C0                       xor	ax,ax
03186 0AF6           50                         push	ax
03187                                           ! Debug: list unsigned short format_width = [S+$1A-$12] (used reg = )
03188 0AF7           FF76         F0            push	-$10[bp]
03189                                           ! Debug: list unsigned long lval = [S+$1C-$18] (used reg = )
03190 0AFA           FF76         EC            push	-$14[bp]
03191 0AFD           FF76         EA            push	-$16[bp]
03192                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03193 0B00           FF76         04            push	4[bp]
03194                                           ! Debug: func () void = put_luint+0 (used reg = )
03195 0B03           E8         FC61            call	_put_luint
03196 0B06           83C4                   0A  add	sp,*$A
03197                                           !BCC_EOS
03198                                           ! 1207           }
03199                                           ! 1208           else if ((c & 0xdf) == 'X')
03200 0B09           EB           70            jmp .5F
03201                       00000B0B            .5D:
03202                                           ! Debug: and int = const $DF to unsigned char c = [S+$18-3] (used reg = )
03203 0B0B           8A46         FF            mov	al,-1[bp]
03204 0B0E           24                     DF  and	al,#$DF
03205                                           ! Debug: logeq int = const $58 to unsigned char = al+0 (used reg = )
03206 0B10           3C                     58  cmp	al,*$58
03207 0B12           75           67            jne 	.60
03208                       00000B14            .61:
03209                                           ! 1209           {
03210                                           ! 1210             if (format_width == 0)
03211                                           ! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$12] (used reg = )
03212 0B14           8B46         F0            mov	ax,-$10[bp]
03213 0B17           85C0                       test	ax,ax
03214 0B19           75           06            jne 	.62
03215                       00000B1B            .63:
03216                                           ! 1211               format_width = 8;
03217                                           ! Debug: eq int = const 8 to unsigned short format_width = [S+$18-$12] (used reg = )
03218 0B1B           B8                   0008  mov	ax,*8
03219 0B1E           8946         F0            mov	-$10[bp],ax
03220                                           !BCC_EOS
03221                                           ! 1212             for (i=format_width-1; i>=0; i--) {
03222                       00000B21            .62:
03223                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$12] (used reg = )
03224 0B21           8B46         F0            mov	ax,-$10[bp]
03225                                           ! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
03226 0B24           48                         dec	ax
03227 0B25           8946         FA            mov	-6[bp],ax
03228                                           !BCC_EOS
03229                                           !BCC_EOS
03230 0B28           EB           4A            jmp .66
03231                       00000B2A            .67:
03232                                           ! 1213               nibble = ((Bit16u)(lval >> (4 * i))) & 0x000f;
03233                                           ! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
03234                                           ! Debug: expression subtree swapping
03235 0B2A           8B46         FA            mov	ax,-6[bp]
03236 0B2D           D1E0                       shl	ax,*1
03237 0B2F           D1E0                       shl	ax,*1
03238                                           ! Debug: sr int = ax+0 to unsigned long lval = [S+$18-$18] (used reg = )
03239 0B31           50                         push	ax
03240 0B32           8B46         EA            mov	ax,-$16[bp]
03241 0B35           8B5E         EC            mov	bx,-$14[bp]
03242 0B38           8B7E         E8            mov	di,-$18[bp]
03243 0B3B           E8         F5BC            call	lsrul
03244 0B3E           44                         inc	sp
03245 0B3F           44                         inc	sp
03246                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
03247                                           ! Debug: and int = const $F to unsigned short = ax+0 (used reg = )
03248 0B40           24                     0F  and	al,*$F
03249                                           ! Debug: eq unsigned char = al+0 to unsigned short nibble = [S+$18-$E] (used reg = )
03250 0B42           30E4                       xor	ah,ah
03251 0B44           8946         F4            mov	-$C[bp],ax
03252                                           !BCC_EOS
03253                                           ! 1214               send (action, (nibble<=9)? (nibble+'0') : (nibble+c-33));
03254                                           ! Debug: le int = const 9 to unsigned short nibble = [S+$18-$E] (used reg = )
03255 0B47           8B46         F4            mov	ax,-$C[bp]
03256 0B4A           3D                   0009  cmp	ax,*9
03257 0B4D           77           08            ja  	.68
03258                       00000B4F            .69:
03259                                           ! Debug: add int = const $30 to unsigned short nibble = [S+$18-$E] (used reg = )
03260 0B4F           8B46         F4            mov	ax,-$C[bp]
03261 0B52           05                   0030  add	ax,*$30
03262 0B55           EB           0C            jmp .6A
03263                       00000B57            .68:
03264                                           ! Debug: add unsigned char c = [S+$18-3] to unsigned short nibble = [S+$18-$E] (used reg = )
03265 0B57           8B46         F4            mov	ax,-$C[bp]
03266 0B5A           0246         FF            add	al,-1[bp]
03267 0B5D           80D4                   00  adc	ah,*0
03268                                           ! Debug: sub int = const $21 to unsigned int = ax+0 (used reg = )
03269 0B60           05                   FFDF  add	ax,*-$21
03270                       00000B63            .6A:
03271                                           ! Debug: list unsigned int = ax+0 (used reg = )
03272 0B63           50                         push	ax
03273                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03274 0B64           FF76         04            push	4[bp]
03275                                           ! Debug: func () void = send+0 (used reg = )
03276 0B67           E8         FB21            call	_send
03277 0B6A           83C4                   04  add	sp,*4
03278                                           !BCC_EOS
03279                                           ! 1215             }
03280                                           ! 1216           }
03281                       00000B6D            .65:
03282                                           ! Debug: postdec short i = [S+$18-8] (used reg = )
03283 0B6D           8B46         FA            mov	ax,-6[bp]
03284 0B70           48                         dec	ax
03285 0B71           8946         FA            mov	-6[bp],ax
03286                       00000B74            .66:
03287                                           ! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
03288 0B74           8B46         FA            mov	ax,-6[bp]
03289 0B77           85C0                       test	ax,ax
03290 0B79           7D           AF            jge	.67
03291                       00000B7B            .6B:
03292                       00000B7B            .64:
03293                                           ! 1217         }
03294                       00000B7B            .60:
03295                       00000B7B            .5F:
03296                       00000B7B            .5C:
03297                                           ! 1218         else if (c == 'd') {
03298 0B7B           E9         00A1            br 	.6C
03299                       00000B7E            .55:
03300                                           ! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
03301 0B7E           8A46         FF            mov	al,-1[bp]
03302 0B81           3C                     64  cmp	al,*$64
03303 0B83           75           38            jne 	.6D
03304                       00000B85            .6E:
03305                                           ! 1219           if (arg & 0x8000)
03306                                           ! Debug: and unsigned int = const $8000 to unsigned short arg = [S+$18-$C] (used reg = )
03307 0B85           8B46         F6            mov	ax,-$A[bp]
03308 0B88           25                   8000  and	ax,#$8000
03309 0B8B           85C0                       test	ax,ax
03310 0B8D           74           1A            je  	.6F
03311                       00000B8F            .70:
03312                                           ! 1220             put_uint(action, -arg, format_width - 1, 1);
03313                                           ! Debug: list int = const 1 (used reg = )
03314 0B8F           B8                   0001  mov	ax,*1
03315 0B92           50                         push	ax
03316                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$12] (used reg = )
03317 0B93           8B46         F0            mov	ax,-$10[bp]
03318                                           ! Debug: list unsigned int = ax-1 (used reg = )
03319 0B96           48                         dec	ax
03320 0B97           50                         push	ax
03321                                           ! Debug: neg unsigned short arg = [S+$1C-$C] (used reg = )
03322 0B98           31C0                       xor	ax,ax
03323 0B9A           2B46         F6            sub	ax,-$A[bp]
03324                                           ! Debug: list unsigned int = ax+0 (used reg = )
03325 0B9D           50                         push	ax
03326                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03327 0B9E           FF76         04            push	4[bp]
03328                                           ! Debug: func () void = put_uint+0 (used reg = )
03329 0BA1           E8         FB40            call	_put_uint
03330 0BA4           83C4                   08  add	sp,*8
03331                                           !BCC_EOS
03332                                           ! 1221           else
03333                                           ! 1222             put_uint(action, arg, format_width, 0);
03334 0BA7           EB           12            jmp .71
03335                       00000BA9            .6F:
03336                                           ! Debug: list int = const 0 (used reg = )
03337 0BA9           31C0                       xor	ax,ax
03338 0BAB           50                         push	ax
03339                                           ! Debug: list unsigned short format_width = [S+$1A-$12] (used reg = )
03340 0BAC           FF76         F0            push	-$10[bp]
03341                                           ! Debug: list unsigned short arg = [S+$1C-$C] (used reg = )
03342 0BAF           FF76         F6            push	-$A[bp]
03343                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03344 0BB2           FF76         04            push	4[bp]
03345                                           ! Debug: func () void = put_uint+0 (used reg = )
03346 0BB5           E8         FB2C            call	_put_uint
03347 0BB8           83C4                   08  add	sp,*8
03348                                           !BCC_EOS
03349                                           ! 1223         }
03350                       00000BBB            .71:
03351                                           ! 1224         else if (c == 's') {
03352 0BBB           EB           62            jmp .72
03353                       00000BBD            .6D:
03354                                           ! Debug: logeq int = const $73 to unsigned char c = [S+$18-3] (used reg = )
03355 0BBD           8A46         FF            mov	al,-1[bp]
03356 0BC0           3C                     73  cmp	al,*$73
03357 0BC2           75           12            jne 	.73
03358                       00000BC4            .74:
03359                                           ! 1225           put_str(action, get_CS(), arg);
03360                                           ! Debug: list unsigned short arg = [S+$18-$C] (used reg = )
03361 0BC4           FF76         F6            push	-$A[bp]
03362                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03363 0BC7           E8         FA92            call	_get_CS
03364                                           ! Debug: list unsigned short = ax+0 (used reg = )
03365 0BCA           50                         push	ax
03366                                           ! Debug: list unsigned short action = [S+$1C+2] (used reg = )
03367 0BCB           FF76         04            push	4[bp]
03368                                           ! Debug: func () void = put_str+0 (used reg = )
03369 0BCE           E8         FC4D            call	_put_str
03370 0BD1           83C4                   06  add	sp,*6
03371                                           !BCC_EOS
03372                                           ! 1226         }
03373                                           ! 1227         else if (c == 'S') {
03374 0BD4           EB           49            jmp .75
03375                       00000BD6            .73:
03376                                           ! Debug: logeq int = const $53 to unsigned char c = [S+$18-3] (used reg = )
03377 0BD6           8A46         FF            mov	al,-1[bp]
03378 0BD9           3C                     53  cmp	al,*$53
03379 0BDB           75           1F            jne 	.76
03380                       00000BDD            .77:
03381                                           ! 1228           arg_ptr++;
03382                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03383 0BDD           8B5E         F8            mov	bx,-8[bp]
03384 0BE0           43                         inc	bx
03385 0BE1           43                         inc	bx
03386 0BE2           895E         F8            mov	-8[bp],bx
03387                                           !BCC_EOS
03388                                           ! 1229           put_str(action, arg, read_word_SS(arg_ptr));
03389                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03390 0BE5           FF76         F8            push	-8[bp]
03391                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
03392 0BE8           E8         FA46            call	_read_word_SS
03393 0BEB           44                         inc	sp
03394 0BEC           44                         inc	sp
03395                                           ! Debug: list unsigned short = ax+0 (used reg = )
03396 0BED           50                         push	ax
03397                                           ! Debug: list unsigned short arg = [S+$1A-$C] (used reg = )
03398 0BEE           FF76         F6            push	-$A[bp]
03399                                           ! Debug: list unsigned short action = [S+$1C+2] (used reg = )
03400 0BF1           FF76         04            push	4[bp]
03401                                           ! Debug: func () void = put_str+0 (used reg = )
03402 0BF4           E8         FC27            call	_put_str
03403 0BF7           83C4                   06  add	sp,*6
03404                                           !BCC_EOS
03405                                           ! 1230         }
03406                                           ! 1231         else if (c == 'c') {
03407 0BFA           EB           23            jmp .78
03408                       00000BFC            .76:
03409                                           ! Debug: logeq int = const $63 to unsigned char c = [S+$18-3] (used reg = )
03410 0BFC           8A46         FF            mov	al,-1[bp]
03411 0BFF           3C                     63  cmp	al,*$63
03412 0C01           75           0E            jne 	.79
03413                       00000C03            .7A:
03414                                           ! 1232           send(action, arg);
03415                                           ! Debug: list unsigned short arg = [S+$18-$C] (used reg = )
03416 0C03           FF76         F6            push	-$A[bp]
03417                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03418 0C06           FF76         04            push	4[bp]
03419                                           ! Debug: func () void = send+0 (used reg = )
03420 0C09           E8         FA7F            call	_send
03421 0C0C           83C4                   04  add	sp,*4
03422                                           !BCC_EOS
03423                                           ! 1233         }
03424                                           ! 1234         else
03425                                           ! 1235           bios_printf((2 | 4 | 1), "bios_printf: unknown format\n");
03426 0C0F           EB           0E            jmp .7B
03427                       00000C11            .79:
03428                                           ! Debug: list * char = .7C+0 (used reg = )
03429 0C11           BB                   D9E9  mov	bx,#.7C
03430 0C14           53                         push	bx
03431                                           ! Debug: list int = const 7 (used reg = )
03432 0C15           B8                   0007  mov	ax,*7
03433 0C18           50                         push	ax
03434                                           ! Debug: func () void = bios_printf+0 (used reg = )
03435 0C19           E8         FD22            call	_bios_printf
03436 0C1C           83C4                   04  add	sp,*4
03437                                           !BCC_EOS
03438                                           ! 1236           in_format = 0;
03439                       00000C1F            .7B:
03440                       00000C1F            .78:
03441                       00000C1F            .75:
03442                       00000C1F            .72:
03443                       00000C1F            .6C:
03444                       00000C1F            .54:
03445                       00000C1F            .51:
03446                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
03447 0C1F           31C0                       xor	ax,ax
03448 0C21           8946         FC            mov	-4[bp],ax
03449                                           !BCC_EOS
03450                                           ! 1237       }
03451                                           ! 1238     }
03452                       00000C24            .44:
03453                                           ! 1239     else {
03454 0C24           EB           0F            jmp .7D
03455                       00000C26            .3F:
03456                                           ! 1240       send(action, c);
03457                                           ! Debug: list unsigned char c = [S+$18-3] (used reg = )
03458 0C26           8A46         FF            mov	al,-1[bp]
03459 0C29           30E4                       xor	ah,ah
03460 0C2B           50                         push	ax
03461                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03462 0C2C           FF76         04            push	4[bp]
03463                                           ! Debug: func () void = send+0 (used reg = )
03464 0C2F           E8         FA59            call	_send
03465 0C32           83C4                   04  add	sp,*4
03466                                           !BCC_EOS
03467                                           ! 1241     }
03468                                           ! 1242     s ++;
03469                       00000C35            .7D:
03470                       00000C35            .3E:
03471                                           ! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
03472 0C35           8B5E         06            mov	bx,6[bp]
03473 0C38           43                         inc	bx
03474 0C39           895E         06            mov	6[bp],bx
03475                                           !BCC_EOS
03476                                           ! 1243   }
03477                                           ! 1244   if (action & 1) {
03478                       00000C3C            .3A:
03479 0C3C           8B5E         06            mov	bx,6[bp]
03480                                           ! Debug: eq unsigned char = [bx+0] to unsigned char c = [S+$18-3] (used reg = )
03481 0C3F           8A07                       mov	al,[bx]
03482 0C41           8846         FF            mov	-1[bp],al
03483 0C44           84C0                       test	al,al
03484 0C46         0F85         FD40            bne 	.3B
03485                       00000C4A            .7E:
03486                       00000C4A            .39:
03487                                           ! Debug: and int = const 1 to unsigned short action = [S+$18+2] (used reg = )
03488 0C4A           8A46         04            mov	al,4[bp]
03489 0C4D           24                     01  and	al,*1
03490 0C4F           84C0                       test	al,al
03491 0C51           74           04            je  	.7F
03492                       00000C53            .80:
03493                                           ! 1245 #asm
03494                                           !BCC_EOS
03495                                           !BCC_ASM
03496                       00000006            _bios_printf.format_width	set	6
03497                       FFFFFFF0            .bios_printf.format_width	set	-$10
03498                       00000014            _bios_printf.format_char	set	$14
03499                       FFFFFFFE            .bios_printf.format_char	set	-2
03500                       0000000E            _bios_printf.arg_ptr	set	$E
03501                       FFFFFFF8            .bios_printf.arg_ptr	set	-8
03502                       0000001A            _bios_printf.action	set	$1A
03503                       00000004            .bios_printf.action	set	4
03504                       00000010            _bios_printf.i	set	$10
03505                       FFFFFFFA            .bios_printf.i	set	-6
03506                       00000008            _bios_printf.shift_count	set	8
03507                       FFFFFFF2            .bios_printf.shift_count	set	-$E
03508                       00000012            _bios_printf.in_format	set	$12
03509                       FFFFFFFC            .bios_printf.in_format	set	-4
03510                       0000001C            _bios_printf.s	set	$1C
03511                       00000006            .bios_printf.s	set	6
03512                       00000000            _bios_printf.lval	set	0
03513                       FFFFFFEA            .bios_printf.lval	set	-$16
03514                       0000000A            _bios_printf.nibble	set	$A
03515                       FFFFFFF4            .bios_printf.nibble	set	-$C
03516                       00000015            _bios_printf.c	set	$15
03517                       FFFFFFFF            .bios_printf.c	set	-1
03518                       0000000C            _bios_printf.arg	set	$C
03519                       FFFFFFF6            .bios_printf.arg	set	-$A
03520                       00000004            _bios_printf.old_ds	set	4
03521                       FFFFFFEE            .bios_printf.old_ds	set	-$12
03522 0C53           FA                             cli
03523                       00000C54             halt2_loop:
03524 0C54           F4                             hlt
03525 0C55           EB           FD                jmp halt2_loop
03526                                           ! 1250 endasm
03527                                           !BCC_ENDASM
03528                                           !BCC_EOS
03529                                           ! 1251   }
03530                                           ! 1252   set_DS(old_ds);
03531                       00000C57            .7F:
03532                                           ! Debug: list unsigned short old_ds = [S+$18-$14] (used reg = )
03533 0C57           FF76         EE            push	-$12[bp]
03534                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
03535 0C5A           E8         FA05            call	_set_DS
03536 0C5D           44                         inc	sp
03537 0C5E           44                         inc	sp
03538                                           !BCC_EOS
03539                                           ! 1253 }
03540 0C5F           89EC                       mov	sp,bp
03541 0C61           5D                         pop	bp
03542 0C62           C3                         ret
03543                                           ! 1254   void
03544                                           ! Register BX used in function bios_printf
03545                                           ! 1255 keyboard_init()
03546                                           ! 1256 {
03547                                           export	_keyboard_init
03548                       00000C63            _keyboard_init:
03549                                           ! 1257     Bit16u max;
03550                                           !BCC_EOS
03551                                           ! 1258     max=0xffff;
03552 0C63           55                         push	bp
03553 0C64           89E5                       mov	bp,sp
03554 0C66           4C                         dec	sp
03555 0C67           4C                         dec	sp
03556                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03557 0C68           B8                   FFFF  mov	ax,#$FFFF
03558 0C6B           8946         FE            mov	-2[bp],ax
03559                                           !BCC_EOS
03560                                           ! 1259     while ( (inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x00);
03561 0C6E           EB           0D            jmp .82
03562                       00000C70            .83:
03563                                           ! Debug: list int = const 0 (used reg = )
03564 0C70           31C0                       xor	ax,ax
03565 0C72           50                         push	ax
03566                                           ! Debug: list int = const $80 (used reg = )
03567 0C73           B8                   0080  mov	ax,#$80
03568 0C76           50                         push	ax
03569                                           ! Debug: func () void = outb+0 (used reg = )
03570 0C77           E8         F894            call	_outb
03571 0C7A           83C4                   04  add	sp,*4
03572                                           !BCC_EOS
03573                                           ! 1260     max=0x2000;
03574                       00000C7D            .82:
03575                                           ! Debug: list int = const $64 (used reg = )
03576 0C7D           B8                   0064  mov	ax,*$64
03577 0C80           50                         push	ax
03578                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03579 0C81           E8         F874            call	_inb
03580 0C84           44                         inc	sp
03581 0C85           44                         inc	sp
03582                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03583 0C86           24                     02  and	al,*2
03584 0C88           84C0                       test	al,al
03585 0C8A           74           0B            je  	.84
03586                       00000C8C            .85:
03587                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03588 0C8C           8B46         FE            mov	ax,-2[bp]
03589 0C8F           48                         dec	ax
03590 0C90           8946         FE            mov	-2[bp],ax
03591                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03592 0C93           85C0                       test	ax,ax
03593 0C95           75           D9            jne	.83
03594                       00000C97            .84:
03595                       00000C97            .81:
03596                                           ! Debug: eq int = const $2000 to unsigned short max = [S+4-4] (used reg = )
03597 0C97           B8                   2000  mov	ax,#$2000
03598 0C9A           8946         FE            mov	-2[bp],ax
03599                                           !BCC_EOS
03600                                           ! 1261     while (--max > 0) {
03601 0C9D           EB           2B            jmp .87
03602                       00000C9F            .88:
03603                                           ! 1262         outb(0x0080, 0x00);
03604                                           ! Debug: list int = const 0 (used reg = )
03605 0C9F           31C0                       xor	ax,ax
03606 0CA1           50                         push	ax
03607                                           ! Debug: list int = const $80 (used reg = )
03608 0CA2           B8                   0080  mov	ax,#$80
03609 0CA5           50                         push	ax
03610                                           ! Debug: func () void = outb+0 (used reg = )
03611 0CA6           E8         F865            call	_outb
03612 0CA9           83C4                   04  add	sp,*4
03613                                           !BCC_EOS
03614                                           ! 1263         if (inb(0x0064) & 0x01) {
03615                                           ! Debug: list int = const $64 (used reg = )
03616 0CAC           B8                   0064  mov	ax,*$64
03617 0CAF           50                         push	ax
03618                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03619 0CB0           E8         F845            call	_inb
03620 0CB3           44                         inc	sp
03621 0CB4           44                         inc	sp
03622                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03623 0CB5           24                     01  and	al,*1
03624 0CB7           84C0                       test	al,al
03625 0CB9           74           0F            je  	.89
03626                       00000CBB            .8A:
03627                                           ! 1264             inb(0x0060);
03628                                           ! Debug: list int = const $60 (used reg = )
03629 0CBB           B8                   0060  mov	ax,*$60
03630 0CBE           50                         push	ax
03631                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03632 0CBF           E8         F836            call	_inb
03633 0CC2           44                         inc	sp
03634 0CC3           44                         inc	sp
03635                                           !BCC_EOS
03636                                           ! 1265             max = 0x2000;
03637                                           ! Debug: eq int = const $2000 to unsigned short max = [S+4-4] (used reg = )
03638 0CC4           B8                   2000  mov	ax,#$2000
03639 0CC7           8946         FE            mov	-2[bp],ax
03640                                           !BCC_EOS
03641                                           ! 1266         }
03642                                           ! 1267     }
03643                       00000CCA            .89:
03644                                           ! 1268     outb(0x0064, 0xaa);
03645                       00000CCA            .87:
03646                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03647 0CCA           8B46         FE            mov	ax,-2[bp]
03648 0CCD           48                         dec	ax
03649 0CCE           8946         FE            mov	-2[bp],ax
03650                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03651 0CD1           85C0                       test	ax,ax
03652 0CD3           75           CA            jne	.88
03653                       00000CD5            .8B:
03654                       00000CD5            .86:
03655                                           ! Debug: list int = const $AA (used reg = )
03656 0CD5           B8                   00AA  mov	ax,#$AA
03657 0CD8           50                         push	ax
03658                                           ! Debug: list int = const $64 (used reg = )
03659 0CD9           B8                   0064  mov	ax,*$64
03660 0CDC           50                         push	ax
03661                                           ! Debug: func () void = outb+0 (used reg = )
03662 0CDD           E8         F82E            call	_outb
03663 0CE0           83C4                   04  add	sp,*4
03664                                           !BCC_EOS
03665                                           ! 1269     max=0xffff;
03666                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03667 0CE3           B8                   FFFF  mov	ax,#$FFFF
03668 0CE6           8946         FE            mov	-2[bp],ax
03669                                           !BCC_EOS
03670                                           ! 1270     while ( (inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x00);
03671 0CE9           EB           0D            jmp .8D
03672                       00000CEB            .8E:
03673                                           ! Debug: list int = const 0 (used reg = )
03674 0CEB           31C0                       xor	ax,ax
03675 0CED           50                         push	ax
03676                                           ! Debug: list int = const $80 (used reg = )
03677 0CEE           B8                   0080  mov	ax,#$80
03678 0CF1           50                         push	ax
03679                                           ! Debug: func () void = outb+0 (used reg = )
03680 0CF2           E8         F819            call	_outb
03681 0CF5           83C4                   04  add	sp,*4
03682                                           !BCC_EOS
03683                                           ! 1271     if (max==0x0) keyboard_panic(00);
03684                       00000CF8            .8D:
03685                                           ! Debug: list int = const $64 (used reg = )
03686 0CF8           B8                   0064  mov	ax,*$64
03687 0CFB           50                         push	ax
03688                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03689 0CFC           E8         F7F9            call	_inb
03690 0CFF           44                         inc	sp
03691 0D00           44                         inc	sp
03692                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03693 0D01           24                     02  and	al,*2
03694 0D03           84C0                       test	al,al
03695 0D05           74           0B            je  	.8F
03696                       00000D07            .90:
03697                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03698 0D07           8B46         FE            mov	ax,-2[bp]
03699 0D0A           48                         dec	ax
03700 0D0B           8946         FE            mov	-2[bp],ax
03701                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03702 0D0E           85C0                       test	ax,ax
03703 0D10           75           D9            jne	.8E
03704                       00000D12            .8F:
03705                       00000D12            .8C:
03706                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03707 0D12           8B46         FE            mov	ax,-2[bp]
03708 0D15           85C0                       test	ax,ax
03709 0D17           75           08            jne 	.91
03710                       00000D19            .92:
03711                                           ! Debug: list int = const 0 (used reg = )
03712 0D19           31C0                       xor	ax,ax
03713 0D1B           50                         push	ax
03714                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03715 0D1C           E8         0488            call	_keyboard_panic
03716 0D1F           44                         inc	sp
03717 0D20           44                         inc	sp
03718                                           !BCC_EOS
03719                                           ! 1272     max=0xffff;
03720                       00000D21            .91:
03721                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03722 0D21           B8                   FFFF  mov	ax,#$FFFF
03723 0D24           8946         FE            mov	-2[bp],ax
03724                                           !BCC_EOS
03725                                           ! 1273     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x01);
03726 0D27           EB           0E            jmp .94
03727                       00000D29            .95:
03728                                           ! Debug: list int = const 1 (used reg = )
03729 0D29           B8                   0001  mov	ax,*1
03730 0D2C           50                         push	ax
03731                                           ! Debug: list int = const $80 (used reg = )
03732 0D2D           B8                   0080  mov	ax,#$80
03733 0D30           50                         push	ax
03734                                           ! Debug: func () void = outb+0 (used reg = )
03735 0D31           E8         F7DA            call	_outb
03736 0D34           83C4                   04  add	sp,*4
03737                                           !BCC_EOS
03738                                           ! 1274     if (max==0x0) keyboard_panic(01);
03739                       00000D37            .94:
03740                                           ! Debug: list int = const $64 (used reg = )
03741 0D37           B8                   0064  mov	ax,*$64
03742 0D3A           50                         push	ax
03743                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03744 0D3B           E8         F7BA            call	_inb
03745 0D3E           44                         inc	sp
03746 0D3F           44                         inc	sp
03747                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03748 0D40           24                     01  and	al,*1
03749                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03750 0D42           84C0                       test	al,al
03751 0D44           75           0B            jne 	.96
03752                       00000D46            .97:
03753                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03754 0D46           8B46         FE            mov	ax,-2[bp]
03755 0D49           48                         dec	ax
03756 0D4A           8946         FE            mov	-2[bp],ax
03757                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03758 0D4D           85C0                       test	ax,ax
03759 0D4F           75           D8            jne	.95
03760                       00000D51            .96:
03761                       00000D51            .93:
03762                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03763 0D51           8B46         FE            mov	ax,-2[bp]
03764 0D54           85C0                       test	ax,ax
03765 0D56           75           09            jne 	.98
03766                       00000D58            .99:
03767                                           ! Debug: list int = const 1 (used reg = )
03768 0D58           B8                   0001  mov	ax,*1
03769 0D5B           50                         push	ax
03770                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03771 0D5C           E8         0448            call	_keyboard_panic
03772 0D5F           44                         inc	sp
03773 0D60           44                         inc	sp
03774                                           !BCC_EOS
03775                                           ! 1275     if ((inb(0x0060) != 0x55)){
03776                       00000D61            .98:
03777                                           ! Debug: list int = const $60 (used reg = )
03778 0D61           B8                   0060  mov	ax,*$60
03779 0D64           50                         push	ax
03780                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03781 0D65           E8         F790            call	_inb
03782 0D68           44                         inc	sp
03783 0D69           44                         inc	sp
03784                                           ! Debug: ne int = const $55 to unsigned char = al+0 (used reg = )
03785 0D6A           3C                     55  cmp	al,*$55
03786 0D6C           74           09            je  	.9A
03787                       00000D6E            .9B:
03788                                           ! 1276         keyboard_panic(991);
03789                                           ! Debug: list int = const $3DF (used reg = )
03790 0D6E           B8                   03DF  mov	ax,#$3DF
03791 0D71           50                         push	ax
03792                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03793 0D72           E8         0432            call	_keyboard_panic
03794 0D75           44                         inc	sp
03795 0D76           44                         inc	sp
03796                                           !BCC_EOS
03797                                           ! 1277  
03798                                           ! 1277    }
03799                                           ! 1278     outb(0x0064,0xab);
03800                       00000D77            .9A:
03801                                           ! Debug: list int = const $AB (used reg = )
03802 0D77           B8                   00AB  mov	ax,#$AB
03803 0D7A           50                         push	ax
03804                                           ! Debug: list int = const $64 (used reg = )
03805 0D7B           B8                   0064  mov	ax,*$64
03806 0D7E           50                         push	ax
03807                                           ! Debug: func () void = outb+0 (used reg = )
03808 0D7F           E8         F78C            call	_outb
03809 0D82           83C4                   04  add	sp,*4
03810                                           !BCC_EOS
03811                                           ! 1279     max=0xffff;
03812                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03813 0D85           B8                   FFFF  mov	ax,#$FFFF
03814 0D88           8946         FE            mov	-2[bp],ax
03815                                           !BCC_EOS
03816                                           ! 1280     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x10);
03817 0D8B           EB           0E            jmp .9D
03818                       00000D8D            .9E:
03819                                           ! Debug: list int = const $10 (used reg = )
03820 0D8D           B8                   0010  mov	ax,*$10
03821 0D90           50                         push	ax
03822                                           ! Debug: list int = const $80 (used reg = )
03823 0D91           B8                   0080  mov	ax,#$80
03824 0D94           50                         push	ax
03825                                           ! Debug: func () void = outb+0 (used reg = )
03826 0D95           E8         F776            call	_outb
03827 0D98           83C4                   04  add	sp,*4
03828                                           !BCC_EOS
03829                                           ! 1281     if (max==0x0) keyboard_panic(10);
03830                       00000D9B            .9D:
03831                                           ! Debug: list int = const $64 (used reg = )
03832 0D9B           B8                   0064  mov	ax,*$64
03833 0D9E           50                         push	ax
03834                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03835 0D9F           E8         F756            call	_inb
03836 0DA2           44                         inc	sp
03837 0DA3           44                         inc	sp
03838                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03839 0DA4           24                     02  and	al,*2
03840 0DA6           84C0                       test	al,al
03841 0DA8           74           0B            je  	.9F
03842                       00000DAA            .A0:
03843                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03844 0DAA           8B46         FE            mov	ax,-2[bp]
03845 0DAD           48                         dec	ax
03846 0DAE           8946         FE            mov	-2[bp],ax
03847                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03848 0DB1           85C0                       test	ax,ax
03849 0DB3           75           D8            jne	.9E
03850                       00000DB5            .9F:
03851                       00000DB5            .9C:
03852                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03853 0DB5           8B46         FE            mov	ax,-2[bp]
03854 0DB8           85C0                       test	ax,ax
03855 0DBA           75           09            jne 	.A1
03856                       00000DBC            .A2:
03857                                           ! Debug: list int = const $A (used reg = )
03858 0DBC           B8                   000A  mov	ax,*$A
03859 0DBF           50                         push	ax
03860                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03861 0DC0           E8         03E4            call	_keyboard_panic
03862 0DC3           44                         inc	sp
03863 0DC4           44                         inc	sp
03864                                           !BCC_EOS
03865                                           ! 1282     max=0xffff;
03866                       00000DC5            .A1:
03867                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03868 0DC5           B8                   FFFF  mov	ax,#$FFFF
03869 0DC8           8946         FE            mov	-2[bp],ax
03870                                           !BCC_EOS
03871                                           ! 1283     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x11);
03872 0DCB           EB           0E            jmp .A4
03873                       00000DCD            .A5:
03874                                           ! Debug: list int = const $11 (used reg = )
03875 0DCD           B8                   0011  mov	ax,*$11
03876 0DD0           50                         push	ax
03877                                           ! Debug: list int = const $80 (used reg = )
03878 0DD1           B8                   0080  mov	ax,#$80
03879 0DD4           50                         push	ax
03880                                           ! Debug: func () void = outb+0 (used reg = )
03881 0DD5           E8         F736            call	_outb
03882 0DD8           83C4                   04  add	sp,*4
03883                                           !BCC_EOS
03884                                           ! 1284     if (max==0x0) keyboard_panic(11);
03885                       00000DDB            .A4:
03886                                           ! Debug: list int = const $64 (used reg = )
03887 0DDB           B8                   0064  mov	ax,*$64
03888 0DDE           50                         push	ax
03889                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03890 0DDF           E8         F716            call	_inb
03891 0DE2           44                         inc	sp
03892 0DE3           44                         inc	sp
03893                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03894 0DE4           24                     01  and	al,*1
03895                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03896 0DE6           84C0                       test	al,al
03897 0DE8           75           0B            jne 	.A6
03898                       00000DEA            .A7:
03899                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03900 0DEA           8B46         FE            mov	ax,-2[bp]
03901 0DED           48                         dec	ax
03902 0DEE           8946         FE            mov	-2[bp],ax
03903                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03904 0DF1           85C0                       test	ax,ax
03905 0DF3           75           D8            jne	.A5
03906                       00000DF5            .A6:
03907                       00000DF5            .A3:
03908                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03909 0DF5           8B46         FE            mov	ax,-2[bp]
03910 0DF8           85C0                       test	ax,ax
03911 0DFA           75           09            jne 	.A8
03912                       00000DFC            .A9:
03913                                           ! Debug: list int = const $B (used reg = )
03914 0DFC           B8                   000B  mov	ax,*$B
03915 0DFF           50                         push	ax
03916                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03917 0E00           E8         03A4            call	_keyboard_panic
03918 0E03           44                         inc	sp
03919 0E04           44                         inc	sp
03920                                           !BCC_EOS
03921                                           ! 1285     if ((inb(0x0060) != 0x00)) {
03922                       00000E05            .A8:
03923                                           ! Debug: list int = const $60 (used reg = )
03924 0E05           B8                   0060  mov	ax,*$60
03925 0E08           50                         push	ax
03926                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03927 0E09           E8         F6EC            call	_inb
03928 0E0C           44                         inc	sp
03929 0E0D           44                         inc	sp
03930                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
03931 0E0E           84C0                       test	al,al
03932 0E10           74           09            je  	.AA
03933                       00000E12            .AB:
03934                                           ! 1286         keyboard_panic(992);
03935                                           ! Debug: list int = const $3E0 (used reg = )
03936 0E12           B8                   03E0  mov	ax,#$3E0
03937 0E15           50                         push	ax
03938                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03939 0E16           E8         038E            call	_keyboard_panic
03940 0E19           44                         inc	sp
03941 0E1A           44                         inc	sp
03942                                           !BCC_EOS
03943                                           ! 1287     }
03944                                           ! 1288     outb(0x0064,0xae);
03945                       00000E1B            .AA:
03946                                           ! Debug: list int = const $AE (used reg = )
03947 0E1B           B8                   00AE  mov	ax,#$AE
03948 0E1E           50                         push	ax
03949                                           ! Debug: list int = const $64 (used reg = )
03950 0E1F           B8                   0064  mov	ax,*$64
03951 0E22           50                         push	ax
03952                                           ! Debug: func () void = outb+0 (used reg = )
03953 0E23           E8         F6E8            call	_outb
03954 0E26           83C4                   04  add	sp,*4
03955                                           !BCC_EOS
03956                                           ! 1289     max=0xffff;
03957                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03958 0E29           B8                   FFFF  mov	ax,#$FFFF
03959 0E2C           8946         FE            mov	-2[bp],ax
03960                                           !BCC_EOS
03961                                           ! 1290     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x10);
03962 0E2F           EB           0E            jmp .AD
03963                       00000E31            .AE:
03964                                           ! Debug: list int = const $10 (used reg = )
03965 0E31           B8                   0010  mov	ax,*$10
03966 0E34           50                         push	ax
03967                                           ! Debug: list int = const $80 (used reg = )
03968 0E35           B8                   0080  mov	ax,#$80
03969 0E38           50                         push	ax
03970                                           ! Debug: func () void = outb+0 (used reg = )
03971 0E39           E8         F6D2            call	_outb
03972 0E3C           83C4                   04  add	sp,*4
03973                                           !BCC_EOS
03974                                           ! 1291     if (max==0x0) keyboard_panic(10);
03975                       00000E3F            .AD:
03976                                           ! Debug: list int = const $64 (used reg = )
03977 0E3F           B8                   0064  mov	ax,*$64
03978 0E42           50                         push	ax
03979                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03980 0E43           E8         F6B2            call	_inb
03981 0E46           44                         inc	sp
03982 0E47           44                         inc	sp
03983                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03984 0E48           24                     02  and	al,*2
03985 0E4A           84C0                       test	al,al
03986 0E4C           74           0B            je  	.AF
03987                       00000E4E            .B0:
03988                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03989 0E4E           8B46         FE            mov	ax,-2[bp]
03990 0E51           48                         dec	ax
03991 0E52           8946         FE            mov	-2[bp],ax
03992                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03993 0E55           85C0                       test	ax,ax
03994 0E57           75           D8            jne	.AE
03995                       00000E59            .AF:
03996                       00000E59            .AC:
03997                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03998 0E59           8B46         FE            mov	ax,-2[bp]
03999 0E5C           85C0                       test	ax,ax
04000 0E5E           75           09            jne 	.B1
04001                       00000E60            .B2:
04002                                           ! Debug: list int = const $A (used reg = )
04003 0E60           B8                   000A  mov	ax,*$A
04004 0E63           50                         push	ax
04005                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04006 0E64           E8         0340            call	_keyboard_panic
04007 0E67           44                         inc	sp
04008 0E68           44                         inc	sp
04009                                           !BCC_EOS
04010                                           ! 1292     outb(0x0064,0xa8);
04011                       00000E69            .B1:
04012                                           ! Debug: list int = const $A8 (used reg = )
04013 0E69           B8                   00A8  mov	ax,#$A8
04014 0E6C           50                         push	ax
04015                                           ! Debug: list int = const $64 (used reg = )
04016 0E6D           B8                   0064  mov	ax,*$64
04017 0E70           50                         push	ax
04018                                           ! Debug: func () void = outb+0 (used reg = )
04019 0E71           E8         F69A            call	_outb
04020 0E74           83C4                   04  add	sp,*4
04021                                           !BCC_EOS
04022                                           ! 1293     max=0xffff;
04023                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04024 0E77           B8                   FFFF  mov	ax,#$FFFF
04025 0E7A           8946         FE            mov	-2[bp],ax
04026                                           !BCC_EOS
04027                                           ! 1294     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x10);
04028 0E7D           EB           0E            jmp .B4
04029                       00000E7F            .B5:
04030                                           ! Debug: list int = const $10 (used reg = )
04031 0E7F           B8                   0010  mov	ax,*$10
04032 0E82           50                         push	ax
04033                                           ! Debug: list int = const $80 (used reg = )
04034 0E83           B8                   0080  mov	ax,#$80
04035 0E86           50                         push	ax
04036                                           ! Debug: func () void = outb+0 (used reg = )
04037 0E87           E8         F684            call	_outb
04038 0E8A           83C4                   04  add	sp,*4
04039                                           !BCC_EOS
04040                                           ! 1295     if (max==0x0) keyboard_panic(10);
04041                       00000E8D            .B4:
04042                                           ! Debug: list int = const $64 (used reg = )
04043 0E8D           B8                   0064  mov	ax,*$64
04044 0E90           50                         push	ax
04045                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04046 0E91           E8         F664            call	_inb
04047 0E94           44                         inc	sp
04048 0E95           44                         inc	sp
04049                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04050 0E96           24                     02  and	al,*2
04051 0E98           84C0                       test	al,al
04052 0E9A           74           0B            je  	.B6
04053                       00000E9C            .B7:
04054                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04055 0E9C           8B46         FE            mov	ax,-2[bp]
04056 0E9F           48                         dec	ax
04057 0EA0           8946         FE            mov	-2[bp],ax
04058                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04059 0EA3           85C0                       test	ax,ax
04060 0EA5           75           D8            jne	.B5
04061                       00000EA7            .B6:
04062                       00000EA7            .B3:
04063                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04064 0EA7           8B46         FE            mov	ax,-2[bp]
04065 0EAA           85C0                       test	ax,ax
04066 0EAC           75           09            jne 	.B8
04067                       00000EAE            .B9:
04068                                           ! Debug: list int = const $A (used reg = )
04069 0EAE           B8                   000A  mov	ax,*$A
04070 0EB1           50                         push	ax
04071                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04072 0EB2           E8         02F2            call	_keyboard_panic
04073 0EB5           44                         inc	sp
04074 0EB6           44                         inc	sp
04075                                           !BCC_EOS
04076                                           ! 1296     outb(0x0060, 0xff);
04077                       00000EB7            .B8:
04078                                           ! Debug: list int = const $FF (used reg = )
04079 0EB7           B8                   00FF  mov	ax,#$FF
04080 0EBA           50                         push	ax
04081                                           ! Debug: list int = const $60 (used reg = )
04082 0EBB           B8                   0060  mov	ax,*$60
04083 0EBE           50                         push	ax
04084                                           ! Debug: func () void = outb+0 (used reg = )
04085 0EBF           E8         F64C            call	_outb
04086 0EC2           83C4                   04  add	sp,*4
04087                                           !BCC_EOS
04088                                           ! 1297     max=0xffff;
04089                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04090 0EC5           B8                   FFFF  mov	ax,#$FFFF
04091 0EC8           8946         FE            mov	-2[bp],ax
04092                                           !BCC_EOS
04093                                           ! 1298     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x20);
04094 0ECB           EB           0E            jmp .BB
04095                       00000ECD            .BC:
04096                                           ! Debug: list int = const $20 (used reg = )
04097 0ECD           B8                   0020  mov	ax,*$20
04098 0ED0           50                         push	ax
04099                                           ! Debug: list int = const $80 (used reg = )
04100 0ED1           B8                   0080  mov	ax,#$80
04101 0ED4           50                         push	ax
04102                                           ! Debug: func () void = outb+0 (used reg = )
04103 0ED5           E8         F636            call	_outb
04104 0ED8           83C4                   04  add	sp,*4
04105                                           !BCC_EOS
04106                                           ! 1299     if (max==0x0) keyboard_panic(20);
04107                       00000EDB            .BB:
04108                                           ! Debug: list int = const $64 (used reg = )
04109 0EDB           B8                   0064  mov	ax,*$64
04110 0EDE           50                         push	ax
04111                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04112 0EDF           E8         F616            call	_inb
04113 0EE2           44                         inc	sp
04114 0EE3           44                         inc	sp
04115                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04116 0EE4           24                     02  and	al,*2
04117 0EE6           84C0                       test	al,al
04118 0EE8           74           0B            je  	.BD
04119                       00000EEA            .BE:
04120                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04121 0EEA           8B46         FE            mov	ax,-2[bp]
04122 0EED           48                         dec	ax
04123 0EEE           8946         FE            mov	-2[bp],ax
04124                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04125 0EF1           85C0                       test	ax,ax
04126 0EF3           75           D8            jne	.BC
04127                       00000EF5            .BD:
04128                       00000EF5            .BA:
04129                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04130 0EF5           8B46         FE            mov	ax,-2[bp]
04131 0EF8           85C0                       test	ax,ax
04132 0EFA           75           09            jne 	.BF
04133                       00000EFC            .C0:
04134                                           ! Debug: list int = const $14 (used reg = )
04135 0EFC           B8                   0014  mov	ax,*$14
04136 0EFF           50                         push	ax
04137                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04138 0F00           E8         02A4            call	_keyboard_panic
04139 0F03           44                         inc	sp
04140 0F04           44                         inc	sp
04141                                           !BCC_EOS
04142                                           ! 1300     max=0xffff;
04143                       00000F05            .BF:
04144                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04145 0F05           B8                   FFFF  mov	ax,#$FFFF
04146 0F08           8946         FE            mov	-2[bp],ax
04147                                           !BCC_EOS
04148                                           ! 1301     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x21);
04149 0F0B           EB           0E            jmp .C2
04150                       00000F0D            .C3:
04151                                           ! Debug: list int = const $21 (used reg = )
04152 0F0D           B8                   0021  mov	ax,*$21
04153 0F10           50                         push	ax
04154                                           ! Debug: list int = const $80 (used reg = )
04155 0F11           B8                   0080  mov	ax,#$80
04156 0F14           50                         push	ax
04157                                           ! Debug: func () void = outb+0 (used reg = )
04158 0F15           E8         F5F6            call	_outb
04159 0F18           83C4                   04  add	sp,*4
04160                                           !BCC_EOS
04161                                           ! 1302     if (max==0x0) keyboard_panic(21);
04162                       00000F1B            .C2:
04163                                           ! Debug: list int = const $64 (used reg = )
04164 0F1B           B8                   0064  mov	ax,*$64
04165 0F1E           50                         push	ax
04166                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04167 0F1F           E8         F5D6            call	_inb
04168 0F22           44                         inc	sp
04169 0F23           44                         inc	sp
04170                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04171 0F24           24                     01  and	al,*1
04172                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04173 0F26           84C0                       test	al,al
04174 0F28           75           0B            jne 	.C4
04175                       00000F2A            .C5:
04176                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04177 0F2A           8B46         FE            mov	ax,-2[bp]
04178 0F2D           48                         dec	ax
04179 0F2E           8946         FE            mov	-2[bp],ax
04180                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04181 0F31           85C0                       test	ax,ax
04182 0F33           75           D8            jne	.C3
04183                       00000F35            .C4:
04184                       00000F35            .C1:
04185                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04186 0F35           8B46         FE            mov	ax,-2[bp]
04187 0F38           85C0                       test	ax,ax
04188 0F3A           75           09            jne 	.C6
04189                       00000F3C            .C7:
04190                                           ! Debug: list int = const $15 (used reg = )
04191 0F3C           B8                   0015  mov	ax,*$15
04192 0F3F           50                         push	ax
04193                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04194 0F40           E8         0264            call	_keyboard_panic
04195 0F43           44                         inc	sp
04196 0F44           44                         inc	sp
04197                                           !BCC_EOS
04198                                           ! 1303     if ((inb(0x0060) != 0xfa)) {
04199                       00000F45            .C6:
04200                                           ! Debug: list int = const $60 (used reg = )
04201 0F45           B8                   0060  mov	ax,*$60
04202 0F48           50                         push	ax
04203                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04204 0F49           E8         F5AC            call	_inb
04205 0F4C           44                         inc	sp
04206 0F4D           44                         inc	sp
04207                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04208 0F4E           3C                     FA  cmp	al,#$FA
04209 0F50           74           09            je  	.C8
04210                       00000F52            .C9:
04211                                           ! 1304         keyboard_panic(993);
04212                                           ! Debug: list int = const $3E1 (used reg = )
04213 0F52           B8                   03E1  mov	ax,#$3E1
04214 0F55           50                         push	ax
04215                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04216 0F56           E8         024E            call	_keyboard_panic
04217 0F59           44                         inc	sp
04218 0F5A           44                         inc	sp
04219                                           !BCC_EOS
04220                                           ! 1305     }
04221                                           ! 1306     max=0xffff;
04222                       00000F5B            .C8:
04223                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04224 0F5B           B8                   FFFF  mov	ax,#$FFFF
04225 0F5E           8946         FE            mov	-2[bp],ax
04226                                           !BCC_EOS
04227                                           ! 1307     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x31);
04228 0F61           EB           0E            jmp .CB
04229                       00000F63            .CC:
04230                                           ! Debug: list int = const $31 (used reg = )
04231 0F63           B8                   0031  mov	ax,*$31
04232 0F66           50                         push	ax
04233                                           ! Debug: list int = const $80 (used reg = )
04234 0F67           B8                   0080  mov	ax,#$80
04235 0F6A           50                         push	ax
04236                                           ! Debug: func () void = outb+0 (used reg = )
04237 0F6B           E8         F5A0            call	_outb
04238 0F6E           83C4                   04  add	sp,*4
04239                                           !BCC_EOS
04240                                           ! 1308     if (max==0x0) keyboard_panic(31);
04241                       00000F71            .CB:
04242                                           ! Debug: list int = const $64 (used reg = )
04243 0F71           B8                   0064  mov	ax,*$64
04244 0F74           50                         push	ax
04245                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04246 0F75           E8         F580            call	_inb
04247 0F78           44                         inc	sp
04248 0F79           44                         inc	sp
04249                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04250 0F7A           24                     01  and	al,*1
04251                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04252 0F7C           84C0                       test	al,al
04253 0F7E           75           0B            jne 	.CD
04254                       00000F80            .CE:
04255                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04256 0F80           8B46         FE            mov	ax,-2[bp]
04257 0F83           48                         dec	ax
04258 0F84           8946         FE            mov	-2[bp],ax
04259                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04260 0F87           85C0                       test	ax,ax
04261 0F89           75           D8            jne	.CC
04262                       00000F8B            .CD:
04263                       00000F8B            .CA:
04264                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04265 0F8B           8B46         FE            mov	ax,-2[bp]
04266 0F8E           85C0                       test	ax,ax
04267 0F90           75           09            jne 	.CF
04268                       00000F92            .D0:
04269                                           ! Debug: list int = const $1F (used reg = )
04270 0F92           B8                   001F  mov	ax,*$1F
04271 0F95           50                         push	ax
04272                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04273 0F96           E8         020E            call	_keyboard_panic
04274 0F99           44                         inc	sp
04275 0F9A           44                         inc	sp
04276                                           !BCC_EOS
04277                                           ! 1309     if ((inb(0x0060) != 0xaa)) {
04278                       00000F9B            .CF:
04279                                           ! Debug: list int = const $60 (used reg = )
04280 0F9B           B8                   0060  mov	ax,*$60
04281 0F9E           50                         push	ax
04282                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04283 0F9F           E8         F556            call	_inb
04284 0FA2           44                         inc	sp
04285 0FA3           44                         inc	sp
04286                                           ! Debug: ne int = const $AA to unsigned char = al+0 (used reg = )
04287 0FA4           3C                     AA  cmp	al,#$AA
04288 0FA6           74           09            je  	.D1
04289                       00000FA8            .D2:
04290                                           ! 1310         keyboard_panic(994);
04291                                           ! Debug: list int = const $3E2 (used reg = )
04292 0FA8           B8                   03E2  mov	ax,#$3E2
04293 0FAB           50                         push	ax
04294                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04295 0FAC           E8         01F8            call	_keyboard_panic
04296 0FAF           44                         inc	sp
04297 0FB0           44                         inc	sp
04298                                           !BCC_EOS
04299                                           ! 1311     }
04300                                           ! 1312     outb(0x0060, 0xf5);
04301                       00000FB1            .D1:
04302                                           ! Debug: list int = const $F5 (used reg = )
04303 0FB1           B8                   00F5  mov	ax,#$F5
04304 0FB4           50                         push	ax
04305                                           ! Debug: list int = const $60 (used reg = )
04306 0FB5           B8                   0060  mov	ax,*$60
04307 0FB8           50                         push	ax
04308                                           ! Debug: func () void = outb+0 (used reg = )
04309 0FB9           E8         F552            call	_outb
04310 0FBC           83C4                   04  add	sp,*4
04311                                           !BCC_EOS
04312                                           ! 1313     max=0xffff;
04313                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04314 0FBF           B8                   FFFF  mov	ax,#$FFFF
04315 0FC2           8946         FE            mov	-2[bp],ax
04316                                           !BCC_EOS
04317                                           ! 1314     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x40);
04318 0FC5           EB           0E            jmp .D4
04319                       00000FC7            .D5:
04320                                           ! Debug: list int = const $40 (used reg = )
04321 0FC7           B8                   0040  mov	ax,*$40
04322 0FCA           50                         push	ax
04323                                           ! Debug: list int = const $80 (used reg = )
04324 0FCB           B8                   0080  mov	ax,#$80
04325 0FCE           50                         push	ax
04326                                           ! Debug: func () void = outb+0 (used reg = )
04327 0FCF           E8         F53C            call	_outb
04328 0FD2           83C4                   04  add	sp,*4
04329                                           !BCC_EOS
04330                                           ! 1315     if (max==0x0) keyboard_panic(40);
04331                       00000FD5            .D4:
04332                                           ! Debug: list int = const $64 (used reg = )
04333 0FD5           B8                   0064  mov	ax,*$64
04334 0FD8           50                         push	ax
04335                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04336 0FD9           E8         F51C            call	_inb
04337 0FDC           44                         inc	sp
04338 0FDD           44                         inc	sp
04339                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04340 0FDE           24                     02  and	al,*2
04341 0FE0           84C0                       test	al,al
04342 0FE2           74           0B            je  	.D6
04343                       00000FE4            .D7:
04344                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04345 0FE4           8B46         FE            mov	ax,-2[bp]
04346 0FE7           48                         dec	ax
04347 0FE8           8946         FE            mov	-2[bp],ax
04348                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04349 0FEB           85C0                       test	ax,ax
04350 0FED           75           D8            jne	.D5
04351                       00000FEF            .D6:
04352                       00000FEF            .D3:
04353                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04354 0FEF           8B46         FE            mov	ax,-2[bp]
04355 0FF2           85C0                       test	ax,ax
04356 0FF4           75           09            jne 	.D8
04357                       00000FF6            .D9:
04358                                           ! Debug: list int = const $28 (used reg = )
04359 0FF6           B8                   0028  mov	ax,*$28
04360 0FF9           50                         push	ax
04361                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04362 0FFA           E8         01AA            call	_keyboard_panic
04363 0FFD           44                         inc	sp
04364 0FFE           44                         inc	sp
04365                                           !BCC_EOS
04366                                           ! 1316     max=0xffff;
04367                       00000FFF            .D8:
04368                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04369 0FFF           B8                   FFFF  mov	ax,#$FFFF
04370 1002           8946         FE            mov	-2[bp],ax
04371                                           !BCC_EOS
04372                                           ! 1317     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x41);
04373 1005           EB           0E            jmp .DB
04374                       00001007            .DC:
04375                                           ! Debug: list int = const $41 (used reg = )
04376 1007           B8                   0041  mov	ax,*$41
04377 100A           50                         push	ax
04378                                           ! Debug: list int = const $80 (used reg = )
04379 100B           B8                   0080  mov	ax,#$80
04380 100E           50                         push	ax
04381                                           ! Debug: func () void = outb+0 (used reg = )
04382 100F           E8         F4FC            call	_outb
04383 1012           83C4                   04  add	sp,*4
04384                                           !BCC_EOS
04385                                           ! 1318     if (max==0x0) keyboard_panic(41);
04386                       00001015            .DB:
04387                                           ! Debug: list int = const $64 (used reg = )
04388 1015           B8                   0064  mov	ax,*$64
04389 1018           50                         push	ax
04390                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04391 1019           E8         F4DC            call	_inb
04392 101C           44                         inc	sp
04393 101D           44                         inc	sp
04394                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04395 101E           24                     01  and	al,*1
04396                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04397 1020           84C0                       test	al,al
04398 1022           75           0B            jne 	.DD
04399                       00001024            .DE:
04400                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04401 1024           8B46         FE            mov	ax,-2[bp]
04402 1027           48                         dec	ax
04403 1028           8946         FE            mov	-2[bp],ax
04404                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04405 102B           85C0                       test	ax,ax
04406 102D           75           D8            jne	.DC
04407                       0000102F            .DD:
04408                       0000102F            .DA:
04409                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04410 102F           8B46         FE            mov	ax,-2[bp]
04411 1032           85C0                       test	ax,ax
04412 1034           75           09            jne 	.DF
04413                       00001036            .E0:
04414                                           ! Debug: list int = const $29 (used reg = )
04415 1036           B8                   0029  mov	ax,*$29
04416 1039           50                         push	ax
04417                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04418 103A           E8         016A            call	_keyboard_panic
04419 103D           44                         inc	sp
04420 103E           44                         inc	sp
04421                                           !BCC_EOS
04422                                           ! 1319     if ((inb(0x0060) != 0xfa)) {
04423                       0000103F            .DF:
04424                                           ! Debug: list int = const $60 (used reg = )
04425 103F           B8                   0060  mov	ax,*$60
04426 1042           50                         push	ax
04427                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04428 1043           E8         F4B2            call	_inb
04429 1046           44                         inc	sp
04430 1047           44                         inc	sp
04431                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04432 1048           3C                     FA  cmp	al,#$FA
04433 104A           74           09            je  	.E1
04434                       0000104C            .E2:
04435                                           ! 1320         keyboard_panic(995);
04436                                           ! Debug: list int = const $3E3 (used reg = )
04437 104C           B8                   03E3  mov	ax,#$3E3
04438 104F           50                         push	ax
04439                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04440 1050           E8         0154            call	_keyboard_panic
04441 1053           44                         inc	sp
04442 1054           44                         inc	sp
04443                                           !BCC_EOS
04444                                           ! 1321     }
04445                                           ! 1322     outb(0x0064, 0x60);
04446                       00001055            .E1:
04447                                           ! Debug: list int = const $60 (used reg = )
04448 1055           B8                   0060  mov	ax,*$60
04449 1058           50                         push	ax
04450                                           ! Debug: list int = const $64 (used reg = )
04451 1059           B8                   0064  mov	ax,*$64
04452 105C           50                         push	ax
04453                                           ! Debug: func () void = outb+0 (used reg = )
04454 105D           E8         F4AE            call	_outb
04455 1060           83C4                   04  add	sp,*4
04456                                           !BCC_EOS
04457                                           ! 1323     max=0xffff;
04458                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04459 1063           B8                   FFFF  mov	ax,#$FFFF
04460 1066           8946         FE            mov	-2[bp],ax
04461                                           !BCC_EOS
04462                                           ! 1324     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x50);
04463 1069           EB           0E            jmp .E4
04464                       0000106B            .E5:
04465                                           ! Debug: list int = const $50 (used reg = )
04466 106B           B8                   0050  mov	ax,*$50
04467 106E           50                         push	ax
04468                                           ! Debug: list int = const $80 (used reg = )
04469 106F           B8                   0080  mov	ax,#$80
04470 1072           50                         push	ax
04471                                           ! Debug: func () void = outb+0 (used reg = )
04472 1073           E8         F498            call	_outb
04473 1076           83C4                   04  add	sp,*4
04474                                           !BCC_EOS
04475                                           ! 1325     if (max==0x0) keyboard_panic(50);
04476                       00001079            .E4:
04477                                           ! Debug: list int = const $64 (used reg = )
04478 1079           B8                   0064  mov	ax,*$64
04479 107C           50                         push	ax
04480                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04481 107D           E8         F478            call	_inb
04482 1080           44                         inc	sp
04483 1081           44                         inc	sp
04484                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04485 1082           24                     02  and	al,*2
04486 1084           84C0                       test	al,al
04487 1086           74           0B            je  	.E6
04488                       00001088            .E7:
04489                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04490 1088           8B46         FE            mov	ax,-2[bp]
04491 108B           48                         dec	ax
04492 108C           8946         FE            mov	-2[bp],ax
04493                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04494 108F           85C0                       test	ax,ax
04495 1091           75           D8            jne	.E5
04496                       00001093            .E6:
04497                       00001093            .E3:
04498                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04499 1093           8B46         FE            mov	ax,-2[bp]
04500 1096           85C0                       test	ax,ax
04501 1098           75           09            jne 	.E8
04502                       0000109A            .E9:
04503                                           ! Debug: list int = const $32 (used reg = )
04504 109A           B8                   0032  mov	ax,*$32
04505 109D           50                         push	ax
04506                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04507 109E           E8         0106            call	_keyboard_panic
04508 10A1           44                         inc	sp
04509 10A2           44                         inc	sp
04510                                           !BCC_EOS
04511                                           ! 1326     outb(0x0060, 0x61);
04512                       000010A3            .E8:
04513                                           ! Debug: list int = const $61 (used reg = )
04514 10A3           B8                   0061  mov	ax,*$61
04515 10A6           50                         push	ax
04516                                           ! Debug: list int = const $60 (used reg = )
04517 10A7           B8                   0060  mov	ax,*$60
04518 10AA           50                         push	ax
04519                                           ! Debug: func () void = outb+0 (used reg = )
04520 10AB           E8         F460            call	_outb
04521 10AE           83C4                   04  add	sp,*4
04522                                           !BCC_EOS
04523                                           ! 1327     max=0xffff;
04524                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04525 10B1           B8                   FFFF  mov	ax,#$FFFF
04526 10B4           8946         FE            mov	-2[bp],ax
04527                                           !BCC_EOS
04528                                           ! 1328     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x60);
04529 10B7           EB           0E            jmp .EB
04530                       000010B9            .EC:
04531                                           ! Debug: list int = const $60 (used reg = )
04532 10B9           B8                   0060  mov	ax,*$60
04533 10BC           50                         push	ax
04534                                           ! Debug: list int = const $80 (used reg = )
04535 10BD           B8                   0080  mov	ax,#$80
04536 10C0           50                         push	ax
04537                                           ! Debug: func () void = outb+0 (used reg = )
04538 10C1           E8         F44A            call	_outb
04539 10C4           83C4                   04  add	sp,*4
04540                                           !BCC_EOS
04541                                           ! 1329     if (max==0x0) keyboard_panic(60);
04542                       000010C7            .EB:
04543                                           ! Debug: list int = const $64 (used reg = )
04544 10C7           B8                   0064  mov	ax,*$64
04545 10CA           50                         push	ax
04546                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04547 10CB           E8         F42A            call	_inb
04548 10CE           44                         inc	sp
04549 10CF           44                         inc	sp
04550                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04551 10D0           24                     02  and	al,*2
04552 10D2           84C0                       test	al,al
04553 10D4           74           0B            je  	.ED
04554                       000010D6            .EE:
04555                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04556 10D6           8B46         FE            mov	ax,-2[bp]
04557 10D9           48                         dec	ax
04558 10DA           8946         FE            mov	-2[bp],ax
04559                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04560 10DD           85C0                       test	ax,ax
04561 10DF           75           D8            jne	.EC
04562                       000010E1            .ED:
04563                       000010E1            .EA:
04564                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04565 10E1           8B46         FE            mov	ax,-2[bp]
04566 10E4           85C0                       test	ax,ax
04567 10E6           75           09            jne 	.EF
04568                       000010E8            .F0:
04569                                           ! Debug: list int = const $3C (used reg = )
04570 10E8           B8                   003C  mov	ax,*$3C
04571 10EB           50                         push	ax
04572                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04573 10EC           E8         00B8            call	_keyboard_panic
04574 10EF           44                         inc	sp
04575 10F0           44                         inc	sp
04576                                           !BCC_EOS
04577                                           ! 1330     outb(0x0060, 0xf4);
04578                       000010F1            .EF:
04579                                           ! Debug: list int = const $F4 (used reg = )
04580 10F1           B8                   00F4  mov	ax,#$F4
04581 10F4           50                         push	ax
04582                                           ! Debug: list int = const $60 (used reg = )
04583 10F5           B8                   0060  mov	ax,*$60
04584 10F8           50                         push	ax
04585                                           ! Debug: func () void = outb+0 (used reg = )
04586 10F9           E8         F412            call	_outb
04587 10FC           83C4                   04  add	sp,*4
04588                                           !BCC_EOS
04589                                           ! 1331     max=0xffff;
04590                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04591 10FF           B8                   FFFF  mov	ax,#$FFFF
04592 1102           8946         FE            mov	-2[bp],ax
04593                                           !BCC_EOS
04594                                           ! 1332     while ((inb(0x0064) & 0x02) && (--max>0)) outb(0x0080, 0x70);
04595 1105           EB           0E            jmp .F2
04596                       00001107            .F3:
04597                                           ! Debug: list int = const $70 (used reg = )
04598 1107           B8                   0070  mov	ax,*$70
04599 110A           50                         push	ax
04600                                           ! Debug: list int = const $80 (used reg = )
04601 110B           B8                   0080  mov	ax,#$80
04602 110E           50                         push	ax
04603                                           ! Debug: func () void = outb+0 (used reg = )
04604 110F           E8         F3FC            call	_outb
04605 1112           83C4                   04  add	sp,*4
04606                                           !BCC_EOS
04607                                           ! 1333     if (max==0x0) keyboard_panic(70);
04608                       00001115            .F2:
04609                                           ! Debug: list int = const $64 (used reg = )
04610 1115           B8                   0064  mov	ax,*$64
04611 1118           50                         push	ax
04612                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04613 1119           E8         F3DC            call	_inb
04614 111C           44                         inc	sp
04615 111D           44                         inc	sp
04616                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04617 111E           24                     02  and	al,*2
04618 1120           84C0                       test	al,al
04619 1122           74           0B            je  	.F4
04620                       00001124            .F5:
04621                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04622 1124           8B46         FE            mov	ax,-2[bp]
04623 1127           48                         dec	ax
04624 1128           8946         FE            mov	-2[bp],ax
04625                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04626 112B           85C0                       test	ax,ax
04627 112D           75           D8            jne	.F3
04628                       0000112F            .F4:
04629                       0000112F            .F1:
04630                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04631 112F           8B46         FE            mov	ax,-2[bp]
04632 1132           85C0                       test	ax,ax
04633 1134           75           09            jne 	.F6
04634                       00001136            .F7:
04635                                           ! Debug: list int = const $46 (used reg = )
04636 1136           B8                   0046  mov	ax,*$46
04637 1139           50                         push	ax
04638                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04639 113A           E8         006A            call	_keyboard_panic
04640 113D           44                         inc	sp
04641 113E           44                         inc	sp
04642                                           !BCC_EOS
04643                                           ! 1334     max=0xffff;
04644                       0000113F            .F6:
04645                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04646 113F           B8                   FFFF  mov	ax,#$FFFF
04647 1142           8946         FE            mov	-2[bp],ax
04648                                           !BCC_EOS
04649                                           ! 1335     while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x71);
04650 1145           EB           0E            jmp .F9
04651                       00001147            .FA:
04652                                           ! Debug: list int = const $71 (used reg = )
04653 1147           B8                   0071  mov	ax,*$71
04654 114A           50                         push	ax
04655                                           ! Debug: list int = const $80 (used reg = )
04656 114B           B8                   0080  mov	ax,#$80
04657 114E           50                         push	ax
04658                                           ! Debug: func () void = outb+0 (used reg = )
04659 114F           E8         F3BC            call	_outb
04660 1152           83C4                   04  add	sp,*4
04661                                           !BCC_EOS
04662                                           ! 1336     if (max==0x
04663                       00001155            .F9:
04664                                           ! Debug: list int = const $64 (used reg = )
04665 1155           B8                   0064  mov	ax,*$64
04666 1158           50                         push	ax
04667                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04668 1159           E8         F39C            call	_inb
04669 115C           44                         inc	sp
04670 115D           44                         inc	sp
04671                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04672 115E           24                     01  and	al,*1
04673                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04674 1160           84C0                       test	al,al
04675 1162           75           0B            jne 	.FB
04676                       00001164            .FC:
04677                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04678 1164           8B46         FE            mov	ax,-2[bp]
04679 1167           48                         dec	ax
04680 1168           8946         FE            mov	-2[bp],ax
04681                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04682 116B           85C0                       test	ax,ax
04683 116D           75           D8            jne	.FA
04684                       0000116F            .FB:
04685                       0000116F            .F8:
04686                                           ! 1336 0) keyboard_panic(70);
04687                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04688 116F           8B46         FE            mov	ax,-2[bp]
04689 1172           85C0                       test	ax,ax
04690 1174           75           09            jne 	.FD
04691                       00001176            .FE:
04692                                           ! Debug: list int = const $46 (used reg = )
04693 1176           B8                   0046  mov	ax,*$46
04694 1179           50                         push	ax
04695                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04696 117A           E8         002A            call	_keyboard_panic
04697 117D           44                         inc	sp
04698 117E           44                         inc	sp
04699                                           !BCC_EOS
04700                                           ! 1337     if ((inb(0x0060) != 0xfa)) {
04701                       0000117F            .FD:
04702                                           ! Debug: list int = const $60 (used reg = )
04703 117F           B8                   0060  mov	ax,*$60
04704 1182           50                         push	ax
04705                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04706 1183           E8         F372            call	_inb
04707 1186           44                         inc	sp
04708 1187           44                         inc	sp
04709                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04710 1188           3C                     FA  cmp	al,#$FA
04711 118A           74           09            je  	.FF
04712                       0000118C            .100:
04713                                           ! 1338         keyboard_panic(996);
04714                                           ! Debug: list int = const $3E4 (used reg = )
04715 118C           B8                   03E4  mov	ax,#$3E4
04716 118F           50                         push	ax
04717                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04718 1190           E8         0014            call	_keyboard_panic
04719 1193           44                         inc	sp
04720 1194           44                         inc	sp
04721                                           !BCC_EOS
04722                                           ! 1339     }
04723                                           ! 1340     outb(0x0080, 0x77);
04724                       00001195            .FF:
04725                                           ! Debug: list int = const $77 (used reg = )
04726 1195           B8                   0077  mov	ax,*$77
04727 1198           50                         push	ax
04728                                           ! Debug: list int = const $80 (used reg = )
04729 1199           B8                   0080  mov	ax,#$80
04730 119C           50                         push	ax
04731                                           ! Debug: func () void = outb+0 (used reg = )
04732 119D           E8         F36E            call	_outb
04733 11A0           83C4                   04  add	sp,*4
04734                                           !BCC_EOS
04735                                           ! 1341 }
04736 11A3           89EC                       mov	sp,bp
04737 11A5           5D                         pop	bp
04738 11A6           C3                         ret
04739                                           ! 1342   void
04740                                           ! 1343 keyboard_panic(status)
04741                                           ! 1344   Bit16u status;
04742                                           export	_keyboard_panic
04743                       000011A7            _keyboard_panic:
04744                                           !BCC_EOS
04745                                           ! 1345 {
04746                                           ! 1346   bios_printf((2 | 4 | 1), "Keyboard error:%u\n",status);
04747 11A7           55                         push	bp
04748 11A8           89E5                       mov	bp,sp
04749                                           ! Debug: list unsigned short status = [S+2+2] (used reg = )
04750 11AA           FF76         04            push	4[bp]
04751                                           ! Debug: list * char = .101+0 (used reg = )
04752 11AD           BB                   D9D6  mov	bx,#.101
04753 11B0           53                         push	bx
04754                                           ! Debug: list int = const 7 (used reg = )
04755 11B1           B8                   0007  mov	ax,*7
04756 11B4           50                         push	ax
04757                                           ! Debug: func () void = bios_printf+0 (used reg = )
04758 11B5           E8         F786            call	_bios_printf
04759 11B8           89EC                       mov	sp,bp
04760                                           !BCC_EOS
04761                                           ! 1347 }
04762 11BA           5D                         pop	bp
04763 11BB           C3                         ret
04764                                           ! 1348   void
04765                                           ! Register BX used in function keyboard_panic
04766                                           ! 1349 shutdown_status_panic(status)
04767                                           ! 1350   Bit16u status;
04768                                           export	_shutdown_status_panic
04769                       000011BC            _shutdown_status_panic:
04770                                           !BCC_EOS
04771                                           ! 1351 {
04772                                           ! 1352   bios_printf((2 | 4 | 1), "Unimplemented shutdown status: %02x\n",(Bit8u)status);
04773 11BC           55                         push	bp
04774 11BD           89E5                       mov	bp,sp
04775                                           ! Debug: list unsigned char status = [S+2+2] (used reg = )
04776 11BF           8A46         04            mov	al,4[bp]
04777 11C2           30E4                       xor	ah,ah
04778 11C4           50                         push	ax
04779                                           ! Debug: list * char = .102+0 (used reg = )
04780 11C5           BB                   D9B1  mov	bx,#.102
04781 11C8           53                         push	bx
04782                                           ! Debug: list int = const 7 (used reg = )
04783 11C9           B8                   0007  mov	ax,*7
04784 11CC           50                         push	ax
04785                                           ! Debug: func () void = bios_printf+0 (used reg = )
04786 11CD           E8         F76E            call	_bios_printf
04787 11D0           89EC                       mov	sp,bp
04788                                           !BCC_EOS
04789                                           ! 1353 }
04790 11D2           5D                         pop	bp
04791 11D3           C3                         ret
04792                                           ! 1354 void s3_resume_panic()
04793                                           ! Register BX used in function shutdown_status_panic
04794                                           ! 1355 {
04795                                           export	_s3_resume_panic
04796                       000011D4            _s3_resume_panic:
04797                                           ! 1356   bios_printf((2 | 4 | 1), "Returned from s3_resume.\n");
04798 11D4           55                         push	bp
04799 11D5           89E5                       mov	bp,sp
04800                                           ! Debug: list * char = .103+0 (used reg = )
04801 11D7           BB                   D997  mov	bx,#.103
04802 11DA           53                         push	bx
04803                                           ! Debug: list int = const 7 (used reg = )
04804 11DB           B8                   0007  mov	ax,*7
04805 11DE           50                         push	ax
04806                                           ! Debug: func () void = bios_printf+0 (used reg = )
04807 11DF           E8         F75C            call	_bios_printf
04808 11E2           89EC                       mov	sp,bp
04809                                           !BCC_EOS
04810                                           ! 1357 }
04811 11E4           5D                         pop	bp
04812 11E5           C3                         ret
04813                                           ! 1358 void
04814                                           ! Register BX used in function s3_resume_panic
04815                                           ! 1359 print_bios_banner()
04816                                           ! 1360 {
04817                                           export	_print_bios_banner
04818                       000011E6            _print_bios_banner:
04819                                           ! 1361   bios_printf(2, "Bochs ""2.7.svn"" BIOS - build: %s\n%s\nOptions: ", "08/01/21", bios_svn_version_string);
04820 11E6           55                         push	bp
04821 11E7           89E5                       mov	bp,sp
04822                                           ! Debug: list * char = bios_svn_version_string+0 (used reg = )
04823 11E9           BB                   016C  mov	bx,#_bios_svn_version_string
04824 11EC           53                         push	bx
04825                                           ! Debug: list * char = .105+0 (used reg = )
04826 11ED           BB                   D962  mov	bx,#.105
04827 11F0           53                         push	bx
04828                                           ! Debug: list * char = .104+0 (used reg = )
04829 11F1           BB                   D96B  mov	bx,#.104
04830 11F4           53                         push	bx
04831                                           ! Debug: list int = const 2 (used reg = )
04832 11F5           B8                   0002  mov	ax,*2
04833 11F8           50                         push	ax
04834                                           ! Debug: func () void = bios_printf+0 (used reg = )
04835 11F9           E8         F742            call	_bios_printf
04836 11FC           89EC                       mov	sp,bp
04837                                           !BCC_EOS
04838                                           ! 1362   bios_printf(2, "apmbios " "pcibios " "pnpbios " "eltorito " "\n\n");
04839                                           ! Debug: list * char = .106+0 (used reg = )
04840 11FE           BB                   D93E  mov	bx,#.106
04841 1201           53                         push	bx
04842                                           ! Debug: list int = const 2 (used reg = )
04843 1202           B8                   0002  mov	ax,*2
04844 1205           50                         push	ax
04845                                           ! Debug: func () void = bios_printf+0 (used reg = )
04846 1206           E8         F735            call	_bios_printf
04847 1209           89EC                       mov	sp,bp
04848                                           !BCC_EOS
04849                                           ! 1363 }
04850 120B           5D                         pop	bp
04851 120C           C3                         ret
04852                                           ! 1364 static char drivetypes[][10]={"", "Floppy","Hard Disk","CD-Rom", "Network"};
04853                                           ! Register BX used in function print_bios_banner
04854                                           
04855                       0000120D            _drivetypes:
04856                       0000120D            .107:
04857 120D                        00            .byte	0
04858 120E                  00000009            .blkb	9
04859                       00001217            .108:
04860 1217                        46            .ascii	"Floppy"
04861 121D                        00            .byte	0
04862 121E                  00000003            .blkb	3
04863                       00001221            .109:
04864 1221                        48            .ascii	"Hard Disk"
04865 122A                        00            .byte	0
04866                       0000122B            .10A:
04867 122B                        43            .ascii	"CD-Rom"
04868 1231                        00            .byte	0
04869 1232                  00000003            .blkb	3
04870                       00001235            .10B:
04871 1235                        4E            .ascii	"Network"
04872 123C                        00            .byte	0
04873 123D                  00000002            .blkb	2
04874                                           !BCC_EOS
04875                                           ! 1365 static void
04876                                           ! 1366 init_boot_vectors()
04877                                           ! 1367 {
04878                                           
04879                       0000123F            _init_boot_vectors:
04880                                           ! 1368   ipl_entry_t e;
04881                                           !BCC_EOS
04882                                           ! 1369   Bit16u count = 0;
04883 123F           55                         push	bp
04884 1240           89E5                       mov	bp,sp
04885 1242           83C4                   EE  add	sp,*-$12
04886                                           ! Debug: eq int = const 0 to unsigned short count = [S+$14-$14] (used reg = )
04887 1245           31C0                       xor	ax,ax
04888 1247           8946         EE            mov	-$12[bp],ax
04889                                           !BCC_EOS
04890                                           ! 1370   Bit16u ss = get_SS();
04891 124A           4C                         dec	sp
04892 124B           4C                         dec	sp
04893                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
04894 124C           E8         F410            call	_get_SS
04895                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$16] (used reg = )
04896 124F           8946         EC            mov	-$14[bp],ax
04897                                           !BCC_EOS
04898                                           ! 1371 #asm
04899                                           !BCC_EOS
04900                                           !BCC_ASM
04901                       00000002            _init_boot_vectors.count	set	2
04902                       FFFFFFEE            .init_boot_vectors.count	set	-$12
04903                       00000000            _init_boot_vectors.ss	set	0
04904                       FFFFFFEC            .init_boot_vectors.ss	set	-$14
04905                       00000004            _init_boot_vectors.e	set	4
04906                       FFFFFFF0            .init_boot_vectors.e	set	-$10
04907 1252           1E                           push ds
04908                                           ! 1373 endasm
04909                                           !BCC_ENDASM
04910                                           !BCC_EOS
04911                                           ! 1374   set_DS(0x9ff0);
04912                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04913 1253           B8                   9FF0  mov	ax,#$9FF0
04914 1256           50                         push	ax
04915                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
04916 1257           E8         F408            call	_set_DS
04917 125A           44                         inc	sp
04918 125B           44                         inc	sp
04919                                           !BCC_EOS
04920                                           ! 1375   _memsetb(0,0x0000,0x9ff0,0x86);
04921                                           ! Debug: list int = const $86 (used reg = )
04922 125C           B8                   0086  mov	ax,#$86
04923 125F           50                         push	ax
04924                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04925 1260           B8                   9FF0  mov	ax,#$9FF0
04926 1263           50                         push	ax
04927                                           ! Debug: list int = const 0 (used reg = )
04928 1264           31C0                       xor	ax,ax
04929 1266           50                         push	ax
04930                                           ! Debug: list int = const 0 (used reg = )
04931 1267           31C0                       xor	ax,ax
04932 1269           50                         push	ax
04933                                           ! Debug: func () void = _memsetb+0 (used reg = )
04934 126A           E8         ED93            call	__memsetb
04935 126D           83C4                   08  add	sp,*8
04936                                           !BCC_EOS
04937                                           ! 1376   *((Bit16u *)(0x0084)) = (0xFFFF);
04938                                           ! Debug: eq unsigned int = const $FFFF to unsigned short = [+$84] (used reg = )
04939 1270           B8                   FFFF  mov	ax,#$FFFF
04940 1273           A3         0084            mov	[$84],ax
04941                                           !BCC_EOS
04942                                           ! 1377   e.type = 0x01; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
04943                                           ! Debug: eq int = const 1 to unsigned short e = [S+$16-$12] (used reg = )
04944 1276           B8                   0001  mov	ax,*1
04945 1279           8946         F0            mov	-$10[bp],ax
04946                                           !BCC_EOS
04947                                           ! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
04948 127C           31C0                       xor	ax,ax
04949 127E           8946         F2            mov	-$E[bp],ax
04950                                           !BCC_EOS
04951                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
04952 1281           31C0                       xor	ax,ax
04953 1283           31DB                       xor	bx,bx
04954 1285           8946         F4            mov	-$C[bp],ax
04955 1288           895E         F6            mov	-$A[bp],bx
04956                                           !BCC_EOS
04957                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
04958 128B           31C0                       xor	ax,ax
04959 128D           31DB                       xor	bx,bx
04960 128F           8946         F8            mov	-8[bp],ax
04961 1292           895E         FA            mov	-6[bp],bx
04962                                           !BCC_EOS
04963                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
04964 1295           31C0                       xor	ax,ax
04965 1297           31DB                       xor	bx,bx
04966 1299           8946         FC            mov	-4[bp],ax
04967 129C           895E         FE            mov	-2[bp],bx
04968                                           !BCC_EOS
04969                                           ! 1378   _memcpyb(0x0000 + count * sizeof (e),0x9ff0,&e,ss,sizeof (e));
04970                                           ! Debug: list int = const $10 (used reg = )
04971 129F           B8                   0010  mov	ax,*$10
04972 12A2           50                         push	ax
04973                                           ! Debug: list unsigned short ss = [S+$18-$16] (used reg = )
04974 12A3           FF76         EC            push	-$14[bp]
04975                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
04976 12A6           8D5E         F0            lea	bx,-$10[bp]
04977 12A9           53                         push	bx
04978                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04979 12AA           B8                   9FF0  mov	ax,#$9FF0
04980 12AD           50                         push	ax
04981                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
04982 12AE           8B46         EE            mov	ax,-$12[bp]
04983 12B1           B1                     04  mov	cl,*4
04984 12B3           D3E0                       shl	ax,cl
04985                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
04986                                           ! Debug: expression subtree swapping
04987                                           ! Debug: list unsigned int = ax+0 (used reg = )
04988 12B5           50                         push	ax
04989                                           ! Debug: func () void = _memcpyb+0 (used reg = )
04990 12B6           E8         ED62            call	__memcpyb
04991 12B9           83C4                   0A  add	sp,*$A
04992                                           !BCC_EOS
04993                                           ! 1379   count++;
04994                                           ! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
04995 12BC           8B46         EE            mov	ax,-$12[bp]
04996 12BF           40                         inc	ax
04997 12C0           8946         EE            mov	-$12[bp],ax
04998                                           !BCC_EOS
04999                                           ! 1380   e.type = 0x02; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
05000                                           ! Debug: eq int = const 2 to unsigned short e = [S+$16-$12] (used reg = )
05001 12C3           B8                   0002  mov	ax,*2
05002 12C6           8946         F0            mov	-$10[bp],ax
05003                                           !BCC_EOS
05004                                           ! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
05005 12C9           31C0                       xor	ax,ax
05006 12CB           8946         F2            mov	-$E[bp],ax
05007                                           !BCC_EOS
05008                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
05009 12CE           31C0                       xor	ax,ax
05010 12D0           31DB                       xor	bx,bx
05011 12D2           8946         F4            mov	-$C[bp],ax
05012 12D5           895E         F6            mov	-$A[bp],bx
05013                                           !BCC_EOS
05014                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
05015 12D8           31C0                       xor	ax,ax
05016 12DA           31DB                       xor	bx,bx
05017 12DC           8946         F8            mov	-8[bp],ax
05018 12DF           895E         FA            mov	-6[bp],bx
05019                                           !BCC_EOS
05020                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
05021 12E2           31C0                       xor	ax,ax
05022 12E4           31DB                       xor	bx,bx
05023 12E6           8946         FC            mov	-4[bp],ax
05024 12E9           895E         FE            mov	-2[bp],bx
05025                                           !BCC_EOS
05026                                           ! 1381   _memcpyb(0x0000 + count * sizeof (e),0x9ff0,&e,ss,sizeof (e));
05027                                           ! Debug: list int = const $10 (used reg = )
05028 12EC           B8                   0010  mov	ax,*$10
05029 12EF           50                         push	ax
05030                                           ! Debug: list unsigned short ss = [S+$18-$16] (used reg = )
05031 12F0           FF76         EC            push	-$14[bp]
05032                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
05033 12F3           8D5E         F0            lea	bx,-$10[bp]
05034 12F6           53                         push	bx
05035                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05036 12F7           B8                   9FF0  mov	ax,#$9FF0
05037 12FA           50                         push	ax
05038                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
05039 12FB           8B46         EE            mov	ax,-$12[bp]
05040 12FE           B1                     04  mov	cl,*4
05041 1300           D3E0                       shl	ax,cl
05042                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
05043                                           ! Debug: expression subtree swapping
05044                                           ! Debug: list unsigned int = ax+0 (used reg = )
05045 1302           50                         push	ax
05046                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05047 1303           E8         ED15            call	__memcpyb
05048 1306           83C4                   0A  add	sp,*$A
05049                                           !BCC_EOS
05050                                           ! 1382   count++;
05051                                           ! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
05052 1309           8B46         EE            mov	ax,-$12[bp]
05053 130C           40                         inc	ax
05054 130D           8946         EE            mov	-$12[bp],ax
05055                                           !BCC_EOS
05056                                           ! 1383   e.type = 0x03; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
05057                                           ! Debug: eq int = const 3 to unsigned short e = [S+$16-$12] (used reg = )
05058 1310           B8                   0003  mov	ax,*3
05059 1313           8946         F0            mov	-$10[bp],ax
05060                                           !BCC_EOS
05061                                           ! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
05062 1316           31C0                       xor	ax,ax
05063 1318           8946         F2            mov	-$E[bp],ax
05064                                           !BCC_EOS
05065                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
05066 131B           31C0                       xor	ax,ax
05067 131D           31DB                       xor	bx,bx
05068 131F           8946         F4            mov	-$C[bp],ax
05069 1322           895E         F6            mov	-$A[bp],bx
05070                                           !BCC_EOS
05071                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
05072 1325           31C0                       xor	ax,ax
05073 1327           31DB                       xor	bx,bx
05074 1329           8946         F8            mov	-8[bp],ax
05075 132C           895E         FA            mov	-6[bp],bx
05076                                           !BCC_EOS
05077                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
05078 132F           31C0                       xor	ax,ax
05079 1331           31DB                       xor	bx,bx
05080 1333           8946         FC            mov	-4[bp],ax
05081 1336           895E         FE            mov	-2[bp],bx
05082                                           !BCC_EOS
05083                                           ! 1384   _memcpyb(0x0000 + count * sizeof (e),0x9ff0,&e,ss,sizeof (e));
05084                                           ! Debug: list int = const $10 (used reg = )
05085 1339           B8                   0010  mov	ax,*$10
05086 133C           50                         push	ax
05087                                           ! Debug: list unsigned short ss = [S+$18-$16] (used reg = )
05088 133D           FF76         EC            push	-$14[bp]
05089                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
05090 1340           8D5E         F0            lea	bx,-$10[bp]
05091 1343           53                         push	bx
05092                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05093 1344           B8                   9FF0  mov	ax,#$9FF0
05094 1347           50                         push	ax
05095                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
05096 1348           8B46         EE            mov	ax,-$12[bp]
05097 134B           B1                     04  mov	cl,*4
05098 134D           D3E0                       shl	ax,cl
05099                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
05100                                           ! Debug: expression subtree swapping
05101                                           ! Debug: list unsigned int = ax+0 (used reg = )
05102 134F           50                         push	ax
05103                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05104 1350           E8         ECC8            call	__memcpyb
05105 1353           83C4                   0A  add	sp,*$A
05106                                           !BCC_EOS
05107                                           ! 1385   count++;
05108                                           ! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
05109 1356           8B46         EE            mov	ax,-$12[bp]
05110 1359           40                         inc	ax
05111 135A           8946         EE            mov	-$12[bp],ax
05112                                           !BCC_EOS
05113                                           ! 1386   *((Bit16u *)(0x0080)) = (count);
05114                                           ! Debug: eq unsigned short count = [S+$16-$14] to unsigned short = [+$80] (used reg = )
05115 135D           8B46         EE            mov	ax,-$12[bp]
05116 1360           A3         0080            mov	[$80],ax
05117                                           !BCC_EOS
05118                                           ! 1387   *((Bit16u *)(0x0082)) = (0xffff);
05119                                           ! Debug: eq unsigned int = const $FFFF to unsigned short = [+$82] (used reg = )
05120 1363           B8                   FFFF  mov	ax,#$FFFF
05121 1366           A3         0082            mov	[$82],ax
05122                                           !BCC_EOS
05123                                           ! 1388 #asm
05124                                           !BCC_EOS
05125                                           !BCC_ASM
05126                       00000002            _init_boot_vectors.count	set	2
05127                       FFFFFFEE            .init_boot_vectors.count	set	-$12
05128                       00000000            _init_boot_vectors.ss	set	0
05129                       FFFFFFEC            .init_boot_vectors.ss	set	-$14
05130                       00000004            _init_boot_vectors.e	set	4
05131                       FFFFFFF0            .init_boot_vectors.e	set	-$10
05132 1369           1F                           pop ds
05133                                           ! 1390 endasm
05134                                           !BCC_ENDASM
05135                                           !BCC_EOS
05136                                           ! 1391 }
05137 136A           89EC                       mov	sp,bp
05138 136C           5D                         pop	bp
05139 136D           C3                         ret
05140                                           ! 1392 static Bit8u
05141                                           ! Register BX used in function init_boot_vectors
05142                                           ! 1393 get_boot_vector(i, e)
05143                                           ! 1394 Bit16u i; ipl_entry_t *e;
05144                       0000136E            _get_boot_vector:
05145                                           !BCC_EOS
05146                                           !BCC_EOS
05147                                           ! 1395 {
05148                                           ! 1396   Bit16u count;
05149                                           !BCC_EOS
05150                                           ! 1397   Bit16u ss = get_SS();
05151 136E           55                         push	bp
05152 136F           89E5                       mov	bp,sp
05153 1371           83C4                   FC  add	sp,*-4
05154                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05155 1374           E8         F2E8            call	_get_SS
05156                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
05157 1377           8946         FC            mov	-4[bp],ax
05158                                           !BCC_EOS
05159                                           ! 1398   count = _read_word(0x0080, 0x9ff0);
05160                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05161 137A           B8                   9FF0  mov	ax,#$9FF0
05162 137D           50                         push	ax
05163                                           ! Debug: list int = const $80 (used reg = )
05164 137E           B8                   0080  mov	ax,#$80
05165 1381           50                         push	ax
05166                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
05167 1382           E8         F26D            call	__read_word
05168 1385           83C4                   04  add	sp,*4
05169                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+6-4] (used reg = )
05170 1388           8946         FE            mov	-2[bp],ax
05171                                           !BCC_EOS
05172                                           ! 1399   if (i >= count) return 0;
05173                                           ! Debug: ge unsigned short count = [S+6-4] to unsigned short i = [S+6+2] (used reg = )
05174 138B           8B46         04            mov	ax,4[bp]
05175 138E           3B46         FE            cmp	ax,-2[bp]
05176 1391           72           06            jb  	.10C
05177                       00001393            .10D:
05178 1393           30C0                       xor	al,al
05179 1395           89EC                       mov	sp,bp
05180 1397           5D                         pop	bp
05181 1398           C3                         ret
05182                                           !BCC_EOS
05183                                           ! 1400   _memcpyb(e,ss,0x0000 + i * sizeof (*e),0x9ff0,sizeof (*e));
05184                       00001399            .10C:
05185                                           ! Debug: list int = const $10 (used reg = )
05186 1399           B8                   0010  mov	ax,*$10
05187 139C           50                         push	ax
05188                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05189 139D           B8                   9FF0  mov	ax,#$9FF0
05190 13A0           50                         push	ax
05191                                           ! Debug: mul int = const $10 to unsigned short i = [S+$A+2] (used reg = )
05192 13A1           8B46         04            mov	ax,4[bp]
05193 13A4           B1                     04  mov	cl,*4
05194 13A6           D3E0                       shl	ax,cl
05195                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
05196                                           ! Debug: expression subtree swapping
05197                                           ! Debug: list unsigned int = ax+0 (used reg = )
05198 13A8           50                         push	ax
05199                                           ! Debug: list unsigned short ss = [S+$C-6] (used reg = )
05200 13A9           FF76         FC            push	-4[bp]
05201                                           ! Debug: list * struct  e = [S+$E+4] (used reg = )
05202 13AC           FF76         06            push	6[bp]
05203                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05204 13AF           E8         EC69            call	__memcpyb
05205 13B2           83C4                   0A  add	sp,*$A
05206                                           !BCC_EOS
05207                                           ! 1401   return 1;
05208 13B5           B0                     01  mov	al,*1
05209 13B7           89EC                       mov	sp,bp
05210 13B9           5D                         pop	bp
05211 13BA           C3                         ret
05212                                           !BCC_EOS
05213                                           ! 1402 }
05214                                           ! 1403   void
05215                                           ! 1404 interactive_bootkey()
05216                                           ! 1405 {
05217                                           export	_interactive_bootkey
05218                       000013BB            _interactive_bootkey:
05219                                           ! 1406   ipl_entry_t e;
05220                                           !BCC_EOS
05221                                           ! 1407   Bit16u count;
05222                                           !BCC_EOS
05223                                           ! 1408   char description[33];
05224                                           !BCC_EOS
05225                                           ! 1409   Bit8u scan_code;
05226                                           !BCC_EOS
05227                                           ! 1410   Bit8u i;
05228                                           !BCC_EOS
05229                                           ! 1411   Bit16u ss = get_SS();
05230 13BB           55                         push	bp
05231 13BC           89E5                       mov	bp,sp
05232 13BE           83C4                   C8  add	sp,*-$38
05233                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05234 13C1           E8         F29B            call	_get_SS
05235                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$3A-$3A] (used reg = )
05236 13C4           8946         C8            mov	-$38[bp],ax
05237                                           !BCC_EOS
05238                                           ! 1412   Bit16u valid_choice = 0;
05239 13C7           4C                         dec	sp
05240 13C8           4C                         dec	sp
05241                                           ! Debug: eq int = const 0 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05242 13C9           31C0                       xor	ax,ax
05243 13CB           8946         C6            mov	-$3A[bp],ax
05244                                           !BCC_EOS
05245                                           ! 1413   while (check_for_keystroke())
05246                                           ! 1414     get_keystroke();
05247 13CE           EB           03            jmp .10F
05248                       000013D0            .110:
05249                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05250 13D0           E8         F532            call	_get_keystroke
05251                                           !BCC_EOS
05252                                           ! 1415   if ((inb_cmos(0x3f) & 0x01) == 0x01)
05253                       000013D3            .10F:
05254                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05255 13D3           E8         F521            call	_check_for_keystroke
05256 13D6           84C0                       test	al,al
05257 13D8           75           F6            jne	.110
05258                       000013DA            .111:
05259                       000013DA            .10E:
05260                                           ! Debug: list int = const $3F (used reg = )
05261 13DA           B8                   003F  mov	ax,*$3F
05262 13DD           50                         push	ax
05263                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
05264 13DE           E8         F15C            call	_inb_cmos
05265 13E1           44                         inc	sp
05266 13E2           44                         inc	sp
05267                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
05268 13E3           24                     01  and	al,*1
05269                                           ! Debug: logeq int = const 1 to unsigned char = al+0 (used reg = )
05270 13E5           3C                     01  cmp	al,*1
05271 13E7           75           04            jne 	.112
05272                       000013E9            .113:
05273                                           ! 1416     return;
05274 13E9           89EC                       mov	sp,bp
05275 13EB           5D                         pop	bp
05276 13EC           C3                         ret
05277                                           !BCC_EOS
05278                                           ! 1417   bios_printf(2, "Press F12
05279                       000013ED            .112:
05280                                           ! 1417  for boot menu.\n\n");
05281                                           ! Debug: list * char = .114+0 (used reg = )
05282 13ED           BB                   D923  mov	bx,#.114
05283 13F0           53                         push	bx
05284                                           ! Debug: list int = const 2 (used reg = )
05285 13F1           B8                   0002  mov	ax,*2
05286 13F4           50                         push	ax
05287                                           ! Debug: func () void = bios_printf+0 (used reg = )
05288 13F5           E8         F546            call	_bios_printf
05289 13F8           83C4                   04  add	sp,*4
05290                                           !BCC_EOS
05291                                           ! 1418   delay_ticks_and_check_for_keystroke(11, 5);
05292                                           ! Debug: list int = const 5 (used reg = )
05293 13FB           B8                   0005  mov	ax,*5
05294 13FE           50                         push	ax
05295                                           ! Debug: list int = const $B (used reg = )
05296 13FF           B8                   000B  mov	ax,*$B
05297 1402           50                         push	ax
05298                                           ! Debug: func () void = delay_ticks_and_check_for_keystroke+0 (used reg = )
05299 1403           E8         F507            call	_delay_ticks_and_check_for_keystroke
05300 1406           83C4                   04  add	sp,*4
05301                                           !BCC_EOS
05302                                           ! 1419   if (check_for_keystroke())
05303                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05304 1409           E8         F4EB            call	_check_for_keystroke
05305 140C           84C0                       test	al,al
05306 140E         0F84         01A1            beq 	.115
05307                       00001412            .116:
05308                                           ! 1420   {
05309                                           ! 1421     scan_code = get_keystroke();
05310                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05311 1412           E8         F4F0            call	_get_keystroke
05312                                           ! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05313 1415           8846         CC            mov	-$34[bp],al
05314                                           !BCC_EOS
05315                                           ! 1422     if (scan_code == 0x86)
05316                                           ! Debug: logeq int = const $86 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05317 1418           8A46         CC            mov	al,-$34[bp]
05318 141B           3C                     86  cmp	al,#$86
05319 141D         0F85         0192            bne 	.117
05320                       00001421            .118:
05321                                           ! 1423     {
05322                                           ! 1424       while (check_for_keystroke())
05323                                           ! 1425         get_keystroke();
05324 1421           EB           03            jmp .11A
05325                       00001423            .11B:
05326                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05327 1423           E8         F4DF            call	_get_keystroke
05328                                           !BCC_EOS
05329                                           ! 1426       bios_printf(2, "Select boot device:\n\n");
05330                       00001426            .11A:
05331                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05332 1426           E8         F4CE            call	_check_for_keystroke
05333 1429           84C0                       test	al,al
05334 142B           75           F6            jne	.11B
05335                       0000142D            .11C:
05336                       0000142D            .119:
05337                                           ! Debug: list * char = .11D+0 (used reg = )
05338 142D           BB                   D90D  mov	bx,#.11D
05339 1430           53                         push	bx
05340                                           ! Debug: list int = const 2 (used reg = )
05341 1431           B8                   0002  mov	ax,*2
05342 1434           50                         push	ax
05343                                           ! Debug: func () void = bios_printf+0 (used reg = )
05344 1435           E8         F506            call	_bios_printf
05345 1438           83C4                   04  add	sp,*4
05346                                           !BCC_EOS
05347                                           ! 1427       count = _read_word(0x0080, 0x9ff0);
05348                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05349 143B           B8                   9FF0  mov	ax,#$9FF0
05350 143E           50                         push	ax
05351                                           ! Debug: list int = const $80 (used reg = )
05352 143F           B8                   0080  mov	ax,#$80
05353 1442           50                         push	ax
05354                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
05355 1443           E8         F1AC            call	__read_word
05356 1446           83C4                   04  add	sp,*4
05357                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$3C-$14] (used reg = )
05358 1449           8946         EE            mov	-$12[bp],ax
05359                                           !BCC_EOS
05360                                           ! 1428       for (i = 0; i < count; i++)
05361                                           ! Debug: eq int = const 0 to unsigned char i = [S+$3C-$37] (used reg = )
05362 144C           30C0                       xor	al,al
05363 144E           8846         CB            mov	-$35[bp],al
05364                                           !BCC_EOS
05365                                           !BCC_EOS
05366                                           ! 1429       {
05367 1451           E9         00EC            br 	.120
05368                       00001454            .121:
05369                                           ! 1430         _memcpyb(&e,ss,0x0000 + i * sizeof (e),0x9ff0,sizeof (e));
05370                                           ! Debug: list int = const $10 (used reg = )
05371 1454           B8                   0010  mov	ax,*$10
05372 1457           50                         push	ax
05373                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05374 1458           B8                   9FF0  mov	ax,#$9FF0
05375 145B           50                         push	ax
05376                                           ! Debug: mul int = const $10 to unsigned char i = [S+$40-$37] (used reg = )
05377 145C           8A46         CB            mov	al,-$35[bp]
05378 145F           30E4                       xor	ah,ah
05379 1461           B1                     04  mov	cl,*4
05380 1463           D3E0                       shl	ax,cl
05381                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
05382                                           ! Debug: expression subtree swapping
05383                                           ! Debug: list unsigned int = ax+0 (used reg = )
05384 1465           50                         push	ax
05385                                           ! Debug: list unsigned short ss = [S+$42-$3A] (used reg = )
05386 1466           FF76         C8            push	-$38[bp]
05387                                           ! Debug: list * struct  e = S+$44-$12 (used reg = )
05388 1469           8D5E         F0            lea	bx,-$10[bp]
05389 146C           53                         push	bx
05390                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05391 146D           E8         EBAB            call	__memcpyb
05392 1470           83C4                   0A  add	sp,*$A
05393                                           !BCC_EOS
05394                                           ! 1431         bios_printf(2, "%d. ", i+1);
05395                                           ! Debug: add int = const 1 to unsigned char i = [S+$3C-$37] (used reg = )
05396 1473           8A46         CB            mov	al,-$35[bp]
05397 1476           30E4                       xor	ah,ah
05398                                           ! Debug: list unsigned int = ax+1 (used reg = )
05399 1478           40                         inc	ax
05400 1479           50                         push	ax
05401                                           ! Debug: list * char = .122+0 (used reg = )
05402 147A           BB                   D908  mov	bx,#.122
05403 147D           53                         push	bx
05404                                           ! Debug: list int = const 2 (used reg = )
05405 147E           B8                   0002  mov	ax,*2
05406 1481           50                         push	ax
05407                                           ! Debug: func () void = bios_printf+0 (used reg = )
05408 1482           E8         F4B9            call	_bios_printf
05409 1485           83C4                   06  add	sp,*6
05410                                           !BCC_EOS
05411                                           ! 1432         switch(e.type)
05412 1488           8B46         F0            mov	ax,-$10[bp]
05413                                           ! 1433         {
05414 148B           E9         008F            br 	.125
05415                                           ! 1434           case 0x01:
05416                                           ! 1435           case 0x02:
05417                       0000148E            .126:
05418                                           ! 1436           case 0x03:
05419                       0000148E            .127:
05420                                           ! 1437             bios_printf(2, "%s\n", drivetypes[e.type]);
05421                       0000148E            .128:
05422                                           ! Debug: ptradd unsigned short e = [S+$3C-$12] to [5] [$A] char = drivetypes+0 (used reg = )
05423 148E           8B5E         F0            mov	bx,-$10[bp]
05424 1491           89DA                       mov	dx,bx
05425 1493           D1E3                       shl	bx,*1
05426 1495           D1E3                       shl	bx,*1
05427 1497           01D3                       add	bx,dx
05428 1499           D1E3                       shl	bx,*1
05429                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
05430                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
05431 149B           81C3                 120D  add	bx,#_drivetypes
05432 149F           53                         push	bx
05433                                           ! Debug: list * char = .129+0 (used reg = )
05434 14A0           BB                   D904  mov	bx,#.129
05435 14A3           53                         push	bx
05436                                           ! Debug: list int = const 2 (used reg = )
05437 14A4           B8                   0002  mov	ax,*2
05438 14A7           50                         push	ax
05439                                           ! Debug: func () void = bios_printf+0 (used reg = )
05440 14A8           E8         F493            call	_bios_printf
05441 14AB           83C4                   06  add	sp,*6
05442                                           !BCC_EOS
05443                                           ! 1438             break;
05444 14AE           E9         0088            br 	.123
05445                                           !BCC_EOS
05446                                           ! 1439           case 0x80:
05447                                           ! 1440             bios_printf(2, "%s", drivetypes[4]);
05448                       000014B1            .12A:
05449                                           ! Debug: list * char = drivetypes+$28 (used reg = )
05450 14B1           BB                   1235  mov	bx,#_drivetypes+$28
05451 14B4           53                         push	bx
05452                                           ! Debug: list * char = .12B+0 (used reg = )
05453 14B5           BB                   D901  mov	bx,#.12B
05454 14B8           53                         push	bx
05455                                           ! Debug: list int = const 2 (used reg = )
05456 14B9           B8                   0002  mov	ax,*2
05457 14BC           50                         push	ax
05458                                           ! Debug: func () void = bios_printf+0 (used reg = )
05459 14BD           E8         F47E            call	_bios_printf
05460 14C0           83C4                   06  add	sp,*6
05461                                           !BCC_EOS
05462                                           ! 1441             if (e.description != 0)
05463                                           ! Debug: ne unsigned long = const 0 to unsigned long e = [S+$3C-$A] (used reg = )
05464                                           ! Debug: expression subtree swapping
05465 14C3           31C0                       xor	ax,ax
05466 14C5           31DB                       xor	bx,bx
05467 14C7           53                         push	bx
05468 14C8           50                         push	ax
05469 14C9           8B46         F8            mov	ax,-8[bp]
05470 14CC           8B5E         FA            mov	bx,-6[bp]
05471 14CF           8D7E         C2            lea	di,-2+..FFFF[bp]
05472 14D2           E8         EBC7            call	lcmpul
05473 14D5           8D66         C6            lea	sp,2+..FFFF[bp]
05474 14D8           74           31            je  	.12C
05475                       000014DA            .12D:
05476                                           ! 1442             {
05477                                           ! 1443               _memcpyb(&description,ss,*((Bit16u *)&e.description),*(((Bit16u *)&e.description)+1),32);
05478                                           ! Debug: list int = const $20 (used reg = )
05479 14DA           B8                   0020  mov	ax,*$20
05480 14DD           50                         push	ax
05481                                           ! Debug: list unsigned short e = [S+$3E-8] (used reg = )
05482 14DE           FF76         FA            push	-6[bp]
05483                                           ! Debug: list unsigned short e = [S+$40-$A] (used reg = )
05484 14E1           FF76         F8            push	-8[bp]
05485                                           ! Debug: list unsigned short ss = [S+$42-$3A] (used reg = )
05486 14E4           FF76         C8            push	-$38[bp]
05487                                           ! Debug: list * [$21] char description = S+$44-$35 (used reg = )
05488 14E7           8D5E         CD            lea	bx,-$33[bp]
05489 14EA           53                         push	bx
05490                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05491 14EB           E8         EB2D            call	__memcpyb
05492 14EE           83C4                   0A  add	sp,*$A
05493                                           !BCC_EOS
05494                                           ! 1444               description[32] = 0;
05495                                           ! Debug: eq int = const 0 to char description = [S+$3C-$15] (used reg = )
05496 14F1           30C0                       xor	al,al
05497 14F3           8846         ED            mov	-$13[bp],al
05498                                           !BCC_EOS
05499                                           ! 1445               bios_printf(2, " [%S]", ss, description);
05500                                           ! Debug: list * char description = S+$3C-$35 (used reg = )
05501 14F6           8D5E         CD            lea	bx,-$33[bp]
05502 14F9           53                         push	bx
05503                                           ! Debug: list unsigned short ss = [S+$3E-$3A] (used reg = )
05504 14FA           FF76         C8            push	-$38[bp]
05505                                           ! Debug: list * char = .12E+0 (used reg = )
05506 14FD           BB                   D8FB  mov	bx,#.12E
05507 1500           53                         push	bx
05508                                           ! Debug: list int = const 2 (used reg = )
05509 1501           B8                   0002  mov	ax,*2
05510 1504           50                         push	ax
05511                                           ! Debug: func () void = bios_printf+0 (used reg = )
05512 1505           E8         F436            call	_bios_printf
05513 1508           83C4                   08  add	sp,*8
05514                                           !BCC_EOS
05515                                           ! 1446            }
05516                                           ! 1447            bios_printf(2, "\n");
05517                       0000150B            .12C:
05518                                           ! Debug: list * char = .12F+0 (used reg = )
05519 150B           BB                   D8F9  mov	bx,#.12F
05520 150E           53                         push	bx
05521                                           ! Debug: list int = const 2 (used reg = )
05522 150F           B8                   0002  mov	ax,*2
05523 1512           50                         push	ax
05524                                           ! Debug: func () void = bios_printf+0 (used reg = )
05525 1513           E8         F428            call	_bios_printf
05526 1516           83C4                   04  add	sp,*4
05527                                           !BCC_EOS
05528                                           ! 1448            break;
05529 1519           EB           1E            jmp .123
05530                                           !BCC_EOS
05531                                           ! 1449         }
05532                                           ! 1450       }
05533 151B           EB           1C            jmp .123
05534                       0000151D            .125:
05535 151D           2D                   0001  sub	ax,*1
05536 1520         0F84         FF6A            beq 	.126
05537 1524           2D                   0001  sub	ax,*1
05538 1527         0F84         FF63            beq 	.127
05539 152B           2D                   0001  sub	ax,*1
05540 152E         0F84         FF5C            beq 	.128
05541 1532           2D                   007D  sub	ax,*$7D
05542 1535         0F84         FF78            beq 	.12A
05543                       00001539            .123:
05544                       FFFFFFC4            ..FFFF	=	-$3C
05545                                           ! 1451       count++;
05546                       00001539            .11F:
05547                                           ! Debug: postinc unsigned char i = [S+$3C-$37] (used reg = )
05548 1539           8A46         CB            mov	al,-$35[bp]
05549 153C           40                         inc	ax
05550 153D           8846         CB            mov	-$35[bp],al
05551                       00001540            .120:
05552                                           ! Debug: lt unsigned short count = [S+$3C-$14] to unsigned char i = [S+$3C-$37] (used reg = )
05553 1540           8A46         CB            mov	al,-$35[bp]
05554 1543           30E4                       xor	ah,ah
05555 1545           3B46         EE            cmp	ax,-$12[bp]
05556 1548         0F82         FF08            blo 	.121
05557                       0000154C            .130:
05558                       0000154C            .11E:
05559                                           ! Debug: postinc unsigned short count = [S+$3C-$14] (used reg = )
05560 154C           8B46         EE            mov	ax,-$12[bp]
05561 154F           40                         inc	ax
05562 1550           8946         EE            mov	-$12[bp],ax
05563                                           !BCC_EOS
05564                                           ! 1452       while (!valid_choice) {
05565 1553           EB           49            jmp .132
05566                       00001555            .133:
05567                                           ! 1453         scan_code = get_keystroke();
05568                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05569 1555           E8         F3AD            call	_get_keystroke
05570                                           ! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05571 1558           8846         CC            mov	-$34[bp],al
05572                                           !BCC_EOS
05573                                           ! 1454         if (scan_code == 0x01 || scan_code == 0x58)
05574                                           ! Debug: logeq int = const 1 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05575 155B           8A46         CC            mov	al,-$34[bp]
05576 155E           3C                     01  cmp	al,*1
05577 1560           74           07            je  	.135
05578                       00001562            .136:
05579                                           ! Debug: logeq int = const $58 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05580 1562           8A46         CC            mov	al,-$34[bp]
05581 1565           3C                     58  cmp	al,*$58
05582 1567           75           08            jne 	.134
05583                       00001569            .135:
05584                                           ! 1455         {
05585                                           ! 1456           valid_choice = 1;
05586                                           ! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05587 1569           B8                   0001  mov	ax,*1
05588 156C           8946         C6            mov	-$3A[bp],ax
05589                                           !BCC_EOS
05590                                           ! 1457         }
05591                                           ! 1458         else if (scan_code <= count)
05592 156F           EB           2D            jmp .137
05593                       00001571            .134:
05594                                           ! Debug: le unsigned short count = [S+$3C-$14] to unsigned char scan_code = [S+$3C-$36] (used reg = )
05595 1571           8A46         CC            mov	al,-$34[bp]
05596 1574           30E4                       xor	ah,ah
05597 1576           3B46         EE            cmp	ax,-$12[bp]
05598 1579           77           23            ja  	.138
05599                       0000157B            .139:
05600                                           ! 1459         {
05601                                           ! 1460           valid_choice = 1;
05602                                           ! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05603 157B           B8                   0001  mov	ax,*1
05604 157E           8946         C6            mov	-$3A[bp],ax
05605                                           !BCC_EOS
05606                                           ! 1461           scan_code -= 1;
05607                                           ! Debug: subab int = const 1 to unsigned char scan_code = [S+$3C-$36] (used reg = )
05608 1581           8A46         CC            mov	al,-$34[bp]
05609 1584           30E4                       xor	ah,ah
05610 1586           48                         dec	ax
05611 1587           8846         CC            mov	-$34[bp],al
05612                                           !BCC_EOS
05613                                           ! 1462           _write_word(scan_code, 0x0084, 0x9ff0);
05614                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05615 158A           B8                   9FF0  mov	ax,#$9FF0
05616 158D           50                         push	ax
05617                                           ! Debug: list int = const $84 (used reg = )
05618 158E           B8                   0084  mov	ax,#$84
05619 1591           50                         push	ax
05620                                           ! Debug: list unsigned char scan_code = [S+$40-$36] (used reg = )
05621 1592           8A46         CC            mov	al,-$34[bp]
05622 1595           30E4                       xor	ah,ah
05623 1597           50                         push	ax
05624                                           ! Debug: func () void = _write_word+0 (used reg = )
05625 1598           E8         F078            call	__write_word
05626 159B           83C4                   06  add	sp,*6
05627                                           !BCC_EOS
05628                                           ! 1463         }
05629                                           ! 1464       }
05630                       0000159E            .138:
05631                       0000159E            .137:
05632                                           ! 1465       bios_printf(2, "\n");
05633                       0000159E            .132:
05634 159E           8B46         C6            mov	ax,-$3A[bp]
05635 15A1           85C0                       test	ax,ax
05636 15A3           74           B0            je 	.133
05637                       000015A5            .13A:
05638                       000015A5            .131:
05639                                           ! Debug: list * char = .13B+0 (used reg = )
05640 15A5           BB                   D8F7  mov	bx,#.13B
05641 15A8           53                         push	bx
05642                                           ! Debug: list int = const 2 (used reg = )
05643 15A9           B8                   0002  mov	ax,*2
05644 15AC           50                         push	ax
05645                                           ! Debug: func () void = bios_printf+0 (used reg = )
05646 15AD           E8         F38E            call	_bios_printf
05647 15B0           83C4                   04  add	sp,*4
05648                                           !BCC_EOS
05649                                           ! 1466     }
05650                                           ! 1467   }
05651                       000015B3            .117:
05652                                           ! 1468 }
05653                       000015B3            .115:
05654 15B3           89EC                       mov	sp,bp
05655 15B5           5D                         pop	bp
05656 15B6           C3                         ret
05657                                           ! 1469 void
05658                                           ! Register BX used in function interactive_bootkey
05659                                           ! 1470 print_boot_device(e)
05660                                           ! 1471   ipl_entry_t *e;
05661                                           export	_print_boot_device
05662                       000015B7            _print_boot_device:
05663                                           !BCC_EOS
05664                                           ! 1472 {
05665                                           ! 1473   Bit16u type;
05666                                           !BCC_EOS
05667                                           ! 1474   char description[33];
05668                                           !BCC_EOS
05669                                           ! 1475   Bit16u ss = get_SS();
05670 15B7           55                         push	bp
05671 15B8           89E5                       mov	bp,sp
05672 15BA           83C4                   DA  add	sp,*-$26
05673                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05674 15BD           E8         F09F            call	_get_SS
05675                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$28-$28] (used reg = )
05676 15C0           8946         DA            mov	-$26[bp],ax
05677                                           !BCC_EOS
05678                                           ! 1476   type = e->type;
05679 15C3           8B5E         04            mov	bx,4[bp]
05680                                           ! Debug: eq unsigned short = [bx+0] to unsigned short type = [S+$28-4] (used reg = )
05681 15C6           8B1F                       mov	bx,[bx]
05682 15C8           895E         FE            mov	-2[bp],bx
05683                                           !BCC_EOS
05684                                           ! 1477   if (type == 0x80) type = 0x4;
05685                                           ! Debug: logeq int = const $80 to unsigned short type = [S+$28-4] (used reg = )
05686 15CB           8B46         FE            mov	ax,-2[bp]
05687 15CE           3D                   0080  cmp	ax,#$80
05688 15D1           75           06            jne 	.13C
05689                       000015D3            .13D:
05690                                           ! Debug: eq int = const 4 to unsigned short type = [S+$28-4] (used reg = )
05691 15D3           B8                   0004  mov	ax,*4
05692 15D6           8946         FE            mov	-2[bp],ax
05693                                           !BCC_EOS
05694                                           ! 1478   if (type == 0 || type > 0x4) bios_printf((2 | 4 | 1), "Bad drive type\n");
05695                       000015D9            .13C:
05696                                           ! Debug: logeq int = const 0 to unsigned short type = [S+$28-4] (used reg = )
05697 15D9           8B46         FE            mov	ax,-2[bp]
05698 15DC           85C0                       test	ax,ax
05699 15DE           74           08            je  	.13F
05700                       000015E0            .140:
05701                                           ! Debug: gt int = const 4 to unsigned short type = [S+$28-4] (used reg = )
05702 15E0           8B46         FE            mov	ax,-2[bp]
05703 15E3           3D                   0004  cmp	ax,*4
05704 15E6           76           0E            jbe 	.13E
05705                       000015E8            .13F:
05706                                           ! Debug: list * char = .141+0 (used reg = )
05707 15E8           BB                   D8E7  mov	bx,#.141
05708 15EB           53                         push	bx
05709                                           ! Debug: list int = const 7 (used reg = )
05710 15EC           B8                   0007  mov	ax,*7
05711 15EF           50                         push	ax
05712                                           ! Debug: func () void = bios_printf+0 (used reg = )
05713 15F0           E8         F34B            call	_bios_printf
05714 15F3           83C4                   04  add	sp,*4
05715                                           !BCC_EOS
05716                                           ! 1479   bios_printf(2, "Booting from %s", drivetypes[type]);
05717                       000015F6            .13E:
05718                                           ! Debug: ptradd unsigned short type = [S+$28-4] to [5] [$A] char = drivetypes+0 (used reg = )
05719 15F6           8B5E         FE            mov	bx,-2[bp]
05720 15F9           89DA                       mov	dx,bx
05721 15FB           D1E3                       shl	bx,*1
05722 15FD           D1E3                       shl	bx,*1
05723 15FF           01D3                       add	bx,dx
05724 1601           D1E3                       shl	bx,*1
05725                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
05726                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
05727 1603           81C3                 120D  add	bx,#_drivetypes
05728 1607           53                         push	bx
05729                                           ! Debug: list * char = .142+0 (used reg = )
05730 1608           BB                   D8D7  mov	bx,#.142
05731 160B           53                         push	bx
05732                                           ! Debug: list int = const 2 (used reg = )
05733 160C           B8                   0002  mov	ax,*2
05734 160F           50                         push	ax
05735                                           ! Debug: func () void = bios_printf+0 (used reg = )
05736 1610           E8         F32B            call	_bios_printf
05737 1613           83C4                   06  add	sp,*6
05738                                           !BCC_EOS
05739                                           ! 1480   if (type == 4 && e->description != 0) {
05740                                           ! Debug: logeq int = const 4 to unsigned short type = [S+$28-4] (used reg = )
05741 1616           8B46         FE            mov	ax,-2[bp]
05742 1619           3D                   0004  cmp	ax,*4
05743 161C           75           51            jne 	.143
05744                       0000161E            .145:
05745 161E           8B5E         04            mov	bx,4[bp]
05746                                           ! Debug: ne unsigned long = const 0 to unsigned long = [bx+8] (used reg = )
05747                                           ! Debug: expression subtree swapping
05748 1621           31C0                       xor	ax,ax
05749 1623           31F6                       xor	si,si
05750 1625           56                         push	si
05751 1626           50                         push	ax
05752 1627           8B47         08            mov	ax,8[bx]
05753 162A           8B5F         0A            mov	bx,$A[bx]
05754 162D           8D7E         D6            lea	di,-$2A[bp]
05755 1630           E8         EA69            call	lcmpul
05756 1633           8D66         DA            lea	sp,-$26[bp]
05757 1636           74           37            je  	.143
05758                       00001638            .144:
05759                                           ! 1481     _memcpyb(&description,ss,*((Bit16u *)&e->description),*(((Bit16u *)&e->description)+1),32);
05760                                           ! Debug: list int = const $20 (used reg = )
05761 1638           B8                   0020  mov	ax,*$20
05762 163B           50                         push	ax
05763 163C           8B5E         04            mov	bx,4[bp]
05764                                           ! Debug: address unsigned long = [bx+8] (used reg = )
05765                                           ! Debug: cast * unsigned short = const 0 to * unsigned long = bx+8 (used reg = )
05766                                           ! Debug: ptradd int = const 1 to * unsigned short = bx+8 (used reg = )
05767                                           ! Debug: list unsigned short = [bx+$A] (used reg = )
05768 163F           FF77         0A            push	$A[bx]
05769 1642           8B5E         04            mov	bx,4[bp]
05770                                           ! Debug: address unsigned long = [bx+8] (used reg = )
05771                                           ! Debug: cast * unsigned short = const 0 to * unsigned long = bx+8 (used reg = )
05772                                           ! Debug: list unsigned short = [bx+8] (used reg = )
05773 1645           FF77         08            push	8[bx]
05774                                           ! Debug: list unsigned short ss = [S+$2E-$28] (used reg = )
05775 1648           FF76         DA            push	-$26[bp]
05776                                           ! Debug: list * [$21] char description = S+$30-$25 (used reg = )
05777 164B           8D5E         DD            lea	bx,-$23[bp]
05778 164E           53                         push	bx
05779                                           ! Debug: func () void = _memcpyb+0 (used reg = )
05780 164F           E8         E9C9            call	__memcpyb
05781 1652           83C4                   0A  add	sp,*$A
05782                                           !BCC_EOS
05783                                           ! 1482     description[32] = 0;
05784                                           ! Debug: eq int = const 0 to char description = [S+$28-5] (used reg = )
05785 1655           30C0                       xor	al,al
05786 1657           8846         FD            mov	-3[bp],al
05787                                           !BCC_EOS
05788                                           ! 1483     bios_printf(2, " [%S]", ss, description);
05789                                           ! Debug: list * char description = S+$28-$25 (used reg = )
05790 165A           8D5E         DD            lea	bx,-$23[bp]
05791 165D           53                         push	bx
05792                                           ! Debug: list unsigned short ss = [S+$2A-$28] (used reg = )
05793 165E           FF76         DA            push	-$26[bp]
05794                                           ! Debug: list * char = .146+0 (used reg = )
05795 1661           BB                   D8D1  mov	bx,#.146
05796 1664           53                         push	bx
05797                                           ! Debug: list int = const 2 (used reg = )
05798 1665           B8                   0002  mov	ax,*2
05799 1668           50                         push	ax
05800                                           ! Debug: func () void = bios_printf+0 (used reg = )
05801 1669           E8         F2D2            call	_bios_printf
05802 166C           83C4                   08  add	sp,*8
05803                                           !BCC_EOS
05804                                           ! 1484   }
05805                                           ! 1485   bios_printf(2, "...\n");
05806                       0000166F            .143:
05807                                           ! Debug: list * char = .147+0 (used reg = )
05808 166F           BB                   D8CC  mov	bx,#.147
05809 1672           53                         push	bx
05810                                           ! Debug: list int = const 2 (used reg = )
05811 1673           B8                   0002  mov	ax,*2
05812 1676           50                         push	ax
05813                                           ! Debug: func () void = bios_printf+0 (used reg = )
05814 1677           E8         F2C4            call	_bios_printf
05815 167A           83C4                   04  add	sp,*4
05816                                           !BCC_EOS
05817                                           ! 1486 }
05818 167D           89EC                       mov	sp,bp
05819 167F           5D                         pop	bp
05820 1680           C3                         ret
05821                                           ! 1487   void
05822                                           ! Register BX used in function print_boot_device
05823                                           ! 1488 print_boot_failure(type, reason)
05824                                           ! 1489   Bit16u type; Bit8u reason;
05825                                           export	_print_boot_failure
05826                       00001681            _print_boot_failure:
05827                                           !BCC_EOS
05828                                           !BCC_EOS
05829                                           ! 1490 {
05830                                           ! 1491   if (type == 0 || 
05831 1681           55                         push	bp
05832 1682           89E5                       mov	bp,sp
05833                                           ! 1491 type > 0x3) bios_printf((2 | 4 | 1), "Bad drive type\n");
05834                                           ! Debug: logeq int = const 0 to unsigned short type = [S+2+2] (used reg = )
05835 1684           8B46         04            mov	ax,4[bp]
05836 1687           85C0                       test	ax,ax
05837 1689           74           08            je  	.149
05838                       0000168B            .14A:
05839                                           ! Debug: gt int = const 3 to unsigned short type = [S+2+2] (used reg = )
05840 168B           8B46         04            mov	ax,4[bp]
05841 168E           3D                   0003  cmp	ax,*3
05842 1691           76           0D            jbe 	.148
05843                       00001693            .149:
05844                                           ! Debug: list * char = .14B+0 (used reg = )
05845 1693           BB                   D8BC  mov	bx,#.14B
05846 1696           53                         push	bx
05847                                           ! Debug: list int = const 7 (used reg = )
05848 1697           B8                   0007  mov	ax,*7
05849 169A           50                         push	ax
05850                                           ! Debug: func () void = bios_printf+0 (used reg = )
05851 169B           E8         F2A0            call	_bios_printf
05852 169E           89EC                       mov	sp,bp
05853                                           !BCC_EOS
05854                                           ! 1492   bios_printf(2, "Boot failed");
05855                       000016A0            .148:
05856                                           ! Debug: list * char = .14C+0 (used reg = )
05857 16A0           BB                   D8B0  mov	bx,#.14C
05858 16A3           53                         push	bx
05859                                           ! Debug: list int = const 2 (used reg = )
05860 16A4           B8                   0002  mov	ax,*2
05861 16A7           50                         push	ax
05862                                           ! Debug: func () void = bios_printf+0 (used reg = )
05863 16A8           E8         F293            call	_bios_printf
05864 16AB           89EC                       mov	sp,bp
05865                                           !BCC_EOS
05866                                           ! 1493   if (type < 4) {
05867                                           ! Debug: lt int = const 4 to unsigned short type = [S+2+2] (used reg = )
05868 16AD           8B46         04            mov	ax,4[bp]
05869 16B0           3D                   0004  cmp	ax,*4
05870 16B3           73           23            jae 	.14D
05871                       000016B5            .14E:
05872                                           ! 1494     if (reason==0)
05873                                           ! Debug: logeq int = const 0 to unsigned char reason = [S+2+4] (used reg = )
05874 16B5           8A46         06            mov	al,6[bp]
05875 16B8           84C0                       test	al,al
05876 16BA           75           0F            jne 	.14F
05877                       000016BC            .150:
05878                                           ! 1495       bios_printf(2, ": not a bootable disk");
05879                                           ! Debug: list * char = .151+0 (used reg = )
05880 16BC           BB                   D89A  mov	bx,#.151
05881 16BF           53                         push	bx
05882                                           ! Debug: list int = const 2 (used reg = )
05883 16C0           B8                   0002  mov	ax,*2
05884 16C3           50                         push	ax
05885                                           ! Debug: func () void = bios_printf+0 (used reg = )
05886 16C4           E8         F277            call	_bios_printf
05887 16C7           89EC                       mov	sp,bp
05888                                           !BCC_EOS
05889                                           ! 1496     else
05890                                           ! 1497       bios_printf(2, ": could not read the boot disk");
05891 16C9           EB           0D            jmp .152
05892                       000016CB            .14F:
05893                                           ! Debug: list * char = .153+0 (used reg = )
05894 16CB           BB                   D87B  mov	bx,#.153
05895 16CE           53                         push	bx
05896                                           ! Debug: list int = const 2 (used reg = )
05897 16CF           B8                   0002  mov	ax,*2
05898 16D2           50                         push	ax
05899                                           ! Debug: func () void = bios_printf+0 (used reg = )
05900 16D3           E8         F268            call	_bios_printf
05901 16D6           89EC                       mov	sp,bp
05902                                           !BCC_EOS
05903                                           ! 1498   }
05904                       000016D8            .152:
05905                                           ! 1499   bios_printf(2, "\n\n");
05906                       000016D8            .14D:
05907                                           ! Debug: list * char = .154+0 (used reg = )
05908 16D8           BB                   D878  mov	bx,#.154
05909 16DB           53                         push	bx
05910                                           ! Debug: list int = const 2 (used reg = )
05911 16DC           B8                   0002  mov	ax,*2
05912 16DF           50                         push	ax
05913                                           ! Debug: func () void = bios_printf+0 (used reg = )
05914 16E0           E8         F25B            call	_bios_printf
05915 16E3           89EC                       mov	sp,bp
05916                                           !BCC_EOS
05917                                           ! 1500 }
05918 16E5           5D                         pop	bp
05919 16E6           C3                         ret
05920                                           ! 1501   void
05921                                           ! Register BX used in function print_boot_failure
05922                                           ! 1502 print_cdromboot_failure( code )
05923                                           ! 1503   Bit16u code;
05924                                           export	_print_cdromboot_failure
05925                       000016E7            _print_cdromboot_failure:
05926                                           !BCC_EOS
05927                                           ! 1504 {
05928                                           ! 1505   bios_printf(2 | 4, "CDROM boot failure code : %04x\n",code);
05929 16E7           55                         push	bp
05930 16E8           89E5                       mov	bp,sp
05931                                           ! Debug: list unsigned short code = [S+2+2] (used reg = )
05932 16EA           FF76         04            push	4[bp]
05933                                           ! Debug: list * char = .155+0 (used reg = )
05934 16ED           BB                   D858  mov	bx,#.155
05935 16F0           53                         push	bx
05936                                           ! Debug: list int = const 6 (used reg = )
05937 16F1           B8                   0006  mov	ax,*6
05938 16F4           50                         push	ax
05939                                           ! Debug: func () void = bios_printf+0 (used reg = )
05940 16F5           E8         F246            call	_bios_printf
05941 16F8           89EC                       mov	sp,bp
05942                                           !BCC_EOS
05943                                           ! 1506   return;
05944 16FA           5D                         pop	bp
05945 16FB           C3                         ret
05946                                           !BCC_EOS
05947                                           ! 1507 }
05948                                           ! 1508 void
05949                                           ! Register BX used in function print_cdromboot_failure
05950                                           ! 1509 nmi_handler_msg()
05951                                           ! 1510 {
05952                                           export	_nmi_handler_msg
05953                       000016FC            _nmi_handler_msg:
05954                                           ! 1511   bios_printf((2 | 4 | 1), "NMI Handler called\n");
05955 16FC           55                         push	bp
05956 16FD           89E5                       mov	bp,sp
05957                                           ! Debug: list * char = .156+0 (used reg = )
05958 16FF           BB                   D844  mov	bx,#.156
05959 1702           53                         push	bx
05960                                           ! Debug: list int = const 7 (used reg = )
05961 1703           B8                   0007  mov	ax,*7
05962 1706           50                         push	ax
05963                                           ! Debug: func () void = bios_printf+0 (used reg = )
05964 1707           E8         F234            call	_bios_printf
05965 170A           89EC                       mov	sp,bp
05966                                           !BCC_EOS
05967                                           ! 1512 }
05968 170C           5D                         pop	bp
05969 170D           C3                         ret
05970                                           ! 1513 void
05971                                           ! Register BX used in function nmi_handler_msg
05972                                           ! 1514 int18_panic_msg()
05973                                           ! 1515 {
05974                                           export	_int18_panic_msg
05975                       0000170E            _int18_panic_msg:
05976                                           ! 1516   bios_printf((2 | 4 | 1), "INT18: BOOT FAILURE\n");
05977 170E           55                         push	bp
05978 170F           89E5                       mov	bp,sp
05979                                           ! Debug: list * char = .157+0 (used reg = )
05980 1711           BB                   D82F  mov	bx,#.157
05981 1714           53                         push	bx
05982                                           ! Debug: list int = const 7 (used reg = )
05983 1715           B8                   0007  mov	ax,*7
05984 1718           50                         push	ax
05985                                           ! Debug: func () void = bios_printf+0 (used reg = )
05986 1719           E8         F222            call	_bios_printf
05987 171C           89EC                       mov	sp,bp
05988                                           !BCC_EOS
05989                                           ! 1517 }
05990 171E           5D                         pop	bp
05991 171F           C3                         ret
05992                                           ! 1518 void
05993                                           ! Register BX used in function int18_panic_msg
05994                                           ! 1519 log_bios_start()
05995                                           ! 1520 {
05996                                           export	_log_bios_start
05997                       00001720            _log_bios_start:
05998                                           ! 1521   bios_printf(4, "%s\n", bios_svn_version_string);
05999 1720           55                         push	bp
06000 1721           89E5                       mov	bp,sp
06001                                           ! Debug: list * char = bios_svn_version_string+0 (used reg = )
06002 1723           BB                   016C  mov	bx,#_bios_svn_version_string
06003 1726           53                         push	bx
06004                                           ! Debug: list * char = .158+0 (used reg = )
06005 1727           BB                   D82B  mov	bx,#.158
06006 172A           53                         push	bx
06007                                           ! Debug: list int = const 4 (used reg = )
06008 172B           B8                   0004  mov	ax,*4
06009 172E           50                         push	ax
06010                                           ! Debug: func () void = bios_printf+0 (used reg = )
06011 172F           E8         F20C            call	_bios_printf
06012 1732           89EC                       mov	sp,bp
06013                                           !BCC_EOS
06014                                           ! 1522 }
06015 1734           5D                         pop	bp
06016 1735           C3                         ret
06017                                           ! 1523   bx_bool
06018                                           ! Register BX used in function log_bios_start
06019                                           ! 1524 set_enable_a20(val)
06020                                           ! 1525   bx_bool val;
06021                                           export	_set_enable_a20
06022                       00001736            _set_enable_a20:
06023                                           !BCC_EOS
06024                                           ! 1526 {
06025                                           ! 1527   Bit8u oldval;
06026                                           !BCC_EOS
06027                                           ! 1528   oldval = inb(0x0092);
06028 1736           55                         push	bp
06029 1737           89E5                       mov	bp,sp
06030 1739           4C                         dec	sp
06031 173A           4C                         dec	sp
06032                                           ! Debug: list int = const $92 (used reg = )
06033 173B           B8                   0092  mov	ax,#$92
06034 173E           50                         push	ax
06035                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06036 173F           E8         EDB6            call	_inb
06037 1742           44                         inc	sp
06038 1743           44                         inc	sp
06039                                           ! Debug: eq unsigned char = al+0 to unsigned char oldval = [S+4-3] (used reg = )
06040 1744           8846         FF            mov	-1[bp],al
06041                                           !BCC_EOS
06042                                           ! 1529   if (val)
06043 1747           8B46         04            mov	ax,4[bp]
06044 174A           85C0                       test	ax,ax
06045 174C           74           14            je  	.159
06046                       0000174E            .15A:
06047                                           ! 1530     outb(0x0092, oldval | 0x02);
06048                                           ! Debug: or int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
06049 174E           8A46         FF            mov	al,-1[bp]
06050 1751           0C                     02  or	al,*2
06051                                           ! Debug: list unsigned char = al+0 (used reg = )
06052 1753           30E4                       xor	ah,ah
06053 1755           50                         push	ax
06054                                           ! Debug: list int = const $92 (used reg = )
06055 1756           B8                   0092  mov	ax,#$92
06056 1759           50                         push	ax
06057                                           ! Debug: func () void = outb+0 (used reg = )
06058 175A           E8         EDB1            call	_outb
06059 175D           83C4                   04  add	sp,*4
06060                                           !BCC_EOS
06061                                           ! 1531   else
06062                                           ! 1532     outb(0x0092, oldval & 0xfd);
06063 1760           EB           12            jmp .15B
06064                       00001762            .159:
06065                                           ! Debug: and int = const $FD to unsigned char oldval = [S+4-3] (used reg = )
06066 1762           8A46         FF            mov	al,-1[bp]
06067 1765           24                     FD  and	al,#$FD
06068                                           ! Debug: list unsigned char = al+0 (used reg = )
06069 1767           30E4                       xor	ah,ah
06070 1769           50                         push	ax
06071                                           ! Debug: list int = const $92 (used reg = )
06072 176A           B8                   0092  mov	ax,#$92
06073 176D           50                         push	ax
06074                                           ! Debug: func () void = outb+0 (used reg = )
06075 176E           E8         ED9D            call	_outb
06076 1771           83C4                   04  add	sp,*4
06077                                           !BCC_EOS
06078                                           ! 1533   return((oldval & 0x02) != 0);
06079                       00001774            .15B:
06080                                           ! Debug: and int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
06081 1774           8A46         FF            mov	al,-1[bp]
06082 1777           24                     02  and	al,*2
06083                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
06084 1779           84C0                       test	al,al
06085 177B           74           04            je 	.15C
06086 177D           B0                     01  mov	al,*1
06087 177F           EB           02            jmp	.15D
06088                       00001781            .15C:
06089 1781           30C0                       xor	al,al
06090                       00001783            .15D:
06091                                           ! Debug: cast unsigned short = const 0 to char = al+0 (used reg = )
06092 1783           30E4                       xor	ah,ah
06093 1785           89EC                       mov	sp,bp
06094 1787           5D                         pop	bp
06095 1788           C3                         ret
06096                                           !BCC_EOS
06097                                           ! 1534 }
06098                                           ! 1535   void
06099                                           ! 1536 debugger_on()
06100                                           ! 1537 {
06101                                           export	_debugger_on
06102                       00001789            _debugger_on:
06103                                           ! 1538   outb(0xfedc, 0x01);
06104 1789           55                         push	bp
06105 178A           89E5                       mov	bp,sp
06106                                           ! Debug: list int = const 1 (used reg = )
06107 178C           B8                   0001  mov	ax,*1
06108 178F           50                         push	ax
06109                                           ! Debug: list unsigned int = const $FEDC (used reg = )
06110 1790           B8                   FEDC  mov	ax,#$FEDC
06111 1793           50                         push	ax
06112                                           ! Debug: func () void = outb+0 (used reg = )
06113 1794           E8         ED77            call	_outb
06114 1797           89EC                       mov	sp,bp
06115                                           !BCC_EOS
06116                                           ! 1539 }
06117 1799           5D                         pop	bp
06118 179A           C3                         ret
06119                                           ! 1540   void
06120                                           ! 1541 debugger_off()
06121                                           ! 1542 {
06122                                           export	_debugger_off
06123                       0000179B            _debugger_off:
06124                                           ! 1543   outb(0xfedc, 0x00);
06125 179B           55                         push	bp
06126 179C           89E5                       mov	bp,sp
06127                                           ! Debug: list int = const 0 (used reg = )
06128 179E           31C0                       xor	ax,ax
06129 17A0           50                         push	ax
06130                                           ! Debug: list unsigned int = const $FEDC (used reg = )
06131 17A1           B8                   FEDC  mov	ax,#$FEDC
06132 17A4           50                         push	ax
06133                                           ! Debug: func () void = outb+0 (used reg = )
06134 17A5           E8         ED66            call	_outb
06135 17A8           89EC                       mov	sp,bp
06136                                           !BCC_EOS
06137                                           ! 1544 }
06138 17AA           5D                         pop	bp
06139 17AB           C3                         ret
06140                                           ! 1545 int
06141                                           ! 1546 s3_resume()
06142                                           ! 1547 {
06143                                           export	_s3_resume
06144                       000017AC            _s3_resume:
06145                                           ! 1548     Bit32u s3_wakeup_vector;
06146                                           !BCC_EOS
06147                                           ! 1549     Bit8u s3_resume_flag;
06148                                           !BCC_EOS
06149                                           ! 1550     s3_resume_flag = *((Bit8u *)(0x04b0));
06150 17AC           55                         push	bp
06151 17AD           89E5                       mov	bp,sp
06152 17AF           83C4                   FA  add	sp,*-6
06153                                           ! Debug: eq unsigned char = [+$4B0] to unsigned char s3_resume_flag = [S+8-7] (used reg = )
06154 17B2           A0         04B0            mov	al,[$4B0]
06155 17B5           8846         FB            mov	-5[bp],al
06156                                           !BCC_EOS
06157                                           ! 1551     s3_wakeup_vector = *((Bit32u *)(0x04b2));
06158                                           ! Debug: eq unsigned long = [+$4B2] to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06159 17B8           A1         04B2            mov	ax,[$4B2]
06160 17BB           8B1E       04B4            mov	bx,[$4B4]
06161 17BF           8946         FC            mov	-4[bp],ax
06162 17C2           895E         FE            mov	-2[bp],bx
06163                                           !BCC_EOS
06164                                           ! 1552     bios_printf(4, "S3 resume called %x 0x%lx\n", s3_resume_flag, s3_wakeup_vector);
06165                                           ! Debug: list unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06166 17C5           FF76         FE            push	-2[bp]
06167 17C8           FF76         FC            push	-4[bp]
06168                                           ! Debug: list unsigned char s3_resume_flag = [S+$C-7] (used reg = )
06169 17CB           8A46         FB            mov	al,-5[bp]
06170 17CE           30E4                       xor	ah,ah
06171 17D0           50                         push	ax
06172                                           ! Debug: list * char = .15E+0 (used reg = )
06173 17D1           BB                   D810  mov	bx,#.15E
06174 17D4           53                         push	bx
06175                                           ! Debug: list int = const 4 (used reg = )
06176 17D5           B8                   0004  mov	ax,*4
06177 17D8           50                         push	ax
06178                                           ! Debug: func () void = bios_printf+0 (used reg = )
06179 17D9           E8         F162            call	_bios_printf
06180 17DC           83C4                   0A  add	sp,*$A
06181                                           !BCC_EOS
06182                                           ! 1553     if (s3_resume_flag != 0xFE || !s3_wakeup_vector)
06183                                           ! Debug: ne int = const $FE to unsigned char s3_resume_flag = [S+8-7] (used reg = )
06184 17DF           8A46         FB            mov	al,-5[bp]
06185 17E2           3C                     FE  cmp	al,#$FE
06186 17E4           75           0B            jne 	.160
06187                       000017E6            .161:
06188 17E6           8B46         FC            mov	ax,-4[bp]
06189 17E9           8B5E         FE            mov	bx,-2[bp]
06190 17EC           E8         E8F6            call	ltstl
06191 17EF           75           06            jne 	.15F
06192                       000017F1            .160:
06193                                           ! 1554      return 0;
06194 17F1           31C0                       xor	ax,ax
06195 17F3           89EC                       mov	sp,bp
06196 17F5           5D                         pop	bp
06197 17F6           C3                         ret
06198                                           !BCC_EOS
06199                                           ! 1555     *((Bit8u *)(0x04b0)) = (0);
06200                       000017F7            .15F:
06201                                           ! Debug: eq int = const 0 to unsigned char = [+$4B0] (used reg = )
06202 17F7           30C0                       xor	al,al
06203 17F9           A2         04B0            mov	[$4B0],al
06204                                           !BCC_EOS
06205                                           ! 1556     *((Bit16u *)(0x04b6)) = ((s3_wakeup_vector & 0xF));
06206                                           ! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06207                                           ! Debug: expression subtree swapping
06208 17FC           B8                   000F  mov	ax,*$F
06209 17FF           31DB                       xor	bx,bx
06210 1801           8D7E         FC            lea	di,-4[bp]
06211 1804           E8         E885            call	landul
06212                                           ! Debug: eq unsigned long = bx+0 to unsigned short = [+$4B6] (used reg = )
06213 1807           A3         04B6            mov	[$4B6],ax
06214                                           !BCC_EOS
06215                                           ! 1557     *((Bit16u *)(0x04b8)) = ((s3_wakeup_vector >> 4));
06216                                           ! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06217 180A           8B46         FC            mov	ax,-4[bp]
06218 180D           8B5E         FE            mov	bx,-2[bp]
06219 1810           BF                   0004  mov	di,*4
06220 1813           E8         E8E4            call	lsrul
06221                                           ! Debug: eq unsigned long = bx+0 to unsigned short = [+$4B8] (used reg = )
06222 1816           A3         04B8            mov	[$4B8],ax
06223                                           !BCC_EOS
06224                                           ! 1558     bios_printf(4, "S3 resume jump to %x:%x\n", (s3_wakeup_vector >> 4), (s3_wakeup_vector & 0xF));
06225                                           ! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06226                                           ! Debug: expression subtree swapping
06227 1819           B8                   000F  mov	ax,*$F
06228 181C           31DB                       xor	bx,bx
06229 181E           8D7E         FC            lea	di,-4[bp]
06230 1821           E8         E868            call	landul
06231                                           ! Debug: list unsigned long = bx+0 (used reg = )
06232 1824           53                         push	bx
06233 1825           50                         push	ax
06234                                           ! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+$C-6] (used reg = )
06235 1826           8B46         FC            mov	ax,-4[bp]
06236 1829           8B5E         FE            mov	bx,-2[bp]
06237 182C           BF                   0004  mov	di,*4
06238 182F           E8         E8C8            call	lsrul
06239                                           ! Debug: list unsigned long = bx+0 (used reg = )
06240 1832           53                         push	bx
06241 1833           50                         push	ax
06242                                           ! Debug: list * char = .162+0 (used reg = )
06243 1834           BB                   D7F7  mov	bx,#.162
06244 1837           53                         push	bx
06245                                           ! Debug: list int = const 4 (used reg = )
06246 1838           B8                   0004  mov	ax,*4
06247 183B           50                         push	ax
06248                                           ! Debug: func () void = bios_printf+0 (used reg = )
06249 183C           E8         F0FF            call	_bios_printf
06250 183F           83C4                   0C  add	sp,*$C
06251                                           !BCC_EOS
06252                                           ! 1559 #asm
06253                                           !BCC_EOS
06254                                           !BCC_ASM
06255                       00000001            _s3_resume.s3_resume_flag	set	1
06256                       FFFFFFFB            .s3_resume.s3_resume_flag	set	-5
06257                       00000002            _s3_resume.s3_wakeup_vector	set	2
06258                       FFFFFFFC            .s3_resume.s3_wakeup_vector	set	-4
06259 1842           FF2E       04B6                jmpf [0x04b6]
06260                                           ! 1561 endasm
06261                                           !BCC_ENDASM
06262                                           !BCC_EOS
06263                                           ! 1562     return 1;
06264 1846           B8                   0001  mov	ax,*1
06265 1849           89EC                       mov	sp,bp
06266 184B           5D                         pop	bp
06267 184C           C3                         ret
06268                                           !BCC_EOS
06269                                           ! 1563 }
06270                                           ! 1564 void ata_init( )
06271                                           ! Register BX used in function s3_resume
06272                                           ! 1565 {
06273                                           export	_ata_init
06274                       0000184D            _ata_init:
06275                                           ! 1566   Bit8u channel, device;
06276                                           !BCC_EOS
06277                                           ! 1567   Bit16u old_ds = set_DS(get_ebda_seg());
06278 184D           55                         push	bp
06279 184E           89E5                       mov	bp,sp
06280 1850           83C4                   FC  add	sp,*-4
06281                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
06282 1853           E8         EE16            call	_get_ebda_seg
06283                                           ! Debug: list unsigned short = ax+0 (used reg = )
06284 1856           50                         push	ax
06285                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
06286 1857           E8         EE08            call	_set_DS
06287 185A           44                         inc	sp
06288 185B           44                         inc	sp
06289                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+6-6] (used reg = )
06290 185C           8946         FC            mov	-4[bp],ax
06291                                           !BCC_EOS
06292                                           ! 1568   for (channel=0; channel<4; channel++) {
06293                                           ! Debug: eq int = const 0 to unsigned char channel = [S+6-3] (used reg = )
06294 185F           30C0                       xor	al,al
06295 1861           8846         FF            mov	-1[bp],al
06296                                           !BCC_EOS
06297                                           !BCC_EOS
06298 1864           EB           4B            jmp .165
06299                       00001866            .166:
06300                                           ! 1569     *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[channel].iface)) = (0x00);
06301                                           ! Debug: ptradd unsigned char channel = [S+6-3] to [4] struct  = const $122 (used reg = )
06302 1866           8A46         FF            mov	al,-1[bp]
06303 1869           30E4                       xor	ah,ah
06304 186B           B1                     03  mov	cl,*3
06305 186D           D3E0                       shl	ax,cl
06306 186F           89C3                       mov	bx,ax
06307                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
06308                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$122 (used reg = )
06309                                           ! Debug: eq int = const 0 to unsigned char = [bx+$122] (used reg = )
06310 1871           30C0                       xor	al,al
06311 1873           8887       0122            mov	$122[bx],al
06312                                           !BCC_EOS
06313                                           ! 1570     *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1)) = (0x0);
06314                                           ! Debug: ptradd unsigned char channel = [S+6-3] to [4] struct  = const $122 (used reg = )
06315 1877           8A46         FF            mov	al,-1[bp]
06316 187A           30E4                       xor	ah,ah
06317 187C           B1                     03  mov	cl,*3
06318 187E           D3E0                       shl	ax,cl
06319 1880           89C3                       mov	bx,ax
06320                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
06321                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
06322                                           ! Debug: eq int = const 0 to unsigned short = [bx+$124] (used reg = )
06323 1882           31C0                       xor	ax,ax
06324 1884           8987       0124            mov	$124[bx],ax
06325                                           !BCC_EOS
06326                                           ! 1571     *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2)) = (0x0);
06327                                           ! Debug: ptradd unsigned char channel = [S+6-3] to [4] struct  = const $122 (used reg = )
06328 1888           8A46         FF            mov	al,-1[bp]
06329 188B           30E4                       xor	ah,ah
06330 188D           B1                     03  mov	cl,*3
06331 188F           D3E0                       shl	ax,cl
06332 1891           89C3                       mov	bx,ax
06333                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
06334                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
06335                                           ! Debug: eq int = const 0 to unsigned short = [bx+$126] (used reg = )
06336 1893           31C0                       xor	ax,ax
06337 1895           8987       0126            mov	$126[bx],ax
06338                                           !BCC_EOS
06339                                           ! 1572     *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[channel].irq)) = (0);
06340                                           ! Debug: ptradd unsigned char channel = [S+6-3] to [4] struct  = const $122 (used reg = )
06341 1899           8A46         FF            mov	al,-1[bp]
06342 189C           30E4                       xor	ah,ah
06343 189E           B1                     03  mov	cl,*3
06344 18A0           D3E0                       shl	ax,cl
06345 18A2           89C3                       mov	bx,ax
06346                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
06347                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$128 (used reg = )
06348                                           ! Debug: eq int = const 0 to unsigned char = [bx+$128] (used reg = )
06349 18A4           30C0                       xor	al,al
06350 18A6           8887       0128            mov	$128[bx],al
06351                                           !BCC_EOS
06352                                           ! 1573   }
06353                                           ! 1574   for (device=0; device<(4*2); device++) {
06354                       000018AA            .164:
06355                                           ! Debug: postinc unsigned char channel = [S+6-3] (used reg = )
06356 18AA           8A46         FF            mov	al,-1[bp]
06357 18AD           40                         inc	ax
06358 18AE           8846         FF            mov	-1[bp],al
06359                       000018B1            .165:
06360                                           ! Debug: lt int = const 4 to unsigned char channel = [S+6-3] (used reg = )
06361 18B1           8A46         FF            mov	al,-1[bp]
06362 18B4           3C                     04  cmp	al,*4
06363 18B6           72           AE            jb 	.166
06364                       000018B8            .167:
06365                       000018B8            .163:
06366                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-4] (used reg = )
06367 18B8           30C0                       xor	al,al
06368 18BA           8846         FE            mov	-2[bp],al
06369                                           !BCC_EOS
06370                                           !BCC_EOS
06371 18BD           E9         0121            br 	.16A
06372                       000018C0            .16B:
06373                                           ! 1575     *((Bit8u *)(&(
06374                                           ! 1575 (ebda_data_t *) 0)->ata.devices[device].type)) = (0x00);
06375                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06376 18C0           8A46         FE            mov	al,-2[bp]
06377 18C3           30E4                       xor	ah,ah
06378 18C5           B9                   001E  mov	cx,*$1E
06379 18C8           F7E9                       imul	cx
06380 18CA           89C3                       mov	bx,ax
06381                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
06382                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
06383                                           ! Debug: eq int = const 0 to unsigned char = [bx+$142] (used reg = )
06384 18CC           30C0                       xor	al,al
06385 18CE           8887       0142            mov	$142[bx],al
06386                                           !BCC_EOS
06387                                           ! 1576     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device)) = (0x00);
06388                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06389 18D2           8A46         FE            mov	al,-2[bp]
06390 18D5           30E4                       xor	ah,ah
06391 18D7           B9                   001E  mov	cx,*$1E
06392 18DA           F7E9                       imul	cx
06393 18DC           89C3                       mov	bx,ax
06394                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
06395                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
06396                                           ! Debug: eq int = const 0 to unsigned char = [bx+$143] (used reg = )
06397 18DE           30C0                       xor	al,al
06398 18E0           8887       0143            mov	$143[bx],al
06399                                           !BCC_EOS
06400                                           ! 1577     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].removable)) = (0);
06401                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06402 18E4           8A46         FE            mov	al,-2[bp]
06403 18E7           30E4                       xor	ah,ah
06404 18E9           B9                   001E  mov	cx,*$1E
06405 18EC           F7E9                       imul	cx
06406 18EE           89C3                       mov	bx,ax
06407                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
06408                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$144 (used reg = )
06409                                           ! Debug: eq int = const 0 to unsigned char = [bx+$144] (used reg = )
06410 18F0           30C0                       xor	al,al
06411 18F2           8887       0144            mov	$144[bx],al
06412                                           !BCC_EOS
06413                                           ! 1578     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].lock)) = (0);
06414                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06415 18F6           8A46         FE            mov	al,-2[bp]
06416 18F9           30E4                       xor	ah,ah
06417 18FB           B9                   001E  mov	cx,*$1E
06418 18FE           F7E9                       imul	cx
06419 1900           89C3                       mov	bx,ax
06420                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
06421                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$145 (used reg = )
06422                                           ! Debug: eq int = const 0 to unsigned char = [bx+$145] (used reg = )
06423 1902           30C0                       xor	al,al
06424 1904           8887       0145            mov	$145[bx],al
06425                                           !BCC_EOS
06426                                           ! 1579     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode)) = (0x00);
06427                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06428 1908           8A46         FE            mov	al,-2[bp]
06429 190B           30E4                       xor	ah,ah
06430 190D           B9                   001E  mov	cx,*$1E
06431 1910           F7E9                       imul	cx
06432 1912           89C3                       mov	bx,ax
06433                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
06434                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
06435                                           ! Debug: eq int = const 0 to unsigned char = [bx+$146] (used reg = )
06436 1914           30C0                       xor	al,al
06437 1916           8887       0146            mov	$146[bx],al
06438                                           !BCC_EOS
06439                                           ! 1580     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].blksize)) = (0);
06440                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06441 191A           8A46         FE            mov	al,-2[bp]
06442 191D           30E4                       xor	ah,ah
06443 191F           B9                   001E  mov	cx,*$1E
06444 1922           F7E9                       imul	cx
06445 1924           89C3                       mov	bx,ax
06446                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
06447                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$148 (used reg = )
06448                                           ! Debug: eq int = const 0 to unsigned short = [bx+$148] (used reg = )
06449 1926           31C0                       xor	ax,ax
06450 1928           8987       0148            mov	$148[bx],ax
06451                                           !BCC_EOS
06452                                           ! 1581     *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].translation)) = (0);
06453                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06454 192C           8A46         FE            mov	al,-2[bp]
06455 192F           30E4                       xor	ah,ah
06456 1931           B9                   001E  mov	cx,*$1E
06457 1934           F7E9                       imul	cx
06458 1936           89C3                       mov	bx,ax
06459                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
06460                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$14A (used reg = )
06461                                           ! Debug: eq int = const 0 to unsigned char = [bx+$14A] (used reg = )
06462 1938           30C0                       xor	al,al
06463 193A           8887       014A            mov	$14A[bx],al
06464                                           !BCC_EOS
06465                                           ! 1582     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.heads)) = (0);
06466                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06467 193E           8A46         FE            mov	al,-2[bp]
06468 1941           30E4                       xor	ah,ah
06469 1943           B9                   001E  mov	cx,*$1E
06470 1946           F7E9                       imul	cx
06471 1948           89C3                       mov	bx,ax
06472                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
06473                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14C (used reg = )
06474                                           ! Debug: eq int = const 0 to unsigned short = [bx+$14C] (used reg = )
06475 194A           31C0                       xor	ax,ax
06476 194C           8987       014C            mov	$14C[bx],ax
06477                                           !BCC_EOS
06478                                           ! 1583     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders)) = (0);
06479                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06480 1950           8A46         FE            mov	al,-2[bp]
06481 1953           30E4                       xor	ah,ah
06482 1955           B9                   001E  mov	cx,*$1E
06483 1958           F7E9                       imul	cx
06484 195A           89C3                       mov	bx,ax
06485                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
06486                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14E (used reg = )
06487                                           ! Debug: eq int = const 0 to unsigned short = [bx+$14E] (used reg = )
06488 195C           31C0                       xor	ax,ax
06489 195E           8987       014E            mov	$14E[bx],ax
06490                                           !BCC_EOS
06491                                           ! 1584     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.spt)) = (0);
06492                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06493 1962           8A46         FE            mov	al,-2[bp]
06494 1965           30E4                       xor	ah,ah
06495 1967           B9                   001E  mov	cx,*$1E
06496 196A           F7E9                       imul	cx
06497 196C           89C3                       mov	bx,ax
06498                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
06499                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$150 (used reg = )
06500                                           ! Debug: eq int = const 0 to unsigned short = [bx+$150] (used reg = )
06501 196E           31C0                       xor	ax,ax
06502 1970           8987       0150            mov	$150[bx],ax
06503                                           !BCC_EOS
06504                                           ! 1585     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.heads)) = (0);
06505                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06506 1974           8A46         FE            mov	al,-2[bp]
06507 1977           30E4                       xor	ah,ah
06508 1979           B9                   001E  mov	cx,*$1E
06509 197C           F7E9                       imul	cx
06510 197E           89C3                       mov	bx,ax
06511                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
06512                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$152 (used reg = )
06513                                           ! Debug: eq int = const 0 to unsigned short = [bx+$152] (used reg = )
06514 1980           31C0                       xor	ax,ax
06515 1982           8987       0152            mov	$152[bx],ax
06516                                           !BCC_EOS
06517                                           ! 1586     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders)) = (0);
06518                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06519 1986           8A46         FE            mov	al,-2[bp]
06520 1989           30E4                       xor	ah,ah
06521 198B           B9                   001E  mov	cx,*$1E
06522 198E           F7E9                       imul	cx
06523 1990           89C3                       mov	bx,ax
06524                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
06525                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$154 (used reg = )
06526                                           ! Debug: eq int = const 0 to unsigned short = [bx+$154] (used reg = )
06527 1992           31C0                       xor	ax,ax
06528 1994           8987       0154            mov	$154[bx],ax
06529                                           !BCC_EOS
06530                                           ! 1587     *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.spt)) = (0);
06531                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06532 1998           8A46         FE            mov	al,-2[bp]
06533 199B           30E4                       xor	ah,ah
06534 199D           B9                   001E  mov	cx,*$1E
06535 19A0           F7E9                       imul	cx
06536 19A2           89C3                       mov	bx,ax
06537                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
06538                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$156 (used reg = )
06539                                           ! Debug: eq int = const 0 to unsigned short = [bx+$156] (used reg = )
06540 19A4           31C0                       xor	ax,ax
06541 19A6           8987       0156            mov	$156[bx],ax
06542                                           !BCC_EOS
06543                                           ! 1588     *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_low)) = (0L);
06544                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06545 19AA           8A46         FE            mov	al,-2[bp]
06546 19AD           30E4                       xor	ah,ah
06547 19AF           B9                   001E  mov	cx,*$1E
06548 19B2           F7E9                       imul	cx
06549 19B4           89C3                       mov	bx,ax
06550                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
06551                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$158 (used reg = )
06552                                           ! Debug: eq long = const 0 to unsigned long = [bx+$158] (used reg = )
06553 19B6           31C0                       xor	ax,ax
06554 19B8           31F6                       xor	si,si
06555 19BA           8987       0158            mov	$158[bx],ax
06556 19BE           89B7       015A            mov	$15A[bx],si
06557                                           !BCC_EOS
06558                                           ! 1589     *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high)) = (0L);
06559                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] struct  = const $142 (used reg = )
06560 19C2           8A46         FE            mov	al,-2[bp]
06561 19C5           30E4                       xor	ah,ah
06562 19C7           B9                   001E  mov	cx,*$1E
06563 19CA           F7E9                       imul	cx
06564 19CC           89C3                       mov	bx,ax
06565                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
06566                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
06567                                           ! Debug: eq long = const 0 to unsigned long = [bx+$15C] (used reg = )
06568 19CE           31C0                       xor	ax,ax
06569 19D0           31F6                       xor	si,si
06570 19D2           8987       015C            mov	$15C[bx],ax
06571 19D6           89B7       015E            mov	$15E[bx],si
06572                                           !BCC_EOS
06573                                           ! 1590   }
06574                                           ! 1591   for (device=0; device<(4*2); device++) {
06575                       000019DA            .169:
06576                                           ! Debug: postinc unsigned char device = [S+6-4] (used reg = )
06577 19DA           8A46         FE            mov	al,-2[bp]
06578 19DD           40                         inc	ax
06579 19DE           8846         FE            mov	-2[bp],al
06580                       000019E1            .16A:
06581                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-4] (used reg = )
06582 19E1           8A46         FE            mov	al,-2[bp]
06583 19E4           3C                     08  cmp	al,*8
06584 19E6         0F82         FED6            blo 	.16B
06585                       000019EA            .16C:
06586                       000019EA            .168:
06587                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-4] (used reg = )
06588 19EA           30C0                       xor	al,al
06589 19EC           8846         FE            mov	-2[bp],al
06590                                           !BCC_EOS
06591                                           !BCC_EOS
06592 19EF           EB           21            jmp .16F
06593                       000019F1            .170:
06594                                           ! 1592     *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdidmap[device])) = ((4*2));
06595                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] unsigned char = const $233 (used reg = )
06596 19F1           8A46         FE            mov	al,-2[bp]
06597 19F4           30E4                       xor	ah,ah
06598 19F6           89C3                       mov	bx,ax
06599                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
06600                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$233 (used reg = )
06601                                           ! Debug: eq int = const 8 to unsigned char = [bx+$233] (used reg = )
06602 19F8           B0                     08  mov	al,*8
06603 19FA           8887       0233            mov	$233[bx],al
06604                                           !BCC_EOS
06605                                           ! 1593     *((Bit8u *)(&((ebda_data_t *) 0)->ata.cdidmap[device])) = ((4*2));
06606                                           ! Debug: ptradd unsigned char device = [S+6-4] to [8] unsigned char = const $23C (used reg = )
06607 19FE           8A46         FE            mov	al,-2[bp]
06608 1A01           30E4                       xor	ah,ah
06609 1A03           89C3                       mov	bx,ax
06610                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
06611                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$23C (used reg = )
06612                                           ! Debug: eq int = const 8 to unsigned char = [bx+$23C] (used reg = )
06613 1A05           B0                     08  mov	al,*8
06614 1A07           8887       023C            mov	$23C[bx],al
06615                                           !BCC_EOS
06616                                           ! 1594   }
06617                                           ! 1595   *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdcount)) = (0);
06618                       00001A0B            .16E:
06619                                           ! Debug: postinc unsigned char device = [S+6-4] (used reg = )
06620 1A0B           8A46         FE            mov	al,-2[bp]
06621 1A0E           40                         inc	ax
06622 1A0F           8846         FE            mov	-2[bp],al
06623                       00001A12            .16F:
06624                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-4] (used reg = )
06625 1A12           8A46         FE            mov	al,-2[bp]
06626 1A15           3C                     08  cmp	al,*8
06627 1A17           72           D8            jb 	.170
06628                       00001A19            .171:
06629                       00001A19            .16D:
06630                                           ! Debug: eq int = const 0 to unsigned char = [+$232] (used reg = )
06631 1A19           30C0                       xor	al,al
06632 1A1B           A2         0232            mov	[$232],al
06633                                           !BCC_EOS
06634                                           ! 1596   *((Bit8u *)(&((ebda_data_t *) 0)->ata.cdcount)) = (0);
06635                                           ! Debug: eq int = const 0 to unsigned char = [+$23B] (used reg = )
06636 1A1E           30C0                       xor	al,al
06637 1A20           A2         023B            mov	[$23B],al
06638                                           !BCC_EOS
06639                                           ! 1597   set_DS(old_ds);
06640                                           ! Debug: list unsigned short old_ds = [S+6-6] (used reg = )
06641 1A23           FF76         FC            push	-4[bp]
06642                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
06643 1A26           E8         EC39            call	_set_DS
06644 1A29           44                         inc	sp
06645 1A2A           44                         inc	sp
06646                                           !BCC_EOS
06647                                           ! 1598 }
06648 1A2B           89EC                       mov	sp,bp
06649 1A2D           5D                         pop	bp
06650 1A2E           C3                         ret
06651                                           ! 1599 int await_ide();
06652                                           ! Register BX used in function ata_init
06653                                           !BCC_EOS
06654                                           ! 1600 static int await_ide(when_done,base,timeout)
06655                                           ! 1601   Bit8u when_done;
06656                       00001A2F            _await_ide:
06657                                           !BCC_EOS
06658                                           ! 1602   Bit16u base;
06659                                           !BCC_EOS
06660                                           ! 1603   Bit16u timeout;
06661                                           !BCC_EOS
06662                                           ! 1604 {
06663                                           ! 1605   Bit32u time=0;
06664 1A2F           55                         push	bp
06665 1A30           89E5                       mov	bp,sp
06666 1A32           83C4                   FC  add	sp,*-4
06667                                           ! Debug: eq int = const 0 to unsigned long time = [S+6-6] (used reg = )
06668 1A35           31C0                       xor	ax,ax
06669 1A37           31DB                       xor	bx,bx
06670 1A39           8946         FC            mov	-4[bp],ax
06671 1A3C           895E         FE            mov	-2[bp],bx
06672                                           !BCC_EOS
06673                                           ! 1606   Bit16u status,last=0;
06674 1A3F           83C4                   FC  add	sp,*-4
06675                                           ! Debug: eq int = const 0 to unsigned short last = [S+$A-$A] (used reg = )
06676 1A42           31C0                       xor	ax,ax
06677 1A44           8946         F8            mov	-8[bp],ax
06678                                           !BCC_EOS
06679                                           ! 1607   Bit8u result;
06680                                           !BCC_EOS
06681                                           ! 1608   status = inb(base + 7);
06682 1A47           4C                         dec	sp
06683 1A48           4C                         dec	sp
06684                                           ! Debug: add int = const 7 to unsigned short base = [S+$C+4] (used reg = )
06685 1A49           8B46         06            mov	ax,6[bp]
06686                                           ! Debug: list unsigned int = ax+7 (used reg = )
06687 1A4C           05                   0007  add	ax,*7
06688 1A4F           50                         push	ax
06689                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06690 1A50           E8         EAA5            call	_inb
06691 1A53           44                         inc	sp
06692 1A54           44                         inc	sp
06693                                           ! Debug: eq unsigned char = al+0 to unsigned short status = [S+$C-8] (used reg = )
06694 1A55           30E4                       xor	ah,ah
06695 1A57           8946         FA            mov	-6[bp],ax
06696                                           !BCC_EOS
06697                                           ! 1609   for(;;) {
06698                                           !BCC_EOS
06699                                           !BCC_EOS
06700                       00001A5A            .174:
06701                                           ! 1610     status = inb(base+7);
06702                                           ! Debug: add int = const 7 to unsigned short base = [S+$C+4] (used reg = )
06703 1A5A           8B46         06            mov	ax,6[bp]
06704                                           ! Debug: list unsigned int = ax+7 (used reg = )
06705 1A5D           05                   0007  add	ax,*7
06706 1A60           50                         push	ax
06707                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06708 1A61           E8         EA94            call	_inb
06709 1A64           44                         inc	sp
06710 1A65           44                         inc	sp
06711                                           ! Debug: eq unsigned char = al+0 to unsigned short status = [S+$C-8] (used reg = )
06712 1A66           30E4                       xor	ah,ah
06713 1A68           8946         FA            mov	-6[bp],ax
06714                                           !BCC_EOS
06715                                           ! 1611     time++;
06716                                           ! Debug: postinc unsigned long time = [S+$C-6] (used reg = )
06717 1A6B           8B46         FC            mov	ax,-4[bp]
06718 1A6E           8B76         FE            mov	si,-2[bp]
06719 1A71           8D5E         FC            lea	bx,-4[bp]
06720 1A74           E8         E669            call	lincl
06721                                           !BCC_EOS
06722                                           ! 1612     if (when_done == 1)
06723                                           ! Debug: logeq int = const 1 to unsigned char when_done = [S+$C+2] (used reg = )
06724 1A77           8A46         04            mov	al,4[bp]
06725 1A7A           3C                     01  cmp	al,*1
06726 1A7C           75           0B            jne 	.175
06727                       00001A7E            .176:
06728                                           ! 1613       result = status & 0x80;
06729                                           ! Debug: and int = const $80 to unsigned short status = [S+$C-8] (used reg = )
06730 1A7E           8A46         FA            mov	al,-6[bp]
06731 1A81           24                     80  and	al,#$80
06732                                           ! Debug: eq unsigned char = al+0 to unsigned char result = [S+$C-$B] (used reg = )
06733 1A83           8846         F7            mov	-9[bp],al
06734                                           !BCC_EOS
06735                                           ! 1614     else if (when_done == 2)
06736 1A86           E9         0094            br 	.177
06737                       00001A89            .175:
06738                                           ! Debug: logeq int = const 2 to unsigned char when_done = [S+$C+2] (used reg = )
06739 1A89           8A46         04            mov	al,4[bp]
06740 1A8C           3C                     02  cmp	al,*2
06741 1A8E           75           15            jne 	.178
06742                       00001A90            .179:
06743                                           ! 1615       result = !(status & 0x80);
06744                                           ! Debug: and int = const $80 to unsigned short status = [S+$C-8] (used reg = )
06745 1A90           8A46         FA            mov	al,-6[bp]
06746 1A93           24                     80  and	al,#$80
06747 1A95           84C0                       test	al,al
06748 1A97           75           04            jne 	.17A
06749                       00001A99            .17B:
06750 1A99           B0                     01  mov	al,*1
06751 1A9B           EB           02            jmp	.17C
06752                       00001A9D            .17A:
06753 1A9D           30C0                       xor	al,al
06754                       00001A9F            .17C:
06755                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$B] (used reg = )
06756 1A9F           8846         F7            mov	-9[bp],al
06757                                           !BCC_EOS
06758                                           ! 1616     else if (when_done == 3)
06759 1AA2           E9         0078            br 	.17D
06760                       00001AA5            .178:
06761                                           ! Debug: logeq int = const 3 to unsigned char when_done = [S+$C+2] (used reg = )
06762 1AA5           8A46         04            mov	al,4[bp]
06763 1AA8           3C                     03  cmp	al,*3
06764 1AAA           75           1D            jne 	.17E
06765                       00001AAC            .17F:
06766                                           ! 1617       result = !(status & 0x80) && (status & 0x08);
06767                                           ! Debug: and int = const $80 to unsigned short status = [S+$C-8] (used reg = )
06768 1AAC           8A46         FA            mov	al,-6[bp]
06769 1AAF           24                     80  and	al,#$80
06770 1AB1           84C0                       test	al,al
06771 1AB3           75           0D            jne 	.180
06772                       00001AB5            .182:
06773                                           ! Debug: and int = const 8 to unsigned short status = [S+$C-8] (used reg = )
06774 1AB5           8A46         FA            mov	al,-6[bp]
06775 1AB8           24                     08  and	al,*8
06776 1ABA           84C0                       test	al,al
06777 1ABC           74           04            je  	.180
06778                       00001ABE            .181:
06779 1ABE           B0                     01  mov	al,*1
06780 1AC0           EB           02            jmp	.183
06781                       00001AC2            .180:
06782 1AC2           30C0                       xor	al,al
06783                       00001AC4            .183:
06784                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$B] (used reg = )
06785 1AC4           8846         F7            mov	-9[bp],al
06786                                           !BCC_EOS
06787                                           ! 1618     else if (when_done == 4)
06788 1AC7           EB           54            jmp .184
06789                       00001AC9            .17E:
06790                                           ! Debug: logeq int = const 4 to unsigned char when_done = [S+$C+2] (used reg = )
06791 1AC9           8A46         04            mov	al,4[bp]
06792 1ACC           3C                     04  cmp	al,*4
06793 1ACE           75           1D            jne 	.185
06794                       00001AD0            .186:
06795                                           ! 1619       result = !(status & 0x80) && !(status & 0x08);
06796                                           ! Debug: and int = const $80 to unsigned short status = [S+$C-8] (used reg = )
06797 1AD0           8A46         FA            mov	al,-6[bp]
06798 1AD3           24                     80  and	al,#$80
06799 1AD5           84C0                       test	al,al
06800 1AD7           75           0D            jne 	.187
06801                       00001AD9            .189:
06802                                           ! Debug: and int = const 8 to unsigned short status = [S+$C-8] (used reg = )
06803 1AD9           8A46         FA            mov	al,-6[bp]
06804 1ADC           24                     08  and	al,*8
06805 1ADE           84C0                       test	al,al
06806 1AE0           75           04            jne 	.187
06807                       00001AE2            .188:
06808 1AE2           B0                     01  mov	al,*1
06809 1AE4           EB           02            jmp	.18A
06810                       00001AE6            .187:
06811 1AE6           30C0                       xor	al,al
06812                       00001AE8            .18A:
06813                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$B] (used reg = )
06814 1AE8           8846         F7            mov	-9[bp],al
06815                                           !BCC_EOS
06816                                           ! 1620     else if (when_done == 5)
06817 1AEB           EB           30            jmp .18B
06818                       00001AED            .185:
06819                                           ! Debug: logeq int = const 5 to unsigned char when_done = [S+$C+2] (used reg = )
06820 1AED           8A46         04            mov	al,4[bp]
06821 1AF0           3C                     05  cmp	al,*5
06822 1AF2           75           1D            jne 	.18C
06823                       00001AF4            .18D:
06824                                           ! 1621       resu
06825                                           ! 1621 lt = !(status & 0x80) && (status & 0x40);
06826                                           ! Debug: and int = const $80 to unsigned short status = [S+$C-8] (used reg = )
06827 1AF4           8A46         FA            mov	al,-6[bp]
06828 1AF7           24                     80  and	al,#$80
06829 1AF9           84C0                       test	al,al
06830 1AFB           75           0D            jne 	.18E
06831                       00001AFD            .190:
06832                                           ! Debug: and int = const $40 to unsigned short status = [S+$C-8] (used reg = )
06833 1AFD           8A46         FA            mov	al,-6[bp]
06834 1B00           24                     40  and	al,*$40
06835 1B02           84C0                       test	al,al
06836 1B04           74           04            je  	.18E
06837                       00001B06            .18F:
06838 1B06           B0                     01  mov	al,*1
06839 1B08           EB           02            jmp	.191
06840                       00001B0A            .18E:
06841 1B0A           30C0                       xor	al,al
06842                       00001B0C            .191:
06843                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$B] (used reg = )
06844 1B0C           8846         F7            mov	-9[bp],al
06845                                           !BCC_EOS
06846                                           ! 1622     else if (when_done == 0)
06847 1B0F           EB           0C            jmp .192
06848                       00001B11            .18C:
06849                                           ! Debug: logeq int = const 0 to unsigned char when_done = [S+$C+2] (used reg = )
06850 1B11           8A46         04            mov	al,4[bp]
06851 1B14           84C0                       test	al,al
06852 1B16           75           05            jne 	.193
06853                       00001B18            .194:
06854                                           ! 1623       result = 0;
06855                                           ! Debug: eq int = const 0 to unsigned char result = [S+$C-$B] (used reg = )
06856 1B18           30C0                       xor	al,al
06857 1B1A           8846         F7            mov	-9[bp],al
06858                                           !BCC_EOS
06859                                           ! 1624     if (result) return 0;
06860                       00001B1D            .193:
06861                       00001B1D            .192:
06862                       00001B1D            .18B:
06863                       00001B1D            .184:
06864                       00001B1D            .17D:
06865                       00001B1D            .177:
06866 1B1D           8A46         F7            mov	al,-9[bp]
06867 1B20           84C0                       test	al,al
06868 1B22           74           06            je  	.195
06869                       00001B24            .196:
06870 1B24           31C0                       xor	ax,ax
06871 1B26           89EC                       mov	sp,bp
06872 1B28           5D                         pop	bp
06873 1B29           C3                         ret
06874                                           !BCC_EOS
06875                                           ! 1625     if (*(((Bit16u *)&time)+1) != last)
06876                       00001B2A            .195:
06877                                           ! Debug: ne unsigned short last = [S+$C-$A] to unsigned short time = [S+$C-4] (used reg = )
06878 1B2A           8B46         FE            mov	ax,-2[bp]
06879 1B2D           3B46         F8            cmp	ax,-8[bp]
06880 1B30           74           06            je  	.197
06881                       00001B32            .198:
06882                                           ! 1626     {
06883                                           ! 1627       last = *(((Bit16u *)&time)+1);
06884                                           ! Debug: eq unsigned short time = [S+$C-4] to unsigned short last = [S+$C-$A] (used reg = )
06885 1B32           8B46         FE            mov	ax,-2[bp]
06886 1B35           8946         F8            mov	-8[bp],ax
06887                                           !BCC_EOS
06888                                           ! 1628       ;
06889                                           !BCC_EOS
06890                                           ! 1629     }
06891                                           ! 1630     if (status & 0x01)
06892                       00001B38            .197:
06893                                           ! Debug: and int = const 1 to unsigned short status = [S+$C-8] (used reg = )
06894 1B38           8A46         FA            mov	al,-6[bp]
06895 1B3B           24                     01  and	al,*1
06896 1B3D           84C0                       test	al,al
06897 1B3F           74           07            je  	.199
06898                       00001B41            .19A:
06899                                           ! 1631     {
06900                                           ! 1632       ;
06901                                           !BCC_EOS
06902                                           ! 1633       return -1;
06903 1B41           B8                   FFFF  mov	ax,*-1
06904 1B44           89EC                       mov	sp,bp
06905 1B46           5D                         pop	bp
06906 1B47           C3                         ret
06907                                           !BCC_EOS
06908                                           ! 1634     }
06909                                           ! 1635     if ((timeout == 0) || ((time>>11) > timeout)) break;
06910                       00001B48            .199:
06911                                           ! Debug: logeq int = const 0 to unsigned short timeout = [S+$C+6] (used reg = )
06912 1B48           8B46         08            mov	ax,8[bp]
06913 1B4B           85C0                       test	ax,ax
06914 1B4D           74           26            je  	.19C
06915                       00001B4F            .19D:
06916                                           ! Debug: cast unsigned long = const 0 to unsigned short timeout = [S+$C+6] (used reg = )
06917 1B4F           8B46         08            mov	ax,8[bp]
06918 1B52           31DB                       xor	bx,bx
06919 1B54           53                         push	bx
06920 1B55           50                         push	ax
06921                                           ! Debug: sr int = const $B to unsigned long time = [S+$10-6] (used reg = )
06922 1B56           8B46         FC            mov	ax,-4[bp]
06923 1B59           8B5E         FE            mov	bx,-2[bp]
06924 1B5C           88E0                       mov	al,ah
06925 1B5E           88DC                       mov	ah,bl
06926 1B60           88FB                       mov	bl,bh
06927 1B62           28FF                       sub	bh,bh
06928 1B64           BF                   0003  mov	di,*3
06929 1B67           E8         E590            call	lsrul
06930                                           ! Debug: gt unsigned long (temp) = [S+$10-$10] to unsigned long = bx+0 (used reg = )
06931 1B6A           8D7E         F2            lea	di,-$E[bp]
06932 1B6D           E8         E52C            call	lcmpul
06933 1B70           8D66         F6            lea	sp,-$A[bp]
06934 1B73           76           02            jbe 	.19B
06935                       00001B75            .19C:
06936 1B75           EB           03            jmp .172
06937                                           !BCC_EOS
06938                                           ! 1636   }
06939                       00001B77            .19B:
06940                                           ! 1637   bios_printf(4, "IDE time out\n");
06941                       00001B77            .173:
06942 1B77           E9         FEE0            br 	.174
06943                       00001B7A            .172:
06944                                           ! Debug: list * char = .19E+0 (used reg = )
06945 1B7A           BB                   D7E9  mov	bx,#.19E
06946 1B7D           53                         push	bx
06947                                           ! Debug: list int = const 4 (used reg = )
06948 1B7E           B8                   0004  mov	ax,*4
06949 1B81           50                         push	ax
06950                                           ! Debug: func () void = bios_printf+0 (used reg = )
06951 1B82           E8         EDB9            call	_bios_printf
06952 1B85           83C4                   04  add	sp,*4
06953                                           !BCC_EOS
06954                                           ! 1638   return -1;
06955 1B88           B8                   FFFF  mov	ax,*-1
06956 1B8B           89EC                       mov	sp,bp
06957 1B8D           5D                         pop	bp
06958 1B8E           C3                         ret
06959                                           !BCC_EOS
06960                                           ! 1639 }
06961                                           ! 1640 void ata_detect( )
06962                                           ! Register BX used in function await_ide
06963                                           ! 1641 {
06964                                           export	_ata_detect
06965                       00001B8F            _ata_detect:
06966                                           ! 1642   Bit8u hdcount, cdcount, device, type;
06967                                           !BCC_EOS
06968                                           ! 1643   Bit8u buffer[0x0200];
06969                                           !BCC_EOS
06970                                           ! 1644   Bit16u old_ds = set_DS(get_ebda_seg());
06971 1B8F           55                         push	bp
06972 1B90           89E5                       mov	bp,sp
06973 1B92           81C4                 FDFA  add	sp,#-$206
06974                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
06975 1B96           E8         EAD3            call	_get_ebda_seg
06976                                           ! Debug: list unsigned short = ax+0 (used reg = )
06977 1B99           50                         push	ax
06978                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
06979 1B9A           E8         EAC5            call	_set_DS
06980 1B9D           44                         inc	sp
06981 1B9E           44                         inc	sp
06982                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+$208-$208] (used reg = )
06983 1B9F           8986       FDFA            mov	-$206[bp],ax
06984                                           !BCC_EOS
06985                                           ! 1645   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[0].iface)) = (0x00);
06986                                           ! Debug: eq int = const 0 to unsigned char = [+$122] (used reg = )
06987 1BA3           30C0                       xor	al,al
06988 1BA5           A2         0122            mov	[$122],al
06989                                           !BCC_EOS
06990                                           ! 1646   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[0].iobase1)) = (0x01f0);
06991                                           ! Debug: eq int = const $1F0 to unsigned short = [+$124] (used reg = )
06992 1BA8           B8                   01F0  mov	ax,#$1F0
06993 1BAB           A3         0124            mov	[$124],ax
06994                                           !BCC_EOS
06995                                           ! 1647   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[0].iobase2)) = (0x3f0);
06996                                           ! Debug: eq int = const $3F0 to unsigned short = [+$126] (used reg = )
06997 1BAE           B8                   03F0  mov	ax,#$3F0
06998 1BB1           A3         0126            mov	[$126],ax
06999                                           !BCC_EOS
07000                                           ! 1648   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[0].irq)) = (14);
07001                                           ! Debug: eq int = const $E to unsigned char = [+$128] (used reg = )
07002 1BB4           B0                     0E  mov	al,*$E
07003 1BB6           A2         0128            mov	[$128],al
07004                                           !BCC_EOS
07005                                           ! 1649   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[1].iface)) = (0x00);
07006                                           ! Debug: eq int = const 0 to unsigned char = [+$12A] (used reg = )
07007 1BB9           30C0                       xor	al,al
07008 1BBB           A2         012A            mov	[$12A],al
07009                                           !BCC_EOS
07010                                           ! 1650   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[1].iobase1)) = (0x0170);
07011                                           ! Debug: eq int = const $170 to unsigned short = [+$12C] (used reg = )
07012 1BBE           B8                   0170  mov	ax,#$170
07013 1BC1           A3         012C            mov	[$12C],ax
07014                                           !BCC_EOS
07015                                           ! 1651   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[1].iobase2)) = (0x370);
07016                                           ! Debug: eq int = const $370 to unsigned short = [+$12E] (used reg = )
07017 1BC4           B8                   0370  mov	ax,#$370
07018 1BC7           A3         012E            mov	[$12E],ax
07019                                           !BCC_EOS
07020                                           ! 1652   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[1].irq)) = (15);
07021                                           ! Debug: eq int = const $F to unsigned char = [+$130] (used reg = )
07022 1BCA           B0                     0F  mov	al,*$F
07023 1BCC           A2         0130            mov	[$130],al
07024                                           !BCC_EOS
07025                                           ! 1653   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[2].iface)) = (0x00);
07026                                           ! Debug: eq int = const 0 to unsigned char = [+$132] (used reg = )
07027 1BCF           30C0                       xor	al,al
07028 1BD1           A2         0132            mov	[$132],al
07029                                           !BCC_EOS
07030                                           ! 1654   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[2].iobase1)) = (0x1e8);
07031                                           ! Debug: eq int = const $1E8 to unsigned short = [+$134] (used reg = )
07032 1BD4           B8                   01E8  mov	ax,#$1E8
07033 1BD7           A3         0134            mov	[$134],ax
07034                                           !BCC_EOS
07035                                           ! 1655   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[2].iobase2)) = (0x3e0);
07036                                           ! Debug: eq int = const $3E0 to unsigned short = [+$136] (used reg = )
07037 1BDA           B8                   03E0  mov	ax,#$3E0
07038 1BDD           A3         0136            mov	[$136],ax
07039                                           !BCC_EOS
07040                                           ! 1656   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[2].irq)) = (12);
07041                                           ! Debug: eq int = const $C to unsigned char = [+$138] (used reg = )
07042 1BE0           B0                     0C  mov	al,*$C
07043 1BE2           A2         0138            mov	[$138],al
07044                                           !BCC_EOS
07045                                           ! 1657   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[3].iface)) = (0x00);
07046                                           ! Debug: eq int = const 0 to unsigned char = [+$13A] (used reg = )
07047 1BE5           30C0                       xor	al,al
07048 1BE7           A2         013A            mov	[$13A],al
07049                                           !BCC_EOS
07050                                           ! 1658   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[3].iobase1)) = (0x168);
07051                                           ! Debug: eq int = const $168 to unsigned short = [+$13C] (used reg = )
07052 1BEA           B8                   0168  mov	ax,#$168
07053 1BED           A3         013C            mov	[$13C],ax
07054                                           !BCC_EOS
07055                                           ! 1659   *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[3].iobase2)) = (0x360);
07056                                           ! Debug: eq int = const $360 to unsigned short = [+$13E] (used reg = )
07057 1BF0           B8                   0360  mov	ax,#$360
07058 1BF3           A3         013E            mov	[$13E],ax
07059                                           !BCC_EOS
07060                                           ! 1660   *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[3].irq)) = (11);
07061                                           ! Debug: eq int = const $B to unsigned char = [+$140] (used reg = )
07062 1BF6           B0                     0B  mov	al,*$B
07063 1BF8           A2         0140            mov	[$140],al
07064                                           !BCC_EOS
07065                                           ! 1661   hdcount=cdcount=0;
07066                                           ! Debug: eq int = const 0 to unsigned char cdcount = [S+$208-4] (used reg = )
07067 1BFB           30C0                       xor	al,al
07068 1BFD           8846         FE            mov	-2[bp],al
07069                                           ! Debug: eq unsigned char = al+0 to unsigned char hdcount = [S+$208-3] (used reg = )
07070 1C00           8846         FF            mov	-1[bp],al
07071                                           !BCC_EOS
07072                                           ! 1662   for(device=0; device<(4*2); device++) {
07073                                           ! Debug: eq int = const 0 to unsigned char device = [S+$208-5] (used reg = )
07074 1C03           30C0                       xor	al,al
07075 1C05           8846         FD            mov	-3[bp],al
07076                                           !BCC_EOS
07077                                           !BCC_EOS
07078 1C08           E9         0C0F            br 	.1A1
07079                       00001C0B            .1A2:
07080                                           ! 1663     Bit16u iobase1, iobase2, blksize;
07081                                           !BCC_EOS
07082                                           ! 1664     Bit8u channel, slave, shift;
07083                                           !BCC_EOS
07084                                           ! 1665     Bit8u sc, sn, cl, ch, st;
07085                                           !BCC_EOS
07086                                           ! 1666     channel = device / 2;
07087 1C0B           83C4                   F2  add	sp,*-$E
07088                                           ! Debug: div int = const 2 to unsigned char device = [S+$216-5] (used reg = )
07089 1C0E           8A46         FD            mov	al,-3[bp]
07090 1C11           30E4                       xor	ah,ah
07091 1C13           D1E8                       shr	ax,*1
07092                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$216-$20F] (used reg = )
07093 1C15           8886       FDF3            mov	-$20D[bp],al
07094                                           !BCC_EOS
07095                                           ! 1667     slave = device % 2;
07096                                           ! Debug: mod int = const 2 to unsigned char device = [S+$216-5] (used reg = )
07097 1C19           8A46         FD            mov	al,-3[bp]
07098 1C1C           30E4                       xor	ah,ah
07099 1C1E           24                     01  and	al,*1
07100                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$216-$210] (used reg = )
07101 1C20           8886       FDF2            mov	-$20E[bp],al
07102                                           !BCC_EOS
07103                                           ! 1668     iobase1 =*((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1));
07104                                           ! Debug: ptradd unsigned char channel = [S+$216-$20F] to [4] struct  = const $122 (used reg = )
07105 1C24           8A86       FDF3            mov	al,-$20D[bp]
07106 1C28           30E4                       xor	ah,ah
07107 1C2A           B1                     03  mov	cl,*3
07108 1C2C           D3E0                       shl	ax,cl
07109 1C2E           89C3                       mov	bx,ax
07110                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
07111                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
07112                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07113 1C30           8B9F       0124            mov	bx,$124[bx]
07114 1C34           899E       FDF8            mov	-$208[bp],bx
07115                                           !BCC_EOS
07116                                           ! 1669     iobase2 =*((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2));
07117                                           ! Debug: ptradd unsigned char channel = [S+$216-$20F] to [4] struct  = const $122 (used reg = )
07118 1C38           8A86       FDF3            mov	al,-$20D[bp]
07119 1C3C           30E4                       xor	ah,ah
07120 1C3E           B1                     03  mov	cl,*3
07121 1C40           D3E0                       shl	ax,cl
07122 1C42           89C3                       mov	bx,ax
07123                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
07124                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
07125                                           ! Debug: eq unsigned short = [bx+$126] to unsigned short iobase2 = [S+$216-$20C] (used reg = )
07126 1C44           8B9F       0126            mov	bx,$126[bx]
07127 1C48           899E       FDF6            mov	-$20A[bp],bx
07128                                           !BCC_EOS
07129                                           ! 1670     outb(iobase2+6, 0x0
07130                                           ! 1670 8 | 0x02);
07131                                           ! Debug: list int = const $A (used reg = )
07132 1C4C           B8                   000A  mov	ax,*$A
07133 1C4F           50                         push	ax
07134                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$218-$20C] (used reg = )
07135 1C50           8B86       FDF6            mov	ax,-$20A[bp]
07136                                           ! Debug: list unsigned int = ax+6 (used reg = )
07137 1C54           05                   0006  add	ax,*6
07138 1C57           50                         push	ax
07139                                           ! Debug: func () void = outb+0 (used reg = )
07140 1C58           E8         E8B3            call	_outb
07141 1C5B           83C4                   04  add	sp,*4
07142                                           !BCC_EOS
07143                                           ! 1671     outb(iobase1+6, slave ? 0xb0 : 0xa0);
07144 1C5E           8A86       FDF2            mov	al,-$20E[bp]
07145 1C62           84C0                       test	al,al
07146 1C64           74           04            je  	.1A3
07147                       00001C66            .1A4:
07148 1C66           B0                     B0  mov	al,#$B0
07149 1C68           EB           02            jmp .1A5
07150                       00001C6A            .1A3:
07151 1C6A           B0                     A0  mov	al,#$A0
07152                       00001C6C            .1A5:
07153                                           ! Debug: list char = al+0 (used reg = )
07154 1C6C           30E4                       xor	ah,ah
07155 1C6E           50                         push	ax
07156                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07157 1C6F           8B86       FDF8            mov	ax,-$208[bp]
07158                                           ! Debug: list unsigned int = ax+6 (used reg = )
07159 1C73           05                   0006  add	ax,*6
07160 1C76           50                         push	ax
07161                                           ! Debug: func () void = outb+0 (used reg = )
07162 1C77           E8         E894            call	_outb
07163 1C7A           83C4                   04  add	sp,*4
07164                                           !BCC_EOS
07165                                           ! 1672     outb(iobase1+2, 0x55);
07166                                           ! Debug: list int = const $55 (used reg = )
07167 1C7D           B8                   0055  mov	ax,*$55
07168 1C80           50                         push	ax
07169                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07170 1C81           8B86       FDF8            mov	ax,-$208[bp]
07171                                           ! Debug: list unsigned int = ax+2 (used reg = )
07172 1C85           40                         inc	ax
07173 1C86           40                         inc	ax
07174 1C87           50                         push	ax
07175                                           ! Debug: func () void = outb+0 (used reg = )
07176 1C88           E8         E883            call	_outb
07177 1C8B           83C4                   04  add	sp,*4
07178                                           !BCC_EOS
07179                                           ! 1673     outb(iobase1+3, 0xaa);
07180                                           ! Debug: list int = const $AA (used reg = )
07181 1C8E           B8                   00AA  mov	ax,#$AA
07182 1C91           50                         push	ax
07183                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07184 1C92           8B86       FDF8            mov	ax,-$208[bp]
07185                                           ! Debug: list unsigned int = ax+3 (used reg = )
07186 1C96           05                   0003  add	ax,*3
07187 1C99           50                         push	ax
07188                                           ! Debug: func () void = outb+0 (used reg = )
07189 1C9A           E8         E871            call	_outb
07190 1C9D           83C4                   04  add	sp,*4
07191                                           !BCC_EOS
07192                                           ! 1674     outb(iobase1+2, 0xaa);
07193                                           ! Debug: list int = const $AA (used reg = )
07194 1CA0           B8                   00AA  mov	ax,#$AA
07195 1CA3           50                         push	ax
07196                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07197 1CA4           8B86       FDF8            mov	ax,-$208[bp]
07198                                           ! Debug: list unsigned int = ax+2 (used reg = )
07199 1CA8           40                         inc	ax
07200 1CA9           40                         inc	ax
07201 1CAA           50                         push	ax
07202                                           ! Debug: func () void = outb+0 (used reg = )
07203 1CAB           E8         E860            call	_outb
07204 1CAE           83C4                   04  add	sp,*4
07205                                           !BCC_EOS
07206                                           ! 1675     outb(iobase1+3, 0x55);
07207                                           ! Debug: list int = const $55 (used reg = )
07208 1CB1           B8                   0055  mov	ax,*$55
07209 1CB4           50                         push	ax
07210                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07211 1CB5           8B86       FDF8            mov	ax,-$208[bp]
07212                                           ! Debug: list unsigned int = ax+3 (used reg = )
07213 1CB9           05                   0003  add	ax,*3
07214 1CBC           50                         push	ax
07215                                           ! Debug: func () void = outb+0 (used reg = )
07216 1CBD           E8         E84E            call	_outb
07217 1CC0           83C4                   04  add	sp,*4
07218                                           !BCC_EOS
07219                                           ! 1676     outb(iobase1+2, 0x55);
07220                                           ! Debug: list int = const $55 (used reg = )
07221 1CC3           B8                   0055  mov	ax,*$55
07222 1CC6           50                         push	ax
07223                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07224 1CC7           8B86       FDF8            mov	ax,-$208[bp]
07225                                           ! Debug: list unsigned int = ax+2 (used reg = )
07226 1CCB           40                         inc	ax
07227 1CCC           40                         inc	ax
07228 1CCD           50                         push	ax
07229                                           ! Debug: func () void = outb+0 (used reg = )
07230 1CCE           E8         E83D            call	_outb
07231 1CD1           83C4                   04  add	sp,*4
07232                                           !BCC_EOS
07233                                           ! 1677     outb(iobase1+3, 0xaa);
07234                                           ! Debug: list int = const $AA (used reg = )
07235 1CD4           B8                   00AA  mov	ax,#$AA
07236 1CD7           50                         push	ax
07237                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07238 1CD8           8B86       FDF8            mov	ax,-$208[bp]
07239                                           ! Debug: list unsigned int = ax+3 (used reg = )
07240 1CDC           05                   0003  add	ax,*3
07241 1CDF           50                         push	ax
07242                                           ! Debug: func () void = outb+0 (used reg = )
07243 1CE0           E8         E82B            call	_outb
07244 1CE3           83C4                   04  add	sp,*4
07245                                           !BCC_EOS
07246                                           ! 1678     sc = inb(iobase1+2);
07247                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07248 1CE6           8B86       FDF8            mov	ax,-$208[bp]
07249                                           ! Debug: list unsigned int = ax+2 (used reg = )
07250 1CEA           40                         inc	ax
07251 1CEB           40                         inc	ax
07252 1CEC           50                         push	ax
07253                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07254 1CED           E8         E808            call	_inb
07255 1CF0           44                         inc	sp
07256 1CF1           44                         inc	sp
07257                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$216-$212] (used reg = )
07258 1CF2           8886       FDF0            mov	-$210[bp],al
07259                                           !BCC_EOS
07260                                           ! 1679     sn = inb(iobase1+3);
07261                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07262 1CF6           8B86       FDF8            mov	ax,-$208[bp]
07263                                           ! Debug: list unsigned int = ax+3 (used reg = )
07264 1CFA           05                   0003  add	ax,*3
07265 1CFD           50                         push	ax
07266                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07267 1CFE           E8         E7F7            call	_inb
07268 1D01           44                         inc	sp
07269 1D02           44                         inc	sp
07270                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$216-$213] (used reg = )
07271 1D03           8886       FDEF            mov	-$211[bp],al
07272                                           !BCC_EOS
07273                                           ! 1680     if ( (sc == 0x55) && (sn == 0xaa) ) {
07274                                           ! Debug: logeq int = const $55 to unsigned char sc = [S+$216-$212] (used reg = )
07275 1D07           8A86       FDF0            mov	al,-$210[bp]
07276 1D0B           3C                     55  cmp	al,*$55
07277 1D0D         0F85         0120            bne 	.1A6
07278                       00001D11            .1A8:
07279                                           ! Debug: logeq int = const $AA to unsigned char sn = [S+$216-$213] (used reg = )
07280 1D11           8A86       FDEF            mov	al,-$211[bp]
07281 1D15           3C                     AA  cmp	al,#$AA
07282 1D17         0F85         0116            bne 	.1A6
07283                       00001D1B            .1A7:
07284                                           ! 1681       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type)) = (0x01);
07285                                           ! Debug: ptradd unsigned char device = [S+$216-5] to [8] struct  = const $142 (used reg = )
07286 1D1B           8A46         FD            mov	al,-3[bp]
07287 1D1E           30E4                       xor	ah,ah
07288 1D20           B9                   001E  mov	cx,*$1E
07289 1D23           F7E9                       imul	cx
07290 1D25           89C3                       mov	bx,ax
07291                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07292                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
07293                                           ! Debug: eq int = const 1 to unsigned char = [bx+$142] (used reg = )
07294 1D27           B0                     01  mov	al,*1
07295 1D29           8887       0142            mov	$142[bx],al
07296                                           !BCC_EOS
07297                                           ! 1682       ata_reset(device);
07298                                           ! Debug: list unsigned char device = [S+$216-5] (used reg = )
07299 1D2D           8A46         FD            mov	al,-3[bp]
07300 1D30           30E4                       xor	ah,ah
07301 1D32           50                         push	ax
07302                                           ! Debug: func () void = ata_reset+0 (used reg = )
07303 1D33           E8         0B28            call	_ata_reset
07304 1D36           44                         inc	sp
07305 1D37           44                         inc	sp
07306                                           !BCC_EOS
07307                                           ! 1683       outb(iobase1+6, slave ? 0xb0 : 0xa0);
07308 1D38           8A86       FDF2            mov	al,-$20E[bp]
07309 1D3C           84C0                       test	al,al
07310 1D3E           74           04            je  	.1A9
07311                       00001D40            .1AA:
07312 1D40           B0                     B0  mov	al,#$B0
07313 1D42           EB           02            jmp .1AB
07314                       00001D44            .1A9:
07315 1D44           B0                     A0  mov	al,#$A0
07316                       00001D46            .1AB:
07317                                           ! Debug: list char = al+0 (used reg = )
07318 1D46           30E4                       xor	ah,ah
07319 1D48           50                         push	ax
07320                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$218-$20A] (used reg = )
07321 1D49           8B86       FDF8            mov	ax,-$208[bp]
07322                                           ! Debug: list unsigned int = ax+6 (used reg = )
07323 1D4D           05                   0006  add	ax,*6
07324 1D50           50                         push	ax
07325                                           ! Debug: func () void = outb+0 (used reg = )
07326 1D51           E8         E7BA            call	_outb
07327 1D54           83C4                   04  add	sp,*4
07328                                           !BCC_EOS
07329                                           ! 1684       sc = inb(iobase1+2);
07330                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07331 1D57           8B86       FDF8            mov	ax,-$208[bp]
07332                                           ! Debug: list unsigned int = ax+2 (used reg = )
07333 1D5B           40                         inc	ax
07334 1D5C           40                         inc	ax
07335 1D5D           50                         push	ax
07336                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07337 1D5E           E8         E797            call	_inb
07338 1D61           44                         inc	sp
07339 1D62           44                         inc	sp
07340                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$216-$212] (used reg = )
07341 1D63           8886       FDF0            mov	-$210[bp],al
07342                                           !BCC_EOS
07343                                           ! 1685       sn = inb(iobase1+3);
07344                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07345 1D67           8B86       FDF8            mov	ax,-$208[bp]
07346                                           ! Debug: list unsigned int = ax+3 (used reg = )
07347 1D6B           05                   0003  add	ax,*3
07348 1D6E           50                         push	ax
07349                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07350 1D6F           E8         E786            call	_inb
07351 1D72           44                         inc	sp
07352 1D73           44                         inc	sp
07353                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$216-$213] (used reg = )
07354 1D74           8886       FDEF            mov	-$211[bp],al
07355                                           !BCC_EOS
07356                                           ! 1686       if ((sc==0x01) && (sn==0x01)) {
07357                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$216-$212] (used reg = )
07358 1D78           8A86       FDF0            mov	al,-$210[bp]
07359 1D7C           3C                     01  cmp	al,*1
07360 1D7E         0F85         00AF            bne 	.1AC
07361                       00001D82            .1AE:
07362                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$216-$213] (used reg = )
07363 1D82           8A86       FDEF            mov	al,-$211[bp]
07364 1D86           3C                     01  cmp	al,*1
07365 1D88         0F85         00A5            bne 	.1AC
07366                       00001D8C            .1AD:
07367                                           ! 1687         cl = inb(iobase1+4);
07368                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07369 1D8C           8B86       FDF8            mov	ax,-$208[bp]
07370                                           ! Debug: list unsigned int = ax+4 (used reg = )
07371 1D90           05                   0004  add	ax,*4
07372 1D93           50                         push	ax
07373                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07374 1D94           E8         E761            call	_inb
07375 1D97           44                         inc	sp
07376 1D98           44                         inc	sp
07377                                           ! Debug: eq unsigned char = al+0 to unsigned char cl = [S+$216-$214] (used reg = )
07378 1D99           8886       FDEE            mov	-$212[bp],al
07379                                           !BCC_EOS
07380                                           ! 1688         ch = inb(iobase1+5);
07381                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07382 1D9D           8B86       FDF8            mov	ax,-$208[bp]
07383                                           ! Debug: list unsigned int = ax+5 (used reg = )
07384 1DA1           05                   0005  add	ax,*5
07385 1DA4           50                         push	ax
07386                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07387 1DA5           E8         E750            call	_inb
07388 1DA8           44                         inc	sp
07389 1DA9           44                         inc	sp
07390                                           ! Debug: eq unsigned char = al+0 to unsigned char ch = [S+$216-$215] (used reg = )
07391 1DAA           8886       FDED            mov	-$213[bp],al
07392                                           !BCC_EOS
07393                                           ! 1689         st = inb(iobase1+7);
07394                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07395 1DAE           8B86       FDF8            mov	ax,-$208[bp]
07396                                           ! Debug: list unsigned int = ax+7 (used reg = )
07397 1DB2           05                   0007  add	ax,*7
07398 1DB5           50                         push	ax
07399                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07400 1DB6           E8         E73F            call	_inb
07401 1DB9           44                         inc	sp
07402 1DBA           44                         inc	sp
07403                                           ! Debug: eq unsigned char = al+0 to unsigned char st = [S+$216-$216] (used reg = )
07404 1DBB           8886       FDEC            mov	-$214[bp],al
07405                                           !BCC_EOS
07406                                           ! 1690         if ((cl==0x14) && (ch==0xeb)) {
07407                                           ! Debug: logeq int = const $14 to unsigned char cl = [S+$216-$214] (used reg = )
07408 1DBF           8A86       FDEE            mov	al,-$212[bp]
07409 1DC3           3C                     14  cmp	al,*$14
07410 1DC5           75           1C            jne 	.1AF
07411                       00001DC7            .1B1:
07412                                           ! Debug: logeq int = const $EB to unsigned char ch = [S+$216-$215] (used reg = )
07413 1DC7           8A86       FDED            mov	al,-$213[bp]
07414 1DCB           3C                     EB  cmp	al,#$EB
07415 1DCD           75           14            jne 	.1AF
07416                       00001DCF            .1B0:
07417                                           ! 1691           *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type)) = (0x03);
07418                                           ! Debug: ptradd unsigned char device = [S+$216-5] to [8] struct  = const $142 (used reg = )
07419 1DCF           8A46         FD            mov	al,-3[bp]
07420 1DD2           30E4                       xor	ah,ah
07421 1DD4           B9                   001E  mov	cx,*$1E
07422 1DD7           F7E9                       imul	cx
07423 1DD9           89C3                       mov	bx,ax
07424                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07425                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
07426                                           ! Debug: eq int = const 3 to unsigned char = [bx+$142] (used reg = )
07427 1DDB           B0                     03  mov	al,*3
07428 1DDD           8887       0142            mov	$142[bx],al
07429                                           !BCC_EOS
07430                                           ! 1692         } else if ((cl==0x00) && (ch==0x00) && (st!=0x00)) {
07431 1DE1           EB           4E            jmp .1B2
07432                       00001DE3            .1AF:
07433                                           ! Debug: logeq int = const 0 to unsigned char cl = [S+$216-$214] (used reg = )
07434 1DE3           8A86       FDEE            mov	al,-$212[bp]
07435 1DE7           84C0                       test	al,al
07436 1DE9           75           24            jne 	.1B3
07437                       00001DEB            .1B6:
07438                                           ! Debug: logeq int = const 0 to unsigned char ch = [S+$216-$215] (used reg = )
07439 1DEB           8A86       FDED            mov	al,-$213[bp]
07440 1DEF           84C0                       test	al,al
07441 1DF1           75           1C            jne 	.1B3
07442                       00001DF3            .1B5:
07443                                           ! Debug: ne int = const 0 to unsigned char st = [S+$216-$216] (used reg = )
07444 1DF3           8A86       FDEC            mov	al,-$214[bp]
07445 1DF7           84C0                       test	al,al
07446 1DF9           74           14            je  	.1B3
07447                       00001DFB            .1B4:
07448                                           ! 1693           *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type)) = (0x02);
07449                                           ! Debug: ptradd unsigned char device = [S+$216-5] to [8] struct  = const $142 (used reg = )
07450 1DFB           8A46         FD            mov	al,-3[bp]
07451 1DFE           30E4                       xor	ah,ah
07452 1E00           B9                   001E  mov	cx,*$1E
07453 1E03           F7E9                       imul	cx
07454 1E05           89C3                       mov	bx,ax
07455                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07456                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
07457                                           ! Debug: eq int = const 2 to unsigned char = [bx+$142] (used reg = )
07458 1E07           B0                     02  mov	al,*2
07459 1E09           8887       0142            mov	$142[bx],al
07460                                           !BCC_EOS
07461                                           ! 1694         } else if ((cl==0xff) && (ch==0xff)) {
07462 1E0D           EB           22            jmp .1B7
07463                       00001E0F            .1B3:
07464                                           ! Debug: logeq int = const $FF to unsigned char cl = [S+$216-$214] (used reg = )
07465 1E0F           8A86       FDEE            mov	al,-$212[bp]
07466 1E13           3C                     FF  cmp	al,#$FF
07467 1E15           75           1A            jne 	.1B8
07468                       00001E17            .1BA:
07469                                           ! Debug: logeq int = const $FF to unsigned char ch = [S+$216-$215] (used reg = )
07470 1E17           8A86       FDED            mov	al,-$213[bp]
07471 1E1B           3C                     FF  cmp	al,#$FF
07472 1E1D           75           12            jne 	.1B8
07473                       00001E1F            .1B9:
07474                                           ! 1695           *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type)) = (0x00);
07475                                           ! Debug: ptradd unsigned char device = [S+$216-5] to [8] struct  = const $142 (used reg = )
07476 1E1F           8A46         FD            mov	al,-3[bp]
07477 1E22           30E4                       xor	ah,ah
07478 1E24           B9                   001E  mov	cx,*$1E
07479 1E27           F7E9                       imul	cx
07480 1E29           89C3                       mov	bx,ax
07481                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07482                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
07483                                           ! Debug: eq int = const 0 to unsigned char = [bx+$142] (used reg = )
07484 1E2B           30C0                       xor	al,al
07485 1E2D           8887       0142            mov	$142[bx],al
07486                                           !BCC_EOS
07487                                           ! 1696         }
07488                                           ! 1697       }
07489                       00001E31            .1B8:
07490                       00001E31            .1B7:
07491                       00001E31            .1B2:
07492                                           ! 1698     }
07493                       00001E31            .1AC:
07494                                           ! 1699     type=*((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type));
07495                       00001E31            .1A6:
07496                                           ! Debug: ptradd unsigned char device = [S+$216-5] to [8] struct  = const $142 (used reg = )
07497 1E31           8A46         FD            mov	al,-3[bp]
07498 1E34           30E4                       xor	ah,ah
07499 1E36           B9                   001E  mov	cx,*$1E
07500 1E39           F7E9                       imul	cx
07501 1E3B           89C3                       mov	bx,ax
07502                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07503                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
07504                                           ! Debug: eq unsigned char = [bx+$142] to unsigned char type = [S+$216-6] (used reg = )
07505 1E3D           8A87       0142            mov	al,$142[bx]
07506 1E41           8846         FC            mov	-4[bp],al
07507                                           !BCC_EOS
07508                                           ! 1700     if(type == 0x02) {
07509                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$216-6] (used reg = )
07510 1E44           8A46         FC            mov	al,-4[bp]
07511 1E47           3C                     02  cmp	al,*2
07512 1E49         0F85         04CC            bne 	.1BB
07513                       00001E4D            .1BC:
07514                                           ! 1701       Bit32u sectors_low, sectors_high;
07515                                           !BCC_EOS
07516                                           ! 1702       Bit16u cylinders, heads, spt;
07517                                           !BCC_EOS
07518                                           ! 1703       Bit8u translation, removable, mode;
07519                                           !BCC_EOS
07520                                           ! 1704       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device)) = (0xFF);
07521 1E4D           83C4                   EE  add	sp,*-$12
07522                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07523 1E50           8A46         FD            mov	al,-3[bp]
07524 1E53           30E4                       xor	ah,ah
07525 1E55           B9                   001E  mov	cx,*$1E
07526 1E58           F7E9                       imul	cx
07527 1E5A           89C3                       mov	bx,ax
07528                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
07529                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
07530                                           ! Debug: eq int = const $FF to unsigned char = [bx+$143] (used reg = )
07531 1E5C           B0                     FF  mov	al,#$FF
07532 1E5E           8887       0143            mov	$143[bx],al
07533                                           !BCC_EOS
07534                                           ! 1705       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode)) = (0x00);
07535                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07536 1E62           8A46         FD            mov	al,-3[bp]
07537 1E65           30E4                       xor	ah,ah
07538 1E67           B9                   001E  mov	cx,*$1E
07539 1E6A           F7E9                       imul	cx
07540 1E6C           89C3                       mov	bx,ax
07541                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
07542                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
07543                                           ! Debug: eq int = const 0 to unsigned char = [bx+$146] (used reg = )
07544 1E6E           30C0                       xor	al,al
07545 1E70           8887       0146            mov	$146[bx],al
07546                                           !BCC_EOS
07547                                           ! 1706       if (ata_cmd_data_io(0, device,0xEC, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) !=0 )
07548                                           ! Debug: list * unsigned char buffer = S+$228-$206 (used reg = )
07549 1E74           8D9E       FDFC            lea	bx,-$204[bp]
07550 1E78           53                         push	bx
07551                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07552 1E79           E8         E7E3            call	_get_SS
07553                                           ! Debug: list unsigned short = ax+0 (used reg = )
07554 1E7C           50                         push	ax
07555                                           ! Debug: list long = const 0 (used reg = )
07556 1E7D           31C0                       xor	ax,ax
07557 1E7F           31DB                       xor	bx,bx
07558 1E81           53                         push	bx
07559 1E82           50                         push	ax
07560                                           ! Debug: list long = const 0 (used reg = )
07561 1E83           31C0                       xor	ax,ax
07562 1E85           31DB                       xor	bx,bx
07563 1E87           53                         push	bx
07564 1E88           50                         push	ax
07565                                           ! Debug: list int = const 0 (used reg = )
07566 1E89           31C0                       xor	ax,ax
07567 1E8B           50                         push	ax
07568                                           ! Debug: list int = const 0 (used reg = )
07569 1E8C           31C0                       xor	ax,ax
07570 1E8E           50                         push	ax
07571                                           ! Debug: list int = const 0 (used reg = )
07572 1E8F           31C0                       xor	ax,ax
07573 1E91           50                         push	ax
07574                                           ! Debug: list int = const 1 (used reg = )
07575 1E92           B8                   0001  mov	ax,*1
07576 1E95           50                         push	ax
07577                                           ! Debug: list int = const $EC (used reg = )
07578 1E96           B8                   00EC  mov	ax,#$EC
07579 1E99           50                         push	ax
07580                                           ! Debug: list unsigned char device = [S+$23E-5] (used reg = )
07581 1E9A           8A46         FD            mov	al,-3[bp]
07582 1E9D           30E4                       xor	ah,ah
07583 1E9F           50                         push	ax
07584                                           ! Debug: list int = const 0 (used reg = )
07585 1EA0           31C0                       xor	ax,ax
07586 1EA2           50                         push	ax
07587                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
07588 1EA3           E8         0ADF            call	_ata_cmd_data_io
07589 1EA6           83C4                   1A  add	sp,*$1A
07590                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
07591 1EA9           85C0                       test	ax,ax
07592 1EAB           74           0E            je  	.1BD
07593                       00001EAD            .1BE:
07594                                           ! 1707         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATA device\n");
07595                                           ! Debug: list * char = .1BF+0 (used reg = )
07596 1EAD           BB                   D7C0  mov	bx,#.1BF
07597 1EB0           53                         push	bx
07598                                           ! Debug: list int = const 7 (used reg = )
07599 1EB1           B8                   0007  mov	ax,*7
07600 1EB4           50                         push	ax
07601                                           ! Debug: func () void = bios_printf+0 (used reg = )
07602 1EB5           E8         EA86            call	_bios_printf
07603 1EB8           83C4                   04  add	sp,*4
07604                                           !BCC_EOS
07605                                           ! 1708       removable = (read_byte_SS(buffer+0) & 0x80) >> 7;
07606                       00001EBB            .1BD:
07607                                           ! Debug: list * unsigned char buffer = S+$228-$206 (used reg = )
07608 1EBB           8D9E       FDFC            lea	bx,-$204[bp]
07609 1EBF           53                         push	bx
07610                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
07611 1EC0           E8         E763            call	_read_byte_SS
07612 1EC3           44                         inc	sp
07613 1EC4           44                         inc	sp
07614                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
07615 1EC5           24                     80  and	al,#$80
07616                                           ! Debug: sr int = const 7 to unsigned char = al+0 (used reg = )
07617 1EC7           30E4                       xor	ah,ah
07618 1EC9           B1                     07  mov	cl,*7
07619 1ECB           D3E8                       shr	ax,cl
07620                                           ! Debug: eq unsigned int = ax+0 to unsigned char removable = [S+$228-$226] (used reg = )
07621 1ECD           8886       FDDC            mov	-$224[bp],al
07622                                           !BCC_EOS
07623                                           ! 1709       mode = read_byte_SS(buffer+96) ? 0x01 : 0x00;
07624                                           ! Debug: list * unsigned char buffer = S+$228-$1A6 (used reg = )
07625 1ED1           8D9E       FE5C            lea	bx,-$1A4[bp]
07626 1ED5           53                         push	bx
07627                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
07628 1ED6           E8         E74D            call	_read_byte_SS
07629 1ED9           44                         inc	sp
07630 1EDA           44                         inc	sp
07631 1EDB           84C0                       test	al,al
07632 1EDD           74           04            je  	.1C0
07633                       00001EDF            .1C1:
07634 1EDF           B0                     01  mov	al,*1
07635 1EE1           EB           02            jmp .1C2
07636                       00001EE3            .1C0:
07637 1EE3           30C0                       xor	al,al
07638                       00001EE5            .1C2:
07639                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$228-$227] (used reg = )
07640 1EE5           8886       FDDB            mov	-$225[bp],al
07641                                           !BCC_EOS
07642                                           ! 1710       blksize = read_word_SS(buffer+10);
07643                                           ! Debug: list * unsigned char buffer = S+$228-$1FC (used reg = )
07644 1EE9           8D9E       FE06            lea	bx,-$1FA[bp]
07645 1EED           53                         push	bx
07646                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
07647 1EEE           E8         E740            call	_read_word_SS
07648 1EF1           44                         inc	sp
07649 1EF2           44                         inc	sp
07650                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$228-$20E] (used reg = )
07651 1EF3           8986       FDF4            mov	-$20C[bp],ax
07652                                           !BCC_EOS
07653                                           ! 1711       cylinders = read_word_SS(buffer+(1*2));
07654                                           ! Debug: list * unsigned char buffer = S+$228-$204 (used reg = )
07655 1EF7           8D9E       FDFE            lea	bx,-$202[bp]
07656 1EFB           53                         push	bx
07657                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
07658 1EFC           E8         E732            call	_read_word_SS
07659 1EFF           44                         inc	sp
07660 1F00           44                         inc	sp
07661                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$220] (used reg = )
07662 1F01           8986       FDE2            mov	-$21E[bp],ax
07663                                           !BCC_EOS
07664                                           ! 1712       heads = read_word_SS(buffer+(3*2));
07665                                           ! Debug: list * unsigned char buffer = S+$228-$200 (used reg = )
07666 1F05           8D9E       FE02            lea	bx,-$1FE[bp]
07667 1F09           53                         push	bx
07668                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
07669 1F0A           E8         E724            call	_read_word_SS
07670 1F0D           44                         inc	sp
07671 1F0E           44                         inc	sp
07672                                           ! Debug: eq unsigned short = ax+0 to unsigned short heads = [S+$228-$222] (used reg = )
07673 1F0F           8986       FDE0            mov	-$220[bp],ax
07674                                           !BCC_EOS
07675                                           ! 1713       spt = read_word_SS(buffer+(6*2));
07676                                           ! Debug: list * unsigned char buffer = S+$228-$1FA (used reg = )
07677 1F13           8D9E       FE08            lea	bx,-$1F8[bp]
07678 1F17           53                         push	bx
07679                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
07680 1F18           E8         E716            call	_read_word_SS
07681 1F1B           44                         inc	sp
07682 1F1C           44                         inc	sp
07683                                           ! Debug: eq unsigned short = ax+0 to unsigned short spt = [S+$228-$224] (used reg = )
07684 1F1D           8986       FDDE            mov	-$222[bp],ax
07685                                           !BCC_EOS
07686                                           ! 1714       if (read_word_SS(buffer+(83*2)) & (1 << 10)) {
07687                                           ! Debug: list * unsigned char buffer = S+$228-$160 (used reg = )
07688 1F21           8D9E       FEA2            lea	bx,-$15E[bp]
07689 1F25           53                         push	bx
07690                                           ! Debug: func () unsigned short = read_word_SS+0 (used reg = )
07691 1F26           E8         E708            call	_read_word_SS
07692 1F29           44                         inc	sp
07693 1F2A           44                         inc	sp
07694                                           ! Debug: and int = const $400 to unsigned short = ax+0 (used reg = )
07695 1F2B           25                   0400  and	ax,#$400
07696 1F2E           85C0                       test	ax,ax
07697 1F30           74           2A            je  	.1C3
07698                       00001F32            .1C4:
07699                                           ! 1715         sectors_low = read_dword_SS(buffer+(100*2));
07700                                           ! Debug: list * unsigned char buffer = S+$228-$13E (used reg = )
07701 1F32           8D9E       FEC4            lea	bx,-$13C[bp]
07702 1F36           53                         push	bx
07703                                           ! Debug: func () unsigned long = read_dword_SS+0 (used reg = )
07704 1F37           E8         E144            call	_read_dword_SS
07705 1F3A           89D3                       mov	bx,dx
07706 1F3C           44                         inc	sp
07707 1F3D           44                         inc	sp
07708                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$21A] (used reg = )
07709 1F3E           8986       FDE8            mov	-$218[bp],ax
07710 1F42           899E       FDEA            mov	-$216[bp],bx
07711                                           !BCC_EOS
07712                                           ! 1716         sectors_high = read_dword_SS(buffer+(102*2));
07713                                           ! Debug: list * unsigned char buffer = S+$228-$13A (used reg = )
07714 1F46           8D9E       FEC8            lea	bx,-$138[bp]
07715 1F4A           53                         push	bx
07716                                           ! Debug: func () unsigned long = read_dword_SS+0 (used reg = )
07717 1F4B           E8         E130            call	_read_dword_SS
07718 1F4E           89D3                       mov	bx,dx
07719 1F50           44                         inc	sp
07720 1F51           44                         inc	sp
07721                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_high = [S+$228-$21E] (used reg = )
07722 1F52           8986       FDE4            mov	-$21C[bp],ax
07723 1F56           899E       FDE6            mov	-$21A[bp],bx
07724                                           !BCC_EOS
07725                                           ! 1717       } else {
07726 1F5A           EB           20            jmp .1C5
07727                       00001F5C            .1C3:
07728                                           ! 1718         sectors_l
07729                                           ! 1718 ow = read_dword_SS(buffer+(60*2));
07730                                           ! Debug: list * unsigned char buffer = S+$228-$18E (used reg = )
07731 1F5C           8D9E       FE74            lea	bx,-$18C[bp]
07732 1F60           53                         push	bx
07733                                           ! Debug: func () unsigned long = read_dword_SS+0 (used reg = )
07734 1F61           E8         E11A            call	_read_dword_SS
07735 1F64           89D3                       mov	bx,dx
07736 1F66           44                         inc	sp
07737 1F67           44                         inc	sp
07738                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$21A] (used reg = )
07739 1F68           8986       FDE8            mov	-$218[bp],ax
07740 1F6C           899E       FDEA            mov	-$216[bp],bx
07741                                           !BCC_EOS
07742                                           ! 1719         sectors_high = 0;
07743                                           ! Debug: eq int = const 0 to unsigned long sectors_high = [S+$228-$21E] (used reg = )
07744 1F70           31C0                       xor	ax,ax
07745 1F72           31DB                       xor	bx,bx
07746 1F74           8986       FDE4            mov	-$21C[bp],ax
07747 1F78           899E       FDE6            mov	-$21A[bp],bx
07748                                           !BCC_EOS
07749                                           ! 1720       }
07750                                           ! 1721       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device)) = (0xFF);
07751                       00001F7C            .1C5:
07752                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07753 1F7C           8A46         FD            mov	al,-3[bp]
07754 1F7F           30E4                       xor	ah,ah
07755 1F81           B9                   001E  mov	cx,*$1E
07756 1F84           F7E9                       imul	cx
07757 1F86           89C3                       mov	bx,ax
07758                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
07759                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
07760                                           ! Debug: eq int = const $FF to unsigned char = [bx+$143] (used reg = )
07761 1F88           B0                     FF  mov	al,#$FF
07762 1F8A           8887       0143            mov	$143[bx],al
07763                                           !BCC_EOS
07764                                           ! 1722       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].removable)) = (removable);
07765                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07766 1F8E           8A46         FD            mov	al,-3[bp]
07767 1F91           30E4                       xor	ah,ah
07768 1F93           B9                   001E  mov	cx,*$1E
07769 1F96           F7E9                       imul	cx
07770 1F98           89C3                       mov	bx,ax
07771                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
07772                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$144 (used reg = )
07773                                           ! Debug: eq unsigned char removable = [S+$228-$226] to unsigned char = [bx+$144] (used reg = )
07774 1F9A           8A86       FDDC            mov	al,-$224[bp]
07775 1F9E           8887       0144            mov	$144[bx],al
07776                                           !BCC_EOS
07777                                           ! 1723       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode)) = (mode);
07778                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07779 1FA2           8A46         FD            mov	al,-3[bp]
07780 1FA5           30E4                       xor	ah,ah
07781 1FA7           B9                   001E  mov	cx,*$1E
07782 1FAA           F7E9                       imul	cx
07783 1FAC           89C3                       mov	bx,ax
07784                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
07785                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
07786                                           ! Debug: eq unsigned char mode = [S+$228-$227] to unsigned char = [bx+$146] (used reg = )
07787 1FAE           8A86       FDDB            mov	al,-$225[bp]
07788 1FB2           8887       0146            mov	$146[bx],al
07789                                           !BCC_EOS
07790                                           ! 1724       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].blksize)) = (blksize);
07791                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07792 1FB6           8A46         FD            mov	al,-3[bp]
07793 1FB9           30E4                       xor	ah,ah
07794 1FBB           B9                   001E  mov	cx,*$1E
07795 1FBE           F7E9                       imul	cx
07796 1FC0           89C3                       mov	bx,ax
07797                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
07798                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$148 (used reg = )
07799                                           ! Debug: eq unsigned short blksize = [S+$228-$20E] to unsigned short = [bx+$148] (used reg = )
07800 1FC2           8B86       FDF4            mov	ax,-$20C[bp]
07801 1FC6           8987       0148            mov	$148[bx],ax
07802                                           !BCC_EOS
07803                                           ! 1725       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.heads)) = (heads);
07804                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07805 1FCA           8A46         FD            mov	al,-3[bp]
07806 1FCD           30E4                       xor	ah,ah
07807 1FCF           B9                   001E  mov	cx,*$1E
07808 1FD2           F7E9                       imul	cx
07809 1FD4           89C3                       mov	bx,ax
07810                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
07811                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$152 (used reg = )
07812                                           ! Debug: eq unsigned short heads = [S+$228-$222] to unsigned short = [bx+$152] (used reg = )
07813 1FD6           8B86       FDE0            mov	ax,-$220[bp]
07814 1FDA           8987       0152            mov	$152[bx],ax
07815                                           !BCC_EOS
07816                                           ! 1726       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders)) = (cylinders);
07817                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07818 1FDE           8A46         FD            mov	al,-3[bp]
07819 1FE1           30E4                       xor	ah,ah
07820 1FE3           B9                   001E  mov	cx,*$1E
07821 1FE6           F7E9                       imul	cx
07822 1FE8           89C3                       mov	bx,ax
07823                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
07824                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$154 (used reg = )
07825                                           ! Debug: eq unsigned short cylinders = [S+$228-$220] to unsigned short = [bx+$154] (used reg = )
07826 1FEA           8B86       FDE2            mov	ax,-$21E[bp]
07827 1FEE           8987       0154            mov	$154[bx],ax
07828                                           !BCC_EOS
07829                                           ! 1727       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.spt)) = (spt);
07830                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07831 1FF2           8A46         FD            mov	al,-3[bp]
07832 1FF5           30E4                       xor	ah,ah
07833 1FF7           B9                   001E  mov	cx,*$1E
07834 1FFA           F7E9                       imul	cx
07835 1FFC           89C3                       mov	bx,ax
07836                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
07837                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$156 (used reg = )
07838                                           ! Debug: eq unsigned short spt = [S+$228-$224] to unsigned short = [bx+$156] (used reg = )
07839 1FFE           8B86       FDDE            mov	ax,-$222[bp]
07840 2002           8987       0156            mov	$156[bx],ax
07841                                           !BCC_EOS
07842                                           ! 1728       *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_low)) = (sectors_low);
07843                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07844 2006           8A46         FD            mov	al,-3[bp]
07845 2009           30E4                       xor	ah,ah
07846 200B           B9                   001E  mov	cx,*$1E
07847 200E           F7E9                       imul	cx
07848 2010           89C3                       mov	bx,ax
07849                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
07850                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$158 (used reg = )
07851                                           ! Debug: eq unsigned long sectors_low = [S+$228-$21A] to unsigned long = [bx+$158] (used reg = )
07852 2012           8B86       FDE8            mov	ax,-$218[bp]
07853 2016           8BB6       FDEA            mov	si,-$216[bp]
07854 201A           8987       0158            mov	$158[bx],ax
07855 201E           89B7       015A            mov	$15A[bx],si
07856                                           !BCC_EOS
07857                                           ! 1729       *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high)) = (sectors_high);
07858                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07859 2022           8A46         FD            mov	al,-3[bp]
07860 2025           30E4                       xor	ah,ah
07861 2027           B9                   001E  mov	cx,*$1E
07862 202A           F7E9                       imul	cx
07863 202C           89C3                       mov	bx,ax
07864                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
07865                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
07866                                           ! Debug: eq unsigned long sectors_high = [S+$228-$21E] to unsigned long = [bx+$15C] (used reg = )
07867 202E           8B86       FDE4            mov	ax,-$21C[bp]
07868 2032           8BB6       FDE6            mov	si,-$21A[bp]
07869 2036           8987       015C            mov	$15C[bx],ax
07870 203A           89B7       015E            mov	$15E[bx],si
07871                                           !BCC_EOS
07872                                           ! 1730       bios_printf(4, "ata%d-%d: PCHS=%u/%d/%d translation=", channel, slave,cylinders, heads, spt);
07873                                           ! Debug: list unsigned short spt = [S+$228-$224] (used reg = )
07874 203E           FFB6       FDDE            push	-$222[bp]
07875                                           ! Debug: list unsigned short heads = [S+$22A-$222] (used reg = )
07876 2042           FFB6       FDE0            push	-$220[bp]
07877                                           ! Debug: list unsigned short cylinders = [S+$22C-$220] (used reg = )
07878 2046           FFB6       FDE2            push	-$21E[bp]
07879                                           ! Debug: list unsigned char slave = [S+$22E-$210] (used reg = )
07880 204A           8A86       FDF2            mov	al,-$20E[bp]
07881 204E           30E4                       xor	ah,ah
07882 2050           50                         push	ax
07883                                           ! Debug: list unsigned char channel = [S+$230-$20F] (used reg = )
07884 2051           8A86       FDF3            mov	al,-$20D[bp]
07885 2055           30E4                       xor	ah,ah
07886 2057           50                         push	ax
07887                                           ! Debug: list * char = .1C6+0 (used reg = )
07888 2058           BB                   D79B  mov	bx,#.1C6
07889 205B           53                         push	bx
07890                                           ! Debug: list int = const 4 (used reg = )
07891 205C           B8                   0004  mov	ax,*4
07892 205F           50                         push	ax
07893                                           ! Debug: func () void = bios_printf+0 (used reg = )
07894 2060           E8         E8DB            call	_bios_printf
07895 2063           83C4                   0E  add	sp,*$E
07896                                           !BCC_EOS
07897                                           ! 1731       translation = inb_cmos(0x39 + channel/2);
07898                                           ! Debug: div int = const 2 to unsigned char channel = [S+$228-$20F] (used reg = )
07899 2066           8A86       FDF3            mov	al,-$20D[bp]
07900 206A           30E4                       xor	ah,ah
07901 206C           D1E8                       shr	ax,*1
07902                                           ! Debug: add unsigned int = ax+0 to int = const $39 (used reg = )
07903                                           ! Debug: expression subtree swapping
07904                                           ! Debug: list unsigned int = ax+$39 (used reg = )
07905 206E           05                   0039  add	ax,*$39
07906 2071           50                         push	ax
07907                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
07908 2072           E8         E4C8            call	_inb_cmos
07909 2075           44                         inc	sp
07910 2076           44                         inc	sp
07911                                           ! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$228-$225] (used reg = )
07912 2077           8886       FDDD            mov	-$223[bp],al
07913                                           !BCC_EOS
07914                                           ! 1732       for (shift=device%4; shift>0; shift--) translation >>= 2;
07915                                           ! Debug: mod int = const 4 to unsigned char device = [S+$228-5] (used reg = )
07916 207B           8A46         FD            mov	al,-3[bp]
07917 207E           30E4                       xor	ah,ah
07918 2080           24                     03  and	al,*3
07919                                           ! Debug: eq unsigned char = al+0 to unsigned char shift = [S+$228-$211] (used reg = )
07920 2082           8886       FDF1            mov	-$20F[bp],al
07921                                           !BCC_EOS
07922                                           !BCC_EOS
07923 2086           EB           17            jmp .1C9
07924                       00002088            .1CA:
07925                                           ! Debug: srab int = const 2 to unsigned char translation = [S+$228-$225] (used reg = )
07926 2088           8A86       FDDD            mov	al,-$223[bp]
07927 208C           30E4                       xor	ah,ah
07928 208E           D1E8                       shr	ax,*1
07929 2090           D1E8                       shr	ax,*1
07930 2092           8886       FDDD            mov	-$223[bp],al
07931                                           !BCC_EOS
07932                                           ! 1733       translation &= 0x03;
07933                       00002096            .1C8:
07934                                           ! Debug: postdec unsigned char shift = [S+$228-$211] (used reg = )
07935 2096           8A86       FDF1            mov	al,-$20F[bp]
07936 209A           48                         dec	ax
07937 209B           8886       FDF1            mov	-$20F[bp],al
07938                       0000209F            .1C9:
07939                                           ! Debug: gt int = const 0 to unsigned char shift = [S+$228-$211] (used reg = )
07940 209F           8A86       FDF1            mov	al,-$20F[bp]
07941 20A3           84C0                       test	al,al
07942 20A5           75           E1            jne	.1CA
07943                       000020A7            .1CB:
07944                       000020A7            .1C7:
07945                                           ! Debug: andab int = const 3 to unsigned char translation = [S+$228-$225] (used reg = )
07946 20A7           8A86       FDDD            mov	al,-$223[bp]
07947 20AB           24                     03  and	al,*3
07948 20AD           8886       FDDD            mov	-$223[bp],al
07949                                           !BCC_EOS
07950                                           ! 1734       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].translation)) = (translation);
07951                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
07952 20B1           8A46         FD            mov	al,-3[bp]
07953 20B4           30E4                       xor	ah,ah
07954 20B6           B9                   001E  mov	cx,*$1E
07955 20B9           F7E9                       imul	cx
07956 20BB           89C3                       mov	bx,ax
07957                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
07958                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$14A (used reg = )
07959                                           ! Debug: eq unsigned char translation = [S+$228-$225] to unsigned char = [bx+$14A] (used reg = )
07960 20BD           8A86       FDDD            mov	al,-$223[bp]
07961 20C1           8887       014A            mov	$14A[bx],al
07962                                           !BCC_EOS
07963                                           ! 1735       switch (translation) {
07964 20C5           8A86       FDDD            mov	al,-$223[bp]
07965 20C9           EB           42            jmp .1CE
07966                                           ! 1736         case 0:
07967                                           ! 1737           bios_printf(4, "none");
07968                       000020CB            .1CF:
07969                                           ! Debug: list * char = .1D0+0 (used reg = )
07970 20CB           BB                   D796  mov	bx,#.1D0
07971 20CE           53                         push	bx
07972                                           ! Debug: list int = const 4 (used reg = )
07973 20CF           B8                   0004  mov	ax,*4
07974 20D2           50                         push	ax
07975                                           ! Debug: func () void = bios_printf+0 (used reg = )
07976 20D3           E8         E868            call	_bios_printf
07977 20D6           83C4                   04  add	sp,*4
07978                                           !BCC_EOS
07979                                           ! 1738           break;
07980 20D9           EB           42            jmp .1CC
07981                                           !BCC_EOS
07982                                           ! 1739         case 1:
07983                                           ! 1740           bios_printf(4, "lba");
07984                       000020DB            .1D1:
07985                                           ! Debug: list * char = .1D2+0 (used reg = )
07986 20DB           BB                   D792  mov	bx,#.1D2
07987 20DE           53                         push	bx
07988                                           ! Debug: list int = const 4 (used reg = )
07989 20DF           B8                   0004  mov	ax,*4
07990 20E2           50                         push	ax
07991                                           ! Debug: func () void = bios_printf+0 (used reg = )
07992 20E3           E8         E858            call	_bios_printf
07993 20E6           83C4                   04  add	sp,*4
07994                                           !BCC_EOS
07995                                           ! 1741           break;
07996 20E9           EB           32            jmp .1CC
07997                                           !BCC_EOS
07998                                           ! 1742         case 2:
07999                                           ! 1743           bios_printf(4, "large");
08000                       000020EB            .1D3:
08001                                           ! Debug: list * char = .1D4+0 (used reg = )
08002 20EB           BB                   D78C  mov	bx,#.1D4
08003 20EE           53                         push	bx
08004                                           ! Debug: list int = const 4 (used reg = )
08005 20EF           B8                   0004  mov	ax,*4
08006 20F2           50                         push	ax
08007                                           ! Debug: func () void = bios_printf+0 (used reg = )
08008 20F3           E8         E848            call	_bios_printf
08009 20F6           83C4                   04  add	sp,*4
08010                                           !BCC_EOS
08011                                           ! 1744           break;
08012 20F9           EB           22            jmp .1CC
08013                                           !BCC_EOS
08014                                           ! 1745         case 3:
08015                                           ! 1746           bios_printf(4, "r-echs");
08016                       000020FB            .1D5:
08017                                           ! Debug: list * char = .1D6+0 (used reg = )
08018 20FB           BB                   D785  mov	bx,#.1D6
08019 20FE           53                         push	bx
08020                                           ! Debug: list int = const 4 (used reg = )
08021 20FF           B8                   0004  mov	ax,*4
08022 2102           50                         push	ax
08023                                           ! Debug: func () void = bios_printf+0 (used reg = )
08024 2103           E8         E838            call	_bios_printf
08025 2106           83C4                   04  add	sp,*4
08026                                           !BCC_EOS
08027                                           ! 1747           break;
08028 2109           EB           12            jmp .1CC
08029                                           !BCC_EOS
08030                                           ! 1748       }
08031                                           ! 1749       switch (translation) {
08032 210B           EB           10            jmp .1CC
08033                       0000210D            .1CE:
08034 210D           2C                     00  sub	al,*0
08035 210F           74           BA            je 	.1CF
08036 2111           2C                     01  sub	al,*1
08037 2113           74           C6            je 	.1D1
08038 2115           2C                     01  sub	al,*1
08039 2117           74           D2            je 	.1D3
08040 2119           2C                     01  sub	al,*1
08041 211B           74           DE            je 	.1D5
08042                       0000211D            .1CC:
08043                       FFFFFDD8            ..FFFE	=	-$228
08044 211D           8A86       FDDD            mov	al,-$223[bp]
08045 2121           E9         0161            br 	.1D9
08046                                           ! 1750         case 0:
08047                                           ! 1751           break;
08048                       00002124            .1DA:
08049 2124           E9         0174            br 	.1D7
08050                                           !BCC_EOS
08051                                           ! 1752         case 1:
08052                                           ! 1753           spt = 63;
08053                       00002127            .1DB:
08054                                           ! Debug: eq int = const $3F to unsigned short spt = [S+$228-$224] (used reg = )
08055 2127           B8                   003F  mov	ax,*$3F
08056 212A           8986       FDDE            mov	-$222[bp],ax
08057                                           !BCC_EOS
08058                                           ! 1754           sectors_low /= 63;
08059                                           ! Debug: divab unsigned long = const $3F to unsigned long sectors_low = [S+$228-$21A] (used reg = )
08060 212E           B8                   003F  mov	ax,*$3F
08061 2131           31DB                       xor	bx,bx
08062 2133           53                         push	bx
08063 2134           50                         push	ax
08064 2135           8B86       FDE8            mov	ax,-$218[bp]
08065 2139           8B9E       FDEA            mov	bx,-$216[bp]
08066 213D           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08067 2141           E8         DFFB            call	ldivul
08068 2144           8986       FDE8            mov	-$218[bp],ax
08069 2148           899E       FDEA            mov	-$216[bp],bx
08070 214C           83C4                   04  add	sp,*4
08071                                           !BCC_EOS
08072                                           ! 1755           heads = sectors_low / 1024;
08073                                           ! Debug: div unsigned long = const $400 to unsigned long sectors_low = [S+$228-$21A] (used reg = )
08074 214F           B8                   0400  mov	ax,#$400
08075 2152           31DB                       xor	bx,bx
08076 2154           53                         push	bx
08077 2155           50                         push	ax
08078 2156           8B86       FDE8            mov	ax,-$218[bp]
08079 215A           8B9E       FDEA            mov	bx,-$216[bp]
08080 215E           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08081 2162           E8         DFDA            call	ldivul
08082 2165           83C4                   04  add	sp,*4
08083                                           ! Debug: eq unsigned long = bx+0 to unsigned short heads = [S+$228-$222] (used reg = )
08084 2168           8986       FDE0            mov	-$220[bp],ax
08085                                           !BCC_EOS
08086                                           ! 1756           if (heads>128) heads = 255;
08087                                           ! Debug: gt int = const $80 to unsigned short heads = [S+$228-$222] (used reg = )
08088 216C           8B86       FDE0            mov	ax,-$220[bp]
08089 2170           3D                   0080  cmp	ax,#$80
08090 2173           76           09            jbe 	.1DC
08091                       00002175            .1DD:
08092                                           ! Debug: eq int = const $FF to unsigned short heads = [S+$228-$222] (used reg = )
08093 2175           B8                   00FF  mov	ax,#$FF
08094 2178           8986       FDE0            mov	-$220[bp],ax
08095                                           !BCC_EOS
08096                                           ! 1757           else if (heads>64) heads = 128;
08097 217C           EB           3D            jmp .1DE
08098                       0000217E            .1DC:
08099                                           ! Debug: gt int = const $40 to unsigned short heads = [S+$228-$222] (used reg = )
08100 217E           8B86       FDE0            mov	ax,-$220[bp]
08101 2182           3D                   0040  cmp	ax,*$40
08102 2185           76           09            jbe 	.1DF
08103                       00002187            .1E0:
08104                                           ! Debug: eq int = const $80 to unsigned short heads = [S+$228-$222] (used reg = )
08105 2187           B8                   0080  mov	ax,#$80
08106 218A           8986       FDE0            mov	-$220[bp],ax
08107                                           !BCC_EOS
08108                                           ! 1758           else if (heads>32) heads = 64;
08109 218E           EB           2B            jmp .1E1
08110                       00002190            .1DF:
08111                                           ! Debug: gt int = const $20 to unsigned short heads = [S+$228-$222] (used reg = )
08112 2190           8B86       FDE0            mov	ax,-$220[bp]
08113 2194           3D                   0020  cmp	ax,*$20
08114 2197           76           09            jbe 	.1E2
08115                       00002199            .1E3:
08116                                           ! Debug: eq int = const $40 to unsigned short heads = [S+$228-$222] (used reg = )
08117 2199           B8                   0040  mov	ax,*$40
08118 219C           8986       FDE0            mov	-$220[bp],ax
08119                                           !BCC_EOS
08120                                           ! 1759           else if (heads>16) heads = 32;
08121 21A0           EB           19            jmp .1E4
08122                       000021A2            .1E2:
08123                                           ! Debug: gt int = const $10 to unsigned short heads = [S+$228-$222] (used reg = )
08124 21A2           8B86       FDE0            mov	ax,-$220[bp]
08125 21A6           3D                   0010  cmp	ax,*$10
08126 21A9           76           09            jbe 	.1E5
08127                       000021AB            .1E6:
08128                                           ! Debug: eq int = const $20 to unsigned short heads = [S+$228-$222] (used reg = )
08129 21AB           B8                   0020  mov	ax,*$20
08130 21AE           8986       FDE0            mov	-$220[bp],ax
08131                                           !BCC_EOS
08132                                           ! 1760           else heads=16;
08133 21B2           EB           07            jmp .1E7
08134                       000021B4            .1E5:
08135                                           ! Debug: eq int = const $10 to unsigned short heads = [S+$228-$222] (used reg = )
08136 21B4           B8                   0010  mov	ax,*$10
08137 21B7           8986       FDE0            mov	-$220[bp],ax
08138                                           !BCC_EOS
08139                                           ! 1761           cylinders = sectors_low / heads;
08140                       000021BB            .1E7:
08141                       000021BB            .1E4:
08142                       000021BB            .1E1:
08143                       000021BB            .1DE:
08144                                           ! Debug: cast unsigned long = const 0 to unsigned short heads = [S+$228-$222] (used reg = )
08145 21BB           8B86       FDE0            mov	ax,-$220[bp]
08146 21BF           31DB                       xor	bx,bx
08147                                           ! Debug: div unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$21A] (used reg = )
08148 21C1           53                         push	bx
08149 21C2           50                         push	ax
08150 21C3           8B86       FDE8            mov	ax,-$218[bp]
08151 21C7           8B9E       FDEA            mov	bx,-$216[bp]
08152 21CB           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08153 21CF           E8         DF6D            call	ldivul
08154 21D2           83C4                   04  add	sp,*4
08155                                           ! Debug: eq unsigned long = bx+0 to unsigned short cylinders = [S+$228-$220] (used reg = )
08156 21D5           8986       FDE2            mov	-$21E[bp],ax
08157                                           !BCC_EOS
08158                                           ! 1762           break;
08159 21D9           E9         00BF            br 	.1D7
08160                                           !BCC_EOS
08161                                           ! 1763         case 3:
08162                                           ! 1764           if (heads==16) {
08163                       000021DC            .1E8:
08164                                           ! Debug: logeq int = const $10 to unsigned short heads = [S+$228-$222] (used reg = )
08165 21DC           8B86       FDE0            mov	ax,-$220[bp]
08166 21E0           3D                   0010  cmp	ax,*$10
08167 21E3           75           72            jne 	.1E9
08168                       000021E5            .1EA:
08169                                           ! 1765             if(cylinders>61439) cylinders=61439;
08170                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$220] (used reg = )
08171 21E5           8B86       FDE2            mov	ax,-$21E[bp]
08172 21E9           31DB                       xor	bx,bx
08173                                           ! Debug: gt long = const $EFFF to unsigned long = bx+0 (used reg = )
08174 21EB           53                         push	bx
08175 21EC           50                         push	ax
08176 21ED           B8                   EFFF  mov	ax,#$EFFF
08177 21F0           31DB                       xor	bx,bx
08178 21F2           53                         push	bx
08179 21F3           50                         push	ax
08180 21F4           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08181 21F8           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08182 21FC           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08183 2200           E8         DE99            call	lcmpul
08184 2203           8DA6       FDDA            lea	sp,2+..FFFD[bp]
08185 2207           76           07            jbe 	.1EB
08186                       00002209            .1EC:
08187                                           ! Debug: eq long = const $EFFF to unsigned short cylinders = [S+$228-$220] (used reg = )
08188 2209           B8                   EFFF  mov	ax,#$EFFF
08189 220C           8986       FDE2            mov	-$21E[bp],ax
08190                                           !BCC_EOS
08191                                           ! 1766             heads=15;
08192                       00002210            .1EB:
08193                                           ! Debug: eq int = const $F to unsigned short heads = [S+$228-$222] (used reg = )
08194 2210           B8                   000F  mov	ax,*$F
08195 2213           8986       FDE0            mov	-$220[bp],ax
08196                                           !BCC_EOS
08197                                           ! 1767             cylinders = (Bit16u)((Bit32u)(cy
08198                                           ! 1767 linders)*16/15);
08199                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$220] (used reg = )
08200 2217           8B86       FDE2            mov	ax,-$21E[bp]
08201 221B           31DB                       xor	bx,bx
08202                                           ! Debug: mul unsigned long = const $10 to unsigned long = bx+0 (used reg = )
08203 221D           53                         push	bx
08204 221E           50                         push	ax
08205 221F           B8                   0010  mov	ax,*$10
08206 2222           31DB                       xor	bx,bx
08207 2224           53                         push	bx
08208 2225           50                         push	ax
08209 2226           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08210 222A           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08211 222E           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08212 2232           E8         DE85            call	lmulul
08213 2235           83C4                   08  add	sp,*8
08214                                           ! Debug: div unsigned long = const $F to unsigned long = bx+0 (used reg = )
08215 2238           53                         push	bx
08216 2239           50                         push	ax
08217 223A           B8                   000F  mov	ax,*$F
08218 223D           31DB                       xor	bx,bx
08219 223F           53                         push	bx
08220 2240           50                         push	ax
08221 2241           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08222 2245           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08223 2249           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08224 224D           E8         DEEF            call	ldivul
08225 2250           83C4                   08  add	sp,*8
08226                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
08227                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$220] (used reg = )
08228 2253           8986       FDE2            mov	-$21E[bp],ax
08229                                           !BCC_EOS
08230                                           ! 1768           }
08231                                           ! 1769         case 2:
08232                       00002257            .1E9:
08233                                           ! 1770           while(cylinders > 1024) {
08234                       00002257            .1ED:
08235 2257           EB           1F            jmp .1EF
08236                       00002259            .1F0:
08237                                           ! 1771             cylinders >>= 1;
08238                                           ! Debug: srab int = const 1 to unsigned short cylinders = [S+$228-$220] (used reg = )
08239 2259           8B86       FDE2            mov	ax,-$21E[bp]
08240 225D           D1E8                       shr	ax,*1
08241 225F           8986       FDE2            mov	-$21E[bp],ax
08242                                           !BCC_EOS
08243                                           ! 1772             heads <<= 1;
08244                                           ! Debug: slab int = const 1 to unsigned short heads = [S+$228-$222] (used reg = )
08245 2263           8B86       FDE0            mov	ax,-$220[bp]
08246 2267           D1E0                       shl	ax,*1
08247 2269           8986       FDE0            mov	-$220[bp],ax
08248                                           !BCC_EOS
08249                                           ! 1773             if (heads > 127) break;
08250                                           ! Debug: gt int = const $7F to unsigned short heads = [S+$228-$222] (used reg = )
08251 226D           8B86       FDE0            mov	ax,-$220[bp]
08252 2271           3D                   007F  cmp	ax,*$7F
08253 2274           76           02            jbe 	.1F1
08254                       00002276            .1F2:
08255 2276           EB           09            jmp .1EE
08256                                           !BCC_EOS
08257                                           ! 1774           }
08258                       00002278            .1F1:
08259                                           ! 1775           break;
08260                       00002278            .1EF:
08261                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$220] (used reg = )
08262 2278           8B86       FDE2            mov	ax,-$21E[bp]
08263 227C           3D                   0400  cmp	ax,#$400
08264 227F           77           D8            ja 	.1F0
08265                       00002281            .1F3:
08266                       00002281            .1EE:
08267 2281           EB           18            jmp .1D7
08268                                           !BCC_EOS
08269                                           ! 1776       }
08270                                           ! 1777       if (cylinders > 1024) cylinders=1024;
08271 2283           EB           16            jmp .1D7
08272                       00002285            .1D9:
08273 2285           2C                     00  sub	al,*0
08274 2287         0F84         FE99            beq 	.1DA
08275 228B           2C                     01  sub	al,*1
08276 228D         0F84         FE96            beq 	.1DB
08277 2291           2C                     01  sub	al,*1
08278 2293           74           C2            je 	.1ED
08279 2295           2C                     01  sub	al,*1
08280 2297         0F84         FF41            beq 	.1E8
08281                       0000229B            .1D7:
08282                       FFFFFDD8            ..FFFD	=	-$228
08283                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$220] (used reg = )
08284 229B           8B86       FDE2            mov	ax,-$21E[bp]
08285 229F           3D                   0400  cmp	ax,#$400
08286 22A2           76           07            jbe 	.1F4
08287                       000022A4            .1F5:
08288                                           ! Debug: eq int = const $400 to unsigned short cylinders = [S+$228-$220] (used reg = )
08289 22A4           B8                   0400  mov	ax,#$400
08290 22A7           8986       FDE2            mov	-$21E[bp],ax
08291                                           !BCC_EOS
08292                                           ! 1778       bios_printf(4, " LCHS=%d/%d/%d\n", cylinders, heads, spt);
08293                       000022AB            .1F4:
08294                                           ! Debug: list unsigned short spt = [S+$228-$224] (used reg = )
08295 22AB           FFB6       FDDE            push	-$222[bp]
08296                                           ! Debug: list unsigned short heads = [S+$22A-$222] (used reg = )
08297 22AF           FFB6       FDE0            push	-$220[bp]
08298                                           ! Debug: list unsigned short cylinders = [S+$22C-$220] (used reg = )
08299 22B3           FFB6       FDE2            push	-$21E[bp]
08300                                           ! Debug: list * char = .1F6+0 (used reg = )
08301 22B7           BB                   D775  mov	bx,#.1F6
08302 22BA           53                         push	bx
08303                                           ! Debug: list int = const 4 (used reg = )
08304 22BB           B8                   0004  mov	ax,*4
08305 22BE           50                         push	ax
08306                                           ! Debug: func () void = bios_printf+0 (used reg = )
08307 22BF           E8         E67C            call	_bios_printf
08308 22C2           83C4                   0A  add	sp,*$A
08309                                           !BCC_EOS
08310                                           ! 1779       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.heads)) = (heads);
08311                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
08312 22C5           8A46         FD            mov	al,-3[bp]
08313 22C8           30E4                       xor	ah,ah
08314 22CA           B9                   001E  mov	cx,*$1E
08315 22CD           F7E9                       imul	cx
08316 22CF           89C3                       mov	bx,ax
08317                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
08318                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14C (used reg = )
08319                                           ! Debug: eq unsigned short heads = [S+$228-$222] to unsigned short = [bx+$14C] (used reg = )
08320 22D1           8B86       FDE0            mov	ax,-$220[bp]
08321 22D5           8987       014C            mov	$14C[bx],ax
08322                                           !BCC_EOS
08323                                           ! 1780       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders)) = (cylinders);
08324                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
08325 22D9           8A46         FD            mov	al,-3[bp]
08326 22DC           30E4                       xor	ah,ah
08327 22DE           B9                   001E  mov	cx,*$1E
08328 22E1           F7E9                       imul	cx
08329 22E3           89C3                       mov	bx,ax
08330                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
08331                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14E (used reg = )
08332                                           ! Debug: eq unsigned short cylinders = [S+$228-$220] to unsigned short = [bx+$14E] (used reg = )
08333 22E5           8B86       FDE2            mov	ax,-$21E[bp]
08334 22E9           8987       014E            mov	$14E[bx],ax
08335                                           !BCC_EOS
08336                                           ! 1781       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.spt)) = (spt);
08337                                           ! Debug: ptradd unsigned char device = [S+$228-5] to [8] struct  = const $142 (used reg = )
08338 22ED           8A46         FD            mov	al,-3[bp]
08339 22F0           30E4                       xor	ah,ah
08340 22F2           B9                   001E  mov	cx,*$1E
08341 22F5           F7E9                       imul	cx
08342 22F7           89C3                       mov	bx,ax
08343                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
08344                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$150 (used reg = )
08345                                           ! Debug: eq unsigned short spt = [S+$228-$224] to unsigned short = [bx+$150] (used reg = )
08346 22F9           8B86       FDDE            mov	ax,-$222[bp]
08347 22FD           8987       0150            mov	$150[bx],ax
08348                                           !BCC_EOS
08349                                           ! 1782       *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdidmap[hdcount])) = (device);
08350                                           ! Debug: ptradd unsigned char hdcount = [S+$228-3] to [8] unsigned char = const $233 (used reg = )
08351 2301           8A46         FF            mov	al,-1[bp]
08352 2304           30E4                       xor	ah,ah
08353 2306           89C3                       mov	bx,ax
08354                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
08355                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$233 (used reg = )
08356                                           ! Debug: eq unsigned char device = [S+$228-5] to unsigned char = [bx+$233] (used reg = )
08357 2308           8A46         FD            mov	al,-3[bp]
08358 230B           8887       0233            mov	$233[bx],al
08359                                           !BCC_EOS
08360                                           ! 1783       hdcount++;
08361                                           ! Debug: postinc unsigned char hdcount = [S+$228-3] (used reg = )
08362 230F           8A46         FF            mov	al,-1[bp]
08363 2312           40                         inc	ax
08364 2313           8846         FF            mov	-1[bp],al
08365                                           !BCC_EOS
08366                                           ! 1784     }
08367 2316           83C4                   12  add	sp,*$12
08368                                           ! 1785     if(type == 0x03) {
08369                       00002319            .1BB:
08370                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$216-6] (used reg = )
08371 2319           8A46         FC            mov	al,-4[bp]
08372 231C           3C                     03  cmp	al,*3
08373 231E         0F85         011F            bne 	.1F7
08374                       00002322            .1F8:
08375                                           ! 1786       Bit8u type, removable, mode;
08376                                           !BCC_EOS
08377                                           ! 1787       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device)) = (0x05);
08378 2322           83C4                   FC  add	sp,*-4
08379                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08380 2325           8A46         FD            mov	al,-3[bp]
08381 2328           30E4                       xor	ah,ah
08382 232A           B9                   001E  mov	cx,*$1E
08383 232D           F7E9                       imul	cx
08384 232F           89C3                       mov	bx,ax
08385                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08386                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
08387                                           ! Debug: eq int = const 5 to unsigned char = [bx+$143] (used reg = )
08388 2331           B0                     05  mov	al,*5
08389 2333           8887       0143            mov	$143[bx],al
08390                                           !BCC_EOS
08391                                           ! 1788       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode)) = (0x00);
08392                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08393 2337           8A46         FD            mov	al,-3[bp]
08394 233A           30E4                       xor	ah,ah
08395 233C           B9                   001E  mov	cx,*$1E
08396 233F           F7E9                       imul	cx
08397 2341           89C3                       mov	bx,ax
08398                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08399                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
08400                                           ! Debug: eq int = const 0 to unsigned char = [bx+$146] (used reg = )
08401 2343           30C0                       xor	al,al
08402 2345           8887       0146            mov	$146[bx],al
08403                                           !BCC_EOS
08404                                           ! 1789       if (ata_cmd_data_io(0, device,0xA1, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) != 0)
08405                                           ! Debug: list * unsigned char buffer = S+$21A-$206 (used reg = )
08406 2349           8D9E       FDFC            lea	bx,-$204[bp]
08407 234D           53                         push	bx
08408                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08409 234E           E8         E30E            call	_get_SS
08410                                           ! Debug: list unsigned short = ax+0 (used reg = )
08411 2351           50                         push	ax
08412                                           ! Debug: list long = const 0 (used reg = )
08413 2352           31C0                       xor	ax,ax
08414 2354           31DB                       xor	bx,bx
08415 2356           53                         push	bx
08416 2357           50                         push	ax
08417                                           ! Debug: list long = const 0 (used reg = )
08418 2358           31C0                       xor	ax,ax
08419 235A           31DB                       xor	bx,bx
08420 235C           53                         push	bx
08421 235D           50                         push	ax
08422                                           ! Debug: list int = const 0 (used reg = )
08423 235E           31C0                       xor	ax,ax
08424 2360           50                         push	ax
08425                                           ! Debug: list int = const 0 (used reg = )
08426 2361           31C0                       xor	ax,ax
08427 2363           50                         push	ax
08428                                           ! Debug: list int = const 0 (used reg = )
08429 2364           31C0                       xor	ax,ax
08430 2366           50                         push	ax
08431                                           ! Debug: list int = const 1 (used reg = )
08432 2367           B8                   0001  mov	ax,*1
08433 236A           50                         push	ax
08434                                           ! Debug: list int = const $A1 (used reg = )
08435 236B           B8                   00A1  mov	ax,#$A1
08436 236E           50                         push	ax
08437                                           ! Debug: list unsigned char device = [S+$230-5] (used reg = )
08438 236F           8A46         FD            mov	al,-3[bp]
08439 2372           30E4                       xor	ah,ah
08440 2374           50                         push	ax
08441                                           ! Debug: list int = const 0 (used reg = )
08442 2375           31C0                       xor	ax,ax
08443 2377           50                         push	ax
08444                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
08445 2378           E8         060A            call	_ata_cmd_data_io
08446 237B           83C4                   1A  add	sp,*$1A
08447                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
08448 237E           85C0                       test	ax,ax
08449 2380           74           0E            je  	.1F9
08450                       00002382            .1FA:
08451                                           ! 1790         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATAPI device\n");
08452                                           ! Debug: list * char = .1FB+0 (used reg = )
08453 2382           BB                   D74A  mov	bx,#.1FB
08454 2385           53                         push	bx
08455                                           ! Debug: list int = const 7 (used reg = )
08456 2386           B8                   0007  mov	ax,*7
08457 2389           50                         push	ax
08458                                           ! Debug: func () void = bios_printf+0 (used reg = )
08459 238A           E8         E5B1            call	_bios_printf
08460 238D           83C4                   04  add	sp,*4
08461                                           !BCC_EOS
08462                                           ! 1791       type = read_byte_SS(buffer+1) & 0x1f;
08463                       00002390            .1F9:
08464                                           ! Debug: list * unsigned char buffer = S+$21A-$205 (used reg = )
08465 2390           8D9E       FDFD            lea	bx,-$203[bp]
08466 2394           53                         push	bx
08467                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08468 2395           E8         E28E            call	_read_byte_SS
08469 2398           44                         inc	sp
08470 2399           44                         inc	sp
08471                                           ! Debug: and int = const $1F to unsigned char = al+0 (used reg = )
08472 239A           24                     1F  and	al,*$1F
08473                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$21A-$217] (used reg = )
08474 239C           8886       FDEB            mov	-$215[bp],al
08475                                           !BCC_EOS
08476                                           ! 1792       removable = (read_byte_SS(buffer+0) & 0x80) ? 1 : 0;
08477                                           ! Debug: list * unsigned char buffer = S+$21A-$206 (used reg = )
08478 23A0           8D9E       FDFC            lea	bx,-$204[bp]
08479 23A4           53                         push	bx
08480                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08481 23A5           E8         E27E            call	_read_byte_SS
08482 23A8           44                         inc	sp
08483 23A9           44                         inc	sp
08484                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
08485 23AA           24                     80  and	al,#$80
08486 23AC           84C0                       test	al,al
08487 23AE           74           04            je  	.1FC
08488                       000023B0            .1FD:
08489 23B0           B0                     01  mov	al,*1
08490 23B2           EB           02            jmp .1FE
08491                       000023B4            .1FC:
08492 23B4           30C0                       xor	al,al
08493                       000023B6            .1FE:
08494                                           ! Debug: eq char = al+0 to unsigned char removable = [S+$21A-$218] (used reg = )
08495 23B6           8886       FDEA            mov	-$216[bp],al
08496                                           !BCC_EOS
08497                                           ! 1793       mode = read_byte_SS(buffer+96) ? 0x01 : 0x00;
08498                                           ! Debug: list * unsigned char buffer = S+$21A-$1A6 (used reg = )
08499 23BA           8D9E       FE5C            lea	bx,-$1A4[bp]
08500 23BE           53                         push	bx
08501                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08502 23BF           E8         E264            call	_read_byte_SS
08503 23C2           44                         inc	sp
08504 23C3           44                         inc	sp
08505 23C4           84C0                       test	al,al
08506 23C6           74           04            je  	.1FF
08507                       000023C8            .200:
08508 23C8           B0                     01  mov	al,*1
08509 23CA           EB           02            jmp .201
08510                       000023CC            .1FF:
08511 23CC           30C0                       xor	al,al
08512                       000023CE            .201:
08513                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$21A-$219] (used reg = )
08514 23CE           8886       FDE9            mov	-$217[bp],al
08515                                           !BCC_EOS
08516                                           ! 1794       blksize = 2048;
08517                                           ! Debug: eq int = const $800 to unsigned short blksize = [S+$21A-$20E] (used reg = )
08518 23D2           B8                   0800  mov	ax,#$800
08519 23D5           8986       FDF4            mov	-$20C[bp],ax
08520                                           !BCC_EOS
08521                                           ! 1795       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device)) = (type);
08522                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08523 23D9           8A46         FD            mov	al,-3[bp]
08524 23DC           30E4                       xor	ah,ah
08525 23DE           B9                   001E  mov	cx,*$1E
08526 23E1           F7E9                       imul	cx
08527 23E3           89C3                       mov	bx,ax
08528                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08529                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
08530                                           ! Debug: eq unsigned char type = [S+$21A-$217] to unsigned char = [bx+$143] (used reg = )
08531 23E5           8A86       FDEB            mov	al,-$215[bp]
08532 23E9           8887       0143            mov	$143[bx],al
08533                                           !BCC_EOS
08534                                           ! 1796       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].removable)) = (removable);
08535                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08536 23ED           8A46         FD            mov	al,-3[bp]
08537 23F0           30E4                       xor	ah,ah
08538 23F2           B9                   001E  mov	cx,*$1E
08539 23F5           F7E9                       imul	cx
08540 23F7           89C3                       mov	bx,ax
08541                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
08542                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$144 (used reg = )
08543                                           ! Debug: eq unsigned char removable = [S+$21A-$218] to unsigned char = [bx+$144] (used reg = )
08544 23F9           8A86       FDEA            mov	al,-$216[bp]
08545 23FD           8887       0144            mov	$144[bx],al
08546                                           !BCC_EOS
08547                                           ! 1797       *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode)) = (mode);
08548                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08549 2401           8A46         FD            mov	al,-3[bp]
08550 2404           30E4                       xor	ah,ah
08551 2406           B9                   001E  mov	cx,*$1E
08552 2409           F7E9                       imul	cx
08553 240B           89C3                       mov	bx,ax
08554                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08555                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
08556                                           ! Debug: eq unsigned char mode = [S+$21A-$219] to unsigned char = [bx+$146] (used reg = )
08557 240D           8A86       FDE9            mov	al,-$217[bp]
08558 2411           8887       0146            mov	$146[bx],al
08559                                           !BCC_EOS
08560                                           ! 1798       *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].blksize)) = (blksize);
08561                                           ! Debug: ptradd unsigned char device = [S+$21A-5] to [8] struct  = const $142 (used reg = )
08562 2415           8A46         FD            mov	al,-3[bp]
08563 2418           30E4                       xor	ah,ah
08564 241A           B9                   001E  mov	cx,*$1E
08565 241D           F7E9                       imul	cx
08566 241F           89C3                       mov	bx,ax
08567                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
08568                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$148 (used reg = )
08569                                           ! Debug: eq unsigned short blksize = [S+$21A-$20E] to unsigned short = [bx+$148] (used reg = )
08570 2421           8B86       FDF4            mov	ax,-$20C[bp]
08571 2425           8987       0148            mov	$148[bx],ax
08572                                           !BCC_EOS
08573                                           ! 1799       *((Bit8u *)(&((ebda_data_t *) 0)->ata.cdidmap[cdcount])) = (device);
08574                                           ! Debug: ptradd unsigned char cdcount = [S+$21A-4] to [8] unsigned char = const $23C (used reg = )
08575 2429           8A46         FE            mov	al,-2[bp]
08576 242C           30E4                       xor	ah,ah
08577 242E           89C3                       mov	bx,ax
08578                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
08579                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$23C (used reg = )
08580                                           ! Debug: eq unsigned char device = [S+$21A-5] to unsigned char = [bx+$23C] (used reg = )
08581 2430           8A46         FD            mov	al,-3[bp]
08582 2433           8887       023C            mov	$23C[bx],al
08583                                           !BCC_EOS
08584                                           ! 1800       cdcount++;
08585                                           ! Debug: postinc unsigned char cdcount = [S+$21A-4] (used reg = )
08586 2437           8A46         FE            mov	al,-2[bp]
08587 243A           40                         inc	ax
08588 243B           8846         FE            mov	-2[bp],al
08589                                           !BCC_EOS
08590                                           ! 1801     }
08591 243E           83C4                   04  add	sp,*4
08592                                           ! 1802     {
08593                       00002441            .1F7:
08594                                           ! 1803       Bit32u sizeinmb;
08595                                           !BCC_EOS
08596                                           ! 1804       Bit16u ataversion;
08597                                           !BCC_EOS
08598                                           ! 1805       Bit8u c, i, lshift, rshift, version, model[41];
08599                                           !BCC_EOS
08600                                           ! 1806       switch (type) {
08601 2441           83C4                   CC  add	sp,*-$34
08602 2444           8A46         FC            mov	al,-4[bp]
08603 2447           E9         0213            br 	.204
08604                                           ! 1807         case 0x02:
08605                                           ! 1808           switch (blksize) {
08606                       0000244A            .205:
08607 244A           8B86       FDF4            mov	ax,-$20C[bp]
08608 244E           EB           2A            jmp .208
08609                                           ! 1809             case 1024:
08610                                           ! 1810               lshift = 22;
08611                       00002450            .209:
08612                                           ! Debug: eq int = const $16 to unsigned char lshift = [S+$24A-$21F] (used reg = )
08613 2450           B0                     16  mov	al,*$16
08614 2452           8886       FDE3            mov	-$21D[bp],al
08615                                           !BCC_EOS
08616                                           ! 1811               rshift = 10;
08617                                           ! Debug: eq int = const $A to unsigned char rshift = [S+$24A-$220] (used reg = )
08618 2456           B0                     0A  mov	al,*$A
08619 2458           8886       FDE2            mov	-$21E[bp],al
08620                                           !BCC_EOS
08621                                           ! 1812               break;
08622 245C           EB           28            jmp .206
08623                                           !BCC_EOS
08624                                           ! 1813             case 4096:
08625                                           ! 1814               lshift = 24;
08626                       0000245E            .20A:
08627                                           ! Debug: eq int = const $18 to unsigned char lshift = [S+$24A-$21F] (used reg = )
08628 245E           B0                     18  mov	al,*$18
08629 2460           8886       FDE3            mov	-$21D[bp],al
08630                                           !BCC_EOS
08631                                           ! 1815               rshift = 8;
08632                                           ! Debug: eq int = const 8 to unsigned char rshift = [S+$24A-$220] (used reg = )
08633 2464           B0                     08  mov	al,*8
08634 2466           8886       FDE2            mov	-$21E[bp],al
08635                                           !BCC_EOS
08636                                           ! 1816               break;
08637 246A           EB           1A            jmp .206
08638                                           !BCC_EOS
08639                                           ! 1817             default
08640                                           ! 1817 :
08641                                           ! 1818               lshift = 21;
08642                       0000246C            .20B:
08643                                           ! Debug: eq int = const $15 to unsigned char lshift = [S+$24A-$21F] (used reg = )
08644 246C           B0                     15  mov	al,*$15
08645 246E           8886       FDE3            mov	-$21D[bp],al
08646                                           !BCC_EOS
08647                                           ! 1819               rshift = 11;
08648                                           ! Debug: eq int = const $B to unsigned char rshift = [S+$24A-$220] (used reg = )
08649 2472           B0                     0B  mov	al,*$B
08650 2474           8886       FDE2            mov	-$21E[bp],al
08651                                           !BCC_EOS
08652                                           ! 1820           }
08653                                           ! 1821           sizeinmb = (*((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high)) << lshift)
08654 2478           EB           0C            jmp .206
08655                       0000247A            .208:
08656 247A           2D                   0400  sub	ax,#$400
08657 247D           74           D1            je 	.209
08658 247F           2D                   0C00  sub	ax,#$C00
08659 2482           74           DA            je 	.20A
08660 2484           EB           E6            jmp	.20B
08661                       00002486            .206:
08662                                           ! 1822             | (*((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_low)) >> rshift);
08663                                           ! Debug: ptradd unsigned char device = [S+$24A-5] to [8] struct  = const $142 (used reg = )
08664 2486           8A46         FD            mov	al,-3[bp]
08665 2489           30E4                       xor	ah,ah
08666 248B           B9                   001E  mov	cx,*$1E
08667 248E           F7E9                       imul	cx
08668 2490           89C3                       mov	bx,ax
08669                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
08670                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$158 (used reg = )
08671                                           ! Debug: sr unsigned char rshift = [S+$24A-$220] to unsigned long = [bx+$158] (used reg = )
08672 2492           8A86       FDE2            mov	al,-$21E[bp]
08673 2496           50                         push	ax
08674 2497           8B87       0158            mov	ax,$158[bx]
08675 249B           8B9F       015A            mov	bx,$15A[bx]
08676 249F           8A8E       FDB6            mov	cl,0+..FFFC[bp]
08677 24A3           30ED                       xor	ch,ch
08678 24A5           89CF                       mov	di,cx
08679 24A7           E8         DC50            call	lsrul
08680 24AA           44                         inc	sp
08681 24AB           44                         inc	sp
08682 24AC           53                         push	bx
08683 24AD           50                         push	ax
08684                                           ! Debug: ptradd unsigned char device = [S+$24E-5] to [8] struct  = const $142 (used reg = )
08685 24AE           8A46         FD            mov	al,-3[bp]
08686 24B1           30E4                       xor	ah,ah
08687 24B3           B9                   001E  mov	cx,*$1E
08688 24B6           F7E9                       imul	cx
08689 24B8           89C3                       mov	bx,ax
08690                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
08691                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
08692                                           ! Debug: sl unsigned char lshift = [S+$24E-$21F] to unsigned long = [bx+$15C] (used reg = )
08693 24BA           8A86       FDE3            mov	al,-$21D[bp]
08694 24BE           50                         push	ax
08695 24BF           8B87       015C            mov	ax,$15C[bx]
08696 24C3           8B9F       015E            mov	bx,$15E[bx]
08697 24C7           8A8E       FDB2            mov	cl,-4+..FFFC[bp]
08698 24CB           30ED                       xor	ch,ch
08699 24CD           89CF                       mov	di,cx
08700 24CF           E8         DC46            call	lslul
08701 24D2           44                         inc	sp
08702 24D3           44                         inc	sp
08703                                           ! Debug: or unsigned long (temp) = [S+$24E-$24E] to unsigned long = bx+0 (used reg = )
08704 24D4           8DBE       FDB4            lea	di,-2+..FFFC[bp]
08705 24D8           E8         DBFD            call	lorul
08706 24DB           83C4                   04  add	sp,*4
08707                                           ! Debug: eq unsigned long = bx+0 to unsigned long sizeinmb = [S+$24A-$21A] (used reg = )
08708 24DE           8986       FDE8            mov	-$218[bp],ax
08709 24E2           899E       FDEA            mov	-$216[bp],bx
08710                                           !BCC_EOS
08711                                           ! 1823         case 0x03:
08712                                           ! 1824           ataversion=((Bit16u)(read_byte_SS(buffer+161))<<8)|read_byte_SS(buffer+160);
08713                       000024E6            .20C:
08714                                           ! Debug: list * unsigned char buffer = S+$24A-$166 (used reg = )
08715 24E6           8D9E       FE9C            lea	bx,-$164[bp]
08716 24EA           53                         push	bx
08717                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08718 24EB           E8         E138            call	_read_byte_SS
08719 24EE           44                         inc	sp
08720 24EF           44                         inc	sp
08721 24F0           50                         push	ax
08722                                           ! Debug: list * unsigned char buffer = S+$24C-$165 (used reg = )
08723 24F1           8D9E       FE9D            lea	bx,-$163[bp]
08724 24F5           53                         push	bx
08725                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08726 24F6           E8         E12D            call	_read_byte_SS
08727 24F9           44                         inc	sp
08728 24FA           44                         inc	sp
08729                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
08730 24FB           30E4                       xor	ah,ah
08731                                           ! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
08732 24FD           88C4                       mov	ah,al
08733 24FF           30C0                       xor	al,al
08734                                           ! Debug: or unsigned char (temp) = [S+$24C-$24C] to unsigned int = ax+0 (used reg = )
08735 2501           0A86       FDB6            or	al,0+..FFFC[bp]
08736 2505           44                         inc	sp
08737 2506           44                         inc	sp
08738                                           ! Debug: eq unsigned int = ax+0 to unsigned short ataversion = [S+$24A-$21C] (used reg = )
08739 2507           8986       FDE6            mov	-$21A[bp],ax
08740                                           !BCC_EOS
08741                                           ! 1825           for(version=15;version>0;version--) {
08742                                           ! Debug: eq int = const $F to unsigned char version = [S+$24A-$221] (used reg = )
08743 250B           B0                     0F  mov	al,*$F
08744 250D           8886       FDE1            mov	-$21F[bp],al
08745                                           !BCC_EOS
08746                                           !BCC_EOS
08747 2511           EB           22            jmp .20F
08748                       00002513            .210:
08749                                           ! 1826             if((ataversion&(1<<version))!=0)
08750                                           ! Debug: sl unsigned char version = [S+$24A-$221] to int = const 1 (used reg = )
08751 2513           8A86       FDE1            mov	al,-$21F[bp]
08752 2517           30E4                       xor	ah,ah
08753 2519           89C3                       mov	bx,ax
08754 251B           B8                   0001  mov	ax,*1
08755 251E           89D9                       mov	cx,bx
08756 2520           D3E0                       shl	ax,cl
08757                                           ! Debug: and int = ax+0 to unsigned short ataversion = [S+$24A-$21C] (used reg = )
08758                                           ! Debug: expression subtree swapping
08759 2522           2386       FDE6            and	ax,-$21A[bp]
08760                                           ! Debug: ne int = const 0 to unsigned int = ax+0 (used reg = )
08761 2526           85C0                       test	ax,ax
08762 2528           74           02            je  	.211
08763                       0000252A            .212:
08764                                           ! 1827             break;
08765 252A           EB           11            jmp .20D
08766                                           !BCC_EOS
08767                                           ! 1828           }
08768                       0000252C            .211:
08769                                           ! 1829           for(i=0;i<20;i++) {
08770                       0000252C            .20E:
08771                                           ! Debug: postdec unsigned char version = [S+$24A-$221] (used reg = )
08772 252C           8A86       FDE1            mov	al,-$21F[bp]
08773 2530           48                         dec	ax
08774 2531           8886       FDE1            mov	-$21F[bp],al
08775                       00002535            .20F:
08776                                           ! Debug: gt int = const 0 to unsigned char version = [S+$24A-$221] (used reg = )
08777 2535           8A86       FDE1            mov	al,-$21F[bp]
08778 2539           84C0                       test	al,al
08779 253B           75           D6            jne	.210
08780                       0000253D            .213:
08781                       0000253D            .20D:
08782                                           ! Debug: eq int = const 0 to unsigned char i = [S+$24A-$21E] (used reg = )
08783 253D           30C0                       xor	al,al
08784 253F           8886       FDE4            mov	-$21C[bp],al
08785                                           !BCC_EOS
08786                                           !BCC_EOS
08787 2543           EB           69            jmp .216
08788                       00002545            .217:
08789                                           ! 1830             _write_byte_SS(read_byte_SS(buffer+(i*2)+54+1), model+(i*2));
08790                                           ! Debug: mul int = const 2 to unsigned char i = [S+$24A-$21E] (used reg = )
08791 2545           8A86       FDE4            mov	al,-$21C[bp]
08792 2549           30E4                       xor	ah,ah
08793 254B           D1E0                       shl	ax,*1
08794                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$24A-$24A (used reg = )
08795 254D           89EB                       mov	bx,bp
08796 254F           01C3                       add	bx,ax
08797                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
08798                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
08799 2551           81C3                 FDB8  add	bx,#-$248
08800 2555           53                         push	bx
08801                                           ! Debug: mul int = const 2 to unsigned char i = [S+$24C-$21E] (used reg = )
08802 2556           8A86       FDE4            mov	al,-$21C[bp]
08803 255A           30E4                       xor	ah,ah
08804 255C           D1E0                       shl	ax,*1
08805                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$24C-$206 (used reg = )
08806 255E           89EB                       mov	bx,bp
08807 2560           01C3                       add	bx,ax
08808                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$204 (used reg = )
08809                                           ! Debug: ptradd int = const 1 to [$200] unsigned char = bx-$1CE (used reg = )
08810                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1CD (used reg = )
08811                                           ! Debug: list * unsigned char = bx-$1CD (used reg = )
08812 2562           81C3                 FE33  add	bx,#-$1CD
08813 2566           53                         push	bx
08814                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08815 2567           E8         E0BC            call	_read_byte_SS
08816 256A           44                         inc	sp
08817 256B           44                         inc	sp
08818                                           ! Debug: list unsigned char = al+0 (used reg = )
08819 256C           30E4                       xor	ah,ah
08820 256E           50                         push	ax
08821                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08822 256F           E8         E0CA            call	__write_byte_SS
08823 2572           83C4                   04  add	sp,*4
08824                                           !BCC_EOS
08825                                           ! 1831             _write_byte_SS(read_byte_SS(buffer+(i*2)+54), model+(i*2)+1);
08826                                           ! Debug: mul int = const 2 to unsigned char i = [S+$24A-$21E] (used reg = )
08827 2575           8A86       FDE4            mov	al,-$21C[bp]
08828 2579           30E4                       xor	ah,ah
08829 257B           D1E0                       shl	ax,*1
08830                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$24A-$24A (used reg = )
08831 257D           89EB                       mov	bx,bp
08832 257F           01C3                       add	bx,ax
08833                                           ! Debug: ptradd int = const 1 to [$29] unsigned char = bx-$248 (used reg = )
08834                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$247 (used reg = )
08835                                           ! Debug: list * unsigned char = bx-$247 (used reg = )
08836 2581           81C3                 FDB9  add	bx,#-$247
08837 2585           53                         push	bx
08838                                           ! Debug: mul int = const 2 to unsigned char i = [S+$24C-$21E] (used reg = )
08839 2586           8A86       FDE4            mov	al,-$21C[bp]
08840 258A           30E4                       xor	ah,ah
08841 258C           D1E0                       shl	ax,*1
08842                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$24C-$206 (used reg = )
08843 258E           89EB                       mov	bx,bp
08844 2590           01C3                       add	bx,ax
08845                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$204 (used reg = )
08846                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1CE (used reg = )
08847                                           ! Debug: list * unsigned char = bx-$1CE (used reg = )
08848 2592           81C3                 FE32  add	bx,#-$1CE
08849 2596           53                         push	bx
08850                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08851 2597           E8         E08C            call	_read_byte_SS
08852 259A           44                         inc	sp
08853 259B           44                         inc	sp
08854                                           ! Debug: list unsigned char = al+0 (used reg = )
08855 259C           30E4                       xor	ah,ah
08856 259E           50                         push	ax
08857                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08858 259F           E8         E09A            call	__write_byte_SS
08859 25A2           83C4                   04  add	sp,*4
08860                                           !BCC_EOS
08861                                           ! 1832           }
08862                                           ! 1833           _write_byte_SS(0x00, model+40);
08863                       000025A5            .215:
08864                                           ! Debug: postinc unsigned char i = [S+$24A-$21E] (used reg = )
08865 25A5           8A86       FDE4            mov	al,-$21C[bp]
08866 25A9           40                         inc	ax
08867 25AA           8886       FDE4            mov	-$21C[bp],al
08868                       000025AE            .216:
08869                                           ! Debug: lt int = const $14 to unsigned char i = [S+$24A-$21E] (used reg = )
08870 25AE           8A86       FDE4            mov	al,-$21C[bp]
08871 25B2           3C                     14  cmp	al,*$14
08872 25B4           72           8F            jb 	.217
08873                       000025B6            .218:
08874                       000025B6            .214:
08875                                           ! Debug: list * unsigned char model = S+$24A-$222 (used reg = )
08876 25B6           8D9E       FDE0            lea	bx,-$220[bp]
08877 25BA           53                         push	bx
08878                                           ! Debug: list int = const 0 (used reg = )
08879 25BB           31C0                       xor	ax,ax
08880 25BD           50                         push	ax
08881                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08882 25BE           E8         E07B            call	__write_byte_SS
08883 25C1           83C4                   04  add	sp,*4
08884                                           !BCC_EOS
08885                                           ! 1834           for(i=39;i>0;i--){
08886                                           ! Debug: eq int = const $27 to unsigned char i = [S+$24A-$21E] (used reg = )
08887 25C4           B0                     27  mov	al,*$27
08888 25C6           8886       FDE4            mov	-$21C[bp],al
08889                                           !BCC_EOS
08890                                           !BCC_EOS
08891 25CA           EB           3D            jmp .21B
08892                       000025CC            .21C:
08893                                           ! 1835             if(read_byte_SS(model+i)==0x20)
08894                                           ! Debug: ptradd unsigned char i = [S+$24A-$21E] to [$29] unsigned char model = S+$24A-$24A (used reg = )
08895 25CC           8A86       FDE4            mov	al,-$21C[bp]
08896 25D0           30E4                       xor	ah,ah
08897 25D2           89EB                       mov	bx,bp
08898 25D4           01C3                       add	bx,ax
08899                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
08900                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
08901 25D6           81C3                 FDB8  add	bx,#-$248
08902 25DA           53                         push	bx
08903                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
08904 25DB           E8         E048            call	_read_byte_SS
08905 25DE           44                         inc	sp
08906 25DF           44                         inc	sp
08907                                           ! Debug: logeq int = const $20 to unsigned char = al+0 (used reg = )
08908 25E0           3C                     20  cmp	al,*$20
08909 25E2           75           1A            jne 	.21D
08910                       000025E4            .21E:
08911                                           ! 1836               _write_byte_SS(0x00, model+i);
08912                                           ! Debug: ptradd unsigned char i = [S+$24A-$21E] to [$29] unsigned char model = S+$24A-$24A (used reg = )
08913 25E4           8A86       FDE4            mov	al,-$21C[bp]
08914 25E8           30E4                       xor	ah,ah
08915 25EA           89EB                       mov	bx,bp
08916 25EC           01C3                       add	bx,ax
08917                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
08918                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
08919 25EE           81C3                 FDB8  add	bx,#-$248
08920 25F2           53                         push	bx
08921                                           ! Debug: list int = const 0 (used reg = )
08922 25F3           31C0                       xor	ax,ax
08923 25F5           50                         push	ax
08924                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08925 25F6           E8         E043            call	__write_byte_SS
08926 25F9           83C4                   04  add	sp,*4
08927                                           !BCC_EOS
08928                                           ! 1837             else break;
08929 25FC           EB           02            jmp .21F
08930                       000025FE            .21D:
08931 25FE           EB           11            jmp .219
08932                                           !BCC_EOS
08933                                           ! 1838           }
08934                       00002600            .21F:
08935                                           ! 1839           if (i>36) {
08936                       00002600            .21A:
08937                                           ! Debug: postdec unsigned char i = [S+$24A-$21E] (used reg = )
08938 2600           8A86       FDE4            mov	al,-$21C[bp]
08939 2604           48                         dec	ax
08940 2605           8886       FDE4            mov	-$21C[bp],al
08941                       00002609            .21B:
08942                                           ! Debug: gt int = const 0 to unsigned char i = [S+$24A-$21E] (used reg = )
08943 2609           8A86       FDE4            mov	al,-$21C[bp]
08944 260D           84C0                       test	al,al
08945 260F           75           BB            jne	.21C
08946                       00002611            .220:
08947                       00002611            .219:
08948                                           ! Debug: gt int = const $24 to unsigned char i = [S+$24A-$21E] (used reg = )
08949 2611           8A86       FDE4            mov	al,-$21C[bp]
08950 2615           3C                     24  cmp	al,*$24
08951 2617           76           40            jbe 	.221
08952                       00002619            .222:
08953                                           ! 1840             _write_byte_SS(0x00, model+36);
08954                                           ! Debug: list * unsigned char model = S+$24A-$226 (used reg = )
08955 2619           8D9E       FDDC            lea	bx,-$224[bp]
08956 261D           53                         push	bx
08957                                           ! Debug: list int = const 0 (used reg = )
08958 261E           31C0                       xor	ax,ax
08959 2620           50                         push	ax
08960                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08961 2621           E8         E018            call	__write_byte_SS
08962 2624           83C4                   04  add	sp,*4
08963                                           !BCC_EOS
08964                                           ! 1841             for(i=35;i>32;i--){
08965                                           ! Debug: eq int = const $23 to unsigned char i = [S+$24A-$21E] (used reg = )
08966 2627           B0                     23  mov	al,*$23
08967 2629           8886       FDE4            mov	-$21C[bp],al
08968                                           !BCC_EOS
08969                                           !BCC_EOS
08970 262D           EB           22            jmp .225
08971                       0000262F            .226:
08972                                           ! 1842               _write_byte_SS(0x2E, model+i);
08973                                           ! Debug: ptradd unsigned char i = [S+$24A-$21E] to [$29] unsigned char model = S+$24A-$24A (used reg = )
08974 262F           8A86       FDE4            mov	al,-$21C[bp]
08975 2633           30E4                       xor	ah,ah
08976 2635           89EB                       mov	bx,bp
08977 2637           01C3                       add	bx,ax
08978                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
08979                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
08980 2639           81C3                 FDB8  add	bx,#-$248
08981 263D           53                         push	bx
08982                                           ! Debug: list int = const $2E (used reg = )
08983 263E           B8                   002E  mov	ax,*$2E
08984 2641           50                         push	ax
08985                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
08986 2642           E8         DFF7            call	__write_byte_SS
08987 2645           83C4                   04  add	sp,*4
08988                                           !BCC_EOS
08989                                           ! 1843             }
08990                                           ! 1844           }
08991                       00002648            .224:
08992                                           ! Debug: postdec unsigned char i = [S+$24A-$21E] (used reg = )
08993 2648           8A86       FDE4            mov	al,-$21C[bp]
08994 264C           48                         dec	ax
08995 264D           8886       FDE4            mov	-$21C[bp],al
08996                       00002651            .225:
08997                                           ! Debug: gt int = const $20 to unsigned char i = [S+$24A-$21E] (used reg = )
08998 2651           8A86       FDE4            mov	al,-$21C[bp]
08999 2655           3C                     20  cmp	al,*$20
09000 2657           77           D6            ja 	.226
09001                       00002659            .227:
09002                       00002659            .223:
09003                                           ! 1845           break;
09004                       00002659            .221:
09005 2659           EB           0E            jmp .202
09006                                           !BCC_EOS
09007                                           ! 1846       }
09008                                           ! 1847       switch (type) {
09009 265B           EB           0C            jmp .202
09010                       0000265D            .204:
09011 265D           2C                     02  sub	al,*2
09012 265F         0F84         FDE7            beq 	.205
09013 2663           2C                     01  sub	al,*1
09014 2665         0F84         FE7D            beq 	.20C
09015                       00002669            .202:
09016                       FFFFFDB6            ..FFFC	=	-$24A
09017 2669           8A46         FC            mov	al,-4[bp]
09018 266C           E9         018E            br 	.22A
09019                                           ! 1848         case 0x02:
09020                                           ! 1849           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
09021                       0000266F            .22B:
09022 266F           8A86       FDF2            mov	al,-$20E[bp]
09023 2673           84C0                       test	al,al
09024 2675           74           05            je  	.22F
09025                       00002677            .230:
09026 2677           BB                   D738  mov	bx,#.22D
09027 267A           EB           03            jmp .231
09028                       0000267C            .22F:
09029 267C           BB                   D731  mov	bx,#.22E
09030                       0000267F            .231:
09031                                           ! Debug: list * char = bx+0 (used reg = )
09032 267F           53                         push	bx
09033                                           ! Debug: list unsigned char channel = [S+$24C-$20F] (used reg = )
09034 2680           8A86       FDF3            mov	al,-$20D[bp]
09035 2684           30E4                       xor	ah,ah
09036 2686           50                         push	ax
09037                                           ! Debug: list * char = .22C+0 (used reg = )
09038 2687           BB                   D73F  mov	bx,#.22C
09039 268A           53                         push	bx
09040                                           ! Debug: list int = const 2 (used reg = )
09041 268B           B8                   0002  mov	ax,*2
09042 268E           50                         push	ax
09043                                           ! Debug: func () void = bios_printf+0 (used reg = )
09044 268F           E8         E2AC            call	_bios_printf
09045 2692           83C4                   08  add	sp,*8
09046                                           !BCC_EOS
09047                                           ! 1850           i=0;
09048                                           ! Debug: eq int = const 0 to unsigned char i = [S+$24A-$21E] (used reg = )
09049 2695           30C0                       xor	al,al
09050 2697           8886       FDE4            mov	-$21C[bp],al
09051                                           !BCC_EOS
09052                                           ! 1851           while(c=read_byte_SS(model+i++))
09053                                           ! 1852             bios_printf(2, "%c",c);
09054 269B           EB           15            jmp .233
09055                       0000269D            .234:
09056                                           ! Debug: list unsigned char c = [S+$24A-$21D] (used reg = )
09057 269D           8A86       FDE5            mov	al,-$21B[bp]
09058 26A1           30E4                       xor	ah,ah
09059 26A3           50                         push	ax
09060                                           ! Debug: list * char = .235+0 (used reg = )
09061 26A4           BB                   D72E  mov	bx,#.235
09062 26A7           53                         push	bx
09063                                           ! Debug: list int = const 2 (used reg = )
09064 26A8           B8                   0002  mov	ax,*2
09065 26AB           50                         push	ax
09066                                           ! Debug: func () void = bios_printf+0 (used reg = )
09067 26AC           E8         E28F            call	_bios_printf
09068 26AF           83C4                   06  add	sp,*6
09069                                           !BCC_EOS
09070                                           ! 1853           if (sizeinmb < (1UL<<16))
09071                       000026B2            .233:
09072                                           ! Debug: postinc unsigned char i = [S+$24A-$21E] (used reg = )
09073 26B2           8A86       FDE4            mov	al,-$21C[bp]
09074 26B6           40                         inc	ax
09075 26B7           8886       FDE4            mov	-$21C[bp],al
09076                                           ! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$24A-$24A (used reg = )
09077 26BB           48                         dec	ax
09078 26BC           30E4                       xor	ah,ah
09079 26BE           89EB                       mov	bx,bp
09080 26C0           01C3                       add	bx,ax
09081                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
09082                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
09083 26C2           81C3                 FDB8  add	bx,#-$248
09084 26C6           53                         push	bx
09085                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
09086 26C7           E8         DF5C            call	_read_byte_SS
09087 26CA           44                         inc	sp
09088 26CB           44                         inc	sp
09089                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$24A-$21D] (used reg = )
09090 26CC           8886       FDE5            mov	-$21B[bp],al
09091 26D0           84C0                       test	al,al
09092 26D2           75           C9            jne	.234
09093                       000026D4            .236:
09094                       000026D4            .232:
09095                                           ! Debug: lt unsigned long = const $10000 to unsigned long sizeinmb = [S+$24A-$21A] (used reg = )
09096 26D4           31C0                       xor	ax,ax
09097 26D6           BB                   0001  mov	bx,*1
09098 26D9           8DBE       FDE8            lea	di,-$218[bp]
09099 26DD           E8         D9BC            call	lcmpul
09100 26E0           76           1B            jbe 	.237
09101                       000026E2            .238:
09102                                           ! 1854             bios_printf(2, " ATA-%d Hard-Disk (%4u MBytes)\n", version, (Bit16u)sizeinmb);
09103                                           ! Debug: list unsigned short sizeinmb = [S+$24A-$21A] (used reg = )
09104 26E2           FFB6       FDE8            push	-$218[bp]
09105                                           ! Debug: list unsigned char version = [S+$24C-$221] (used reg = )
09106 26E6           8A86       FDE1            mov	al,-$21F[bp]
09107 26EA           30E4                       xor	ah,ah
09108 26EC           50                         push	ax
09109                                           ! Debug: list * char = .239+0 (used reg = )
09110 26ED           BB                   D70E  mov	bx,#.239
09111 26F0           53                         push	bx
09112                                           ! Debug: list int = const 2 (used reg = )
09113 26F1           B8                   0002  mov	ax,*2
09114 26F4           50                         push	ax
09115                                           ! Debug: func () void = bios_printf+0 (used reg = )
09116 26F5           E8         E246            call	_bios_printf
09117 26F8           83C4                   08  add	sp,*8
09118                                           !BCC_EOS
09119                                           ! 1855           else
09120                                           ! 1856             bios_printf(2, " ATA-%d Hard-Disk (%4u GBytes)\n", version, (Bit16u)(sizeinmb>>10));
09121 26FB           EB           2C            jmp .23A
09122                       000026FD            .237:
09123                                           ! Debug: sr int = const $A to unsigned long sizeinmb = [S+$24A-$21A] (used reg = )
09124 26FD           8B86       FDE8            mov	ax,-$218[bp]
09125 2701           8B9E       FDEA            mov	bx,-$216[bp]
09126 2705           88E0                       mov	al,ah
09127 2707           88DC                       mov	ah,bl
09128 2709           88FB                       mov	bl,bh
09129 270B           28FF                       sub	bh,bh
09130 270D           BF                   0002  mov	di,*2
09131 2710           E8         D9E7            call	lsrul
09132                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
09133                                           ! Debug: list unsigned short = ax+0 (used reg = )
09134 2713           50                         push	ax
09135                                           ! Debug: list unsigned char version = [S+$24C-$221] (used reg = )
09136 2714           8A86       FDE1            mov	al,-$21F[bp]
09137 2718           30E4                       xor	ah,ah
09138 271A           50                         push	ax
09139                                           ! Debug: list * char = .23B+0 (used reg = )
09140 271B           BB                   D6EE  mov	bx,#.23B
09141 271E           53                         push	bx
09142                                           ! Debug: list int = const 2 (used reg = )
09143 271F           B8                   0002  mov	ax,*2
09144 2722           50                         push	ax
09145                                           ! Debug: func () void = bios_printf+0 (used reg = )
09146 2723           E8         E218            call	_bios_printf
09147 2726           83C4                   08  add	sp,*8
09148                                           !BCC_EOS
09149                                           ! 1857           break;
09150                       00002729            .23A:
09151 2729           E9         00E1            br 	.228
09152                                           !BCC_EOS
09153                                           ! 1858         case 0x03:
09154                                           ! 1859           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
09155                       0000272C            .23C:
09156 272C           8A86       FDF2            mov	al,-$20E[bp]
09157 2730           84C0                       test	al,al
09158 2732           74           05            je  	.240
09159                       00002734            .241:
09160 2734           BB                   D6DC  mov	bx,#.23E
09161 2737           EB           03            jmp .242
09162                       00002739            .240:
09163 2739           BB                   D6D5  mov	bx,#.23F
09164                       0000273C            .242:
09165                                           ! Debug: list * char = bx+0 (used reg = )
09166 273C           53                         push	bx
09167                                           ! Debug: list unsigned char channel = [S+$24C-$20F] (used reg = )
09168 273D           8A86       FDF3            mov	al,-$20D[bp]
09169 2741           30E4                       xor	ah,ah
09170 2743           50                         push	ax
09171                                           ! Debug: list * char = .23D+0 (used reg = )
09172 2744           BB                   D6E3  mov	bx,#.23D
09173 2747           53                         push	bx
09174                                           ! Debug: list int = const 2 (used reg = )
09175 2748           B8                   0002  mov	ax,*2
09176 274B           50                         push	ax
09177                                           ! Debug: func () void = bios_printf+0 (used reg = )
09178 274C           E8         E1EF            call	_bios_printf
09179 274F           83C4                   08  add	sp,*8
09180                                           !BCC_EOS
09181                                           ! 1860           i=0; while(c=read_byte_SS(model+i++)) bios_printf(2, "%c",c);
09182                                           ! Debug: eq int = const 0 to unsigned char i = [S+$24A-$21E] (used reg = )
09183 2752           30C0                       xor	al,al
09184 2754           8886       FDE4            mov	-$21C[bp],al
09185                                           !BCC_EOS
09186 2758           EB           15            jmp .244
09187                       0000275A            .245:
09188                                           ! Debug: list unsigned char c = [S+$24A-$21D] (used reg = )
09189 275A           8A86       FDE5            mov	al,-$21B[bp]
09190 275E           30E4                       xor	ah,ah
09191 2760           50                         push	ax
09192                                           ! Debug: list * char = .246+0 (used reg = )
09193 2761           BB                   D6D2  mov	bx,#.246
09194 2764           53                         push	bx
09195                                           ! Debug: list int = const 2 (used reg = )
09196 2765           B8                   0002  mov	ax,*2
09197 2768           50                         push	ax
09198                                           ! Debug: func () void = bios_printf+0 (used reg = )
09199 2769           E8         E1D2            call	_bios_printf
09200 276C           83C4                   06  add	sp,*6
09201                                           !BCC_EOS
09202                                           ! 1861           if(*((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].device))==0x05)
09203                       0000276F            .244:
09204                                           ! Debug: postinc unsigned char i = [S+$24A-$21E] (used reg = )
09205 276F           8A86       FDE4            mov	al,-$21C[bp]
09206 2773           40                         inc	ax
09207 2774           8886       FDE4            mov	-$21C[bp],al
09208                                           ! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$24A-$24A (used reg = )
09209 2778           48                         dec	ax
09210 2779           30E4                       xor	ah,ah
09211 277B           89EB                       mov	bx,bp
09212 277D           01C3                       add	bx,ax
09213                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$248 (used reg = )
09214                                           ! Debug: list * unsigned char = bx-$248 (used reg = )
09215 277F           81C3                 FDB8  add	bx,#-$248
09216 2783           53                         push	bx
09217                                           ! Debug: func () unsigned char = read_byte_SS+0 (used reg = )
09218 2784           E8         DE9F            call	_read_byte_SS
09219 2787           44                         inc	sp
09220 2788           44                         inc	sp
09221                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$24A-$21D] (used reg = )
09222 2789           8886       FDE5            mov	-$21B[bp],al
09223 278D           84C0                       test	al,al
09224 278F           75           C9            jne	.245
09225                       00002791            .247:
09226                       00002791            .243:
09227                                           ! Debug: ptradd unsigned char device = [S+$24A-5] to [8] struct  = const $142 (used reg = )
09228 2791           8A46         FD            mov	al,-3[bp]
09229 2794           30E4                       xor	ah,ah
09230 2796           B9                   001E  mov	cx,*$1E
09231 2799           F7E9                       imul	cx
09232 279B           89C3                       mov	bx,ax
09233                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
09234                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$143 (used reg = )
09235                                           ! Debug: logeq int = const 5 to unsigned char = [bx+$143] (used reg = )
09236 279D           8A87       0143            mov	al,$143[bx]
09237 27A1           3C                     05  cmp	al,*5
09238 27A3           75           17            jne 	.248
09239                       000027A5            .249:
09240                                           ! 1862             bios_printf(2, " ATAPI-%d CD-Rom/DVD-Rom\n",version);
09241                                           ! Debug: list unsigned char version = [S+$24A-$221] (used reg = )
09242 27A5           8A86       FDE1            mov	al,-$21F[bp]
09243 27A9           30E4                       xor	ah,ah
09244 27AB           50                         push	ax
09245                                           ! Debug: list * char = .24A+0 (used reg = )
09246 27AC           BB                   D6B8  mov	bx,#.24A
09247 27AF           53                         push	bx
09248                                           ! Debug: list int = const 2 (used reg = )
09249 27B0           B8                   0002  mov	ax,*2
09250 27B3           50                         push	ax
09251                                           ! Debug: func () void = bios_printf+0 (used reg = )
09252 27B4           E8         E187            call	_bios_printf
09253 27B7           83C4                   06  add	sp,*6
09254                                           !BCC_EOS
09255                                           ! 1863           else
09256                                           ! 1864             bios_printf(2, " ATAPI-%d Device\n",version);
09257 27BA           EB           15            jmp .24B
09258                       000027BC            .248:
09259                                           ! Debug: list unsigned char version = [S+$24A-$221] (used reg = )
09260 27BC           8A86       FDE1            mov	al,-$21F[bp]
09261 27C0           30E4                       xor	ah,ah
09262 27C2           50                         push	ax
09263                                           ! Debug: list * char = .24C+0 (used reg = )
09264 27C3           BB                   D6A6  mov	bx,#.24C
09265 27C6           53                         push	bx
09266                                           ! Debug: list int = const 2 (used reg = )
09267 27C7           B8                   0002  mov	ax,*2
09268 27CA           50                         push	ax
09269                                           ! Debug: func () void = bios_printf+0 (used reg = )
09270 27CB           E8         E170            call	_bios_printf
09271 27CE           83C4                   06  add	sp,*6
09272                                           !BCC_EOS
09273                                           ! 1865           break;
09274                       000027D1            .24B:
09275 27D1           EB           3A            jmp .228
09276                                           !BCC_EOS
09277                                           ! 1866         case 0x01:
09278                                           ! 1867           bios_printf(2, "ata%d %s: Unknown device\n",channel,slave?" slave":"master");
09279                       000027D3            .24D:
09280                                           ! 1867 
09281 27D3           8A86       FDF2            mov	al,-$20E[bp]
09282 27D7           84C0                       test	al,al
09283 27D9           74           05            je  	.251
09284                       000027DB            .252:
09285 27DB           BB                   D685  mov	bx,#.24F
09286 27DE           EB           03            jmp .253
09287                       000027E0            .251:
09288 27E0           BB                   D67E  mov	bx,#.250
09289                       000027E3            .253:
09290                                           ! Debug: list * char = bx+0 (used reg = )
09291 27E3           53                         push	bx
09292                                           ! Debug: list unsigned char channel = [S+$24C-$20F] (used reg = )
09293 27E4           8A86       FDF3            mov	al,-$20D[bp]
09294 27E8           30E4                       xor	ah,ah
09295 27EA           50                         push	ax
09296                                           ! Debug: list * char = .24E+0 (used reg = )
09297 27EB           BB                   D68C  mov	bx,#.24E
09298 27EE           53                         push	bx
09299                                           ! Debug: list int = const 2 (used reg = )
09300 27EF           B8                   0002  mov	ax,*2
09301 27F2           50                         push	ax
09302                                           ! Debug: func () void = bios_printf+0 (used reg = )
09303 27F3           E8         E148            call	_bios_printf
09304 27F6           83C4                   08  add	sp,*8
09305                                           !BCC_EOS
09306                                           ! 1868           break;
09307 27F9           EB           12            jmp .228
09308                                           !BCC_EOS
09309                                           ! 1869       }
09310                                           ! 1870     }
09311 27FB           EB           10            jmp .228
09312                       000027FD            .22A:
09313 27FD           2C                     01  sub	al,*1
09314 27FF           74           D2            je 	.24D
09315 2801           2C                     01  sub	al,*1
09316 2803         0F84         FE68            beq 	.22B
09317 2807           2C                     01  sub	al,*1
09318 2809         0F84         FF1F            beq 	.23C
09319                       0000280D            .228:
09320                       FFFFFDB6            ..FFFB	=	-$24A
09321 280D           83C4                   34  add	sp,*$34
09322                                           ! 1871   }
09323 2810           83C4                   0E  add	sp,*$E
09324                                           ! 1872   *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdcount)) = (hdcount);
09325                       00002813            .1A0:
09326                                           ! Debug: postinc unsigned char device = [S+$208-5] (used reg = )
09327 2813           8A46         FD            mov	al,-3[bp]
09328 2816           40                         inc	ax
09329 2817           8846         FD            mov	-3[bp],al
09330                       0000281A            .1A1:
09331                                           ! Debug: lt int = const 8 to unsigned char device = [S+$208-5] (used reg = )
09332 281A           8A46         FD            mov	al,-3[bp]
09333 281D           3C                     08  cmp	al,*8
09334 281F         0F82         F3E8            blo 	.1A2
09335                       00002823            .254:
09336                       00002823            .19F:
09337                                           ! Debug: eq unsigned char hdcount = [S+$208-3] to unsigned char = [+$232] (used reg = )
09338 2823           8A46         FF            mov	al,-1[bp]
09339 2826           A2         0232            mov	[$232],al
09340                                           !BCC_EOS
09341                                           ! 1873   *((Bit8u *)(&((ebda_data_t *) 0)->ata.cdcount)) = (cdcount);
09342                                           ! Debug: eq unsigned char cdcount = [S+$208-4] to unsigned char = [+$23B] (used reg = )
09343 2829           8A46         FE            mov	al,-2[bp]
09344 282C           A2         023B            mov	[$23B],al
09345                                           !BCC_EOS
09346                                           ! 1874   _write_byte(hdcount, 0x75, 0x40);
09347                                           ! Debug: list int = const $40 (used reg = )
09348 282F           B8                   0040  mov	ax,*$40
09349 2832           50                         push	ax
09350                                           ! Debug: list int = const $75 (used reg = )
09351 2833           B8                   0075  mov	ax,*$75
09352 2836           50                         push	ax
09353                                           ! Debug: list unsigned char hdcount = [S+$20C-3] (used reg = )
09354 2837           8A46         FF            mov	al,-1[bp]
09355 283A           30E4                       xor	ah,ah
09356 283C           50                         push	ax
09357                                           ! Debug: func () void = _write_byte+0 (used reg = )
09358 283D           E8         DDC0            call	__write_byte
09359 2840           83C4                   06  add	sp,*6
09360                                           !BCC_EOS
09361                                           ! 1875   bios_printf(2, "\n");
09362                                           ! Debug: list * char = .255+0 (used reg = )
09363 2843           BB                   D67C  mov	bx,#.255
09364 2846           53                         push	bx
09365                                           ! Debug: list int = const 2 (used reg = )
09366 2847           B8                   0002  mov	ax,*2
09367 284A           50                         push	ax
09368                                           ! Debug: func () void = bios_printf+0 (used reg = )
09369 284B           E8         E0F0            call	_bios_printf
09370 284E           83C4                   04  add	sp,*4
09371                                           !BCC_EOS
09372                                           ! 1876   set_DS(old_ds);
09373                                           ! Debug: list unsigned short old_ds = [S+$208-$208] (used reg = )
09374 2851           FFB6       FDFA            push	-$206[bp]
09375                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
09376 2855           E8         DE0A            call	_set_DS
09377 2858           44                         inc	sp
09378 2859           44                         inc	sp
09379                                           !BCC_EOS
09380                                           ! 1877 }
09381 285A           89EC                       mov	sp,bp
09382 285C           5D                         pop	bp
09383 285D           C3                         ret
09384                                           ! 1878 void ata_reset(device)
09385                                           ! Register BX used in function ata_detect
09386                                           ! 1879 Bit16u device;
09387                                           export	_ata_reset
09388                       0000285E            _ata_reset:
09389                                           !BCC_EOS
09390                                           ! 1880 {
09391                                           ! 1881   Bit16u iobase1, iobase2;
09392                                           !BCC_EOS
09393                                           ! 1882   Bit8u channel, slave, sn, sc;
09394                                           !BCC_EOS
09395                                           ! 1883   Bit8u type;
09396                                           !BCC_EOS
09397                                           ! 1884   Bit16u max;
09398                                           !BCC_EOS
09399                                           ! 1885   channel = device / 2;
09400 285E           55                         push	bp
09401 285F           89E5                       mov	bp,sp
09402 2861           83C4                   F4  add	sp,*-$C
09403                                           ! Debug: div int = const 2 to unsigned short device = [S+$E+2] (used reg = )
09404 2864           8B46         04            mov	ax,4[bp]
09405 2867           D1E8                       shr	ax,*1
09406                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$E-7] (used reg = )
09407 2869           8846         FB            mov	-5[bp],al
09408                                           !BCC_EOS
09409                                           ! 1886   slave = device % 2;
09410                                           ! Debug: mod int = const 2 to unsigned short device = [S+$E+2] (used reg = )
09411 286C           8B46         04            mov	ax,4[bp]
09412 286F           24                     01  and	al,*1
09413                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$E-8] (used reg = )
09414 2871           8846         FA            mov	-6[bp],al
09415                                           !BCC_EOS
09416                                           ! 1887   iobase1 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1));
09417                                           ! Debug: ptradd unsigned char channel = [S+$E-7] to [4] struct  = const $122 (used reg = )
09418 2874           8A46         FB            mov	al,-5[bp]
09419 2877           30E4                       xor	ah,ah
09420 2879           B1                     03  mov	cl,*3
09421 287B           D3E0                       shl	ax,cl
09422 287D           89C3                       mov	bx,ax
09423                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
09424                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
09425                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$E-4] (used reg = )
09426 287F           8B9F       0124            mov	bx,$124[bx]
09427 2883           895E         FE            mov	-2[bp],bx
09428                                           !BCC_EOS
09429                                           ! 1888   iobase2 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2));
09430                                           ! Debug: ptradd unsigned char channel = [S+$E-7] to [4] struct  = const $122 (used reg = )
09431 2886           8A46         FB            mov	al,-5[bp]
09432 2889           30E4                       xor	ah,ah
09433 288B           B1                     03  mov	cl,*3
09434 288D           D3E0                       shl	ax,cl
09435 288F           89C3                       mov	bx,ax
09436                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
09437                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
09438                                           ! Debug: eq unsigned short = [bx+$126] to unsigned short iobase2 = [S+$E-6] (used reg = )
09439 2891           8B9F       0126            mov	bx,$126[bx]
09440 2895           895E         FC            mov	-4[bp],bx
09441                                           !BCC_EOS
09442                                           ! 1889   outb(iobase2+6, 0x08 | 0x02 | 0x04);
09443                                           ! Debug: list int = const $E (used reg = )
09444 2898           B8                   000E  mov	ax,*$E
09445 289B           50                         push	ax
09446                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-6] (used reg = )
09447 289C           8B46         FC            mov	ax,-4[bp]
09448                                           ! Debug: list unsigned int = ax+6 (used reg = )
09449 289F           05                   0006  add	ax,*6
09450 28A2           50                         push	ax
09451                                           ! Debug: func () void = outb+0 (used reg = )
09452 28A3           E8         DC68            call	_outb
09453 28A6           83C4                   04  add	sp,*4
09454                                           !BCC_EOS
09455                                           ! 1890   await_ide(1, iobase1, 20);
09456                                           ! Debug: list int = const $14 (used reg = )
09457 28A9           B8                   0014  mov	ax,*$14
09458 28AC           50                         push	ax
09459                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
09460 28AD           FF76         FE            push	-2[bp]
09461                                           ! Debug: list int = const 1 (used reg = )
09462 28B0           B8                   0001  mov	ax,*1
09463 28B3           50                         push	ax
09464                                           ! Debug: func () int = await_ide+0 (used reg = )
09465 28B4           E8         F178            call	_await_ide
09466 28B7           83C4                   06  add	sp,*6
09467                                           !BCC_EOS
09468                                           ! 1891   outb(iobase2+6, 0x08 | 0x02);
09469                                           ! Debug: list int = const $A (used reg = )
09470 28BA           B8                   000A  mov	ax,*$A
09471 28BD           50                         push	ax
09472                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-6] (used reg = )
09473 28BE           8B46         FC            mov	ax,-4[bp]
09474                                           ! Debug: list unsigned int = ax+6 (used reg = )
09475 28C1           05                   0006  add	ax,*6
09476 28C4           50                         push	ax
09477                                           ! Debug: func () void = outb+0 (used reg = )
09478 28C5           E8         DC46            call	_outb
09479 28C8           83C4                   04  add	sp,*4
09480                                           !BCC_EOS
09481                                           ! 1892   type=*((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type));
09482                                           ! Debug: ptradd unsigned short device = [S+$E+2] to [8] struct  = const $142 (used reg = )
09483 28CB           8B46         04            mov	ax,4[bp]
09484 28CE           B9                   001E  mov	cx,*$1E
09485 28D1           F7E9                       imul	cx
09486 28D3           89C3                       mov	bx,ax
09487                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
09488                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
09489                                           ! Debug: eq unsigned char = [bx+$142] to unsigned char type = [S+$E-$B] (used reg = )
09490 28D5           8A87       0142            mov	al,$142[bx]
09491 28D9           8846         F7            mov	-9[bp],al
09492                                           !BCC_EOS
09493                                           ! 1893   if (type != 0x00) {
09494                                           ! Debug: ne int = const 0 to unsigned char type = [S+$E-$B] (used reg = )
09495 28DC           8A46         F7            mov	al,-9[bp]
09496 28DF           84C0                       test	al,al
09497 28E1         0F84         0084            beq 	.256
09498                       000028E5            .257:
09499                                           ! 1894     outb(iobase1+6, slave?0xb0:0xa0);
09500 28E5           8A46         FA            mov	al,-6[bp]
09501 28E8           84C0                       test	al,al
09502 28EA           74           04            je  	.258
09503                       000028EC            .259:
09504 28EC           B0                     B0  mov	al,#$B0
09505 28EE           EB           02            jmp .25A
09506                       000028F0            .258:
09507 28F0           B0                     A0  mov	al,#$A0
09508                       000028F2            .25A:
09509                                           ! Debug: list char = al+0 (used reg = )
09510 28F2           30E4                       xor	ah,ah
09511 28F4           50                         push	ax
09512                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$10-4] (used reg = )
09513 28F5           8B46         FE            mov	ax,-2[bp]
09514                                           ! Debug: list unsigned int = ax+6 (used reg = )
09515 28F8           05                   0006  add	ax,*6
09516 28FB           50                         push	ax
09517                                           ! Debug: func () void = outb+0 (used reg = )
09518 28FC           E8         DC0F            call	_outb
09519 28FF           83C4                   04  add	sp,*4
09520                                           !BCC_EOS
09521                                           ! 1895     sc = inb(iobase1+2);
09522                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$E-4] (used reg = )
09523 2902           8B46         FE            mov	ax,-2[bp]
09524                                           ! Debug: list unsigned int = ax+2 (used reg = )
09525 2905           40                         inc	ax
09526 2906           40                         inc	ax
09527 2907           50                         push	ax
09528                                           ! Debug: func () unsigned char = inb+0 (used reg = )
09529 2908           E8         DBED            call	_inb
09530 290B           44                         inc	sp
09531 290C           44                         inc	sp
09532                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$E-$A] (used reg = )
09533 290D           8846         F8            mov	-8[bp],al
09534                                           !BCC_EOS
09535                                           ! 1896     sn = inb(iobase1+3);
09536                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$E-4] (used reg = )
09537 2910           8B46         FE            mov	ax,-2[bp]
09538                                           ! Debug: list unsigned int = ax+3 (used reg = )
09539 2913           05                   0003  add	ax,*3
09540 2916           50                         push	ax
09541                                           ! Debug: func () unsigned char = inb+0 (used reg = )
09542 2917           E8         DBDE            call	_inb
09543 291A           44                         inc	sp
09544 291B           44                         inc	sp
09545                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$E-9] (used reg = )
09546 291C           8846         F9            mov	-7[bp],al
09547                                           !BCC_EOS
09548                                           ! 1897     if ( (sc==0x01) && (sn==0x01) ) {
09549                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$E-$A] (used reg = )
09550 291F           8A46         F8            mov	al,-8[bp]
09551 2922           3C                     01  cmp	al,*1
09552 2924           75           32            jne 	.25B
09553                       00002926            .25D:
09554                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$E-9] (used reg = )
09555 2926           8A46         F9            mov	al,-7[bp]
09556 2929           3C                     01  cmp	al,*1
09557 292B           75           2B            jne 	.25B
09558                       0000292D            .25C:
09559                                           ! 1898       if (type == 0x02)
09560                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$E-$B] (used reg = )
09561 292D           8A46         F7            mov	al,-9[bp]
09562 2930           3C                     02  cmp	al,*2
09563 2932           75           13            jne 	.25E
09564                       00002934            .25F:
09565                                           ! 1899         await_ide(5, iobase1, 32000u);
09566                                           ! Debug: list unsigned int = const $7D00 (used reg = )
09567 2934           B8                   7D00  mov	ax,#$7D00
09568 2937           50                         push	ax
09569                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
09570 2938           FF76         FE            push	-2[bp]
09571                                           ! Debug: list int = const 5 (used reg = )
09572 293B           B8                   0005  mov	ax,*5
09573 293E           50                         push	ax
09574                                           ! Debug: func () int = await_ide+0 (used reg = )
09575 293F           E8         F0ED            call	_await_ide
09576 2942           83C4                   06  add	sp,*6
09577                                           !BCC_EOS
09578                                           ! 1900       else
09579                                           ! 1901         await_ide(2, iobase1, 32000u);
09580 2945           EB           11            jmp .260
09581                       00002947            .25E:
09582                                           ! Debug: list unsigned int = const $7D00 (used reg = )
09583 2947           B8                   7D00  mov	ax,#$7D00
09584 294A           50                         push	ax
09585                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
09586 294B           FF76         FE            push	-2[bp]
09587                                           ! Debug: list int = const 2 (used reg = )
09588 294E           B8                   0002  mov	ax,*2
09589 2951           50                         push	ax
09590                                           ! Debug: func () int = await_ide+0 (used reg = )
09591 2952           E8         F0DA            call	_await_ide
09592 2955           83C4                   06  add	sp,*6
09593                                           !BCC_EOS
09594                                           ! 1902     }
09595                       00002958            .260:
09596                                           ! 1903     await_ide(2, iobase1, 32000u);
09597                       00002958            .25B:
09598                                           ! Debug: list unsigned int = const $7D00 (used reg = )
09599 2958           B8                   7D00  mov	ax,#$7D00
09600 295B           50                         push	ax
09601                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
09602 295C           FF76         FE            push	-2[bp]
09603                                           ! Debug: list int = const 2 (used reg = )
09604 295F           B8                   0002  mov	ax,*2
09605 2962           50                         push	ax
09606                                           ! Debug: func () int = await_ide+0 (used reg = )
09607 2963           E8         F0C9            call	_await_ide
09608 2966           83C4                   06  add	sp,*6
09609                                           !BCC_EOS
09610                                           ! 1904   }
09611                                           ! 1905   outb(iobase2+6, 0x08);
09612                       00002969            .256:
09613                                           ! Debug: list int = const 8 (used reg = )
09614 2969           B8                   0008  mov	ax,*8
09615 296C           50                         push	ax
09616                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-6] (used reg = )
09617 296D           8B46         FC            mov	ax,-4[bp]
09618                                           ! Debug: list unsigned int = ax+6 (used reg = )
09619 2970           05                   0006  add	ax,*6
09620 2973           50                         push	ax
09621                                           ! Debug: func () void = outb+0 (used reg = )
09622 2974           E8         DB97            call	_outb
09623 2977           83C4                   04  add	sp,*4
09624                                           !BCC_EOS
09625                                           ! 1906 }
09626 297A           89EC                       mov	sp,bp
09627 297C           5D                         pop	bp
09628 297D           C3                         ret
09629                                           ! 1907 Bit16u ata_cmd_non_data()
09630                                           ! Register BX used in function ata_reset
09631                                           ! 1908 {return 0;}
09632                                           export	_ata_cmd_non_data
09633                       0000297E            _ata_cmd_non_data:
09634 297E           55                         push	bp
09635 297F           89E5                       mov	bp,sp
09636 2981           31C0                       xor	ax,ax
09637 2983           5D                         pop	bp
09638 2984           C3                         ret
09639                                           !BCC_EOS
09640                                           ! 1909 Bit16u ata_cmd_data_io(ioflag, device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
09641                                           ! 1910 Bit16u ioflag, device, command, count, cylinder, head, sector, segment, offset;
09642                                           export	_ata_cmd_data_io
09643                       00002985            _ata_cmd_data_io:
09644                                           !BCC_EOS
09645                                           ! 1911 Bit32u lba_low, lba_high;
09646                                           !BCC_EOS
09647                                           ! 1912 {
09648                                           ! 1913   Bit16u iobase1, iobase2, blksize;
09649                                           !BCC_EOS
09650                                           ! 1914   Bit8u channel, slave;
09651                                           !BCC_EOS
09652                                           ! 1915   Bit8u status, current, mode;
09653                                           !BCC_EOS
09654                                           ! 1916   channel = device / 2;
09655 2985           55                         push	bp
09656 2986           89E5                       mov	bp,sp
09657 2988           83C4                   F4  add	sp,*-$C
09658                                           ! Debug: div int = const 2 to unsigned short device = [S+$E+4] (used reg = )
09659 298B           8B46         06            mov	ax,6[bp]
09660 298E           D1E8                       shr	ax,*1
09661                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$E-9] (used reg = )
09662 2990           8846         F9            mov	-7[bp],al
09663                                           !BCC_EOS
09664                                           ! 1917   slave = device % 2;
09665                                           ! Debug: mod int = const 2 to unsigned short device = [S+$E+4] (used reg = )
09666 2993           8B46         06            mov	ax,6[bp]
09667 2996           24                     01  and	al,*1
09668                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$E-$A] (used reg = )
09669 2998           8846         F8            mov	-8[bp],al
09670                                           !BCC_EOS
09671                                           ! 1918   iobase1 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1));
09672                                           ! Debug: ptradd unsigned char channel = [S+$E-9] to [4] struct  = const $122 (used reg = )
09673 299B           8A46         F9            mov	al,-7[bp]
09674 299E           30E4                       xor	ah,ah
09675 29A0           B1                     03  mov	cl,*3
09676 29A2           D3E0                       shl	ax,cl
09677 29A4           89C3                       mov	bx,ax
09678                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
09679                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
09680                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$E-4] (used reg = )
09681 29A6           8B9F       0124            mov	bx,$124[bx]
09682 29AA           895E         FE            mov	-2[bp],bx
09683                                           !BCC_EOS
09684                                           ! 1919   iobase2 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2));
09685                                           ! Debug: ptradd unsigned char channel = [S+$E-9] to [4] struct  = const $122 (used reg = )
09686 29AD           8A46         F9            mov	al,-7[bp]
09687 29B0           30E4                       xor	ah,ah
09688 29B2           B1                     03  mov	cl,*3
09689 29B4           D3E0                       shl	ax,cl
09690 29B6           89C3                       mov	bx,ax
09691                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
09692                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
09693                                           ! Debug: eq unsigned short = [bx+$126] to unsigned short iobase2 = [S+$E-6] (used reg = )
09694 29B8           8B9F       0126            mov	bx,$126[bx]
09695 29BC           895E         FC            mov	-4[bp],bx
09696                                           !BCC_EOS
09697                                           ! 1920   mode = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode));
09698                                           ! Debug: ptradd unsigned short device = [S+$E+4] to [8] struct  = const $142 (used reg = )
09699 29BF           8B46         06            mov	ax,6[bp]
09700 29C2           B9                   001E  mov	cx,*$1E
09701 29C5           F7E9                       imul	cx
09702 29C7           89C3                       mov	bx,ax
09703                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
09704                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
09705                                           ! Debug: eq unsigned char = [bx+$146] to unsigned char mode = [S+$E-$D] (used reg = )
09706 29C9           8A87       0146            mov	al,$146[bx]
09707 29CD           8846         F5            mov	-$B[bp],al
09708                                           !BCC_EOS
09709                                           ! 1921   if ((command == 0xEC) ||
09710                                           ! 1922       (command == 0xA1)) {
09711                                           ! Debug: logeq int = const $EC to unsigned short command = [S+$E+6] (used reg = )
09712 29D0           8B46         08            mov	ax,8[bp]
09713 29D3           3D                   00EC  cmp	ax,#$EC
09714 29D6           74           08            je  	.262
09715                       000029D8            .263:
09716                                           ! Debug: logeq int = const $A1 to unsigned short command = [S+$E+6] (used reg = )
09717 29D8           8B46         08            mov	ax,8[bp]
09718 29DB           3D                   00A1  cmp	ax,#$A1
09719 29DE           75           08            jne 	.261
09720                       000029E0            .262:
09721                                           ! 1923     blksize = 0x200;
09722                                           ! Debug: eq int = const $200 to unsigned short blksize = [S+$E-8] (used reg = )
09723 29E0           B8                   0200  mov	ax,#$200
09724 29E3           8946         FA            mov	-6[bp],ax
09725                                           !BCC_EOS
09726                                           ! 1924   } else {
09727 29E6           EB           11            jmp .264
09728                       000029E8            .261:
09729                                           ! 1925     blksize = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].blksize));
09730                                           ! Debug: ptradd unsigned short device = [S+$E+4] to [8] struct  = const $142 (used reg = )
09731 29E8           8B46         06            mov	ax,6[bp]
09732 29EB           B9                   001E  mov	cx,*$1E
09733 29EE           F7E9                       imul	cx
09734 29F0           89C3                       mov	bx,ax
09735                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
09736                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$148 (used reg = )
09737                                           ! Debug: eq unsigned short = [bx+$148] to unsigned short blksize = [S+$E-8] (used reg = )
09738 29F2           8B9F       0148            mov	bx,$148[bx]
09739 29F6           895E         FA            mov	-6[bp],bx
09740                                           !BCC_EOS
09741                                           ! 1926   }
09742                                           ! 1927   if (mode == 0x01) blksize>>=2;
09743                       000029F9            .264:
09744                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$E-$D] (used reg = )
09745 29F9           8A46         F5            mov	al,-$B[bp]
09746 29FC           3C                     01  cmp	al,*1
09747 29FE           75           0C            jne 	.265
09748                       00002A00            .266:
09749                                           ! Debug: srab int = const 2 to unsigned short blksize = [S+$E-8] (used reg = )
09750 2A00           8B46         FA            mov	ax,-6[bp]
09751 2A03           D1E8                       shr	ax,*1
09752 2A05           D1E8                       shr	ax,*1
09753 2A07           8946         FA            mov	-6[bp],ax
09754                                           !BCC_EOS
09755                                           ! 1928   else blksize>>=1;
09756 2A0A           EB           08            jmp .267
09757                       00002A0C            .265:
09758                                           ! Debug: srab int = const 1 to unsigned short blksize = [S+$E-8] (used reg = )
09759 2A0C           8B46         FA            mov	ax,-6[bp]
09760 2A0F           D1E8                       shr	ax,*1
09761 2A11           8946         FA            mov	-6[bp],ax
09762                                           !BCC_EOS
09763                                           ! 1929   *((Bit16u *)(&((ebda_data_t *) 0)->ata.trsfsectors)) = (0);
09764                       00002A14            .267:
09765                                           ! Debug: eq int = const 0 to unsigned short = [+$254] (used reg = )
09766 2A14           31C0                       xor	ax,ax
09767 2A16           A3         0254            mov	[$254],ax
09768                                           !BCC_EOS
09769                                           ! 1930   *((Bit32u *)(&((ebda_data_t *) 0)->ata.trsfbytes)) = (0
09770                                           ! 1930 L);
09771                                           ! Debug: eq long = const 0 to unsigned long = [+$256] (used reg = )
09772 2A19           31C0                       xor	ax,ax
09773 2A1B           31DB                       xor	bx,bx
09774 2A1D           A3         0256            mov	[$256],ax
09775 2A20           891E       0258            mov	[$258],bx
09776                                           !BCC_EOS
09777                                           ! 1931   current = 0;
09778                                           ! Debug: eq int = const 0 to unsigned char current = [S+$E-$C] (used reg = )
09779 2A24           30C0                       xor	al,al
09780 2A26           8846         F6            mov	-$A[bp],al
09781                                           !BCC_EOS
09782                                           ! 1932   status = inb(iobase1 + 7);
09783                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$E-4] (used reg = )
09784 2A29           8B46         FE            mov	ax,-2[bp]
09785                                           ! Debug: list unsigned int = ax+7 (used reg = )
09786 2A2C           05                   0007  add	ax,*7
09787 2A2F           50                         push	ax
09788                                           ! Debug: func () unsigned char = inb+0 (used reg = )
09789 2A30           E8         DAC5            call	_inb
09790 2A33           44                         inc	sp
09791 2A34           44                         inc	sp
09792                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$E-$B] (used reg = )
09793 2A35           8846         F7            mov	-9[bp],al
09794                                           !BCC_EOS
09795                                           ! 1933   if (status & 0x80) return 1;
09796                                           ! Debug: and int = const $80 to unsigned char status = [S+$E-$B] (used reg = )
09797 2A38           8A46         F7            mov	al,-9[bp]
09798 2A3B           24                     80  and	al,#$80
09799 2A3D           84C0                       test	al,al
09800 2A3F           74           07            je  	.268
09801                       00002A41            .269:
09802 2A41           B8                   0001  mov	ax,*1
09803 2A44           89EC                       mov	sp,bp
09804 2A46           5D                         pop	bp
09805 2A47           C3                         ret
09806                                           !BCC_EOS
09807                                           ! 1934   outb(iobase2 + 6, 0x08 | 0x02);
09808                       00002A48            .268:
09809                                           ! Debug: list int = const $A (used reg = )
09810 2A48           B8                   000A  mov	ax,*$A
09811 2A4B           50                         push	ax
09812                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-6] (used reg = )
09813 2A4C           8B46         FC            mov	ax,-4[bp]
09814                                           ! Debug: list unsigned int = ax+6 (used reg = )
09815 2A4F           05                   0006  add	ax,*6
09816 2A52           50                         push	ax
09817                                           ! Debug: func () void = outb+0 (used reg = )
09818 2A53           E8         DAB8            call	_outb
09819 2A56           83C4                   04  add	sp,*4
09820                                           !BCC_EOS
09821                                           ! 1935   if (sector == 0) {
09822                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$E+$E] (used reg = )
09823 2A59           8B46         10            mov	ax,$10[bp]
09824 2A5C           85C0                       test	ax,ax
09825 2A5E         0F85         00F5            bne 	.26A
09826                       00002A62            .26B:
09827                                           ! 1936     if (*(((Bit8u *)&count)+1) >= 1 || lba_high || (lba_low >= ((1UL << 28) - count))) {
09828                                           ! Debug: ge int = const 1 to unsigned char count = [S+$E+9] (used reg = )
09829 2A62           8A46         0B            mov	al,$B[bp]
09830 2A65           3C                     01  cmp	al,*1
09831 2A67           72           04            jb 	.270
09832 2A69           B0                     01  mov	al,*1
09833 2A6B           EB           02            jmp	.271
09834                       00002A6D            .270:
09835 2A6D           30C0                       xor	al,al
09836                       00002A6F            .271:
09837                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
09838 2A6F           30E4                       xor	ah,ah
09839 2A71           99                         cwd
09840 2A72           89D3                       mov	bx,dx
09841 2A74           E8         D66E            call	ltstl
09842 2A77           75           2A            jne 	.26D
09843                       00002A79            .26F:
09844 2A79           8B46         16            mov	ax,$16[bp]
09845 2A7C           8B5E         18            mov	bx,$18[bp]
09846 2A7F           E8         D663            call	ltstl
09847 2A82           75           1F            jne 	.26D
09848                       00002A84            .26E:
09849                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$E+8] (used reg = )
09850 2A84           8B46         0A            mov	ax,$A[bp]
09851 2A87           31DB                       xor	bx,bx
09852                                           ! Debug: sub unsigned long = bx+0 to unsigned long = const $10000000 (used reg = )
09853 2A89           53                         push	bx
09854 2A8A           50                         push	ax
09855 2A8B           31C0                       xor	ax,ax
09856 2A8D           BB                   1000  mov	bx,#$1000
09857 2A90           8D7E         F0            lea	di,-$10[bp]
09858 2A93           E8         D61C            call	lsubul
09859 2A96           83C4                   04  add	sp,*4
09860                                           ! Debug: ge unsigned long = bx+0 to unsigned long lba_low = [S+$E+$10] (used reg = )
09861 2A99           8D7E         12            lea	di,$12[bp]
09862 2A9C           E8         D5FD            call	lcmpul
09863 2A9F         0F87         0086            bhi 	.26C
09864                       00002AA3            .26D:
09865                                           ! 1937       outb(iobase1 + 1, 0x00);
09866                                           ! Debug: list int = const 0 (used reg = )
09867 2AA3           31C0                       xor	ax,ax
09868 2AA5           50                         push	ax
09869                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$10-4] (used reg = )
09870 2AA6           8B46         FE            mov	ax,-2[bp]
09871                                           ! Debug: list unsigned int = ax+1 (used reg = )
09872 2AA9           40                         inc	ax
09873 2AAA           50                         push	ax
09874                                           ! Debug: func () void = outb+0 (used reg = )
09875 2AAB           E8         DA60            call	_outb
09876 2AAE           83C4                   04  add	sp,*4
09877                                           !BCC_EOS
09878                                           ! 1938       outb(iobase1 + 2, *(((Bit8u *)&count)+1));
09879                                           ! Debug: list unsigned char count = [S+$E+9] (used reg = )
09880 2AB1           8A46         0B            mov	al,$B[bp]
09881 2AB4           30E4                       xor	ah,ah
09882 2AB6           50                         push	ax
09883                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$10-4] (used reg = )
09884 2AB7           8B46         FE            mov	ax,-2[bp]
09885                                           ! Debug: list unsigned int = ax+2 (used reg = )
09886 2ABA           40                         inc	ax
09887 2ABB           40                         inc	ax
09888 2ABC           50                         push	ax
09889                                           ! Debug: func () void = outb+0 (used reg = )
09890 2ABD           E8         DA4E            call	_outb
09891 2AC0           83C4                   04  add	sp,*4
09892                                           !BCC_EOS
09893                                           ! 1939       outb(iobase1 + 3, *(((Bit8u *)&*(((Bit16u *)&lba_low)+1))+1));
09894                                           ! Debug: list unsigned char lba_low = [S+$E+$13] (used reg = )
09895 2AC3           8A46         15            mov	al,$15[bp]
09896 2AC6           30E4                       xor	ah,ah
09897 2AC8           50                         push	ax
09898                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$10-4] (used reg = )
09899 2AC9           8B46         FE            mov	ax,-2[bp]
09900                                           ! Debug: list unsigned int = ax+3 (used reg = )
09901 2ACC           05                   0003  add	ax,*3
09902 2ACF           50                         push	ax
09903                                           ! Debug: func () void = outb+0 (used reg = )
09904 2AD0           E8         DA3B            call	_outb
09905 2AD3           83C4                   04  add	sp,*4
09906                                           !BCC_EOS
09907                                           ! 1940       outb(iobase1 + 4, *((Bit8u *)&lba_high));
09908                                           ! Debug: list unsigned char lba_high = [S+$E+$14] (used reg = )
09909 2AD6           8A46         16            mov	al,$16[bp]
09910 2AD9           30E4                       xor	ah,ah
09911 2ADB           50                         push	ax
09912                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$10-4] (used reg = )
09913 2ADC           8B46         FE            mov	ax,-2[bp]
09914                                           ! Debug: list unsigned int = ax+4 (used reg = )
09915 2ADF           05                   0004  add	ax,*4
09916 2AE2           50                         push	ax
09917                                           ! Debug: func () void = outb+0 (used reg = )
09918 2AE3           E8         DA28            call	_outb
09919 2AE6           83C4                   04  add	sp,*4
09920                                           !BCC_EOS
09921                                           ! 1941       outb(iobase1 + 5, *(((Bit8u *)&*((Bit16u *)&lba_high))+1));
09922                                           ! Debug: list unsigned char lba_high = [S+$E+$15] (used reg = )
09923 2AE9           8A46         17            mov	al,$17[bp]
09924 2AEC           30E4                       xor	ah,ah
09925 2AEE           50                         push	ax
09926                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$10-4] (used reg = )
09927 2AEF           8B46         FE            mov	ax,-2[bp]
09928                                           ! Debug: list unsigned int = ax+5 (used reg = )
09929 2AF2           05                   0005  add	ax,*5
09930 2AF5           50                         push	ax
09931                                           ! Debug: func () void = outb+0 (used reg = )
09932 2AF6           E8         DA15            call	_outb
09933 2AF9           83C4                   04  add	sp,*4
09934                                           !BCC_EOS
09935                                           ! 1942       command |= 0x04;
09936                                           ! Debug: orab int = const 4 to unsigned short command = [S+$E+6] (used reg = )
09937 2AFC           8B46         08            mov	ax,8[bp]
09938 2AFF           0C                     04  or	al,*4
09939 2B01           8946         08            mov	8[bp],ax
09940                                           !BCC_EOS
09941                                           ! 1943       count &= (1 << 8) - 1;
09942                                           ! Debug: andab int = const $FF to unsigned short count = [S+$E+8] (used reg = )
09943 2B04           8A46         0A            mov	al,$A[bp]
09944 2B07           30E4                       xor	ah,ah
09945 2B09           8946         0A            mov	$A[bp],ax
09946                                           !BCC_EOS
09947                                           ! 1944       lba_low &= (1UL << 24) - 1;
09948                                           ! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$E+$10] (used reg = )
09949 2B0C           B8                   FFFF  mov	ax,#$FFFF
09950 2B0F           BB                   00FF  mov	bx,#$FF
09951 2B12           53                         push	bx
09952 2B13           50                         push	ax
09953 2B14           8B46         12            mov	ax,$12[bp]
09954 2B17           8B5E         14            mov	bx,$14[bp]
09955 2B1A           8D7E         F0            lea	di,-$10[bp]
09956 2B1D           E8         D56C            call	landul
09957 2B20           8946         12            mov	$12[bp],ax
09958 2B23           895E         14            mov	$14[bp],bx
09959 2B26           83C4                   04  add	sp,*4
09960                                           !BCC_EOS
09961                                           ! 1945     }
09962                                           ! 1946     sector = (Bit16u) *((Bit8u *)&lba_low);
09963                       00002B29            .26C:
09964                                           ! Debug: cast unsigned short = const 0 to unsigned char lba_low = [S+$E+$10] (used reg = )
09965 2B29           8A46         12            mov	al,$12[bp]
09966 2B2C           30E4                       xor	ah,ah
09967                                           ! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$E+$E] (used reg = )
09968 2B2E           8946         10            mov	$10[bp],ax
09969                                           !BCC_EOS
09970                                           ! 1947     lba_low >>= 8;
09971                                           ! Debug: srab int = const 8 to unsigned long lba_low = [S+$E+$10] (used reg = )
09972 2B31           8B46         12            mov	ax,$12[bp]
09973 2B34           8B5E         14            mov	bx,$14[bp]
09974 2B37           88E0                       mov	al,ah
09975 2B39           88DC                       mov	ah,bl
09976 2B3B           88FB                       mov	bl,bh
09977 2B3D           28FF                       sub	bh,bh
09978 2B3F           8946         12            mov	$12[bp],ax
09979 2B42           895E         14            mov	$14[bp],bx
09980                                           !BCC_EOS
09981                                           ! 1948     cylinder = *((Bit16u *)&lba_low);
09982                                           ! Debug: eq unsigned short lba_low = [S+$E+$10] to unsigned short cylinder = [S+$E+$A] (used reg = )
09983 2B45           8B46         12            mov	ax,$12[bp]
09984 2B48           8946         0C            mov	$C[bp],ax
09985                                           !BCC_EOS
09986                                           ! 1949     head = (*(((Bit16u *)&lba_low)+1) & 0x000f) | 0x40;
09987                                           ! Debug: and int = const $F to unsigned short lba_low = [S+$E+$12] (used reg = )
09988 2B4B           8A46         14            mov	al,$14[bp]
09989 2B4E           24                     0F  and	al,*$F
09990                                           ! Debug: or int = const $40 to unsigned char = al+0 (used reg = )
09991 2B50           0C                     40  or	al,*$40
09992                                           ! Debug: eq unsigned char = al+0 to unsigned short head = [S+$E+$C] (used reg = )
09993 2B52           30E4                       xor	ah,ah
09994 2B54           8946         0E            mov	$E[bp],ax
09995                                           !BCC_EOS
09996                                           ! 1950   }
09997                                           ! 1951   outb(iobase1 + 1, 0x00);
09998                       00002B57            .26A:
09999                                           ! Debug: list int = const 0 (used reg = )
10000 2B57           31C0                       xor	ax,ax
10001 2B59           50                         push	ax
10002                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$10-4] (used reg = )
10003 2B5A           8B46         FE            mov	ax,-2[bp]
10004                                           ! Debug: list unsigned int = ax+1 (used reg = )
10005 2B5D           40                         inc	ax
10006 2B5E           50                         push	ax
10007                                           ! Debug: func () void = outb+0 (used reg = )
10008 2B5F           E8         D9AC            call	_outb
10009 2B62           83C4                   04  add	sp,*4
10010                                           !BCC_EOS
10011                                           ! 1952   outb(iobase1 + 2, count);
10012                                           ! Debug: list unsigned short count = [S+$E+8] (used reg = )
10013 2B65           FF76         0A            push	$A[bp]
10014                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$10-4] (used reg = )
10015 2B68           8B46         FE            mov	ax,-2[bp]
10016                                           ! Debug: list unsigned int = ax+2 (used reg = )
10017 2B6B           40                         inc	ax
10018 2B6C           40                         inc	ax
10019 2B6D           50                         push	ax
10020                                           ! Debug: func () void = outb+0 (used reg = )
10021 2B6E           E8         D99D            call	_outb
10022 2B71           83C4                   04  add	sp,*4
10023                                           !BCC_EOS
10024                                           ! 1953   outb(iobase1 + 3, sector);
10025                                           ! Debug: list unsigned short sector = [S+$E+$E] (used reg = )
10026 2B74           FF76         10            push	$10[bp]
10027                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$10-4] (used reg = )
10028 2B77           8B46         FE            mov	ax,-2[bp]
10029                                           ! Debug: list unsigned int = ax+3 (used reg = )
10030 2B7A           05                   0003  add	ax,*3
10031 2B7D           50                         push	ax
10032                                           ! Debug: func () void = outb+0 (used reg = )
10033 2B7E           E8         D98D            call	_outb
10034 2B81           83C4                   04  add	sp,*4
10035                                           !BCC_EOS
10036                                           ! 1954   outb(iobase1 + 4, *((Bit8u *)&cylinder));
10037                                           ! Debug: list unsigned char cylinder = [S+$E+$A] (used reg = )
10038 2B84           8A46         0C            mov	al,$C[bp]
10039 2B87           30E4                       xor	ah,ah
10040 2B89           50                         push	ax
10041                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$10-4] (used reg = )
10042 2B8A           8B46         FE            mov	ax,-2[bp]
10043                                           ! Debug: list unsigned int = ax+4 (used reg = )
10044 2B8D           05                   0004  add	ax,*4
10045 2B90           50                         push	ax
10046                                           ! Debug: func () void = outb+0 (used reg = )
10047 2B91           E8         D97A            call	_outb
10048 2B94           83C4                   04  add	sp,*4
10049                                           !BCC_EOS
10050                                           ! 1955   outb(iobase1 + 5, *(((Bit8u *)&cylinder)+1));
10051                                           ! Debug: list unsigned char cylinder = [S+$E+$B] (used reg = )
10052 2B97           8A46         0D            mov	al,$D[bp]
10053 2B9A           30E4                       xor	ah,ah
10054 2B9C           50                         push	ax
10055                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$10-4] (used reg = )
10056 2B9D           8B46         FE            mov	ax,-2[bp]
10057                                           ! Debug: list unsigned int = ax+5 (used reg = )
10058 2BA0           05                   0005  add	ax,*5
10059 2BA3           50                         push	ax
10060                                           ! Debug: func () void = outb+0 (used reg = )
10061 2BA4           E8         D967            call	_outb
10062 2BA7           83C4                   04  add	sp,*4
10063                                           !BCC_EOS
10064                                           ! 1956   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
10065 2BAA           8A46         F8            mov	al,-8[bp]
10066 2BAD           84C0                       test	al,al
10067 2BAF           74           04            je  	.273
10068                       00002BB1            .274:
10069 2BB1           B0                     B0  mov	al,#$B0
10070 2BB3           EB           02            jmp .275
10071                       00002BB5            .273:
10072 2BB5           B0                     A0  mov	al,#$A0
10073                       00002BB7            .275:
10074                                           ! Debug: or unsigned char head = [S+$E+$C] to char = al+0 (used reg = )
10075 2BB7           0A46         0E            or	al,$E[bp]
10076                                           ! Debug: list unsigned char = al+0 (used reg = )
10077 2BBA           30E4                       xor	ah,ah
10078 2BBC           50                         push	ax
10079                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$10-4] (used reg = )
10080 2BBD           8B46         FE            mov	ax,-2[bp]
10081                                           ! Debug: list unsigned int = ax+6 (used reg = )
10082 2BC0           05                   0006  add	ax,*6
10083 2BC3           50                         push	ax
10084                                           ! Debug: func () void = outb+0 (used reg = )
10085 2BC4           E8         D947            call	_outb
10086 2BC7           83C4                   04  add	sp,*4
10087                                           !BCC_EOS
10088                                           ! 1957   outb(iobase1 + 7, command);
10089                                           ! Debug: list unsigned short command = [S+$E+6] (used reg = )
10090 2BCA           FF76         08            push	8[bp]
10091                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-4] (used reg = )
10092 2BCD           8B46         FE            mov	ax,-2[bp]
10093                                           ! Debug: list unsigned int = ax+7 (used reg = )
10094 2BD0           05                   0007  add	ax,*7
10095 2BD3           50                         push	ax
10096                                           ! Debug: func () void = outb+0 (used reg = )
10097 2BD4           E8         D937            call	_outb
10098 2BD7           83C4                   04  add	sp,*4
10099                                           !BCC_EOS
10100                                           ! 1958   await_ide(3, iobase1, 32000u);
10101                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10102 2BDA           B8                   7D00  mov	ax,#$7D00
10103 2BDD           50                         push	ax
10104                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
10105 2BDE           FF76         FE            push	-2[bp]
10106                                           ! Debug: list int = const 3 (used reg = )
10107 2BE1           B8                   0003  mov	ax,*3
10108 2BE4           50                         push	ax
10109                                           ! Debug: func () int = await_ide+0 (used reg = )
10110 2BE5           E8         EE47            call	_await_ide
10111 2BE8           83C4                   06  add	sp,*6
10112                                           !BCC_EOS
10113                                           ! 1959   status = inb(iobase1 + 7);
10114                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$E-4] (used reg = )
10115 2BEB           8B46         FE            mov	ax,-2[bp]
10116                                           ! Debug: list unsigned int = ax+7 (used reg = )
10117 2BEE           05                   0007  add	ax,*7
10118 2BF1           50                         push	ax
10119                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10120 2BF2           E8         D903            call	_inb
10121 2BF5           44                         inc	sp
10122 2BF6           44                         inc	sp
10123                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$E-$B] (used reg = )
10124 2BF7           8846         F7            mov	-9[bp],al
10125                                           !BCC_EOS
10126                                           ! 1960   if (status & 0x01) {
10127                                           ! Debug: and int = const 1 to unsigned char status = [S+$E-$B] (used reg = )
10128 2BFA           8A46         F7            mov	al,-9[bp]
10129 2BFD           24                     01  and	al,*1
10130 2BFF           84C0                       test	al,al
10131 2C01           74           09            je  	.276
10132                       00002C03            .277:
10133                                           ! 1961     ;
10134                                           !BCC_EOS
10135                                           ! 1962     return 2;
10136 2C03           B8                   0002  mov	ax,*2
10137 2C06           89EC                       mov	sp,bp
10138 2C08           5D                         pop	bp
10139 2C09           C3                         ret
10140                                           !BCC_EOS
10141                                           ! 1963   } else if ( !(status & 0x08) ) {
10142 2C0A           EB           10            jmp .278
10143                       00002C0C            .276:
10144                                           ! Debug: and int = const 8 to unsigned char status = [S+$E-$B] (used reg = )
10145 2C0C           8A46         F7            mov	al,-9[bp]
10146 2C0F           24                     08  and	al,*8
10147 2C11           84C0                       test	al,al
10148 2C13           75           07            jne 	.279
10149                       00002C15            .27A:
10150                                           ! 1964     ;
10151                                           !BCC_EOS
10152                                           ! 1965     return 3;
10153 2C15           B8                   0003  mov	ax,*3
10154 2C18           89EC                       mov	sp,bp
10155 2C1A           5D                         pop	bp
10156 2C1B           C3                         ret
10157                                           !BCC_EOS
10158                                           ! 1966   }
10159                                           ! 1967 #asm
10160                       00002C1C            .279:
10161                       00002C1C            .278:
10162                                           !BCC_EOS
10163                                           !BCC_ASM
10164                       00000016            _ata_cmd_data_io.count	set	$16
10165                       0000000A            .ata_cmd_data_io.count	set	$A
10166                       00000026            _ata_cmd_data_io.segment	set	$26
10167                       0000001A            .ata_cmd_data_io.segment	set	$1A
10168                       0000000A            _ata_cmd_data_io.iobase1	set	$A
10169                       FFFFFFFE            .ata_cmd_data_io.iobase1	set	-2
10170                       00000005            _ata_cmd_data_io.channel	set	5
10171                       FFFFFFF9            .ata_cmd_data_io.channel	set	-7
10172                       0000001E            _ata_cmd_data_io.lba_low	set	$1E
10173                       00000012            .ata_cmd_data_io.lba_low	set	$12
10174                       00000022            _ata_cmd_data_io.lba_high	set	$22
10175                       00000016            .ata_cmd_data_io.lba_high	set	$16
10176                       0000001C            _ata_cmd_data_io.sector	set	$1C
10177                       00000010            .ata_cmd_data_io.sector	set	$10
10178                       00000006            _ata_cmd_data_io.blksize	set	6
10179                       FFFFFFFA            .ata_cmd_data_io.blksize	set	-6
10180                       0000001A            _ata_cmd_data_io.head	set	$1A
10181                       0000000E            .ata_cmd_data_io.head	set	$E
10182                       00000010            _ata_cmd_data_io.ioflag	set	$10
10183                       00000004            .ata_cmd_data_io.ioflag	set	4
10184                       00000018            _ata_cmd_data_io.cylinder	set	$18
10185                       0000000C            .ata_cmd_data_io.cylinder	set	$C
10186                       00000012            _ata_cmd_data_io.device	set	$12
10187                       00000006            .ata_cmd_data_io.device	set	6
10188                       00000003            _ata_cmd_data_io.status	set	3
10189                       FFFFFFF7            .ata_cmd_data_io.status	set	-9
10190                       00000002            _ata_cmd_data_io.current	set	2
10191                       FFFFFFF6            .ata_cmd_data_io.current	set	-$A
10192                       00000014            _ata_cmd_data_io.command	set	$14
10193                       00000008            .ata_cmd_data_io.command	set	8
10194                       00000001            _ata_cmd_data_io.mode	set	1
10195                       FFFFFFF5            .ata_cmd_data_io.mode	set	-$B
10196                       00000008            _ata_cmd_data_io.iobase2	set	8
10197                       FFFFFFFC            .ata_cmd_data_io.iobase2	set	-4
10198                       00000028            _ata_cmd_data_io.offset	set	$28
10199                       0000001C            .ata_cmd_data_io.offset	set	$1C
10200                       00000004            _ata_cmd_data_io.slave	set	4
10201                       FFFFFFF8            .ata_cmd_data_io.slave	set	-8
10202 2C1C           FB                                 sti ;; enable higher priority interrupts
10203                                           ! 1969 endasm
10204                                           !BCC_ENDASM
10205                                           !BCC_EOS
10206                                           ! 1970   while (1) {
10207                       00002C1D            .27D:
10208                                           ! 1971     if(ioflag == 0)
10209                                           ! Debug: logeq int = const 0 to unsigned short ioflag = [S+$E+2] (used reg = )
10210 2C1D           8B46         04            mov	ax,4[bp]
10211 2C20           85C0                       test	ax,ax
10212 2C22           75           36            jne 	.27E
10213                       00002C24            .27F:
10214                                           ! 1972     {
10215                                           ! 1973 #asm
10216                                           !BCC_EOS
10217                                           !BCC_ASM
10218                       00000016            _ata_cmd_data_io.count	set	$16
10219                       0000000A            .ata_cmd_data_io.count	set	$A
10220                       00000026            _ata_cmd_data_io.segment	set	$26
10221                       0000001A            .ata_cmd_data_io.segment	set	$1A
10222                       0000000A            _ata_cmd_data_io.iobase1	set	$A
10223                       FFFFFFFE            .ata_cmd_data_io.iobase1	set	-2
10224                       00000005            _ata_cmd_data_io.channel	set	5
10225                       FFFFFFF9            .ata_cmd_data_io.channel	set	-7
10226                       0000001E            _ata_cmd_data_io.lba_low	set	$1E
10227                       00000012            .ata_cmd_data_io.lba_low	set	$12
10228                       00000022            _ata_cmd_data_io.lba_high	set	$22
10229                       00000016            .ata_cmd_data_io.lba_high	set	$16
10230                       0000001C            _ata_cmd_data_io.sector	set	$1C
10231                       00000010            .ata_cmd_data_io.sector	set	$10
10232                       00000006            _ata_cmd_data_io.blksize	set	6
10233                       FFFFFFFA            .ata_cmd_data_io.blksize	set	-6
10234                       0000001A            _ata_cmd_data_io.head	set	$1A
10235                       0000000E            .ata_cmd_data_io.head	set	$E
10236                       00000010            _ata_cmd_data_io.ioflag	set	$10
10237                       00000004            .ata_cmd_data_io.ioflag	set	4
10238                       00000018            _ata_cmd_data_io.cylinder	set	$18
10239                       0000000C            .ata_cmd_data_io.cylinder	set	$C
10240                       00000012            _ata_cmd_data_io.device	set	$12
10241                       00000006            .ata_cmd_data_io.device	set	6
10242                       00000003            _ata_cmd_data_io.status	set	3
10243                       FFFFFFF7            .ata_cmd_data_io.status	set	-9
10244                       00000002            _ata_cmd_data_io.current	set	2
10245                       FFFFFFF6            .ata_cmd_data_io.current	set	-$A
10246                       00000014            _ata_cmd_data_io.command	set	$14
10247                       00000008            .ata_cmd_data_io.command	set	8
10248                       00000001            _ata_cmd_data_io.mode	set	1
10249                       FFFFFFF5            .ata_cmd_data_io.mode	set	-$B
10250                       00000008            _ata_cmd_data_io.iobase2	set	8
10251                       FFFFFFFC            .ata_cmd_data_io.iobase2	set	-4
10252                       00000028            _ata_cmd_data_io.offset	set	$28
10253                       0000001C            .ata_cmd_data_io.offset	set	$1C
10254                       00000004            _ata_cmd_data_io.slave	set	4
10255                       FFFFFFF8            .ata_cmd_data_io.slave	set	-8
10256 2C24           55                                 push bp
10257 2C25           89E5                               mov bp, sp
10258 2C27           8B7E         2A                    mov di, _ata_cmd_data_io.offset + 2[bp]
10259 2C2A           8B46         28                    mov ax, _ata_cmd_data_io.segment + 2[bp]
10260 2C2D           8B4E         08                    mov cx, _ata_cmd_data_io.blksize + 2[bp]
10261                                                   ;; adjust if there will be an overrun. 2K max sector size
10262 2C30           81FF                 F800          cmp di, #0xf800 ;;
10263 2C34           76           07                    jbe ata_in_no_adjust
10264                       00002C36            ata_in_adjust:
10265 2C36           81EF                 0800          sub di, #0x0800 ;; sub 2 kbytes from offset
10266 2C3A           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
10267                       00002C3D            ata_in_no_adjust:
10268 2C3D           8EC0                               mov es, ax ;; segment in es
10269 2C3F           8B56         0C                    mov dx, _ata_cmd_data_io.iobase1 + 2[bp] ;; ATA data read port
10270 2C42           8A66         03                    mov ah, _ata_cmd_data_io.mode + 2[bp]
10271 2C45           80FC                   01          cmp ah, #0x01
10272 2C48           74           04                    je ata_in_32
10273                       00002C4A            ata_in_16:
10274 2C4A           F3                                 rep
10275 2C4B           6D                                   insw ;; CX words transferred from port(DX) to ES:[DI]
10276 2C4C           EB           03                    jmp ata_in_done
10277                       00002C4E            ata_in_32:
10278 2C4E           F3                                 rep
10279 2C4F     66    6D                                   insd ;; CX dwords transferred from port(DX) to ES:[DI]
10280                       00002C51            ata_in_done:
10281 2C51           897E         2A                    mov _ata_cmd_data_io.offset + 2[bp], di
10282 2C54           8C46         28                    mov _ata_cmd_data_io.segment + 2[bp], es
10283 2C57           5D                                 pop bp
10284                                           ! 2002 endasm
10285                                           !BCC_ENDASM
10286                                           !BCC_EOS
10287                                           ! 2003     }
10288                                           ! 2004     else
10289                                           ! 2005     {
10290 2C58           EB           36            jmp .280
10291                       00002C5A            .27E:
10292                                           ! 2006 #asm
10293                                           !BCC_EOS
10294                                           !BCC_ASM
10295                       00000016            _ata_cmd_data_io.count	set	$16
10296                       0000000A            .ata_cmd_data_io.count	set	$A
10297                       00000026            _ata_cmd_data_io.segment	set	$26
10298                       0000001A            .ata_cmd_data_io.segment	set	$1A
10299                       0000000A            _ata_cmd_data_io.iobase1	set	$A
10300                       FFFFFFFE            .ata_cmd_data_io.iobase1	set	-2
10301                       00000005            _ata_cmd_data_io.channel	set	5
10302                       FFFFFFF9            .ata_cmd_data_io.channel	set	-7
10303                       0000001E            _ata_cmd_data_io.lba_low	set	$1E
10304                       00000012            .ata_cmd_data_io.lba_low	set	$12
10305                       00000022            _ata_cmd_data_io.lba_high	set	$22
10306                       00000016            .ata_cmd_data_io.lba_high	set	$16
10307                       0000001C            _ata_cmd_data_io.sector	set	$1C
10308                       00000010            .ata_cmd_data_io.sector	set	$10
10309                       00000006            _ata_cmd_data_io.blksize	set	6
10310                       FFFFFFFA            .ata_cmd_data_io.blksize	set	-6
10311                       0000001A            _ata_cmd_data_io.head	set	$1A
10312                       0000000E            .ata_cmd_data_io.head	set	$E
10313                       00000010            _ata_cmd_data_io.ioflag	set	$10
10314                       00000004            .ata_cmd_data_io.ioflag	set	4
10315                       00000018            _ata_cmd_data_io.cylinder	set	$18
10316                       0000000C            .ata_cmd_data_io.cylinder	set	$C
10317                       00000012            _ata_cmd_data_io.device	set	$12
10318                       00000006            .ata_cmd_data_io.device	set	6
10319                       00000003            _ata_cmd_data_io.status	set	3
10320                       FFFFFFF7            .ata_cmd_data_io.status	set	-9
10321                       00000002            _ata_cmd_data_io.current	set	2
10322                       FFFFFFF6            .ata_cmd_data_io.current	set	-$A
10323                       00000014            _ata_cmd_data_io.command	set	$14
10324                       00000008            .ata_cmd_data_io.command	set	8
10325                       00000001            _ata_cmd_data_io.mode	set	1
10326                       FFFFFFF5            .ata_cmd_data_io.mode	set	-$B
10327                       00000008            _ata_cmd_data_io.iobase2	set	8
10328                       FFFFFFFC            .ata_cmd_data_io.iobase2	set	-4
10329                       00000028            _ata_cmd_data_io.offset	set	$28
10330                       0000001C            .ata_cmd_data_io.offset	set	$1C
10331                       00000004            _ata_cmd_data_io.slave	set	4
10332                       FFFFFFF8            .ata_cmd_data_io.slave	set	-8
10333 2C5A           55                                 push bp
10334 2C5B           89E5                               mov bp, sp
10335 2C5D           8B76         2A                    mov si, _ata_cmd_data_io.offset + 2[bp]
10336 2C60           8B46         28                    mov ax, _ata_cmd_data_io.segment + 2[bp]
10337 2C63           8B4E         08                    mov cx, _ata_cmd_data_io.blksize + 2[bp]
10338                                                   ;; adjust if there will be an overrun. 2K max sector size
10339 2C66           81FE                 F800          cmp si, #0xf800 ;;
10340 2C6A           76           07                    jbe ata_out_no_adjust
10341                       00002C6C            ata_out_adjust:
10342 2C6C           81EE                 0800          sub si, #0x0800 ;; sub 2 kbytes from offset
10343 2C70           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
10344                       00002C73            ata_out_no_adjust:
10345 2C73           8EC0                               mov es, ax ;; segment in es
10346 2C75           8B56         0C                    mov dx, _ata_cmd_data_io.iobase1 + 2[bp] ;; ATA data write port
10347 2C78           8A66         03                    mov ah, _ata_cmd_data_io.mode + 2[bp]
10348 2C7B           80FC                   01          cmp ah, #0x01
10349 2C7E           74           05                    je ata_out_32
10350                       00002C80            ata_out_16:
10351 2C80           26                                 seg ES
10352 2C81           F3                                 rep
10353 2C82           6F                                   outsw ;; CX words transferred from port(DX) to ES:[SI]
10354 2C83           EB           04                    jmp ata_out_done
10355                       00002C85            ata_out_32:
10356 2C85           26                                 seg ES
10357 2C86           F3                                 rep
10358 2C87     66    6F                                   outsd ;; CX dwords transferred from port(DX) to ES:[SI]
10359                       00002C89            ata_out_done:
10360 2C89           8976         2A                    mov _ata_cmd_data_io.offset + 2[bp], si
10361 2C8C           8C46         28                    mov _ata_cmd_data_io.segment + 2[bp], es
10362 2C8F           5D                                 pop bp
10363                                           ! 2037 endasm
10364                                           !BCC_ENDASM
10365                                           !BCC_EOS
10366                                           ! 2038     }
10367                                           ! 2039     current++;
10368                       00002C90            .280:
10369                                           ! Debug: postinc unsigned char current = [S+$E-$C] (used reg = )
10370 2C90           8A46         F6            mov	al,-$A[bp]
10371 2C93           40                         inc	ax
10372 2C94           8846         F6            mov	-$A[bp],al
10373                                           !BCC_EOS
10374                                           ! 2040     *((Bit16u *)(&((ebda_data_t *) 0)->ata.trsfsectors)) = (current);
10375                                           ! Debug: eq unsigned char current = [S+$E-$C] to unsigned short = [+$254] (used reg = )
10376 2C97           8A46         F6            mov	al,-$A[bp]
10377 2C9A           30E4                       xor	ah,ah
10378 2C9C           A3         0254            mov	[$254],ax
10379                                           !BCC_EOS
10380                                           ! 2041     count--;
10381                                           ! Debug: postdec unsigned short count = [S+$E+8] (used reg = )
10382 2C9F           8B46         0A            mov	ax,$A[bp]
10383 2CA2           48                         dec	ax
10384 2CA3           8946         0A            mov	$A[bp],ax
10385                                           !BCC_EOS
10386                                           ! 2042     if(ioflag == 0) await_ide(2, iobase1, 32000u);
10387                                           ! Debug: logeq int = const 0 to unsigned short ioflag = [S+$E+2] (used reg = )
10388 2CA6           8B46         04            mov	ax,4[bp]
10389 2CA9           85C0                       test	ax,ax
10390 2CAB           75           11            jne 	.281
10391                       00002CAD            .282:
10392                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10393 2CAD           B8                   7D00  mov	ax,#$7D00
10394 2CB0           50                         push	ax
10395                                           ! Debug: list unsigned short iobase1 = [S+$10-4] (used reg = )
10396 2CB1           FF76         FE            push	-2[bp]
10397                                           ! Debug: list int = const 2 (used reg = )
10398 2CB4           B8                   0002  mov	ax,*2
10399 2CB7           50                         push	ax
10400                                           ! Debug: func () int = await_ide+0 (used reg = )
10401 2CB8           E8         ED74            call	_await_ide
10402 2CBB           83C4                   06  add	sp,*6
10403                                           !BCC_EOS
10404                                           ! 2043     status = inb(iobase1 + 7);
10405                       00002CBE            .281:
10406                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$E-4] (used reg = )
10407 2CBE           8B46         FE            mov	ax,-2[bp]
10408                                           ! Debug: list unsigned int = ax+7 (used reg = )
10409 2CC1           05                   0007  add	ax,*7
10410 2CC4           50                         push	ax
10411                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10412 2CC5           E8         D830            call	_inb
10413 2CC8           44                         inc	sp
10414 2CC9           44                         inc	sp
10415                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$E-$B] (used reg = )
10416 2CCA           8846         F7            mov	-9[bp],al
10417                                           !BCC_EOS
10418                                           ! 2044     if(ioflag == 0)
10419                                           ! Debug: logeq int = const 0 to unsigned short ioflag = [S+$E+2] (used reg = )
10420 2CCD           8B46         04            mov	ax,4[bp]
10421 2CD0           85C0                       test	ax,ax
10422 2CD2           75           2F            jne 	.283
10423                       00002CD4            .284:
10424                                           ! 2045     {
10425                                           ! 2046       if (count == 0) {
10426                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$E+8] (used reg = )
10427 2CD4           8B46         0A            mov	ax,$A[bp]
10428 2CD7           85C0                       test	ax,ax
10429 2CD9           75           14            jne 	.285
10430                       00002CDB            .286:
10431                                           ! 2047         if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
10432                                           ! 2048             != 0x40 ) {
10433                                           ! Debug: and int = const $C9 to unsigned char status = [S+$E-$B] (used reg = )
10434 2CDB           8A46         F7            mov	al,-9[bp]
10435 2CDE           24                     C9  and	al,#$C9
10436                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
10437 2CE0           3C                     40  cmp	al,*$40
10438 2CE2           74           07            je  	.287
10439                       00002CE4            .288:
10440                                           ! 2049           ;
10441                                           !BCC_EOS
10442                                           ! 2050           return 4;
10443 2CE4           B8                   0004  mov	ax,*4
10444 2CE7           89EC                       mov	sp,bp
10445 2CE9           5D                         pop	bp
10446 2CEA           C3                         ret
10447                                           !BCC_EOS
10448                                           ! 2051         }
10449                                           ! 2052         break;
10450                       00002CEB            .287:
10451 2CEB           EB           46            jmp .27B
10452                                           !BCC_EOS
10453                                           ! 2053       }
10454                                           ! 2054       else {
10455 2CED           EB           12            jmp .289
10456                       00002CEF            .285:
10457                                           ! 2055         if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
10458                                           ! 2056             != (0x40 | 0x08) ) {
10459                                           ! Debug: and int = const $C9 to unsigned char status = [S+$E-$B] (used reg = )
10460 2CEF           8A46         F7            mov	al,-9[bp]
10461 2CF2           24                     C9  and	al,#$C9
10462                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
10463 2CF4           3C                     48  cmp	al,*$48
10464 2CF6           74           07            je  	.28A
10465                       00002CF8            .28B:
10466                                           ! 2057           ;
10467                                           !BCC_EOS
10468                                           ! 2058           return 5;
10469 2CF8           B8                   0005  mov	ax,*5
10470 2CFB           89EC                       mov	sp,bp
10471 2CFD           5D                         pop	bp
10472 2CFE           C3                         ret
10473                                           !BCC_EOS
10474                                           ! 2059         }
10475                                           ! 2060         continue;
10476                       00002CFF            .28A:
10477 2CFF           EB           2F            jmp .27C
10478                                           !BCC_EOS
10479                                           ! 2061       }
10480                                           ! 2062     }
10481                       00002D01            .289:
10482                                           ! 2063     else
10483                                           ! 2064     {
10484 2D01           EB           2D            jmp .28C
10485                       00002D03            .283:
10486                                           ! 2065       if (count == 0) {
10487                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$E+8] (used reg = )
10488 2D03           8B46         0A            mov	ax,$A[bp]
10489 2D06           85C0                       test	ax,ax
10490 2D08           75           14            jne 	.28D
10491                       00002D0A            .28E:
10492                                           ! 2066         if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
10493                                           ! 2067             != 0x40 ) {
10494                                           ! Debug: and int = const $E9 to unsigned char status = [S+$E-$B] (used reg = )
10495 2D0A           8A46         F7            mov	al,-9[bp]
10496 2D0D           24                     E9  and	al,#$E9
10497                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
10498 2D0F           3C                     40  cmp	al,*$40
10499 2D11           74           07            je  	.28F
10500                       00002D13            .290:
10501                                           ! 2068           ;
10502                                           !BCC_EOS
10503                                           ! 2069           return 6;
10504 2D13           B8                   0006  mov	ax,*6
10505 2D16           89EC                       mov	sp,bp
10506 2D18           5D                         pop	bp
10507 2D19           C3                         ret
10508                                           !BCC_EOS
10509                                           ! 2070         }
10510                                           ! 2071         break;
10511                       00002D1A            .28F:
10512 2D1A           EB           17            jmp .27B
10513                                           !BCC_EOS
10514                                           ! 2072       }
10515                                           ! 2073       else {
10516 2D1C           EB           12            jmp .291
10517                       00002D1E            .28D:
10518                                           ! 2074         if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
10519                                           ! 2075             !=
10520                                           ! 2075  (0x40 | 0x08) ) {
10521                                           ! Debug: and int = const $C9 to unsigned char status = [S+$E-$B] (used reg = )
10522 2D1E           8A46         F7            mov	al,-9[bp]
10523 2D21           24                     C9  and	al,#$C9
10524                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
10525 2D23           3C                     48  cmp	al,*$48
10526 2D25           74           07            je  	.292
10527                       00002D27            .293:
10528                                           ! 2076           ;
10529                                           !BCC_EOS
10530                                           ! 2077           return 7;
10531 2D27           B8                   0007  mov	ax,*7
10532 2D2A           89EC                       mov	sp,bp
10533 2D2C           5D                         pop	bp
10534 2D2D           C3                         ret
10535                                           !BCC_EOS
10536                                           ! 2078         }
10537                                           ! 2079         continue;
10538                       00002D2E            .292:
10539 2D2E           EB           00            jmp .27C
10540                                           !BCC_EOS
10541                                           ! 2080       }
10542                                           ! 2081     }
10543                       00002D30            .291:
10544                                           ! 2082   }
10545                       00002D30            .28C:
10546                                           ! 2083   outb(iobase2+6, 0x08);
10547                       00002D30            .27C:
10548 2D30           E9         FEEA            br 	.27D
10549                       00002D33            .294:
10550                       00002D33            .27B:
10551                                           ! Debug: list int = const 8 (used reg = )
10552 2D33           B8                   0008  mov	ax,*8
10553 2D36           50                         push	ax
10554                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-6] (used reg = )
10555 2D37           8B46         FC            mov	ax,-4[bp]
10556                                           ! Debug: list unsigned int = ax+6 (used reg = )
10557 2D3A           05                   0006  add	ax,*6
10558 2D3D           50                         push	ax
10559                                           ! Debug: func () void = outb+0 (used reg = )
10560 2D3E           E8         D7CD            call	_outb
10561 2D41           83C4                   04  add	sp,*4
10562                                           !BCC_EOS
10563                                           ! 2084   return 0;
10564 2D44           31C0                       xor	ax,ax
10565 2D46           89EC                       mov	sp,bp
10566 2D48           5D                         pop	bp
10567 2D49           C3                         ret
10568                                           !BCC_EOS
10569                                           ! 2085 }
10570                                           ! 2086 Bit16u ata_cmd_packet(device, cmdlen, cmdseg, cmdoff, header, length, inout, bufseg, bufoff)
10571                                           ! Register BX used in function ata_cmd_data_io
10572                                           ! 2087 Bit8u cmdlen,inout;
10573                                           export	_ata_cmd_packet
10574                       00002D4A            _ata_cmd_packet:
10575                                           !BCC_EOS
10576                                           ! 2088 Bit16u device,cmdseg, cmdoff, bufseg, bufoff;
10577                                           !BCC_EOS
10578                                           ! 2089 Bit16u header;
10579                                           !BCC_EOS
10580                                           ! 2090 Bit32u length;
10581                                           !BCC_EOS
10582                                           ! 2091 {
10583                                           ! 2092   Bit16u ebda_seg=get_ebda_seg(), old_ds;
10584 2D4A           55                         push	bp
10585 2D4B           89E5                       mov	bp,sp
10586 2D4D           4C                         dec	sp
10587 2D4E           4C                         dec	sp
10588                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
10589 2D4F           E8         D91A            call	_get_ebda_seg
10590                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
10591 2D52           8946         FE            mov	-2[bp],ax
10592                                           !BCC_EOS
10593                                           ! 2093   Bit16u iobase1, iobase2;
10594                                           !BCC_EOS
10595                                           ! 2094   Bit16u lcount, lbefore, lafter, count;
10596                                           !BCC_EOS
10597                                           ! 2095   Bit8u channel, slave;
10598                                           !BCC_EOS
10599                                           ! 2096   Bit8u status, mode, lmode;
10600                                           !BCC_EOS
10601                                           ! 2097   Bit32u total, transfer;
10602                                           !BCC_EOS
10603                                           ! 2098   channel = device / 2;
10604 2D55           83C4                   E4  add	sp,*-$1C
10605                                           ! Debug: div int = const 2 to unsigned short device = [S+$20+2] (used reg = )
10606 2D58           8B46         04            mov	ax,4[bp]
10607 2D5B           D1E8                       shr	ax,*1
10608                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$20-$13] (used reg = )
10609 2D5D           8846         EF            mov	-$11[bp],al
10610                                           !BCC_EOS
10611                                           ! 2099   slave = device % 2;
10612                                           ! Debug: mod int = const 2 to unsigned short device = [S+$20+2] (used reg = )
10613 2D60           8B46         04            mov	ax,4[bp]
10614 2D63           24                     01  and	al,*1
10615                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$20-$14] (used reg = )
10616 2D65           8846         EE            mov	-$12[bp],al
10617                                           !BCC_EOS
10618                                           ! 2100   if (inout == 0x02) {
10619                                           ! Debug: logeq int = const 2 to unsigned char inout = [S+$20+$10] (used reg = )
10620 2D68           8A46         12            mov	al,$12[bp]
10621 2D6B           3C                     02  cmp	al,*2
10622 2D6D           75           15            jne 	.295
10623                       00002D6F            .296:
10624                                           ! 2101     bios_printf(4, "ata_cmd_packet: DATA_OUT not supported yet\n");
10625                                           ! Debug: list * char = .297+0 (used reg = )
10626 2D6F           BB                   D650  mov	bx,#.297
10627 2D72           53                         push	bx
10628                                           ! Debug: list int = const 4 (used reg = )
10629 2D73           B8                   0004  mov	ax,*4
10630 2D76           50                         push	ax
10631                                           ! Debug: func () void = bios_printf+0 (used reg = )
10632 2D77           E8         DBC4            call	_bios_printf
10633 2D7A           83C4                   04  add	sp,*4
10634                                           !BCC_EOS
10635                                           ! 2102     return 1;
10636 2D7D           B8                   0001  mov	ax,*1
10637 2D80           89EC                       mov	sp,bp
10638 2D82           5D                         pop	bp
10639 2D83           C3                         ret
10640                                           !BCC_EOS
10641                                           ! 2103   }
10642                                           ! 2104   if (header & 1) {
10643                       00002D84            .295:
10644                                           ! Debug: and int = const 1 to unsigned short header = [S+$20+$A] (used reg = )
10645 2D84           8A46         0C            mov	al,$C[bp]
10646 2D87           24                     01  and	al,*1
10647 2D89           84C0                       test	al,al
10648 2D8B           74           07            je  	.298
10649                       00002D8D            .299:
10650                                           ! 2105     ;
10651                                           !BCC_EOS
10652                                           ! 2106     return 1;
10653 2D8D           B8                   0001  mov	ax,*1
10654 2D90           89EC                       mov	sp,bp
10655 2D92           5D                         pop	bp
10656 2D93           C3                         ret
10657                                           !BCC_EOS
10658                                           ! 2107   }
10659                                           ! 2108   old_ds = set_DS(ebda_seg);
10660                       00002D94            .298:
10661                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
10662 2D94           FF76         FE            push	-2[bp]
10663                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
10664 2D97           E8         D8C8            call	_set_DS
10665 2D9A           44                         inc	sp
10666 2D9B           44                         inc	sp
10667                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+$20-6] (used reg = )
10668 2D9C           8946         FC            mov	-4[bp],ax
10669                                           !BCC_EOS
10670                                           ! 2109   iobase1 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1));
10671                                           ! Debug: ptradd unsigned char channel = [S+$20-$13] to [4] struct  = const $122 (used reg = )
10672 2D9F           8A46         EF            mov	al,-$11[bp]
10673 2DA2           30E4                       xor	ah,ah
10674 2DA4           B1                     03  mov	cl,*3
10675 2DA6           D3E0                       shl	ax,cl
10676 2DA8           89C3                       mov	bx,ax
10677                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
10678                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
10679                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$20-8] (used reg = )
10680 2DAA           8B9F       0124            mov	bx,$124[bx]
10681 2DAE           895E         FA            mov	-6[bp],bx
10682                                           !BCC_EOS
10683                                           ! 2110   iobase2 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2));
10684                                           ! Debug: ptradd unsigned char channel = [S+$20-$13] to [4] struct  = const $122 (used reg = )
10685 2DB1           8A46         EF            mov	al,-$11[bp]
10686 2DB4           30E4                       xor	ah,ah
10687 2DB6           B1                     03  mov	cl,*3
10688 2DB8           D3E0                       shl	ax,cl
10689 2DBA           89C3                       mov	bx,ax
10690                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
10691                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
10692                                           ! Debug: eq unsigned short = [bx+$126] to unsigned short iobase2 = [S+$20-$A] (used reg = )
10693 2DBC           8B9F       0126            mov	bx,$126[bx]
10694 2DC0           895E         F8            mov	-8[bp],bx
10695                                           !BCC_EOS
10696                                           ! 2111   mode = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode));
10697                                           ! Debug: ptradd unsigned short device = [S+$20+2] to [8] struct  = const $142 (used reg = )
10698 2DC3           8B46         04            mov	ax,4[bp]
10699 2DC6           B9                   001E  mov	cx,*$1E
10700 2DC9           F7E9                       imul	cx
10701 2DCB           89C3                       mov	bx,ax
10702                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
10703                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
10704                                           ! Debug: eq unsigned char = [bx+$146] to unsigned char mode = [S+$20-$16] (used reg = )
10705 2DCD           8A87       0146            mov	al,$146[bx]
10706 2DD1           8846         EC            mov	-$14[bp],al
10707                                           !BCC_EOS
10708                                           ! 2112   transfer= 0L;
10709                                           ! Debug: eq long = const 0 to unsigned long transfer = [S+$20-$20] (used reg = )
10710 2DD4           31C0                       xor	ax,ax
10711 2DD6           31DB                       xor	bx,bx
10712 2DD8           8946         E2            mov	-$1E[bp],ax
10713 2DDB           895E         E4            mov	-$1C[bp],bx
10714                                           !BCC_EOS
10715                                           ! 2113   if (cmdlen < 12) cmdlen=12;
10716                                           ! Debug: lt int = const $C to unsigned char cmdlen = [S+$20+4] (used reg = )
10717 2DDE           8A46         06            mov	al,6[bp]
10718 2DE1           3C                     0C  cmp	al,*$C
10719 2DE3           73           05            jae 	.29A
10720                       00002DE5            .29B:
10721                                           ! Debug: eq int = const $C to unsigned char cmdlen = [S+$20+4] (used reg = )
10722 2DE5           B0                     0C  mov	al,*$C
10723 2DE7           8846         06            mov	6[bp],al
10724                                           !BCC_EOS
10725                                           ! 2114   if (cmdlen > 12) cmdlen=16;
10726                       00002DEA            .29A:
10727                                           ! Debug: gt int = const $C to unsigned char cmdlen = [S+$20+4] (used reg = )
10728 2DEA           8A46         06            mov	al,6[bp]
10729 2DED           3C                     0C  cmp	al,*$C
10730 2DEF           76           05            jbe 	.29C
10731                       00002DF1            .29D:
10732                                           ! Debug: eq int = const $10 to unsigned char cmdlen = [S+$20+4] (used reg = )
10733 2DF1           B0                     10  mov	al,*$10
10734 2DF3           8846         06            mov	6[bp],al
10735                                           !BCC_EOS
10736                                           ! 2115   cmdlen>>=1;
10737                       00002DF6            .29C:
10738                                           ! Debug: srab int = const 1 to unsigned char cmdlen = [S+$20+4] (used reg = )
10739 2DF6           8A46         06            mov	al,6[bp]
10740 2DF9           30E4                       xor	ah,ah
10741 2DFB           D1E8                       shr	ax,*1
10742 2DFD           8846         06            mov	6[bp],al
10743                                           !BCC_EOS
10744                                           ! 2116   *((Bit16u *)(&((ebda_data_t *) 0)->ata.trsfsectors)) = (0);
10745                                           ! Debug: eq int = const 0 to unsigned short = [+$254] (used reg = )
10746 2E00           31C0                       xor	ax,ax
10747 2E02           A3         0254            mov	[$254],ax
10748                                           !BCC_EOS
10749                                           ! 2117   *((Bit32u *)(&((ebda_data_t *) 0)->ata.trsfbytes)) = (0L);
10750                                           ! Debug: eq long = const 0 to unsigned long = [+$256] (used reg = )
10751 2E05           31C0                       xor	ax,ax
10752 2E07           31DB                       xor	bx,bx
10753 2E09           A3         0256            mov	[$256],ax
10754 2E0C           891E       0258            mov	[$258],bx
10755                                           !BCC_EOS
10756                                           ! 2118   set_DS(old_ds);
10757                                           ! Debug: list unsigned short old_ds = [S+$20-6] (used reg = )
10758 2E10           FF76         FC            push	-4[bp]
10759                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
10760 2E13           E8         D84C            call	_set_DS
10761 2E16           44                         inc	sp
10762 2E17           44                         inc	sp
10763                                           !BCC_EOS
10764                                           ! 2119   status = inb(iobase1 + 7);
10765                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-8] (used reg = )
10766 2E18           8B46         FA            mov	ax,-6[bp]
10767                                           ! Debug: list unsigned int = ax+7 (used reg = )
10768 2E1B           05                   0007  add	ax,*7
10769 2E1E           50                         push	ax
10770                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10771 2E1F           E8         D6D6            call	_inb
10772 2E22           44                         inc	sp
10773 2E23           44                         inc	sp
10774                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$20-$15] (used reg = )
10775 2E24           8846         ED            mov	-$13[bp],al
10776                                           !BCC_EOS
10777                                           ! 2120   if (status & 0x80) return 2;
10778                                           ! Debug: and int = const $80 to unsigned char status = [S+$20-$15] (used reg = )
10779 2E27           8A46         ED            mov	al,-$13[bp]
10780 2E2A           24                     80  and	al,#$80
10781 2E2C           84C0                       test	al,al
10782 2E2E           74           07            je  	.29E
10783                       00002E30            .29F:
10784 2E30           B8                   0002  mov	ax,*2
10785 2E33           89EC                       mov	sp,bp
10786 2E35           5D                         pop	bp
10787 2E36           C3                         ret
10788                                           !BCC_EOS
10789                                           ! 2121   outb(iobase2 + 6, 0x08 | 0x02);
10790                       00002E37            .29E:
10791                                           ! Debug: list int = const $A (used reg = )
10792 2E37           B8                   000A  mov	ax,*$A
10793 2E3A           50                         push	ax
10794                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$22-$A] (used reg = )
10795 2E3B           8B46         F8            mov	ax,-8[bp]
10796                                           ! Debug: list unsigned int = ax+6 (used reg = )
10797 2E3E           05                   0006  add	ax,*6
10798 2E41           50                         push	ax
10799                                           ! Debug: func () void = outb+0 (used reg = )
10800 2E42           E8         D6C9            call	_outb
10801 2E45           83C4                   04  add	sp,*4
10802                                           !BCC_EOS
10803                                           ! 2122   outb(iobase1 + 1, 0x00);
10804                                           ! Debug: list int = const 0 (used reg = )
10805 2E48           31C0                       xor	ax,ax
10806 2E4A           50                         push	ax
10807                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$22-8] (used reg = )
10808 2E4B           8B46         FA            mov	ax,-6[bp]
10809                                           ! Debug: list unsigned int = ax+1 (used reg = )
10810 2E4E           40                         inc	ax
10811 2E4F           50                         push	ax
10812                                           ! Debug: func () void = outb+0 (used reg = )
10813 2E50           E8         D6BB            call	_outb
10814 2E53           83C4                   04  add	sp,*4
10815                                           !BCC_EOS
10816                                           ! 2123   outb(iobase1 + 2, 0x00);
10817                                           ! Debug: list int = const 0 (used reg = )
10818 2E56           31C0                       xor	ax,ax
10819 2E58           50                         push	ax
10820                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-8] (used reg = )
10821 2E59           8B46         FA            mov	ax,-6[bp]
10822                                           ! Debug: list unsigned int = ax+2 (used reg = )
10823 2E5C           40                         inc	ax
10824 2E5D           40                         inc	ax
10825 2E5E           50                         push	ax
10826                                           ! Debug: func () void = outb+0 (used reg = )
10827 2E5F           E8         D6AC            call	_outb
10828 2E62           83C4                   04  add	sp,*4
10829                                           !BCC_EOS
10830                                           ! 2124   outb(iobase1 + 3, 0x00);
10831                                           ! Debug: list int = const 0 (used reg = )
10832 2E65           31C0                       xor	ax,ax
10833 2E67           50                         push	ax
10834                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$22-8] (used reg = )
10835 2E68           8B46         FA            mov	ax,-6[bp]
10836                                           ! Debug: list unsigned int = ax+3 (used reg = )
10837 2E6B           05                   0003  add	ax,*3
10838 2E6E           50                         push	ax
10839                                           ! Debug: func () void = outb+0 (used reg = )
10840 2E6F           E8         D69C            call	_outb
10841 2E72           83C4                   04  add	sp,*4
10842                                           !BCC_EOS
10843                                           ! 2125   outb(iobase1 + 4, 0xfff0 & 0x00ff);
10844                                           ! Debug: list unsigned int = const $F0 (used reg = )
10845 2E75           B8                   00F0  mov	ax,#$F0
10846 2E78           50                         push	ax
10847                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$22-8] (used reg = )
10848 2E79           8B46         FA            mov	ax,-6[bp]
10849                                           ! Debug: list unsigned int = ax+4 (used reg = )
10850 2E7C           05                   0004  add	ax,*4
10851 2E7F           50                         push	ax
10852                                           ! Debug: func () void = outb+0 (used reg = )
10853 2E80           E8         D68B            call	_outb
10854 2E83           83C4                   04  add	sp,*4
10855                                           !BCC_EOS
10856                                           ! 2126   outb(iobase1 + 5, 0xfff0 >> 8);
10857                                           ! Debug: list unsigned int = const $FF (used reg = )
10858 2E86           B8                   00FF  mov	ax,#$FF
10859 2E89           50                         push	ax
10860                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$22-8] (used reg = )
10861 2E8A           8B46         FA            mov	ax,-6[bp]
10862                                           ! Debug: list unsigned int = ax+5 (used reg = )
10863 2E8D           05                   0005  add	ax,*5
10864 2E90           50                         push	ax
10865                                           ! Debug: func () void = outb+0 (used reg = )
10866 2E91           E8         D67A            call	_outb
10867 2E94           83C4                   04  add	sp,*4
10868                                           !BCC_EOS
10869                                           ! 2127   outb(iobase1 + 6, slave ? 0xb0 : 0xa0);
10870 2E97           8A46         EE            mov	al,-$12[bp]
10871 2E9A           84C0                       test	al,al
10872 2E9C           74           04            je  	.2A0
10873                       00002E9E            .2A1:
10874 2E9E           B0                     B0  mov	al,#$B0
10875 2EA0           EB           02            jmp .2A2
10876                       00002EA2            .2A0:
10877 2EA2           B0                     A0  mov	al,#$A0
10878                       00002EA4            .2A2:
10879                                           ! Debug: list char = al+0 (used reg = )
10880 2EA4           30E4                       xor	ah,ah
10881 2EA6           50                         push	ax
10882                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$22-8] (used reg = )
10883 2EA7           8B46         FA            mov	ax,-6[bp]
10884                                           ! Debug: list unsigned int = ax+6 (used reg = )
10885 2EAA           05                   0006  add	ax,*6
10886 2EAD           50                         push	ax
10887                                           ! Debug: func () void = outb+0 (used reg = )
10888 2EAE           E8         D65D            call	_outb
10889 2EB1           83C4                   04  add	sp,*4
10890                                           !BCC_EOS
10891                                           ! 2128   outb(iobase1 + 7, 0xA0);
10892                                           ! Debug: list int = const $A0 (used reg = )
10893 2EB4           B8                   00A0  mov	ax,#$A0
10894 2EB7           50                         push	ax
10895                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$22-8] (used reg = )
10896 2EB8           8B46         FA            mov	ax,-6[bp]
10897                                           ! Debug: list unsigned int = ax+7 (used reg = )
10898 2EBB           05                   0007  add	ax,*7
10899 2EBE           50                         push	ax
10900                                           ! Debug: func () void = outb+0 (used reg = )
10901 2EBF           E8         D64C            call	_outb
10902 2EC2           83C4                   04  add	sp,*4
10903                                           !BCC_EOS
10904                                           ! 2129   await_ide(3, iobase1, 32000u);
10905                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10906 2EC5           B8                   7D00  mov	ax,#$7D00
10907 2EC8           50                         push	ax
10908                                           ! Debug: list unsigned short iobase1 = [S+$22-8] (used reg = )
10909 2EC9           FF76         FA            push	-6[bp]
10910                                           ! Debug: list int = const 3 (used reg = )
10911 2ECC           B8                   0003  mov	ax,*3
10912 2ECF           50                         push	ax
10913                                           ! Debug: func () int = await_ide+0 (used reg = )
10914 2ED0           E8         EB5C            call	_await_ide
10915 2ED3           83C4                   06  add	sp,*6
10916                                           !BCC_EOS
10917                                           ! 2130   status = inb(iobase1 + 7);
10918                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-8] (used reg = )
10919 2ED6           8B46         FA            mov	ax,-6[bp]
10920                                           ! Debug: list unsigned int = ax+7 (used reg = )
10921 2ED9           05                   0007  add	ax,*7
10922 2EDC           50                         push	ax
10923                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10924 2EDD           E8         D618            call	_inb
10925 2EE0           44                         inc	sp
10926 2EE1           44                         inc	sp
10927                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$20-$15] (used reg = )
10928 2EE2           8846         ED            mov	-$13[bp],al
10929                                           !BCC_EOS
10930                                           ! 2131   if (status & 0x01) {
10931                                           ! Debug: and int = const 1 to unsigned char status = [S+$20-$15] (used reg = )
10932 2EE5           8A46         ED            mov	al,-$13[bp]
10933 2EE8           24                     01  and	al,*1
10934 2EEA           84C0                       test	al,al
10935 2EEC           74           09            je  	.2A3
10936                       00002EEE            .2A4:
10937                                           ! 2132     ;
10938                                           !BCC_EOS
10939                                           ! 2133     return 3;
10940 2EEE           B8                   0003  mov	ax,*3
10941 2EF1           89EC                       mov	sp,bp
10942 2EF3           5D                         pop	bp
10943 2EF4           C3                         ret
10944                                           !BCC_EOS
10945                                           ! 2134   } else if ( !(status & 0x08) ) {
10946 2EF5           EB           10            jmp .2A5
10947                       00002EF7            .2A3:
10948                                           ! Debug: and int = const 8 to unsigned char status = [S+$20-$15] (used reg = )
10949 2EF7           8A46         ED            mov	al,-$13[bp]
10950 2EFA           24                     08  and	al,*8
10951 2EFC           84C0                       test	al,al
10952 2EFE           75           07            jne 	.2A6
10953                       00002F00            .2A7:
10954                                           ! 2135     ;
10955                                           !BCC_EOS
10956                                           ! 2136     return 4;
10957 2F00           B8                   0004  mov	ax,*4
10958 2F03           89EC                       mov	sp,bp
10959 2F05           5D                         pop	bp
10960 2F06           C3                         ret
10961                                           !BCC_EOS
10962                                           ! 2137   }
10963                                           ! 2138   cmdseg += (cmdoff / 16);
10964                       00002F07            .2A6:
10965                       00002F07            .2A5:
10966                                           ! Debug: div int = const $10 to unsigned short cmdoff = [S+$20+8] (used reg = )
10967 2F07           8B46         0A            mov	ax,$A[bp]
10968 2F0A           B1                     04  mov	cl,*4
10969 2F0C           D3E8                       shr	ax,cl
10970                                           ! Debug: addab unsigned int = ax+0 to unsigned short cmdseg = [S+$20+6] (used reg = )
10971 2F0E           0346         08            add	ax,8[bp]
10972 2F11           8946         08            mov	8[bp],ax
10973                                           !BCC_EOS
10974                                           ! 2139   cmdoff %= 16;
10975                                           ! Debug: modab int = const $10 to unsigned short cmdoff = [S+$20+8] (used reg = )
10976 2F14           8B46         0A            mov	ax,$A[bp]
10977 2F17           24                     0F  and	al,*$F
10978 2F19           30E4                       xor	ah,ah
10979 2F1B           8946         0A            mov	$A[bp],ax
10980                                           !BCC_EOS
10981                                           ! 2140 #asm
10982                                           !BCC_EOS
10983                                           !BCC_ASM
10984                       00000028            _ata_cmd_packet.cmdoff	set	$28
10985                       0000000A            .ata_cmd_packet.cmdoff	set	$A
10986                       0000002A            _ata_cmd_packet.header	set	$2A
10987                       0000000C            .ata_cmd_packet.header	set	$C
10988                       0000000E            _ata_cmd_packet.count	set	$E
10989                       FFFFFFF0            .ata_cmd_packet.count	set	-$10
10990                       00000010            _ata_cmd_packet.lafter	set	$10
10991                       FFFFFFF2            .ata_cmd_packet.lafter	set	-$E
10992                       00000018            _ata_cmd_packet.iobase1	set	$18
10993                       FFFFFFFA            .ata_cmd_packet.iobase1	set	-6
10994                       0000000D            _ata_cmd_packet.channel	set	$D
10995                       FFFFFFEF            .ata_cmd_packet.channel	set	-$11
10996                       00000026            _ata_cmd_packet.cmdseg	set	$26
10997                       00000008            .ata_cmd_packet.cmdseg	set	8
10998                       00000024            _ata_cmd_packet.cmdlen	set	$24
10999                       00000006            .ata_cmd_packet.cmdlen	set	6
11000                       00000009            _ata_cmd_packet.lmode	set	9
11001                       FFFFFFEB            .ata_cmd_packet.lmode	set	-$15
11002                       00000022            _ata_cmd_packet.device	set	$22
11003                       00000004            .ata_cmd_packet.device	set	4
11004                       0000001C            _ata_cmd_packet.ebda_seg	set	$1C
11005                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
11006                       00000014            _ata_cmd_packet.lcount	set	$14
11007                       FFFFFFF6            .ata_cmd_packet.lcount	set	-$A
11008                       00000004            _ata_cmd_packet.total	set	4
11009                       FFFFFFE6            .ata_cmd_packet.total	set	-$1A
11010                       0000000B            _ata_cmd_packet.status	set	$B
11011                       FFFFFFED            .ata_cmd_packet.status	set	-$13
11012                       0000000A            _ata_cmd_packet.mode	set	$A
11013                       FFFFFFEC            .ata_cmd_packet.mode	set	-$14
11014                       00000034            _ata_cmd_packet.bufoff	set	$34
11015                       00000016            .ata_cmd_packet.bufoff	set	$16
11016                       00000000            _ata_cmd_packet.transfer	set	0
11017                       FFFFFFE2            .ata_cmd_packet.transfer	set	-$1E
11018                       00000016            _ata_cmd_packet.iobase2	set	$16
11019                       FFFFFFF8            .ata_cmd_packet.iobase2	set	-8
11020                       00000012            _ata_cmd_packet.lbefore	set	$12
11021                       FFFFFFF4            .ata_cmd_packet.lbefore	set	-$C
11022                       00000032            _ata_cmd_packet.bufseg	set	$32
11023                       00000014            .ata_cmd_packet.bufseg	set	$14
11024                       0000000C            _ata_cmd_packet.slave	set	$C
11025                       FFFFFFEE            .ata_cmd_packet.slave	set	-$12
11026                       00000030            _ata_cmd_packet.inout	set	$30
11027                       00000012            .ata_cmd_packet.inout	set	$12
11028                       0000001A            _ata_cmd_packet.old_ds	set	$1A
11029                       FFFFFFFC            .ata_cmd_packet.old_ds	set	-4
11030                       0000002C            _ata_cmd_packet.length	set	$2C
11031                       0000000E            .ata_cmd_packet.length	set	$E
11032 2F1E           FB                               sti ;; enable higher priority interrupts
11033 2F1F           55                               push bp
11034 2F20           89E5                             mov bp, sp
11035 2F22           8B76         2A                  mov si, _ata_cmd_packet.cmdoff + 2[bp]
11036 2F25           8B46         28                  mov ax, _ata_cmd_packet.cmdseg + 2[bp]
11037 2F28           8B4E         26                  mov cx, _ata_cmd_packet.cmdlen + 2[bp]
11038 2F2B           8EC0                             mov es, ax ;; segment in es
11039 2F2D           8B56         1A                  mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data write port
11040 2F30           26                               seg ES
11041 2F31           F3                               rep
11042 2F32           6F                                 outsw ;; CX words transferred from port(DX) to ES:[SI]
11043 2F33           5D                               pop bp
11044                                           ! 2153 endasm
11045                                           !BCC_ENDASM
11046                                           !BCC_EOS
11047                                           ! 2154   if (inout == 0x00) {
11048                                           ! Debug: logeq int = const 0 to unsigned char inout = [S+$20+$10] (used reg = )
11049 2F34           8A46         12            mov	al,$12[bp]
11050 2F37           84C0                       test	al,al
11051 2F39           75           23            jne 	.2A8
11052                       00002F3B            .2A9:
11053                                           ! 2155     await_ide(2, iobase1, 32000u);
11054                                           ! Debug: list unsigned int = const $7D00 (used reg = )
11055 2F3B           B8                   7D00  mov	ax,#$7D00
11056 2F3E           50                         push	ax
11057                                           ! Debug: list unsigned short iobase1 = [S+$22-8] (used reg = )
11058 2F3F           FF76         FA            push	-6[bp]
11059                                           ! Debug: list int = const 2 (used reg = )
11060 2F42           B8                   0002  mov	ax,*2
11061 2F45           50                         push	ax
11062                                           ! Debug: func () int = await_ide+0 (used reg = )
11063 2F46           E8         EAE6            call	_await_ide
11064 2F49           83C4                   06  add	sp,*6
11065                                           !BCC_EOS
11066                                           ! 2156     status = inb(iobase1 + 7);
11067                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-8] (used reg = )
11068 2F4C           8B46         FA            mov	ax,-6[bp]
11069                                           ! Debug: list unsigned int = ax+7 (used reg = )
11070 2F4F           05                   0007  add	ax,*7
11071 2F52           50                         push	ax
11072                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11073 2F53           E8         D5A2            call	_inb
11074 2F56           44                         inc	sp
11075 2F57           44                         inc	sp
11076                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$20-$15] (used reg = )
11077 2F58           8846         ED            mov	-$13[bp],al
11078                                           !BCC_EOS
11079                                           ! 2157   }
11080                                           ! 2158   else {
11081 2F5B           E9         026F            br 	.2AA
11082                       00002F5E            .2A8:
11083                                           ! 2159     Bit16u loops = 0;
11084 2F5E           4C                         dec	sp
11085 2F5F           4C                         dec	sp
11086                                           ! Debug: eq int = const 0 to unsigned short loops = [S+$22-$22] (used reg = )
11087 2F60           31C0                       xor	ax,ax
11088 2F62           8946         E0            mov	-$20[bp],ax
11089                                           !BCC_EOS
11090                                           ! 2160     Bit8u sc;
11091                                           !BCC_EOS
11092                                           ! 2161     while (1) {
11093 2F65           4C                         dec	sp
11094 2F66           4C                         dec	sp
11095                       00002F67            .2AD:
11096                                           ! 2162       if (loops == 0) {
11097                                           ! Debug: logeq int = const 0 to unsigned short loops = [S+$24-$22] (used reg = )
11098 2F67           8B46         E0            mov	ax,-$20[bp]
11099 2F6A           85C0                       test	ax,ax
11100 2F6C           75           22            jne 	.2AE
11101                       00002F6E            .2AF:
11102                                           ! 2163         status = inb(iobase2 + 6);
11103                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$24-$A] (used reg = )
11104 2F6E           8B46         F8            mov	ax,-8[bp]
11105                                           ! Debug: list unsigned int = ax+6 (used reg = )
11106 2F71           05                   0006  add	ax,*6
11107 2F74           50                         push	ax
11108                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11109 2F75           E8         D580            call	_inb
11110 2F78           44                         inc	sp
11111 2F79           44                         inc	sp
11112                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$24-$15] (used reg = )
11113 2F7A           8846         ED            mov	-$13[bp],al
11114                                           !BCC_EOS
11115                                           ! 2164         await_ide(3, iobase1, 32000u);
11116                                           ! Debug: list unsigned int = const $7D00 (used reg = )
11117 2F7D           B8                   7D00  mov	ax,#$7D00
11118 2F80           50                         push	ax
11119                                           ! Debug: list unsigned short iobase1 = [S+$26-8] (used reg = )
11120 2F81           FF76         FA            push	-6[bp]
11121                                           ! Debug: list int = const 3 (used reg = )
11122 2F84           B8                   0003  mov	ax,*3
11123 2F87           50                         push	ax
11124                                           ! Debug: func () int = await_ide+0 (used reg = )
11125 2F88           E8         EAA4            call	_await_ide
11126 2F8B           83C4                   06  add	sp,*6
11127                                           !BCC_EOS
11128                                           ! 2165       }
11129                                           ! 2166       else
11130                                           ! 2167         await_ide(2, iobase1, 32000u);
11131 2F8E           EB           11            jmp .2B0
11132                       00002F90            .2AE:
11133                                           ! Debug: list unsigned int = const $7D00 (used reg = )
11134 2F90           B8                   7D00  mov	ax,#$7D00
11135 2F93           50                         push	ax
11136                                           ! Debug: list unsigned short iobase1 = [S+$26-8] (used reg = )
11137 2F94           FF76         FA            push	-6[bp]
11138                                           ! Debug: list int = const 2 (used reg = )
11139 2F97           B8                   0002  mov	ax,*2
11140 2F9A           50                         push	ax
11141                                           ! Debug: func () int = await_ide+0 (used reg = )
11142 2F9B           E8         EA91            call	_await_ide
11143 2F9E           83C4                   06  add	sp,*6
11144                                           !BCC_EOS
11145                                           ! 2168       loops++;
11146                       00002FA1            .2B0:
11147                                           ! Debug: postinc unsigned short loops = [S+$24-$22] (used reg = )
11148 2FA1           8B46         E0            mov	ax,-$20[bp]
11149 2FA4           40                         inc	ax
11150 2FA5           8946         E0            mov	-$20[bp],ax
11151                                           !BCC_EOS
11152                                           ! 2169       status = inb(iobase1 + 7);
11153                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$24-8] (used reg = )
11154 2FA8           8B46         FA            mov	ax,-6[bp]
11155                                           ! Debug: list unsigned int = ax+7 (used reg = )
11156 2FAB           05                   0007  add	ax,*7
11157 2FAE           50                         push	ax
11158                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11159 2FAF           E8         D546            call	_inb
11160 2FB2           44                         inc	sp
11161 2FB3           44                         inc	sp
11162                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$24-$15] (used reg = )
11163 2FB4           8846         ED            mov	-$13[bp],al
11164                                           !BCC_EOS
11165                                           ! 2170       sc = inb(iobase1 + 2);
11166                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$24-8] (used reg = )
11167 2FB7           8B46         FA            mov	ax,-6[bp]
11168                                           ! Debug: list unsigned int = ax+2 (used reg = )
11169 2FBA           40                         inc	ax
11170 2FBB           40                         inc	ax
11171 2FBC           50                         push	ax
11172                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11173 2FBD           E8         D538            call	_inb
11174 2FC0           44                         inc	sp
11175 2FC1           44                         inc	sp
11176                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$24-$23] (used reg = )
11177 2FC2           8846         DF            mov	-$21[bp],al
11178                                           !BCC_EOS
11179                                           ! 2171       if(((inb(iobase1 + 2)&0x7)==0x3) &&
11180                                           ! 2172          ((status & (0x40 | 0x01)) == 0x40)) break;
11181                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$24-8] (used reg = )
11182 2FC5           8B46         FA            mov	ax,-6[bp]
11183                                           ! Debug: list unsigned int = ax+2 (used reg = )
11184 2FC8           40                         inc	ax
11185 2FC9           40                         inc	ax
11186 2FCA           50                         push	ax
11187                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11188 2FCB           E8         D52A            call	_inb
11189 2FCE           44                         inc	sp
11190 2FCF           44                         inc	sp
11191                                           ! Debug: and int = const 7 to unsigned char = al+0 (used reg = )
11192 2FD0           24                     07  and	al,*7
11193                                           ! Debug: logeq int = const 3 to unsigned char = al+0 (used reg = )
11194 2FD2           3C                     03  cmp	al,*3
11195 2FD4           75           0C            jne 	.2B1
11196                       00002FD6            .2B3:
11197                                           ! Debug: and int = const $41 to unsigned char status = [S+$24-$15] (used reg = )
11198 2FD6           8A46         ED            mov	al,-$13[bp]
11199 2FD9           24                     41  and	al,*$41
11200                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
11201 2FDB           3C                     40  cmp	al,*$40
11202 2FDD           75           03            jne 	.2B1
11203                       00002FDF            .2B2:
11204 2FDF           E9         01E8            br 	.2AB
11205                                           !BCC_EOS
11206                                           ! 2173       if (status & 0x01) {
11207                       00002FE2            .2B1:
11208                                           ! Debug: and int = const 1 to unsigned char status = [S+$24-$15] (used reg = )
11209 2FE2           8A46         ED            mov	al,-$13[bp]
11210 2FE5           24                     01  and	al,*1
11211 2FE7           84C0                       test	al,al
11212 2FE9           74           07            je  	.2B4
11213                       00002FEB            .2B5:
11214                                           ! 2174         ;
11215                                           !BCC_EOS
11216                                           ! 2175         return 3;
11217 2FEB           B8                   0003  mov	ax,*3
11218 2FEE           89EC                       mov	sp,bp
11219 2FF0           5D                         pop	bp
11220 2FF1           C3                         ret
11221                                           !BCC_EOS
11222                                           ! 2176       }
11223                                           ! 2177       bufseg += (bufoff / 16);
11224                       00002FF2            .2B4:
11225                                           ! Debug: div int = const $10 to unsigned short bufoff = [S+$24+$14] (used reg = )
11226 2FF2           8B46         16            mov	ax,$16[bp]
11227 2FF5           B1                     04  mov	cl,*4
11228 2FF7           D3E8                       shr	ax,cl
11229                                           ! Debug: addab unsigned int = ax+0 to unsigned short bufseg = [S+$24+$12] (used reg = )
11230 2FF9           0346         14            add	ax,$14[bp]
11231 2FFC           8946         14            mov	$14[bp],ax
11232                                           !BCC_EOS
11233                                           ! 2178       bufoff %= 16;
11234                                           ! Debug: modab int = const $10 to unsigned short bufoff = [S+$24+$14] (used reg = )
11235 2FFF           8B46         16            mov	ax,$16[bp]
11236 3002           24                     0F  and	al,*$F
11237 3004           30E4                       xor	ah,ah
11238 3006           8946         16            mov	$16[bp],ax
11239                                           !BCC_EOS
11240                                           ! 2179       *((Bit8u *)&lcount) = inb(iobase1 + 4);
11241                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$24-8] (used reg = )
11242 3009           8B46         FA            mov	ax,-6[bp]
11243                                           ! Debug: list unsigned int = ax+4 (used reg = )
11244 300C           05                   0004  add	ax,*4
11245 300F           50                         push	ax
11246                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11247 3010           E8         D4E5            call	_inb
11248 3013           44                         inc	sp
11249 3014           44                         inc	sp
11250                                           ! Debug: eq unsigned char = al+0 to unsigned char lcount = [S+$24-$C] (used reg = )
11251 3015           8846         F6            mov	-$A[bp],al
11252                                           !BCC_EOS
11253                                           ! 2180       *(((Bit8u *)&lcount)+1) = inb(iobase1 + 5);
11254                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$24-8] (used reg = )
11255 3018           8B46         FA            mov	ax,-6[bp]
11256                                           ! Debug: list unsigned int = ax+5 (used reg = )
11257 301B           05                   0005  add	ax,*5
11258 301E           50                         push	ax
11259                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11260 301F           E8         D4D6            call	_inb
11261 3022           44                         inc	sp
11262 3023           44                         inc	sp
11263                                           ! Debug: eq unsigned char = al+0 to unsigned char lcount = [S+$24-$B] (used reg = )
11264 3024           8846         F7            mov	-9[bp],al
11265                                           !BCC_EOS
11266                                           ! 2181       if(header>lcount) {
11267                                           ! Debug: gt unsigned short lcount = [S+$24-$C] to unsigned short header = [S+$24+$A] (used reg = )
11268 3027           8B46         0C            mov	ax,$C[bp]
11269 302A           3B46         F6            cmp	ax,-$A[bp]
11270 302D           76           16            jbe 	.2B6
11271                       0000302F            .2B7:
11272                                           ! 2182          lbefore=lcount;
11273                                           ! Debug: eq unsigned short lcount = [S+$24-$C] to unsigned short lbefore = [S+$24-$E] (used reg = )
11274 302F           8B46         F6            mov	ax,-$A[bp]
11275 3032           8946         F4            mov	-$C[bp],ax
11276                                           !BCC_EOS
11277                                           ! 2183          header-=lcount;
11278                                           ! Debug: subab unsigned short lcount = [S+$24-$C] to unsigned short header = [S+$24+$A] (used reg = )
11279 3035           8B46         0C            mov	ax,$C[bp]
11280 3038           2B46         F6            sub	ax,-$A[bp]
11281 303B           8946         0C            mov	$C[bp],ax
11282                                           !BCC_EOS
11283                                           ! 2184          lcount=0;
11284                                           ! Debug: eq int = const 0 to unsigned short lcount = [S+$24-$C] (used reg = )
11285 303E           31C0                       xor	ax,ax
11286 3040           8946         F6            mov	-$A[bp],ax
11287                                           !BCC_EOS
11288                                           ! 2185       }
11289                                           ! 2186       else {
11290 3043           EB           14            jmp .2B8
11291                       00003045            .2B6:
11292                                           ! 2187         lbefore=header;
11293                                           ! Debug: eq unsigned short header = [S+$24+$A] to unsigned short lbefore = [S+$24-$E] (used reg = )
11294 3045           8B46         0C            mov	ax,$C[bp]
11295 3048           8946         F4            mov	-$C[bp],ax
11296                                           !BCC_EOS
11297                                           ! 2188         header=0;
11298                                           ! Debug: eq int = const 0 to unsigned short header = [S+$24+$A] (used reg = )
11299 304B           31C0                       xor	ax,ax
11300 304D           8946         0C            mov	$C[bp],ax
11301                                           !BCC_EOS
11302                                           ! 2189         lcount-=lbefore;
11303                                           ! Debug: subab unsigned short lbefore = [S+$24-$E] to unsigned short lcount = [S+$24-$C] (used reg = )
11304 3050           8B46         F6            mov	ax,-$A[bp]
11305 3053           2B46         F4            sub	ax,-$C[bp]
11306 3056           8946         F6            mov	-$A[bp],ax
11307                                           !BCC_EOS
11308                                           ! 2190       }
11309                                           ! 2191       if(lcount>length) {
11310                       00003059            .2B8:
11311                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$24-$C] (used reg = )
11312 3059           8B46         F6            mov	ax,-$A[bp]
11313 305C           31DB                       xor	bx,bx
11314                                           ! Debug: gt unsigned long length = [S+$24+$C] to unsigned long = bx+0 (used reg = )
11315 305E           8D7E         0E            lea	di,$E[bp]
11316 3061           E8         D038            call	lcmpul
11317 3064           76           20            jbe 	.2B9
11318                       00003066            .2BA:
11319                                           ! 2192         lafter=lcount-length;
11320                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$24-$C] (used reg = )
11321 3066           8B46         F6            mov	ax,-$A[bp]
11322 3069           31DB                       xor	bx,bx
11323                                           ! Debug: sub unsigned long length = [S+$24+$C] to unsigned long = bx+0 (used reg = )
11324 306B           8D7E         0E            lea	di,$E[bp]
11325 306E           E8         D041            call	lsubul
11326                                           ! Debug: eq unsigned long = bx+0 to unsigned short lafter = [S+$24-$10] (used reg = )
11327 3071           8946         F2            mov	-$E[bp],ax
11328                                           !BCC_EOS
11329                                           ! 2193         lcount=length;
11330                                           ! Debug: eq unsigned long length = [S+$24+$C] to unsigned short lcount = [S+$24-$C] (used reg = )
11331 3074           8B46         0E            mov	ax,$E[bp]
11332 3077           8946         F6            mov	-$A[bp],ax
11333                                           !BCC_EOS
11334                                           ! 2194         length=0;
11335                                           ! Debug: eq int = const 0 to unsigned long length = [S+$24+$C] (used reg = )
11336 307A           31C0                       xor	ax,ax
11337 307C           31DB                       xor	bx,bx
11338 307E           8946         0E            mov	$E[bp],ax
11339 3081           895E         10            mov	$10[bp],bx
11340                                           !BCC_EOS
11341                                           ! 2195       }
11342                                           ! 2196       else {
11343 3084           EB           21            jmp .2BB
11344                       00003086            .2B9:
11345                                           ! 2197         lafter=0;
11346                                           ! Debug: eq int = const 0 to unsigned short lafter = [S+$24-$10] (used reg = )
11347 3086           31C0                       xor	ax,ax
11348 3088           8946         F2            mov	-$E[bp],ax
11349                                           !BCC_EOS
11350                                           ! 2198         length-=lcount;
11351                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$24-$C] (used reg = )
11352 308B           8B46         F6            mov	ax,-$A[bp]
11353 308E           31DB                       xor	bx,bx
11354                                           ! Debug: subab unsigned long = bx+0 to unsigned long length = [S+$24+$C] (used reg = )
11355 3090           53                         push	bx
11356 3091           50                         push	ax
11357 3092           8B46         0E            mov	ax,$E[bp]
11358 3095           8B5E         10            mov	bx,$10[bp]
11359 3098           8D7E         DA            lea	di,-$26[bp]
11360 309B           E8         D014            call	lsubul
11361 309E           8946         0E            mov	$E[bp],ax
11362 30A1           895E         10            mov	$10[bp],bx
11363 30A4           83C4                   04  add	sp,*4
11364                                           !BCC_EOS
11365                                           ! 2199       }
11366                                           ! 2200       count = lcount;
11367                       000030A7            .2BB:
11368                                           ! Debug: eq unsigned short lcount = [S+$24-$C] to unsigned short count = [S+$24-$12] (used reg = )
11369 30A7           8B46         F6            mov	ax,-$A[bp]
11370 30AA           8946         F0            mov	-$10[bp],ax
11371                                           !BCC_EOS
11372                                           ! 2201       ;
11373                                           !BCC_EOS
11374                                           ! 2202       ;
11375                                           !BCC_EOS
11376                                           ! 2203       lmode = mode;
11377                                           ! Debug: eq unsigned char mode = [S+$24-$16] to unsigned char lmode = [S+$24-$17] (used reg = )
11378 30AD           8A46         EC            mov	al,-$14[bp]
11379 30B0           8846         EB            mov	-$15[bp],al
11380                                           !BCC_EOS
11381                                           ! 2204       if (lbefore & 0x03) lmode=0x00;
11382                                           ! Debug: and int = const 3 to unsigned short lbefore = [S+$24-$E] (used reg = )
11383 30B3           8A46         F4            mov	al,-$C[bp]
11384 30B6           24                     03  and	al,*3
11385 30B8           84C0                       test	al,al
11386 30BA           74           05            je  	.2BC
11387                       000030BC            .2BD:
11388                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$24-$17] (used reg = )
11389 30BC           30C0                       xor	al,al
11390 30BE           8846         EB            mov	-$15[bp],al
11391                                           !BCC_EOS
11392                                           ! 2205       if (lcount & 0x03) lmode=0x00;
11393                       000030C1            .2BC:
11394                                           ! Debug: and int = const 3 to unsigned short lcount = [S+$24-$C] (used reg = )
11395 30C1           8A46         F6            mov	al,-$A[bp]
11396 30C4           24                     03  and	al,*3
11397 30C6           84C0                       test	al,al
11398 30C8           74           05            je  	.2BE
11399                       000030CA            .2BF:
11400                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$24-$17] (used reg = )
11401 30CA           30C0                       xor	al,al
11402 30CC           8846         EB            mov	-$15[bp],al
11403                                           !BCC_EOS
11404                                           ! 2206       if (lafter & 0x03) lmode=0x00;
11405                       000030CF            .2BE:
11406                                           ! Debug: and int = const 3 to unsigned short lafter = [S+$24-$10] (used reg = )
11407 30CF           8A46         F2            mov	al,-$E[bp]
11408 30D2           24                     03  and	al,*3
11409 30D4           84C0                       test	al,al
11410 30D6           74           05            je  	.2C0
11411                       000030D8            .2C1:
11412                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$24-$17] (used reg = )
11413 30D8           30C0                       xor	al,al
11414 30DA           8846         EB            mov	-$15[bp],al
11415                                           !BCC_EOS
11416                                           ! 2207       if (lcount & 0x01) {
11417                       000030DD            .2C0:
11418                                           ! Debug: and int = const 1 to unsigned short lcount = [S+$24-$C] (used reg = )
11419 30DD           8A46         F6            mov	al,-$A[bp]
11420 30E0           24                     01  and	al,*1
11421 30E2           84C0                       test	al,al
11422 30E4           74           1E            je  	.2C2
11423                       000030E6            .2C3:
11424                                           ! 2208         lcount+=1;
11425                                           ! Debug: addab int = const 1 to unsigned short lcount = [S+$24-$C] (used reg = )
11426 30E6           8B46         F6            mov	ax,-$A[bp]
11427 30E9           40                         inc	ax
11428 30EA           8946         F6            mov	-$A[bp],ax
11429                                           !BCC_EOS
11430                                           ! 2209         if ((lafter > 0) && (lafter & 0x01)) {
11431                                           ! Debug: gt int = const 0 to unsigned short lafter = [S+$24-$10] (used reg = )
11432 30ED           8B46         F2            mov	ax,-$E[bp]
11433 30F0           85C0                       test	ax,ax
11434 30F2           74           10            je  	.2C4
11435                       000030F4            .2C6:
11436                                           ! Debug: and int = const 1 to unsigned short lafter = [S+$24-$10] (used reg = )
11437 30F4           8A46         F2            mov	al,-$E[bp]
11438 30F7           24                     01  and	al,*1
11439 30F9           84C0                       test	al,al
11440 30FB           74           07            je  	.2C4
11441                       000030FD            .2C5:
11442                                           ! 2210           lafter-=1;
11443                                           ! Debug: subab int = const 1 to unsigned short lafter = [S+$24-$10] (used reg = )
11444 30FD           8B46         F2            mov	ax,-$E[bp]
11445 3100           48                         dec	ax
11446 3101           8946         F2            mov	-$E[bp],ax
11447                                           !BCC_EOS
11448                                           ! 2211         }
11449                                           ! 2212       }
11450                       00003104            .2C4:
11451                                           ! 2213       if (lmode == 0x01) {
11452                       00003104            .2C2:
11453                                           ! Debug: logeq int = const 1 to unsigned char lmode = [S+$24-$17] (used reg = )
11454 3104           8A46         EB            mov	al,-$15[bp]
11455 3107           3C                     01  cmp	al,*1
11456 3109           75           20            jne 	.2C7
11457                       0000310B            .2C8:
11458                                           ! 2214         lcount>>=2; lbefore>>=2; lafter>>=2;
11459                                           ! Debug: srab int = const 2 to unsigned short lcount = [S+$24-$C] (used reg = )
11460 310B           8B46         F6            mov	ax,-$A[bp]
11461 310E           D1E8                       shr	ax,*1
11462 3110           D1E8                       shr	ax,*1
11463 3112           8946         F6            mov	-$A[bp],ax
11464                                           !BCC_EOS
11465                                           ! Debug: srab int = const 2 to unsigned short lbefore = [S+$24-$E] (used reg = )
11466 3115           8B46         F4            mov	ax,-$C[bp]
11467 3118           D1E8                       shr	ax,*1
11468 311A           D1E8                       shr	ax,*1
11469 311C           8946         F4            mov	-$C[bp],ax
11470                                           !BCC_EOS
11471                                           ! Debug: srab int = const 2 to unsigned short lafter = [S+$24-$10] (used reg = )
11472 311F           8B46         F2            mov	ax,-$E[bp]
11473 3122           D1E8                       shr	ax,*1
11474 3124           D1E8                       shr	ax,*1
11475 3126           8946         F2            mov	-$E[bp],ax
11476                                           !BCC_EOS
11477                                           ! 2215       }
11478                                           ! 2216       else {
11479 3129           EB           18            jmp .2C9
11480                       0000312B            .2C7:
11481                                           ! 2217         lcount>>=1; lbefore>>=1; lafter>>=1;
11482                                           ! Debug: srab int = const 1 to unsigned short lcount = [S+$24-$C] (used reg = )
11483 312B           8B46         F6            mov	ax,-$A[bp]
11484 312E           D1E8                       shr	ax,*1
11485 3130           8946         F6            mov	-$A[bp],ax
11486                                           !BCC_EOS
11487                                           ! Debug: srab int = const 1 to unsigned short lbefore = [S+$24-$E] (used reg = )
11488 3133           8B46         F4            mov	ax,-$C[bp]
11489 3136           D1E8                       shr	ax,*1
11490 3138           8946         F4            mov	-$C[bp],ax
11491                                           !BCC_EOS
11492                                           ! Debug: srab int = const 1 to unsigned short lafter = [S+$24-$10] (used reg = )
11493 313B           8B46         F2            mov	ax,-$E[bp]
11494 313E           D1E8                       shr	ax,*1
11495 3140           8946         F2            mov	-$E[bp],ax
11496                                           !BCC_EOS
11497                                           ! 2218       }
11498                                           ! 2219        ;
11499                       00003143            .2C9:
11500                                           !BCC_EOS
11501                                           ! 2220 #asm
11502                                           !BCC_EOS
11503                                           !BCC_ASM
11504                       0000002C            _ata_cmd_packet.cmdoff	set	$2C
11505                       0000000A            .ata_cmd_packet.cmdoff	set	$A
11506                       0000002E            _ata_cmd_packet.header	set	$2E
11507                       0000000C            .ata_cmd_packet.header	set	$C
11508                       00000012            _ata_cmd_packet.count	set	$12
11509                       FFFFFFF0            .ata_cmd_packet.count	set	-$10
11510                       00000014            _ata_cmd_packet.lafter	set	$14
11511                       FFFFFFF2            .ata_cmd_packet.lafter	set	-$E
11512                       0000001C            _ata_cmd_packet.iobase1	set	$1C
11513                       FFFFFFFA            .ata_cmd_packet.iobase1	set	-6
11514                       00000011            _ata_cmd_packet.channel	set	$11
11515                       FFFFFFEF            .ata_cmd_packet.channel	set	-$11
11516                       0000002A            _ata_cmd_packet.cmdseg	set	$2A
11517                       00000008            .ata_cmd_packet.cmdseg	set	8
11518                       00000028            _ata_cmd_packet.cmdlen	set	$28
11519                       00000006            .ata_cmd_packet.cmdlen	set	6
11520                       0000000D            _ata_cmd_packet.lmode	set	$D
11521                       FFFFFFEB            .ata_cmd_packet.lmode	set	-$15
11522                       00000026            _ata_cmd_packet.device	set	$26
11523                       00000004            .ata_cmd_packet.device	set	4
11524                       00000002            _ata_cmd_packet.loops	set	2
11525                       FFFFFFE0            .ata_cmd_packet.loops	set	-$20
11526                       00000020            _ata_cmd_packet.ebda_seg	set	$20
11527                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
11528                       00000018            _ata_cmd_packet.lcount	set	$18
11529                       FFFFFFF6            .ata_cmd_packet.lcount	set	-$A
11530                       00000008            _ata_cmd_packet.total	set	8
11531                       FFFFFFE6            .ata_cmd_packet.total	set	-$1A
11532                       0000000F            _ata_cmd_packet.status	set	$F
11533                       FFFFFFED            .ata_cmd_packet.status	set	-$13
11534                       0000000E            _ata_cmd_packet.mode	set	$E
11535                       FFFFFFEC            .ata_cmd_packet.mode	set	-$14
11536                       00000038            _ata_cmd_packet.bufoff	set	$38
11537                       00000016            .ata_cmd_packet.bufoff	set	$16
11538                       00000004            _ata_cmd_packet.transfer	set	4
11539                       FFFFFFE2            .ata_cmd_packet.transfer	set	-$1E
11540                       00000001            _ata_cmd_packet.sc	set	1
11541                       FFFFFFDF            .ata_cmd_packet.sc	set	-$21
11542                       0000001A            _ata_cmd_packet.iobase2	set	$1A
11543                       FFFFFFF8            .ata_cmd_packet.iobase2	set	-8
11544                       00000016            _ata_cmd_packet.lbefore	set	$16
11545                       FFFFFFF4            .ata_cmd_packet.lbefore	set	-$C
11546                       00000036            _ata_cmd_packet.bufseg	set	$36
11547                       00000014            .ata_cmd_packet.bufseg	set	$14
11548                       00000010            _ata_cmd_packet.slave	set	$10
11549                       FFFFFFEE            .ata_cmd_packet.slave	set	-$12
11550                       00000034            _ata_cmd_packet.inout	set	$34
11551                       00000012            .ata_cmd_packet.inout	set	$12
11552                       0000001E            _ata_cmd_packet.old_ds	set	$1E
11553                       FFFFFFFC            .ata_cmd_packet.old_ds	set	-4
11554                       00000030            _ata_cmd_packet.length	set	$30
11555                       0000000E            .ata_cmd_packet.length	set	$E
11556 3143           55                                 push bp
11557 3144           89E5                               mov bp, sp
11558 3146           8B56         1E                    mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data read port
11559 3149           8B4E         18                    mov cx, _ata_cmd_packet.lbefore + 2[bp]
11560 314C           E3           15                    jcxz ata_packet_no_before
11561 314E           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
11562 3151           80FC                   01          cmp ah, #0x01
11563 3154           74           05                    je ata_packet_in_before_32
11564                       00003156            ata_packet_in_before_16:
11565 3156           ED                                 in ax, dx
11566 3157           E2           FD                    loop ata_packet_in_before_16
11567 3159           EB           08                    jmp ata_packet_no_before
11568                       0000315B            ata_packet_in_before_32:
11569 315B     66    50                                 push eax
11570                       0000315D            ata_packet_in_before_32_loop:
11571 315D     66    ED                                 in eax, dx
11572 315F           E2           FC                    loop ata_packet_in_before_32_loop
11573 3161     66    58                                 pop eax
11574                       00003163            ata_packet_no_before:
11575 3163           8B4E         1A                    mov cx, _ata_cmd_packet.lcount + 2[bp]
11576 3166           E3           17                    jcxz ata_packet_after
11577 3168           8B7E         3A                    mov di, _ata_cmd_packet.bufoff + 2[bp]
11578 316B           8B46         38                    mov ax, _ata_cmd_packet.bufseg + 2[bp]
11579 316E           8EC0                               mov es, ax
11580 3170           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
11581 3173           80FC                   01          cmp ah, #0x01
11582 3176           74           04                    je ata_packet_in_32
11583                       00003178            ata_packet_in_16:
11584 3178           F3                                 rep
11585 3179           6D                                   insw ;; CX words transferred to port(DX) to ES:[DI]
11586 317A           EB           03                    jmp ata_packet_after
11587                       0000317C            ata_packet_in_32:
11588 317C           F3                                 rep
11589 317D     66    6D                                   insd ;; CX dwords transferred to port(DX) to ES:[DI]
11590                       0000317F            ata_packet_after:
11591 317F           8B4E         16                    mov cx, _ata_cmd_packet.lafter + 2[bp]
11592 3182           E3           15                    jcxz ata_packet_done
11593 3184           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
11594 3187           80FC                   01          cmp ah, #0x01
11595 318A           74           05                    je ata_packet_in_after_32
11596                       0000318C            ata_packet_in_after_16:
11597 318C           ED                                 in ax, dx
11598 318D           E2           FD                    loop ata_packet_in_after_16
11599 318F           EB           08                    jmp ata_packet_done
11600                       00003191            ata_packet_in_after_32:
11601 3191     66    50                                 push eax
11602                       00003193            ata_packet_in_after_32_loop:
11603 3193     66    ED                                 in eax, dx
11604 3195           E2           FC                    loop ata_packet_in_after_32_loop
11605 3197     66    58                                 pop eax
11606                       00003199            ata_packet_done:
11607 3199           5D                                 pop bp
11608                                           ! 2273 endasm
11609                                           !BCC_ENDASM
11610                                           !BCC_EOS
11611                                           ! 2274       bufoff += count;
11612                                           ! Debug: addab unsigned short count = [S+$24-$12] to unsigned short bufoff = [S+$24+$14] (used reg = )
11613 319A           8B46         16            mov	ax,$16[bp]
11614 319D           0346         F0            add	ax,-$10[bp]
11615 31A0           8946         16            mov	$16[bp],ax
11616                                           !BCC_EOS
11617                                           ! 2275       transfer += count;
11618                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$24-$12] (used reg = )
11619 31A3           8B46         F0            mov	ax,-$10[bp]
11620 31A6           31DB                       xor	bx,bx
11621                                           ! Debug: addab unsigned long = bx+0 to unsigned long transfer = [S+$24-$20] (used reg = )
11622 31A8           8D7E         E2            lea	di,-$1E[bp]
11623 31AB           E8         CEE6            call	laddul
11624 31AE           8946         E2            mov	-$1E[bp],ax
11625 31B1           895E         E4            mov	-$1C[bp],bx
11626                                           !BCC_EOS
11627                                           ! 2276       _write_dword(transfer, &((ebda_data_t *) 0)->ata.trsfbytes, ebda_seg);
11628                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
11629 31B4           FF76         FE            push	-2[bp]
11630                                           ! Debug: list * unsigned long = const $256 (used reg = )
11631 31B7           B8                   0256  mov	ax,#$256
11632 31BA           50                         push	ax
11633                                           ! Debug: list unsigned long transfer = [S+$28-$20] (used reg = )
11634 31BB           FF76         E4            push	-$1C[bp]
11635 31BE           FF76         E2            push	-$1E[bp]
11636                                           ! Debug: func () void = _write_dword+0 (used reg = )
11637 31C1           E8         CEA3            call	__write_dword
11638 31C4           83C4                   08  add	sp,*8
11639                                           !BCC_EOS
11640                                           ! 2277     }
11641                                           ! 2278   }
11642                       000031C7            .2AC:
11643 31C7           E9         FD9D            br 	.2AD
11644                       000031CA            .2CA:
11645                       000031CA            .2AB:
11646 31CA           83C4                   04  add	sp,*4
11647                                           ! 2279   if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
11648                       000031CD            .2AA:
11649                                           ! 2280          != 0x40 ) {
11650                                           ! Debug: and int = const $E9 to unsigned char status = [S+$20-$15] (used reg = )
11651 31CD           8A46         ED            mov	al,-$13[bp]
11652 31D0           24                     E9  and	al,#$E9
11653                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
11654 31D2           3C                     40  cmp	al,*$40
11655 31D4           74           07            je  	.2CB
11656                       000031D6            .2CC:
11657                                           ! 2281     ;
11658                                           !BCC_EOS
11659                                           ! 2282     return 4;
11660 31D6           B8                   0004  mov	ax,*4
11661 31D9           89EC                       mov	sp,bp
11662 31DB           5D                         pop	bp
11663 31DC           C3                         ret
11664                                           !BCC_EOS
11665                                           ! 2283   }
11666                                           ! 2284   outb(iobase2+6, 0x08);
11667                       000031DD            .2CB:
11668                                           ! Debug: list int = const 8 (used reg = )
11669 31DD           B8                   0008  mov	ax,*8
11670 31E0           50                         push	ax
11671                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$22-$A] (used reg = )
11672 31E1           8B46         F8            mov	ax,-8[bp]
11673                                           ! Debug: list unsigned int = ax+6 (used reg = )
11674 31E4           05                   0006  add	ax,*6
11675 31E7           50                         push	ax
11676                                           ! Debug: func () void = outb+0 (used reg = )
11677 31E8           E8         D323            call	_outb
11678 31EB           83C4                   04  add	sp,*4
11679                                           !BCC_EOS
11680                                           ! 2285   return 0;
11681 31EE           31C0                       xor	ax,ax
11682 31F0           89EC                       mov	sp,bp
11683 31F2           5D                         pop	bp
11684 31F3           C3                         ret
11685                                           !BCC_EOS
11686                                           ! 2286 }
11687                                           ! 2287   Bit16u
11688                                           ! Register BX used in function ata_cmd_packet
11689                                           ! 2288 atapi_get_sense(device, seg, asc, ascq)
11690                                           ! 2289   Bit16u device;
11691                                           export	_atapi_get_sense
11692                       000031F4            _atapi_get_sense:
11693                                           !BCC_EOS
11694                                           ! 2290 {
11695                                           ! 2291   Bit8u atacmd[12];
11696                                           !BCC_EOS
11697                                           ! 2292   Bit8u buffer[18];
11698                                           !BCC_EOS
11699                                           ! 2293   Bit8u i;
11700                                           !BCC_EOS
11701                                           ! 2294   _memsetb(0,atacmd,get_SS(),12);
11702 31F4           55                         push	bp
11703 31F5           89E5                       mov	bp,sp
11704 31F7           83C4                   E0  add	sp,*-$20
11705                                           ! Debug: list int = const $C (used reg = )
11706 31FA           B8                   000C  mov	ax,*$C
11707 31FD           50                         push	ax
11708                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11709 31FE           E8         D45E            call	_get_SS
11710                                           ! Debug: list unsigned short = ax+0 (used reg = )
11711 3201           50                         push	ax
11712                                           ! Debug: list * unsigned char atacmd = S+$26-$E (used reg = )
11713 3202           8D5E         F4            lea	bx,-$C[bp]
11714 3205           53                         push	bx
11715                                           ! Debug: list int = const 0 (used reg = )
11716 3206           31C0                       xor	ax,ax
11717 3208           50                         push	ax
11718                                           ! Debug: func () void = _memsetb+0 (used reg = )
11719 3209           E8         CDF4            call	__memsetb
11720 320C           83C4                   08  add	sp,*8
11721                                           !BCC_EOS
11722                                           ! 2295   atacmd[0]=0x03;
11723                                           ! Debug: eq int = const 3 to unsigned char atacmd = [S+$22-$E] (used reg = )
11724 320F           B0                     03  mov	al,*3
11725 3211           8846         F4            mov	-$C[bp],al
11726                                           !BCC_EOS
11727                                           ! 2296   atacmd[4]=sizeof(buffer);
11728                                           ! Debug: eq int = const $12 to unsigned char atacmd = [S+$22-$A] (used reg = )
11729 3214           B0                     12  mov	al,*$12
11730 3216           8846         F8            mov	-8[bp],al
11731                                           !BCC_EOS
11732                                           ! 2297   if (ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 18L, 0x01, get_SS(), buffer) != 0)
11733                                           ! Debug: list * unsigned char buffer = S+$22-$20 (used reg = )
11734 3219           8D5E         E2            lea	bx,-$1E[bp]
11735 321C           53                         push	bx
11736                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11737 321D           E8         D43F            call	_get_SS
11738                                           ! Debug: list unsigned short = ax+0 (used reg = )
11739 3220           50                         push	ax
11740                                           ! Debug: list int = const 1 (used reg = )
11741 3221           B8                   0001  mov	ax,*1
11742 3224           50                         push	ax
11743                                           ! Debug: list long = const $12 (used reg = )
11744 3225           B8                   0012  mov	ax,*$12
11745 3228           31DB                       xor	bx,bx
11746 322A           53                         push	bx
11747 322B           50                         push	ax
11748                                           ! Debug: list int = const 0 (used reg = )
11749 322C           31C0                       xor	ax,ax
11750 322E           50                         push	ax
11751                                           ! Debug: list * unsigned char atacmd = S+$2E-$E (used reg = )
11752 322F           8D5E         F4            lea	bx,-$C[bp]
11753 3232           53                         push	bx
11754                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11755 3233           E8         D429            call	_get_SS
11756                                           ! Debug: list unsigned short = ax+0 (used reg = )
11757 3236           50                         push	ax
11758                                           ! Debug: list int = const $C (used reg = )
11759 3237           B8                   000C  mov	ax,*$C
11760 323A           50                         push	ax
11761                                           ! Debug: list unsigned short device = [S+$34+2] (used reg = )
11762 323B           FF76         04            push	4[bp]
11763                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
11764 323E           E8         FB09            call	_ata_cmd_packet
11765 3241           83C4                   14  add	sp,*$14
11766                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
11767 3244           85C0                       test	ax,ax
11768 3246           74           07            je  	.2CD
11769                       00003248            .2CE:
11770                                           ! 2298     return 0x0002;
11771 3248           B8                   0002  mov	ax,*2
11772 324B           89EC                       mov	sp,bp
11773 324D           5D                         pop	bp
11774 324E           C3                         ret
11775                                           !BCC_EOS
11776                                           ! 2299   _write_byte(buffer[12], asc, seg);
11777                       0000324F            .2CD:
11778                                           ! Debug: list int seg = [S+$22+4] (used reg = )
11779 324F           FF76         06            push	6[bp]
11780                                           ! Debug: list int asc = [S+$24+6] (used reg = )
11781 3252           FF76         08            push	8[bp]
11782                                           ! Debug: list unsigned char buffer = [S+$26-$14] (used reg = )
11783 3255           8A46         EE            mov	al,-$12[bp]
11784 3258           30E4                       xor	ah,ah
11785 325A           50                         push	ax
11786                                           ! Debug: func () void = _write_byte+0 (used reg = )
11787 325B           E8         D3A2            call	__write_byte
11788 325E           83C4                   06  add	sp,*6
11789                                           !BCC_EOS
11790                                           ! 2300   _write_byte(buffer[13], ascq, seg);
11791                                           ! Debug: list int seg = [S+$22+4] (used reg = )
11792 3261           FF76         06            push	6[bp]
11793                                           ! Debug: list int ascq = [S+$24+8] (used reg = )
11794 3264           FF76         0A            push	$A[bp]
11795                                           ! Debug: list unsigned char buffer = [S+$26-$13] (used reg = )
11796 3267           8A46         EF            mov	al,-$11[bp]
11797 326A           30E4                       xor	ah,ah
11798 326C           50                         push	ax
11799                                           ! Debug: func () void = _write_byte+0 (used reg = )
11800 326D           E8         D390            call	__write_byte
11801 3270           83C4                   06  add	sp,*6
11802                                           !BCC_EOS
11803                                           ! 2301   return 0;
11804 3273           31C0                       xor	ax,ax
11805 3275           89EC                       mov	sp,bp
11806 3277           5D                         pop	bp
11807 3278           C3                         ret
11808                                           !BCC_EOS
11809                                           ! 2302 }
11810                                           ! 2303   Bit16u
11811                                           ! Register BX used in function atapi_get_sense
11812                                           ! 2304 atapi_is_ready(device)
11813                                           ! 2305   Bit16u device;
11814                                           export	_atapi_is_ready
11815                       00003279            _atapi_is_ready:
11816                                           !BCC_EOS
11817                                           ! 2306 {
11818                                           ! 2307   Bit8u packet[12];
11819                                           !BCC_EOS
11820                                           ! 2308   Bit8u buf[8];
11821                                           !BCC_EOS
11822                                           ! 2309   Bit32u block_len;
11823                                           !BCC_EOS
11824                                           ! 2310   Bit32u sectors;
11825                                           !BCC_EOS
11826                                           ! 2311   Bit32u timeout;
11827                                           !BCC_EOS
11828                                           ! 2312   Bit32u time;
11829                                           !BCC_EOS
11830                                           ! 2313   Bit8u asc, ascq;
11831                                           !BCC_EOS
11832                                           ! 2314   Bit8u in_progress;
11833                                           !BCC_EOS
11834                                           ! 2315   Bit16u ebda_seg = get_ebda_seg();
11835 3279           55                         push	bp
11836 327A           89E5                       mov	bp,sp
11837 327C           83C4                   D6  add	sp,*-$2A
11838                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
11839 327F           E8         D3EA            call	_get_ebda_seg
11840                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
11841 3282           8946         D6            mov	-$2A[bp],ax
11842                                           !BCC_EOS
11843                                           ! 2316   if (_rea
11844                                           ! 2316 d_byte(&((ebda_data_t *) 0)->ata.devices[device].type, ebda_seg) != 0x03) {
11845                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
11846 3285           FF76         D6            push	-$2A[bp]
11847                                           ! Debug: ptradd unsigned short device = [S+$2E+2] to [8] struct  = const $142 (used reg = )
11848 3288           8B46         04            mov	ax,4[bp]
11849 328B           B9                   001E  mov	cx,*$1E
11850 328E           F7E9                       imul	cx
11851 3290           89C3                       mov	bx,ax
11852                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
11853                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
11854 3292           81C3                 0142  add	bx,#$142
11855 3296           53                         push	bx
11856                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
11857 3297           E8         D34A            call	__read_byte
11858 329A           83C4                   04  add	sp,*4
11859                                           ! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
11860 329D           3C                     03  cmp	al,*3
11861 329F           74           15            je  	.2CF
11862                       000032A1            .2D0:
11863                                           ! 2317     bios_printf(2, "not implemented for non-ATAPI device\n");
11864                                           ! Debug: list * char = .2D1+0 (used reg = )
11865 32A1           BB                   D62A  mov	bx,#.2D1
11866 32A4           53                         push	bx
11867                                           ! Debug: list int = const 2 (used reg = )
11868 32A5           B8                   0002  mov	ax,*2
11869 32A8           50                         push	ax
11870                                           ! Debug: func () void = bios_printf+0 (used reg = )
11871 32A9           E8         D692            call	_bios_printf
11872 32AC           83C4                   04  add	sp,*4
11873                                           !BCC_EOS
11874                                           ! 2318     return -1;
11875 32AF           B8                   FFFF  mov	ax,#$FFFF
11876 32B2           89EC                       mov	sp,bp
11877 32B4           5D                         pop	bp
11878 32B5           C3                         ret
11879                                           !BCC_EOS
11880                                           ! 2319   }
11881                                           ! 2320   ;
11882                       000032B6            .2CF:
11883                                           !BCC_EOS
11884                                           ! 2321   _memsetb(0,packet,get_SS(),sizeof packet);
11885                                           ! Debug: list int = const $C (used reg = )
11886 32B6           B8                   000C  mov	ax,*$C
11887 32B9           50                         push	ax
11888                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11889 32BA           E8         D3A2            call	_get_SS
11890                                           ! Debug: list unsigned short = ax+0 (used reg = )
11891 32BD           50                         push	ax
11892                                           ! Debug: list * unsigned char packet = S+$30-$E (used reg = )
11893 32BE           8D5E         F4            lea	bx,-$C[bp]
11894 32C1           53                         push	bx
11895                                           ! Debug: list int = const 0 (used reg = )
11896 32C2           31C0                       xor	ax,ax
11897 32C4           50                         push	ax
11898                                           ! Debug: func () void = _memsetb+0 (used reg = )
11899 32C5           E8         CD38            call	__memsetb
11900 32C8           83C4                   08  add	sp,*8
11901                                           !BCC_EOS
11902                                           ! 2322   packet[0] = 0x25;
11903                                           ! Debug: eq int = const $25 to unsigned char packet = [S+$2C-$E] (used reg = )
11904 32CB           B0                     25  mov	al,*$25
11905 32CD           8846         F4            mov	-$C[bp],al
11906                                           !BCC_EOS
11907                                           ! 2323   timeout = 5000;
11908                                           ! Debug: eq int = const $1388 to unsigned long timeout = [S+$2C-$22] (used reg = )
11909 32D0           B8                   1388  mov	ax,#$1388
11910 32D3           31DB                       xor	bx,bx
11911 32D5           8946         E0            mov	-$20[bp],ax
11912 32D8           895E         E2            mov	-$1E[bp],bx
11913                                           !BCC_EOS
11914                                           ! 2324   time = 0;
11915                                           ! Debug: eq int = const 0 to unsigned long time = [S+$2C-$26] (used reg = )
11916 32DB           31C0                       xor	ax,ax
11917 32DD           31DB                       xor	bx,bx
11918 32DF           8946         DC            mov	-$24[bp],ax
11919 32E2           895E         DE            mov	-$22[bp],bx
11920                                           !BCC_EOS
11921                                           ! 2325   in_progress = 0;
11922                                           ! Debug: eq int = const 0 to unsigned char in_progress = [S+$2C-$29] (used reg = )
11923 32E5           30C0                       xor	al,al
11924 32E7           8846         D9            mov	-$27[bp],al
11925                                           !BCC_EOS
11926                                           ! 2326   while (time < timeout) {
11927 32EA           E9         00AB            br 	.2D3
11928                       000032ED            .2D4:
11929                                           ! 2327     if (ata_cmd_packet(device, sizeof(packet), get_SS(), packet, 0, 8L, 0x01, get_SS(), buf) == 0)
11930                                           ! Debug: list * unsigned char buf = S+$2C-$16 (used reg = )
11931 32ED           8D5E         EC            lea	bx,-$14[bp]
11932 32F0           53                         push	bx
11933                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11934 32F1           E8         D36B            call	_get_SS
11935                                           ! Debug: list unsigned short = ax+0 (used reg = )
11936 32F4           50                         push	ax
11937                                           ! Debug: list int = const 1 (used reg = )
11938 32F5           B8                   0001  mov	ax,*1
11939 32F8           50                         push	ax
11940                                           ! Debug: list long = const 8 (used reg = )
11941 32F9           B8                   0008  mov	ax,*8
11942 32FC           31DB                       xor	bx,bx
11943 32FE           53                         push	bx
11944 32FF           50                         push	ax
11945                                           ! Debug: list int = const 0 (used reg = )
11946 3300           31C0                       xor	ax,ax
11947 3302           50                         push	ax
11948                                           ! Debug: list * unsigned char packet = S+$38-$E (used reg = )
11949 3303           8D5E         F4            lea	bx,-$C[bp]
11950 3306           53                         push	bx
11951                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11952 3307           E8         D355            call	_get_SS
11953                                           ! Debug: list unsigned short = ax+0 (used reg = )
11954 330A           50                         push	ax
11955                                           ! Debug: list int = const $C (used reg = )
11956 330B           B8                   000C  mov	ax,*$C
11957 330E           50                         push	ax
11958                                           ! Debug: list unsigned short device = [S+$3E+2] (used reg = )
11959 330F           FF76         04            push	4[bp]
11960                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
11961 3312           E8         FA35            call	_ata_cmd_packet
11962 3315           83C4                   14  add	sp,*$14
11963                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
11964 3318           85C0                       test	ax,ax
11965 331A           75           06            jne 	.2D5
11966                       0000331C            .2D6:
11967                                           ! 2328       goto ok;
11968 331C           83C4                   00  add	sp,#..FFFA+$2C
11969 331F           E9         008D            br 	.FFFA
11970                                           !BCC_EOS
11971                                           ! 2329     if (atapi_get_sense(device, get_SS(), &asc, &ascq) == 0) {
11972                       00003322            .2D5:
11973                                           ! Debug: list * unsigned char ascq = S+$2C-$28 (used reg = )
11974 3322           8D5E         DA            lea	bx,-$26[bp]
11975 3325           53                         push	bx
11976                                           ! Debug: list * unsigned char asc = S+$2E-$27 (used reg = )
11977 3326           8D5E         DB            lea	bx,-$25[bp]
11978 3329           53                         push	bx
11979                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
11980 332A           E8         D332            call	_get_SS
11981                                           ! Debug: list unsigned short = ax+0 (used reg = )
11982 332D           50                         push	ax
11983                                           ! Debug: list unsigned short device = [S+$32+2] (used reg = )
11984 332E           FF76         04            push	4[bp]
11985                                           ! Debug: func () unsigned short = atapi_get_sense+0 (used reg = )
11986 3331           E8         FEC0            call	_atapi_get_sense
11987 3334           83C4                   08  add	sp,*8
11988                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
11989 3337           85C0                       test	ax,ax
11990 3339           75           41            jne 	.2D7
11991                       0000333B            .2D8:
11992                                           ! 2330       if (asc == 0x3a) {
11993                                           ! Debug: logeq int = const $3A to unsigned char asc = [S+$2C-$27] (used reg = )
11994 333B           8A46         DB            mov	al,-$25[bp]
11995 333E           3C                     3A  cmp	al,*$3A
11996 3340           75           07            jne 	.2D9
11997                       00003342            .2DA:
11998                                           ! 2331         ;
11999                                           !BCC_EOS
12000                                           ! 2332         return -1;
12001 3342           B8                   FFFF  mov	ax,#$FFFF
12002 3345           89EC                       mov	sp,bp
12003 3347           5D                         pop	bp
12004 3348           C3                         ret
12005                                           !BCC_EOS
12006                                           ! 2333       }
12007                                           ! 2334       if (asc == 0x04 && ascq == 0x01 && !in_progress) {
12008                       00003349            .2D9:
12009                                           ! Debug: logeq int = const 4 to unsigned char asc = [S+$2C-$27] (used reg = )
12010 3349           8A46         DB            mov	al,-$25[bp]
12011 334C           3C                     04  cmp	al,*4
12012 334E           75           2C            jne 	.2DB
12013                       00003350            .2DE:
12014                                           ! Debug: logeq int = const 1 to unsigned char ascq = [S+$2C-$28] (used reg = )
12015 3350           8A46         DA            mov	al,-$26[bp]
12016 3353           3C                     01  cmp	al,*1
12017 3355           75           25            jne 	.2DB
12018                       00003357            .2DD:
12019 3357           8A46         D9            mov	al,-$27[bp]
12020 335A           84C0                       test	al,al
12021 335C           75           1E            jne 	.2DB
12022                       0000335E            .2DC:
12023                                           ! 2335         bios_printf(2, "Waiting for device to detect medium... ");
12024                                           ! Debug: list * char = .2DF+0 (used reg = )
12025 335E           BB                   D602  mov	bx,#.2DF
12026 3361           53                         push	bx
12027                                           ! Debug: list int = const 2 (used reg = )
12028 3362           B8                   0002  mov	ax,*2
12029 3365           50                         push	ax
12030                                           ! Debug: func () void = bios_printf+0 (used reg = )
12031 3366           E8         D5D5            call	_bios_printf
12032 3369           83C4                   04  add	sp,*4
12033                                           !BCC_EOS
12034                                           ! 2336         timeout = 30000;
12035                                           ! Debug: eq int = const $7530 to unsigned long timeout = [S+$2C-$22] (used reg = )
12036 336C           B8                   7530  mov	ax,#$7530
12037 336F           31DB                       xor	bx,bx
12038 3371           8946         E0            mov	-$20[bp],ax
12039 3374           895E         E2            mov	-$1E[bp],bx
12040                                           !BCC_EOS
12041                                           ! 2337         in_progress = 1;
12042                                           ! Debug: eq int = const 1 to unsigned char in_progress = [S+$2C-$29] (used reg = )
12043 3377           B0                     01  mov	al,*1
12044 3379           8846         D9            mov	-$27[bp],al
12045                                           !BCC_EOS
12046                                           ! 2338       }
12047                                           ! 2339     }
12048                       0000337C            .2DB:
12049                                           ! 2340     time += 100;
12050                       0000337C            .2D7:
12051                                           ! Debug: addab unsigned long = const $64 to unsigned long time = [S+$2C-$26] (used reg = )
12052 337C           B8                   0064  mov	ax,*$64
12053 337F           31DB                       xor	bx,bx
12054 3381           53                         push	bx
12055 3382           50                         push	ax
12056 3383           8B46         DC            mov	ax,-$24[bp]
12057 3386           8B5E         DE            mov	bx,-$22[bp]
12058 3389           8D7E         D2            lea	di,-$2E[bp]
12059 338C           E8         CD05            call	laddul
12060 338F           8946         DC            mov	-$24[bp],ax
12061 3392           895E         DE            mov	-$22[bp],bx
12062 3395           83C4                   04  add	sp,*4
12063                                           !BCC_EOS
12064                                           ! 2341   }
12065                                           ! 2342   ;
12066                       00003398            .2D3:
12067                                           ! Debug: lt unsigned long timeout = [S+$2C-$22] to unsigned long time = [S+$2C-$26] (used reg = )
12068 3398           8B46         E0            mov	ax,-$20[bp]
12069 339B           8B5E         E2            mov	bx,-$1E[bp]
12070 339E           8D7E         DC            lea	di,-$24[bp]
12071 33A1           E8         CCF8            call	lcmpul
12072 33A4         0F87         FF45            bhi 	.2D4
12073                       000033A8            .2E0:
12074                       000033A8            .2D2:
12075                                           !BCC_EOS
12076                                           ! 2343   return -1;
12077 33A8           B8                   FFFF  mov	ax,#$FFFF
12078 33AB           89EC                       mov	sp,bp
12079 33AD           5D                         pop	bp
12080 33AE           C3                         ret
12081                                           !BCC_EOS
12082                                           ! 2344 ok:
12083                       000033AF            .FFFA:
12084                       FFFFFFD4            ..FFFA	=	-$2C
12085                                           ! 2345   *(((Bit8u *)&*(((Bit16u *)&block_len)+1))+1) = buf[4];
12086                                           ! Debug: eq unsigned char buf = [S+$2C-$12] to unsigned char block_len = [S+$2C-$17] (used reg = )
12087 33AF           8A46         F0            mov	al,-$10[bp]
12088 33B2           8846         EB            mov	-$15[bp],al
12089                                           !BCC_EOS
12090                                           ! 2346   *((Bit8u *)&*(((Bit16u *)&block_len)+1)) = buf[5];
12091                                           ! Debug: eq unsigned char buf = [S+$2C-$11] to unsigned char block_len = [S+$2C-$18] (used reg = )
12092 33B5           8A46         F1            mov	al,-$F[bp]
12093 33B8           8846         EA            mov	-$16[bp],al
12094                                           !BCC_EOS
12095                                           ! 2347   *(((Bit8u *)&*((Bit16u *)&block_len))+1) = buf[6];
12096                                           ! Debug: eq unsigned char buf = [S+$2C-$10] to unsigned char block_len = [S+$2C-$19] (used reg = )
12097 33BB           8A46         F2            mov	al,-$E[bp]
12098 33BE           8846         E9            mov	-$17[bp],al
12099                                           !BCC_EOS
12100                                           ! 2348   *((Bit8u *)&block_len) = buf[7];
12101                                           ! Debug: eq unsigned char buf = [S+$2C-$F] to unsigned char block_len = [S+$2C-$1A] (used reg = )
12102 33C1           8A46         F3            mov	al,-$D[bp]
12103 33C4           8846         E8            mov	-$18[bp],al
12104                                           !BCC_EOS
12105                                           ! 2349   ;
12106                                           !BCC_EOS
12107                                           ! 2350   if (block_len!= 2048 && block_len!= 512)
12108                                           ! Debug: ne unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
12109                                           ! Debug: expression subtree swapping
12110 33C7           B8                   0800  mov	ax,#$800
12111 33CA           31DB                       xor	bx,bx
12112 33CC           53                         push	bx
12113 33CD           50                         push	ax
12114 33CE           8B46         E8            mov	ax,-$18[bp]
12115 33D1           8B5E         EA            mov	bx,-$16[bp]
12116 33D4           8D7E         D2            lea	di,-$2E[bp]
12117 33D7           E8         CCC2            call	lcmpul
12118 33DA           8D66         D6            lea	sp,-$2A[bp]
12119 33DD           74           33            je  	.2E1
12120                       000033DF            .2E3:
12121                                           ! Debug: ne unsigned long = const $200 to unsigned long block_len = [S+$2C-$1A] (used reg = )
12122                                           ! Debug: expression subtree swapping
12123 33DF           B8                   0200  mov	ax,#$200
12124 33E2           31DB                       xor	bx,bx
12125 33E4           53                         push	bx
12126 33E5           50                         push	ax
12127 33E6           8B46         E8            mov	ax,-$18[bp]
12128 33E9           8B5E         EA            mov	bx,-$16[bp]
12129 33EC           8D7E         D2            lea	di,-$2E[bp]
12130 33EF           E8         CCAA            call	lcmpul
12131 33F2           8D66         D6            lea	sp,-$2A[bp]
12132 33F5           74           1B            je  	.2E1
12133                       000033F7            .2E2:
12134                                           ! 2351   {
12135                                           ! 2352     bios_printf(2, "Unsupported sector size %u\n", block_len);
12136                                           ! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
12137 33F7           FF76         EA            push	-$16[bp]
12138 33FA           FF76         E8            push	-$18[bp]
12139                                           ! Debug: list * char = .2E4+0 (used reg = )
12140 33FD           BB                   D5E6  mov	bx,#.2E4
12141 3400           53                         push	bx
12142                                           ! Debug: list int = const 2 (used reg = )
12143 3401           B8                   0002  mov	ax,*2
12144 3404           50                         push	ax
12145                                           ! Debug: func () void = bios_printf+0 (used reg = )
12146 3405           E8         D536            call	_bios_printf
12147 3408           83C4                   08  add	sp,*8
12148                                           !BCC_EOS
12149                                           ! 2353     return -1;
12150 340B           B8                   FFFF  mov	ax,#$FFFF
12151 340E           89EC                       mov	sp,bp
12152 3410           5D                         pop	bp
12153 3411           C3                         ret
12154                                           !BCC_EOS
12155                                           ! 2354   }
12156                                           ! 2355   _write_dword(block_len, &((ebda_data_t *) 0)->ata.devices[device].blksize, ebda_seg);
12157                       00003412            .2E1:
12158                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
12159 3412           FF76         D6            push	-$2A[bp]
12160                                           ! Debug: ptradd unsigned short device = [S+$2E+2] to [8] struct  = const $142 (used reg = )
12161 3415           8B46         04            mov	ax,4[bp]
12162 3418           B9                   001E  mov	cx,*$1E
12163 341B           F7E9                       imul	cx
12164 341D           89C3                       mov	bx,ax
12165                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
12166                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
12167 341F           81C3                 0148  add	bx,#$148
12168 3423           53                         push	bx
12169                                           ! Debug: list unsigned long block_len = [S+$30-$1A] (used reg = )
12170 3424           FF76         EA            push	-$16[bp]
12171 3427           FF76         E8            push	-$18[bp]
12172                                           ! Debug: func () void = _write_dword+0 (used reg = )
12173 342A           E8         CC3A            call	__write_dword
12174 342D           83C4                   08  add	sp,*8
12175                                           !BCC_EOS
12176                                           ! 2356   *(((Bit8u *)&*(((Bit16u *)&sectors)+1))+1) = buf[0];
12177                                           ! Debug: eq unsigned char buf = [S+$2C-$16] to unsigned char sectors = [S+$2C-$1B] (used reg = )
12178 3430           8A46         EC            mov	al,-$14[bp]
12179 3433           8846         E7            mov	-$19[bp],al
12180                                           !BCC_EOS
12181                                           ! 2357   *((Bit8u *)&*(((Bit16u *)&sectors)+1)) = buf[1];
12182                                           ! Debug: eq unsigned char buf = [S+$2C-$15] to unsigned char sectors = [S+$2C-$1C] (used reg = )
12183 3436           8A46         ED            mov	al,-$13[bp]
12184 3439           8846         E6            mov	-$1A[bp],al
12185                                           !BCC_EOS
12186                                           ! 2358   *(((Bit8u *)&*((Bit16u *)&sectors))+1) = buf[2];
12187                                           ! Debug: eq unsigned char buf = [S+$2C-$14] to unsigned char sectors = [S+$2C-$1D] (used reg = )
12188 343C           8A46         EE            mov	al,-$12[bp]
12189 343F           8846         E5            mov	-$1B[bp],al
12190                                           !BCC_EOS
12191                                           ! 2359   *((Bit8u *)&sectors) = buf[3];
12192                                           ! Debug: eq unsigned char buf = [S+$2C-$13] to unsigned char sectors = [S+$2C-$1E] (used reg = )
12193 3442           8A46         EF            mov	al,-$11[bp]
12194 3445           8846         E4            mov	-$1C[bp],al
12195                                           !BCC_EOS
12196                                           ! 2360   ;
12197                                           !BCC_EOS
12198                                           ! 2361   if (block_len == 2048)
12199                                           ! Debug: logeq unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
12200                                           ! Debug: expression subtree swapping
12201 3448           B8                   0800  mov	ax,#$800
12202 344B           31DB                       xor	bx,bx
12203 344D           53                         push	bx
12204 344E           50                         push	ax
12205 344F           8B46         E8            mov	ax,-$18[bp]
12206 3452           8B5E         EA            mov	bx,-$16[bp]
12207 3455           8D7E         D2            lea	di,-$2E[bp]
12208 3458           E8         CC41            call	lcmpul
12209 345B           8D66         D6            lea	sp,-$2A[bp]
12210 345E           75           12            jne 	.2E5
12211                       00003460            .2E6:
12212                                           ! 2362     sectors <<= 2;
12213                                           ! Debug: slab int = const 2 to unsigned long sectors = [S+$2C-$1E] (used reg = )
12214 3460           8B46         E4            mov	ax,-$1C[bp]
12215 3463           8B5E         E6            mov	bx,-$1A[bp]
12216 3466           BF                   0002  mov	di,*2
12217 3469           E8         CCAC            call	lslul
12218 346C           8946         E4            mov	-$1C[bp],ax
12219 346F           895E         E6            mov	-$1A[bp],bx
12220                                           !BCC_EOS
12221                                           ! 2363   if (sectors != _read_dword(&((ebda_data_t *) 0)->ata.devices[device].sectors_low, ebda_seg))
12222                       00003472            .2E5:
12223                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
12224 3472           FF76         D6            push	-$2A[bp]
12225                                           ! Debug: ptradd unsigned short device = [S+$2E+2] to [8] struct  = const $142 (used reg = )
12226 3475           8B46         04            mov	ax,4[bp]
12227 3478           B9                   001E  mov	cx,*$1E
12228 347B           F7E9                       imul	cx
12229 347D           89C3                       mov	bx,ax
12230                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
12231                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
12232 347F           81C3                 0158  add	bx,#$158
12233 3483           53                         push	bx
12234                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
12235 3484           E8         CBCF            call	__read_dword
12236 3487           89D3                       mov	bx,dx
12237 3489           83C4                   04  add	sp,*4
12238                                           ! Debug: ne unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
12239                                           ! Debug: expression subtree swapping
12240 348C           8D7E         E4            lea	di,-$1C[bp]
12241 348F           E8         CC0A            call	lcmpul
12242 3492           74           24            je  	.2E7
12243                       00003494            .2E8:
12244                                           ! 2364     bios_printf(2, "%dMB medium detected\n", sectors>>(20-9));
12245                                           ! Debug: sr int = const $B to unsigned long sectors = [S+$2C-$1E] (used reg = )
12246 3494           8B46         E4            mov	ax,-$1C[bp]
12247 3497           8B5E         E6            mov	bx,-$1A[bp]
12248 349A           88E0                       mov	al,ah
12249 349C           88DC                       mov	ah,bl
12250 349E           88FB                       mov	bl,bh
12251 34A0           28FF                       sub	bh,bh
12252 34A2           BF                   0003  mov	di,*3
12253 34A5           E8         CC52            call	lsrul
12254                                           ! Debug: list unsigned long = bx+0 (used reg = )
12255 34A8           53                         push	bx
12256 34A9           50                         push	ax
12257                                           ! Debug: list * char = .2E9+0 (used reg = )
12258 34AA           BB                   D5D0  mov	bx,#.2E9
12259 34AD           53                         push	bx
12260                                           ! Debug: list int = const 2 (used reg = )
12261 34AE           B8                   0002  mov	ax,*2
12262 34B1           50                         push	ax
12263                                           ! Debug: func () void = bios_printf+0 (used reg = )
12264 34B2           E8         D489            call	_bios_printf
12265 34B5           83C4                   08  add	sp,*8
12266                                           !BCC_EOS
12267                                           ! 2365   _write_dword(sectors, &((ebda_data_t *) 0)->ata.devices[device].sectors_low, ebda_seg);
12268                       000034B8            .2E7:
12269                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
12270 34B8           FF76         D6            push	-$2A[bp]
12271                                           ! Debug: ptradd unsigned short device = [S+$2E+2] to [8] struct  = const $142 (used reg = )
12272 34BB           8B46         04            mov	ax,4[bp]
12273 34BE           B9                   001E  mov	cx,*$1E
12274 34C1           F7E9                       imul	cx
12275 34C3           89C3                       mov	bx,ax
12276                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
12277                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
12278 34C5           81C3                 0158  add	bx,#$158
12279 34C9           53                         push	bx
12280                                           ! Debug: list unsigned long sectors = [S+$30-$1E] (used reg = )
12281 34CA           FF76         E6            push	-$1A[bp]
12282 34CD           FF76         E4            push	-$1C[bp]
12283                                           ! Debug: func () void = _write_dword+0 (used reg = )
12284 34D0           E8         CB94            call	__write_dword
12285 34D3           83C4                   08  add	sp,*8
12286                                           !BCC_EOS
12287                                           ! 2366   return 0;
12288 34D6           31C0                       xor	ax,ax
12289 34D8           89EC                       mov	sp,bp
12290 34DA           5D                         pop	bp
12291 34DB           C3                         ret
12292                                           !BCC_EOS
12293                                           ! 2367 }
12294                                           ! 2368   Bit16u
12295                                           ! Register BX used in function atapi_is_ready
12296                                           ! 2369 atapi_is_cdrom(device)
12297                                           ! 2370   Bit8u device;
12298                                           export	_atapi_is_cdrom
12299                       000034DC            _atapi_is_cdrom:
12300                                           !BCC_EOS
12301                                           ! 2371 {
12302                                           ! 2372   Bit16u ebda_seg=get_ebda_seg();
12303 34DC           55                         push	bp
12304 34DD           89E5                       mov	bp,sp
12305 34DF           4C                         dec	sp
12306 34E0           4C                         dec	sp
12307                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
12308 34E1           E8         D188            call	_get_ebda_seg
12309                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12310 34E4           8946         FE            mov	-2[bp],ax
12311                                           !BCC_EOS
12312                                           ! 2373   if (device >= (4*2))
12313                                           ! Debug: ge int = const 8 to unsigned char device = [S+4+2] (used reg = )
12314 34E7           8A46         04            mov	al,4[bp]
12315 34EA           3C                     08  cmp	al,*8
12316 34EC           72           06            jb  	.2EA
12317                       000034EE            .2EB:
12318                                           ! 2374     return 0;
12319 34EE           31C0                       xor	ax,ax
12320 34F0           89EC                       mov	sp,bp
12321 34F2           5D                         pop	bp
12322 34F3           C3                         ret
12323                                           !BCC_EOS
12324                                           ! 2375   if (_read_byte(&((ebda_data_t *) 0)->ata.devices[device].type, ebda_seg) != 0x03)
12325                       000034F4            .2EA:
12326                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
12327 34F4           FF76         FE            push	-2[bp]
12328                                           ! Debug: ptradd unsigned char device = [S+6+2] to [8] struct  = const $142 (used reg = )
12329 34F7           8A46         04            mov	al,4[bp]
12330 34FA           30E4                       xor	ah,ah
12331 34FC           B9                   001E  mov	cx,*$1E
12332 34FF           F7E9                       imul	cx
12333 3501           89C3                       mov	bx,ax
12334                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
12335                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
12336 3503           81C3                 0142  add	bx,#$142
12337 3507           53                         push	bx
12338                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12339 3508           E8         D0D9            call	__read_byte
12340 350B           83C4                   04  add	sp,*4
12341                                           ! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
12342 350E           3C                     03  cmp	al,*3
12343 3510           74           06            je  	.2EC
12344                       00003512            .2ED:
12345                                           ! 2376     return 0;
12346 3512           31C0                       xor	ax,ax
12347 3514           89EC                       mov	sp,bp
12348 3516           5D                         pop	bp
12349 3517           C3                         ret
12350                                           !BCC_EOS
12351                                           ! 2377   if (_read_byte(&((ebda_data_t *) 0)->ata.devices[device].device, ebda_seg) != 0x05)
12352                       00003518            .2EC:
12353                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
12354 3518           FF76         FE            push	-2[bp]
12355                                           ! Debug: ptradd unsigned char device = [S+6+2] to [8] struct  = const $142 (used reg = )
12356 351B           8A46         04            mov	al,4[bp]
12357 351E           30E4                       xor	ah,ah
12358 3520           B9                   001E  mov	cx,*$1E
12359 3523           F7E9                       imul	cx
12360 3525           89C3                       mov	bx,ax
12361                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
12362                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
12363 3527           81C3                 0143  add	bx,#$143
12364 352B           53                         push	bx
12365                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12366 352C           E8         D0B5            call	__read_byte
12367 352F           83C4                   04  add	sp,*4
12368                                           ! Debug: ne int = const 5 to unsigned char = al+0 (used reg = )
12369 3532           3C                     05  cmp	al,*5
12370 3534           74           06            je  	.2EE
12371                       00003536            .2EF:
12372                                           ! 2378     return 0;
12373 3536           31C0                       xor	ax,ax
12374 3538           89EC                       mov	sp,bp
12375 353A           5D                         pop	bp
12376 353B           C3                         ret
12377                                           !BCC_EOS
12378                                           ! 2379   return 1;
12379                       0000353C            .2EE:
12380 353C           B8                   0001  mov	ax,*1
12381 353F           89EC                       mov	sp,bp
12382 3541           5D                         pop	bp
12383 3542           C3                         ret
12384                                           !BCC_EOS
12385                                           ! 2380 }
12386                                           ! 2381   void
12387                                           ! Register BX used in function atapi_is_cdrom
12388                                           ! 2382 cdemu_init()
12389                                           ! 2383 {
12390                                           export	_cdemu_init
12391                       00003543            _cdemu_init:
12392                                           ! 2384   B
12393                                           ! 2384 it16u ebda_seg=get_ebda_seg();
12394 3543           55                         push	bp
12395 3544           89E5                       mov	bp,sp
12396 3546           4C                         dec	sp
12397 3547           4C                         dec	sp
12398                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
12399 3548           E8         D121            call	_get_ebda_seg
12400                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12401 354B           8946         FE            mov	-2[bp],ax
12402                                           !BCC_EOS
12403                                           ! 2385   _write_byte(0x00, &((ebda_data_t *) 0)->cdemu.active, ebda_seg);
12404                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
12405 354E           FF76         FE            push	-2[bp]
12406                                           ! Debug: list * unsigned char = const $25A (used reg = )
12407 3551           B8                   025A  mov	ax,#$25A
12408 3554           50                         push	ax
12409                                           ! Debug: list int = const 0 (used reg = )
12410 3555           31C0                       xor	ax,ax
12411 3557           50                         push	ax
12412                                           ! Debug: func () void = _write_byte+0 (used reg = )
12413 3558           E8         D0A5            call	__write_byte
12414 355B           83C4                   06  add	sp,*6
12415                                           !BCC_EOS
12416                                           ! 2386 }
12417 355E           89EC                       mov	sp,bp
12418 3560           5D                         pop	bp
12419 3561           C3                         ret
12420                                           ! 2387   Bit8u
12421                                           ! 2388 cdemu_isactive()
12422                                           ! 2389 {
12423                                           export	_cdemu_isactive
12424                       00003562            _cdemu_isactive:
12425                                           ! 2390   Bit16u ebda_seg=get_ebda_seg();
12426 3562           55                         push	bp
12427 3563           89E5                       mov	bp,sp
12428 3565           4C                         dec	sp
12429 3566           4C                         dec	sp
12430                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
12431 3567           E8         D102            call	_get_ebda_seg
12432                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12433 356A           8946         FE            mov	-2[bp],ax
12434                                           !BCC_EOS
12435                                           ! 2391   return(_read_byte(&((ebda_data_t *) 0)->cdemu.active, ebda_seg));
12436                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
12437 356D           FF76         FE            push	-2[bp]
12438                                           ! Debug: list * unsigned char = const $25A (used reg = )
12439 3570           B8                   025A  mov	ax,#$25A
12440 3573           50                         push	ax
12441                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12442 3574           E8         D06D            call	__read_byte
12443 3577           83C4                   04  add	sp,*4
12444                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
12445 357A           89EC                       mov	sp,bp
12446 357C           5D                         pop	bp
12447 357D           C3                         ret
12448                                           !BCC_EOS
12449                                           ! 2392 }
12450                                           ! 2393   Bit8u
12451                                           ! 2394 cdemu_emulated_drive()
12452                                           ! 2395 {
12453                                           export	_cdemu_emulated_drive
12454                       0000357E            _cdemu_emulated_drive:
12455                                           ! 2396   Bit16u ebda_seg=get_ebda_seg();
12456 357E           55                         push	bp
12457 357F           89E5                       mov	bp,sp
12458 3581           4C                         dec	sp
12459 3582           4C                         dec	sp
12460                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
12461 3583           E8         D0E6            call	_get_ebda_seg
12462                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12463 3586           8946         FE            mov	-2[bp],ax
12464                                           !BCC_EOS
12465                                           ! 2397   return(_read_byte(&((ebda_data_t *) 0)->cdemu.emulated_drive, ebda_seg));
12466                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
12467 3589           FF76         FE            push	-2[bp]
12468                                           ! Debug: list * unsigned char = const $25C (used reg = )
12469 358C           B8                   025C  mov	ax,#$25C
12470 358F           50                         push	ax
12471                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12472 3590           E8         D051            call	__read_byte
12473 3593           83C4                   04  add	sp,*4
12474                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
12475 3596           89EC                       mov	sp,bp
12476 3598           5D                         pop	bp
12477 3599           C3                         ret
12478                                           !BCC_EOS
12479                                           ! 2398 }
12480                                           ! 2399 static char isotag[6]="CD001";
12481                                           
12482                       0000359A            _isotag:
12483                       0000359A            .2F0:
12484 359A                        43            .ascii	"CD001"
12485 359F                        00            .byte	0
12486                                           !BCC_EOS
12487                                           ! 2400 static char eltorito[24]="EL TORITO SPECIFICATION";
12488                       000035A0            _eltorito:
12489                       000035A0            .2F1:
12490 35A0                        45            .ascii	"EL TORITO SPECIFICATION"
12491 35B7                        00            .byte	0
12492                                           !BCC_EOS
12493                                           ! 2401   Bit16u
12494                                           ! 2402 cdrom_boot()
12495                                           ! 2403 {
12496                                           
12497                                           export	_cdrom_boot
12498                       000035B8            _cdrom_boot:
12499                                           ! 2404   Bit16u ebda_seg=get_ebda_seg(), old_ds;
12500 35B8           55                         push	bp
12501 35B9           89E5                       mov	bp,sp
12502 35BB           4C                         dec	sp
12503 35BC           4C                         dec	sp
12504                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
12505 35BD           E8         D0AC            call	_get_ebda_seg
12506                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12507 35C0           8946         FE            mov	-2[bp],ax
12508                                           !BCC_EOS
12509                                           ! 2405   Bit8u atacmd[12], buffer[2048];
12510                                           !BCC_EOS
12511                                           ! 2406   Bit32u lba;
12512                                           !BCC_EOS
12513                                           ! 2407   Bit16u boot_segment, nbsectors, i, error;
12514                                           !BCC_EOS
12515                                           ! 2408   Bit8u device;
12516                                           !BCC_EOS
12517                                           ! 2409   for (device=0; device<(4*2);device++) {
12518 35C3           81C4                 F7E4  add	sp,#-$81C
12519                                           ! Debug: eq int = const 0 to unsigned char device = [S+$820-$81F] (used reg = )
12520 35C7           30C0                       xor	al,al
12521 35C9           8886       F7E3            mov	-$81D[bp],al
12522                                           !BCC_EOS
12523                                           !BCC_EOS
12524 35CD           EB           1B            jmp .2F4
12525                       000035CF            .2F5:
12526                                           ! 2410     if (atapi_is_cdrom(device)) break;
12527                                           ! Debug: list unsigned char device = [S+$820-$81F] (used reg = )
12528 35CF           8A86       F7E3            mov	al,-$81D[bp]
12529 35D3           30E4                       xor	ah,ah
12530 35D5           50                         push	ax
12531                                           ! Debug: func () unsigned short = atapi_is_cdrom+0 (used reg = )
12532 35D6           E8         FF03            call	_atapi_is_cdrom
12533 35D9           44                         inc	sp
12534 35DA           44                         inc	sp
12535 35DB           85C0                       test	ax,ax
12536 35DD           74           02            je  	.2F6
12537                       000035DF            .2F7:
12538 35DF           EB           11            jmp .2F2
12539                                           !BCC_EOS
12540                                           ! 2411   }
12541                       000035E1            .2F6:
12542                                           ! 2412   if(device >= (4*2)) return 2;
12543                       000035E1            .2F3:
12544                                           ! Debug: postinc unsigned char device = [S+$820-$81F] (used reg = )
12545 35E1           8A86       F7E3            mov	al,-$81D[bp]
12546 35E5           40                         inc	ax
12547 35E6           8886       F7E3            mov	-$81D[bp],al
12548                       000035EA            .2F4:
12549                                           ! Debug: lt int = const 8 to unsigned char device = [S+$820-$81F] (used reg = )
12550 35EA           8A86       F7E3            mov	al,-$81D[bp]
12551 35EE           3C                     08  cmp	al,*8
12552 35F0           72           DD            jb 	.2F5
12553                       000035F2            .2F8:
12554                       000035F2            .2F2:
12555                                           ! Debug: ge int = const 8 to unsigned char device = [S+$820-$81F] (used reg = )
12556 35F2           8A86       F7E3            mov	al,-$81D[bp]
12557 35F6           3C                     08  cmp	al,*8
12558 35F8           72           07            jb  	.2F9
12559                       000035FA            .2FA:
12560 35FA           B8                   0002  mov	ax,*2
12561 35FD           89EC                       mov	sp,bp
12562 35FF           5D                         pop	bp
12563 3600           C3                         ret
12564                                           !BCC_EOS
12565                                           ! 2413   if(error = atapi_is_ready(device) != 0)
12566                       00003601            .2F9:
12567                                           ! Debug: list unsigned char device = [S+$820-$81F] (used reg = )
12568 3601           8A86       F7E3            mov	al,-$81D[bp]
12569 3605           30E4                       xor	ah,ah
12570 3607           50                         push	ax
12571                                           ! Debug: func () unsigned short = atapi_is_ready+0 (used reg = )
12572 3608           E8         FC6E            call	_atapi_is_ready
12573 360B           44                         inc	sp
12574 360C           44                         inc	sp
12575                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
12576 360D           85C0                       test	ax,ax
12577 360F           74           04            je 	.2FD
12578 3611           B0                     01  mov	al,*1
12579 3613           EB           02            jmp	.2FE
12580                       00003615            .2FD:
12581 3615           30C0                       xor	al,al
12582                       00003617            .2FE:
12583                                           ! Debug: eq char = al+0 to unsigned short error = [S+$820-$81E] (used reg = )
12584 3617           30E4                       xor	ah,ah
12585 3619           8986       F7E4            mov	-$81C[bp],ax
12586 361D           85C0                       test	ax,ax
12587 361F           74           12            je  	.2FB
12588                       00003621            .2FC:
12589                                           ! 2414     bios_printf(4, "ata_is_ready returned %d\n",error);
12590                                           ! Debug: list unsigned short error = [S+$820-$81E] (used reg = )
12591 3621           FFB6       F7E4            push	-$81C[bp]
12592                                           ! Debug: list * char = .2FF+0 (used reg = )
12593 3625           BB                   D5B6  mov	bx,#.2FF
12594 3628           53                         push	bx
12595                                           ! Debug: list int = const 4 (used reg = )
12596 3629           B8                   0004  mov	ax,*4
12597 362C           50                         push	ax
12598                                           ! Debug: func () void = bios_printf+0 (used reg = )
12599 362D           E8         D30E            call	_bios_printf
12600 3630           83C4                   06  add	sp,*6
12601                                           !BCC_EOS
12602                                           ! 2415   _memsetb(0,atacmd,get_SS(),12);
12603                       00003633            .2FB:
12604                                           ! Debug: list int = const $C (used reg = )
12605 3633           B8                   000C  mov	ax,*$C
12606 3636           50                         push	ax
12607                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12608 3637           E8         D025            call	_get_SS
12609                                           ! Debug: list unsigned short = ax+0 (used reg = )
12610 363A           50                         push	ax
12611                                           ! Debug: list * unsigned char atacmd = S+$824-$12 (used reg = )
12612 363B           8D5E         F0            lea	bx,-$10[bp]
12613 363E           53                         push	bx
12614                                           ! Debug: list int = const 0 (used reg = )
12615 363F           31C0                       xor	ax,ax
12616 3641           50                         push	ax
12617                                           ! Debug: func () void = _memsetb+0 (used reg = )
12618 3642           E8         C9BB            call	__memsetb
12619 3645           83C4                   08  add	sp,*8
12620                                           !BCC_EOS
12621                                           ! 2416   atacmd[0]=0x28;
12622                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$820-$12] (used reg = )
12623 3648           B0                     28  mov	al,*$28
12624 364A           8846         F0            mov	-$10[bp],al
12625                                           !BCC_EOS
12626                                           ! 2417   atacmd[7]=(0x01 & 0xff00) >> 8;
12627                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$820-$B] (used reg = )
12628 364D           30C0                       xor	al,al
12629 364F           8846         F7            mov	-9[bp],al
12630                                           !BCC_EOS
12631                                           ! 2418   atacmd[8]=(0x01 & 0x00ff);
12632                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$820-$A] (used reg = )
12633 3652           B0                     01  mov	al,*1
12634 3654           8846         F8            mov	-8[bp],al
12635                                           !BCC_EOS
12636                                           ! 2419   atacmd[2]=(0x11 & 0xff000000) >> 24;
12637                                           ! Debug: eq unsigned long = const 0 to unsigned char atacmd = [S+$820-$10] (used reg = )
12638 3657           30C0                       xor	al,al
12639 3659           8846         F2            mov	-$E[bp],al
12640                                           !BCC_EOS
12641                                           ! 2420   atacmd[3]=(0x11 & 0x00ff0000) >> 16;
12642                                           ! Debug: eq long = const 0 to unsigned char atacmd = [S+$820-$F] (used reg = )
12643 365C           30C0                       xor	al,al
12644 365E           8846         F3            mov	-$D[bp],al
12645                                           !BCC_EOS
12646                                           ! 2421   atacmd[4]=(0x11 & 0x0000ff00) >> 8;
12647                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$820-$E] (used reg = )
12648 3661           30C0                       xor	al,al
12649 3663           8846         F4            mov	-$C[bp],al
12650                                           !BCC_EOS
12651                                           ! 2422   atacmd[5]=(0x11 & 0x000000ff);
12652                                           ! Debug: eq int = const $11 to unsigned char atacmd = [S+$820-$D] (used reg = )
12653 3666           B0                     11  mov	al,*$11
12654 3668           8846         F5            mov	-$B[bp],al
12655                                           !BCC_EOS
12656                                           ! 2423   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
12657                                           ! Debug: list * unsigned char buffer = S+$820-$812 (used reg = )
12658 366B           8D9E       F7F0            lea	bx,-$810[bp]
12659 366F           53                         push	bx
12660                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12661 3670           E8         CFEC            call	_get_SS
12662                                           ! Debug: list unsigned short = ax+0 (used reg = )
12663 3673           50                         push	ax
12664                                           ! Debug: list int = const 1 (used reg = )
12665 3674           B8                   0001  mov	ax,*1
12666 3677           50                         push	ax
12667                                           ! Debug: list long = const $800 (used reg = )
12668 3678           B8                   0800  mov	ax,#$800
12669 367B           31DB                       xor	bx,bx
12670 367D           53                         push	bx
12671 367E           50                         push	ax
12672                                           ! Debug: list int = const 0 (used reg = )
12673 367F           31C0                       xor	ax,ax
12674 3681           50                         push	ax
12675                                           ! Debug: list * unsigned char atacmd = S+$82C-$12 (used reg = )
12676 3682           8D5E         F0            lea	bx,-$10[bp]
12677 3685           53                         push	bx
12678                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12679 3686           E8         CFD6            call	_get_SS
12680                                           ! Debug: list unsigned short = ax+0 (used reg = )
12681 3689           50                         push	ax
12682                                           ! Debug: list int = const $C (used reg = )
12683 368A           B8                   000C  mov	ax,*$C
12684 368D           50                         push	ax
12685                                           ! Debug: list unsigned char device = [S+$832-$81F] (used reg = )
12686 368E           8A86       F7E3            mov	al,-$81D[bp]
12687 3692           30E4                       xor	ah,ah
12688 3694           50                         push	ax
12689                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
12690 3695           E8         F6B2            call	_ata_cmd_packet
12691 3698           83C4                   14  add	sp,*$14
12692                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$820-$81E] (used reg = )
12693 369B           8986       F7E4            mov	-$81C[bp],ax
12694                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
12695 369F           85C0                       test	ax,ax
12696 36A1           74           07            je  	.300
12697                       000036A3            .301:
12698                                           ! 2424     return 3;
12699 36A3           B8                   0003  mov	ax,*3
12700 36A6           89EC                       mov	sp,bp
12701 36A8           5D                         pop	bp
12702 36A9           C3                         ret
12703                                           !BCC_EOS
12704                                           ! 2425   if(buffer[0]!=0) return 4;
12705                       000036AA            .300:
12706                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$820-$812] (used reg = )
12707 36AA           8A86       F7F0            mov	al,-$810[bp]
12708 36AE           84C0                       test	al,al
12709 36B0           74           07            je  	.302
12710                       000036B2            .303:
12711 36B2           B8                   0004  mov	ax,*4
12712 36B5           89EC                       mov	sp,bp
12713 36B7           5D                         pop	bp
12714 36B8           C3                         ret
12715                                           !BCC_EOS
12716                                           ! 2426   for(i=0;i<5;i++){
12717                       000036B9            .302:
12718                                           ! Debug: eq int = const 0 to unsigned short i = [S+$820-$81C] (used reg = )
12719 36B9           31C0                       xor	ax,ax
12720 36BB           8986       F7E6            mov	-$81A[bp],ax
12721                                           !BCC_EOS
12722                                           !BCC_EOS
12723 36BF           EB           3B            jmp .306
12724                       000036C1            .307:
12725                                           ! 2427     if(buffer[1+i]!=_read_byte(&isotag[i], 0xf000)) return 5;
12726                                           ! Debug: list unsigned int = const $F000 (used reg = )
12727 36C1           B8                   F000  mov	ax,#$F000
12728 36C4           50                         push	ax
12729                                           ! Debug: ptradd unsigned short i = [S+$822-$81C] to [6] char = isotag+0 (used reg = )
12730 36C5           8B9E       F7E6            mov	bx,-$81A[bp]
12731                                           ! Debug: address char = [bx+_isotag+0] (used reg = )
12732                                           ! Debug: list * char = bx+_isotag+0 (used reg = )
12733 36C9           81C3                 359A  add	bx,#_isotag
12734 36CD           53                         push	bx
12735                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12736 36CE           E8         CF13            call	__read_byte
12737 36D1           83C4                   04  add	sp,*4
12738 36D4           50                         push	ax
12739                                           ! Debug: add unsigned short i = [S+$822-$81C] to int = const 1 (used reg = )
12740                                           ! Debug: expression subtree swapping
12741 36D5           8B86       F7E6            mov	ax,-$81A[bp]
12742                                           ! Debug: ptradd unsigned int = ax+1 to [$800] unsigned char buffer = S+$822-$812 (used reg = )
12743 36D9           40                         inc	ax
12744 36DA           89EB                       mov	bx,bp
12745 36DC           01C3                       add	bx,ax
12746                                           ! Debug: ne unsigned char (temp) = [S+$822-$822] to unsigned char = [bx-$810] (used reg = )
12747 36DE           8A87       F7F0            mov	al,-$810[bx]
12748 36E2           3A86       F7E0            cmp	al,-$820[bp]
12749 36E6           8DA6       F7E2            lea	sp,-$81E[bp]
12750 36EA           74           07            je  	.308
12751                       000036EC            .309:
12752 36EC           B8                   0005  mov	ax,*5
12753 36EF           89EC                       mov	sp,bp
12754 36F1           5D                         pop	bp
12755 36F2           C3                         ret
12756                                           !BCC_EOS
12757                                           ! 2428   }
12758                       000036F3            .308:
12759                                           ! 2429   for(i=0;i<23;i++)
12760                       000036F3            .305:
12761                                           ! Debug: postinc unsigned short i = [S+$820-$81C] (used reg = )
12762 36F3           8B86       F7E6            mov	ax,-$81A[bp]
12763 36F7           40                         inc	ax
12764 36F8           8986       F7E6            mov	-$81A[bp],ax
12765                       000036FC            .306:
12766                                           ! Debug: lt int = const 5 to unsigned short i = [S+$820-$81C] (used reg = )
12767 36FC           8B86       F7E6            mov	ax,-$81A[bp]
12768 3700           3D                   0005  cmp	ax,*5
12769 3703           72           BC            jb 	.307
12770                       00003705            .30A:
12771                       00003705            .304:
12772                                           ! Debug: eq int = const 0 to unsigned short i = [S+$820-$81C] (used reg = )
12773 3705           31C0                       xor	ax,ax
12774 3707           8986       F7E6            mov	-$81A[bp],ax
12775                                           !BCC_EOS
12776                                           !BCC_EOS
12777                                           ! 2430     if(buffer[7+i]!=_read_byte(&eltorito[i], 0xf000)) return 6;
12778 370B           EB           3D            jmp .30D
12779                       0000370D            .30E:
12780                                           ! Debug: list unsigned int = const $F000 (used reg = )
12781 370D           B8                   F000  mov	ax,#$F000
12782 3710           50                         push	ax
12783                                           ! Debug: ptradd unsigned short i = [S+$822-$81C] to [$18] char = eltorito+0 (used reg = )
12784 3711           8B9E       F7E6            mov	bx,-$81A[bp]
12785                                           ! Debug: address char = [bx+_eltorito+0] (used reg = )
12786                                           ! Debug: list * char = bx+_eltorito+0 (used reg = )
12787 3715           81C3                 35A0  add	bx,#_eltorito
12788 3719           53                         push	bx
12789                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
12790 371A           E8         CEC7            call	__read_byte
12791 371D           83C4                   04  add	sp,*4
12792 3720           50                         push	ax
12793                                           ! Debug: add unsigned short i = [S+$822-$81C] to int = const 7 (used reg = )
12794                                           ! Debug: expression subtree swapping
12795 3721           8B86       F7E6            mov	ax,-$81A[bp]
12796                                           ! Debug: ptradd unsigned int = ax+7 to [$800] unsigned char buffer = S+$822-$812 (used reg = )
12797 3725           05                   0007  add	ax,*7
12798 3728           89EB                       mov	bx,bp
12799 372A           01C3                       add	bx,ax
12800                                           ! Debug: ne unsigned char (temp) = [S+$822-$822] to unsigned char = [bx-$810] (used reg = )
12801 372C           8A87       F7F0            mov	al,-$810[bx]
12802 3730           3A86       F7E0            cmp	al,-$820[bp]
12803 3734           8DA6       F7E2            lea	sp,-$81E[bp]
12804 3738           74           07            je  	.30F
12805                       0000373A            .310:
12806 373A           B8                   0006  mov	ax,*6
12807 373D           89EC                       mov	sp,bp
12808 373F           5D                         pop	bp
12809 3740           C3                         ret
12810                                           !BCC_EOS
12811                                           ! 2431   lba=*((Bit32u *)&buffer[0x47]);
12812                       00003741            .30F:
12813                       00003741            .30C:
12814                                           ! Debug: postinc unsigned short i = [S+$820-$81C] (used reg = )
12815 3741           8B86       F7E6            mov	ax,-$81A[bp]
12816 3745           40                         inc	ax
12817 3746           8986       F7E6            mov	-$81A[bp],ax
12818                       0000374A            .30D:
12819                                           ! Debug: lt int = const $17 to unsigned short i = [S+$820-$81C] (used reg = )
12820 374A           8B86       F7E6            mov	ax,-$81A[bp]
12821 374E           3D                   0017  cmp	ax,*$17
12822 3751           72           BA            jb 	.30E
12823                       00003753            .311:
12824                       00003753            .30B:
12825                                           ! Debug: eq unsigned long buffer = [S+$820-$7CB] to unsigned long lba = [S+$820-$816] (used reg = )
12826 3753           8B86       F837            mov	ax,-$7C9[bp]
12827 3757           8B9E       F839            mov	bx,-$7C7[bp]
12828 375B           8986       F7EC            mov	-$814[bp],ax
12829 375F           899E       F7EE            mov	-$812[bp],bx
12830                                           !BCC_EOS
12831                                           ! 2432   _memsetb(0,atacmd,get_SS(),12);
12832                                           ! Debug: list int = const $C (used reg = )
12833 3763           B8                   000C  mov	ax,*$C
12834 3766           50                         push	ax
12835                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12836 3767           E8         CEF5            call	_get_SS
12837                                           ! Debug: list unsigned short = ax+0 (used reg = )
12838 376A           50                         push	ax
12839                                           ! Debug: list * unsigned char atacmd = S+$824-$12 (used reg = )
12840 376B           8D5E         F0            lea	bx,-$10[bp]
12841 376E           53                         push	bx
12842                                           ! Debug: list int = const 0 (used reg = )
12843 376F           31C0                       xor	ax,ax
12844 3771           50                         push	ax
12845                                           ! Debug: func () void = _memsetb+0 (used reg = )
12846 3772           E8         C88B            call	__memsetb
12847 3775           83C4                   08  add	sp,*8
12848                                           !BCC_EOS
12849                                           ! 2433   atacmd[0]=0x28;
12850                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$820-$12] (used reg = )
12851 3778           B0                     28  mov	al,*$28
12852 377A           8846         F0            mov	-$10[bp],al
12853                                           !BCC_EOS
12854                                           ! 2434   atacmd[7]=(0x01 & 0xff00) >> 8;
12855                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$820-$B] (used reg = )
12856 377D           30C0                       xor	al,al
12857 377F           8846         F7            mov	-9[bp],al
12858                                           !BCC_EOS
12859                                           ! 2435   atacmd[8]=(0x01 & 0x00ff);
12860                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$820-$A] (used reg = )
12861 3782           B0                     01  mov	al,*1
12862 3784           8846         F8            mov	-8[bp],al
12863                                           !BCC_EOS
12864                                           ! 2436   atacmd[2]=*(((Bit8u *)&*(((Bit16u *)&lba)+1))+1);
12865                                           ! Debug: eq unsigned char lba = [S+$820-$813] to unsigned char atacmd = [S+$820-$10] (used reg = )
12866 3787           8A86       F7EF            mov	al,-$811[bp]
12867 378B           8846         F2            mov	-$E[bp],al
12868                                           !BCC_EOS
12869                                           ! 2437   atacmd[3]=*((Bit8u *)&*(((Bit16u *)&lba)+1));
12870                                           ! Debug: eq unsigned char lba = [S+$820-$814] to unsigned char atacmd = [S+$820-$F] (used reg = )
12871 378E           8A86       F7EE            mov	al,-$812[bp]
12872 3792           8846         F3            mov	-$D[bp],al
12873                                           !BCC_EOS
12874                                           ! 2438   atacmd[4]=*(((Bit8u *)&*((Bit16u *)&lba))+1);
12875                                           ! Debug: eq unsigned char lba = [S+$820-$815] to unsigned char atacmd = [S+$820-$E] (used reg = )
12876 3795           8A86       F7ED            mov	al,-$813[bp]
12877 3799           8846         F4            mov	-$C[bp],al
12878                                           !BCC_EOS
12879                                           ! 2439   atacmd[5]=*((Bit8u *)&lba);
12880                                           ! Debug: eq unsigned char lba = [S+$820-$816] to unsigned char atacmd = [S+$820-$D] (used reg = )
12881 379C           8A86       F7EC            mov	al,-$814[bp]
12882 37A0           8846         F5            mov	-$B[bp],al
12883                                           !BCC_EOS
12884                                           ! 2440   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
12885                                           ! Debug: list * unsigned char buffer = S+$820-$812 (used reg = )
12886 37A3           8D9E       F7F0            lea	bx,-$810[bp]
12887 37A7           53                         push	bx
12888                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12889 37A8           E8         CEB4            call	_get_SS
12890                                           ! Debug: list unsigned short = ax+0 (used reg = )
12891 37AB           50                         push	ax
12892                                           ! Debug: list int = const 1 (used reg = )
12893 37AC           B8                   0001  mov	ax,*1
12894 37AF           50                         push	ax
12895                                           ! Debug: list long = const $800 (used reg = )
12896 37B0           B8                   0800  mov	ax,#$800
12897 37B3           31DB                       xor	bx,bx
12898 37B5           53                         push	bx
12899 37B6           50                         push	ax
12900                                           ! Debug: list int = const 0 (used reg = )
12901 37B7           31C0                       xor	ax,ax
12902 37B9           50                         push	ax
12903                                           ! Debug: list * unsigned char atacmd = S+$82C-$12 (used reg = )
12904 37BA           8D5E         F0            lea	bx,-$10[bp]
12905 37BD           53                         push	bx
12906                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12907 37BE           E8         CE9E            call	_get_SS
12908                                           ! Debug: list unsigned short = ax+0 (used reg = )
12909 37C1           50                         push	ax
12910                                           ! Debug: list int = const $C (used reg = )
12911 37C2           B8                   000C  mov	ax,*$C
12912 37C5           50                         push	ax
12913                                           ! Debug: list unsigned char device = [S+$832-$81F] (used reg = )
12914 37C6           8A86       F7E3            mov	al,-$81D[bp]
12915 37CA           30E4                       xor	ah,ah
12916 37CC           50                         push	ax
12917                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
12918 37CD           E8         F57A            call	_ata_cmd_packet
12919 37D0           83C4                   14  add	sp,*$14
12920                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$820-$81E] (used reg = )
12921 37D3           8986       F7E4            mov	-$81C[bp],ax
12922                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
12923 37D7           85C0                       test	ax,ax
12924 37D9           74           07            je  	.312
12925                       000037DB            .313:
12926                                           ! 2441     return 7;
12927 37DB           B8                   0007  mov	ax,*7
12928 37DE           89EC                       mov	sp,bp
12929 37E0           5D                         pop	bp
12930 37E1           C3                         ret
12931                                           !BCC_EOS
12932                                           ! 2442   if(buffer[0x00]!=0x01)return 8;
12933                       000037E2            .312:
12934                                           ! Debug: ne int = const 1 to unsigned char buffer = [S+$820-$812] (used reg = )
12935 37E2           8A86       F7F0            mov	al,-$810[bp]
12936 37E6           3C                     01  cmp	al,*1
12937 37E8           74           07            je  	.314
12938                       000037EA            .315:
12939 37EA           B8                   0008  mov	ax,*8
12940 37ED           89EC                       mov	sp,bp
12941 37EF           5D                         pop	bp
12942 37F0           C3                         ret
12943                                           !BCC_EOS
12944                                           ! 2443   if(buffer[0x01]!=0x00)return 9;
12945                       000037F1            .314:
12946                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$820-$811] (used reg = )
12947 37F1           8A86       F7F1            mov	al,-$80F[bp]
12948 37F5           84C0                       test	al,al
12949 37F7           74           07            je  	.316
12950                       000037F9            .317:
12951 37F9           B8                   0009  mov	ax,*9
12952 37FC           89EC                       mov	sp,bp
12953 37FE           5D                         pop	bp
12954 37FF           C3                         ret
12955                                           !BCC_EOS
12956                                           ! 2444   if(buffer[0x1E]!=0x55)return 10;
12957                       00003800            .316:
12958                                           ! Debug: ne int = const $55 to unsigned char buffer = [S+$820-$7F4] (used reg = )
12959 3800           8A86       F80E            mov	al,-$7F2[bp]
12960 3804           3C                     55  cmp	al,*$55
12961 3806           74           07            je  	.318
12962                       00003808            .319:
12963 3808           B8                   000A  mov	ax,*$A
12964 380B           89EC                       mov	sp,bp
12965 380D           5D                         pop	bp
12966 380E           C3                         ret
12967                                           !BCC_EOS
12968                                           ! 2445   if(buffer[0x1F]!=0xAA)return 10;
12969                       0000380F            .318:
12970                                           ! Debug: ne int = const $AA to unsigned char buffer = [S+$820-$7F3] (used reg = )
12971 380F           8A86       F80F            mov	al,-$7F1[bp]
12972 3813           3C                     AA  cmp	al,#$AA
12973 3815           74           07            je  	.31A
12974                       00003817            .31B:
12975 3817           B8                   000A  mov	ax,*$A
12976 381A           89EC                       mov	sp,bp
12977 381C           5D                         pop	bp
12978 381D           C3                         ret
12979                                           !BCC_EOS
12980                                           ! 2446   if(buffer[0x20]!=0x88)return 11;
12981                       0000381E            .31A:
12982                                           ! Debug: ne int = const $88 to unsigned char buffer = [S+$820-$7F2] (used reg = )
12983 381E           8A86       F810            mov	al,-$7F0[bp]
12984 3822           3C                     88  cmp	al,#$88
12985 3824           74           07            je  	.31C
12986                       00003826            .31D:
12987 3826           B8                   000B  mov	ax,*$B
12988 3829           89EC                       mov	sp,bp
12989 382B           5D                         pop	bp
12990 382C           C3                         ret
12991                                           !BCC_EOS
12992                                           ! 2447   old_ds 
12993                       0000382D            .31C:
12994                                           ! 2447 = set_DS(ebda_seg);
12995                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
12996 382D           FF76         FE            push	-2[bp]
12997                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
12998 3830           E8         CE2F            call	_set_DS
12999 3833           44                         inc	sp
13000 3834           44                         inc	sp
13001                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+$820-6] (used reg = )
13002 3835           8946         FC            mov	-4[bp],ax
13003                                           !BCC_EOS
13004                                           ! 2448   *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.media)) = (buffer[0x21]);
13005                                           ! Debug: eq unsigned char buffer = [S+$820-$7F1] to unsigned char = [+$25B] (used reg = )
13006 3838           8A86       F811            mov	al,-$7EF[bp]
13007 383C           A2         025B            mov	[$25B],al
13008                                           !BCC_EOS
13009                                           ! 2449   if(buffer[0x21]==0){
13010                                           ! Debug: logeq int = const 0 to unsigned char buffer = [S+$820-$7F1] (used reg = )
13011 383F           8A86       F811            mov	al,-$7EF[bp]
13012 3843           84C0                       test	al,al
13013 3845           75           07            jne 	.31E
13014                       00003847            .31F:
13015                                           ! 2450     *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive)) = (0xE0);
13016                                           ! Debug: eq int = const $E0 to unsigned char = [+$25C] (used reg = )
13017 3847           B0                     E0  mov	al,#$E0
13018 3849           A2         025C            mov	[$25C],al
13019                                           !BCC_EOS
13020                                           ! 2451   }
13021                                           ! 2452   else if(buffer[0x21]<4)
13022 384C           EB           14            jmp .320
13023                       0000384E            .31E:
13024                                           ! Debug: lt int = const 4 to unsigned char buffer = [S+$820-$7F1] (used reg = )
13025 384E           8A86       F811            mov	al,-$7EF[bp]
13026 3852           3C                     04  cmp	al,*4
13027 3854           73           07            jae 	.321
13028                       00003856            .322:
13029                                           ! 2453     *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive)) = (0x00);
13030                                           ! Debug: eq int = const 0 to unsigned char = [+$25C] (used reg = )
13031 3856           30C0                       xor	al,al
13032 3858           A2         025C            mov	[$25C],al
13033                                           !BCC_EOS
13034                                           ! 2454   else
13035                                           ! 2455     *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive)) = (0x80);
13036 385B           EB           05            jmp .323
13037                       0000385D            .321:
13038                                           ! Debug: eq int = const $80 to unsigned char = [+$25C] (used reg = )
13039 385D           B0                     80  mov	al,#$80
13040 385F           A2         025C            mov	[$25C],al
13041                                           !BCC_EOS
13042                                           ! 2456   *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.controller_index)) = (device/2);
13043                       00003862            .323:
13044                       00003862            .320:
13045                                           ! Debug: div int = const 2 to unsigned char device = [S+$820-$81F] (used reg = )
13046 3862           8A86       F7E3            mov	al,-$81D[bp]
13047 3866           30E4                       xor	ah,ah
13048 3868           D1E8                       shr	ax,*1
13049                                           ! Debug: eq unsigned int = ax+0 to unsigned char = [+$25D] (used reg = )
13050 386A           A2         025D            mov	[$25D],al
13051                                           !BCC_EOS
13052                                           ! 2457   *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.device_spec)) = (device%2);
13053                                           ! Debug: mod int = const 2 to unsigned char device = [S+$820-$81F] (used reg = )
13054 386D           8A86       F7E3            mov	al,-$81D[bp]
13055 3871           30E4                       xor	ah,ah
13056 3873           24                     01  and	al,*1
13057                                           ! Debug: eq unsigned char = al+0 to unsigned char = [+$25E] (used reg = )
13058 3875           A2         025E            mov	[$25E],al
13059                                           !BCC_EOS
13060                                           ! 2458   boot_segment=*((Bit16u *)&buffer[0x22]);
13061                                           ! Debug: eq unsigned short buffer = [S+$820-$7F0] to unsigned short boot_segment = [S+$820-$818] (used reg = )
13062 3878           8B86       F812            mov	ax,-$7EE[bp]
13063 387C           8986       F7EA            mov	-$816[bp],ax
13064                                           !BCC_EOS
13065                                           ! 2459   if(boot_segment==0x0000)boot_segment=0x07C0;
13066                                           ! Debug: logeq int = const 0 to unsigned short boot_segment = [S+$820-$818] (used reg = )
13067 3880           8B86       F7EA            mov	ax,-$816[bp]
13068 3884           85C0                       test	ax,ax
13069 3886           75           07            jne 	.324
13070                       00003888            .325:
13071                                           ! Debug: eq int = const $7C0 to unsigned short boot_segment = [S+$820-$818] (used reg = )
13072 3888           B8                   07C0  mov	ax,#$7C0
13073 388B           8986       F7EA            mov	-$816[bp],ax
13074                                           !BCC_EOS
13075                                           ! 2460   *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.load_segment)) = (boot_segment);
13076                       0000388F            .324:
13077                                           ! Debug: eq unsigned short boot_segment = [S+$820-$818] to unsigned short = [+$266] (used reg = )
13078 388F           8B86       F7EA            mov	ax,-$816[bp]
13079 3893           A3         0266            mov	[$266],ax
13080                                           !BCC_EOS
13081                                           ! 2461   *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.buffer_segment)) = (0x0000);
13082                                           ! Debug: eq int = const 0 to unsigned short = [+$264] (used reg = )
13083 3896           31C0                       xor	ax,ax
13084 3898           A3         0264            mov	[$264],ax
13085                                           !BCC_EOS
13086                                           ! 2462   nbsectors=*((Bit16u *)&buffer[0x26]);
13087                                           ! Debug: eq unsigned short buffer = [S+$820-$7EC] to unsigned short nbsectors = [S+$820-$81A] (used reg = )
13088 389B           8B86       F816            mov	ax,-$7EA[bp]
13089 389F           8986       F7E8            mov	-$818[bp],ax
13090                                           !BCC_EOS
13091                                           ! 2463   *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.sector_count)) = (nbsectors);
13092                                           ! Debug: eq unsigned short nbsectors = [S+$820-$81A] to unsigned short = [+$268] (used reg = )
13093 38A3           8B86       F7E8            mov	ax,-$818[bp]
13094 38A7           A3         0268            mov	[$268],ax
13095                                           !BCC_EOS
13096                                           ! 2464   lba=*((Bit32u *)&buffer[0x28]);
13097                                           ! Debug: eq unsigned long buffer = [S+$820-$7EA] to unsigned long lba = [S+$820-$816] (used reg = )
13098 38AA           8B86       F818            mov	ax,-$7E8[bp]
13099 38AE           8B9E       F81A            mov	bx,-$7E6[bp]
13100 38B2           8986       F7EC            mov	-$814[bp],ax
13101 38B6           899E       F7EE            mov	-$812[bp],bx
13102                                           !BCC_EOS
13103                                           ! 2465   *((Bit32u *)(&((ebda_data_t *) 0)->cdemu.ilba)) = (lba);
13104                                           ! Debug: eq unsigned long lba = [S+$820-$816] to unsigned long = [+$260] (used reg = )
13105 38BA           8B86       F7EC            mov	ax,-$814[bp]
13106 38BE           8B9E       F7EE            mov	bx,-$812[bp]
13107 38C2           A3         0260            mov	[$260],ax
13108 38C5           891E       0262            mov	[$262],bx
13109                                           !BCC_EOS
13110                                           ! 2466   _memsetb(0,atacmd,get_SS(),12);
13111                                           ! Debug: list int = const $C (used reg = )
13112 38C9           B8                   000C  mov	ax,*$C
13113 38CC           50                         push	ax
13114                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13115 38CD           E8         CD8F            call	_get_SS
13116                                           ! Debug: list unsigned short = ax+0 (used reg = )
13117 38D0           50                         push	ax
13118                                           ! Debug: list * unsigned char atacmd = S+$824-$12 (used reg = )
13119 38D1           8D5E         F0            lea	bx,-$10[bp]
13120 38D4           53                         push	bx
13121                                           ! Debug: list int = const 0 (used reg = )
13122 38D5           31C0                       xor	ax,ax
13123 38D7           50                         push	ax
13124                                           ! Debug: func () void = _memsetb+0 (used reg = )
13125 38D8           E8         C725            call	__memsetb
13126 38DB           83C4                   08  add	sp,*8
13127                                           !BCC_EOS
13128                                           ! 2467   atacmd[0]=0x28;
13129                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$820-$12] (used reg = )
13130 38DE           B0                     28  mov	al,*$28
13131 38E0           8846         F0            mov	-$10[bp],al
13132                                           !BCC_EOS
13133                                           ! 2468   i = 1+(nbsectors-1)/4;
13134                                           ! Debug: sub int = const 1 to unsigned short nbsectors = [S+$820-$81A] (used reg = )
13135 38E3           8B86       F7E8            mov	ax,-$818[bp]
13136                                           ! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
13137 38E7           48                         dec	ax
13138 38E8           D1E8                       shr	ax,*1
13139 38EA           D1E8                       shr	ax,*1
13140                                           ! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
13141                                           ! Debug: expression subtree swapping
13142                                           ! Debug: eq unsigned int = ax+1 to unsigned short i = [S+$820-$81C] (used reg = )
13143 38EC           40                         inc	ax
13144 38ED           8986       F7E6            mov	-$81A[bp],ax
13145                                           !BCC_EOS
13146                                           ! 2469   atacmd[7]=*(((Bit8u *)&i)+1);
13147                                           ! Debug: eq unsigned char i = [S+$820-$81B] to unsigned char atacmd = [S+$820-$B] (used reg = )
13148 38F1           8A86       F7E7            mov	al,-$819[bp]
13149 38F5           8846         F7            mov	-9[bp],al
13150                                           !BCC_EOS
13151                                           ! 2470   atacmd[8]=*((Bit8u *)&i);
13152                                           ! Debug: eq unsigned char i = [S+$820-$81C] to unsigned char atacmd = [S+$820-$A] (used reg = )
13153 38F8           8A86       F7E6            mov	al,-$81A[bp]
13154 38FC           8846         F8            mov	-8[bp],al
13155                                           !BCC_EOS
13156                                           ! 2471   atacmd[2]=*(((Bit8u *)&*(((Bit16u *)&lba)+1))+1);
13157                                           ! Debug: eq unsigned char lba = [S+$820-$813] to unsigned char atacmd = [S+$820-$10] (used reg = )
13158 38FF           8A86       F7EF            mov	al,-$811[bp]
13159 3903           8846         F2            mov	-$E[bp],al
13160                                           !BCC_EOS
13161                                           ! 2472   atacmd[3]=*((Bit8u *)&*(((Bit16u *)&lba)+1));
13162                                           ! Debug: eq unsigned char lba = [S+$820-$814] to unsigned char atacmd = [S+$820-$F] (used reg = )
13163 3906           8A86       F7EE            mov	al,-$812[bp]
13164 390A           8846         F3            mov	-$D[bp],al
13165                                           !BCC_EOS
13166                                           ! 2473   atacmd[4]=*(((Bit8u *)&*((Bit16u *)&lba))+1);
13167                                           ! Debug: eq unsigned char lba = [S+$820-$815] to unsigned char atacmd = [S+$820-$E] (used reg = )
13168 390D           8A86       F7ED            mov	al,-$813[bp]
13169 3911           8846         F4            mov	-$C[bp],al
13170                                           !BCC_EOS
13171                                           ! 2474   atacmd[5]=*((Bit8u *)&lba);
13172                                           ! Debug: eq unsigned char lba = [S+$820-$816] to unsigned char atacmd = [S+$820-$D] (used reg = )
13173 3914           8A86       F7EC            mov	al,-$814[bp]
13174 3918           8846         F5            mov	-$B[bp],al
13175                                           !BCC_EOS
13176                                           ! 2475   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, nbsectors*512L, 0x01, boot_segment,0)) != 0)
13177                                           ! Debug: list int = const 0 (used reg = )
13178 391B           31C0                       xor	ax,ax
13179 391D           50                         push	ax
13180                                           ! Debug: list unsigned short boot_segment = [S+$822-$818] (used reg = )
13181 391E           FFB6       F7EA            push	-$816[bp]
13182                                           ! Debug: list int = const 1 (used reg = )
13183 3922           B8                   0001  mov	ax,*1
13184 3925           50                         push	ax
13185                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$826-$81A] (used reg = )
13186 3926           8B86       F7E8            mov	ax,-$818[bp]
13187 392A           31DB                       xor	bx,bx
13188                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
13189 392C           53                         push	bx
13190 392D           50                         push	ax
13191 392E           B8                   0200  mov	ax,#$200
13192 3931           31DB                       xor	bx,bx
13193 3933           53                         push	bx
13194 3934           50                         push	ax
13195 3935           8B86       F7D8            mov	ax,-$828[bp]
13196 3939           8B9E       F7DA            mov	bx,-$826[bp]
13197 393D           8DBE       F7D4            lea	di,-$82C[bp]
13198 3941           E8         C776            call	lmulul
13199 3944           83C4                   08  add	sp,*8
13200                                           ! Debug: list unsigned long = bx+0 (used reg = )
13201 3947           53                         push	bx
13202 3948           50                         push	ax
13203                                           ! Debug: list int = const 0 (used reg = )
13204 3949           31C0                       xor	ax,ax
13205 394B           50                         push	ax
13206                                           ! Debug: list * unsigned char atacmd = S+$82C-$12 (used reg = )
13207 394C           8D5E         F0            lea	bx,-$10[bp]
13208 394F           53                         push	bx
13209                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13210 3950           E8         CD0C            call	_get_SS
13211                                           ! Debug: list unsigned short = ax+0 (used reg = )
13212 3953           50                         push	ax
13213                                           ! Debug: list int = const $C (used reg = )
13214 3954           B8                   000C  mov	ax,*$C
13215 3957           50                         push	ax
13216                                           ! Debug: list unsigned char device = [S+$832-$81F] (used reg = )
13217 3958           8A86       F7E3            mov	al,-$81D[bp]
13218 395C           30E4                       xor	ah,ah
13219 395E           50                         push	ax
13220                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
13221 395F           E8         F3E8            call	_ata_cmd_packet
13222 3962           83C4                   14  add	sp,*$14
13223                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$820-$81E] (used reg = )
13224 3965           8986       F7E4            mov	-$81C[bp],ax
13225                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
13226 3969           85C0                       test	ax,ax
13227 396B           74           0F            je  	.326
13228                       0000396D            .327:
13229                                           ! 2476   {
13230                                           ! 2477     set_DS(old_ds);
13231                                           ! Debug: list unsigned short old_ds = [S+$820-6] (used reg = )
13232 396D           FF76         FC            push	-4[bp]
13233                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
13234 3970           E8         CCEF            call	_set_DS
13235 3973           44                         inc	sp
13236 3974           44                         inc	sp
13237                                           !BCC_EOS
13238                                           ! 2478     return 12;
13239 3975           B8                   000C  mov	ax,*$C
13240 3978           89EC                       mov	sp,bp
13241 397A           5D                         pop	bp
13242 397B           C3                         ret
13243                                           !BCC_EOS
13244                                           ! 2479   }
13245                                           ! 2480   switch(*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.media))) {
13246                       0000397C            .326:
13247 397C           A0         025B            mov	al,[$25B]
13248 397F           E9         009B            br 	.32A
13249                                           ! 2481     case 0x01:
13250                                           ! 2482       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt)) = (15);
13251                       00003982            .32B:
13252                                           ! Debug: eq int = const $F to unsigned short = [+$26E] (used reg = )
13253 3982           B8                   000F  mov	ax,*$F
13254 3985           A3         026E            mov	[$26E],ax
13255                                           !BCC_EOS
13256                                           ! 2483       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders)) = (80);
13257                                           ! Debug: eq int = const $50 to unsigned short = [+$26C] (used reg = )
13258 3988           B8                   0050  mov	ax,*$50
13259 398B           A3         026C            mov	[$26C],ax
13260                                           !BCC_EOS
13261                                           ! 2484       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads)) = (2);
13262                                           ! Debug: eq int = const 2 to unsigned short = [+$26A] (used reg = )
13263 398E           B8                   0002  mov	ax,*2
13264 3991           A3         026A            mov	[$26A],ax
13265                                           !BCC_EOS
13266                                           ! 2485       break;
13267 3994           E9         009C            br 	.328
13268                                           !BCC_EOS
13269                                           ! 2486     case 0x02:
13270                                           ! 2487       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt)) = (18);
13271                       00003997            .32C:
13272                                           ! Debug: eq int = const $12 to unsigned short = [+$26E] (used reg = )
13273 3997           B8                   0012  mov	ax,*$12
13274 399A           A3         026E            mov	[$26E],ax
13275                                           !BCC_EOS
13276                                           ! 2488       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders)) = (80);
13277                                           ! Debug: eq int = const $50 to unsigned short = [+$26C] (used reg = )
13278 399D           B8                   0050  mov	ax,*$50
13279 39A0           A3         026C            mov	[$26C],ax
13280                                           !BCC_EOS
13281                                           ! 2489       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads)) = (2);
13282                                           ! Debug: eq int = const 2 to unsigned short = [+$26A] (used reg = )
13283 39A3           B8                   0002  mov	ax,*2
13284 39A6           A3         026A            mov	[$26A],ax
13285                                           !BCC_EOS
13286                                           ! 2490       break;
13287 39A9           E9         0087            br 	.328
13288                                           !BCC_EOS
13289                                           ! 2491     case 0x03:
13290                                           ! 2492       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt)) = (36);
13291                       000039AC            .32D:
13292                                           ! Debug: eq int = const $24 to unsigned short = [+$26E] (used reg = )
13293 39AC           B8                   0024  mov	ax,*$24
13294 39AF           A3         026E            mov	[$26E],ax
13295                                           !BCC_EOS
13296                                           ! 2493      
13297                                           ! 2493  *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders)) = (80);
13298                                           ! Debug: eq int = const $50 to unsigned short = [+$26C] (used reg = )
13299 39B2           B8                   0050  mov	ax,*$50
13300 39B5           A3         026C            mov	[$26C],ax
13301                                           !BCC_EOS
13302                                           ! 2494       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads)) = (2);
13303                                           ! Debug: eq int = const 2 to unsigned short = [+$26A] (used reg = )
13304 39B8           B8                   0002  mov	ax,*2
13305 39BB           A3         026A            mov	[$26A],ax
13306                                           !BCC_EOS
13307                                           ! 2495       break;
13308 39BE           EB           73            jmp .328
13309                                           !BCC_EOS
13310                                           ! 2496     case 0x04:
13311                                           ! 2497       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt)) = (_read_byte(446+6, boot_segment)&0x3f);
13312                       000039C0            .32E:
13313                                           ! Debug: list unsigned short boot_segment = [S+$820-$818] (used reg = )
13314 39C0           FFB6       F7EA            push	-$816[bp]
13315                                           ! Debug: list int = const $1C4 (used reg = )
13316 39C4           B8                   01C4  mov	ax,#$1C4
13317 39C7           50                         push	ax
13318                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
13319 39C8           E8         CC19            call	__read_byte
13320 39CB           83C4                   04  add	sp,*4
13321                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
13322 39CE           24                     3F  and	al,*$3F
13323                                           ! Debug: eq unsigned char = al+0 to unsigned short = [+$26E] (used reg = )
13324 39D0           30E4                       xor	ah,ah
13325 39D2           A3         026E            mov	[$26E],ax
13326                                           !BCC_EOS
13327                                           ! 2498       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders)) = ((_read_byte(446+6, boot_segment)<<2) + _read_byte(446+7, boot_segment) + 1);
13328                                           ! Debug: list unsigned short boot_segment = [S+$820-$818] (used reg = )
13329 39D5           FFB6       F7EA            push	-$816[bp]
13330                                           ! Debug: list int = const $1C5 (used reg = )
13331 39D9           B8                   01C5  mov	ax,#$1C5
13332 39DC           50                         push	ax
13333                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
13334 39DD           E8         CC04            call	__read_byte
13335 39E0           83C4                   04  add	sp,*4
13336 39E3           50                         push	ax
13337                                           ! Debug: list unsigned short boot_segment = [S+$822-$818] (used reg = )
13338 39E4           FFB6       F7EA            push	-$816[bp]
13339                                           ! Debug: list int = const $1C4 (used reg = )
13340 39E8           B8                   01C4  mov	ax,#$1C4
13341 39EB           50                         push	ax
13342                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
13343 39EC           E8         CBF5            call	__read_byte
13344 39EF           83C4                   04  add	sp,*4
13345                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
13346 39F2           30E4                       xor	ah,ah
13347 39F4           D1E0                       shl	ax,*1
13348 39F6           D1E0                       shl	ax,*1
13349                                           ! Debug: add unsigned char (temp) = [S+$822-$822] to unsigned int = ax+0 (used reg = )
13350 39F8           0286       F7E0            add	al,0+..FFF9[bp]
13351 39FC           80D4                   00  adc	ah,*0
13352 39FF           44                         inc	sp
13353 3A00           44                         inc	sp
13354                                           ! Debug: add int = const 1 to unsigned int = ax+0 (used reg = )
13355                                           ! Debug: eq unsigned int = ax+1 to unsigned short = [+$26C] (used reg = )
13356 3A01           40                         inc	ax
13357 3A02           A3         026C            mov	[$26C],ax
13358                                           !BCC_EOS
13359                                           ! 2499       *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads)) = (_read_byte(446+5, boot_segment) + 1);
13360                                           ! Debug: list unsigned short boot_segment = [S+$820-$818] (used reg = )
13361 3A05           FFB6       F7EA            push	-$816[bp]
13362                                           ! Debug: list int = const $1C3 (used reg = )
13363 3A09           B8                   01C3  mov	ax,#$1C3
13364 3A0C           50                         push	ax
13365                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
13366 3A0D           E8         CBD4            call	__read_byte
13367 3A10           83C4                   04  add	sp,*4
13368                                           ! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
13369 3A13           30E4                       xor	ah,ah
13370                                           ! Debug: eq unsigned int = ax+1 to unsigned short = [+$26A] (used reg = )
13371 3A15           40                         inc	ax
13372 3A16           A3         026A            mov	[$26A],ax
13373                                           !BCC_EOS
13374                                           ! 2500       break;
13375 3A19           EB           18            jmp .328
13376                                           !BCC_EOS
13377                                           ! 2501    }
13378                                           ! 2502   if(*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.media))!=0) {
13379 3A1B           EB           16            jmp .328
13380                       00003A1D            .32A:
13381 3A1D           2C                     01  sub	al,*1
13382 3A1F         0F84         FF5F            beq 	.32B
13383 3A23           2C                     01  sub	al,*1
13384 3A25         0F84         FF6E            beq 	.32C
13385 3A29           2C                     01  sub	al,*1
13386 3A2B         0F84         FF7D            beq 	.32D
13387 3A2F           2C                     01  sub	al,*1
13388 3A31           74           8D            je 	.32E
13389                       00003A33            .328:
13390                       FFFFF7E0            ..FFF9	=	-$820
13391                                           ! Debug: ne int = const 0 to unsigned char = [+$25B] (used reg = )
13392 3A33           A0         025B            mov	al,[$25B]
13393 3A36           84C0                       test	al,al
13394 3A38           74           33            je  	.32F
13395                       00003A3A            .330:
13396                                           ! 2503     if(*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive))==0x00)
13397                                           ! Debug: logeq int = const 0 to unsigned char = [+$25C] (used reg = )
13398 3A3A           A0         025C            mov	al,[$25C]
13399 3A3D           84C0                       test	al,al
13400 3A3F           75           23            jne 	.331
13401                       00003A41            .332:
13402                                           ! 2504       _write_byte(_read_byte(0x10, 0x40)|0x41, 0x10, 0x40);
13403                                           ! Debug: list int = const $40 (used reg = )
13404 3A41           B8                   0040  mov	ax,*$40
13405 3A44           50                         push	ax
13406                                           ! Debug: list int = const $10 (used reg = )
13407 3A45           B8                   0010  mov	ax,*$10
13408 3A48           50                         push	ax
13409                                           ! Debug: list int = const $40 (used reg = )
13410 3A49           B8                   0040  mov	ax,*$40
13411 3A4C           50                         push	ax
13412                                           ! Debug: list int = const $10 (used reg = )
13413 3A4D           B8                   0010  mov	ax,*$10
13414 3A50           50                         push	ax
13415                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
13416 3A51           E8         CB90            call	__read_byte
13417 3A54           83C4                   04  add	sp,*4
13418                                           ! Debug: or int = const $41 to unsigned char = al+0 (used reg = )
13419 3A57           0C                     41  or	al,*$41
13420                                           ! Debug: list unsigned char = al+0 (used reg = )
13421 3A59           30E4                       xor	ah,ah
13422 3A5B           50                         push	ax
13423                                           ! Debug: func () void = _write_byte+0 (used reg = )
13424 3A5C           E8         CBA1            call	__write_byte
13425 3A5F           83C4                   06  add	sp,*6
13426                                           !BCC_EOS
13427                                           ! 2505     else
13428                                           ! 2506       *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdcount)) = (*((Bit8u *)(&((ebda_data_t *) 0)->ata.hdcount)) + 1);
13429 3A62           EB           09            jmp .333
13430                       00003A64            .331:
13431                                           ! Debug: add int = const 1 to unsigned char = [+$232] (used reg = )
13432 3A64           A0         0232            mov	al,[$232]
13433 3A67           30E4                       xor	ah,ah
13434                                           ! Debug: eq unsigned int = ax+1 to unsigned char = [+$232] (used reg = )
13435 3A69           40                         inc	ax
13436 3A6A           A2         0232            mov	[$232],al
13437                                           !BCC_EOS
13438                                           ! 2507   }
13439                       00003A6D            .333:
13440                                           ! 2508   if(*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.media))!=0)
13441                       00003A6D            .32F:
13442                                           ! Debug: ne int = const 0 to unsigned char = [+$25B] (used reg = )
13443 3A6D           A0         025B            mov	al,[$25B]
13444 3A70           84C0                       test	al,al
13445 3A72           74           05            je  	.334
13446                       00003A74            .335:
13447                                           ! 2509     *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.active)) = (0x01);
13448                                           ! Debug: eq int = const 1 to unsigned char = [+$25A] (used reg = )
13449 3A74           B0                     01  mov	al,*1
13450 3A76           A2         025A            mov	[$25A],al
13451                                           !BCC_EOS
13452                                           ! 2510   i = (*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive))*0x100)+0;
13453                       00003A79            .334:
13454                                           ! Debug: mul int = const $100 to unsigned char = [+$25C] (used reg = )
13455 3A79           A0         025C            mov	al,[$25C]
13456 3A7C           30E4                       xor	ah,ah
13457 3A7E           B9                   0100  mov	cx,#$100
13458 3A81           F7E9                       imul	cx
13459                                           ! Debug: add int = const 0 to unsigned int = ax+0 (used reg = )
13460                                           ! Debug: eq unsigned int = ax+0 to unsigned short i = [S+$820-$81C] (used reg = )
13461 3A83           8986       F7E6            mov	-$81A[bp],ax
13462                                           !BCC_EOS
13463                                           ! 2511   set_DS(old_ds);
13464                                           ! Debug: list unsigned short old_ds = [S+$820-6] (used reg = )
13465 3A87           FF76         FC            push	-4[bp]
13466                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
13467 3A8A           E8         CBD5            call	_set_DS
13468 3A8D           44                         inc	sp
13469 3A8E           44                         inc	sp
13470                                           !BCC_EOS
13471                                           ! 2512   return i;
13472 3A8F           8B86       F7E6            mov	ax,-$81A[bp]
13473 3A93           89EC                       mov	sp,bp
13474 3A95           5D                         pop	bp
13475 3A96           C3                         ret
13476                                           !BCC_EOS
13477                                           ! 2513 }
13478                                           ! 2514 void int14_function(regs, ds, iret_addr)
13479                                           ! Register BX used in function cdrom_boot
13480                                           ! 2515   pusha_regs_t regs;
13481                                           export	_int14_function
13482                       00003A97            _int14_function:
13483                                           !BCC_EOS
13484                                           ! 2516   Bit16u ds;
13485                                           !BCC_EOS
13486                                           ! 2517   iret_addr_t iret_addr;
13487                                           !BCC_EOS
13488                                           ! 2518 {
13489                                           ! 2519   Bit16u addr,timer,val16;
13490                                           !BCC_EOS
13491                                           ! 2520   Bit8u counter;
13492                                           !BCC_EOS
13493                                           ! 2521 #asm
13494 3A97           55                         push	bp
13495 3A98           89E5                       mov	bp,sp
13496 3A9A           83C4                   F8  add	sp,*-8
13497                                           !BCC_EOS
13498                                           !BCC_ASM
13499                       0000001C            _int14_function.ds	set	$1C
13500                       00000014            .int14_function.ds	set	$14
13501                       00000001            _int14_function.counter	set	1
13502                       FFFFFFF9            .int14_function.counter	set	-7
13503                       00000004            _int14_function.timer	set	4
13504                       FFFFFFFC            .int14_function.timer	set	-4
13505                       0000001E            _int14_function.iret_addr	set	$1E
13506                       00000016            .int14_function.iret_addr	set	$16
13507                       00000006            _int14_function.addr	set	6
13508                       FFFFFFFE            .int14_function.addr	set	-2
13509                       00000002            _int14_function.val16	set	2
13510                       FFFFFFFA            .int14_function.val16	set	-6
13511                       0000000C            _int14_function.regs	set	$C
13512                       00000004            .int14_function.regs	set	4
13513 3A9D           FB                           sti
13514                                           ! 2523 endasm
13515                                           !BCC_ENDASM
13516                                           !BCC_EOS
13517                                           ! 2524   addr = *((Bit16u *)(0x400 + (regs.u.r16.dx << 1)));
13518                                           ! Debug: sl int = const 1 to unsigned short regs = [S+$A+$C] (used reg = )
13519 3A9E           8B46         0E            mov	ax,$E[bp]
13520 3AA1           D1E0                       shl	ax,*1
13521                                           ! Debug: add unsigned int = ax+0 to int = const $400 (used reg = )
13522                                           ! Debug: expression subtree swapping
13523                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$400 (used reg = )
13524 3AA3           89C3                       mov	bx,ax
13525                                           ! Debug: eq unsigned short = [bx+$400] to unsigned short addr = [S+$A-4] (used reg = )
13526 3AA5           8B9F       0400            mov	bx,$400[bx]
13527 3AA9           895E         FE            mov	-2[bp],bx
13528                                           !BCC_EOS
13529                                           ! 2525   counter = *((Bit8u *)(0x047C + regs.u.r16.dx));
13530                                           ! Debug: add unsigned short regs = [S+$A+$C] to int = const $47C (used reg = )
13531                                           ! Debug: expression subtree swapping
13532 3AAC           8B46         0E            mov	ax,$E[bp]
13533                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$47C (used reg = )
13534 3AAF           89C3                       mov	bx,ax
13535                                           ! Debug: eq unsigned char = [bx+$47C] to unsigned char counter = [S+$A-9] (used reg = )
13536 3AB1           8A87       047C            mov	al,$47C[bx]
13537 3AB5           8846         F9            mov	-7[bp],al
13538                                           !BCC_EOS
13539                                           ! 2526   if ((regs.u.r16.dx < 4) && (addr > 0)) {
13540                                           ! Debug: lt int = const 4 to unsigned short regs = [S+$A+$C] (used reg = )
13541 3AB8           8B46         0E            mov	ax,$E[bp]
13542 3ABB           3D                   0004  cmp	ax,*4
13543 3ABE         0F83         01F6            bhis	.336
13544                       00003AC2            .338:
13545                                           ! Debug: gt int = const 0 to unsigned short addr = [S+$A-4] (used reg = )
13546 3AC2           8B46         FE            mov	ax,-2[bp]
13547 3AC5           85C0                       test	ax,ax
13548 3AC7         0F84         01ED            beq 	.336
13549                       00003ACB            .337:
13550                                           ! 2527     switch (regs.u.r8.ah) {
13551 3ACB           8A46         13            mov	al,$13[bp]
13552 3ACE           E9         01CD            br 	.33B
13553                                           ! 2528       case 0:
13554                                           ! 2529         outb(addr+3, inb(addr+3) | 0x80);
13555                       00003AD1            .33C:
13556                                           ! Debug: add int = const 3 to unsigned short addr = [S+$A-4] (used reg = )
13557 3AD1           8B46         FE            mov	ax,-2[bp]
13558                                           ! Debug: list unsigned int = ax+3 (used reg = )
13559 3AD4           05                   0003  add	ax,*3
13560 3AD7           50                         push	ax
13561                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13562 3AD8           E8         CA1D            call	_inb
13563 3ADB           44                         inc	sp
13564 3ADC           44                         inc	sp
13565                                           ! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
13566 3ADD           0C                     80  or	al,#$80
13567                                           ! Debug: list unsigned char = al+0 (used reg = )
13568 3ADF           30E4                       xor	ah,ah
13569 3AE1           50                         push	ax
13570                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
13571 3AE2           8B46         FE            mov	ax,-2[bp]
13572                                           ! Debug: list unsigned int = ax+3 (used reg = )
13573 3AE5           05                   0003  add	ax,*3
13574 3AE8           50                         push	ax
13575                                           ! Debug: func () void = outb+0 (used reg = )
13576 3AE9           E8         CA22            call	_outb
13577 3AEC           83C4                   04  add	sp,*4
13578                                           !BCC_EOS
13579                                           ! 2530         if (regs.u.r8.al & 0xE0 == 0) {
13580                                           ! Debug: and int = const 0 to unsigned char regs = [S+$A+$10] (used reg = )
13581 3AEF           8A46         12            mov	al,$12[bp]
13582 3AF2           30C0                       xor	al,al
13583 3AF4           84C0                       test	al,al
13584 3AF6           74           1E            je  	.33D
13585                       00003AF8            .33E:
13586                                           ! 2531           outb(addr, 0x17);
13587                                           ! Debug: list int = const $17 (used reg = )
13588 3AF8           B8                   0017  mov	ax,*$17
13589 3AFB           50                         push	ax
13590                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
13591 3AFC           FF76         FE            push	-2[bp]
13592                                           ! Debug: func () void = outb+0 (used reg = )
13593 3AFF           E8         CA0C            call	_outb
13594 3B02           83C4                   04  add	sp,*4
13595                                           !BCC_EOS
13596                                           ! 2532           outb(addr+1, 0x04);
13597                                           ! Debug: list int = const 4 (used reg = )
13598 3B05           B8                   0004  mov	ax,*4
13599 3B08           50                         push	ax
13600                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
13601 3B09           8B46         FE            mov	ax,-2[bp]
13602                                           ! Debug: list unsigned int = ax+1 (used reg = )
13603 3B0C           40                         inc	ax
13604 3B0D           50                         push	ax
13605                                           ! Debug: func () void = outb+0 (used reg = )
13606 3B0E           E8         C9FD            call	_outb
13607 3B11           83C4                   04  add	sp,*4
13608                                           !BCC_EOS
13609                                           ! 2533         } else {
13610 3B14           EB           37            jmp .33F
13611                       00003B16            .33D:
13612                                           ! 2534           val16 = 0x600 >> ((regs.u.r8.al & 0xE0) >> 5);
13613                                           ! Debug: and int = const $E0 to unsigned char regs = [S+$A+$10] (used reg = )
13614 3B16           8A46         12            mov	al,$12[bp]
13615 3B19           24                     E0  and	al,#$E0
13616                                           ! Debug: sr int = const 5 to unsigned char = al+0 (used reg = )
13617 3B1B           30E4                       xor	ah,ah
13618 3B1D           B1                     05  mov	cl,*5
13619 3B1F           D3E8                       shr	ax,cl
13620                                           ! Debug: sr unsigned int = ax+0 to int = const $600 (used reg = )
13621 3B21           89C3                       mov	bx,ax
13622 3B23           B8                   0600  mov	ax,#$600
13623 3B26           89D9                       mov	cx,bx
13624 3B28           D3F8                       sar	ax,cl
13625                                           ! Debug: eq int = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
13626 3B2A           8946         FA            mov	-6[bp],ax
13627                                           !BCC_EOS
13628                                           ! 2535           outb(addr, val16 & 0xFF);
13629                                           ! Debug: and int = const $FF to unsigned short val16 = [S+$A-8] (used reg = )
13630 3B2D           8A46         FA            mov	al,-6[bp]
13631                                           ! Debug: list unsigned char = al+0 (used reg = )
13632 3B30           30E4                       xor	ah,ah
13633 3B32           50                         push	ax
13634                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
13635 3B33           FF76         FE            push	-2[bp]
13636                                           ! Debug: func () void = outb+0 (used reg = )
13637 3B36           E8         C9D5            call	_outb
13638 3B39           83C4                   04  add	sp,*4
13639                                           !BCC_EOS
13640                                           ! 2536           outb(addr+1, *(((Bit8u *)&val16)+1));
13641                                           ! Debug: list unsigned char val16 = [S+$A-7] (used reg = )
13642 3B3C           8A46         FB            mov	al,-5[bp]
13643 3B3F           30E4                       xor	ah,ah
13644 3B41           50                         push	ax
13645                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
13646 3B42           8B46         FE            mov	ax,-2[bp]
13647                                           ! Debug: list unsigned int = ax+1 (used reg = )
13648 3B45           40                         inc	ax
13649 3B46           50                         push	ax
13650                                           ! Debug: func () void = outb+0 (used reg = )
13651 3B47           E8         C9C4            call	_outb
13652 3B4A           83C4                   04  add	sp,*4
13653                                           !BCC_EOS
13654                                           ! 2537         }
13655                                           ! 2538         outb(addr+3, regs.u.r8.al & 0x1F);
13656                       00003B4D            .33F:
13657                                           ! Debug: and int = const $1F to unsigned char regs = [S+$A+$10] (used reg = )
13658 3B4D           8A46         12            mov	al,$12[bp]
13659 3B50           24                     1F  and	al,*$1F
13660                                           ! Debug: list unsigned char = al+0 (used reg = )
13661 3B52           30E4                       xor	ah,ah
13662 3B54           50                         push	ax
13663                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
13664 3B55           8B46         FE            mov	ax,-2[bp]
13665                                           ! Debug: list unsigned int = ax+3 (used reg = )
13666 3B58           05                   0003  add	ax,*3
13667 3B5B           50                         push	ax
13668                                           ! Debug: func () void = outb+0 (used reg = )
13669 3B5C           E8         C9AF            call	_outb
13670 3B5F           83C4                   04  add	sp,*4
13671                                           !BCC_EOS
13672                                           ! 2539         regs.u.r8.ah = inb(addr+5);
13673                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13674 3B62           8B46         FE            mov	ax,-2[bp]
13675                                           ! Debug: list unsigned int = ax+5 (used reg = )
13676 3B65           05                   0005  add	ax,*5
13677 3B68           50                         push	ax
13678                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13679 3B69           E8         C98C            call	_inb
13680 3B6C           44                         inc	sp
13681 3B6D           44                         inc	sp
13682                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
13683 3B6E           8846         13            mov	$13[bp],al
13684                                           !BCC_EOS
13685                                           ! 2540         regs.u.r8.al = inb(addr+6);
13686                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
13687 3B71           8B46         FE            mov	ax,-2[bp]
13688                                           ! Debug: list unsigned int = ax+6 (used reg = )
13689 3B74           05                   0006  add	ax,*6
13690 3B77           50                         push	ax
13691                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13692 3B78           E8         C97D            call	_inb
13693 3B7B           44                         inc	sp
13694 3B7C           44                         inc	sp
13695                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
13696 3B7D           8846         12            mov	$12[bp],al
13697                                           !BCC_EOS
13698                                           ! 2541         iret_addr.flags.u.r8.flagsl &= 0xfe;
13699                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
13700 3B80           8A46         1A            mov	al,$1A[bp]
13701 3B83           24                     FE  and	al,#$FE
13702 3B85           8846         1A            mov	$1A[bp],al
13703                                           !BCC_EOS
13704                                           ! 2542         break;
13705 3B88           E9         012B            br 	.339
13706                                           !BCC_EOS
13707                                           ! 2543       case 1:
13708                                           ! 2544         timer = *((Bit16u *)(0x046C));
13709                       00003B8B            .340:
13710                                           ! Debug: eq unsigned short = [+$46C] to unsigned short timer = [S+$A-6] (used reg = )
13711 3B8B           A1         046C            mov	ax,[$46C]
13712 3B8E           8946         FC            mov	-4[bp],ax
13713                                           !BCC_EOS
13714                                           ! 2545         while (((inb(addr+5) & 0x60) != 0x60) && (counter)) {
13715 3B91           EB           1B            jmp .342
13716                       00003B93            .343:
13717                                           ! 2546           val16 
13718                                           ! 2546 = *((Bit16u *)(0x046C));
13719                                           ! Debug: eq unsigned short = [+$46C] to unsigned short val16 = [S+$A-8] (used reg = )
13720 3B93           A1         046C            mov	ax,[$46C]
13721 3B96           8946         FA            mov	-6[bp],ax
13722                                           !BCC_EOS
13723                                           ! 2547           if (val16 != timer) {
13724                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
13725 3B99           8B46         FA            mov	ax,-6[bp]
13726 3B9C           3B46         FC            cmp	ax,-4[bp]
13727 3B9F           74           0D            je  	.344
13728                       00003BA1            .345:
13729                                           ! 2548             timer = val16;
13730                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
13731 3BA1           8B46         FA            mov	ax,-6[bp]
13732 3BA4           8946         FC            mov	-4[bp],ax
13733                                           !BCC_EOS
13734                                           ! 2549             counter--;
13735                                           ! Debug: postdec unsigned char counter = [S+$A-9] (used reg = )
13736 3BA7           8A46         F9            mov	al,-7[bp]
13737 3BAA           48                         dec	ax
13738 3BAB           8846         F9            mov	-7[bp],al
13739                                           !BCC_EOS
13740                                           ! 2550           }
13741                                           ! 2551         }
13742                       00003BAE            .344:
13743                                           ! 2552         if (counter > 0) {
13744                       00003BAE            .342:
13745                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13746 3BAE           8B46         FE            mov	ax,-2[bp]
13747                                           ! Debug: list unsigned int = ax+5 (used reg = )
13748 3BB1           05                   0005  add	ax,*5
13749 3BB4           50                         push	ax
13750                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13751 3BB5           E8         C940            call	_inb
13752 3BB8           44                         inc	sp
13753 3BB9           44                         inc	sp
13754                                           ! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
13755 3BBA           24                     60  and	al,*$60
13756                                           ! Debug: ne int = const $60 to unsigned char = al+0 (used reg = )
13757 3BBC           3C                     60  cmp	al,*$60
13758 3BBE           74           07            je  	.346
13759                       00003BC0            .347:
13760 3BC0           8A46         F9            mov	al,-7[bp]
13761 3BC3           84C0                       test	al,al
13762 3BC5           75           CC            jne	.343
13763                       00003BC7            .346:
13764                       00003BC7            .341:
13765                                           ! Debug: gt int = const 0 to unsigned char counter = [S+$A-9] (used reg = )
13766 3BC7           8A46         F9            mov	al,-7[bp]
13767 3BCA           84C0                       test	al,al
13768 3BCC           74           20            je  	.348
13769                       00003BCE            .349:
13770                                           ! 2553           outb(addr, regs.u.r8.al);
13771                                           ! Debug: list unsigned char regs = [S+$A+$10] (used reg = )
13772 3BCE           8A46         12            mov	al,$12[bp]
13773 3BD1           30E4                       xor	ah,ah
13774 3BD3           50                         push	ax
13775                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
13776 3BD4           FF76         FE            push	-2[bp]
13777                                           ! Debug: func () void = outb+0 (used reg = )
13778 3BD7           E8         C934            call	_outb
13779 3BDA           83C4                   04  add	sp,*4
13780                                           !BCC_EOS
13781                                           ! 2554           regs.u.r8.ah = inb(addr+5);
13782                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13783 3BDD           8B46         FE            mov	ax,-2[bp]
13784                                           ! Debug: list unsigned int = ax+5 (used reg = )
13785 3BE0           05                   0005  add	ax,*5
13786 3BE3           50                         push	ax
13787                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13788 3BE4           E8         C911            call	_inb
13789 3BE7           44                         inc	sp
13790 3BE8           44                         inc	sp
13791                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
13792 3BE9           8846         13            mov	$13[bp],al
13793                                           !BCC_EOS
13794                                           ! 2555         } else {
13795 3BEC           EB           05            jmp .34A
13796                       00003BEE            .348:
13797                                           ! 2556           regs.u.r8.ah = 0x80;
13798                                           ! Debug: eq int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
13799 3BEE           B0                     80  mov	al,#$80
13800 3BF0           8846         13            mov	$13[bp],al
13801                                           !BCC_EOS
13802                                           ! 2557         }
13803                                           ! 2558         iret_addr.flags.u.r8.flagsl &= 0xfe;
13804                       00003BF3            .34A:
13805                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
13806 3BF3           8A46         1A            mov	al,$1A[bp]
13807 3BF6           24                     FE  and	al,#$FE
13808 3BF8           8846         1A            mov	$1A[bp],al
13809                                           !BCC_EOS
13810                                           ! 2559         break;
13811 3BFB           E9         00B8            br 	.339
13812                                           !BCC_EOS
13813                                           ! 2560       case 2:
13814                                           ! 2561         timer = *((Bit16u *)(0x046C));
13815                       00003BFE            .34B:
13816                                           ! Debug: eq unsigned short = [+$46C] to unsigned short timer = [S+$A-6] (used reg = )
13817 3BFE           A1         046C            mov	ax,[$46C]
13818 3C01           8946         FC            mov	-4[bp],ax
13819                                           !BCC_EOS
13820                                           ! 2562         while (((inb(addr+5) & 0x01) == 0) && (counter)) {
13821 3C04           EB           1B            jmp .34D
13822                       00003C06            .34E:
13823                                           ! 2563           val16 = *((Bit16u *)(0x046C));
13824                                           ! Debug: eq unsigned short = [+$46C] to unsigned short val16 = [S+$A-8] (used reg = )
13825 3C06           A1         046C            mov	ax,[$46C]
13826 3C09           8946         FA            mov	-6[bp],ax
13827                                           !BCC_EOS
13828                                           ! 2564           if (val16 != timer) {
13829                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
13830 3C0C           8B46         FA            mov	ax,-6[bp]
13831 3C0F           3B46         FC            cmp	ax,-4[bp]
13832 3C12           74           0D            je  	.34F
13833                       00003C14            .350:
13834                                           ! 2565             timer = val16;
13835                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
13836 3C14           8B46         FA            mov	ax,-6[bp]
13837 3C17           8946         FC            mov	-4[bp],ax
13838                                           !BCC_EOS
13839                                           ! 2566             counter--;
13840                                           ! Debug: postdec unsigned char counter = [S+$A-9] (used reg = )
13841 3C1A           8A46         F9            mov	al,-7[bp]
13842 3C1D           48                         dec	ax
13843 3C1E           8846         F9            mov	-7[bp],al
13844                                           !BCC_EOS
13845                                           ! 2567           }
13846                                           ! 2568         }
13847                       00003C21            .34F:
13848                                           ! 2569         if (counter > 0) {
13849                       00003C21            .34D:
13850                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13851 3C21           8B46         FE            mov	ax,-2[bp]
13852                                           ! Debug: list unsigned int = ax+5 (used reg = )
13853 3C24           05                   0005  add	ax,*5
13854 3C27           50                         push	ax
13855                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13856 3C28           E8         C8CD            call	_inb
13857 3C2B           44                         inc	sp
13858 3C2C           44                         inc	sp
13859                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
13860 3C2D           24                     01  and	al,*1
13861                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
13862 3C2F           84C0                       test	al,al
13863 3C31           75           07            jne 	.351
13864                       00003C33            .352:
13865 3C33           8A46         F9            mov	al,-7[bp]
13866 3C36           84C0                       test	al,al
13867 3C38           75           CC            jne	.34E
13868                       00003C3A            .351:
13869                       00003C3A            .34C:
13870                                           ! Debug: gt int = const 0 to unsigned char counter = [S+$A-9] (used reg = )
13871 3C3A           8A46         F9            mov	al,-7[bp]
13872 3C3D           84C0                       test	al,al
13873 3C3F           74           1C            je  	.353
13874                       00003C41            .354:
13875                                           ! 2570           regs.u.r8.ah = inb(addr+5);
13876                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13877 3C41           8B46         FE            mov	ax,-2[bp]
13878                                           ! Debug: list unsigned int = ax+5 (used reg = )
13879 3C44           05                   0005  add	ax,*5
13880 3C47           50                         push	ax
13881                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13882 3C48           E8         C8AD            call	_inb
13883 3C4B           44                         inc	sp
13884 3C4C           44                         inc	sp
13885                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
13886 3C4D           8846         13            mov	$13[bp],al
13887                                           !BCC_EOS
13888                                           ! 2571           regs.u.r8.al = inb(addr);
13889                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
13890 3C50           FF76         FE            push	-2[bp]
13891                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13892 3C53           E8         C8A2            call	_inb
13893 3C56           44                         inc	sp
13894 3C57           44                         inc	sp
13895                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
13896 3C58           8846         12            mov	$12[bp],al
13897                                           !BCC_EOS
13898                                           ! 2572         } else {
13899 3C5B           EB           05            jmp .355
13900                       00003C5D            .353:
13901                                           ! 2573           regs.u.r8.ah = 0x80;
13902                                           ! Debug: eq int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
13903 3C5D           B0                     80  mov	al,#$80
13904 3C5F           8846         13            mov	$13[bp],al
13905                                           !BCC_EOS
13906                                           ! 2574         }
13907                                           ! 2575         iret_addr.flags.u.r8.flagsl &= 0xfe;
13908                       00003C62            .355:
13909                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
13910 3C62           8A46         1A            mov	al,$1A[bp]
13911 3C65           24                     FE  and	al,#$FE
13912 3C67           8846         1A            mov	$1A[bp],al
13913                                           !BCC_EOS
13914                                           ! 2576         break;
13915 3C6A           EB           4A            jmp .339
13916                                           !BCC_EOS
13917                                           ! 2577       case 3:
13918                                           ! 2578         regs.u.r8.ah = inb(addr+5);
13919                       00003C6C            .356:
13920                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
13921 3C6C           8B46         FE            mov	ax,-2[bp]
13922                                           ! Debug: list unsigned int = ax+5 (used reg = )
13923 3C6F           05                   0005  add	ax,*5
13924 3C72           50                         push	ax
13925                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13926 3C73           E8         C882            call	_inb
13927 3C76           44                         inc	sp
13928 3C77           44                         inc	sp
13929                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
13930 3C78           8846         13            mov	$13[bp],al
13931                                           !BCC_EOS
13932                                           ! 2579         regs.u.r8.al = inb(addr+6);
13933                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
13934 3C7B           8B46         FE            mov	ax,-2[bp]
13935                                           ! Debug: list unsigned int = ax+6 (used reg = )
13936 3C7E           05                   0006  add	ax,*6
13937 3C81           50                         push	ax
13938                                           ! Debug: func () unsigned char = inb+0 (used reg = )
13939 3C82           E8         C873            call	_inb
13940 3C85           44                         inc	sp
13941 3C86           44                         inc	sp
13942                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
13943 3C87           8846         12            mov	$12[bp],al
13944                                           !BCC_EOS
13945                                           ! 2580         iret_addr.flags.u.r8.flagsl &= 0xfe;
13946                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
13947 3C8A           8A46         1A            mov	al,$1A[bp]
13948 3C8D           24                     FE  and	al,#$FE
13949 3C8F           8846         1A            mov	$1A[bp],al
13950                                           !BCC_EOS
13951                                           ! 2581         break;
13952 3C92           EB           22            jmp .339
13953                                           !BCC_EOS
13954                                           ! 2582       default:
13955                                           ! 2583         iret_addr.flags.u.r8.flagsl |= 0x01;
13956                       00003C94            .357:
13957                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
13958 3C94           8A46         1A            mov	al,$1A[bp]
13959 3C97           0C                     01  or	al,*1
13960 3C99           8846         1A            mov	$1A[bp],al
13961                                           !BCC_EOS
13962                                           ! 2584       }
13963                                           ! 2585   } else {
13964 3C9C           EB           18            jmp .339
13965                       00003C9E            .33B:
13966 3C9E           2C                     00  sub	al,*0
13967 3CA0         0F84         FE2D            beq 	.33C
13968 3CA4           2C                     01  sub	al,*1
13969 3CA6         0F84         FEE1            beq 	.340
13970 3CAA           2C                     01  sub	al,*1
13971 3CAC         0F84         FF4E            beq 	.34B
13972 3CB0           2C                     01  sub	al,*1
13973 3CB2           74           B8            je 	.356
13974 3CB4           EB           DE            jmp	.357
13975                       00003CB6            .339:
13976                       FFFFFFF6            ..FFF8	=	-$A
13977 3CB6           EB           08            jmp .358
13978                       00003CB8            .336:
13979                                           ! 2586     iret_addr.flags.u.r8.flagsl |= 0x01;
13980                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
13981 3CB8           8A46         1A            mov	al,$1A[bp]
13982 3CBB           0C                     01  or	al,*1
13983 3CBD           8846         1A            mov	$1A[bp],al
13984                                           !BCC_EOS
13985                                           ! 2587   }
13986                                           ! 2588 }
13987                       00003CC0            .358:
13988 3CC0           89EC                       mov	sp,bp
13989 3CC2           5D                         pop	bp
13990 3CC3           C3                         ret
13991                                           ! 2589   void
13992                                           ! Register BX used in function int14_function
13993                                           ! 2590 int15_function(regs, ES, DS, FLAGS)
13994                                           ! 2591   pusha_regs_t regs;
13995                                           export	_int15_function
13996                       00003CC4            _int15_function:
13997                                           !BCC_EOS
13998                                           ! 2592   Bit16u ES, DS, FLAGS;
13999                                           !BCC_EOS
14000                                           ! 2593 {
14001                                           ! 2594   Bit16u ebda_seg=get_ebda_seg();
14002 3CC4           55                         push	bp
14003 3CC5           89E5                       mov	bp,sp
14004 3CC7           4C                         dec	sp
14005 3CC8           4C                         dec	sp
14006                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
14007 3CC9           E8         C9A0            call	_get_ebda_seg
14008                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
14009 3CCC           8946         FE            mov	-2[bp],ax
14010                                           !BCC_EOS
14011                                           ! 2595   bx_bool prev_a20_enable;
14012                                           !BCC_EOS
14013                                           ! 2596   Bit16u base15_00;
14014                                           !BCC_EOS
14015                                           ! 2597   Bit8u base23_16;
14016                                           !BCC_EOS
14017                                           ! 2598   Bit16u ss;
14018                                           !BCC_EOS
14019                                           ! 2599   Bit16u BX,CX,DX;
14020                                           !BCC_EOS
14021                                           ! 2600   Bit16u bRegister;
14022                                           !BCC_EOS
14023                                           ! 2601   Bit8u irqDisable;
14024                                           !BCC_EOS
14025                                           ! 2602 ;
14026 3CCF           83C4                   EE  add	sp,*-$12
14027                                           !BCC_EOS
14028                                           ! 2603   switch (regs.u.r8.ah) {
14029 3CD2           8A46         13            mov	al,$13[bp]
14030 3CD5           E9         0488            br 	.35B
14031                                           ! 2604     case 0x24:
14032                                           ! 2605       switch (regs.u.r8.al) {
14033                       00003CD8            .35C:
14034 3CD8           8A46         12            mov	al,$12[bp]
14035 3CDB           E9         0074            br 	.35F
14036                                           ! 2606         case 0x00:
14037                                           ! 2607         case 0x01:
14038                       00003CDE            .360:
14039                                           ! 2608           set_enable_a20(regs.u.r8.al);
14040                       00003CDE            .361:
14041                                           ! Debug: list unsigned char regs = [S+$16+$10] (used reg = )
14042 3CDE           8A46         12            mov	al,$12[bp]
14043 3CE1           30E4                       xor	ah,ah
14044 3CE3           50                         push	ax
14045                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
14046 3CE4           E8         DA4F            call	_set_enable_a20
14047 3CE7           44                         inc	sp
14048 3CE8           44                         inc	sp
14049                                           !BCC_EOS
14050                                           ! 2609           FLAGS &= 0xfffe;
14051                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14052 3CE9           8B46         18            mov	ax,$18[bp]
14053 3CEC           24                     FE  and	al,#$FE
14054 3CEE           8946         18            mov	$18[bp],ax
14055                                           !BCC_EOS
14056                                           ! 2610           regs.u.r8.ah = 0;
14057                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
14058 3CF1           30C0                       xor	al,al
14059 3CF3           8846         13            mov	$13[bp],al
14060                                           !BCC_EOS
14061                                           ! 2611           break;
14062 3CF6           E9         006B            br 	.35D
14063                                           !BCC_EOS
14064                                           ! 2612         case 0x02:
14065                                           ! 2613           regs.u.r8.al = (inb(0x0092) >> 1) & 0x01;
14066                       00003CF9            .362:
14067                                           ! Debug: list int = const $92 (used reg = )
14068 3CF9           B8                   0092  mov	ax,#$92
14069 3CFC           50                         push	ax
14070                                           ! Debug: func () unsigned char = inb+0 (used reg = )
14071 3CFD           E8         C7F8            call	_inb
14072 3D00           44                         inc	sp
14073 3D01           44                         inc	sp
14074                                           ! Debug: sr int = const 1 to unsigned char = al+0 (used reg = )
14075 3D02           30E4                       xor	ah,ah
14076 3D04           D1E8                       shr	ax,*1
14077                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
14078 3D06           24                     01  and	al,*1
14079                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$16+$10] (used reg = )
14080 3D08           8846         12            mov	$12[bp],al
14081                                           !BCC_EOS
14082                                           ! 2614           FLAGS &= 0xfffe;
14083                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14084 3D0B           8B46         18            mov	ax,$18[bp]
14085 3D0E           24                     FE  and	al,#$FE
14086 3D10           8946         18            mov	$18[bp],ax
14087                                           !BCC_EOS
14088                                           ! 2615           regs.u.r8.ah = 0;
14089                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
14090 3D13           30C0                       xor	al,al
14091 3D15           8846         13            mov	$13[bp],al
14092                                           !BCC_EOS
14093                                           ! 2616           break;
14094 3D18           EB           4A            jmp .35D
14095                                           !BCC_EOS
14096                                           ! 2617         case 0x03:
14097                                           ! 2618           FLAGS &= 0xfffe;
14098                       00003D1A            .363:
14099                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14100 3D1A           8B46         18            mov	ax,$18[bp]
14101 3D1D           24                     FE  and	al,#$FE
14102 3D1F           8946         18            mov	$18[bp],ax
14103                                           !BCC_EOS
14104                                           ! 2619           regs.u.r8.ah = 0;
14105                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
14106 3D22           30C0                       xor	al,al
14107 3D24           8846         13            mov	$13[bp],al
14108                                           !BCC_EOS
14109                                           ! 2620           regs.u.r16.bx = 3;
14110                                           ! Debug: eq int = const 3 to unsigned short regs = [S+$16+$A] (used reg = )
14111 3D27           B8                   0003  mov	ax,*3
14112 3D2A           8946         0C            mov	$C[bp],ax
14113                                           !BCC_EOS
14114                                           ! 2621           break;
14115 3D2D           EB           35            jmp .35D
14116                                           !BCC_EOS
14117                                           ! 2622         default:
14118                                           ! 2623           bios_printf(4, "int15: Func 24h, subfunc %02xh, A20 gate control not supported\n", (unsigned) regs.u.r8.al);
14119                       00003D2F            .364:
14120                                           ! Debug: list unsigned char regs = [S+$16+$10] (used reg = )
14121 3D2F           8A46         12            mov	al,$12[bp]
14122 3D32           30E4                       xor	ah,ah
14123 3D34           50                         push	ax
14124                                           ! Debug: list * char = .365+0 (used reg = )
14125 3D35           BB                   D576  mov	bx,#.365
14126 3D38           53                         push	bx
14127                                           ! Debug: list int = const 4 (used reg = )
14128 3D39           B8                   0004  mov	ax,*4
14129 3D3C           50                         push	ax
14130                                           ! Debug: func () void = bios_printf+0 (used reg = )
14131 3D3D           E8         CBFE            call	_bios_printf
14132 3D40           83C4                   06  add	sp,*6
14133                                           !BCC_EOS
14134                                           ! 2624           FLAGS |= 0x0001;
14135                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
14136 3D43           8B46         18            mov	ax,$18[bp]
14137 3D46           0C                     01  or	al,*1
14138 3D48           8946         18            mov	$18[bp],ax
14139                                           !BCC_EOS
14140                                           ! 2625           regs.u.r8.ah = 0x86;
14141                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
14142 3D4B           B0                     86  mov	al,#$86
14143 3D4D           8846         13            mov	$13[bp],al
14144                                           !BCC_EOS
14145                                           ! 2626       }
14146                                           ! 2627   
14147                                           ! 2627     break;
14148 3D50           EB           12            jmp .35D
14149                       00003D52            .35F:
14150 3D52           2C                     00  sub	al,*0
14151 3D54           74           88            je 	.360
14152 3D56           2C                     01  sub	al,*1
14153 3D58           74           84            je 	.361
14154 3D5A           2C                     01  sub	al,*1
14155 3D5C           74           9B            je 	.362
14156 3D5E           2C                     01  sub	al,*1
14157 3D60           74           B8            je 	.363
14158 3D62           EB           CB            jmp	.364
14159                       00003D64            .35D:
14160 3D64           E9         0443            br 	.359
14161                                           !BCC_EOS
14162                                           ! 2628     case 0x41:
14163                                           ! 2629       FLAGS |= 0x0001;
14164                       00003D67            .366:
14165                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
14166 3D67           8B46         18            mov	ax,$18[bp]
14167 3D6A           0C                     01  or	al,*1
14168 3D6C           8946         18            mov	$18[bp],ax
14169                                           !BCC_EOS
14170                                           ! 2630       regs.u.r8.ah = 0x86;
14171                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
14172 3D6F           B0                     86  mov	al,#$86
14173 3D71           8846         13            mov	$13[bp],al
14174                                           !BCC_EOS
14175                                           ! 2631       break;
14176 3D74           E9         0433            br 	.359
14177                                           !BCC_EOS
14178                                           ! 2632     case 0x4f:
14179                                           ! 2633       FLAGS |= 0x0001;
14180                       00003D77            .367:
14181                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
14182 3D77           8B46         18            mov	ax,$18[bp]
14183 3D7A           0C                     01  or	al,*1
14184 3D7C           8946         18            mov	$18[bp],ax
14185                                           !BCC_EOS
14186                                           ! 2634       break;
14187 3D7F           E9         0428            br 	.359
14188                                           !BCC_EOS
14189                                           ! 2635     case 0x52:
14190                                           ! 2636       FLAGS &= 0xfffe;
14191                       00003D82            .368:
14192                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14193 3D82           8B46         18            mov	ax,$18[bp]
14194 3D85           24                     FE  and	al,#$FE
14195 3D87           8946         18            mov	$18[bp],ax
14196                                           !BCC_EOS
14197                                           ! 2637       regs.u.r8.ah = 0;
14198                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
14199 3D8A           30C0                       xor	al,al
14200 3D8C           8846         13            mov	$13[bp],al
14201                                           !BCC_EOS
14202                                           ! 2638       break;
14203 3D8F           E9         0418            br 	.359
14204                                           !BCC_EOS
14205                                           ! 2639     case 0x83: {
14206                       00003D92            .369:
14207                                           ! 2640       set_DS(0x40);
14208                                           ! Debug: list int = const $40 (used reg = )
14209 3D92           B8                   0040  mov	ax,*$40
14210 3D95           50                         push	ax
14211                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
14212 3D96           E8         C8C9            call	_set_DS
14213 3D99           44                         inc	sp
14214 3D9A           44                         inc	sp
14215                                           !BCC_EOS
14216                                           ! 2641       if( regs.u.r8.al == 0 ) {
14217                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+$16+$10] (used reg = )
14218 3D9B           8A46         12            mov	al,$12[bp]
14219 3D9E           84C0                       test	al,al
14220 3DA0         0F85         007D            bne 	.36A
14221                       00003DA4            .36B:
14222                                           ! 2642         if( ( *((Bit8u *)(0xA0)) & 1 ) == 0 ) {
14223                                           ! Debug: and int = const 1 to unsigned char = [+$A0] (used reg = )
14224 3DA4           A0         00A0            mov	al,[$A0]
14225 3DA7           24                     01  and	al,*1
14226                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
14227 3DA9           84C0                       test	al,al
14228 3DAB         0F85         0063            bne 	.36C
14229                       00003DAF            .36D:
14230                                           ! 2643           *((Bit8u *)(0xA0)) = (1);
14231                                           ! Debug: eq int = const 1 to unsigned char = [+$A0] (used reg = )
14232 3DAF           B0                     01  mov	al,*1
14233 3DB1           A2         00A0            mov	[$A0],al
14234                                           !BCC_EOS
14235                                           ! 2644           *((Bit16u *)(0x98)) = (ES);
14236                                           ! Debug: eq unsigned short ES = [S+$16+$12] to unsigned short = [+$98] (used reg = )
14237 3DB4           8B46         14            mov	ax,$14[bp]
14238 3DB7           A3         0098            mov	[$98],ax
14239                                           !BCC_EOS
14240                                           ! 2645           *((Bit16u *)(0x9A)) = (regs.u.r16.bx);
14241                                           ! Debug: eq unsigned short regs = [S+$16+$A] to unsigned short = [+$9A] (used reg = )
14242 3DBA           8B46         0C            mov	ax,$C[bp]
14243 3DBD           A3         009A            mov	[$9A],ax
14244                                           !BCC_EOS
14245                                           ! 2646           *((Bit16u *)(0x9C)) = (regs.u.r16.dx);
14246                                           ! Debug: eq unsigned short regs = [S+$16+$C] to unsigned short = [+$9C] (used reg = )
14247 3DC0           8B46         0E            mov	ax,$E[bp]
14248 3DC3           A3         009C            mov	[$9C],ax
14249                                           !BCC_EOS
14250                                           ! 2647           *((Bit16u *)(0x9E)) = (regs.u.r16.cx);
14251                                           ! Debug: eq unsigned short regs = [S+$16+$E] to unsigned short = [+$9E] (used reg = )
14252 3DC6           8B46         10            mov	ax,$10[bp]
14253 3DC9           A3         009E            mov	[$9E],ax
14254                                           !BCC_EOS
14255                                           ! 2648           FLAGS &= 0xfffe;
14256                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14257 3DCC           8B46         18            mov	ax,$18[bp]
14258 3DCF           24                     FE  and	al,#$FE
14259 3DD1           8946         18            mov	$18[bp],ax
14260                                           !BCC_EOS
14261                                           ! 2649           irqDisable = inb( 0x00a1 );
14262                                           ! Debug: list int = const $A1 (used reg = )
14263 3DD4           B8                   00A1  mov	ax,#$A1
14264 3DD7           50                         push	ax
14265                                           ! Debug: func () unsigned char = inb+0 (used reg = )
14266 3DD8           E8         C71D            call	_inb
14267 3DDB           44                         inc	sp
14268 3DDC           44                         inc	sp
14269                                           ! Debug: eq unsigned char = al+0 to unsigned char irqDisable = [S+$16-$15] (used reg = )
14270 3DDD           8846         ED            mov	-$13[bp],al
14271                                           !BCC_EOS
14272                                           ! 2650           outb( 0x00a1, irqDisable & 0xFE );
14273                                           ! Debug: and int = const $FE to unsigned char irqDisable = [S+$16-$15] (used reg = )
14274 3DE0           8A46         ED            mov	al,-$13[bp]
14275 3DE3           24                     FE  and	al,#$FE
14276                                           ! Debug: list unsigned char = al+0 (used reg = )
14277 3DE5           30E4                       xor	ah,ah
14278 3DE7           50                         push	ax
14279                                           ! Debug: list int = const $A1 (used reg = )
14280 3DE8           B8                   00A1  mov	ax,#$A1
14281 3DEB           50                         push	ax
14282                                           ! Debug: func () void = outb+0 (used reg = )
14283 3DEC           E8         C71F            call	_outb
14284 3DEF           83C4                   04  add	sp,*4
14285                                           !BCC_EOS
14286                                           ! 2651           bRegister = inb_cmos( 0xB );
14287                                           ! Debug: list int = const $B (used reg = )
14288 3DF2           B8                   000B  mov	ax,*$B
14289 3DF5           50                         push	ax
14290                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
14291 3DF6           E8         C744            call	_inb_cmos
14292 3DF9           44                         inc	sp
14293 3DFA           44                         inc	sp
14294                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$16-$14] (used reg = )
14295 3DFB           30E4                       xor	ah,ah
14296 3DFD           8946         EE            mov	-$12[bp],ax
14297                                           !BCC_EOS
14298                                           ! 2652           outb_cmos( 0xB, bRegister | 0x40 );
14299                                           ! Debug: or int = const $40 to unsigned short bRegister = [S+$16-$14] (used reg = )
14300 3E00           8B46         EE            mov	ax,-$12[bp]
14301 3E03           0C                     40  or	al,*$40
14302                                           ! Debug: list unsigned int = ax+0 (used reg = )
14303 3E05           50                         push	ax
14304                                           ! Debug: list int = const $B (used reg = )
14305 3E06           B8                   000B  mov	ax,*$B
14306 3E09           50                         push	ax
14307                                           ! Debug: func () void = outb_cmos+0 (used reg = )
14308 3E0A           E8         C721            call	_outb_cmos
14309 3E0D           83C4                   04  add	sp,*4
14310                                           !BCC_EOS
14311                                           ! 2653         } else {
14312 3E10           EB           0D            jmp .36E
14313                       00003E12            .36C:
14314                                           ! 2654           ;
14315                                           !BCC_EOS
14316                                           ! 2655           FLAGS |= 0x0001;
14317                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
14318 3E12           8B46         18            mov	ax,$18[bp]
14319 3E15           0C                     01  or	al,*1
14320 3E17           8946         18            mov	$18[bp],ax
14321                                           !BCC_EOS
14322                                           ! 2656           regs.u.r8.ah = 0x86;
14323                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
14324 3E1A           B0                     86  mov	al,#$86
14325 3E1C           8846         13            mov	$13[bp],al
14326                                           !BCC_EOS
14327                                           ! 2657         }
14328                                           ! 2658       } else if( regs.u.r8.al == 1 ) {
14329                       00003E1F            .36E:
14330 3E1F           EB           48            jmp .36F
14331                       00003E21            .36A:
14332                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$16+$10] (used reg = )
14333 3E21           8A46         12            mov	al,$12[bp]
14334 3E24           3C                     01  cmp	al,*1
14335 3E26           75           2D            jne 	.370
14336                       00003E28            .371:
14337                                           ! 2659         *((Bit8u *)(0xA0)) = (0);
14338                                           ! Debug: eq int = const 0 to unsigned char = [+$A0] (used reg = )
14339 3E28           30C0                       xor	al,al
14340 3E2A           A2         00A0            mov	[$A0],al
14341                                           !BCC_EOS
14342                                           ! 2660         FLAGS &= 0xfffe;
14343                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14344 3E2D           8B46         18            mov	ax,$18[bp]
14345 3E30           24                     FE  and	al,#$FE
14346 3E32           8946         18            mov	$18[bp],ax
14347                                           !BCC_EOS
14348                                           ! 2661         bRegister = inb_cmos( 0xB );
14349                                           ! Debug: list int = const $B (used reg = )
14350 3E35           B8                   000B  mov	ax,*$B
14351 3E38           50                         push	ax
14352                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
14353 3E39           E8         C701            call	_inb_cmos
14354 3E3C           44                         inc	sp
14355 3E3D           44                         inc	sp
14356                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$16-$14] (used reg = )
14357 3E3E           30E4                       xor	ah,ah
14358 3E40           8946         EE            mov	-$12[bp],ax
14359                                           !BCC_EOS
14360                                           ! 2662         outb_cmos( 0xB, bRegister & ~0x40 );
14361                                           ! Debug: and int = const -$41 to unsigned short bRegister = [S+$16-$14] (used reg = )
14362 3E43           8B46         EE            mov	ax,-$12[bp]
14363 3E46           24                     BF  and	al,#$BF
14364                                           ! Debug: list unsigned int = ax+0 (used reg = )
14365 3E48           50                         push	ax
14366                                           ! Debug: list int = const $B (used reg = )
14367 3E49           B8                   000B  mov	ax,*$B
14368 3E4C           50                         push	ax
14369                                           ! Debug: func () void = outb_cmos+0 (used reg = )
14370 3E4D           E8         C6DE            call	_outb_cmos
14371 3E50           83C4                   04  add	sp,*4
14372                                           !BCC_EOS
14373                                           ! 2663       } else {
14374 3E53           EB           14            jmp .372
14375                       00003E55            .370:
14376                                           ! 2664         ;
14377                                           !BCC_EOS
14378                                           ! 2665         FLAGS |= 0x0001;
14379                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
14380 3E55           8B46         18            mov	ax,$18[bp]
14381 3E58           0C                     01  or	al,*1
14382 3E5A           8946         18            mov	$18[bp],ax
14383                                           !BCC_EOS
14384                                           ! 2666         regs.u.r8.ah = 0x86;
14385                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
14386 3E5D           B0                     86  mov	al,#$86
14387 3E5F           8846         13            mov	$13[bp],al
14388                                           !BCC_EOS
14389                                           ! 2667         regs.u.r8.al--;
14390                                           ! Debug: postdec unsigned char regs = [S+$16+$10] (used reg = )
14391 3E62           8A46         12            mov	al,$12[bp]
14392 3E65           48                         dec	ax
14393 3E66           8846         12            mov	$12[bp],al
14394                                           !BCC_EOS
14395                                           ! 2668       }
14396                                           ! 2669       break;
14397                       00003E69            .372:
14398                       00003E69            .36F:
14399 3E69           E9         033E            br 	.359
14400                                           !BCC_EOS
14401                                           ! 2670     }
14402                                           ! 2671     case 0x87:
14403                                           ! 2672 #asm
14404                       00003E6C            .373:
14405                                           !BCC_EOS
14406                                           !BCC_ASM
14407                       00000006            _int15_function.CX	set	6
14408                       FFFFFFF2            .int15_function.CX	set	-$E
14409                       0000002C            _int15_function.FLAGS	set	$2C
14410                       00000018            .int15_function.FLAGS	set	$18
14411                       00000001            _int15_function.irqDisable	set	1
14412                       FFFFFFED            .int15_function.irqDisable	set	-$13
14413                       0000002A            _int15_function.DS	set	$2A
14414                       00000016            .int15_function.DS	set	$16
14415                       00000004            _int15_function.DX	set	4
14416                       FFFFFFF0            .int15_function.DX	set	-$10
14417                       0000000D            _int15_function.base23_16	set	$D
14418                       FFFFFFF9            .int15_function.base23_16	set	-7
14419                       00000002            _int15_function.bRegister	set	2
14420                       FFFFFFEE            .int15_function.bRegister	set	-$12
14421                       00000028            _int15_function.ES	set	$28
14422                       00000014            .int15_function.ES	set	$14
14423                       00000012            _int15_function.ebda_seg	set	$12
14424                       FFFFFFFE            .int15_function.ebda_seg	set	-2
14425                       0000000E            _int15_function.base15_00	set	$E
14426                       FFFFFFFA            .int15_function.base15_00	set	-6
14427                       0000000A            _int15_function.ss	set	$A
14428                       FFFFFFF6            .int15_function.ss	set	-$A
14429                       00000008            _int15_function.BX	set	8
14430                       FFFFFFF4            .int15_function.BX	set	-$C
14431                       00000018            _int15_function.regs	set	$18
14432                       00000004            .int15_function.regs	set	4
14433                       00000010            _int15_function.prev_a20_enable	set	$10
14434                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
14435 3E6C           FA                           cli
14436                                           ! 2674 endasm
14437                                           !BCC_ENDASM
14438                                           !BCC_EOS
14439                                           ! 2675       prev_a20_enable = set_enable_a20(1);
14440                                           ! Debug: list int = const 1 (used reg = )
14441 3E6D           B8                   0001  mov	ax,*1
14442 3E70           50                         push	ax
14443                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
14444 3E71           E8         D8C2            call	_set_enable_a20
14445 3E74           44                         inc	sp
14446 3E75           44                         inc	sp
14447                                           ! Debug: eq unsigned short = ax+0 to unsigned short prev_a20_enable = [S+$16-6] (used reg = )
14448 3E76           8946         FC            mov	-4[bp],ax
14449                                           !BCC_EOS
14450                                           ! 2676       base15_00 = (ES << 4) + regs.u.r16.si;
14451                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$16+$12] (used reg = )
14452 3E79           8B46         14            mov	ax,$14[bp]
14453 3E7C           B1                     04  mov	cl,*4
14454 3E7E           D3E0                       shl	ax,cl
14455                                           ! Debug: add unsigned short regs = [S+$16+4] to unsigned int = ax+0 (used reg = )
14456 3E80           0346         06            add	ax,6[bp]
14457                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$16-8] (used reg = )
14458 3E83           8946         FA            mov	-6[bp],ax
14459                                           !BCC_EOS
14460                                           ! 2677       base23_16 = ES >> 12;
14461                                           ! Debug: sr int = const $C to unsigned short ES = [S+$16+$12] (used reg = )
14462 3E86           8B46         14            mov	ax,$14[bp]
14463 3E89           88E0                       mov	al,ah
14464 3E8B           30E4                       xor	ah,ah
14465 3E8D           B1                     04  mov	cl,*4
14466 3E8F           D3E8                       shr	ax,cl
14467                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$16-9] (used reg = )
14468 3E91           8846         F9            mov	-7[bp],al
14469                                           !BCC_EOS
14470                                           ! 2678       if (base15_00 < (ES<<4))
14471                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$16+$12] (used reg = )
14472 3E94           8B46         14            mov	ax,$14[bp]
14473 3E97           B1                     04  mov	cl,*4
14474 3E99           D3E0                       shl	ax,cl
14475                                           ! Debug: lt unsigned int = ax+0 to unsigned short base15_00 = [S+$16-8] (used reg = )
14476 3E9B           3B46         FA            cmp	ax,-6[bp]
14477 3E9E           76           07            jbe 	.374
14478                       00003EA0            .375:
14479                                           ! 2679         base23_16++;
14480                                           ! Debug: postinc unsigned char base23_16 = [S+$16-9] (used reg = )
14481 3EA0           8A46         F9            mov	al,-7[bp]
14482 3EA3           40                         inc	ax
14483 3EA4           8846         F9            mov	-7[bp],al
14484                                           !BCC_EOS
14485                                           ! 2680       set_DS(ES);
14486                       00003EA7            .374:
14487                                           ! Debug: list unsigned short ES = [S+$16+$12] (used reg = )
14488 3EA7           FF76         14            push	$14[bp]
14489                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
14490 3EAA           E8         C7B5            call	_set_DS
14491 3EAD           44                         inc	sp
14492 3EAE           44                         inc	sp
14493                                           !BCC_EOS
14494                                           ! 2681       *((Bit16u *)(regs.u.r16.si+0x08+0)) = (47);
14495                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
14496 3EAF           8B46         06            mov	ax,6[bp]
14497                                           ! Debug: add int = const 0 to unsigned int = ax+8 (used reg = )
14498                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+8 (used reg = )
14499 3EB2           89C3                       mov	bx,ax
14500                                           ! Debug: eq int = const $2F to unsigned short = [bx+8] (used reg = )
14501 3EB4           B8                   002F  mov	ax,*$2F
14502 3EB7           8947         08            mov	8[bx],ax
14503                                           !BCC_EOS
14504                                           ! 2682       *((Bit16u *)(regs.u.r16.si+0x08+2)) = (base15_00);
14505                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
14506 3EBA           8B46         06            mov	ax,6[bp]
14507                                           ! Debug: add int = const 2 to unsigned int = ax+8 (used reg = )
14508                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$A (used reg = )
14509 3EBD           89C3                       mov	bx,ax
14510                                           ! Debug: eq unsigned short base15_00 = [S+$16-8] to unsigned short = [bx+$A] (used reg = )
14511 3EBF           8B46         FA            mov	ax,-6[bp]
14512 3EC2           8947         0A            mov	$A[bx],ax
14513                                           !BCC_EOS
14514                                           ! 2683       *((Bit8u *)(regs.u.r16.si+0x08+4)) = (base23_16);
14515                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
14516 3EC5           8B46         06            mov	ax,6[bp]
14517                                           ! Debug: add int = const 4 to unsigned int = ax+8 (used reg = )
14518                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$C (used reg = )
14519 3EC8           89C3                       mov	bx,ax
14520                                           ! Debug: eq unsigned char base23_16 = [S+$16-9] to unsigned char = [bx+$C] (used reg = )
14521 3ECA           8A46         F9            mov	al,-7[bp]
14522 3ECD           8847         0C            mov	$C[bx],al
14523                                           !BCC_EOS
14524                                           ! 2684       *((Bit8u *)(regs.u.r16.si+0x08+5)) = (0x93);
14525                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
14526 3ED0           8B46         06            mov	ax,6[bp]
14527                                           ! Debug: add int = const 5 to unsigned int = ax+8 (used reg = )
14528                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$D (used reg = )
14529 3ED3           89C3                       mov	bx,ax
14530                                           ! Debug: eq int = const $93 to unsigned char = [bx+$D] (used reg = )
14531 3ED5           B0                     93  mov	al,#$93
14532 3ED7           8847         0D            mov	$D[bx],al
14533                                           !BCC_EOS
14534                                           ! 2685       *((Bit16u *)(regs.u.r16.si+0x08+6)) = (0x0000);
14535                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
14536 3EDA           8B46         06            mov	ax,6[bp]
14537                                           ! Debug: add int = const 6 to unsigned int = ax+8 (used reg = )
14538                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$E (used reg = )
14539 3EDD           89C3                       mov	bx,ax
14540                                           ! Debug: eq int = const 0 to unsigned short = [bx+$E] (used reg = )
14541 3EDF           31C0                       xor	ax,ax
14542 3EE1           8947         0E            mov	$E[bx],ax
14543                                           !BCC_EOS
14544                                           ! 2686       *((Bit16u *)(regs.u.r16.si+0x20+0)) = (0xffff);
14545                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
14546 3EE4           8B46         06            mov	ax,6[bp]
14547                                           ! Debug: add int = const 0 to unsigned int = ax+$20 (used reg = )
14548                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$20 (used reg = )
14549 3EE7           89C3                       mov	bx,ax
14550                                           ! Debug: eq unsigned int = const $FFFF to unsigned short = [bx+$20] (used reg = )
14551 3EE9           B8                   FFFF  mov	ax,#$FFFF
14552 3EEC           8947         20            mov	$20[bx],ax
14553                                           !BCC_EOS
14554                                           ! 2687       *((Bit16u *)(regs.u.r16.si+0x20+2)) = (0x0000);
14555                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
14556 3EEF           8B46         06            mov	ax,6[bp]
14557                                           ! Debug: add int = const 2 to unsigned int = ax+$20 (used reg = )
14558                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$22 (used reg = )
14559 3EF2           89C3                       mov	bx,ax
14560                                           ! Debug: eq int = const 0 to unsigned short = [bx+$22] (used reg = )
14561 3EF4           31C0                       xor	ax,ax
14562 3EF6           8947         22            mov	$22[bx],ax
14563                                           !BCC_EOS
14564                                           ! 2688       *((Bit8u *)(regs.u.r16.si+0x20+4)) = (0x000f);
14565                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
14566 3EF9           8B46         06            mov	ax,6[bp]
14567                                           ! Debug: add int = const 4 to unsigned int = ax+$20 (used reg = )
14568                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$24 (used reg = )
14569 3EFC           89C3                       mov	bx,ax
14570                                           ! Debug: eq int = const $F to unsigned char = [bx+$24] (used reg = )
14571 3EFE           B0                     0F  mov	al,*$F
14572 3F00           8847         24            mov	$24[bx],al
14573                                           !BCC_EOS
14574                                           ! 2689       *((Bit8u *)(regs.u.r16.si+0x20+5)) = (0x9b);
14575                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
14576 3F03           8B46         06            mov	ax,6[bp]
14577                                           ! Debug: add int = const 5 to unsigned int = ax+$20 (used reg = )
14578                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$25 (used reg = )
14579 3F06           89C3                       mov	bx,ax
14580                                           ! Debug: eq int = const $9B to unsigned char = [bx+$25] (used reg = )
14581 3F08           B0                     9B  mov	al,#$9B
14582 3F0A           8847         25            mov	$25[bx],al
14583                                           !BCC_EOS
14584                                           ! 2690       *((Bit16u *)(regs.u.r16.si+0x20+6)) = (0x0000);
14585                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
14586 3F0D           8B46         06            mov	ax,6[bp]
14587                                           ! Debug: add int = const 6 to unsigned int = ax+$20 (used reg = )
14588                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$26 (used reg = )
14589 3F10           89C3                       mov	bx,ax
14590                                           ! Debug: eq int = const 0 to unsigned short = [bx+$26] (used reg = )
14591 3F12           31C0                       xor	ax,ax
14592 3F14           8947         26            mov	$26[bx],ax
14593                                           !BCC_EOS
14594                                           ! 2691       ss = get_SS();
14595                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14596 3F17           E8         C745            call	_get_SS
14597                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$C] (used reg = )
14598 3F1A           8946         F6            mov	-$A[bp],ax
14599                                           !BCC_EOS
14600                                           ! 2692       base15_00 = ss << 4;
14601                                           ! Debug: sl int = const 4 to unsigned short ss = [S+$16-$C] (used reg = )
14602 3F1D           8B46         F6            mov	ax,-$A[bp]
14603 3F20           B1                     04  mov	cl,*4
14604 3F22           D3E0                       shl	ax,cl
14605                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$16-8] (used reg = )
14606 3F24           8946         FA            mov	-6[bp],ax
14607                                           !BCC_EOS
14608                                           ! 2693       base23_16 = ss >> 12;
14609                                           ! Debug: sr int = const $C to unsigned short ss = [S+$16-$C] (used reg = )
14610 3F27           8B46         F6            mov	ax,-$A[bp]
14611 3F2A           88E0                       mov	al,ah
14612 3F2C           30E4                       xor	ah,ah
14613 3F2E           B1                     04  mov	cl,*4
14614 3F30           D3E8                       shr	ax,cl
14615                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$16-9] (used reg = )
14616 3F32           8846         F9            mov	-7[bp],al
14617                                           !BCC_EOS
14618                                           ! 2694       *((Bit16u *)(regs.u.r16.si+0x28+0)) = (0xffff);
14619                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
14620 3F35           8B46         06            mov	ax,6[bp]
14621                                           ! Debug: add int = const 0 to unsigned int = ax+$28 (used reg = )
14622                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$28 (used reg = )
14623 3F38           89C3                       mov	bx,ax
14624                                           ! Debug: eq unsigned int = const $FFFF to unsigned short = [bx+$28] (used reg = )
14625 3F3A           B8                   FFFF  mov	ax,#$FFFF
14626 3F3D           8947         28            mov	$28[bx],ax
14627                                           !BCC_EOS
14628                                           ! 2695       *((
14629                                           ! 2695 Bit16u *)(regs.u.r16.si+0x28+2)) = (base15_00);
14630                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
14631 3F40           8B46         06            mov	ax,6[bp]
14632                                           ! Debug: add int = const 2 to unsigned int = ax+$28 (used reg = )
14633                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$2A (used reg = )
14634 3F43           89C3                       mov	bx,ax
14635                                           ! Debug: eq unsigned short base15_00 = [S+$16-8] to unsigned short = [bx+$2A] (used reg = )
14636 3F45           8B46         FA            mov	ax,-6[bp]
14637 3F48           8947         2A            mov	$2A[bx],ax
14638                                           !BCC_EOS
14639                                           ! 2696       *((Bit8u *)(regs.u.r16.si+0x28+4)) = (base23_16);
14640                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
14641 3F4B           8B46         06            mov	ax,6[bp]
14642                                           ! Debug: add int = const 4 to unsigned int = ax+$28 (used reg = )
14643                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2C (used reg = )
14644 3F4E           89C3                       mov	bx,ax
14645                                           ! Debug: eq unsigned char base23_16 = [S+$16-9] to unsigned char = [bx+$2C] (used reg = )
14646 3F50           8A46         F9            mov	al,-7[bp]
14647 3F53           8847         2C            mov	$2C[bx],al
14648                                           !BCC_EOS
14649                                           ! 2697       *((Bit8u *)(regs.u.r16.si+0x28+5)) = (0x93);
14650                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
14651 3F56           8B46         06            mov	ax,6[bp]
14652                                           ! Debug: add int = const 5 to unsigned int = ax+$28 (used reg = )
14653                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2D (used reg = )
14654 3F59           89C3                       mov	bx,ax
14655                                           ! Debug: eq int = const $93 to unsigned char = [bx+$2D] (used reg = )
14656 3F5B           B0                     93  mov	al,#$93
14657 3F5D           8847         2D            mov	$2D[bx],al
14658                                           !BCC_EOS
14659                                           ! 2698       *((Bit16u *)(regs.u.r16.si+0x28+6)) = (0x0000);
14660                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
14661 3F60           8B46         06            mov	ax,6[bp]
14662                                           ! Debug: add int = const 6 to unsigned int = ax+$28 (used reg = )
14663                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$2E (used reg = )
14664 3F63           89C3                       mov	bx,ax
14665                                           ! Debug: eq int = const 0 to unsigned short = [bx+$2E] (used reg = )
14666 3F65           31C0                       xor	ax,ax
14667 3F67           8947         2E            mov	$2E[bx],ax
14668                                           !BCC_EOS
14669                                           ! 2699       CX = regs.u.r16.cx;
14670                                           ! Debug: eq unsigned short regs = [S+$16+$E] to unsigned short CX = [S+$16-$10] (used reg = )
14671 3F6A           8B46         10            mov	ax,$10[bp]
14672 3F6D           8946         F2            mov	-$E[bp],ax
14673                                           !BCC_EOS
14674                                           ! 2700 #asm
14675                                           !BCC_EOS
14676                                           !BCC_ASM
14677                       00000006            _int15_function.CX	set	6
14678                       FFFFFFF2            .int15_function.CX	set	-$E
14679                       0000002C            _int15_function.FLAGS	set	$2C
14680                       00000018            .int15_function.FLAGS	set	$18
14681                       00000001            _int15_function.irqDisable	set	1
14682                       FFFFFFED            .int15_function.irqDisable	set	-$13
14683                       0000002A            _int15_function.DS	set	$2A
14684                       00000016            .int15_function.DS	set	$16
14685                       00000004            _int15_function.DX	set	4
14686                       FFFFFFF0            .int15_function.DX	set	-$10
14687                       0000000D            _int15_function.base23_16	set	$D
14688                       FFFFFFF9            .int15_function.base23_16	set	-7
14689                       00000002            _int15_function.bRegister	set	2
14690                       FFFFFFEE            .int15_function.bRegister	set	-$12
14691                       00000028            _int15_function.ES	set	$28
14692                       00000014            .int15_function.ES	set	$14
14693                       00000012            _int15_function.ebda_seg	set	$12
14694                       FFFFFFFE            .int15_function.ebda_seg	set	-2
14695                       0000000E            _int15_function.base15_00	set	$E
14696                       FFFFFFFA            .int15_function.base15_00	set	-6
14697                       0000000A            _int15_function.ss	set	$A
14698                       FFFFFFF6            .int15_function.ss	set	-$A
14699                       00000008            _int15_function.BX	set	8
14700                       FFFFFFF4            .int15_function.BX	set	-$C
14701                       00000018            _int15_function.regs	set	$18
14702                       00000004            .int15_function.regs	set	4
14703                       00000010            _int15_function.prev_a20_enable	set	$10
14704                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
14705 3F70           89E3                             mov bx, sp
14706 3F72           36                               SEG SS
14707 3F73           8B4F         06                    mov cx, _int15_function.CX [bx]
14708 3F76     66    50                               push eax
14709 3F78     66    31C0                             xor eax, eax
14710 3F7B           8ED8                             mov ds, ax
14711 3F7D           8C16       0469                  mov 0x0469, ss
14712 3F81           8926       0467                  mov 0x0467, sp
14713 3F85           26                               SEG ES
14714 3F86         0F0154         08                    lgdt [si + 0x08]
14715 3F8A           2E                               SEG CS
14716 3F8B         0F011E       F8AB                    lidt [pmode_IDT_info]
14717                                                 ;; perhaps do something with IDT here
14718                                                 ;; set PE bit in CR0
14719 3F90         0F20C0                             mov eax, cr0
14720 3F93           0C                     01        or al, #0x01
14721 3F95         0F22C0                             mov cr0, eax
14722                                                 ;; far jump to flush CPU queue after transition to protected mode
14723                                                 JMP_AP(0x0020, protected_mode)
 +a   3F98                        EA              db 0xea
 +a   3F99                      3F9D              dw  protected_mode
 +a   3F9B                      0020              dw 0x0020
14724                       00003F9D            protected_mode:
14725                                                 ;; GDT points to valid descriptor table, now load SS, DS, ES
14726 3F9D           B8                   0028        mov ax, #0x28 ;; 101 000 = 5th descriptor in table, TI=GDT, RPL=00
14727 3FA0           8ED0                             mov ss, ax
14728 3FA2           B8                   0010        mov ax, #0x10 ;; 010 000 = 2nd descriptor in table, TI=GDT, RPL=00
14729 3FA5           8ED8                             mov ds, ax
14730 3FA7           B8                   0018        mov ax, #0x18 ;; 011 000 = 3rd descriptor in table, TI=GDT, RPL=00
14731 3FAA           8EC0                             mov es, ax
14732 3FAC           31F6                             xor si, si
14733 3FAE           31FF                             xor di, di
14734 3FB0           FC                               cld
14735 3FB1           F3                               rep
14736 3FB2           A5                                 movsw ;; move CX words from DS:SI to ES:DI
14737                                                 ;; make sure DS and ES limits are 64KB
14738 3FB3           B8                   0028        mov ax, #0x28
14739 3FB6           8ED8                             mov ds, ax
14740 3FB8           8EC0                             mov es, ax
14741                                                 ;; reset PG bit in CR0 ???
14742 3FBA         0F20C0                             mov eax, cr0
14743 3FBD           24                     FE        and al, #0xFE
14744 3FBF         0F22C0                             mov cr0, eax
14745                                                 ;; far jump to flush CPU queue after transition to real mode
14746                                                 JMP_AP(0xf000, real_mode)
 +a   3FC2                        EA              db 0xea
 +a   3FC3                      3FC7              dw  real_mode
 +a   3FC5                      F000              dw 0xf000
14747                       00003FC7            real_mode:
14748                                                 ;; restore IDT to normal real-mode defaults
14749 3FC7           2E                               SEG CS
14750 3FC8         0F011E       F8B1                    lidt [rmode_IDT_info]
14751 3FCD           31C0                             xor ax, ax
14752 3FCF           8ED8                             mov ds, ax
14753 3FD1           8E16       0469                  mov ss, 0x0469
14754 3FD5           8B26       0467                  mov sp, 0x0467
14755 3FD9     66    58                               pop eax
14756                                           ! 2752 endasm
14757                                           !BCC_ENDASM
14758                                           !BCC_EOS
14759                                           ! 2753       set_enable_a20(prev_a20_enable);
14760                                           ! Debug: list unsigned short prev_a20_enable = [S+$16-6] (used reg = )
14761 3FDB           FF76         FC            push	-4[bp]
14762                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
14763 3FDE           E8         D755            call	_set_enable_a20
14764 3FE1           44                         inc	sp
14765 3FE2           44                         inc	sp
14766                                           !BCC_EOS
14767                                           ! 2754 #asm
14768                                           !BCC_EOS
14769                                           !BCC_ASM
14770                       00000006            _int15_function.CX	set	6
14771                       FFFFFFF2            .int15_function.CX	set	-$E
14772                       0000002C            _int15_function.FLAGS	set	$2C
14773                       00000018            .int15_function.FLAGS	set	$18
14774                       00000001            _int15_function.irqDisable	set	1
14775                       FFFFFFED            .int15_function.irqDisable	set	-$13
14776                       0000002A            _int15_function.DS	set	$2A
14777                       00000016            .int15_function.DS	set	$16
14778                       00000004            _int15_function.DX	set	4
14779                       FFFFFFF0            .int15_function.DX	set	-$10
14780                       0000000D            _int15_function.base23_16	set	$D
14781                       FFFFFFF9            .int15_function.base23_16	set	-7
14782                       00000002            _int15_function.bRegister	set	2
14783                       FFFFFFEE            .int15_function.bRegister	set	-$12
14784                       00000028            _int15_function.ES	set	$28
14785                       00000014            .int15_function.ES	set	$14
14786                       00000012            _int15_function.ebda_seg	set	$12
14787                       FFFFFFFE            .int15_function.ebda_seg	set	-2
14788                       0000000E            _int15_function.base15_00	set	$E
14789                       FFFFFFFA            .int15_function.base15_00	set	-6
14790                       0000000A            _int15_function.ss	set	$A
14791                       FFFFFFF6            .int15_function.ss	set	-$A
14792                       00000008            _int15_function.BX	set	8
14793                       FFFFFFF4            .int15_function.BX	set	-$C
14794                       00000018            _int15_function.regs	set	$18
14795                       00000004            .int15_function.regs	set	4
14796                       00000010            _int15_function.prev_a20_enable	set	$10
14797                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
14798 3FE3           FB                           sti
14799                                           ! 2756 endasm
14800                                           !BCC_ENDASM
14801                                           !BCC_EOS
14802                                           ! 2757       regs.u.r8.ah = 0;
14803                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
14804 3FE4           30C0                       xor	al,al
14805 3FE6           8846         13            mov	$13[bp],al
14806                                           !BCC_EOS
14807                                           ! 2758       FLAGS &= 0xfffe;
14808                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14809 3FE9           8B46         18            mov	ax,$18[bp]
14810 3FEC           24                     FE  and	al,#$FE
14811 3FEE           8946         18            mov	$18[bp],ax
14812                                           !BCC_EOS
14813                                           ! 2759       break;
14814 3FF1           E9         01B6            br 	.359
14815                                           !BCC_EOS
14816                                           ! 2760     case 0x88:
14817                                           ! 2761       regs.u.r8.al = inb_cmos(0x30);
14818                       00003FF4            .376:
14819                                           ! Debug: list int = const $30 (used reg = )
14820 3FF4           B8                   0030  mov	ax,*$30
14821 3FF7           50                         push	ax
14822                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
14823 3FF8           E8         C542            call	_inb_cmos
14824 3FFB           44                         inc	sp
14825 3FFC           44                         inc	sp
14826                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$16+$10] (used reg = )
14827 3FFD           8846         12            mov	$12[bp],al
14828                                           !BCC_EOS
14829                                           ! 2762       regs.u.r8.ah = inb_cmos(0x31);
14830                                           ! Debug: list int = const $31 (used reg = )
14831 4000           B8                   0031  mov	ax,*$31
14832 4003           50                         push	ax
14833                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
14834 4004           E8         C536            call	_inb_cmos
14835 4007           44                         inc	sp
14836 4008           44                         inc	sp
14837                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$16+$11] (used reg = )
14838 4009           8846         13            mov	$13[bp],al
14839                                           !BCC_EOS
14840                                           ! 2763       if(regs.u.r16.ax > 0xffc0)
14841                                           ! Debug: gt unsigned int = const $FFC0 to unsigned short regs = [S+$16+$10] (used reg = )
14842 400C           8B46         12            mov	ax,$12[bp]
14843 400F           3D                   FFC0  cmp	ax,#$FFC0
14844 4012           76           06            jbe 	.377
14845                       00004014            .378:
14846                                           ! 2764         regs.u.r16.ax = 0xffc0;
14847                                           ! Debug: eq unsigned int = const $FFC0 to unsigned short regs = [S+$16+$10] (used reg = )
14848 4014           B8                   FFC0  mov	ax,#$FFC0
14849 4017           8946         12            mov	$12[bp],ax
14850                                           !BCC_EOS
14851                                           ! 2765       FLAGS &= 0xfffe;
14852                       0000401A            .377:
14853                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
14854 401A           8B46         18            mov	ax,$18[bp]
14855 401D           24                     FE  and	al,#$FE
14856 401F           8946         18            mov	$18[bp],ax
14857                                           !BCC_EOS
14858                                           ! 2766       break;
14859 4022           E9         0185            br 	.359
14860                                           !BCC_EOS
14861                                           ! 2767   case 0x89:
14862                                           ! 2768 #asm
14863                       00004025            .379:
14864                                           !BCC_EOS
14865                                           !BCC_ASM
14866                       00000006            _int15_function.CX	set	6
14867                       FFFFFFF2            .int15_function.CX	set	-$E
14868                       0000002C            _int15_function.FLAGS	set	$2C
14869                       00000018            .int15_function.FLAGS	set	$18
14870                       00000001            _int15_function.irqDisable	set	1
14871                       FFFFFFED            .int15_function.irqDisable	set	-$13
14872                       0000002A            _int15_function.DS	set	$2A
14873                       00000016            .int15_function.DS	set	$16
14874                       00000004            _int15_function.DX	set	4
14875                       FFFFFFF0            .int15_function.DX	set	-$10
14876                       0000000D            _int15_function.base23_16	set	$D
14877                       FFFFFFF9            .int15_function.base23_16	set	-7
14878                       00000002            _int15_function.bRegister	set	2
14879                       FFFFFFEE            .int15_function.bRegister	set	-$12
14880                       00000028            _int15_function.ES	set	$28
14881                       00000014            .int15_function.ES	set	$14
14882                       00000012            _int15_function.ebda_seg	set	$12
14883                       FFFFFFFE            .int15_function.ebda_seg	set	-2
14884                       0000000E            _int15_function.base15_00	set	$E
14885                       FFFFFFFA            .int15_function.base15_00	set	-6
14886                       0000000A            _int15_function.ss	set	$A
14887                       FFFFFFF6            .int15_function.ss	set	-$A
14888                       00000008            _int15_function.BX	set	8
14889                       FFFFFFF4            .int15_function.BX	set	-$C
14890                       00000018            _int15_function.regs	set	$18
14891                       00000004            .int15_function.regs	set	4
14892                       00000010            _int15_function.prev_a20_enable	set	$10
14893                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
14894 4025           FA                           cli
14895                                           ! 2770 endasm
14896                                           !BCC_ENDASM
14897                                           !BCC_EOS
14898                                           ! 2771       set_enable_a20(1);
14899                                           ! Debug: list int = const 1 (used reg = )
14900 4026           B8                   0001  mov	ax,*1
14901 4029           50                         push	ax
14902                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
14903 402A           E8         D709            call	_set_enable_a20
14904 402D           44                         inc	sp
14905 402E           44                         inc	sp
14906                                           !BCC_EOS
14907                                           ! 2772       set_DS(
14908                                           ! 2772 ES);
14909                                           ! Debug: list unsigned short ES = [S+$16+$12] (used reg = )
14910 402F           FF76         14            push	$14[bp]
14911                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
14912 4032           E8         C62D            call	_set_DS
14913 4035           44                         inc	sp
14914 4036           44                         inc	sp
14915                                           !BCC_EOS
14916                                           ! 2773       *((Bit16u *)(regs.u.r16.si+0x38+0)) = (0xffff);
14917                                           ! Debug: add int = const $38 to unsigned short regs = [S+$16+4] (used reg = )
14918 4037           8B46         06            mov	ax,6[bp]
14919                                           ! Debug: add int = const 0 to unsigned int = ax+$38 (used reg = )
14920                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$38 (used reg = )
14921 403A           89C3                       mov	bx,ax
14922                                           ! Debug: eq unsigned int = const $FFFF to unsigned short = [bx+$38] (used reg = )
14923 403C           B8                   FFFF  mov	ax,#$FFFF
14924 403F           8947         38            mov	$38[bx],ax
14925                                           !BCC_EOS
14926                                           ! 2774       *((Bit16u *)(regs.u.r16.si+0x38+2)) = (0x0000);
14927                                           ! Debug: add int = const $38 to unsigned short regs = [S+$16+4] (used reg = )
14928 4042           8B46         06            mov	ax,6[bp]
14929                                           ! Debug: add int = const 2 to unsigned int = ax+$38 (used reg = )
14930                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$3A (used reg = )
14931 4045           89C3                       mov	bx,ax
14932                                           ! Debug: eq int = const 0 to unsigned short = [bx+$3A] (used reg = )
14933 4047           31C0                       xor	ax,ax
14934 4049           8947         3A            mov	$3A[bx],ax
14935                                           !BCC_EOS
14936                                           ! 2775       *((Bit8u *)(regs.u.r16.si+0x38+4)) = (0x000f);
14937                                           ! Debug: add int = const $38 to unsigned short regs = [S+$16+4] (used reg = )
14938 404C           8B46         06            mov	ax,6[bp]
14939                                           ! Debug: add int = const 4 to unsigned int = ax+$38 (used reg = )
14940                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$3C (used reg = )
14941 404F           89C3                       mov	bx,ax
14942                                           ! Debug: eq int = const $F to unsigned char = [bx+$3C] (used reg = )
14943 4051           B0                     0F  mov	al,*$F
14944 4053           8847         3C            mov	$3C[bx],al
14945                                           !BCC_EOS
14946                                           ! 2776       *((Bit8u *)(regs.u.r16.si+0x38+5)) = (0x9b);
14947                                           ! Debug: add int = const $38 to unsigned short regs = [S+$16+4] (used reg = )
14948 4056           8B46         06            mov	ax,6[bp]
14949                                           ! Debug: add int = const 5 to unsigned int = ax+$38 (used reg = )
14950                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$3D (used reg = )
14951 4059           89C3                       mov	bx,ax
14952                                           ! Debug: eq int = const $9B to unsigned char = [bx+$3D] (used reg = )
14953 405B           B0                     9B  mov	al,#$9B
14954 405D           8847         3D            mov	$3D[bx],al
14955                                           !BCC_EOS
14956                                           ! 2777       *((Bit16u *)(regs.u.r16.si+0x38+6)) = (0x0000);
14957                                           ! Debug: add int = const $38 to unsigned short regs = [S+$16+4] (used reg = )
14958 4060           8B46         06            mov	ax,6[bp]
14959                                           ! Debug: add int = const 6 to unsigned int = ax+$38 (used reg = )
14960                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$3E (used reg = )
14961 4063           89C3                       mov	bx,ax
14962                                           ! Debug: eq int = const 0 to unsigned short = [bx+$3E] (used reg = )
14963 4065           31C0                       xor	ax,ax
14964 4067           8947         3E            mov	$3E[bx],ax
14965                                           !BCC_EOS
14966                                           ! 2778       BX = regs.u.r16.bx;
14967                                           ! Debug: eq unsigned short regs = [S+$16+$A] to unsigned short BX = [S+$16-$E] (used reg = )
14968 406A           8B46         0C            mov	ax,$C[bp]
14969 406D           8946         F4            mov	-$C[bp],ax
14970                                           !BCC_EOS
14971                                           ! 2779 #asm
14972                                           !BCC_EOS
14973                                           !BCC_ASM
14974                       00000006            _int15_function.CX	set	6
14975                       FFFFFFF2            .int15_function.CX	set	-$E
14976                       0000002C            _int15_function.FLAGS	set	$2C
14977                       00000018            .int15_function.FLAGS	set	$18
14978                       00000001            _int15_function.irqDisable	set	1
14979                       FFFFFFED            .int15_function.irqDisable	set	-$13
14980                       0000002A            _int15_function.DS	set	$2A
14981                       00000016            .int15_function.DS	set	$16
14982                       00000004            _int15_function.DX	set	4
14983                       FFFFFFF0            .int15_function.DX	set	-$10
14984                       0000000D            _int15_function.base23_16	set	$D
14985                       FFFFFFF9            .int15_function.base23_16	set	-7
14986                       00000002            _int15_function.bRegister	set	2
14987                       FFFFFFEE            .int15_function.bRegister	set	-$12
14988                       00000028            _int15_function.ES	set	$28
14989                       00000014            .int15_function.ES	set	$14
14990                       00000012            _int15_function.ebda_seg	set	$12
14991                       FFFFFFFE            .int15_function.ebda_seg	set	-2
14992                       0000000E            _int15_function.base15_00	set	$E
14993                       FFFFFFFA            .int15_function.base15_00	set	-6
14994                       0000000A            _int15_function.ss	set	$A
14995                       FFFFFFF6            .int15_function.ss	set	-$A
14996                       00000008            _int15_function.BX	set	8
14997                       FFFFFFF4            .int15_function.BX	set	-$C
14998                       00000018            _int15_function.regs	set	$18
14999                       00000004            .int15_function.regs	set	4
15000                       00000010            _int15_function.prev_a20_enable	set	$10
15001                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
15002 4070           89E3                             mov bx, sp
15003 4072           36                               SEG SS
15004 4073           8B5F         08                    mov bx, _int15_function.BX [bx]
15005 4076           B0                     11        mov al, #0x11 ; send initialisation commands
15006 4078           E6                     20        out 0x0020, al
15007 407A           E6                     A0        out 0x00a0, al
15008 407C           88F8                             mov al, bh
15009 407E           E6                     21        out 0x0021, al
15010 4080           88D8                             mov al, bl
15011 4082           E6                     A1        out 0x00a1, al
15012 4084           B0                     04        mov al, #0x04
15013 4086           E6                     21        out 0x0021, al
15014 4088           B0                     02        mov al, #0x02
15015 408A           E6                     A1        out 0x00a1, al
15016 408C           B0                     01        mov al, #0x01
15017 408E           E6                     21        out 0x0021, al
15018 4090           E6                     A1        out 0x00a1, al
15019 4092           B0                     FF        mov al, #0xff ; mask all IRQs, user must re-enable
15020 4094           E6                     21        out 0x0021, al
15021 4096           E6                     A1        out 0x00a1, al
15022 4098           26                               SEG ES
15023 4099         0F0154         08                    lgdt [si + 0x08]
15024 409D           26                               SEG ES
15025 409E         0F015C         10                    lidt [si + 0x10]
15026 40A2         0F20C0                             mov eax, cr0
15027 40A5           0C                     01        or al, #0x01
15028 40A7         0F22C0                             mov cr0, eax
15029                                                 JMP_AP(0x0038, protmode_switch)
 +a   40AA                        EA              db 0xea
 +a   40AB                      40AF              dw  protmode_switch
 +a   40AD                      0038              dw 0x0038
15030                       000040AF            protmode_switch:
15031                                                 ;; GDT points to valid descriptor table, now load SS, DS, ES
15032 40AF           B8                   0028        mov ax, #0x28
15033 40B2           8ED0                             mov ss, ax
15034 40B4           B8                   0018        mov ax, #0x18
15035 40B7           8ED8                             mov ds, ax
15036 40B9           B8                   0020        mov ax, #0x20
15037 40BC           8EC0                             mov es, ax
15038 40BE           89EC                             mov sp,bp
15039 40C0           83C4                   04        add sp,#4 ; skip return address
15040 40C3           61                               popa ; restore regs
15041 40C4           58                               pop ax ; skip saved es
15042 40C5           58                               pop ax ; skip saved ds
15043 40C6           58                               pop ax ; skip saved flags
15044 40C7           59                               pop cx ; get return offset
15045 40C8           58                               pop ax ; skip return segment
15046 40C9           58                               pop ax ; skip flags
15047 40CA           B8                   0030        mov ax, #0x30 ; ah must be 0 on successful exit
15048 40CD           50                               push ax
15049 40CE           51                               push cx ; re-create modified ret address on stack
15050 40CF           CB                               retf
15051                                           ! 2829 endasm
15052                                           !BCC_ENDASM
15053                                           !BCC_EOS
15054                                           ! 2830       break;
15055 40D0           E9         00D7            br 	.359
15056                                           !BCC_EOS
15057                                           ! 2831     case 0xbf:
15058                                           ! 2832       bios_printf(4, "*** int 15h function AH=bf not yet supported!\n");
15059                       000040D3            .37A:
15060                                           ! Debug: list * char = .37B+0 (used reg = )
15061 40D3           BB                   D547  mov	bx,#.37B
15062 40D6           53                         push	bx
15063                                           ! Debug: list int = const 4 (used reg = )
15064 40D7           B8                   0004  mov	ax,*4
15065 40DA           50                         push	ax
15066                                           ! Debug: func () void = bios_printf+0 (used reg = )
15067 40DB           E8         C860            call	_bios_printf
15068 40DE           83C4                   04  add	sp,*4
15069                                           !BCC_EOS
15070                                           ! 2833       FLAGS |= 0x0001;
15071                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
15072 40E1           8B46         18            mov	ax,$18[bp]
15073 40E4           0C                     01  or	al,*1
15074 40E6           8946         18            mov	$18[bp],ax
15075                                           !BCC_EOS
15076                                           ! 2834       regs.u.r8.ah = 0x86;
15077                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
15078 40E9           B0                     86  mov	al,#$86
15079 40EB           8846         13            mov	$13[bp],al
15080                                           !BCC_EOS
15081                                           ! 2835       break;
15082 40EE           E9         00B9            br 	.359
15083                                           !BCC_EOS
15084                                           ! 2836     case 0xC0:
15085                                           ! 2837       FLAGS &= 0xfffe;
15086                       000040F1            .37C:
15087                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
15088 40F1           8B46         18            mov	ax,$18[bp]
15089 40F4           24                     FE  and	al,#$FE
15090 40F6           8946         18            mov	$18[bp],ax
15091                                           !BCC_EOS
15092                                           ! 2838       regs.u.r8.ah = 0;
15093                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
15094 40F9           30C0                       xor	al,al
15095 40FB           8846         13            mov	$13[bp],al
15096                                           !BCC_EOS
15097                                           ! 2839       regs.u.r16.bx = 0xe6f5;
15098                                           ! Debug: eq unsigned int = const $E6F5 to unsigned short regs = [S+$16+$A] (used reg = )
15099 40FE           B8                   E6F5  mov	ax,#$E6F5
15100 4101           8946         0C            mov	$C[bp],ax
15101                                           !BCC_EOS
15102                                           ! 2840       ES = 0xF000;
15103                                           ! Debug: eq unsigned int = const $F000 to unsigned short ES = [S+$16+$12] (used reg = )
15104 4104           B8                   F000  mov	ax,#$F000
15105 4107           8946         14            mov	$14[bp],ax
15106                                           !BCC_EOS
15107                                           ! 2841       break;
15108 410A           E9         009D            br 	.359
15109                                           !BCC_EOS
15110                                           ! 2842     case 0xc1:
15111                                           ! 2843       ES = ebda_seg;
15112                       0000410D            .37D:
15113                                           ! Debug: eq unsigned short ebda_seg = [S+$16-4] to unsigned short ES = [S+$16+$12] (used reg = )
15114 410D           8B46         FE            mov	ax,-2[bp]
15115 4110           8946         14            mov	$14[bp],ax
15116                                           !BCC_EOS
15117                                           ! 2844       FLAGS &= 0xfffe;
15118                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
15119 4113           8B46         18            mov	ax,$18[bp]
15120 4116           24                     FE  and	al,#$FE
15121 4118           8946         18            mov	$18[bp],ax
15122                                           !BCC_EOS
15123                                           ! 2845       break;
15124 411B           E9         008C            br 	.359
15125                                           !BCC_EOS
15126                                           ! 2846     case 0xd8:
15127                                           ! 2847       bios_printf(8, "EISA BIOS not present\n");
15128                       0000411E            .37E:
15129                                           ! Debug: list * char = .37F+0 (used reg = )
15130 411E           BB                   D530  mov	bx,#.37F
15131 4121           53                         push	bx
15132                                           ! Debug: list int = const 8 (used reg = )
15133 4122           B8                   0008  mov	ax,*8
15134 4125           50                         push	ax
15135                                           ! Debug: func () void = bios_printf+0 (used reg = )
15136 4126           E8         C815            call	_bios_printf
15137 4129           83C4                   04  add	sp,*4
15138                                           !BCC_EOS
15139                                           ! 2848       FLAGS |= 0x0001;
15140                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
15141 412C           8B46         18            mov	ax,$18[bp]
15142 412F           0C                     01  or	al,*1
15143 4131           8946         18            mov	$18[bp],ax
15144                                           !BCC_EOS
15145                                           ! 2849       regs.u.r8.ah = 0x86;
15146                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
15147 4134           B0                     86  mov	al,#$86
15148 4136           8846         13            mov	$13[bp],al
15149                                           !BCC_EOS
15150                                           ! 2850       break;
15151 4139           EB           6F            jmp .359
15152                                           !BCC_EOS
15153                                           ! 2851     
15154                                           ! 2851 default:
15155                                           ! 2852       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
15156                       0000413B            .380:
15157                                           ! Debug: list unsigned short regs = [S+$16+$A] (used reg = )
15158 413B           FF76         0C            push	$C[bp]
15159                                           ! Debug: list unsigned short regs = [S+$18+$10] (used reg = )
15160 413E           FF76         12            push	$12[bp]
15161                                           ! Debug: list * char = .381+0 (used reg = )
15162 4141           BB                   D4F6  mov	bx,#.381
15163 4144           53                         push	bx
15164                                           ! Debug: list int = const 4 (used reg = )
15165 4145           B8                   0004  mov	ax,*4
15166 4148           50                         push	ax
15167                                           ! Debug: func () void = bios_printf+0 (used reg = )
15168 4149           E8         C7F2            call	_bios_printf
15169 414C           83C4                   08  add	sp,*8
15170                                           !BCC_EOS
15171                                           ! 2853       FLAGS |= 0x0001;
15172                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
15173 414F           8B46         18            mov	ax,$18[bp]
15174 4152           0C                     01  or	al,*1
15175 4154           8946         18            mov	$18[bp],ax
15176                                           !BCC_EOS
15177                                           ! 2854       regs.u.r8.ah = 0x86;
15178                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
15179 4157           B0                     86  mov	al,#$86
15180 4159           8846         13            mov	$13[bp],al
15181                                           !BCC_EOS
15182                                           ! 2855       break;
15183 415C           EB           4C            jmp .359
15184                                           !BCC_EOS
15185                                           ! 2856     }
15186                                           ! 2857 }
15187 415E           EB           4A            jmp .359
15188                       00004160            .35B:
15189 4160           2C                     24  sub	al,*$24
15190 4162         0F84         FB72            beq 	.35C
15191 4166           2C                     1D  sub	al,*$1D
15192 4168         0F84         FBFB            beq 	.366
15193 416C           2C                     0E  sub	al,*$E
15194 416E         0F84         FC05            beq 	.367
15195 4172           2C                     03  sub	al,*3
15196 4174         0F84         FC0A            beq 	.368
15197 4178           2C                     31  sub	al,*$31
15198 417A         0F84         FC14            beq 	.369
15199 417E           2C                     04  sub	al,*4
15200 4180         0F84         FCE8            beq 	.373
15201 4184           2C                     01  sub	al,*1
15202 4186         0F84         FE6A            beq 	.376
15203 418A           2C                     01  sub	al,*1
15204 418C         0F84         FE95            beq 	.379
15205 4190           2C                     36  sub	al,*$36
15206 4192         0F84         FF3D            beq 	.37A
15207 4196           2C                     01  sub	al,*1
15208 4198         0F84         FF55            beq 	.37C
15209 419C           2C                     01  sub	al,*1
15210 419E         0F84         FF6B            beq 	.37D
15211 41A2           2C                     17  sub	al,*$17
15212 41A4         0F84         FF76            beq 	.37E
15213 41A8           EB           91            jmp	.380
15214                       000041AA            .359:
15215                       FFFFFFEA            ..FFF7	=	-$16
15216 41AA           89EC                       mov	sp,bp
15217 41AC           5D                         pop	bp
15218 41AD           C3                         ret
15219                                           ! 2858   void
15220                                           ! Register BX used in function int15_function
15221                                           ! 2859 int15_function_mouse(regs, ES, DS, FLAGS)
15222                                           ! 2860   pusha_regs_t regs;
15223                                           export	_int15_function_mouse
15224                       000041AE            _int15_function_mouse:
15225                                           !BCC_EOS
15226                                           ! 2861   Bit16u ES, DS, FLAGS;
15227                                           !BCC_EOS
15228                                           ! 2862 {
15229                                           ! 2863   Bit16u ebda_seg=get_ebda_seg();
15230 41AE           55                         push	bp
15231 41AF           89E5                       mov	bp,sp
15232 41B1           4C                         dec	sp
15233 41B2           4C                         dec	sp
15234                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
15235 41B3           E8         C4B6            call	_get_ebda_seg
15236                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
15237 41B6           8946         FE            mov	-2[bp],ax
15238                                           !BCC_EOS
15239                                           ! 2864   Bit8u mouse_flags_1, mouse_flags_2;
15240                                           !BCC_EOS
15241                                           ! 2865   Bit16u mouse_driver_seg;
15242                                           !BCC_EOS
15243                                           ! 2866   Bit16u mouse_driver_offset;
15244                                           !BCC_EOS
15245                                           ! 2867   Bit8u comm_byte, prev_command_byte;
15246                                           !BCC_EOS
15247                                           ! 2868   Bit8u ret, mouse_data1, mouse_data2, mouse_data3;
15248                                           !BCC_EOS
15249                                           ! 2869 ;
15250 41B9           83C4                   F4  add	sp,*-$C
15251                                           !BCC_EOS
15252                                           ! 2870   switch (regs.u.r8.ah) {
15253 41BC           8A46         13            mov	al,$13[bp]
15254 41BF           E9         0664            br 	.384
15255                                           ! 2871     case 0xC2:
15256                                           ! 2872       switch (regs.u.r8.al) {
15257                       000041C2            .385:
15258 41C2           8A46         12            mov	al,$12[bp]
15259 41C5           E9         0612            br 	.388
15260                                           ! 2873         case 0:
15261                                           ! 2874 ;
15262                       000041C8            .389:
15263                                           !BCC_EOS
15264                                           ! 2875           switch (regs.u.r8.bh) {
15265 41C8           8A46         0D            mov	al,$D[bp]
15266 41CB           E9         00E9            br 	.38C
15267                                           ! 2876             case 0:
15268                                           ! 2877 ;
15269                       000041CE            .38D:
15270                                           !BCC_EOS
15271                                           ! 2878               inhibit_mouse_int_and_events();
15272                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
15273 41CE           E8         1011            call	_inhibit_mouse_int_and_events
15274                                           !BCC_EOS
15275                                           ! 2879               ret = send_to_mouse_ctrl(0xF5);
15276                                           ! Debug: list int = const $F5 (used reg = )
15277 41D1           B8                   00F5  mov	ax,#$F5
15278 41D4           50                         push	ax
15279                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15280 41D5           E8         115B            call	_send_to_mouse_ctrl
15281 41D8           44                         inc	sp
15282 41D9           44                         inc	sp
15283                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15284 41DA           8846         F5            mov	-$B[bp],al
15285                                           !BCC_EOS
15286                                           ! 2880               if (ret == 0) {
15287                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15288 41DD           8A46         F5            mov	al,-$B[bp]
15289 41E0           84C0                       test	al,al
15290 41E2           75           2B            jne 	.38E
15291                       000041E4            .38F:
15292                                           ! 2881                 ret = get_mouse_data(&mouse_data1);
15293                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
15294 41E4           8D5E         F4            lea	bx,-$C[bp]
15295 41E7           53                         push	bx
15296                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15297 41E8           E8         1192            call	_get_mouse_data
15298 41EB           44                         inc	sp
15299 41EC           44                         inc	sp
15300                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15301 41ED           8846         F5            mov	-$B[bp],al
15302                                           !BCC_EOS
15303                                           ! 2882                 if ( (ret == 0) || (mouse_data1 == 0xFA) ) {
15304                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15305 41F0           8A46         F5            mov	al,-$B[bp]
15306 41F3           84C0                       test	al,al
15307 41F5           74           07            je  	.391
15308                       000041F7            .392:
15309                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15310 41F7           8A46         F4            mov	al,-$C[bp]
15311 41FA           3C                     FA  cmp	al,#$FA
15312 41FC           75           11            jne 	.390
15313                       000041FE            .391:
15314                                           ! 2883                   FLAGS &= 0xfffe;
15315                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
15316 41FE           8B46         18            mov	ax,$18[bp]
15317 4201           24                     FE  and	al,#$FE
15318 4203           8946         18            mov	$18[bp],ax
15319                                           !BCC_EOS
15320                                           ! 2884                   regs.u.r8.ah = 0;
15321                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
15322 4206           30C0                       xor	al,al
15323 4208           8846         13            mov	$13[bp],al
15324                                           !BCC_EOS
15325                                           ! 2885                   return;
15326 420B           89EC                       mov	sp,bp
15327 420D           5D                         pop	bp
15328 420E           C3                         ret
15329                                           !BCC_EOS
15330                                           ! 2886                 }
15331                                           ! 2887               }
15332                       0000420F            .390:
15333                                           ! 2888               FLAGS |= 0x0001;
15334                       0000420F            .38E:
15335                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15336 420F           8B46         18            mov	ax,$18[bp]
15337 4212           0C                     01  or	al,*1
15338 4214           8946         18            mov	$18[bp],ax
15339                                           !BCC_EOS
15340                                           ! 2889               regs.u.r8.ah = ret;
15341                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
15342 4217           8A46         F5            mov	al,-$B[bp]
15343 421A           8846         13            mov	$13[bp],al
15344                                           !BCC_EOS
15345                                           ! 2890               return;
15346 421D           89EC                       mov	sp,bp
15347 421F           5D                         pop	bp
15348 4220           C3                         ret
15349                                           !BCC_EOS
15350                                           ! 2891               break;
15351 4221           E9         00A1            br 	.38A
15352                                           !BCC_EOS
15353                                           ! 2892             case 1:
15354                                           ! 2893 ;
15355                       00004224            .393:
15356                                           !BCC_EOS
15357                                           ! 2894               mouse_flags_2 = _read_byte(&((ebda_data_t *) 0)->mouse_flag2, ebda_seg);
15358                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
15359 4224           FF76         FE            push	-2[bp]
15360                                           ! Debug: list * unsigned char = const $27 (used reg = )
15361 4227           B8                   0027  mov	ax,*$27
15362 422A           50                         push	ax
15363                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
15364 422B           E8         C3B6            call	__read_byte
15365 422E           83C4                   04  add	sp,*4
15366                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
15367 4231           8846         FC            mov	-4[bp],al
15368                                           !BCC_EOS
15369                                           ! 2895               if ( (mouse_flags_2 & 0x80) == 0 ) {
15370                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
15371 4234           8A46         FC            mov	al,-4[bp]
15372 4237           24                     80  and	al,#$80
15373                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
15374 4239           84C0                       test	al,al
15375 423B           75           11            jne 	.394
15376                       0000423D            .395:
15377                                           ! 2896                 ;
15378                                           !BCC_EOS
15379                                           ! 2897                 FLAGS |= 0x0001;
15380                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15381 423D           8B46         18            mov	ax,$18[bp]
15382 4240           0C                     01  or	al,*1
15383 4242           8946         18            mov	$18[bp],ax
15384                                           !BCC_EOS
15385                                           ! 2898                 regs.u.r8.ah = 5;
15386                                           ! Debug: eq int = const 5 to unsigned char regs = [S+$10+$11] (used reg = )
15387 4245           B0                     05  mov	al,*5
15388 4247           8846         13            mov	$13[bp],al
15389                                           !BCC_EOS
15390                                           ! 2899                 return;
15391 424A           89EC                       mov	sp,bp
15392 424C           5D                         pop	bp
15393 424D           C3                         ret
15394                                           !BCC_EOS
15395                                           ! 2900               }
15396                                           ! 2901               inhibit_mouse_int_and_events();
15397                       0000424E            .394:
15398                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
15399 424E           E8         0F91            call	_inhibit_mouse_int_and_events
15400                                           !BCC_EOS
15401                                           ! 2902               ret = send_to_mouse_ctrl(0xF4);
15402                                           ! Debug: list int = const $F4 (used reg = )
15403 4251           B8                   00F4  mov	ax,#$F4
15404 4254           50                         push	ax
15405                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15406 4255           E8         10DB            call	_send_to_mouse_ctrl
15407 4258           44                         inc	sp
15408 4259           44                         inc	sp
15409                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15410 425A           8846         F5            mov	-$B[bp],al
15411                                           !BCC_EOS
15412                                           ! 2903               if (ret == 0) {
15413                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15414 425D           8A46         F5            mov	al,-$B[bp]
15415 4260           84C0                       test	al,al
15416 4262           75           2E            jne 	.396
15417                       00004264            .397:
15418                                           ! 2904                 ret = get_mouse_data(&mouse_data1);
15419                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
15420 4264           8D5E         F4            lea	bx,-$C[bp]
15421 4267           53                         push	bx
15422                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15423 4268           E8         1112            call	_get_mouse_data
15424 426B           44                         inc	sp
15425 426C           44                         inc	sp
15426                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15427 426D           8846         F5            mov	-$B[bp],al
15428                                           !BCC_EOS
15429                                           ! 2905                 if ( (ret == 0) && (mouse_data1 == 0xFA) ) {
15430                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15431 4270           8A46         F5            mov	al,-$B[bp]
15432 4273           84C0                       test	al,al
15433 4275           75           1B            jne 	.398
15434                       00004277            .39A:
15435                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15436 4277           8A46         F4            mov	al,-$C[bp]
15437 427A           3C                     FA  cmp	al,#$FA
15438 427C           75           14            jne 	.398
15439                       0000427E            .399:
15440                                           ! 2906                   enable_mouse_int_and_events();
15441                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
15442 427E           E8         100E            call	_enable_mouse_int_and_events
15443                                           !BCC_EOS
15444                                           ! 2907                   FLAGS &= 0xfffe;
15445                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
15446 4281           8B46         18            mov	ax,$18[bp]
15447 4284           24                     FE  and	al,#$FE
15448 4286           8946         18            mov	$18[bp],ax
15449                                           !BCC_EOS
15450                                           ! 2908                   regs.u.r8.ah = 0;
15451                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
15452 4289           30C0                       xor	al,al
15453 428B           8846         13            mov	$13[bp],al
15454                                           !BCC_EOS
15455                                           ! 2909                   return;
15456 428E           89EC                       mov	sp,bp
15457 4290           5D                         pop	bp
15458 4291           C3                         ret
15459                                           !BCC_EOS
15460                                           ! 2910                 }
15461                                           ! 2911               }
15462                       00004292            .398:
15463                                           ! 2912               FLAGS |= 0x0001;
15464                       00004292            .396:
15465                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15466 4292           8B46         18            mov	ax,$18[bp]
15467 4295           0C                     01  or	al,*1
15468 4297           8946         18            mov	$18[bp],ax
15469                                           !BCC_EOS
15470                                           ! 2913               regs.u.r8.ah = ret;
15471                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
15472 429A           8A46         F5            mov	al,-$B[bp]
15473 429D           8846         13            mov	$13[bp],al
15474                                           !BCC_EOS
15475                                           ! 2914               return;
15476 42A0           89EC                       mov	sp,bp
15477 42A2           5D                         pop	bp
15478 42A3           C3                         ret
15479                                           !BCC_EOS
15480                                           ! 2915             default:
15481                                           ! 2916               ;
15482                       000042A4            .39B:
15483                                           !BCC_EOS
15484                                           ! 2917               FLAGS |= 0x0001;
15485                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15486 42A4           8B46         18            mov	ax,$18[bp]
15487 42A7           0C                     01  or	al,*1
15488 42A9           8946         18            mov	$18[bp],ax
15489                                           !BCC_EOS
15490                                           ! 2918               regs.u.r8.ah = 1;
15491                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
15492 42AC           B0                     01  mov	al,*1
15493 42AE           8846         13            mov	$13[bp],al
15494                                           !BCC_EOS
15495                                           ! 2919          
15496                                           ! 2919      return;
15497 42B1           89EC                       mov	sp,bp
15498 42B3           5D                         pop	bp
15499 42B4           C3                         ret
15500                                           !BCC_EOS
15501                                           ! 2920           }
15502                                           ! 2921           break;
15503 42B5           EB           0E            jmp .38A
15504                       000042B7            .38C:
15505 42B7           2C                     00  sub	al,*0
15506 42B9         0F84         FF11            beq 	.38D
15507 42BD           2C                     01  sub	al,*1
15508 42BF         0F84         FF61            beq 	.393
15509 42C3           EB           DF            jmp	.39B
15510                       000042C5            .38A:
15511 42C5           E9         0537            br 	.386
15512                                           !BCC_EOS
15513                                           ! 2922         case 1:
15514                                           ! 2923         case 5:
15515                       000042C8            .39C:
15516                                           ! 2924 ;
15517                       000042C8            .39D:
15518                                           !BCC_EOS
15519                                           ! 2925           if (regs.u.r8.al == 5) {
15520                                           ! Debug: logeq int = const 5 to unsigned char regs = [S+$10+$10] (used reg = )
15521 42C8           8A46         12            mov	al,$12[bp]
15522 42CB           3C                     05  cmp	al,*5
15523 42CD         0F85         0070            bne 	.39E
15524                       000042D1            .39F:
15525                                           ! 2926             if ((regs.u.r8.bh != 3) && (regs.u.r8.bh != 4)) {
15526                                           ! Debug: ne int = const 3 to unsigned char regs = [S+$10+$B] (used reg = )
15527 42D1           8A46         0D            mov	al,$D[bp]
15528 42D4           3C                     03  cmp	al,*3
15529 42D6           74           18            je  	.3A0
15530                       000042D8            .3A2:
15531                                           ! Debug: ne int = const 4 to unsigned char regs = [S+$10+$B] (used reg = )
15532 42D8           8A46         0D            mov	al,$D[bp]
15533 42DB           3C                     04  cmp	al,*4
15534 42DD           74           11            je  	.3A0
15535                       000042DF            .3A1:
15536                                           ! 2927               FLAGS |= 0x0001;
15537                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15538 42DF           8B46         18            mov	ax,$18[bp]
15539 42E2           0C                     01  or	al,*1
15540 42E4           8946         18            mov	$18[bp],ax
15541                                           !BCC_EOS
15542                                           ! 2928               regs.u.r8.ah = 0x02;
15543                                           ! Debug: eq int = const 2 to unsigned char regs = [S+$10+$11] (used reg = )
15544 42E7           B0                     02  mov	al,*2
15545 42E9           8846         13            mov	$13[bp],al
15546                                           !BCC_EOS
15547                                           ! 2929               return;
15548 42EC           89EC                       mov	sp,bp
15549 42EE           5D                         pop	bp
15550 42EF           C3                         ret
15551                                           !BCC_EOS
15552                                           ! 2930             }
15553                                           ! 2931             mouse_flags_2 = _read_byte(&((ebda_data_t *) 0)->mouse_flag2, ebda_seg);
15554                       000042F0            .3A0:
15555                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
15556 42F0           FF76         FE            push	-2[bp]
15557                                           ! Debug: list * unsigned char = const $27 (used reg = )
15558 42F3           B8                   0027  mov	ax,*$27
15559 42F6           50                         push	ax
15560                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
15561 42F7           E8         C2EA            call	__read_byte
15562 42FA           83C4                   04  add	sp,*4
15563                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
15564 42FD           8846         FC            mov	-4[bp],al
15565                                           !BCC_EOS
15566                                           ! 2932             mouse_flags_2 = (mouse_flags_2 & 0xF8) | regs.u.r8.bh - 1;
15567                                           ! Debug: sub int = const 1 to unsigned char regs = [S+$10+$B] (used reg = )
15568 4300           8A46         0D            mov	al,$D[bp]
15569 4303           30E4                       xor	ah,ah
15570 4305           48                         dec	ax
15571 4306           50                         push	ax
15572                                           ! Debug: and int = const $F8 to unsigned char mouse_flags_2 = [S+$12-6] (used reg = )
15573 4307           8A46         FC            mov	al,-4[bp]
15574 430A           24                     F8  and	al,#$F8
15575                                           ! Debug: or unsigned int (temp) = [S+$12-$12] to unsigned char = al+0 (used reg = )
15576 430C           30E4                       xor	ah,ah
15577 430E           0B46         F0            or	ax,0+..FFF6[bp]
15578 4311           44                         inc	sp
15579 4312           44                         inc	sp
15580                                           ! Debug: eq unsigned int = ax+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
15581 4313           8846         FC            mov	-4[bp],al
15582                                           !BCC_EOS
15583                                           ! 2933             mouse_flags_1 = 0x00;
15584                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
15585 4316           30C0                       xor	al,al
15586 4318           8846         FD            mov	-3[bp],al
15587                                           !BCC_EOS
15588                                           ! 2934             _write_byte(mouse_flags_1, &((ebda_data_t *) 0)->mouse_flag1, ebda_seg);
15589                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
15590 431B           FF76         FE            push	-2[bp]
15591                                           ! Debug: list * unsigned char = const $26 (used reg = )
15592 431E           B8                   0026  mov	ax,*$26
15593 4321           50                         push	ax
15594                                           ! Debug: list unsigned char mouse_flags_1 = [S+$14-5] (used reg = )
15595 4322           8A46         FD            mov	al,-3[bp]
15596 4325           30E4                       xor	ah,ah
15597 4327           50                         push	ax
15598                                           ! Debug: func () void = _write_byte+0 (used reg = )
15599 4328           E8         C2D5            call	__write_byte
15600 432B           83C4                   06  add	sp,*6
15601                                           !BCC_EOS
15602                                           ! 2935             _write_byte(mouse_flags_2, &((ebda_data_t *) 0)->mouse_flag2, ebda_seg);
15603                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
15604 432E           FF76         FE            push	-2[bp]
15605                                           ! Debug: list * unsigned char = const $27 (used reg = )
15606 4331           B8                   0027  mov	ax,*$27
15607 4334           50                         push	ax
15608                                           ! Debug: list unsigned char mouse_flags_2 = [S+$14-6] (used reg = )
15609 4335           8A46         FC            mov	al,-4[bp]
15610 4338           30E4                       xor	ah,ah
15611 433A           50                         push	ax
15612                                           ! Debug: func () void = _write_byte+0 (used reg = )
15613 433B           E8         C2C2            call	__write_byte
15614 433E           83C4                   06  add	sp,*6
15615                                           !BCC_EOS
15616                                           ! 2936           }
15617                                           ! 2937           inhibit_mouse_int_and_events();
15618                       00004341            .39E:
15619                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
15620 4341           E8         0E9E            call	_inhibit_mouse_int_and_events
15621                                           !BCC_EOS
15622                                           ! 2938           ret = send_to_mouse_ctrl(0xFF);
15623                                           ! Debug: list int = const $FF (used reg = )
15624 4344           B8                   00FF  mov	ax,#$FF
15625 4347           50                         push	ax
15626                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15627 4348           E8         0FE8            call	_send_to_mouse_ctrl
15628 434B           44                         inc	sp
15629 434C           44                         inc	sp
15630                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15631 434D           8846         F5            mov	-$B[bp],al
15632                                           !BCC_EOS
15633                                           ! 2939           if (ret == 0) {
15634                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15635 4350           8A46         F5            mov	al,-$B[bp]
15636 4353           84C0                       test	al,al
15637 4355         0F85         0087            bne 	.3A3
15638                       00004359            .3A4:
15639                                           ! 2940             ret = get_mouse_data(&mouse_data3);
15640                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
15641 4359           8D5E         F2            lea	bx,-$E[bp]
15642 435C           53                         push	bx
15643                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15644 435D           E8         101D            call	_get_mouse_data
15645 4360           44                         inc	sp
15646 4361           44                         inc	sp
15647                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15648 4362           8846         F5            mov	-$B[bp],al
15649                                           !BCC_EOS
15650                                           ! 2941             if (mouse_data3 == 0xfe) {
15651                                           ! Debug: logeq int = const $FE to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
15652 4365           8A46         F2            mov	al,-$E[bp]
15653 4368           3C                     FE  cmp	al,#$FE
15654 436A           75           0C            jne 	.3A5
15655                       0000436C            .3A6:
15656                                           ! 2942               FLAGS |= 0x0001;
15657                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15658 436C           8B46         18            mov	ax,$18[bp]
15659 436F           0C                     01  or	al,*1
15660 4371           8946         18            mov	$18[bp],ax
15661                                           !BCC_EOS
15662                                           ! 2943               return;
15663 4374           89EC                       mov	sp,bp
15664 4376           5D                         pop	bp
15665 4377           C3                         ret
15666                                           !BCC_EOS
15667                                           ! 2944             }
15668                                           ! 2945             if (mouse_data3 != 0xfa)
15669                       00004378            .3A5:
15670                                           ! Debug: ne int = const $FA to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
15671 4378           8A46         F2            mov	al,-$E[bp]
15672 437B           3C                     FA  cmp	al,#$FA
15673 437D           74           14            je  	.3A7
15674                       0000437F            .3A8:
15675                                           ! 2946               bios_printf((2 | 4 | 1), "Mouse reset returned %02x (should be ack)\n", (unsigned)mouse_data3);
15676                                           ! Debug: list unsigned char mouse_data3 = [S+$10-$10] (used reg = )
15677 437F           8A46         F2            mov	al,-$E[bp]
15678 4382           30E4                       xor	ah,ah
15679 4384           50                         push	ax
15680                                           ! Debug: list * char = .3A9+0 (used reg = )
15681 4385           BB                   D4CB  mov	bx,#.3A9
15682 4388           53                         push	bx
15683                                           ! Debug: list int = const 7 (used reg = )
15684 4389           B8                   0007  mov	ax,*7
15685 438C           50                         push	ax
15686                                           ! Debug: func () void = bios_printf+0 (used reg = )
15687 438D           E8         C5AE            call	_bios_printf
15688 4390           83C4                   06  add	sp,*6
15689                                           !BCC_EOS
15690                                           ! 2947             if ( ret == 0 ) {
15691                       00004393            .3A7:
15692                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15693 4393           8A46         F5            mov	al,-$B[bp]
15694 4396           84C0                       test	al,al
15695 4398           75           46            jne 	.3AA
15696                       0000439A            .3AB:
15697                                           ! 2948               ret = get_mouse_data(&mouse_data1);
15698                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
15699 439A           8D5E         F4            lea	bx,-$C[bp]
15700 439D           53                         push	bx
15701                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15702 439E           E8         0FDC            call	_get_mouse_data
15703 43A1           44                         inc	sp
15704 43A2           44                         inc	sp
15705                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15706 43A3           8846         F5            mov	-$B[bp],al
15707                                           !BCC_EOS
15708                                           ! 2949               if ( ret == 0 ) {
15709                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15710 43A6           8A46         F5            mov	al,-$B[bp]
15711 43A9           84C0                       test	al,al
15712 43AB           75           33            jne 	.3AC
15713                       000043AD            .3AD:
15714                                           ! 2950                 ret = get_mouse_data(&mouse_data2);
15715                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
15716 43AD           8D5E         F3            lea	bx,-$D[bp]
15717 43B0           53                         push	bx
15718                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15719 43B1           E8         0FC9            call	_get_mouse_data
15720 43B4           44                         inc	sp
15721 43B5           44                         inc	sp
15722                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15723 43B6           8846         F5            mov	-$B[bp],al
15724                                           !BCC_EOS
15725                                           ! 2951                 if ( ret == 0 ) {
15726                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15727 43B9           8A46         F5            mov	al,-$B[bp]
15728 43BC           84C0                       test	al,al
15729 43BE           75           20            jne 	.3AE
15730                       000043C0            .3AF:
15731                                           ! 2952                   enable_mouse_int_and_events();
15732                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
15733 43C0           E8         0ECC            call	_enable_mouse_int_and_events
15734                                           !BCC_EOS
15735                                           ! 2953                   FLAGS &= 0xfffe;
15736                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
15737 43C3           8B46         18            mov	ax,$18[bp]
15738 43C6           24                     FE  and	al,#$FE
15739 43C8           8946         18            mov	$18[bp],ax
15740                                           !BCC_EOS
15741                                           ! 2954                   regs.u.r8.ah = 0;
15742                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
15743 43CB           30C0                       xor	al,al
15744 43CD           8846         13            mov	$13[bp],al
15745                                           !BCC_EOS
15746                                           ! 2955                   regs.u.r8.bl = mouse_data1;
15747                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
15748 43D0           8A46         F4            mov	al,-$C[bp]
15749 43D3           8846         0C            mov	$C[bp],al
15750                                           !BCC_EOS
15751                                           ! 2956                   regs.u.r8.bh = mouse_data2;
15752                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
15753 43D6           8A46         F3            mov	al,-$D[bp]
15754 43D9           8846         0D            mov	$D[bp],al
15755                                           !BCC_EOS
15756                                           ! 2957                   return;
15757 43DC           89EC                       mov	sp,bp
15758 43DE           5D                         pop	bp
15759 43DF           C3                         ret
15760                                           !BCC_EOS
15761                                           ! 2958                 }
15762                                           ! 2959               }
15763                       000043E0            .3AE:
15764                                           ! 2960             }
15765                       000043E0            .3AC:
15766                                           ! 2961           }
15767                       000043E0            .3AA:
15768                                           ! 2962           FLAGS |= 0x0001;
15769                       000043E0            .3A3:
15770                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15771 43E0           8B46         18            mov	ax,$18[bp]
15772 43E3           0C                     01  or	al,*1
15773 43E5           8946         18            mov	$18[bp],ax
15774                                           !BCC_EOS
15775                                           ! 2963           regs.u.r8.ah = ret;
15776                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
15777 43E8           8A46         F5            mov	al,-$B[bp]
15778 43EB           8846         13            mov	$13[bp],al
15779                                           !BCC_EOS
15780                                           ! 2964           return;
15781 43EE           89EC                       mov	sp,bp
15782 43F0           5D                         pop	bp
15783 43F1           C3                         ret
15784                                           !BCC_EOS
15785                                           ! 2965         case 2:
15786                                           ! 2966 ;
15787                       000043F2            .3B0:
15788                                           !BCC_EOS
15789                                           ! 2967           switch (regs.u.r8.bh) {
15790 43F2           8A46         0D            mov	al,$D[bp]
15791 43F5           EB           38            jmp .3B3
15792                                           ! 2968             case 0: mouse_data1 = 10; break;
15793                       000043F7            .3B4:
15794                                           ! Debug: eq int = const $A to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15795 43F7           B0                     0A  mov	al,*$A
15796 43F9           8846         F4            mov	-$C[bp],al
15797                                           !BCC_EOS
15798 43FC           EB           54            jmp .3B1
15799                                           !BCC_EOS
15800                                           ! 2969             case 1: mouse_data1 = 20; break;
15801                       000043FE            .3B5:
15802                                           ! Debug: eq int = const $14 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15803 43FE           B0                     14  mov	al,*$14
15804 4400           8846         F4            mov	-$C[bp],al
15805                                           !BCC_EOS
15806 4403           EB           4D            jmp .3B1
15807                                           !BCC_EOS
15808                                           ! 2970             case 2: mouse_data1 = 40; break;
15809                       00004405            .3B6:
15810                                           ! Debug: eq int = const $28 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15811 4405           B0                     28  mov	al,*$28
15812 4407           8846         F4            mov	-$C[bp],al
15813                                           !BCC_EOS
15814 440A           EB           46            jmp .3B1
15815                                           !BCC_EOS
15816                                           ! 2971             case 3: mouse_data1 = 60; break;
15817                       0000440C            .3B7:
15818                                           ! Debug: eq int = const $3C to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15819 440C           B0                     3C  mov	al,*$3C
15820 440E           8846         F4            mov	-$C[bp],al
15821                                           !BCC_EOS
15822 4411           EB           3F            jmp .3B1
15823                                           !BCC_EOS
15824                                           ! 2972             case 4: mouse_data1 = 80; break;
15825                       00004413            .3B8:
15826                                           ! Debug: eq int = const $50 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15827 4413           B0                     50  mov	al,*$50
15828 4415           8846         F4            mov	-$C[bp],al
15829                                           !BCC_EOS
15830 4418           EB           38            jmp .3B1
15831                                           !BCC_EOS
15832                                           ! 2973             case 5: mouse_data1 = 100; break;
15833                       0000441A            .3B9:
15834                                           ! Debug: eq int = const $64 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15835 441A           B0                     64  mov	al,*$64
15836 441C           8846         F4            mov	-$C[bp],al
15837                                           !BCC_EOS
15838 441F           EB           31            jmp .3B1
15839                                           !BCC_EOS
15840                                           ! 2974             case 6: mouse_data1 = 200; break;
15841                       00004421            .3BA:
15842                                           ! Debug: eq int = const $C8 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15843 4421           B0                     C8  mov	al,#$C8
15844 4423           8846         F4            mov	-$C[bp],al
15845                                           !BCC_EOS
15846 4426           EB           2A            jmp .3B1
15847                                           !BCC_EOS
15848                                           ! 2975             default: mouse_data1 = 0;
15849                       00004428            .3BB:
15850                                           ! Debug: eq int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15851 4428           30C0                       xor	al,al
15852 442A           8846         F4            mov	-$C[bp],al
15853                                           !BCC_EOS
15854                                           ! 2976           }
15855                                           ! 2977 
15856                                           ! 2977           if (mouse_data1 > 0) {
15857 442D           EB           23            jmp .3B1
15858                       0000442F            .3B3:
15859 442F           2C                     00  sub	al,*0
15860 4431           72           F5            jb 	.3BB
15861 4433           3C                     06  cmp	al,*6
15862 4435           77           19            ja  	.3BC
15863 4437           30E4                       xor	ah,ah
15864 4439           D1E0                       shl	ax,*1
15865 443B           89C3                       mov	bx,ax
15866 443D           2E                         seg	cs
15867 443E           FFA7       4442            br	.3BD[bx]
15868                       00004442            .3BD:
15869 4442                      43F7            .word	.3B4
15870 4444                      43FE            .word	.3B5
15871 4446                      4405            .word	.3B6
15872 4448                      440C            .word	.3B7
15873 444A                      4413            .word	.3B8
15874 444C                      441A            .word	.3B9
15875 444E                      4421            .word	.3BA
15876                       00004450            .3BC:
15877 4450           EB           D6            jmp	.3BB
15878                       00004452            .3B1:
15879                                           ! Debug: gt int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15880 4452           8A46         F4            mov	al,-$C[bp]
15881 4455           84C0                       test	al,al
15882 4457           74           57            je  	.3BE
15883                       00004459            .3BF:
15884                                           ! 2978             ret = send_to_mouse_ctrl(0xF3);
15885                                           ! Debug: list int = const $F3 (used reg = )
15886 4459           B8                   00F3  mov	ax,#$F3
15887 445C           50                         push	ax
15888                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15889 445D           E8         0ED3            call	_send_to_mouse_ctrl
15890 4460           44                         inc	sp
15891 4461           44                         inc	sp
15892                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15893 4462           8846         F5            mov	-$B[bp],al
15894                                           !BCC_EOS
15895                                           ! 2979             if (ret == 0) {
15896                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15897 4465           8A46         F5            mov	al,-$B[bp]
15898 4468           84C0                       test	al,al
15899 446A           75           35            jne 	.3C0
15900                       0000446C            .3C1:
15901                                           ! 2980               ret = get_mouse_data(&mouse_data2);
15902                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
15903 446C           8D5E         F3            lea	bx,-$D[bp]
15904 446F           53                         push	bx
15905                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15906 4470           E8         0F0A            call	_get_mouse_data
15907 4473           44                         inc	sp
15908 4474           44                         inc	sp
15909                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15910 4475           8846         F5            mov	-$B[bp],al
15911                                           !BCC_EOS
15912                                           ! 2981               ret = send_to_mouse_ctrl(mouse_data1);
15913                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15914 4478           8A46         F4            mov	al,-$C[bp]
15915 447B           30E4                       xor	ah,ah
15916 447D           50                         push	ax
15917                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15918 447E           E8         0EB2            call	_send_to_mouse_ctrl
15919 4481           44                         inc	sp
15920 4482           44                         inc	sp
15921                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15922 4483           8846         F5            mov	-$B[bp],al
15923                                           !BCC_EOS
15924                                           ! 2982               ret = get_mouse_data(&mouse_data2);
15925                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
15926 4486           8D5E         F3            lea	bx,-$D[bp]
15927 4489           53                         push	bx
15928                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15929 448A           E8         0EF0            call	_get_mouse_data
15930 448D           44                         inc	sp
15931 448E           44                         inc	sp
15932                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15933 448F           8846         F5            mov	-$B[bp],al
15934                                           !BCC_EOS
15935                                           ! 2983               FLAGS &= 0xfffe;
15936                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
15937 4492           8B46         18            mov	ax,$18[bp]
15938 4495           24                     FE  and	al,#$FE
15939 4497           8946         18            mov	$18[bp],ax
15940                                           !BCC_EOS
15941                                           ! 2984               regs.u.r8.ah = 0;
15942                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
15943 449A           30C0                       xor	al,al
15944 449C           8846         13            mov	$13[bp],al
15945                                           !BCC_EOS
15946                                           ! 2985             } else {
15947 449F           EB           0D            jmp .3C2
15948                       000044A1            .3C0:
15949                                           ! 2986               FLAGS |= 0x0001;
15950                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15951 44A1           8B46         18            mov	ax,$18[bp]
15952 44A4           0C                     01  or	al,*1
15953 44A6           8946         18            mov	$18[bp],ax
15954                                           !BCC_EOS
15955                                           ! 2987               regs.u.r8.ah = 0x86;
15956                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
15957 44A9           B0                     86  mov	al,#$86
15958 44AB           8846         13            mov	$13[bp],al
15959                                           !BCC_EOS
15960                                           ! 2988             }
15961                                           ! 2989           } else {
15962                       000044AE            .3C2:
15963 44AE           EB           0D            jmp .3C3
15964                       000044B0            .3BE:
15965                                           ! 2990             FLAGS |= 0x0001;
15966                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15967 44B0           8B46         18            mov	ax,$18[bp]
15968 44B3           0C                     01  or	al,*1
15969 44B5           8946         18            mov	$18[bp],ax
15970                                           !BCC_EOS
15971                                           ! 2991             regs.u.r8.ah = 0x86;
15972                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
15973 44B8           B0                     86  mov	al,#$86
15974 44BA           8846         13            mov	$13[bp],al
15975                                           !BCC_EOS
15976                                           ! 2992           }
15977                                           ! 2993           break;
15978                       000044BD            .3C3:
15979 44BD           E9         033F            br 	.386
15980                                           !BCC_EOS
15981                                           ! 2994         case 3:
15982                                           ! 2995 ;
15983                       000044C0            .3C4:
15984                                           !BCC_EOS
15985                                           ! 2996           comm_byte = inhibit_mouse_int_and_events();
15986                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
15987 44C0           E8         0D1F            call	_inhibit_mouse_int_and_events
15988                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
15989 44C3           8846         F7            mov	-9[bp],al
15990                                           !BCC_EOS
15991                                           ! 2997           if (regs.u.r8.bh < 4) {
15992                                           ! Debug: lt int = const 4 to unsigned char regs = [S+$10+$B] (used reg = )
15993 44C6           8A46         0D            mov	al,$D[bp]
15994 44C9           3C                     04  cmp	al,*4
15995 44CB         0F83         008D            bhis	.3C5
15996                       000044CF            .3C6:
15997                                           ! 2998             ret = send_to_mouse_ctrl(0xE8);
15998                                           ! Debug: list int = const $E8 (used reg = )
15999 44CF           B8                   00E8  mov	ax,#$E8
16000 44D2           50                         push	ax
16001                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16002 44D3           E8         0E5D            call	_send_to_mouse_ctrl
16003 44D6           44                         inc	sp
16004 44D7           44                         inc	sp
16005                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16006 44D8           8846         F5            mov	-$B[bp],al
16007                                           !BCC_EOS
16008                                           ! 2999             if (ret == 0) {
16009                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16010 44DB           8A46         F5            mov	al,-$B[bp]
16011 44DE           84C0                       test	al,al
16012 44E0           75           6B            jne 	.3C7
16013                       000044E2            .3C8:
16014                                           ! 3000               ret = get_mouse_data(&mouse_data1);
16015                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16016 44E2           8D5E         F4            lea	bx,-$C[bp]
16017 44E5           53                         push	bx
16018                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16019 44E6           E8         0E94            call	_get_mouse_data
16020 44E9           44                         inc	sp
16021 44EA           44                         inc	sp
16022                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16023 44EB           8846         F5            mov	-$B[bp],al
16024                                           !BCC_EOS
16025                                           ! 3001               if (mouse_data1 != 0xfa)
16026                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16027 44EE           8A46         F4            mov	al,-$C[bp]
16028 44F1           3C                     FA  cmp	al,#$FA
16029 44F3           74           14            je  	.3C9
16030                       000044F5            .3CA:
16031                                           ! 3002                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
16032                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16033 44F5           8A46         F4            mov	al,-$C[bp]
16034 44F8           30E4                       xor	ah,ah
16035 44FA           50                         push	ax
16036                                           ! Debug: list * char = .3CB+0 (used reg = )
16037 44FB           BB                   D49F  mov	bx,#.3CB
16038 44FE           53                         push	bx
16039                                           ! Debug: list int = const 7 (used reg = )
16040 44FF           B8                   0007  mov	ax,*7
16041 4502           50                         push	ax
16042                                           ! Debug: func () void = bios_printf+0 (used reg = )
16043 4503           E8         C438            call	_bios_printf
16044 4506           83C4                   06  add	sp,*6
16045                                           !BCC_EOS
16046                                           ! 3003               ret = send_to_mouse_ctrl(regs.u.r8.bh);
16047                       00004509            .3C9:
16048                                           ! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
16049 4509           8A46         0D            mov	al,$D[bp]
16050 450C           30E4                       xor	ah,ah
16051 450E           50                         push	ax
16052                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16053 450F           E8         0E21            call	_send_to_mouse_ctrl
16054 4512           44                         inc	sp
16055 4513           44                         inc	sp
16056                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16057 4514           8846         F5            mov	-$B[bp],al
16058                                           !BCC_EOS
16059                                           ! 3004               ret = get_mouse_data(&mouse_data1);
16060                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16061 4517           8D5E         F4            lea	bx,-$C[bp]
16062 451A           53                         push	bx
16063                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16064 451B           E8         0E5F            call	_get_mouse_data
16065 451E           44                         inc	sp
16066 451F           44                         inc	sp
16067                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16068 4520           8846         F5            mov	-$B[bp],al
16069                                           !BCC_EOS
16070                                           ! 3005               if (mouse_data1 != 0xfa)
16071                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16072 4523           8A46         F4            mov	al,-$C[bp]
16073 4526           3C                     FA  cmp	al,#$FA
16074 4528           74           14            je  	.3CC
16075                       0000452A            .3CD:
16076                                           ! 3006                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
16077                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16078 452A           8A46         F4            mov	al,-$C[bp]
16079 452D           30E4                       xor	ah,ah
16080 452F           50                         push	ax
16081                                           ! Debug: list * char = .3CE+0 (used reg = )
16082 4530           BB                   D473  mov	bx,#.3CE
16083 4533           53                         push	bx
16084                                           ! Debug: list int = const 7 (used reg = )
16085 4534           B8                   0007  mov	ax,*7
16086 4537           50                         push	ax
16087                                           ! Debug: func () void = bios_printf+0 (used reg = )
16088 4538           E8         C403            call	_bios_printf
16089 453B           83C4                   06  add	sp,*6
16090                                           !BCC_EOS
16091                                           ! 3007               FLAGS &= 0xfffe;
16092                       0000453E            .3CC:
16093                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16094 453E           8B46         18            mov	ax,$18[bp]
16095 4541           24                     FE  and	al,#$FE
16096 4543           8946         18            mov	$18[bp],ax
16097                                           !BCC_EOS
16098                                           ! 3008               regs.u.r8.ah = 0;
16099                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16100 4546           30C0                       xor	al,al
16101 4548           8846         13            mov	$13[bp],al
16102                                           !BCC_EOS
16103                                           ! 3009             } else {
16104 454B           EB           0D            jmp .3CF
16105                       0000454D            .3C7:
16106                                           ! 3010               FLAGS |= 0x0001;
16107                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16108 454D           8B46         18            mov	ax,$18[bp]
16109 4550           0C                     01  or	al,*1
16110 4552           8946         18            mov	$18[bp],ax
16111                                           !BCC_EOS
16112                                           ! 3011               regs.u.r8.ah = 0x86;
16113                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16114 4555           B0                     86  mov	al,#$86
16115 4557           8846         13            mov	$13[bp],al
16116                                           !BCC_EOS
16117                                           ! 3012             }
16118                                           ! 3013           } else {
16119                       0000455A            .3CF:
16120 455A           EB           0D            jmp .3D0
16121                       0000455C            .3C5:
16122                                           ! 3014             FLAGS |= 0x0001;
16123                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16124 455C           8B46         18            mov	ax,$18[bp]
16125 455F           0C                     01  or	al,*1
16126 4561           8946         18            mov	$18[bp],ax
16127                                           !BCC_EOS
16128                                           ! 3015             regs.u.r8.ah = 0x86;
16129                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16130 4564           B0                     86  mov	al,#$86
16131 4566           8846         13            mov	$13[bp],al
16132                                           !BCC_EOS
16133                                           ! 3016           }
16134                                           ! 3017           set_kbd_command_byte(comm_byte);
16135                       00004569            .3D0:
16136                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
16137 4569           8A46         F7            mov	al,-9[bp]
16138 456C           30E4                       xor	ah,ah
16139 456E           50                         push	ax
16140                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
16141 456F           E8         0E42            call	_set_kbd_command_byte
16142 4572           44                         inc	sp
16143 4573           44                         inc	sp
16144                                           !BCC_EOS
16145                                           ! 3018           break;
16146 4574           E9         0288            br 	.386
16147                                           !BCC_EOS
16148                                           ! 3019         case 4:
16149                                           ! 3020 ;
16150                       00004577            .3D1:
16151                                           !BCC_EOS
16152                                           ! 3021           inhibit_mouse_int_and_events();
16153                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
16154 4577           E8         0C68            call	_inhibit_mouse_int_and_events
16155                                           !BCC_EOS
16156                                           ! 3022           ret = send_to_mouse_ctrl(0xF2);
16157                                           ! Debug: list int = const $F2 (used reg = )
16158 457A           B8                   00F2  mov	ax,#$F2
16159 457D           50                         push	ax
16160                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16161 457E           E8         0DB2            call	_send_to_mouse_ctrl
16162 4581           44                         inc	sp
16163 4582           44                         inc	sp
16164                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16165 4583           8846         F5            mov	-$B[bp],al
16166                                           !BCC_EOS
16167                                           ! 3023           if (ret == 0) {
16168                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16169 4586           8A46         F5            mov	al,-$B[bp]
16170 4589           84C0                       test	al,al
16171 458B           75           2D            jne 	.3D2
16172                       0000458D            .3D3:
16173                                           ! 3024             ret = get_mouse_data(&mouse_data1);
16174                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16175 458D           8D5E         F4            lea	bx,-$C[bp]
16176 4590           53                         push	bx
16177                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16178 4591           E8         0DE9            call	_get_mouse_data
16179 4594           44                         inc	sp
16180 4595           44                         inc	sp
16181                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16182 4596           8846         F5            mov	-$B[bp],al
16183                                           !BCC_EOS
16184                                           ! 3025             ret = get_mouse_data(&mouse_data2);
16185                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
16186 4599           8D5E         F3            lea	bx,-$D[bp]
16187 459C           53                         push	bx
16188                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16189 459D           E8         0DDD            call	_get_mouse_data
16190 45A0           44                         inc	sp
16191 45A1           44                         inc	sp
16192                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16193 45A2           8846         F5            mov	-$B[bp],al
16194                                           !BCC_EOS
16195                                           ! 3026             FLAGS &= 0xfffe;
16196                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16197 45A5           8B46         18            mov	ax,$18[bp]
16198 45A8           24                     FE  and	al,#$FE
16199 45AA           8946         18            mov	$18[bp],ax
16200                                           !BCC_EOS
16201                                           ! 3027             regs.u.r8.ah = 0;
16202                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16203 45AD           30C0                       xor	al,al
16204 45AF           8846         13            mov	$13[bp],al
16205                                           !BCC_EOS
16206                                           ! 3028             regs.u.r8.bh = mouse_data2;
16207                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
16208 45B2           8A46         F3            mov	al,-$D[bp]
16209 45B5           8846         0D            mov	$D[bp],al
16210                                           !BCC_EOS
16211                                           ! 3029           } else {
16212 45B8           EB           0D            jmp .3D4
16213                       000045BA            .3D2:
16214                                           ! 3030             FLAGS |= 0x0001;
16215                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16216 45BA           8B46         18            mov	ax,$18[bp]
16217 45BD           0C                     01  or	al,*1
16218 45BF           8946         18            mov	$18[bp],ax
16219                                           !BCC_EOS
16220                                           ! 3031             regs.u.r8.ah = 0x86;
16221                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16222 45C2           B0                     86  mov	al,#$86
16223 45C4           8846         13            mov	$13[bp],al
16224                                           !BCC_EOS
16225                                           ! 3032           }
16226                                           ! 3033           break;
16227                       000045C7            .3D4:
16228 45C7           E9         0235            br 	.386
16229                                           !BCC_EOS
16230                                           ! 3034         case 6:
16231                                           ! 3035 ;
16232                       000045CA            .3D5:
16233                                           !BCC_EOS
16234                                           ! 3036           switch (regs.u.r8.bh) {
16235 45CA           8A46         0D            mov	al,$D[bp]
16236 45CD           E9         015A            br 	.3D8
16237                                           ! 3037             case 0:
16238                                           ! 3038               comm_byte = inhibit_mouse_int_and_events();
16239                       000045D0            .3D9:
16240                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
16241 45D0           E8         0C0F            call	_inhibit_mouse_int_and_events
16242                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
16243 45D3           8846         F7            mov	-9[bp],al
16244                                           !BCC_EOS
16245                                           ! 3039 
16246                                           ! 3039               ret = send_to_mouse_ctrl(0xE9);
16247                                           ! Debug: list int = const $E9 (used reg = )
16248 45D6           B8                   00E9  mov	ax,#$E9
16249 45D9           50                         push	ax
16250                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16251 45DA           E8         0D56            call	_send_to_mouse_ctrl
16252 45DD           44                         inc	sp
16253 45DE           44                         inc	sp
16254                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16255 45DF           8846         F5            mov	-$B[bp],al
16256                                           !BCC_EOS
16257                                           ! 3040               if (ret == 0) {
16258                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16259 45E2           8A46         F5            mov	al,-$B[bp]
16260 45E5           84C0                       test	al,al
16261 45E7         0F85         0095            bne 	.3DA
16262                       000045EB            .3DB:
16263                                           ! 3041                 ret = get_mouse_data(&mouse_data1);
16264                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16265 45EB           8D5E         F4            lea	bx,-$C[bp]
16266 45EE           53                         push	bx
16267                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16268 45EF           E8         0D8B            call	_get_mouse_data
16269 45F2           44                         inc	sp
16270 45F3           44                         inc	sp
16271                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16272 45F4           8846         F5            mov	-$B[bp],al
16273                                           !BCC_EOS
16274                                           ! 3042                 if (mouse_data1 != 0xfa)
16275                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16276 45F7           8A46         F4            mov	al,-$C[bp]
16277 45FA           3C                     FA  cmp	al,#$FA
16278 45FC           74           14            je  	.3DC
16279                       000045FE            .3DD:
16280                                           ! 3043                   bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
16281                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16282 45FE           8A46         F4            mov	al,-$C[bp]
16283 4601           30E4                       xor	ah,ah
16284 4603           50                         push	ax
16285                                           ! Debug: list * char = .3DE+0 (used reg = )
16286 4604           BB                   D447  mov	bx,#.3DE
16287 4607           53                         push	bx
16288                                           ! Debug: list int = const 7 (used reg = )
16289 4608           B8                   0007  mov	ax,*7
16290 460B           50                         push	ax
16291                                           ! Debug: func () void = bios_printf+0 (used reg = )
16292 460C           E8         C32F            call	_bios_printf
16293 460F           83C4                   06  add	sp,*6
16294                                           !BCC_EOS
16295                                           ! 3044                 if (ret == 0) {
16296                       00004612            .3DC:
16297                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16298 4612           8A46         F5            mov	al,-$B[bp]
16299 4615           84C0                       test	al,al
16300 4617           75           67            jne 	.3DF
16301                       00004619            .3E0:
16302                                           ! 3045                   ret = get_mouse_data(&mouse_data1);
16303                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16304 4619           8D5E         F4            lea	bx,-$C[bp]
16305 461C           53                         push	bx
16306                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16307 461D           E8         0D5D            call	_get_mouse_data
16308 4620           44                         inc	sp
16309 4621           44                         inc	sp
16310                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16311 4622           8846         F5            mov	-$B[bp],al
16312                                           !BCC_EOS
16313                                           ! 3046                   if (ret == 0) {
16314                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16315 4625           8A46         F5            mov	al,-$B[bp]
16316 4628           84C0                       test	al,al
16317 462A           75           54            jne 	.3E1
16318                       0000462C            .3E2:
16319                                           ! 3047                     ret = get_mouse_data(&mouse_data2);
16320                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
16321 462C           8D5E         F3            lea	bx,-$D[bp]
16322 462F           53                         push	bx
16323                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16324 4630           E8         0D4A            call	_get_mouse_data
16325 4633           44                         inc	sp
16326 4634           44                         inc	sp
16327                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16328 4635           8846         F5            mov	-$B[bp],al
16329                                           !BCC_EOS
16330                                           ! 3048                     if (ret == 0) {
16331                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16332 4638           8A46         F5            mov	al,-$B[bp]
16333 463B           84C0                       test	al,al
16334 463D           75           41            jne 	.3E3
16335                       0000463F            .3E4:
16336                                           ! 3049                       ret = get_mouse_data(&mouse_data3);
16337                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
16338 463F           8D5E         F2            lea	bx,-$E[bp]
16339 4642           53                         push	bx
16340                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16341 4643           E8         0D37            call	_get_mouse_data
16342 4646           44                         inc	sp
16343 4647           44                         inc	sp
16344                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16345 4648           8846         F5            mov	-$B[bp],al
16346                                           !BCC_EOS
16347                                           ! 3050                       if (ret == 0) {
16348                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16349 464B           8A46         F5            mov	al,-$B[bp]
16350 464E           84C0                       test	al,al
16351 4650           75           2E            jne 	.3E5
16352                       00004652            .3E6:
16353                                           ! 3051                         FLAGS &= 0xfffe;
16354                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16355 4652           8B46         18            mov	ax,$18[bp]
16356 4655           24                     FE  and	al,#$FE
16357 4657           8946         18            mov	$18[bp],ax
16358                                           !BCC_EOS
16359                                           ! 3052                         regs.u.r8.ah = 0;
16360                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16361 465A           30C0                       xor	al,al
16362 465C           8846         13            mov	$13[bp],al
16363                                           !BCC_EOS
16364                                           ! 3053                         regs.u.r8.bl = mouse_data1;
16365                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
16366 465F           8A46         F4            mov	al,-$C[bp]
16367 4662           8846         0C            mov	$C[bp],al
16368                                           !BCC_EOS
16369                                           ! 3054                         regs.u.r8.cl = mouse_data2;
16370                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$E] (used reg = )
16371 4665           8A46         F3            mov	al,-$D[bp]
16372 4668           8846         10            mov	$10[bp],al
16373                                           !BCC_EOS
16374                                           ! 3055                         regs.u.r8.dl = mouse_data3;
16375                                           ! Debug: eq unsigned char mouse_data3 = [S+$10-$10] to unsigned char regs = [S+$10+$C] (used reg = )
16376 466B           8A46         F2            mov	al,-$E[bp]
16377 466E           8846         0E            mov	$E[bp],al
16378                                           !BCC_EOS
16379                                           ! 3056                         set_kbd_command_byte(comm_byte);
16380                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
16381 4671           8A46         F7            mov	al,-9[bp]
16382 4674           30E4                       xor	ah,ah
16383 4676           50                         push	ax
16384                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
16385 4677           E8         0D3A            call	_set_kbd_command_byte
16386 467A           44                         inc	sp
16387 467B           44                         inc	sp
16388                                           !BCC_EOS
16389                                           ! 3057                         return;
16390 467C           89EC                       mov	sp,bp
16391 467E           5D                         pop	bp
16392 467F           C3                         ret
16393                                           !BCC_EOS
16394                                           ! 3058                       }
16395                                           ! 3059                     }
16396                       00004680            .3E5:
16397                                           ! 3060                   }
16398                       00004680            .3E3:
16399                                           ! 3061                 }
16400                       00004680            .3E1:
16401                                           ! 3062               }
16402                       00004680            .3DF:
16403                                           ! 3063               FLAGS |= 0x0001;
16404                       00004680            .3DA:
16405                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16406 4680           8B46         18            mov	ax,$18[bp]
16407 4683           0C                     01  or	al,*1
16408 4685           8946         18            mov	$18[bp],ax
16409                                           !BCC_EOS
16410                                           ! 3064               regs.u.r8.ah = ret;
16411                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
16412 4688           8A46         F5            mov	al,-$B[bp]
16413 468B           8846         13            mov	$13[bp],al
16414                                           !BCC_EOS
16415                                           ! 3065               set_kbd_command_byte(comm_byte);
16416                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
16417 468E           8A46         F7            mov	al,-9[bp]
16418 4691           30E4                       xor	ah,ah
16419 4693           50                         push	ax
16420                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
16421 4694           E8         0D1D            call	_set_kbd_command_byte
16422 4697           44                         inc	sp
16423 4698           44                         inc	sp
16424                                           !BCC_EOS
16425                                           ! 3066               return;
16426 4699           89EC                       mov	sp,bp
16427 469B           5D                         pop	bp
16428 469C           C3                         ret
16429                                           !BCC_EOS
16430                                           ! 3067             case 1:
16431                                           ! 3068             case 2:
16432                       0000469D            .3E7:
16433                                           ! 3069               comm_byte = inhibit_mouse_int_and_events();
16434                       0000469D            .3E8:
16435                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
16436 469D           E8         0B42            call	_inhibit_mouse_int_and_events
16437                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
16438 46A0           8846         F7            mov	-9[bp],al
16439                                           !BCC_EOS
16440                                           ! 3070               if (regs.u.r8.bh == 1) {
16441                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$10+$B] (used reg = )
16442 46A3           8A46         0D            mov	al,$D[bp]
16443 46A6           3C                     01  cmp	al,*1
16444 46A8           75           0E            jne 	.3E9
16445                       000046AA            .3EA:
16446                                           ! 3071                 ret = send_to_mouse_ctrl(0xE6);
16447                                           ! Debug: list int = const $E6 (used reg = )
16448 46AA           B8                   00E6  mov	ax,#$E6
16449 46AD           50                         push	ax
16450                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16451 46AE           E8         0C82            call	_send_to_mouse_ctrl
16452 46B1           44                         inc	sp
16453 46B2           44                         inc	sp
16454                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16455 46B3           8846         F5            mov	-$B[bp],al
16456                                           !BCC_EOS
16457                                           ! 3072               } else {
16458 46B6           EB           0C            jmp .3EB
16459                       000046B8            .3E9:
16460                                           ! 3073                 ret = send_to_mouse_ctrl(0xE7);
16461                                           ! Debug: list int = const $E7 (used reg = )
16462 46B8           B8                   00E7  mov	ax,#$E7
16463 46BB           50                         push	ax
16464                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16465 46BC           E8         0C74            call	_send_to_mouse_ctrl
16466 46BF           44                         inc	sp
16467 46C0           44                         inc	sp
16468                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16469 46C1           8846         F5            mov	-$B[bp],al
16470                                           !BCC_EOS
16471                                           ! 3074               }
16472                                           ! 3075               if (ret == 0) {
16473                       000046C4            .3EB:
16474                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16475 46C4           8A46         F5            mov	al,-$B[bp]
16476 46C7           84C0                       test	al,al
16477 46C9           75           19            jne 	.3EC
16478                       000046CB            .3ED:
16479                                           ! 3076                 get_mouse_data(&mouse_data1);
16480                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16481 46CB           8D5E         F4            lea	bx,-$C[bp]
16482 46CE           53                         push	bx
16483                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16484 46CF           E8         0CAB            call	_get_mouse_data
16485 46D2           44                         inc	sp
16486 46D3           44                         inc	sp
16487                                           !BCC_EOS
16488                                           ! 3077                 ret = (mouse_data1 != 0xFA);
16489                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16490 46D4           8A46         F4            mov	al,-$C[bp]
16491 46D7           3C                     FA  cmp	al,#$FA
16492 46D9           74           04            je 	.3EE
16493 46DB           B0                     01  mov	al,*1
16494 46DD           EB           02            jmp	.3EF
16495                       000046DF            .3EE:
16496 46DF           30C0                       xor	al,al
16497                       000046E1            .3EF:
16498                                           ! Debug: eq char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16499 46E1           8846         F5            mov	-$B[bp],al
16500                                           !BCC_EOS
16501                                           ! 3078               }
16502                                           ! 3079               if (ret == 0) {
16503                       000046E4            .3EC:
16504                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16505 46E4           8A46         F5            mov	al,-$B[bp]
16506 46E7           84C0                       test	al,al
16507 46E9           75           0F            jne 	.3F0
16508                       000046EB            .3F1:
16509                                           ! 3080                 FLAGS &= 0xfffe;
16510                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16511 46EB           8B46         18            mov	ax,$18[bp]
16512 46EE           24                     FE  and	al,#$FE
16513 46F0           8946         18            mov	$18[bp],ax
16514                                           !BCC_EOS
16515                                           ! 3081                 regs.u.r8.ah = 0;
16516                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16517 46F3           30C0                       xor	al,al
16518 46F5           8846         13            mov	$13[bp],al
16519                                           !BCC_EOS
16520                                           ! 3082               } else {
16521 46F8           EB           0D            jmp .3F2
16522                       000046FA            .3F0:
16523                                           ! 3083                 FLAGS |= 0x0001;
16524                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16525 46FA           8B46         18            mov	ax,$18[bp]
16526 46FD           0C                     01  or	al,*1
16527 46FF           8946         18            mov	$18[bp],ax
16528                                           !BCC_EOS
16529                                           ! 3084                 regs.u.r8.ah = 0x86;
16530                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16531 4702           B0                     86  mov	al,#$86
16532 4704           8846         13            mov	$13[bp],al
16533                                           !BCC_EOS
16534                                           ! 3085               }
16535                                           ! 3086               set_kbd_command_byte(comm_byte);
16536                       00004707            .3F2:
16537                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
16538 4707           8A46         F7            mov	al,-9[bp]
16539 470A           30E4                       xor	ah,ah
16540 470C           50                         push	ax
16541                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
16542 470D           E8         0CA4            call	_set_kbd_command_byte
16543 4710           44                         inc	sp
16544 4711           44                         inc	sp
16545                                           !BCC_EOS
16546                                           ! 3087               break;
16547 4712           EB           2A            jmp .3D6
16548                                           !BCC_EOS
16549                                           ! 3088             default:
16550                                           ! 3089               bios_printf((2 | 4 | 1), "INT 15h C2 AL=6, BH=%02x\n", (unsigned) regs.u.r8.bh);
16551                       00004714            .3F3:
16552                                           ! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
16553 4714           8A46         0D            mov	al,$D[bp]
16554 4717           30E4                       xor	ah,ah
16555 4719           50                         push	ax
16556                                           ! Debug: list * char = .3F4+0 (used reg = )
16557 471A           BB                   D42D  mov	bx,#.3F4
16558 471D           53                         push	bx
16559                                           ! Debug: list int = const 7 (used reg = )
16560 471E           B8                   0007  mov	ax,*7
16561 4721           50                         push	ax
16562                                           ! Debug: func () void = bios_printf+0 (used reg = )
16563 4722           E8         C219            call	_bios_printf
16564 4725           83C4                   06  add	sp,*6
16565                                           !BCC_EOS
16566                                           ! 3090           }
16567                                           ! 3091           break;
16568 4728           EB           14            jmp .3D6
16569                       0000472A            .3D8:
16570 472A           2C                     00  sub	al,*0
16571 472C         0F84         FEA0            beq 	.3D9
16572 4730           2C                     01  sub	al,*1
16573 4732         0F84         FF67            beq 	.3E7
16574 4736           2C                     01  sub	al,*1
16575 4738         0F84         FF61            beq 	.3E8
16576 473C           EB           D6            jmp	.3F3
16577                       0000473E            .3D6:
16578 473E           E9         00BE            br 	.386
16579                                           !BCC_EOS
16580                                           ! 3092         case 7:
16581                                           ! 3093 ;
16582                       00004741            .3F5:
16583                                           !BCC_EOS
16584                                           ! 3094           mouse_driver_seg = ES;
16585                                           ! Debug: eq unsigned short ES = [S+$10+$12] to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
16586 4741           8B46         14            mov	ax,$14[bp]
16587 4744           8946         FA            mov	-6[bp],ax
16588                                           !BCC_EOS
16589                                           ! 3095           mouse
16590                                           ! 3095 _driver_offset = regs.u.r16.bx;
16591                                           ! Debug: eq unsigned short regs = [S+$10+$A] to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
16592 4747           8B46         0C            mov	ax,$C[bp]
16593 474A           8946         F8            mov	-8[bp],ax
16594                                           !BCC_EOS
16595                                           ! 3096           _write_word(mouse_driver_offset, &((ebda_data_t *) 0)->mouse_driver_offset, ebda_seg);
16596                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
16597 474D           FF76         FE            push	-2[bp]
16598                                           ! Debug: list * unsigned short = const $22 (used reg = )
16599 4750           B8                   0022  mov	ax,*$22
16600 4753           50                         push	ax
16601                                           ! Debug: list unsigned short mouse_driver_offset = [S+$14-$A] (used reg = )
16602 4754           FF76         F8            push	-8[bp]
16603                                           ! Debug: func () void = _write_word+0 (used reg = )
16604 4757           E8         BEB9            call	__write_word
16605 475A           83C4                   06  add	sp,*6
16606                                           !BCC_EOS
16607                                           ! 3097           _write_word(mouse_driver_seg, &((ebda_data_t *) 0)->mouse_driver_seg, ebda_seg);
16608                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
16609 475D           FF76         FE            push	-2[bp]
16610                                           ! Debug: list * unsigned short = const $24 (used reg = )
16611 4760           B8                   0024  mov	ax,*$24
16612 4763           50                         push	ax
16613                                           ! Debug: list unsigned short mouse_driver_seg = [S+$14-8] (used reg = )
16614 4764           FF76         FA            push	-6[bp]
16615                                           ! Debug: func () void = _write_word+0 (used reg = )
16616 4767           E8         BEA9            call	__write_word
16617 476A           83C4                   06  add	sp,*6
16618                                           !BCC_EOS
16619                                           ! 3098           mouse_flags_2 = _read_byte(&((ebda_data_t *) 0)->mouse_flag2, ebda_seg);
16620                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
16621 476D           FF76         FE            push	-2[bp]
16622                                           ! Debug: list * unsigned char = const $27 (used reg = )
16623 4770           B8                   0027  mov	ax,*$27
16624 4773           50                         push	ax
16625                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
16626 4774           E8         BE6D            call	__read_byte
16627 4777           83C4                   04  add	sp,*4
16628                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16629 477A           8846         FC            mov	-4[bp],al
16630                                           !BCC_EOS
16631                                           ! 3099           if (mouse_driver_offset == 0 && mouse_driver_seg == 0) {
16632                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
16633 477D           8B46         F8            mov	ax,-8[bp]
16634 4780           85C0                       test	ax,ax
16635 4782           75           1D            jne 	.3F6
16636                       00004784            .3F8:
16637                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
16638 4784           8B46         FA            mov	ax,-6[bp]
16639 4787           85C0                       test	ax,ax
16640 4789           75           16            jne 	.3F6
16641                       0000478B            .3F7:
16642                                           ! 3100             if ( (mouse_flags_2 & 0x80) != 0 ) {
16643                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16644 478B           8A46         FC            mov	al,-4[bp]
16645 478E           24                     80  and	al,#$80
16646                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
16647 4790           84C0                       test	al,al
16648 4792           74           0B            je  	.3F9
16649                       00004794            .3FA:
16650                                           ! 3101               mouse_flags_2 &= ~0x80;
16651                                           ! Debug: andab int = const -$81 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16652 4794           8A46         FC            mov	al,-4[bp]
16653 4797           24                     7F  and	al,*$7F
16654 4799           8846         FC            mov	-4[bp],al
16655                                           !BCC_EOS
16656                                           ! 3102               inhibit_mouse_int_and_events();
16657                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
16658 479C           E8         0A43            call	_inhibit_mouse_int_and_events
16659                                           !BCC_EOS
16660                                           ! 3103             }
16661                                           ! 3104           }
16662                       0000479F            .3F9:
16663                                           ! 3105           else {
16664 479F           EB           08            jmp .3FB
16665                       000047A1            .3F6:
16666                                           ! 3106             mouse_flags_2 |= 0x80;
16667                                           ! Debug: orab int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16668 47A1           8A46         FC            mov	al,-4[bp]
16669 47A4           0C                     80  or	al,#$80
16670 47A6           8846         FC            mov	-4[bp],al
16671                                           !BCC_EOS
16672                                           ! 3107           }
16673                                           ! 3108           _write_byte(mouse_flags_2, &((ebda_data_t *) 0)->mouse_flag2, ebda_seg);
16674                       000047A9            .3FB:
16675                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
16676 47A9           FF76         FE            push	-2[bp]
16677                                           ! Debug: list * unsigned char = const $27 (used reg = )
16678 47AC           B8                   0027  mov	ax,*$27
16679 47AF           50                         push	ax
16680                                           ! Debug: list unsigned char mouse_flags_2 = [S+$14-6] (used reg = )
16681 47B0           8A46         FC            mov	al,-4[bp]
16682 47B3           30E4                       xor	ah,ah
16683 47B5           50                         push	ax
16684                                           ! Debug: func () void = _write_byte+0 (used reg = )
16685 47B6           E8         BE47            call	__write_byte
16686 47B9           83C4                   06  add	sp,*6
16687                                           !BCC_EOS
16688                                           ! 3109           FLAGS &= 0xfffe;
16689                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16690 47BC           8B46         18            mov	ax,$18[bp]
16691 47BF           24                     FE  and	al,#$FE
16692 47C1           8946         18            mov	$18[bp],ax
16693                                           !BCC_EOS
16694                                           ! 3110           regs.u.r8.ah = 0;
16695                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16696 47C4           30C0                       xor	al,al
16697 47C6           8846         13            mov	$13[bp],al
16698                                           !BCC_EOS
16699                                           ! 3111           break;
16700 47C9           EB           34            jmp .386
16701                                           !BCC_EOS
16702                                           ! 3112         default:
16703                                           ! 3113 ;
16704                       000047CB            .3FC:
16705                                           !BCC_EOS
16706                                           ! 3114           regs.u.r8.ah = 1;
16707                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
16708 47CB           B0                     01  mov	al,*1
16709 47CD           8846         13            mov	$13[bp],al
16710                                           !BCC_EOS
16711                                           ! 3115           FLAGS |= 0x0001;
16712                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16713 47D0           8B46         18            mov	ax,$18[bp]
16714 47D3           0C                     01  or	al,*1
16715 47D5           8946         18            mov	$18[bp],ax
16716                                           !BCC_EOS
16717                                           ! 3116       }
16718                                           ! 3117       break;
16719 47D8           EB           25            jmp .386
16720                       000047DA            .388:
16721 47DA           2C                     00  sub	al,*0
16722 47DC           72           ED            jb 	.3FC
16723 47DE           3C                     07  cmp	al,*7
16724 47E0           77           1B            ja  	.3FD
16725 47E2           30E4                       xor	ah,ah
16726 47E4           D1E0                       shl	ax,*1
16727 47E6           89C3                       mov	bx,ax
16728 47E8           2E                         seg	cs
16729 47E9           FFA7       47ED            br	.3FE[bx]
16730                       000047ED            .3FE:
16731 47ED                      41C8            .word	.389
16732 47EF                      42C8            .word	.39C
16733 47F1                      43F2            .word	.3B0
16734 47F3                      44C0            .word	.3C4
16735 47F5                      4577            .word	.3D1
16736 47F7                      42C8            .word	.39D
16737 47F9                      45CA            .word	.3D5
16738 47FB                      4741            .word	.3F5
16739                       000047FD            .3FD:
16740 47FD           EB           CC            jmp	.3FC
16741                       000047FF            .386:
16742 47FF           EB           2D            jmp .382
16743                                           !BCC_EOS
16744                                           ! 3118     default:
16745                                           ! 3119       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
16746                       00004801            .3FF:
16747                                           ! Debug: list unsigned short regs = [S+$10+$A] (used reg = )
16748 4801           FF76         0C            push	$C[bp]
16749                                           ! Debug: list unsigned short regs = [S+$12+$10] (used reg = )
16750 4804           FF76         12            push	$12[bp]
16751                                           ! Debug: list * char = .400+0 (used reg = )
16752 4807           BB                   D3F3  mov	bx,#.400
16753 480A           53                         push	bx
16754                                           ! Debug: list int = const 4 (used reg = )
16755 480B           B8                   0004  mov	ax,*4
16756 480E           50                         push	ax
16757                                           ! Debug: func () void = bios_printf+0 (used reg = )
16758 480F           E8         C12C            call	_bios_printf
16759 4812           83C4                   08  add	sp,*8
16760                                           !BCC_EOS
16761                                           ! 3120       FLAGS |= 0x0001;
16762                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16763 4815           8B46         18            mov	ax,$18[bp]
16764 4818           0C                     01  or	al,*1
16765 481A           8946         18            mov	$18[bp],ax
16766                                           !BCC_EOS
16767                                           ! 3121       regs.u.r8.ah = 0x86;
16768                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16769 481D           B0                     86  mov	al,#$86
16770 481F           8846         13            mov	$13[bp],al
16771                                           !BCC_EOS
16772                                           ! 3122       break;
16773 4822           EB           0A            jmp .382
16774                                           !BCC_EOS
16775                                           ! 3123   }
16776                                           ! 3124 }
16777 4824           EB           08            jmp .382
16778                       00004826            .384:
16779 4826           2C                     C2  sub	al,#$C2
16780 4828         0F84         F996            beq 	.385
16781 482C           EB           D3            jmp	.3FF
16782                       0000482E            .382:
16783                       FFFFFFF0            ..FFF6	=	-$10
16784 482E           89EC                       mov	sp,bp
16785 4830           5D                         pop	bp
16786 4831           C3                         ret
16787                                           ! 3125 void set_e820_range(ES, DI, start, end, extra_start, extra_end, type)
16788                                           ! Register BX used in function int15_function_mouse
16789                                           ! 3126      Bit16u ES;
16790                                           export	_set_e820_range
16791                       00004832            _set_e820_range:
16792                                           !BCC_EOS
16793                                           ! 3127      Bit16u DI;
16794                                           !BCC_EOS
16795                                           ! 3128      Bit32u start;
16796                                           !BCC_EOS
16797                                           ! 3129      Bit32u end;
16798                                           !BCC_EOS
16799                                           ! 3130      Bit8u extra_start;
16800                                           !BCC_EOS
16801                                           ! 3131      Bit8u extra_end;
16802                                           !BCC_EOS
16803                                           ! 3132      Bit16u type;
16804                                           !BCC_EOS
16805                                           ! 3133 {
16806                                           ! 3134     Bit16u old_ds = set_DS(ES);
16807 4832           55                         push	bp
16808 4833           89E5                       mov	bp,sp
16809 4835           4C                         dec	sp
16810 4836           4C                         dec	sp
16811                                           ! Debug: list unsigned short ES = [S+4+2] (used reg = )
16812 4837           FF76         04            push	4[bp]
16813                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
16814 483A           E8         BE25            call	_set_DS
16815 483D           44                         inc	sp
16816 483E           44                         inc	sp
16817                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+4-4] (used reg = )
16818 483F           8946         FE            mov	-2[bp],ax
16819                                           !BCC_EOS
16820                                           ! 3135     *((Bit32u *)(DI)) = (start);
16821 4842           8B5E         06            mov	bx,6[bp]
16822                                           ! Debug: eq unsigned long start = [S+4+6] to unsigned long = [bx+0] (used reg = )
16823 4845           8B46         08            mov	ax,8[bp]
16824 4848           8B76         0A            mov	si,$A[bp]
16825 484B           8907                       mov	[bx],ax
16826 484D           8977         02            mov	2[bx],si
16827                                           !BCC_EOS
16828                                           ! 3136     *((Bit16u *)(DI+4)) = (extra_start);
16829                                           ! Debug: add int = const 4 to unsigned short DI = [S+4+4] (used reg = )
16830 4850           8B46         06            mov	ax,6[bp]
16831                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+4 (used reg = )
16832 4853           89C3                       mov	bx,ax
16833                                           ! Debug: eq unsigned char extra_start = [S+4+$E] to unsigned short = [bx+4] (used reg = )
16834 4855           8A46         10            mov	al,$10[bp]
16835 4858           30E4                       xor	ah,ah
16836 485A           8947         04            mov	4[bx],ax
16837                                           !BCC_EOS
16838                                           ! 3137     *((Bit16u *)(DI+6)) = (0x00);
16839                                           ! Debug: add int = const 6 to unsigned short DI = [S+4+4] (used reg = )
16840 485D           8B46         06            mov	ax,6[bp]
16841                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+6 (used reg = )
16842 4860           89C3                       mov	bx,ax
16843                                           ! Debug: eq int = const 0 to unsigned short = [bx+6] (used reg = )
16844 4862           31C0                       xor	ax,ax
16845 4864           8947         06            mov	6[bx],ax
16846                                           !BCC_EOS
16847                                           ! 3138     end -= start;
16848                                           ! Debug: subab unsigned long start = [S+4+6] to unsigned long end = [S+4+$A] (used reg = )
16849 4867           8B46         0C            mov	ax,$C[bp]
16850 486A           8B5E         0E            mov	bx,$E[bp]
16851 486D           8D7E         08            lea	di,8[bp]
16852 4870           E8         B83F            call	lsubul
16853 4873           8946         0C            mov	$C[bp],ax
16854 4876           895E         0E            mov	$E[bp],bx
16855                                           !BCC_EOS
16856                                           ! 3139     extra_end -= extra_start;
16857                                           ! Debug: subab unsigned char extra_start = [S+4+$E] to unsigned char extra_end = [S+4+$10] (used reg = )
16858 4879           8A46         12            mov	al,$12[bp]
16859 487C           30E4                       xor	ah,ah
16860 487E           2A46         10            sub	al,$10[bp]
16861 4881           80DC                   00  sbb	ah,*0
16862 4884           8846         12            mov	$12[bp],al
16863                                           !BCC_EOS
16864                                           ! 3140     *((Bit32u *)(DI+8)) = (end);
16865                                           ! Debug: add int = const 8 to unsigned short DI = [S+4+4] (used reg = )
16866 4887           8B46         06            mov	ax,6[bp]
16867                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+8 (used reg = )
16868 488A           89C3                       mov	bx,ax
16869                                           ! Debug: eq unsigned long end = [S+4+$A] to unsigned long = [bx+8] (used reg = )
16870 488C           8B46         0C            mov	ax,$C[bp]
16871 488F           8B76         0E            mov	si,$E[bp]
16872 4892           8947         08            mov	8[bx],ax
16873 4895           8977         0A            mov	$A[bx],si
16874                                           !BCC_EOS
16875                                           ! 3141     *((Bit16u *)(DI+12)) = (extra_end);
16876                                           ! Debug: add int = const $C to unsigned short DI = [S+4+4] (used reg = )
16877 4898           8B46         06            mov	ax,6[bp]
16878                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$C (used reg = )
16879 489B           89C3                       mov	bx,ax
16880                                           ! Debug: eq unsigned char extra_end = [S+4+$10] to unsigned short = [bx+$C] (used reg = )
16881 489D           8A46         12            mov	al,$12[bp]
16882 48A0           30E4                       xor	ah,ah
16883 48A2           8947         0C            mov	$C[bx],ax
16884                                           !BCC_EOS
16885                                           ! 3142     *((Bit16u *)(DI+14)) = (0x0000);
16886                                           ! Debug: add int = const $E to unsigned short DI = [S+4+4] (used reg = )
16887 48A5           8B46         06            mov	ax,6[bp]
16888                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$E (used reg = )
16889 48A8           89C3                       mov	bx,ax
16890                                           ! Debug: eq int = const 0 to unsigned short = [bx+$E] (used reg = )
16891 48AA           31C0                       xor	ax,ax
16892 48AC           8947         0E            mov	$E[bx],ax
16893                                           !BCC_EOS
16894                                           ! 3143     *((Bit16u *)(DI+16)) = (type);
16895                                           ! Debug: add int = const $10 to unsigned short DI = [S+4+4] (used reg = )
16896 48AF           8B46         06            mov	ax,6[bp]
16897                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$10 (used reg = )
16898 48B2           89C3                       mov	bx,ax
16899                                           ! Debug: eq unsigned short type = [S+4+$12] to unsigned short = [bx+$10] (used reg = )
16900 48B4           8B46         14            mov	ax,$14[bp]
16901 48B7           8947         10            mov	$10[bx],ax
16902                                           !BCC_EOS
16903                                           ! 3144     *((Bit16u *)(DI+18)) = (0x0);
16904                                           ! Debug: add int = const $12 to unsigned short DI = [S+4+4] (used reg = )
16905 48BA           8B46         06            mov	ax,6[bp]
16906                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$12 (used reg = )
16907 48BD           89C3                       mov	bx,ax
16908                                           ! Debug: eq int = const 0 to unsigned short = [bx+$12] (used reg = )
16909 48BF           31C0                       xor	ax,ax
16910 48C1           8947         12            mov	$12[bx],ax
16911                                           !BCC_EOS
16912                                           ! 3145     set_DS(old_ds);
16913                                           ! Debug: list unsigned short old_ds = [S+4-4] (used reg = )
16914 48C4           FF76         FE            push	-2[bp]
16915                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
16916 48C7           E8         BD98            call	_set_DS
16917 48CA           44                         inc	sp
16918 48CB           44                         inc	sp
16919                                           !BCC_EOS
16920                                           ! 3146 }
16921 48CC           89EC                       mov	sp,bp
16922 48CE           5D                         pop	bp
16923 48CF           C3                         ret
16924                                           ! 3147   void
16925                                           ! Register BX used in function set_e820_range
16926                                           ! 3148 int15_function32(regs, ES, DS, FLAGS)
16927                                           ! 3149   pushad_regs_t regs;
16928                                           export	_int15_function32
16929                       000048D0            _int15_function32:
16930                                           !BCC_EOS
16931                                           ! 3150   Bit16u ES, DS, FLAGS;
16932                                           !BCC_EOS
16933                                           ! 3151 {
16934                                           ! 3152   Bit32u extended_memory_size=0;
16935 48D0           55                         push	bp
16936 48D1           89E5                       mov	bp,sp
16937 48D3           83C4                   FC  add	sp,*-4
16938                                           ! Debug: eq int = const 0 to unsigned long extended_memory_size = [S+6-6] (used reg = )
16939 48D6           31C0                       xor	ax,ax
16940 48D8           31DB                       xor	bx,bx
16941 48DA           8946         FC            mov	-4[bp],ax
16942 48DD           895E         FE            mov	-2[bp],bx
16943                                           !BCC_EOS
16944                                           ! 3153   Bit32u extra_lowbits_memory_size=0;
16945 48E0           83C4                   FC  add	sp,*-4
16946                                           ! Debug: eq int = const 0 to unsigned long extra_lowbits_memory_size = [S+$A-$A] (used reg = )
16947 48E3           31C0                       xor	ax,ax
16948 48E5           31DB                       xor	bx,bx
16949 48E7           8946         F8            mov	-8[bp],ax
16950 48EA           895E         FA            mov	-6[bp],bx
16951                                           !BCC_EOS
16952                                           ! 3154   Bit16u CX,DX;
16953                                           !BCC_EOS
16954                                           ! 3155   Bit8u extra_highbits_memory_size=0;
16955 48ED           83C4                   FB  add	sp,*-5
16956                                           ! Debug: eq int = const 0 to unsigned char extra_highbits_memory_size = [S+$F-$F] (used reg = )
16957 48F0           30C0                       xor	al,al
16958 48F2           8846         F3            mov	-$D[bp],al
16959                                           !BCC_EOS
16960                                           ! 3156 ;
16961 48F5           4C                         dec	sp
16962                                           !BCC_EOS
16963                                           ! 3157   switch (regs.u.r8.ah) {
16964 48F6           8A46         21            mov	al,$21[bp]
16965 48F9           E9         0477            br 	.403
16966                                           ! 3158     case 0x86:
16967                                           ! 3159       CX = regs.u.r16.cx;
16968                       000048FC            .404:
16969                                           ! Debug: eq unsigned short regs = [S+$10+$1A] to unsigned short CX = [S+$10-$C] (used reg = )
16970 48FC           8B46         1C            mov	ax,$1C[bp]
16971 48FF           8946         F6            mov	-$A[bp],ax
16972                                           !BCC_EOS
16973                                           ! 3160       DX = regs.u.r16.dx;
16974                                           ! Debug: eq unsigned short regs = [S+$10+$16] to unsigned short DX = [S+$10-$E] (used reg = )
16975 4902           8B46         18            mov	ax,$18[bp]
16976 4905           8946         F4            mov	-$C[bp],ax
16977                                           !BCC_EOS
16978                                           ! 3161 #asm
16979                                           !BCC_EOS
16980                                           !BCC_ASM
16981                       00000004            _int15_function32.CX	set	4
16982                       FFFFFFF6            .int15_function32.CX	set	-$A
16983                       00000001            _int15_function32.extra_highbits_memory_size	set	1
16984                       FFFFFFF3            .int15_function32.extra_highbits_memory_size	set	-$D
16985                       00000006            _int15_function32.extra_lowbits_memory_size	set	6
16986                       FFFFFFF8            .int15_function32.extra_lowbits_memory_size	set	-8
16987                       0000000A            _int15_function32.extended_memory_size	set	$A
16988                       FFFFFFFC            .int15_function32.extended_memory_size	set	-4
16989                       00000036            _int15_function32.FLAGS	set	$36
16990                       00000028            .int15_function32.FLAGS	set	$28
16991                       00000034            _int15_function32.DS	set	$34
16992                       00000026            .int15_function32.DS	set	$26
16993                       00000002            _int15_function32.DX	set	2
16994                       FFFFFFF4            .int15_function32.DX	set	-$C
16995                       00000032            _int15_function32.ES	set	$32
16996                       00000024            .int15_function32.ES	set	$24
16997                       00000012            _int15_function32.regs	set	$12
16998                       00000004            .int15_function32.regs	set	4
16999 4908           FB                               sti
17000                                                 ;; Get the count in eax
17001 4909           89E3                             mov bx, sp
17002 490B           36                               SEG SS
17003 490C           8B47         04                    mov ax, _int15_function32.CX [bx]
17004 490F     66    C1E0                   10        shl eax, #16
17005 4913           36                               SEG SS
17006 4914           8B47         02                    mov ax, _int15_function32.DX [bx]
17007                                                 ;; convert to numbers of 15usec ticks
17008 4917     66    BB               0000000F        mov ebx, #15
17009 491D     66    31D2                             xor edx, edx
17010 4920     66    F7F3                             div eax, ebx
17011 4923     66    89C1                             mov ecx, eax
17012                                                 ;; wait for ecx number of refresh requests
17013 4926           E4                     61        in al, 0x0061
17014 4928           24                     10        and al,#0x10
17015 492A           88C4                             mov ah, al
17016 492C     66    09C9                             or ecx, ecx
17017 492F           74           0E                  je int1586_tick_end
17018                       00004931            int1586_tick:
17019 4931           E4                     61        in al, 0x0061
17020 4933           24                     10        and al,#0x10
17021 4935           38E0                             cmp al, ah
17022 4937           74           F8                  je int1586_tick
17023 4939           88C4                             mov ah, al
17024 493B     66    49                               dec ecx
17025 493D           75           F2                  jnz int1586_tick
17026                       0000493F            int1586_tick_end:
17027                                           ! 3190 endasm
17028                                           !BCC_ENDASM
17029                                           !BCC_EOS
17030                                           ! 3191       break;
17031 493F           E9         043F            br 	.401
17032                                           !BCC_EOS
17033                                           ! 3192     case 0xe8:
17034                                           ! 3193         switch(regs.u.r8.al) {
17035                       00004942            .405:
17036 4942           8A46         20            mov	al,$20[bp]
17037 4945           E9         03F8            br 	.408
17038                                           ! 3194          case 0x20:
17039                                           ! 3195             if (regs.u.r32.edx == 0x534D4150) {
17040                       00004948            .409:
17041                                           ! Debug: logeq long = const $534D4150 to unsigned long regs = [S+$10+$16] (used reg = )
17042                                           ! Debug: expression subtree swapping
17043 4948           B8                   4150  mov	ax,#$4150
17044 494B           BB                   534D  mov	bx,#$534D
17045 494E           53                         push	bx
17046 494F           50                         push	ax
17047 4950           8B46         18            mov	ax,$18[bp]
17048 4953           8B5E         1A            mov	bx,$1A[bp]
17049 4956           8D7E         EE            lea	di,-2+..FFF5[bp]
17050 4959           E8         B740            call	lcmpul
17051 495C           8D66         F2            lea	sp,2+..FFF5[bp]
17052 495F         0F85         0379            bne 	.40A
17053                       00004963            .40B:
17054                                           ! 3196                 *((Bit8u *)&extended_memory_size) = inb_cmos(0x34);
17055                                           ! Debug: list int = const $34 (used reg = )
17056 4963           B8                   0034  mov	ax,*$34
17057 4966           50                         push	ax
17058                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17059 4967           E8         BBD3            call	_inb_cmos
17060 496A           44                         inc	sp
17061 496B           44                         inc	sp
17062                                           ! Debug: eq unsigned char = al+0 to unsigned char extended_memory_size = [S+$10-6] (used reg = )
17063 496C           8846         FC            mov	-4[bp],al
17064                                           !BCC_EOS
17065                                           ! 3197                 *(((Bit8u *)&*((Bit16u *)&extended_memory_size))+1) = inb_cmos(0x35);
17066                                           ! Debug: list int = const $35 (used reg = )
17067 496F           B8                   0035  mov	ax,*$35
17068 4972           50                         push	ax
17069                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17070 4973           E8         BBC7            call	_inb_cmos
17071 4976           44                         inc	sp
17072 4977           44                         inc	sp
17073                                           ! Debug: eq unsigned char = al+0 to unsigned char extended_memory_size = [S+$10-5] (used reg = )
17074 4978           8846         FD            mov	-3[bp],al
17075                                           !BCC_EOS
17076                                           ! 3198                 extended_memory_size *= 64;
17077                                           ! Debug: mulab unsigned long = const $40 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17078 497B           B8                   0040  mov	ax,*$40
17079 497E           31DB                       xor	bx,bx
17080 4980           53                         push	bx
17081 4981           50                         push	ax
17082 4982           8B46         FC            mov	ax,-4[bp]
17083 4985           8B5E         FE            mov	bx,-2[bp]
17084 4988           8D7E         EE            lea	di,-2+..FFF5[bp]
17085 498B           E8         B72C            call	lmulul
17086 498E           8946         FC            mov	-4[bp],ax
17087 4991           895E         FE            mov	-2[bp],bx
17088 4994           83C4                   04  add	sp,*4
17089                                           !BCC_EOS
17090                                           ! 3199                 if (extended_memory_size > 0x2fc000) {
17091                                           ! Debug: gt long = const $2FC000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17092 4997           B8                   C000  mov	ax,#$C000
17093 499A           BB                   002F  mov	bx,*$2F
17094 499D           8D7E         FC            lea	di,-4[bp]
17095 49A0           E8         B6F9            call	lcmpul
17096 49A3           73           0C            jae 	.40C
17097                       000049A5            .40D:
17098                                           ! 3200                     extended_memory_size = 0x2fc000;
17099                                           ! Debug: eq long = const $2FC000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17100 49A5           B8                   C000  mov	ax,#$C000
17101 49A8           BB                   002F  mov	bx,*$2F
17102 49AB           8946         FC            mov	-4[bp],ax
17103 49AE           895E         FE            mov	-2[bp],bx
17104                                           !BCC_EOS
17105                                           ! 3201                 }
17106                                           ! 3202                 extended_memory_size *= 1024;
17107                       000049B1            .40C:
17108                                           ! Debug: mulab unsigned long = const $400 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17109 49B1           B8                   0400  mov	ax,#$400
17110 49B4           31DB                       xor	bx,bx
17111 49B6           53                         push	bx
17112 49B7           50                         push	ax
17113 49B8           8B46         FC            mov	ax,-4[bp]
17114 49BB           8B5E         FE            mov	bx,-2[bp]
17115 49BE           8D7E         EE            lea	di,-2+..FFF5[bp]
17116 49C1           E8         B6F6            call	lmulul
17117 49C4           8946         FC            mov	-4[bp],ax
17118 49C7           895E         FE            mov	-2[bp],bx
17119 49CA           83C4                   04  add	sp,*4
17120                                           !BCC_EOS
17121                                           ! 3203                 extended_memory_size += (16L * 1024 * 1024);
17122                                           ! Debug: addab long = const $1000000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17123 49CD           31C0                       xor	ax,ax
17124 49CF           BB                   0100  mov	bx,#$100
17125 49D2           53                         push	bx
17126 49D3           50                         push	ax
17127 49D4           8B46         FC            mov	ax,-4[bp]
17128 49D7           8B5E         FE            mov	bx,-2[bp]
17129 49DA           8D7E         EE            lea	di,-2+..FFF5[bp]
17130 49DD           E8         B6B4            call	laddul
17131 49E0           8946         FC            mov	-4[bp],ax
17132 49E3           895E         FE            mov	-2[bp],bx
17133 49E6           83C4                   04  add	sp,*4
17134                                           !BCC_EOS
17135                                           ! 3204                 if (extended_memory_size <= (16L * 1024 * 1024)) {
17136                                           ! Debug: le long = const $1000000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17137 49E9           31C0                       xor	ax,ax
17138 49EB           BB                   0100  mov	bx,#$100
17139 49EE           8D7E         FC            lea	di,-4[bp]
17140 49F1           E8         B6A8            call	lcmpul
17141 49F4           72           50            jb  	.40E
17142                       000049F6            .40F:
17143                                           ! 3205                     *((Bit8u *)&extended_memory_size) = inb_cmos(0x30);
17144                                           ! Debug: list int = const $30 (used reg = )
17145 49F6           B8                   0030  mov	ax,*$30
17146 49F9           50                         push	ax
17147                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17148 49FA           E8         BB40            call	_inb_cmos
17149 49FD           44                         inc	sp
17150 49FE           44                         inc	sp
17151                                           ! Debug: eq unsigned char = al+0 to unsigned char extended_memory_size = [S+$10-6] (used reg = )
17152 49FF           8846         FC            mov	-4[bp],al
17153                                           !BCC_EOS
17154                                           ! 3206                     *(((Bit8u *)&*((Bit16u *)&extended_memory_size))+1) = inb_cmos(0x31);
17155                                           ! Debug: list int = const $31 (used reg = )
17156 4A02           B8                   0031  mov	ax,*$31
17157 4A05           50                         push	ax
17158                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17159 4A06           E8         BB34            call	_inb_cmos
17160 4A09           44                         inc	sp
17161 4A0A           44                         inc	sp
17162                                           ! Debug: eq unsigned char = al+0 to unsigned char extended_memory_size = [S+$10-5] (used reg = )
17163 4A0B           8846         FD            mov	-3[bp],al
17164                                           !BCC_EOS
17165                                           ! 3207                     extended_memory_size *= 1024;
17166                                           ! Debug: mulab unsigned long = const $400 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17167 4A0E           B8                   0400  mov	ax,#$400
17168 4A11           31DB                       xor	bx,bx
17169 4A13           53                         push	bx
17170 4A14           50                         push	ax
17171 4A15           8B46         FC            mov	ax,-4[bp]
17172 4A18           8B5E         FE            mov	bx,-2[bp]
17173 4A1B           8D7E         EE            lea	di,-2+..FFF5[bp]
17174 4A1E           E8         B699            call	lmulul
17175 4A21           8946         FC            mov	-4[bp],ax
17176 4A24           895E         FE            mov	-2[bp],bx
17177 4A27           83C4                   04  add	sp,*4
17178                                           !BCC_EOS
17179                                           ! 3208                     extended_memory_size += (1L * 1024 * 1024);
17180                                           ! Debug: addab long = const $100000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17181 4A2A           31C0                       xor	ax,ax
17182 4A2C           BB                   0010  mov	bx,*$10
17183 4A2F           53                         push	bx
17184 4A30           50                         push	ax
17185 4A31           8B46         FC            mov	ax,-4[bp]
17186 4A34           8B5E         FE            mov	bx,-2[bp]
17187 4A37           8D7E         EE            lea	di,-2+..FFF5[bp]
17188 4A3A           E8         B657            call	laddul
17189 4A3D           8946         FC            mov	-4[bp],ax
17190 4A40           895E         FE            mov	-2[bp],bx
17191 4A43           83C4                   04  add	sp,*4
17192                                           !BCC_EOS
17193                                           ! 3209                 }
17194                                           ! 3210                 *((Bit8u *)&*(((Bit16u *)&extra_lowbits_memory_size)+1)) = inb_cmos(0x5b);
17195                       00004A46            .40E:
17196                                           ! Debug: list int = const $5B (used reg = )
17197 4A46           B8                   005B  mov	ax,*$5B
17198 4A49           50                         push	ax
17199                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17200 4A4A           E8         BAF0            call	_inb_cmos
17201 4A4D           44                         inc	sp
17202 4A4E           44                         inc	sp
17203                                           ! Debug: eq unsigned char = al+0 to unsigned char extra_lowbits_memory_size = [S+$10-8] (used reg = )
17204 4A4F           8846         FA            mov	-6[bp],al
17205                                           !BCC_EOS
17206                                           ! 3211                 *(((Bit8u *)&*(((Bit16u *)&extra_lowbits_memory_size)+1))+1) = inb_cmos(0x5c);
17207                                           ! Debug: list int = const $5C (used reg = )
17208 4A52           B8                   005C  mov	ax,*$5C
17209 4A55           50                         push	ax
17210                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17211 4A56           E8         BAE4            call	_inb_cmos
17212 4A59           44                         inc	sp
17213 4A5A           44                         inc	sp
17214                                           ! Debug: eq unsigned char = al+0 to unsigned char extra_lowbits_memory_size = [S+$10-7] (used reg = )
17215 4A5B           8846         FB            mov	-5[bp],al
17216                                           !BCC_EOS
17217                                           ! 3212                 *((Bit16u *)&extra_lowbits_memory_size) = 0;
17218                                           ! Debug: eq int = const 0 to unsigned short extra_lowbits_memory_size = [S+$10-$A] (used reg = )
17219 4A5E           31C0                       xor	ax,ax
17220 4A60           8946         F8            mov	-8[bp],ax
17221                                           !BCC_EOS
17222                                           ! 3213                 extra_highbits_memory_size = inb_cmos(0x5d);
17223                                           ! Debug: list int = const $5D (used reg = )
17224 4A63           B8                   005D  mov	ax,*$5D
17225 4A66           50                         push	ax
17226                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17227 4A67           E8         BAD3            call	_inb_cmos
17228 4A6A           44                         inc	sp
17229 4A6B           44                         inc	sp
17230                                           ! Debug: eq unsigned char = al+0 to unsigned char extra_highbits_memory_size = [S+$10-$F] (used reg = )
17231 4A6C           8846         F3            mov	-$D[bp],al
17232                                           !BCC_EOS
17233                                           ! 3214                 switch(regs.u.r16.bx)
17234 4A6F           8B46         14            mov	ax,$14[bp]
17235                                           ! 3215                 {
17236 4A72           E9         0221            br 	.412
17237                                           ! 3216                     case 0:
17238                                           ! 3217                         set_e820_range(ES, regs.u.r16.di,
17239                       00004A75            .413:
17240                                           ! 3218                                        0x0000000L, 0x0009f000L, 0, 0, 1);
17241                                           ! Debug: list int = const 1 (used reg = )
17242 4A75           B8                   0001  mov	ax,*1
17243 4A78           50                         push	ax
17244                                           ! Debug: list int = const 0 (used reg = )
17245 4A79           31C0                       xor	ax,ax
17246 4A7B           50                         push	ax
17247                                           ! Debug: list int = const 0 (used reg = )
17248 4A7C           31C0                       xor	ax,ax
17249 4A7E           50                         push	ax
17250                                           ! Debug: list long = const $9F000 (used reg = )
17251 4A7F           B8                   F000  mov	ax,#$F000
17252 4A82           BB                   0009  mov	bx,*9
17253 4A85           53                         push	bx
17254 4A86           50                         push	ax
17255                                           ! Debug: list long = const 0 (used reg = )
17256 4A87           31C0                       xor	ax,ax
17257 4A89           31DB                       xor	bx,bx
17258 4A8B           53                         push	bx
17259 4A8C           50                         push	ax
17260                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17261 4A8D           FF76         04            push	4[bp]
17262                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17263 4A90           FF76         24            push	$24[bp]
17264                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17265 4A93           E8         FD9C            call	_set_e820_range
17266 4A96           83C4                   12  add	sp,*$12
17267                                           !BCC_EOS
17268                                           ! 3219                         regs.u.r32.ebx = 1;
17269                                           ! Debug: eq int = const 1 to unsigned long regs = [S+$10+$12] (used reg = )
17270 4A99           B8                   0001  mov	ax,*1
17271 4A9C           31DB                       xor	bx,bx
17272 4A9E           8946         14            mov	$14[bp],ax
17273 4AA1           895E         16            mov	$16[bp],bx
17274                                           !BCC_EOS
17275                                           ! 3220           
17276                                           ! 3220               break;
17277 4AA4           E9         0214            br 	.410
17278                                           !BCC_EOS
17279                                           ! 3221                     case 1:
17280                                           ! 3222                         set_e820_range(ES, regs.u.r16.di,
17281                       00004AA7            .414:
17282                                           ! 3223                                        0x0009f000L, 0x000a0000L, 0, 0, 2);
17283                                           ! Debug: list int = const 2 (used reg = )
17284 4AA7           B8                   0002  mov	ax,*2
17285 4AAA           50                         push	ax
17286                                           ! Debug: list int = const 0 (used reg = )
17287 4AAB           31C0                       xor	ax,ax
17288 4AAD           50                         push	ax
17289                                           ! Debug: list int = const 0 (used reg = )
17290 4AAE           31C0                       xor	ax,ax
17291 4AB0           50                         push	ax
17292                                           ! Debug: list long = const $A0000 (used reg = )
17293 4AB1           31C0                       xor	ax,ax
17294 4AB3           BB                   000A  mov	bx,*$A
17295 4AB6           53                         push	bx
17296 4AB7           50                         push	ax
17297                                           ! Debug: list long = const $9F000 (used reg = )
17298 4AB8           B8                   F000  mov	ax,#$F000
17299 4ABB           BB                   0009  mov	bx,*9
17300 4ABE           53                         push	bx
17301 4ABF           50                         push	ax
17302                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17303 4AC0           FF76         04            push	4[bp]
17304                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17305 4AC3           FF76         24            push	$24[bp]
17306                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17307 4AC6           E8         FD69            call	_set_e820_range
17308 4AC9           83C4                   12  add	sp,*$12
17309                                           !BCC_EOS
17310                                           ! 3224                         regs.u.r32.ebx = 2;
17311                                           ! Debug: eq int = const 2 to unsigned long regs = [S+$10+$12] (used reg = )
17312 4ACC           B8                   0002  mov	ax,*2
17313 4ACF           31DB                       xor	bx,bx
17314 4AD1           8946         14            mov	$14[bp],ax
17315 4AD4           895E         16            mov	$16[bp],bx
17316                                           !BCC_EOS
17317                                           ! 3225                         break;
17318 4AD7           E9         01E1            br 	.410
17319                                           !BCC_EOS
17320                                           ! 3226                     case 2:
17321                                           ! 3227                         set_e820_range(ES, regs.u.r16.di,
17322                       00004ADA            .415:
17323                                           ! 3228                                        0x000e8000L, 0x00100000L, 0, 0, 2);
17324                                           ! Debug: list int = const 2 (used reg = )
17325 4ADA           B8                   0002  mov	ax,*2
17326 4ADD           50                         push	ax
17327                                           ! Debug: list int = const 0 (used reg = )
17328 4ADE           31C0                       xor	ax,ax
17329 4AE0           50                         push	ax
17330                                           ! Debug: list int = const 0 (used reg = )
17331 4AE1           31C0                       xor	ax,ax
17332 4AE3           50                         push	ax
17333                                           ! Debug: list long = const $100000 (used reg = )
17334 4AE4           31C0                       xor	ax,ax
17335 4AE6           BB                   0010  mov	bx,*$10
17336 4AE9           53                         push	bx
17337 4AEA           50                         push	ax
17338                                           ! Debug: list long = const $E8000 (used reg = )
17339 4AEB           B8                   8000  mov	ax,#$8000
17340 4AEE           BB                   000E  mov	bx,*$E
17341 4AF1           53                         push	bx
17342 4AF2           50                         push	ax
17343                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17344 4AF3           FF76         04            push	4[bp]
17345                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17346 4AF6           FF76         24            push	$24[bp]
17347                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17348 4AF9           E8         FD36            call	_set_e820_range
17349 4AFC           83C4                   12  add	sp,*$12
17350                                           !BCC_EOS
17351                                           ! 3229                         if (extended_memory_size <= 0x100000)
17352                                           ! Debug: le long = const $100000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
17353 4AFF           31C0                       xor	ax,ax
17354 4B01           BB                   0010  mov	bx,*$10
17355 4B04           8D7E         FC            lea	di,-4[bp]
17356 4B07           E8         B592            call	lcmpul
17357 4B0A           72           0D            jb  	.416
17358                       00004B0C            .417:
17359                                           ! 3230                             regs.u.r32.ebx = 6;
17360                                           ! Debug: eq int = const 6 to unsigned long regs = [S+$10+$12] (used reg = )
17361 4B0C           B8                   0006  mov	ax,*6
17362 4B0F           31DB                       xor	bx,bx
17363 4B11           8946         14            mov	$14[bp],ax
17364 4B14           895E         16            mov	$16[bp],bx
17365                                           !BCC_EOS
17366                                           ! 3231                         else
17367                                           ! 3232                             regs.u.r32.ebx = 3;
17368 4B17           EB           0B            jmp .418
17369                       00004B19            .416:
17370                                           ! Debug: eq int = const 3 to unsigned long regs = [S+$10+$12] (used reg = )
17371 4B19           B8                   0003  mov	ax,*3
17372 4B1C           31DB                       xor	bx,bx
17373 4B1E           8946         14            mov	$14[bp],ax
17374 4B21           895E         16            mov	$16[bp],bx
17375                                           !BCC_EOS
17376                                           ! 3233                         break;
17377                       00004B24            .418:
17378 4B24           E9         0194            br 	.410
17379                                           !BCC_EOS
17380                                           ! 3234                     case 3:
17381                                           ! 3235                         set_e820_range(ES, regs.u.r16.di,
17382                       00004B27            .419:
17383                                           ! 3236                                        0x00100000L,
17384                                           ! 3237                                        extended_memory_size, 0, 0, 1);
17385                                           ! Debug: list int = const 1 (used reg = )
17386 4B27           B8                   0001  mov	ax,*1
17387 4B2A           50                         push	ax
17388                                           ! Debug: list int = const 0 (used reg = )
17389 4B2B           31C0                       xor	ax,ax
17390 4B2D           50                         push	ax
17391                                           ! Debug: list int = const 0 (used reg = )
17392 4B2E           31C0                       xor	ax,ax
17393 4B30           50                         push	ax
17394                                           ! Debug: list unsigned long extended_memory_size = [S+$16-6] (used reg = )
17395 4B31           FF76         FE            push	-2[bp]
17396 4B34           FF76         FC            push	-4[bp]
17397                                           ! Debug: list long = const $100000 (used reg = )
17398 4B37           31C0                       xor	ax,ax
17399 4B39           BB                   0010  mov	bx,*$10
17400 4B3C           53                         push	bx
17401 4B3D           50                         push	ax
17402                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17403 4B3E           FF76         04            push	4[bp]
17404                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17405 4B41           FF76         24            push	$24[bp]
17406                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17407 4B44           E8         FCEB            call	_set_e820_range
17408 4B47           83C4                   12  add	sp,*$12
17409                                           !BCC_EOS
17410                                           ! 3238                         regs.u.r32.ebx = 6;
17411                                           ! Debug: eq int = const 6 to unsigned long regs = [S+$10+$12] (used reg = )
17412 4B4A           B8                   0006  mov	ax,*6
17413 4B4D           31DB                       xor	bx,bx
17414 4B4F           8946         14            mov	$14[bp],ax
17415 4B52           895E         16            mov	$16[bp],bx
17416                                           !BCC_EOS
17417                                           ! 3239                         break;
17418 4B55           E9         0163            br 	.410
17419                                           !BCC_EOS
17420                                           ! 3240                     case 4:
17421                                           ! 3241                         set_e820_range(ES, regs.u.r16.di,
17422                       00004B58            .41A:
17423                                           ! 3242                                        extended_memory_size - 0x00010000L - 0x00002000,
17424                                           ! 3243                                        extended_memory_size - 0x00010000L, 0, 0, 2);
17425                                           ! Debug: list int = const 2 (used reg = )
17426 4B58           B8                   0002  mov	ax,*2
17427 4B5B           50                         push	ax
17428                                           ! Debug: list int = const 0 (used reg = )
17429 4B5C           31C0                       xor	ax,ax
17430 4B5E           50                         push	ax
17431                                           ! Debug: list int = const 0 (used reg = )
17432 4B5F           31C0                       xor	ax,ax
17433 4B61           50                         push	ax
17434                                           ! Debug: sub long = const $10000 to unsigned long extended_memory_size = [S+$16-6] (used reg = )
17435 4B62           31C0                       xor	ax,ax
17436 4B64           BB                   0001  mov	bx,*1
17437 4B67           53                         push	bx
17438 4B68           50                         push	ax
17439 4B69           8B46         FC            mov	ax,-4[bp]
17440 4B6C           8B5E         FE            mov	bx,-2[bp]
17441 4B6F           8D7E         E8            lea	di,-8+..FFF5[bp]
17442 4B72           E8         B53D            call	lsubul
17443 4B75           83C4                   04  add	sp,*4
17444                                           ! Debug: list unsigned long = bx+0 (used reg = )
17445 4B78           53                         push	bx
17446 4B79           50                         push	ax
17447                                           ! Debug: sub long = const $10000 to unsigned long extended_memory_size = [S+$1A-6] (used reg = )
17448 4B7A           31C0                       xor	ax,ax
17449 4B7C           BB                   0001  mov	bx,*1
17450 4B7F           53                         push	bx
17451 4B80           50                         push	ax
17452 4B81           8B46         FC            mov	ax,-4[bp]
17453 4B84           8B5E         FE            mov	bx,-2[bp]
17454 4B87           8D7E         E4            lea	di,-$C+..FFF5[bp]
17455 4B8A           E8         B525            call	lsubul
17456 4B8D           83C4                   04  add	sp,*4
17457                                           ! Debug: sub unsigned long = const $2000 to unsigned long = bx+0 (used reg = )
17458 4B90           53                         push	bx
17459 4B91           50                         push	ax
17460 4B92           B8                   2000  mov	ax,#$2000
17461 4B95           31DB                       xor	bx,bx
17462 4B97           53                         push	bx
17463 4B98           50                         push	ax
17464 4B99           8B46         E4            mov	ax,-$C+..FFF5[bp]
17465 4B9C           8B5E         E6            mov	bx,-$A+..FFF5[bp]
17466 4B9F           8D7E         E0            lea	di,-$10+..FFF5[bp]
17467 4BA2           E8         B50D            call	lsubul
17468 4BA5           83C4                   08  add	sp,*8
17469                                           ! Debug: list unsigned long = bx+0 (used reg = )
17470 4BA8           53                         push	bx
17471 4BA9           50                         push	ax
17472                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17473 4BAA           FF76         04            push	4[bp]
17474                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17475 4BAD           FF76         24            push	$24[bp]
17476                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17477 4BB0           E8         FC7F            call	_set_e820_range
17478 4BB3           83C4                   12  add	sp,*$12
17479                                           !BCC_EOS
17480                                           ! 3244                         regs.u.r32.ebx = 5;
17481                                           ! Debug: eq int = const 5 to unsigned long regs = [S+$10+$12] (used reg = )
17482 4BB6           B8                   0005  mov	ax,*5
17483 4BB9           31DB                       xor	bx,bx
17484 4BBB           8946         14            mov	$14[bp],ax
17485 4BBE           895E         16            mov	$16[bp],bx
17486                                           !BCC_EOS
17487                                           ! 3245                         break;
17488 4BC1           E9         00F7            br 	.410
17489                                           !BCC_EOS
17490                                           ! 3246                     case 5:
17491                                           ! 3247                         set_e820_range(ES, regs.u.r16.di,
17492                       00004BC4            .41B:
17493                                           ! 3248                                        extended_memory_size - 0x00010000L,
17494                                           ! 3249                                        extended_memory_size, 0, 0, 3);
17495                                           ! Debug: list int = const 3 (used reg = )
17496 4BC4           B8                   0003  mov	ax,*3
17497 4BC7           50                         push	ax
17498                                           ! Debug: list int = const 0 (used reg = )
17499 4BC8           31C0                       xor	ax,ax
17500 4BCA           50                         push	ax
17501                                           ! Debug: list int = const 0 (used reg = )
17502 4BCB           31C0                       xor	ax,ax
17503 4BCD           50                         push	ax
17504                                           ! Debug: list unsigned long extended_memory_size = [S+$16-6] (used reg = )
17505 4BCE           FF76         FE            push	-2[bp]
17506 4BD1           FF76         FC            push	-4[bp]
17507                                           ! Debug: sub long = const $10000 to unsigned long extended_memory_size = [S+$1A-6] (used reg = )
17508 4BD4           31C0                       xor	ax,ax
17509 4BD6           BB                   0001  mov	bx,*1
17510 4BD9           53                         push	bx
17511 4BDA           50                         push	ax
17512 4BDB           8B46         FC            mov	ax,-4[bp]
17513 4BDE           8B5E         FE            mov	bx,-2[bp]
17514 4BE1           8D7E         E4            lea	di,-$C+..FFF5[bp]
17515 4BE4           E8         B4CB            call	lsubul
17516 4BE7           83C4                   04  add	sp,*4
17517                                           ! Debug: list unsigned long = bx+0 (used reg = )
17518 4BEA           53                         push	bx
17519 4BEB           50                         push	ax
17520                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17521 4BEC           FF76         04            push	4[bp]
17522                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17523 4BEF           FF76         24            push	$24[bp]
17524                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17525 4BF2           E8         FC3D            call	_set_e820_range
17526 4BF5           83C4                   12  add	sp,*$12
17527                                           !BCC_EOS
17528                                           ! 3250                         regs.u.r32.ebx = 6;
17529                                           ! Debug: eq int = const 6 to unsigned long regs = [S+$10+$12] (used reg = )
17530 4BF8           B8                   0006  mov	ax,*6
17531 4BFB           31DB                       xor	bx,bx
17532 4BFD           8946         14            mov	$14[bp],ax
17533 4C00           895E         16            mov	$16[bp],bx
17534                                           !BCC_EOS
17535                                           ! 3251                         break;
17536 4C03           E9         00B5            br 	.410
17537                                           !BCC_EOS
17538                                           ! 3252                     case 6:
17539                                           ! 3253                         set_e820_range(ES, regs.u.r16.di,
17540                       00004C06            .41C:
17541                                           ! 3254                                        0xfffc0000L, 0x00000000L, 0, 0, 2);
17542                                           ! Debug: list int = const 2 (used reg = )
17543 4C06           B8                   0002  mov	ax,*2
17544 4C09           50                         push	ax
17545                                           ! Debug: list int = const 0 (used reg = )
17546 4C0A           31C0                       xor	ax,ax
17547 4C0C           50                         push	ax
17548                                           ! Debug: list int = const 0 (used reg = )
17549 4C0D           31C0                       xor	ax,ax
17550 4C0F           50                         push	ax
17551                                           ! Debug: list long = const 0 (used reg = )
17552 4C10           31C0                       xor	ax,ax
17553 4C12           31DB                       xor	bx,bx
17554 4C14           53                         push	bx
17555 4C15           50                         push	ax
17556                                           ! Debug: list unsigned long = const $FFFC0000 (used reg = )
17557 4C16           31C0                       xor	ax,ax
17558 4C18           BB                   FFFC  mov	bx,#$FFFC
17559 4C1B           53                         push	bx
17560 4C1C           50                         push	ax
17561                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17562 4C1D           FF76         04            push	4[bp]
17563                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17564 4C20           FF76         24            push	$24[bp]
17565                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17566 4C23           E8         FC0C            call	_set_e820_range
17567 4C26           83C4                   12  add	sp,*$12
17568                                           !BCC_EOS
17569                                           ! 3255                         if (extra_highbits_memory_size || extra_lowbits_memory_size)
17570                                           ! Debug: cast unsigned long = const 0 to unsigned char extra_highbits_memory_size = [S+$10-$F] (used reg = )
17571 4C29           8A46         F3            mov	al,-$D[bp]
17572 4C2C           30E4                       xor	ah,ah
17573 4C2E           31DB                       xor	bx,bx
17574 4C30           E8         B4B2            call	ltstl
17575 4C33           75           0B            jne 	.41E
17576                       00004C35            .41F:
17577 4C35           8B46         F8            mov	ax,-8[bp]
17578 4C38           8B5E         FA            mov	bx,-6[bp]
17579 4C3B           E8         B4A7            call	ltstl
17580 4C3E           74           0D            je  	.41D
17581                       00004C40            .41E:
17582                                           ! 3256                             regs.u.r32.ebx = 7;
17583                                           ! Debug: eq int = const 7 to unsigned long regs = [S+$10+$12] (used reg = )
17584 4C40           B8                   0007  mov	ax,*7
17585 4C43           31DB                       xor	bx,bx
17586 4C45           8946         14            mov	$14[bp],ax
17587 4C48           895E         16            mov	$16[bp],bx
17588                                           !BCC_EOS
17589                                           ! 3257                         else
17590                                           ! 3258                             regs.u.r32.ebx = 0;
17591 4C4B           EB           0A            jmp .420
17592                       00004C4D            .41D:
17593                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$10+$12] (used reg = )
17594 4C4D           31C0                       xor	ax,ax
17595 4C4F           31DB                       xor	bx,bx
17596 4C51           8946         14            mov	$14[bp],ax
17597 4C54           895E         16            mov	$16[bp],bx
17598                                           !BCC_EOS
17599                                           ! 3259                         break;
17600                       00004C57            .420:
17601 4C57           EB           62            jmp .410
17602                                           !BCC_EOS
17603                                           ! 3260                     case 7:
17604                                           ! 3261                         set_e820_range(ES, regs.u.r16.di,
17605                       00004C59            .421:
17606                                           ! 3261  0x00000000L,
17607                                           ! 3262                             extra_lowbits_memory_size, 1, extra_highbits_memory_size
17608                                           ! 3263                                        + 1, 1);
17609                                           ! Debug: list int = const 1 (used reg = )
17610 4C59           B8                   0001  mov	ax,*1
17611 4C5C           50                         push	ax
17612                                           ! Debug: add int = const 1 to unsigned char extra_highbits_memory_size = [S+$12-$F] (used reg = )
17613 4C5D           8A46         F3            mov	al,-$D[bp]
17614 4C60           30E4                       xor	ah,ah
17615                                           ! Debug: list unsigned int = ax+1 (used reg = )
17616 4C62           40                         inc	ax
17617 4C63           50                         push	ax
17618                                           ! Debug: list int = const 1 (used reg = )
17619 4C64           B8                   0001  mov	ax,*1
17620 4C67           50                         push	ax
17621                                           ! Debug: list unsigned long extra_lowbits_memory_size = [S+$16-$A] (used reg = )
17622 4C68           FF76         FA            push	-6[bp]
17623 4C6B           FF76         F8            push	-8[bp]
17624                                           ! Debug: list long = const 0 (used reg = )
17625 4C6E           31C0                       xor	ax,ax
17626 4C70           31DB                       xor	bx,bx
17627 4C72           53                         push	bx
17628 4C73           50                         push	ax
17629                                           ! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
17630 4C74           FF76         04            push	4[bp]
17631                                           ! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
17632 4C77           FF76         24            push	$24[bp]
17633                                           ! Debug: func () void = set_e820_range+0 (used reg = )
17634 4C7A           E8         FBB5            call	_set_e820_range
17635 4C7D           83C4                   12  add	sp,*$12
17636                                           !BCC_EOS
17637                                           ! 3264                         regs.u.r32.ebx = 0;
17638                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$10+$12] (used reg = )
17639 4C80           31C0                       xor	ax,ax
17640 4C82           31DB                       xor	bx,bx
17641 4C84           8946         14            mov	$14[bp],ax
17642 4C87           895E         16            mov	$16[bp],bx
17643                                           !BCC_EOS
17644                                           ! 3265                         break;
17645 4C8A           EB           2F            jmp .410
17646                                           !BCC_EOS
17647                                           ! 3266                     default:
17648                                           ! 3267                         goto int15_unimplemented;
17649                       00004C8C            .422:
17650 4C8C           83C4                   00  add	sp,#..FFF4-..FFF5
17651 4C8F           E9         00BC            br 	.FFF4
17652                                           !BCC_EOS
17653                                           ! 3268                         break;
17654 4C92           EB           27            jmp .410
17655                                           !BCC_EOS
17656                                           ! 3269                 }
17657                                           ! 3270                 regs.u.r32.eax = 0x534D4150;
17658 4C94           EB           25            jmp .410
17659                       00004C96            .412:
17660 4C96           2D                   0000  sub	ax,*0
17661 4C99           7C           F1            jl 	.422
17662 4C9B           3D                   0007  cmp	ax,*7
17663 4C9E           77           19            ja  	.423
17664 4CA0           D1E0                       shl	ax,*1
17665 4CA2           89C3                       mov	bx,ax
17666 4CA4           2E                         seg	cs
17667 4CA5           FFA7       4CA9            br	.424[bx]
17668                       00004CA9            .424:
17669 4CA9                      4A75            .word	.413
17670 4CAB                      4AA7            .word	.414
17671 4CAD                      4ADA            .word	.415
17672 4CAF                      4B27            .word	.419
17673 4CB1                      4B58            .word	.41A
17674 4CB3                      4BC4            .word	.41B
17675 4CB5                      4C06            .word	.41C
17676 4CB7                      4C59            .word	.421
17677                       00004CB9            .423:
17678 4CB9           EB           D1            jmp	.422
17679                       00004CBB            .410:
17680                                           ! Debug: eq long = const $534D4150 to unsigned long regs = [S+$10+$1E] (used reg = )
17681 4CBB           B8                   4150  mov	ax,#$4150
17682 4CBE           BB                   534D  mov	bx,#$534D
17683 4CC1           8946         20            mov	$20[bp],ax
17684 4CC4           895E         22            mov	$22[bp],bx
17685                                           !BCC_EOS
17686                                           ! 3271                 regs.u.r32.ecx = 0x14;
17687                                           ! Debug: eq int = const $14 to unsigned long regs = [S+$10+$1A] (used reg = )
17688 4CC7           B8                   0014  mov	ax,*$14
17689 4CCA           31DB                       xor	bx,bx
17690 4CCC           8946         1C            mov	$1C[bp],ax
17691 4CCF           895E         1E            mov	$1E[bp],bx
17692                                           !BCC_EOS
17693                                           ! 3272                 FLAGS &= 0xfffe;
17694                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$26] (used reg = )
17695 4CD2           8B46         28            mov	ax,$28[bp]
17696 4CD5           24                     FE  and	al,#$FE
17697 4CD7           8946         28            mov	$28[bp],ax
17698                                           !BCC_EOS
17699                                           ! 3273             } else {
17700 4CDA           EB           06            jmp .425
17701                       00004CDC            .40A:
17702                                           ! 3274               goto int15_unimplemented;
17703 4CDC           83C4                   00  add	sp,#..FFF4-..FFF5
17704 4CDF           E9         006C            br 	.FFF4
17705                                           !BCC_EOS
17706                                           ! 3275             }
17707                                           ! 3276             break;
17708                       00004CE2            .425:
17709 4CE2           E9         0067            br 	.406
17710                                           !BCC_EOS
17711                                           ! 3277         case 0x01:
17712                                           ! 3278           FLAGS &= 0xfffe;
17713                       00004CE5            .426:
17714                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$26] (used reg = )
17715 4CE5           8B46         28            mov	ax,$28[bp]
17716 4CE8           24                     FE  and	al,#$FE
17717 4CEA           8946         28            mov	$28[bp],ax
17718                                           !BCC_EOS
17719                                           ! 3279           regs.u.r8.cl = inb_cmos(0x30);
17720                                           ! Debug: list int = const $30 (used reg = )
17721 4CED           B8                   0030  mov	ax,*$30
17722 4CF0           50                         push	ax
17723                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17724 4CF1           E8         B849            call	_inb_cmos
17725 4CF4           44                         inc	sp
17726 4CF5           44                         inc	sp
17727                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$1A] (used reg = )
17728 4CF6           8846         1C            mov	$1C[bp],al
17729                                           !BCC_EOS
17730                                           ! 3280           regs.u.r8.ch = inb_cmos(0x31);
17731                                           ! Debug: list int = const $31 (used reg = )
17732 4CF9           B8                   0031  mov	ax,*$31
17733 4CFC           50                         push	ax
17734                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17735 4CFD           E8         B83D            call	_inb_cmos
17736 4D00           44                         inc	sp
17737 4D01           44                         inc	sp
17738                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$1B] (used reg = )
17739 4D02           8846         1D            mov	$1D[bp],al
17740                                           !BCC_EOS
17741                                           ! 3281           if(regs.u.r16.cx > 0x3c00)
17742                                           ! Debug: gt int = const $3C00 to unsigned short regs = [S+$10+$1A] (used reg = )
17743 4D05           8B46         1C            mov	ax,$1C[bp]
17744 4D08           3D                   3C00  cmp	ax,#$3C00
17745 4D0B           76           06            jbe 	.427
17746                       00004D0D            .428:
17747                                           ! 3282           {
17748                                           ! 3283             regs.u.r16.cx = 0x3c00;
17749                                           ! Debug: eq int = const $3C00 to unsigned short regs = [S+$10+$1A] (used reg = )
17750 4D0D           B8                   3C00  mov	ax,#$3C00
17751 4D10           8946         1C            mov	$1C[bp],ax
17752                                           !BCC_EOS
17753                                           ! 3284           }
17754                                           ! 3285           regs.u.r8.dl = inb_cmos(0x34);
17755                       00004D13            .427:
17756                                           ! Debug: list int = const $34 (used reg = )
17757 4D13           B8                   0034  mov	ax,*$34
17758 4D16           50                         push	ax
17759                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17760 4D17           E8         B823            call	_inb_cmos
17761 4D1A           44                         inc	sp
17762 4D1B           44                         inc	sp
17763                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$16] (used reg = )
17764 4D1C           8846         18            mov	$18[bp],al
17765                                           !BCC_EOS
17766                                           ! 3286           regs.u.r8.dh = inb_cmos(0x35);
17767                                           ! Debug: list int = const $35 (used reg = )
17768 4D1F           B8                   0035  mov	ax,*$35
17769 4D22           50                         push	ax
17770                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17771 4D23           E8         B817            call	_inb_cmos
17772 4D26           44                         inc	sp
17773 4D27           44                         inc	sp
17774                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$17] (used reg = )
17775 4D28           8846         19            mov	$19[bp],al
17776                                           !BCC_EOS
17777                                           ! 3287           regs.u.r16.ax = regs.u.r16.cx;
17778                                           ! Debug: eq unsigned short regs = [S+$10+$1A] to unsigned short regs = [S+$10+$1E] (used reg = )
17779 4D2B           8B46         1C            mov	ax,$1C[bp]
17780 4D2E           8946         20            mov	$20[bp],ax
17781                                           !BCC_EOS
17782                                           ! 3288           regs.u.r16.bx = regs.u.r16.dx;
17783                                           ! Debug: eq unsigned short regs = [S+$10+$16] to unsigned short regs = [S+$10+$12] (used reg = )
17784 4D31           8B46         18            mov	ax,$18[bp]
17785 4D34           8946         14            mov	$14[bp],ax
17786                                           !BCC_EOS
17787                                           ! 3289           break;
17788 4D37           EB           13            jmp .406
17789                                           !BCC_EOS
17790                                           ! 3290         default:
17791                                           ! 3291           goto int15_unimplemented;
17792                       00004D39            .429:
17793 4D39           83C4                   00  add	sp,#..FFF4-..FFF5
17794 4D3C           EB           10            jmp .FFF4
17795                                           !BCC_EOS
17796                                           ! 3292        }
17797                                           ! 3293        break;
17798 4D3E           EB           0C            jmp .406
17799                       00004D40            .408:
17800 4D40           2C                     01  sub	al,*1
17801 4D42           74           A1            je 	.426
17802 4D44           2C                     1F  sub	al,*$1F
17803 4D46         0F84         FBFE            beq 	.409
17804 4D4A           EB           ED            jmp	.429
17805                       00004D4C            .406:
17806 4D4C           EB           33            jmp .401
17807                                           !BCC_EOS
17808                                           ! 3294     int15_unimplemented:
17809                       00004D4E            .FFF4:
17810                                           ! 3295     default:
17811                                           ! 3296       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
17812                       00004D4E            .42A:
17813                                           ! Debug: list unsigned short regs = [S+$10+$12] (used reg = )
17814 4D4E           FF76         14            push	$14[bp]
17815                                           ! Debug: list unsigned short regs = [S+$12+$1E] (used reg = )
17816 4D51           FF76         20            push	$20[bp]
17817                                           ! Debug: list * char = .42B+0 (used reg = )
17818 4D54           BB                   D3B9  mov	bx,#.42B
17819 4D57           53                         push	bx
17820                                           ! Debug: list int = const 4 (used reg = )
17821 4D58           B8                   0004  mov	ax,*4
17822 4D5B           50                         push	ax
17823                                           ! Debug: func () void = bios_printf+0 (used reg = )
17824 4D5C           E8         BBDF            call	_bios_printf
17825 4D5F           83C4                   08  add	sp,*8
17826                                           !BCC_EOS
17827                                           ! 3297       FLAGS |= 0x0001;
17828                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$26] (used reg = )
17829 4D62           8B46         28            mov	ax,$28[bp]
17830 4D65           0C                     01  or	al,*1
17831 4D67           8946         28            mov	$28[bp],ax
17832                                           !BCC_EOS
17833                                           ! 3298       regs.u.r8.ah = 0x86;
17834                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$1F] (used reg = )
17835 4D6A           B0                     86  mov	al,#$86
17836 4D6C           8846         21            mov	$21[bp],al
17837                                           !BCC_EOS
17838                                           ! 3299       break;
17839 4D6F           EB           10            jmp .401
17840                                           !BCC_EOS
17841                                           ! 3300     }
17842                                           ! 3301 }
17843 4D71           EB           0E            jmp .401
17844                       00004D73            .403:
17845 4D73           2C                     86  sub	al,#$86
17846 4D75         0F84         FB83            beq 	.404
17847 4D79           2C                     62  sub	al,*$62
17848 4D7B         0F84         FBC3            beq 	.405
17849 4D7F           EB           CD            jmp	.42A
17850                       00004D81            .401:
17851                       FFFFFFF0            ..FFF5	=	-$10
17852                       FFFFFFF0            ..FFF4	=	-$10
17853 4D81           89EC                       mov	sp,bp
17854 4D83           5D                         pop	bp
17855 4D84           C3                         ret
17856                                           ! 3302   void
17857                                           ! Register BX used in function int15_function32
17858                                           ! 3303 int16_function(DI, SI, BP, SP, BX, DX, CX, AX, FLAGS)
17859                                           ! 3304   Bit16u DI, SI, BP, SP, BX, DX, CX, AX, FLAGS;
17860                                           export	_int16_function
17861                       00004D85            _int16_function:
17862                                           !BCC_EOS
17863                                           ! 3305 {
17864                                           ! 3306   Bit8u scan_code, ascii_code, shift_flags, led_flags, count;
17865                                           !BCC_EOS
17866                                           ! 3307   Bit16u kbd_code, max;
17867                                           !BCC_EOS
17868                                           ! 3308   ;
17869 4D85           55                         push	bp
17870 4D86           89E5                       mov	bp,sp
17871 4D88           83C4                   F6  add	sp,*-$A
17872                                           !BCC_EOS
17873                                           ! 3309   shift_flags = *((Bit8u *)(0x17));
17874                                           ! Debug: eq unsigned char = [+$17] to unsigned char shift_flags = [S+$C-5] (used reg = )
17875 4D8B           A0         0017            mov	al,[$17]
17876 4D8E           8846         FD            mov	-3[bp],al
17877                                           !BCC_EOS
17878                                           ! 3310   led_flags = *((Bit8u *)(0x97));
17879                                           ! Debug: eq unsigned char = [+$97] to unsigned char led_flags = [S+$C-6] (used reg = )
17880 4D91           A0         0097            mov	al,[$97]
17881 4D94           8846         FC            mov	-4[bp],al
17882                                           !BCC_EOS
17883                                           ! 3311   if ((((shift_flags >> 4) & 0x07) ^ (led_flags & 0x07)) != 0) {
17884                                           ! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
17885 4D97           8A46         FC            mov	al,-4[bp]
17886 4D9A           24                     07  and	al,*7
17887 4D9C           50                         push	ax
17888                                           ! Debug: sr int = const 4 to unsigned char shift_flags = [S+$E-5] (used reg = )
17889 4D9D           8A46         FD            mov	al,-3[bp]
17890 4DA0           30E4                       xor	ah,ah
17891 4DA2           B1                     04  mov	cl,*4
17892 4DA4           D3E8                       shr	ax,cl
17893                                           ! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
17894 4DA6           24                     07  and	al,*7
17895                                           ! Debug: eor unsigned char (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
17896 4DA8           3246         F4            xor	al,-$C[bp]
17897 4DAB           44                         inc	sp
17898 4DAC           44                         inc	sp
17899                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
17900 4DAD           84C0                       test	al,al
17901 4DAF         0F84         0095            beq 	.42C
17902                       00004DB3            .42D:
17903                                           ! 3312 #asm
17904                                           !BCC_EOS
17905                                           !BCC_ASM
17906                       00000012            _int16_function.BP	set	$12
17907                       00000008            .int16_function.BP	set	8
17908                       00000005            _int16_function.count	set	5
17909                       FFFFFFFB            .int16_function.count	set	-5
17910                       0000001A            _int16_function.CX	set	$1A
17911                       00000010            .int16_function.CX	set	$10
17912                       00000008            _int16_function.ascii_code	set	8
17913                       FFFFFFFE            .int16_function.ascii_code	set	-2
17914                       0000000E            _int16_function.DI	set	$E
17915                       00000004            .int16_function.DI	set	4
17916                       0000001E            _int16_function.FLAGS	set	$1E
17917                       00000014            .int16_function.FLAGS	set	$14
17918                       00000002            _int16_function.kbd_code	set	2
17919                       FFFFFFF8            .int16_function.kbd_code	set	-8
17920                       00000009            _int16_function.scan_code	set	9
17921                       FFFFFFFF            .int16_function.scan_code	set	-1
17922                       00000018            _int16_function.DX	set	$18
17923                       0000000E            .int16_function.DX	set	$E
17924                       00000006            _int16_function.led_flags	set	6
17925                       FFFFFFFC            .int16_function.led_flags	set	-4
17926                       00000010            _int16_function.SI	set	$10
17927                       00000006            .int16_function.SI	set	6
17928                       0000001C            _int16_function.AX	set	$1C
17929                       00000012            .int16_function.AX	set	$12
17930                       00000014            _int16_function.SP	set	$14
17931                       0000000A            .int16_function.SP	set	$A
17932                       00000016            _int16_function.BX	set	$16
17933                       0000000C            .int16_function.BX	set	$C
17934                       00000007            _int16_function.shift_flags	set	7
17935                       FFFFFFFD            .int16_function.shift_flags	set	-3
17936                       00000000            _int16_function.max	set	0
17937                       FFFFFFF6            .int16_function.max	set	-$A
17938 4DB3           FA                             cli
17939                                           ! 3314 endasm
17940                                           !BCC_ENDASM
17941                                           !BCC_EOS
17942                                           ! 3315     outb(0x0060, 0xed);
17943                                           ! Debug: list int = const $ED (used reg = )
17944 4DB4           B8                   00ED  mov	ax,#$ED
17945 4DB7           50                         push	ax
17946                                           ! Debug: list int = const $60 (used reg = )
17947 4DB8           B8                   0060  mov	ax,*$60
17948 4DBB           50                         push	ax
17949                                           ! Debug: func () void = outb+0 (used reg = )
17950 4DBC           E8         B74F            call	_outb
17951 4DBF           83C4                   04  add	sp,*4
17952                                           !BCC_EOS
17953                                           ! 3316     while ((inb(0x0064) & 0x01) == 0) outb(0x0080, 0x21);
17954 4DC2           EB           0E            jmp .42F
17955                       00004DC4            .430:
17956                                           ! Debug: list int = const $21 (used reg = )
17957 4DC4           B8                   0021  mov	ax,*$21
17958 4DC7           50                         push	ax
17959                                           ! Debug: list int = const $80 (used reg = )
17960 4DC8           B8                   0080  mov	ax,#$80
17961 4DCB           50                         push	ax
17962                                           ! Debug: func () void = outb+0 (used reg = )
17963 4DCC           E8         B73F            call	_outb
17964 4DCF           83C4                   04  add	sp,*4
17965                                           !BCC_EOS
17966                                           ! 3317     if ((inb(0x0060) == 0xfa)) {
17967                       00004DD2            .42F:
17968                                           ! Debug: list int = const $64 (used reg = )
17969 4DD2           B8                   0064  mov	ax,*$64
17970 4DD5           50                         push	ax
17971                                           ! Debug: func () unsigned char = inb+0 (used reg = )
17972 4DD6           E8         B71F            call	_inb
17973 4DD9           44                         inc	sp
17974 4DDA           44                         inc	sp
17975                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
17976 4DDB           24                     01  and	al,*1
17977                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
17978 4DDD           84C0                       test	al,al
17979 4DDF           74           E3            je 	.430
17980                       00004DE1            .431:
17981                       00004DE1            .42E:
17982                                           ! Debug: list int = const $60 (used reg = )
17983 4DE1           B8                   0060  mov	ax,*$60
17984 4DE4           50                         push	ax
17985                                           ! Debug: func () unsigned char = inb+0 (used reg = )
17986 4DE5           E8         B710            call	_inb
17987 4DE8           44                         inc	sp
17988 4DE9           44                         inc	sp
17989                                           ! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
17990 4DEA           3C                     FA  cmp	al,#$FA
17991 4DEC           75           59            jne 	.432
17992                       00004DEE            .433:
17993                                           ! 3318       led_flags &= 0xf8;
17994                                           ! Debug: andab int = const $F8 to unsigned char led_flags = [S+$C-6] (used reg = )
17995 4DEE           8A46         FC            mov	al,-4[bp]
17996 4DF1           24                     F8  and	al,#$F8
17997 4DF3           8846         FC            mov	-4[bp],al
17998                                           !BCC_EOS
17999                                           ! 3319       led_flags |= ((shift_flags >> 4) & 0x07);
18000                                           ! Debug: sr int = const 4 to unsigned char shift_flags = [S+$C-5] (used reg = )
18001 4DF6           8A46         FD            mov	al,-3[bp]
18002 4DF9           30E4                       xor	ah,ah
18003 4DFB           B1                     04  mov	cl,*4
18004 4DFD           D3E8                       shr	ax,cl
18005                                           ! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
18006 4DFF           24                     07  and	al,*7
18007                                           ! Debug: orab unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
18008 4E01           0A46         FC            or	al,-4[bp]
18009 4E04           8846         FC            mov	-4[bp],al
18010                                           !BCC_EOS
18011                                           ! 3320       outb(0x0060, led_flags & 0x07);
18012                                           ! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
18013 4E07           8A46         FC            mov	al,-4[bp]
18014 4E0A           24                     07  and	al,*7
18015                                           ! Debug: list unsigned char = al+0 (used reg = )
18016 4E0C           30E4                       xor	ah,ah
18017 4E0E           50                         push	ax
18018                                           ! Debug: list int = const $60 (used reg = )
18019 4E0F           B8                   0060  mov	ax,*$60
18020 4E12           50                         push	ax
18021                                           ! Debug: func () void = outb+0 (used reg = )
18022 4E13           E8         B6F8            call	_outb
18023 4E16           83C4                   04  add	sp,*4
18024                                           !BCC_EOS
18025                                           ! 3321       while ((inb(0x0064) & 0x01) == 0) outb(0x0080, 0x21);
18026 4E19           EB           0E            jmp .435
18027                       00004E1B            .436:
18028                                           ! Debug: list int = const $21 (used reg = )
18029 4E1B           B8                   0021  mov	ax,*$21
18030 4E1E           50                         push	ax
18031                                           ! Debug: list int = const $80 (used reg = )
18032 4E1F           B8                   0080  mov	ax,#$80
18033 4E22           50                         push	ax
18034                                           ! Debug: func () void = outb+0 (used reg = )
18035 4E23           E8         B6E8            call	_outb
18036 4E26           83C4                   04  add	sp,*4
18037                                           !BCC_EOS
18038                                           ! 3322       inb(0x0060);
18039                       00004E29            .435:
18040                                           ! Debug: list int = const $64 (used reg = )
18041 4E29           B8                   0064  mov	ax,*$64
18042 4E2C           50                         push	ax
18043                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18044 4E2D           E8         B6C8            call	_inb
18045 4E30           44                         inc	sp
18046 4E31           44                         inc	sp
18047                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
18048 4E32           24                     01  and	al,*1
18049                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
18050 4E34           84C0                       test	al,al
18051 4E36           74           E3            je 	.436
18052                       00004E38            .437:
18053                       00004E38            .434:
18054                                           ! Debug: list int = const $60 (used reg = )
18055 4E38           B8                   0060  mov	ax,*$60
18056 4E3B           50                         push	ax
18057                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18058 4E3C           E8         B6B9            call	_inb
18059 4E3F           44                         inc	sp
18060 4E40           44                         inc	sp
18061                                           !BCC_EOS
18062                                           ! 3323       *((Bit8u *)(0x97)) = (led_flags);
18063                                           ! Debug: eq unsigned char led_flags = [S+$C-6] to unsigned char = [+$97] (used reg = )
18064 4E41           8A46         FC            mov	al,-4[bp]
18065 4E44           A2         0097            mov	[$97],al
18066                                           !BCC_EOS
18067                                           ! 3324     }
18068                                           ! 3325 #asm
18069                       00004E47            .432:
18070                                           !BCC_EOS
18071                                           !BCC_ASM
18072                       00000012            _int16_function.BP	set	$12
18073                       00000008            .int16_function.BP	set	8
18074                       00000005            _int16_function.count	set	5
18075                       FFFFFFFB            .int16_function.count	set	-5
18076                       0000001A            _int16_function.CX	set	$1A
18077                       00000010            .int16_function.CX	set	$10
18078                       00000008            _int16_function.ascii_code	set	8
18079                       FFFFFFFE            .int16_function.ascii_code	set	-2
18080                       0000000E            _int16_function.DI	set	$E
18081                       00000004            .int16_function.DI	set	4
18082                       0000001E            _int16_function.FLAGS	set	$1E
18083                       00000014            .int16_function.FLAGS	set	$14
18084                       00000002            _int16_function.kbd_code	set	2
18085                       FFFFFFF8            .int16_function.kbd_code	set	-8
18086                       00000009            _int16_function.scan_code	set	9
18087                       FFFFFFFF            .int16_function.scan_code	set	-1
18088                       00000018            _int16_function.DX	set	$18
18089                       0000000E            .int16_function.DX	set	$E
18090                       00000006            _int16_function.led_flags	set	6
18091                       FFFFFFFC            .int16_function.led_flags	set	-4
18092                       00000010            _int16_function.SI	set	$10
18093                       00000006            .int16_function.SI	set	6
18094                       0000001C            _int16_function.AX	set	$1C
18095                       00000012            .int16_function.AX	set	$12
18096                       00000014            _int16_function.SP	set	$14
18097                       0000000A            .int16_function.SP	set	$A
18098                       00000016            _int16_function.BX	set	$16
18099                       0000000C            .int16_function.BX	set	$C
18100                       00000007            _int16_function.shift_flags	set	7
18101                       FFFFFFFD            .int16_function.shift_flags	set	-3
18102                       00000000            _int16_function.max	set	0
18103                       FFFFFFF6            .int16_function.max	set	-$A
18104 4E47           FB                             sti
18105                                           ! 3327 endasm
18106                                           !BCC_ENDASM
18107                                           !BCC_EOS
18108                                           ! 3328   }
18109                                           ! 3329   switch (*(((Bit8u *)&AX)+
18110                       00004E48            .42C:
18111                                           ! 3329 1)) {
18112 4E48           8A46         13            mov	al,$13[bp]
18113 4E4B           E9         029C            br 	.43A
18114                                           ! 3330     case 0x00:
18115                                           ! 3331       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
18116                       00004E4E            .43B:
18117                                           ! Debug: list int = const 1 (used reg = )
18118 4E4E           B8                   0001  mov	ax,*1
18119 4E51           50                         push	ax
18120                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
18121 4E52           8D5E         FE            lea	bx,-2[bp]
18122 4E55           53                         push	bx
18123                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
18124 4E56           8D5E         FF            lea	bx,-1[bp]
18125 4E59           53                         push	bx
18126                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
18127 4E5A           E8         02D8            call	_dequeue_key
18128 4E5D           83C4                   06  add	sp,*6
18129 4E60           85C0                       test	ax,ax
18130 4E62           75           0E            jne 	.43C
18131                       00004E64            .43D:
18132                                           ! 3332         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
18133                                           ! Debug: list * char = .43E+0 (used reg = )
18134 4E64           BB                   D395  mov	bx,#.43E
18135 4E67           53                         push	bx
18136                                           ! Debug: list int = const 7 (used reg = )
18137 4E68           B8                   0007  mov	ax,*7
18138 4E6B           50                         push	ax
18139                                           ! Debug: func () void = bios_printf+0 (used reg = )
18140 4E6C           E8         BACF            call	_bios_printf
18141 4E6F           83C4                   04  add	sp,*4
18142                                           !BCC_EOS
18143                                           ! 3333       }
18144                                           ! 3334       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
18145                       00004E72            .43C:
18146                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
18147 4E72           8A46         FF            mov	al,-1[bp]
18148 4E75           84C0                       test	al,al
18149 4E77           74           0E            je  	.43F
18150                       00004E79            .441:
18151                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18152 4E79           8A46         FE            mov	al,-2[bp]
18153 4E7C           3C                     F0  cmp	al,#$F0
18154 4E7E           75           07            jne 	.43F
18155                       00004E80            .440:
18156                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18157 4E80           30C0                       xor	al,al
18158 4E82           8846         FE            mov	-2[bp],al
18159                                           !BCC_EOS
18160                                           ! 3335       else if (ascii_code == 0xE0) ascii_code = 0;
18161 4E85           EB           0C            jmp .442
18162                       00004E87            .43F:
18163                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18164 4E87           8A46         FE            mov	al,-2[bp]
18165 4E8A           3C                     E0  cmp	al,#$E0
18166 4E8C           75           05            jne 	.443
18167                       00004E8E            .444:
18168                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18169 4E8E           30C0                       xor	al,al
18170 4E90           8846         FE            mov	-2[bp],al
18171                                           !BCC_EOS
18172                                           ! 3336       AX = (scan_code << 8) | ascii_code;
18173                       00004E93            .443:
18174                       00004E93            .442:
18175                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
18176 4E93           8A46         FF            mov	al,-1[bp]
18177 4E96           30E4                       xor	ah,ah
18178 4E98           88C4                       mov	ah,al
18179 4E9A           30C0                       xor	al,al
18180                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
18181 4E9C           0A46         FE            or	al,-2[bp]
18182                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
18183 4E9F           8946         12            mov	$12[bp],ax
18184                                           !BCC_EOS
18185                                           ! 3337       break;
18186 4EA2           E9         028C            br 	.438
18187                                           !BCC_EOS
18188                                           ! 3338     case 0x01:
18189                                           ! 3339       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
18190                       00004EA5            .445:
18191                                           ! Debug: list int = const 0 (used reg = )
18192 4EA5           31C0                       xor	ax,ax
18193 4EA7           50                         push	ax
18194                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
18195 4EA8           8D5E         FE            lea	bx,-2[bp]
18196 4EAB           53                         push	bx
18197                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
18198 4EAC           8D5E         FF            lea	bx,-1[bp]
18199 4EAF           53                         push	bx
18200                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
18201 4EB0           E8         0282            call	_dequeue_key
18202 4EB3           83C4                   06  add	sp,*6
18203 4EB6           85C0                       test	ax,ax
18204 4EB8           75           0C            jne 	.446
18205                       00004EBA            .447:
18206                                           ! 3340         FLAGS |= 0x0040;
18207                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
18208 4EBA           8B46         14            mov	ax,$14[bp]
18209 4EBD           0C                     40  or	al,*$40
18210 4EBF           8946         14            mov	$14[bp],ax
18211                                           !BCC_EOS
18212                                           ! 3341         return;
18213 4EC2           89EC                       mov	sp,bp
18214 4EC4           5D                         pop	bp
18215 4EC5           C3                         ret
18216                                           !BCC_EOS
18217                                           ! 3342       }
18218                                           ! 3343       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
18219                       00004EC6            .446:
18220                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
18221 4EC6           8A46         FF            mov	al,-1[bp]
18222 4EC9           84C0                       test	al,al
18223 4ECB           74           0E            je  	.448
18224                       00004ECD            .44A:
18225                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18226 4ECD           8A46         FE            mov	al,-2[bp]
18227 4ED0           3C                     F0  cmp	al,#$F0
18228 4ED2           75           07            jne 	.448
18229                       00004ED4            .449:
18230                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18231 4ED4           30C0                       xor	al,al
18232 4ED6           8846         FE            mov	-2[bp],al
18233                                           !BCC_EOS
18234                                           ! 3344       else if (ascii_code == 0xE0) ascii_code = 0;
18235 4ED9           EB           0C            jmp .44B
18236                       00004EDB            .448:
18237                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18238 4EDB           8A46         FE            mov	al,-2[bp]
18239 4EDE           3C                     E0  cmp	al,#$E0
18240 4EE0           75           05            jne 	.44C
18241                       00004EE2            .44D:
18242                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18243 4EE2           30C0                       xor	al,al
18244 4EE4           8846         FE            mov	-2[bp],al
18245                                           !BCC_EOS
18246                                           ! 3345       AX = (scan_code << 8) | ascii_code;
18247                       00004EE7            .44C:
18248                       00004EE7            .44B:
18249                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
18250 4EE7           8A46         FF            mov	al,-1[bp]
18251 4EEA           30E4                       xor	ah,ah
18252 4EEC           88C4                       mov	ah,al
18253 4EEE           30C0                       xor	al,al
18254                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
18255 4EF0           0A46         FE            or	al,-2[bp]
18256                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
18257 4EF3           8946         12            mov	$12[bp],ax
18258                                           !BCC_EOS
18259                                           ! 3346       FLAGS &= 0xffbf;
18260                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
18261 4EF6           8B46         14            mov	ax,$14[bp]
18262 4EF9           24                     BF  and	al,#$BF
18263 4EFB           8946         14            mov	$14[bp],ax
18264                                           !BCC_EOS
18265                                           ! 3347       break;
18266 4EFE           E9         0230            br 	.438
18267                                           !BCC_EOS
18268                                           ! 3348     case 0x02:
18269                                           ! 3349       shift_flags = *((Bit8u *)(0x17));
18270                       00004F01            .44E:
18271                                           ! Debug: eq unsigned char = [+$17] to unsigned char shift_flags = [S+$C-5] (used reg = )
18272 4F01           A0         0017            mov	al,[$17]
18273 4F04           8846         FD            mov	-3[bp],al
18274                                           !BCC_EOS
18275                                           ! 3350       *((Bit8u *)&AX) = (shift_flags);
18276                                           ! Debug: eq unsigned char shift_flags = [S+$C-5] to unsigned char AX = [S+$C+$10] (used reg = )
18277 4F07           8A46         FD            mov	al,-3[bp]
18278 4F0A           8846         12            mov	$12[bp],al
18279                                           !BCC_EOS
18280                                           ! 3351       break;
18281 4F0D           E9         0221            br 	.438
18282                                           !BCC_EOS
18283                                           ! 3352     case 0x05:
18284                                           ! 3353       if ( !enqueue_key(*(((Bit8u *)&CX)+1), ( CX & 0x00ff )) ) {
18285                       00004F10            .44F:
18286                                           ! Debug: and int = const $FF to unsigned short CX = [S+$C+$E] (used reg = )
18287 4F10           8A46         10            mov	al,$10[bp]
18288                                           ! Debug: list unsigned char = al+0 (used reg = )
18289 4F13           30E4                       xor	ah,ah
18290 4F15           50                         push	ax
18291                                           ! Debug: list unsigned char CX = [S+$E+$F] (used reg = )
18292 4F16           8A46         11            mov	al,$11[bp]
18293 4F19           30E4                       xor	ah,ah
18294 4F1B           50                         push	ax
18295                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
18296 4F1C           E8         0A55            call	_enqueue_key
18297 4F1F           83C4                   04  add	sp,*4
18298 4F22           85C0                       test	ax,ax
18299 4F24           75           07            jne 	.450
18300                       00004F26            .451:
18301                                           ! 3354         *((Bit8u *)&AX) = (1);
18302                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$C+$10] (used reg = )
18303 4F26           B0                     01  mov	al,*1
18304 4F28           8846         12            mov	$12[bp],al
18305                                           !BCC_EOS
18306                                           ! 3355       }
18307                                           ! 3356       else {
18308 4F2B           EB           05            jmp .452
18309                       00004F2D            .450:
18310                                           ! 3357         *((Bit8u *)&AX) = (0);
18311                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$C+$10] (used reg = )
18312 4F2D           30C0                       xor	al,al
18313 4F2F           8846         12            mov	$12[bp],al
18314                                           !BCC_EOS
18315                                           ! 3358       }
18316                                           ! 3359       break;
18317                       00004F32            .452:
18318 4F32           E9         01FC            br 	.438
18319                                           !BCC_EOS
18320                                           ! 3360     case 0x09:
18321                                           ! 3361       *((Bit8u *)&AX) = (0x30);
18322                       00004F35            .453:
18323                                           ! Debug: eq int = const $30 to unsigned char AX = [S+$C+$10] (used reg = )
18324 4F35           B0                     30  mov	al,*$30
18325 4F37           8846         12            mov	$12[bp],al
18326                                           !BCC_EOS
18327                                           ! 3362       break;
18328 4F3A           E9         01F4            br 	.438
18329                                           !BCC_EOS
18330                                           ! 3363     case 0x0A:
18331                                           ! 3364       count = 2;
18332                       00004F3D            .454:
18333                                           ! Debug: eq int = const 2 to unsigned char count = [S+$C-7] (used reg = )
18334 4F3D           B0                     02  mov	al,*2
18335 4F3F           8846         FB            mov	-5[bp],al
18336                                           !BCC_EOS
18337                                           ! 3365       kbd_code = 0x0;
18338                                           ! Debug: eq int = const 0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
18339 4F42           31C0                       xor	ax,ax
18340 4F44           8946         F8            mov	-8[bp],ax
18341                                           !BCC_EOS
18342                                           ! 3366       outb(0x0060, 0xf2);
18343                                           ! Debug: list int = const $F2 (used reg = )
18344 4F47           B8                   00F2  mov	ax,#$F2
18345 4F4A           50                         push	ax
18346                                           ! Debug: list int = const $60 (used reg = )
18347 4F4B           B8                   0060  mov	ax,*$60
18348 4F4E           50                         push	ax
18349                                           ! Debug: func () void = outb+0 (used reg = )
18350 4F4F           E8         B5BC            call	_outb
18351 4F52           83C4                   04  add	sp,*4
18352                                           !BCC_EOS
18353                                           ! 3367       max=0xffff;
18354                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
18355 4F55           B8                   FFFF  mov	ax,#$FFFF
18356 4F58           8946         F6            mov	-$A[bp],ax
18357                                           !BCC_EOS
18358                                           ! 3368       while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x00);
18359 4F5B           EB           0D            jmp .456
18360                       00004F5D            .457:
18361                                           ! Debug: list int = const 0 (used reg = )
18362 4F5D           31C0                       xor	ax,ax
18363 4F5F           50                         push	ax
18364                                           ! Debug: list int = const $80 (used reg = )
18365 4F60           B8                   0080  mov	ax,#$80
18366 4F63           50                         push	ax
18367                                           ! Debug: func () void = outb+0 (used reg = )
18368 4F64           E8         B5A7            call	_outb
18369 4F67           83C4                   04  add	sp,*4
18370                                           !BCC_EOS
18371                                           ! 3369       if (max>0x0) {
18372                       00004F6A            .456:
18373                                           ! Debug: list int = const $64 (used reg = )
18374 4F6A           B8                   0064  mov	ax,*$64
18375 4F6D           50                         push	ax
18376                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18377 4F6E           E8         B587            call	_inb
18378 4F71           44                         inc	sp
18379 4F72           44                         inc	sp
18380                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
18381 4F73           24                     01  and	al,*1
18382                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
18383 4F75           84C0                       test	al,al
18384 4F77           75           0B            jne 	.458
18385                       00004F79            .459:
18386                                           ! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
18387 4F79           8B46         F6            mov	ax,-$A[bp]
18388 4F7C           48                         dec	ax
18389 4F7D           8946         F6            mov	-$A[bp],ax
18390                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
18391 4F80           85C0                       test	ax,ax
18392 4F82           75           D9            jne	.457
18393                       00004F84            .458:
18394                       00004F84            .455:
18395                                           ! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
18396 4F84           8B46         F6            mov	ax,-$A[bp]
18397 4F87           85C0                       test	ax,ax
18398 4F89           74           6D            je  	.45A
18399                       00004F8B            .45B:
18400                                           ! 3370         if ((inb(0x0060) == 0xfa)) {
18401                                           ! Debug: list int = const $60 (used reg = )
18402 4F8B           B8                   0060  mov	ax,*$60
18403 4F8E           50                         push	ax
18404                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18405 4F8F           E8         B566            call	_inb
18406 4F92           44                         inc	sp
18407 4F93           44                         inc	sp
18408                                           ! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
18409 4F94           3C                     FA  cmp	al,#$FA
18410 4F96           75           60            jne 	.45C
18411                       00004F98            .45D:
18412                                           ! 3371           do {
18413                       00004F98            .460:
18414                                           ! 3372             max=0xffff;
18415                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
18416 4F98           B8                   FFFF  mov	ax,#$FFFF
18417 4F9B           8946         F6            mov	-$A[bp],ax
18418                                           !BCC_EOS
18419                                           ! 3373             while ( ((inb(0x0064) & 0x01) == 0) && (--max>0) ) outb(0x0080, 0x00);
18420 4F9E           EB           0D            jmp .462
18421                       00004FA0            .463:
18422                                           ! Debug: list int = const 0 (used reg = )
18423 4FA0           31C0                       xor	ax,ax
18424 4FA2           50                         push	ax
18425                                           ! Debug: list int = const $80 (used reg = )
18426 4FA3           B8                   0080  mov	ax,#$80
18427 4FA6           50                         push	ax
18428                                           ! Debug: func () void = outb+0 (used reg = )
18429 4FA7           E8         B564            call	_outb
18430 4FAA           83C4                   04  add	sp,*4
18431                                           !BCC_EOS
18432                                           ! 3374             if (max>0x0) {
18433                       00004FAD            .462:
18434                                           ! Debug: list int = const $64 (used reg = )
18435 4FAD           B8                   0064  mov	ax,*$64
18436 4FB0           50                         push	ax
18437                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18438 4FB1           E8         B544            call	_inb
18439 4FB4           44                         inc	sp
18440 4FB5           44                         inc	sp
18441                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
18442 4FB6           24                     01  and	al,*1
18443                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
18444 4FB8           84C0                       test	al,al
18445 4FBA           75           0B            jne 	.464
18446                       00004FBC            .465:
18447                                           ! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
18448 4FBC           8B46         F6            mov	ax,-$A[bp]
18449 4FBF           48                         dec	ax
18450 4FC0           8946         F6            mov	-$A[bp],ax
18451                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
18452 4FC3           85C0                       test	ax,ax
18453 4FC5           75           D9            jne	.463
18454                       00004FC7            .464:
18455                       00004FC7            .461:
18456                                           ! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
18457 4FC7           8B46         F6            mov	ax,-$A[bp]
18458 4FCA           85C0                       test	ax,ax
18459 4FCC           74           1F            je  	.466
18460                       00004FCE            .467:
18461                                           ! 3375               kbd_code >>= 8;
18462                                           ! Debug: srab int = const 8 to unsigned short kbd_code = [S+$C-$A] (used reg = )
18463 4FCE           8B46         F8            mov	ax,-8[bp]
18464 4FD1           88E0                       mov	al,ah
18465 4FD3           30E4                       xor	ah,ah
18466 4FD5           8946         F8            mov	-8[bp],ax
18467                                           !BCC_EOS
18468                                           ! 3376               kbd_code |= (inb(0x0060) << 8);
18469                                           ! Debug: list int = const $60 (used reg = )
18470 4FD8           B8                   0060  mov	ax,*$60
18471 4FDB           50                         push	ax
18472                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18473 4FDC           E8         B519            call	_inb
18474 4FDF           44                         inc	sp
18475 4FE0           44                         inc	sp
18476                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
18477 4FE1           30E4                       xor	ah,ah
18478 4FE3           88C4                       mov	ah,al
18479 4FE5           30C0                       xor	al,al
18480                                           ! Debug: orab unsigned int = ax+0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
18481 4FE7           0B46         F8            or	ax,-8[bp]
18482 4FEA           8946         F8            mov	-8[bp],ax
18483                                           !BCC_EOS
18484                                           ! 3377             }
18485                                           ! 3378           } while (--count>0);
18486                       00004FED            .466:
18487                       00004FED            .45F:
18488                                           ! Debug: predec unsigned char count = [S+$C-7] (used reg = )
18489 4FED           8A46         FB            mov	al,-5[bp]
18490 4FF0           48                         dec	ax
18491 4FF1           8846         FB            mov	-5[bp],al
18492                                           ! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
18493 4FF4           84C0                       test	al,al
18494 4FF6           75           A0            jne	.460
18495                       00004FF8            .468:
18496                                           !BCC_EOS
18497                                           ! 3379         }
18498                       00004FF8            .45E:
18499                                           ! 3380       }
18500                       00004FF8            .45C:
18501                                           ! 3381       BX=kbd_code;
18502                       00004FF8            .45A:
18503                                           ! Debug: eq unsigned short kbd_code = [S+$C-$A] to unsigned short BX = [S+$C+$A] (used reg = )
18504 4FF8           8B46         F8            mov	ax,-8[bp]
18505 4FFB           8946         0C            mov	$C[bp],ax
18506                                           !BCC_EOS
18507                                           ! 3382       break;
18508 4FFE           E9         0130            br 	.438
18509                                           !BCC_EOS
18510                                           ! 3383     case 0x10:
18511                                           ! 3384       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
18512                       00005001            .469:
18513                                           ! Debug: list int = const 1 (used reg = )
18514 5001           B8                   0001  mov	ax,*1
18515 5004           50                         push	ax
18516                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
18517 5005           8D5E         FE            lea	bx,-2[bp]
18518 5008           53                         push	bx
18519                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
18520 5009           8D5E         FF            lea	bx,-1[bp]
18521 500C           53                         push	bx
18522                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
18523 500D           E8         0125            call	_dequeue_key
18524 5010           83C4                   06  add	sp,*6
18525 5013           85C0                       test	ax,ax
18526 5015           75           0E            jne 	.46A
18527                       00005017            .46B:
18528                                           ! 3385         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
18529                                           ! Debug: list * char = .46C+0 (used reg = )
18530 5017           BB                   D371  mov	bx,#.46C
18531 501A           53                         push	bx
18532                                           ! Debug: list int = const 7 (used reg = )
18533 501B           B8                   0007  mov	ax,*7
18534 501E           50                         push	ax
18535                                           ! Debug: func () void = bios_printf+0 (used reg = )
18536 501F           E8         B91C            call	_bios_printf
18537 5022           83C4                   04  add	sp,*4
18538                                           !BCC_EOS
18539                                           ! 3386       }
18540                                           ! 3387       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
18541                       00005025            .46A:
18542                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
18543 5025           8A46         FF            mov	al,-1[bp]
18544 5028           84C0                       test	al,al
18545 502A           74           0C            je  	.46D
18546                       0000502C            .46F:
18547                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18548 502C           8A46         FE            mov	al,-2[bp]
18549 502F           3C                     F0  cmp	al,#$F0
18550 5031           75           05            jne 	.46D
18551                       00005033            .46E:
18552                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18553 5033           30C0                       xor	al,al
18554 5035           8846         FE            mov	-2[bp],al
18555                                           !BCC_EOS
18556                                           ! 3388       AX = (scan_code << 8) | ascii_code;
18557                       00005038            .46D:
18558                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
18559 5038           8A46         FF            mov	al,-1[bp]
18560 503B           30E4                       xor	ah,ah
18561 503D           88C4                       mov	ah,al
18562 503F           30C0                       xor	al,al
18563                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
18564 5041           0A46         FE            or	al,-2[bp]
18565                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
18566 5044           8946         12            mov	$12[bp],ax
18567                                           !BCC_EOS
18568                                           ! 3389       break;
18569 5047           E9         00E7            br 	.438
18570                                           !BCC_EOS
18571                                           ! 3390     case 0x11:
18572                                           ! 3391       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
18573                       0000504A            .470:
18574                                           ! Debug: list int = const 0 (used reg = )
18575 504A           31C0                       xor	ax,ax
18576 504C           50                         push	ax
18577                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
18578 504D           8D5E         FE            lea	bx,-2[bp]
18579 5050           53                         push	bx
18580                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
18581 5051           8D5E         FF            lea	bx,-1[bp]
18582 5054           53                         push	bx
18583                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
18584 5055           E8         00DD            call	_dequeue_key
18585 5058           83C4                   06  add	sp,*6
18586 505B           85C0                       test	ax,ax
18587 505D           75           0C            jne 	.471
18588                       0000505F            .472:
18589                                           ! 3392         FLAGS |= 0x0040;
18590                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
18591 505F           8B46         14            mov	ax,$14[bp]
18592 5062           0C                     40  or	al,*$40
18593 5064           8946         14            mov	$14[bp],ax
18594                                           !BCC_EOS
18595                                           ! 3393         return;
18596 5067           89EC                       mov	sp,bp
18597 5069           5D                         pop	bp
18598 506A           C3                         ret
18599                                           !BCC_EOS
18600                                           ! 3394       }
18601                                           ! 3395       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
18602                       0000506B            .471:
18603                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
18604 506B           8A46         FF            mov	al,-1[bp]
18605 506E           84C0                       test	al,al
18606 5070           74           0C            je  	.473
18607                       00005072            .475:
18608                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18609 5072           8A46         FE            mov	al,-2[bp]
18610 5075           3C                     F0  cmp	al,#$F0
18611 5077           75           05            jne 	.473
18612                       00005079            .474:
18613                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
18614 5079           30C0                       xor	al,al
18615 507B           8846         FE            mov	-2[bp],al
18616                                           !BCC_EOS
18617                                           ! 3396       AX = (scan_code << 8) | ascii_code;
18618                       0000507E            .473:
18619                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
18620 507E           8A46         FF            mov	al,-1[bp]
18621 5081           30E4                       xor	ah,ah
18622 5083           88C4                       mov	ah,al
18623 5085           30C0                       xor	al,al
18624                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
18625 5087           0A46         FE            or	al,-2[bp]
18626                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
18627 508A           8946         12            mov	$12[bp],ax
18628                                           !BCC_EOS
18629                                           ! 3397       F
18630                                           ! 3397 LAGS &= 0xffbf;
18631                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
18632 508D           8B46         14            mov	ax,$14[bp]
18633 5090           24                     BF  and	al,#$BF
18634 5092           8946         14            mov	$14[bp],ax
18635                                           !BCC_EOS
18636                                           ! 3398       break;
18637 5095           E9         0099            br 	.438
18638                                           !BCC_EOS
18639                                           ! 3399     case 0x12:
18640                                           ! 3400       shift_flags = *((Bit8u *)(0x17));
18641                       00005098            .476:
18642                                           ! Debug: eq unsigned char = [+$17] to unsigned char shift_flags = [S+$C-5] (used reg = )
18643 5098           A0         0017            mov	al,[$17]
18644 509B           8846         FD            mov	-3[bp],al
18645                                           !BCC_EOS
18646                                           ! 3401       *((Bit8u *)&AX) = (shift_flags);
18647                                           ! Debug: eq unsigned char shift_flags = [S+$C-5] to unsigned char AX = [S+$C+$10] (used reg = )
18648 509E           8A46         FD            mov	al,-3[bp]
18649 50A1           8846         12            mov	$12[bp],al
18650                                           !BCC_EOS
18651                                           ! 3402       shift_flags = *((Bit8u *)(0x18)) & 0x73;
18652                                           ! Debug: and int = const $73 to unsigned char = [+$18] (used reg = )
18653 50A4           A0         0018            mov	al,[$18]
18654 50A7           24                     73  and	al,*$73
18655                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
18656 50A9           8846         FD            mov	-3[bp],al
18657                                           !BCC_EOS
18658                                           ! 3403       shift_flags |= *((Bit8u *)(0x96)) & 0x0c;
18659                                           ! Debug: and int = const $C to unsigned char = [+$96] (used reg = )
18660 50AC           A0         0096            mov	al,[$96]
18661 50AF           24                     0C  and	al,*$C
18662                                           ! Debug: orab unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
18663 50B1           0A46         FD            or	al,-3[bp]
18664 50B4           8846         FD            mov	-3[bp],al
18665                                           !BCC_EOS
18666                                           ! 3404       *(((Bit8u *)&AX)+1) = (shift_flags);
18667                                           ! Debug: eq unsigned char shift_flags = [S+$C-5] to unsigned char AX = [S+$C+$11] (used reg = )
18668 50B7           8A46         FD            mov	al,-3[bp]
18669 50BA           8846         13            mov	$13[bp],al
18670                                           !BCC_EOS
18671                                           ! 3405       ;
18672                                           !BCC_EOS
18673                                           ! 3406       break;
18674 50BD           EB           72            jmp .438
18675                                           !BCC_EOS
18676                                           ! 3407     case 0x92:
18677                                           ! 3408       *(((Bit8u *)&AX)+1) = (0x80);
18678                       000050BF            .477:
18679                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$C+$11] (used reg = )
18680 50BF           B0                     80  mov	al,#$80
18681 50C1           8846         13            mov	$13[bp],al
18682                                           !BCC_EOS
18683                                           ! 3409       break;
18684 50C4           EB           6B            jmp .438
18685                                           !BCC_EOS
18686                                           ! 3410     case 0xA2:
18687                                           ! 3411       break;
18688                       000050C6            .478:
18689 50C6           EB           69            jmp .438
18690                                           !BCC_EOS
18691                                           ! 3412     case 0x6F:
18692                                           ! 3413       if (( AX & 0x00ff ) == 0x08)
18693                       000050C8            .479:
18694                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
18695 50C8           8A46         12            mov	al,$12[bp]
18696                                           ! Debug: logeq int = const 8 to unsigned char = al+0 (used reg = )
18697 50CB           3C                     08  cmp	al,*8
18698 50CD           75           05            jne 	.47A
18699                       000050CF            .47B:
18700                                           ! 3414         *(((Bit8u *)&AX)+1) = (0x02);
18701                                           ! Debug: eq int = const 2 to unsigned char AX = [S+$C+$11] (used reg = )
18702 50CF           B0                     02  mov	al,*2
18703 50D1           8846         13            mov	$13[bp],al
18704                                           !BCC_EOS
18705                                           ! 3415     default:
18706                       000050D4            .47A:
18707                                           ! 3416       bios_printf(4, "KBD: unsupported int 16h function %02x\n", *(((Bit8u *)&AX)+1));
18708                       000050D4            .47C:
18709                                           ! Debug: list unsigned char AX = [S+$C+$11] (used reg = )
18710 50D4           8A46         13            mov	al,$13[bp]
18711 50D7           30E4                       xor	ah,ah
18712 50D9           50                         push	ax
18713                                           ! Debug: list * char = .47D+0 (used reg = )
18714 50DA           BB                   D349  mov	bx,#.47D
18715 50DD           53                         push	bx
18716                                           ! Debug: list int = const 4 (used reg = )
18717 50DE           B8                   0004  mov	ax,*4
18718 50E1           50                         push	ax
18719                                           ! Debug: func () void = bios_printf+0 (used reg = )
18720 50E2           E8         B859            call	_bios_printf
18721 50E5           83C4                   06  add	sp,*6
18722                                           !BCC_EOS
18723                                           ! 3417   }
18724                                           ! 3418 }
18725 50E8           EB           47            jmp .438
18726                       000050EA            .43A:
18727 50EA           2C                     00  sub	al,*0
18728 50EC           72           E6            jb 	.47C
18729 50EE           3C                     12  cmp	al,*$12
18730 50F0           77           31            ja  	.47E
18731 50F2           30E4                       xor	ah,ah
18732 50F4           D1E0                       shl	ax,*1
18733 50F6           89C3                       mov	bx,ax
18734 50F8           2E                         seg	cs
18735 50F9           FFA7       50FD            br	.47F[bx]
18736                       000050FD            .47F:
18737 50FD                      4E4E            .word	.43B
18738 50FF                      4EA5            .word	.445
18739 5101                      4F01            .word	.44E
18740 5103                      50D4            .word	.47C
18741 5105                      50D4            .word	.47C
18742 5107                      4F10            .word	.44F
18743 5109                      50D4            .word	.47C
18744 510B                      50D4            .word	.47C
18745 510D                      50D4            .word	.47C
18746 510F                      4F35            .word	.453
18747 5111                      4F3D            .word	.454
18748 5113                      50D4            .word	.47C
18749 5115                      50D4            .word	.47C
18750 5117                      50D4            .word	.47C
18751 5119                      50D4            .word	.47C
18752 511B                      50D4            .word	.47C
18753 511D                      5001            .word	.469
18754 511F                      504A            .word	.470
18755 5121                      5098            .word	.476
18756                       00005123            .47E:
18757 5123           2C                     6F  sub	al,*$6F
18758 5125           74           A1            je 	.479
18759 5127           2C                     23  sub	al,*$23
18760 5129           74           94            je 	.477
18761 512B           2C                     10  sub	al,*$10
18762 512D           74           97            je 	.478
18763 512F           EB           A3            jmp	.47C
18764                       00005131            .438:
18765                       FFFFFFF4            ..FFF3	=	-$C
18766 5131           89EC                       mov	sp,bp
18767 5133           5D                         pop	bp
18768 5134           C3                         ret
18769                                           ! 3419   unsigned int
18770                                           ! Register BX used in function int16_function
18771                                           ! 3420 dequeue_key(scan_code, ascii_code, incr)
18772                                           ! 3421   Bit8u *scan_code;
18773                                           export	_dequeue_key
18774                       00005135            _dequeue_key:
18775                                           !BCC_EOS
18776                                           ! 3422   Bit8u *ascii_code;
18777                                           !BCC_EOS
18778                                           ! 3423   unsigned int incr;
18779                                           !BCC_EOS
18780                                           ! 3424 {
18781                                           ! 3425   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail;
18782                                           !BCC_EOS
18783                                           ! 3426   Bit8u acode, scode;
18784                                           !BCC_EOS
18785                                           ! 3427   buffer_start = *((Bit16u *)(0x0080));
18786 5135           55                         push	bp
18787 5136           89E5                       mov	bp,sp
18788 5138           83C4                   F6  add	sp,*-$A
18789                                           ! Debug: eq unsigned short = [+$80] to unsigned short buffer_start = [S+$C-4] (used reg = )
18790 513B           A1         0080            mov	ax,[$80]
18791 513E           8946         FE            mov	-2[bp],ax
18792                                           !BCC_EOS
18793                                           ! 3428   buffer_end = *((Bit16u *)(0x0082));
18794                                           ! Debug: eq unsigned short = [+$82] to unsigned short buffer_end = [S+$C-6] (used reg = )
18795 5141           A1         0082            mov	ax,[$82]
18796 5144           8946         FC            mov	-4[bp],ax
18797                                           !BCC_EOS
18798                                           ! 3429   buffer_head = *((Bit16u *)(0x001a));
18799                                           ! Debug: eq unsigned short = [+$1A] to unsigned short buffer_head = [S+$C-8] (used reg = )
18800 5147           A1         001A            mov	ax,[$1A]
18801 514A           8946         FA            mov	-6[bp],ax
18802                                           !BCC_EOS
18803                                           ! 3430   buffer_tail = *((Bit16u *)(0x001c));
18804                                           ! Debug: eq unsigned short = [+$1C] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
18805 514D           A1         001C            mov	ax,[$1C]
18806 5150           8946         F8            mov	-8[bp],ax
18807                                           !BCC_EOS
18808                                           ! 3431   if (buffer_head != buffer_tail) {
18809                                           ! Debug: ne unsigned short buffer_tail = [S+$C-$A] to unsigned short buffer_head = [S+$C-8] (used reg = )
18810 5153           8B46         FA            mov	ax,-6[bp]
18811 5156           3B46         F8            cmp	ax,-8[bp]
18812 5159           74           5D            je  	.480
18813                       0000515B            .481:
18814                                           ! 3432     acode = *((Bit8u *)(buffer_head));
18815 515B           8B5E         FA            mov	bx,-6[bp]
18816                                           ! Debug: eq unsigned char = [bx+0] to unsigned char acode = [S+$C-$B] (used reg = )
18817 515E           8A07                       mov	al,[bx]
18818 5160           8846         F7            mov	-9[bp],al
18819                                           !BCC_EOS
18820                                           ! 3433     scode = *((Bit8u *)(buffer_head+1));
18821                                           ! Debug: add int = const 1 to unsigned short buffer_head = [S+$C-8] (used reg = )
18822 5163           8B46         FA            mov	ax,-6[bp]
18823                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+1 (used reg = )
18824 5166           89C3                       mov	bx,ax
18825                                           ! Debug: eq unsigned char = [bx+1] to unsigned char scode = [S+$C-$C] (used reg = )
18826 5168           8A47         01            mov	al,1[bx]
18827 516B           8846         F6            mov	-$A[bp],al
18828                                           !BCC_EOS
18829                                           ! 3434     _write_byte_SS(acode, ascii_code);
18830                                           ! Debug: list * unsigned char ascii_code = [S+$C+4] (used reg = )
18831 516E           FF76         06            push	6[bp]
18832                                           ! Debug: list unsigned char acode = [S+$E-$B] (used reg = )
18833 5171           8A46         F7            mov	al,-9[bp]
18834 5174           30E4                       xor	ah,ah
18835 5176           50                         push	ax
18836                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
18837 5177           E8         B4C2            call	__write_byte_SS
18838 517A           83C4                   04  add	sp,*4
18839                                           !BCC_EOS
18840                                           ! 3435     _write_byte_SS(scode, scan_code);
18841                                           ! Debug: list * unsigned char scan_code = [S+$C+2] (used reg = )
18842 517D           FF76         04            push	4[bp]
18843                                           ! Debug: list unsigned char scode = [S+$E-$C] (used reg = )
18844 5180           8A46         F6            mov	al,-$A[bp]
18845 5183           30E4                       xor	ah,ah
18846 5185           50                         push	ax
18847                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
18848 5186           E8         B4B3            call	__write_byte_SS
18849 5189           83C4                   04  add	sp,*4
18850                                           !BCC_EOS
18851                                           ! 3436     if (incr) {
18852 518C           8B46         08            mov	ax,8[bp]
18853 518F           85C0                       test	ax,ax
18854 5191           74           1C            je  	.482
18855                       00005193            .483:
18856                                           ! 3437       buffer_head += 2;
18857                                           ! Debug: addab int = const 2 to unsigned short buffer_head = [S+$C-8] (used reg = )
18858 5193           8B46         FA            mov	ax,-6[bp]
18859 5196           40                         inc	ax
18860 5197           40                         inc	ax
18861 5198           8946         FA            mov	-6[bp],ax
18862                                           !BCC_EOS
18863                                           ! 3438       if (buffer_head >= buffer_end)
18864                                           ! Debug: ge unsigned short buffer_end = [S+$C-6] to unsigned short buffer_head = [S+$C-8] (used reg = )
18865 519B           8B46         FA            mov	ax,-6[bp]
18866 519E           3B46         FC            cmp	ax,-4[bp]
18867 51A1           72           06            jb  	.484
18868                       000051A3            .485:
18869                                           ! 3439         buffer_head = buffer_start;
18870                                           ! Debug: eq unsigned short buffer_start = [S+$C-4] to unsigned short buffer_head = [S+$C-8] (used reg = )
18871 51A3           8B46         FE            mov	ax,-2[bp]
18872 51A6           8946         FA            mov	-6[bp],ax
18873                                           !BCC_EOS
18874                                           ! 3440       *((Bit16u *)(0x001a)) = (buffer_head);
18875                       000051A9            .484:
18876                                           ! Debug: eq unsigned short buffer_head = [S+$C-8] to unsigned short = [+$1A] (used reg = )
18877 51A9           8B46         FA            mov	ax,-6[bp]
18878 51AC           A3         001A            mov	[$1A],ax
18879                                           !BCC_EOS
18880                                           ! 3441     }
18881                                           ! 3442     return(1);
18882                       000051AF            .482:
18883 51AF           B8                   0001  mov	ax,*1
18884 51B2           89EC                       mov	sp,bp
18885 51B4           5D                         pop	bp
18886 51B5           C3                         ret
18887                                           !BCC_EOS
18888                                           ! 3443   }
18889                                           ! 3444   else {
18890 51B6           EB           06            jmp .486
18891                       000051B8            .480:
18892                                           ! 3445     return(0);
18893 51B8           31C0                       xor	ax,ax
18894 51BA           89EC                       mov	sp,bp
18895 51BC           5D                         pop	bp
18896 51BD           C3                         ret
18897                                           !BCC_EOS
18898                                           ! 3446   }
18899                                           ! 3447 }
18900                       000051BE            .486:
18901 51BE           89EC                       mov	sp,bp
18902 51C0           5D                         pop	bp
18903 51C1           C3                         ret
18904                                           ! 3448 static char panic_msg_keyb_buffer_full[] = "%s: keyboard input buffer full\n";
18905                                           ! Register BX used in function dequeue_key
18906                                           
18907                       000051C2            _panic_msg_keyb_buffer_full:
18908                       000051C2            .487:
18909 51C2                        25            .ascii	"%s: keyboard input buffer full"
18910 51E0                        0A            .byte	$A
18911 51E1                        00            .byte	0
18912                                           !BCC_EOS
18913                                           ! 3449   Bit8u
18914                                           ! 3450 inhibit_mouse_int_and_events()
18915                                           ! 3451 {
18916                                           
18917                                           export	_inhibit_mouse_int_and_events
18918                       000051E2            _inhibit_mouse_int_and_events:
18919                                           ! 3452   Bit8u command_byte, prev_command_byte;
18920                                           !BCC_EOS
18921                                           ! 3453   if ( inb(0x0064) & 0x02 )
18922 51E2           55                         push	bp
18923 51E3           89E5                       mov	bp,sp
18924 51E5           4C                         dec	sp
18925 51E6           4C                         dec	sp
18926                                           ! Debug: list int = const $64 (used reg = )
18927 51E7           B8                   0064  mov	ax,*$64
18928 51EA           50                         push	ax
18929                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18930 51EB           E8         B30A            call	_inb
18931 51EE           44                         inc	sp
18932 51EF           44                         inc	sp
18933                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
18934 51F0           24                     02  and	al,*2
18935 51F2           84C0                       test	al,al
18936 51F4           74           12            je  	.488
18937                       000051F6            .489:
18938                                           ! 3454     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
18939                                           ! Debug: list * char = .48A+0 (used reg = )
18940 51F6           BB                   D33E  mov	bx,#.48A
18941 51F9           53                         push	bx
18942                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
18943 51FA           BB                   51C2  mov	bx,#_panic_msg_keyb_buffer_full
18944 51FD           53                         push	bx
18945                                           ! Debug: list int = const 7 (used reg = )
18946 51FE           B8                   0007  mov	ax,*7
18947 5201           50                         push	ax
18948                                           ! Debug: func () void = bios_printf+0 (used reg = )
18949 5202           E8         B739            call	_bios_printf
18950 5205           83C4                   06  add	sp,*6
18951                                           !BCC_EOS
18952                                           ! 3455   outb(0x0064, 0x20);
18953                       00005208            .488:
18954                                           ! Debug: list int = const $20 (used reg = )
18955 5208           B8                   0020  mov	ax,*$20
18956 520B           50                         push	ax
18957                                           ! Debug: list int = const $64 (used reg = )
18958 520C           B8                   0064  mov	ax,*$64
18959 520F           50                         push	ax
18960                                           ! Debug: func () void = outb+0 (used reg = )
18961 5210           E8         B2FB            call	_outb
18962 5213           83C4                   04  add	sp,*4
18963                                           !BCC_EOS
18964                                           ! 3456   while ( (inb(0x0064) & 0x01) != 0x01 );
18965 5216           EB           00            jmp .48C
18966                       00005218            .48D:
18967                                           !BCC_EOS
18968                                           ! 3457   prev_command_byte = inb(0x0060);
18969                       00005218            .48C:
18970                                           ! Debug: list int = const $64 (used reg = )
18971 5218           B8                   0064  mov	ax,*$64
18972 521B           50                         push	ax
18973                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18974 521C           E8         B2D9            call	_inb
18975 521F           44                         inc	sp
18976 5220           44                         inc	sp
18977                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
18978 5221           24                     01  and	al,*1
18979                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
18980 5223           3C                     01  cmp	al,*1
18981 5225           75           F1            jne	.48D
18982                       00005227            .48E:
18983                       00005227            .48B:
18984                                           ! Debug: list int = const $60 (used reg = )
18985 5227           B8                   0060  mov	ax,*$60
18986 522A           50                         push	ax
18987                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18988 522B           E8         B2CA            call	_inb
18989 522E           44                         inc	sp
18990 522F           44                         inc	sp
18991                                           ! Debug: eq unsigned char = al+0 to unsigned char prev_command_byte = [S+4-4] (used reg = )
18992 5230           8846         FE            mov	-2[bp],al
18993                                           !BCC_EOS
18994                                           ! 3458   command_byte = prev_command_byte;
18995                                           ! Debug: eq unsigned char prev_command_byte = [S+4-4] to unsigned char command_byte = [S+4-3] (used reg = )
18996 5233           8A46         FE            mov	al,-2[bp]
18997 5236           8846         FF            mov	-1[bp],al
18998                                           !BCC_EOS
18999                                           ! 3459   if ( inb(0x0064) & 0x02 )
19000                                           ! Debug: list int = const $64 (used reg = )
19001 5239           B8                   0064  mov	ax,*$64
19002 523C           50                         push	ax
19003                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19004 523D           E8         B2B8            call	_inb
19005 5240           44                         inc	sp
19006 5241           44                         inc	sp
19007                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
19008 5242           24                     02  and	al,*2
19009 5244           84C0                       test	al,al
19010 5246           74           12            je  	.48F
19011                       00005248            .490:
19012                                           ! 3460     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
19013                                           ! Debug: list * char = .491+0 (used reg = )
19014 5248           BB                   D333  mov	bx,#.491
19015 524B           53                         push	bx
19016                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
19017 524C           BB                   51C2  mov	bx,#_panic_msg_keyb_buffer_full
19018 524F           53                         push	bx
19019                                           ! Debug: list int = const 7 (used reg = )
19020 5250           B8                   0007  mov	ax,*7
19021 5253           50                         push	ax
19022                                           ! Debug: func () void = bios_printf+0 (used reg = )
19023 5254           E8         B6E7            call	_bios_printf
19024 5257           83C4                   06  add	sp,*6
19025                                           !BCC_EOS
19026                                           ! 3461   command_byte &= 0xfd;
19027                       0000525A            .48F:
19028                                           ! Debug: andab int = const $FD to unsigned char command_byte = [S+4-3] (used reg = )
19029 525A           8A46         FF            mov	al,-1[bp]
19030 525D           24                     FD  and	al,#$FD
19031 525F           8846         FF            mov	-1[bp],al
19032                                           !BCC_EOS
19033                                           ! 3462   command_byte |= 0x20;
19034                                           ! Debug: orab int = const $20 to unsigned char command_byte = [S+4-3] (used reg = )
19035 5262           8A46         FF            mov	al,-1[bp]
19036 5265           0C                     20  or	al,*$20
19037 5267           8846         FF            mov	-1[bp],al
19038                                           !BCC_EOS
19039                                           ! 3463   outb(0x0064, 0x60);
19040                                           ! Debug: list int = const $60 (used reg = )
19041 526A           B8                   0060  mov	ax,*$60
19042 526D           50                         push	ax
19043                                           ! Debug: list int = const $64 (used reg = )
19044 526E           B8                   0064  mov	ax,*$64
19045 5271           50                         push	ax
19046                                           ! Debug: func () void = outb+0 (used reg = )
19047 5272           E8         B299            call	_outb
19048 5275           83C4                   04  add	sp,*4
19049                                           !BCC_EOS
19050                                           ! 3464   outb(0x0060, command_byte);
19051                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
19052 5278           8A46         FF            mov	al,-1[bp]
19053 527B           30E4                       xor	ah,ah
19054 527D           50                         push	ax
19055                                           ! Debug: list int = const $60 (used reg = )
19056 527E           B8                   0060  mov	ax,*$60
19057 5281           50                         push	ax
19058                                           ! Debug: func () void = outb+0 (used reg = )
19059 5282           E8         B289            call	_outb
19060 5285           83C4                   04  add	sp,*4
19061                                           !BCC_EOS
19062                                           ! 3465   return(prev_command_byte);
19063 5288           8A46         FE            mov	al,-2[bp]
19064 528B           89EC                       mov	sp,bp
19065 528D           5D                         pop	bp
19066 528E           C3                         ret
19067                                           !BCC_EOS
19068                                           ! 3466 }
19069                                           ! 3467   void
19070                                           ! Register BX used in function inhibit_mouse_int_and_events
19071                                           ! 3468 enable_mouse_int_and_events()
19072                                           ! 3469 {
19073                                           export	_enable_mouse_int_and_events
19074                       0000528F            _enable_mouse_int_and_events:
19075                                           ! 3470   Bit8u command_byte;
19076                                           !BCC_EOS
19077                                           ! 3471   if ( inb(0x0064) & 0x02 )
19078 528F           55                         push	bp
19079 5290           89E5                       mov	bp,sp
19080 5292           4C                         dec	sp
19081 5293           4C                         dec	sp
19082                                           ! Debug: list int = const $64 (used reg = )
19083 5294           B8                   0064  mov	ax,*$64
19084 5297           50                         push	ax
19085                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19086 5298           E8         B25D            call	_inb
19087 529B           44                         inc	sp
19088 529C           44                         inc	sp
19089                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
19090 529D           24                     02  and	al,*2
19091 529F           84C0                       test	al,al
19092 52A1           74           12            je  	.492
19093                       000052A3            .493:
19094                                           ! 3472  
19095                                           ! 3472    bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
19096                                           ! Debug: list * char = .494+0 (used reg = )
19097 52A3           BB                   D329  mov	bx,#.494
19098 52A6           53                         push	bx
19099                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
19100 52A7           BB                   51C2  mov	bx,#_panic_msg_keyb_buffer_full
19101 52AA           53                         push	bx
19102                                           ! Debug: list int = const 7 (used reg = )
19103 52AB           B8                   0007  mov	ax,*7
19104 52AE           50                         push	ax
19105                                           ! Debug: func () void = bios_printf+0 (used reg = )
19106 52AF           E8         B68C            call	_bios_printf
19107 52B2           83C4                   06  add	sp,*6
19108                                           !BCC_EOS
19109                                           ! 3473   outb(0x0064, 0x20);
19110                       000052B5            .492:
19111                                           ! Debug: list int = const $20 (used reg = )
19112 52B5           B8                   0020  mov	ax,*$20
19113 52B8           50                         push	ax
19114                                           ! Debug: list int = const $64 (used reg = )
19115 52B9           B8                   0064  mov	ax,*$64
19116 52BC           50                         push	ax
19117                                           ! Debug: func () void = outb+0 (used reg = )
19118 52BD           E8         B24E            call	_outb
19119 52C0           83C4                   04  add	sp,*4
19120                                           !BCC_EOS
19121                                           ! 3474   while ( (inb(0x0064) & 0x01) != 0x01 );
19122 52C3           EB           00            jmp .496
19123                       000052C5            .497:
19124                                           !BCC_EOS
19125                                           ! 3475   command_byte = inb(0x0060);
19126                       000052C5            .496:
19127                                           ! Debug: list int = const $64 (used reg = )
19128 52C5           B8                   0064  mov	ax,*$64
19129 52C8           50                         push	ax
19130                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19131 52C9           E8         B22C            call	_inb
19132 52CC           44                         inc	sp
19133 52CD           44                         inc	sp
19134                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
19135 52CE           24                     01  and	al,*1
19136                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
19137 52D0           3C                     01  cmp	al,*1
19138 52D2           75           F1            jne	.497
19139                       000052D4            .498:
19140                       000052D4            .495:
19141                                           ! Debug: list int = const $60 (used reg = )
19142 52D4           B8                   0060  mov	ax,*$60
19143 52D7           50                         push	ax
19144                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19145 52D8           E8         B21D            call	_inb
19146 52DB           44                         inc	sp
19147 52DC           44                         inc	sp
19148                                           ! Debug: eq unsigned char = al+0 to unsigned char command_byte = [S+4-3] (used reg = )
19149 52DD           8846         FF            mov	-1[bp],al
19150                                           !BCC_EOS
19151                                           ! 3476   if ( inb(0x0064) & 0x02 )
19152                                           ! Debug: list int = const $64 (used reg = )
19153 52E0           B8                   0064  mov	ax,*$64
19154 52E3           50                         push	ax
19155                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19156 52E4           E8         B211            call	_inb
19157 52E7           44                         inc	sp
19158 52E8           44                         inc	sp
19159                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
19160 52E9           24                     02  and	al,*2
19161 52EB           84C0                       test	al,al
19162 52ED           74           12            je  	.499
19163                       000052EF            .49A:
19164                                           ! 3477     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
19165                                           ! Debug: list * char = .49B+0 (used reg = )
19166 52EF           BB                   D31F  mov	bx,#.49B
19167 52F2           53                         push	bx
19168                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
19169 52F3           BB                   51C2  mov	bx,#_panic_msg_keyb_buffer_full
19170 52F6           53                         push	bx
19171                                           ! Debug: list int = const 7 (used reg = )
19172 52F7           B8                   0007  mov	ax,*7
19173 52FA           50                         push	ax
19174                                           ! Debug: func () void = bios_printf+0 (used reg = )
19175 52FB           E8         B640            call	_bios_printf
19176 52FE           83C4                   06  add	sp,*6
19177                                           !BCC_EOS
19178                                           ! 3478   command_byte |= 0x02;
19179                       00005301            .499:
19180                                           ! Debug: orab int = const 2 to unsigned char command_byte = [S+4-3] (used reg = )
19181 5301           8A46         FF            mov	al,-1[bp]
19182 5304           0C                     02  or	al,*2
19183 5306           8846         FF            mov	-1[bp],al
19184                                           !BCC_EOS
19185                                           ! 3479   command_byte &= 0xdf;
19186                                           ! Debug: andab int = const $DF to unsigned char command_byte = [S+4-3] (used reg = )
19187 5309           8A46         FF            mov	al,-1[bp]
19188 530C           24                     DF  and	al,#$DF
19189 530E           8846         FF            mov	-1[bp],al
19190                                           !BCC_EOS
19191                                           ! 3480   outb(0x0064, 0x60);
19192                                           ! Debug: list int = const $60 (used reg = )
19193 5311           B8                   0060  mov	ax,*$60
19194 5314           50                         push	ax
19195                                           ! Debug: list int = const $64 (used reg = )
19196 5315           B8                   0064  mov	ax,*$64
19197 5318           50                         push	ax
19198                                           ! Debug: func () void = outb+0 (used reg = )
19199 5319           E8         B1F2            call	_outb
19200 531C           83C4                   04  add	sp,*4
19201                                           !BCC_EOS
19202                                           ! 3481   outb(0x0060, command_byte);
19203                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
19204 531F           8A46         FF            mov	al,-1[bp]
19205 5322           30E4                       xor	ah,ah
19206 5324           50                         push	ax
19207                                           ! Debug: list int = const $60 (used reg = )
19208 5325           B8                   0060  mov	ax,*$60
19209 5328           50                         push	ax
19210                                           ! Debug: func () void = outb+0 (used reg = )
19211 5329           E8         B1E2            call	_outb
19212 532C           83C4                   04  add	sp,*4
19213                                           !BCC_EOS
19214                                           ! 3482 }
19215 532F           89EC                       mov	sp,bp
19216 5331           5D                         pop	bp
19217 5332           C3                         ret
19218                                           ! 3483   Bit8u
19219                                           ! Register BX used in function enable_mouse_int_and_events
19220                                           ! 3484 send_to_mouse_ctrl(sendbyte)
19221                                           ! 3485   Bit8u sendbyte;
19222                                           export	_send_to_mouse_ctrl
19223                       00005333            _send_to_mouse_ctrl:
19224                                           !BCC_EOS
19225                                           ! 3486 {
19226                                           ! 3487   Bit8u response;
19227                                           !BCC_EOS
19228                                           ! 3488   if ( inb(0x0064) & 0x02 )
19229 5333           55                         push	bp
19230 5334           89E5                       mov	bp,sp
19231 5336           4C                         dec	sp
19232 5337           4C                         dec	sp
19233                                           ! Debug: list int = const $64 (used reg = )
19234 5338           B8                   0064  mov	ax,*$64
19235 533B           50                         push	ax
19236                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19237 533C           E8         B1B9            call	_inb
19238 533F           44                         inc	sp
19239 5340           44                         inc	sp
19240                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
19241 5341           24                     02  and	al,*2
19242 5343           84C0                       test	al,al
19243 5345           74           12            je  	.49C
19244                       00005347            .49D:
19245                                           ! 3489     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"sendmouse");
19246                                           ! Debug: list * char = .49E+0 (used reg = )
19247 5347           BB                   D315  mov	bx,#.49E
19248 534A           53                         push	bx
19249                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
19250 534B           BB                   51C2  mov	bx,#_panic_msg_keyb_buffer_full
19251 534E           53                         push	bx
19252                                           ! Debug: list int = const 7 (used reg = )
19253 534F           B8                   0007  mov	ax,*7
19254 5352           50                         push	ax
19255                                           ! Debug: func () void = bios_printf+0 (used reg = )
19256 5353           E8         B5E8            call	_bios_printf
19257 5356           83C4                   06  add	sp,*6
19258                                           !BCC_EOS
19259                                           ! 3490   outb(0x0064, 0xD4);
19260                       00005359            .49C:
19261                                           ! Debug: list int = const $D4 (used reg = )
19262 5359           B8                   00D4  mov	ax,#$D4
19263 535C           50                         push	ax
19264                                           ! Debug: list int = const $64 (used reg = )
19265 535D           B8                   0064  mov	ax,*$64
19266 5360           50                         push	ax
19267                                           ! Debug: func () void = outb+0 (used reg = )
19268 5361           E8         B1AA            call	_outb
19269 5364           83C4                   04  add	sp,*4
19270                                           !BCC_EOS
19271                                           ! 3491   outb(0x0060, sendbyte);
19272                                           ! Debug: list unsigned char sendbyte = [S+4+2] (used reg = )
19273 5367           8A46         04            mov	al,4[bp]
19274 536A           30E4                       xor	ah,ah
19275 536C           50                         push	ax
19276                                           ! Debug: list int = const $60 (used reg = )
19277 536D           B8                   0060  mov	ax,*$60
19278 5370           50                         push	ax
19279                                           ! Debug: func () void = outb+0 (used reg = )
19280 5371           E8         B19A            call	_outb
19281 5374           83C4                   04  add	sp,*4
19282                                           !BCC_EOS
19283                                           ! 3492   return(0);
19284 5377           30C0                       xor	al,al
19285 5379           89EC                       mov	sp,bp
19286 537B           5D                         pop	bp
19287 537C           C3                         ret
19288                                           !BCC_EOS
19289                                           ! 3493 }
19290                                           ! 3494   Bit8u
19291                                           ! Register BX used in function send_to_mouse_ctrl
19292                                           ! 3495 get_mouse_data(data)
19293                                           ! 3496   Bit8u *data;
19294                                           export	_get_mouse_data
19295                       0000537D            _get_mouse_data:
19296                                           !BCC_EOS
19297                                           ! 3497 {
19298                                           ! 3498   Bit8u response;
19299                                           !BCC_EOS
19300                                           ! 3499   while ((inb(0x0064) & 0x21) != 0x21) { }
19301 537D           55                         push	bp
19302 537E           89E5                       mov	bp,sp
19303 5380           4C                         dec	sp
19304 5381           4C                         dec	sp
19305 5382           EB           00            jmp .4A0
19306                       00005384            .4A1:
19307                                           ! 3500   response = inb(0x0060);
19308                       00005384            .4A0:
19309                                           ! Debug: list int = const $64 (used reg = )
19310 5384           B8                   0064  mov	ax,*$64
19311 5387           50                         push	ax
19312                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19313 5388           E8         B16D            call	_inb
19314 538B           44                         inc	sp
19315 538C           44                         inc	sp
19316                                           ! Debug: and int = const $21 to unsigned char = al+0 (used reg = )
19317 538D           24                     21  and	al,*$21
19318                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
19319 538F           3C                     21  cmp	al,*$21
19320 5391           75           F1            jne	.4A1
19321                       00005393            .4A2:
19322                       00005393            .49F:
19323                                           ! Debug: list int = const $60 (used reg = )
19324 5393           B8                   0060  mov	ax,*$60
19325 5396           50                         push	ax
19326                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19327 5397           E8         B15E            call	_inb
19328 539A           44                         inc	sp
19329 539B           44                         inc	sp
19330                                           ! Debug: eq unsigned char = al+0 to unsigned char response = [S+4-3] (used reg = )
19331 539C           8846         FF            mov	-1[bp],al
19332                                           !BCC_EOS
19333                                           ! 3501   _write_byte_SS(response, data);
19334                                           ! Debug: list * unsigned char data = [S+4+2] (used reg = )
19335 539F           FF76         04            push	4[bp]
19336                                           ! Debug: list unsigned char response = [S+6-3] (used reg = )
19337 53A2           8A46         FF            mov	al,-1[bp]
19338 53A5           30E4                       xor	ah,ah
19339 53A7           50                         push	ax
19340                                           ! Debug: func () void = _write_byte_SS+0 (used reg = )
19341 53A8           E8         B291            call	__write_byte_SS
19342 53AB           83C4                   04  add	sp,*4
19343                                           !BCC_EOS
19344                                           ! 3502   return(0);
19345 53AE           30C0                       xor	al,al
19346 53B0           89EC                       mov	sp,bp
19347 53B2           5D                         pop	bp
19348 53B3           C3                         ret
19349                                           !BCC_EOS
19350                                           ! 3503 }
19351                                           ! 3504   void
19352                                           ! 3505 set_kbd_command_byte(command_byte)
19353                                           ! 3506   Bit8u command_byte;
19354                                           export	_set_kbd_command_byte
19355                       000053B4            _set_kbd_command_byte:
19356                                           !BCC_EOS
19357                                           ! 3507 {
19358                                           ! 3508   if ( inb(0x0064) & 0x02 )
19359 53B4           55                         push	bp
19360 53B5           89E5                       mov	bp,sp
19361                                           ! Debug: list int = const $64 (used reg = )
19362 53B7           B8                   0064  mov	ax,*$64
19363 53BA           50                         push	ax
19364                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19365 53BB           E8         B13A            call	_inb
19366 53BE           89EC                       mov	sp,bp
19367                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
19368 53C0           24                     02  and	al,*2
19369 53C2           84C0                       test	al,al
19370 53C4           74           11            je  	.4A3
19371                       000053C6            .4A4:
19372                                           ! 3509     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"setkbdcomm");
19373                                           ! Debug: list * char = .4A5+0 (used reg = )
19374 53C6           BB                   D30A  mov	bx,#.4A5
19375 53C9           53                         push	bx
19376                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
19377 53CA           BB                   51C2  mov	bx,#_panic_msg_keyb_buffer_full
19378 53CD           53                         push	bx
19379                                           ! Debug: list int = const 7 (used reg = )
19380 53CE           B8                   0007  mov	ax,*7
19381 53D1           50                         push	ax
19382                                           ! Debug: func () void = bios_printf+0 (used reg = )
19383 53D2           E8         B569            call	_bios_printf
19384 53D5           89EC                       mov	sp,bp
19385                                           !BCC_EOS
19386                                           ! 3510   outb(0x0064, 0xD4);
19387                       000053D7            .4A3:
19388                                           ! Debug: list int = const $D4 (used reg = )
19389 53D7           B8                   00D4  mov	ax,#$D4
19390 53DA           50                         push	ax
19391                                           ! Debug: list int = const $64 (used reg = )
19392 53DB           B8                   0064  mov	ax,*$64
19393 53DE           50                         push	ax
19394                                           ! Debug: func () void = outb+0 (used reg = )
19395 53DF           E8         B12C            call	_outb
19396 53E2           89EC                       mov	sp,bp
19397                                           !BCC_EOS
19398                                           ! 3511   outb(0x0064, 0x60);
19399                                           ! Debug: list int = const $60 (used reg = )
19400 53E4           B8                   0060  mov	ax,*$60
19401 53E7           50                         push	ax
19402                                           ! Debug: list int = const $64 (used reg = )
19403 53E8           B8                   0064  mov	ax,*$64
19404 53EB           50                         push	ax
19405                                           ! Debug: func () void = outb+0 (used reg = )
19406 53EC           E8         B11F            call	_outb
19407 53EF           89EC                       mov	sp,bp
19408                                           !BCC_EOS
19409                                           ! 3512   outb(0x0060, command_byte);
19410                                           ! Debug: list unsigned char command_byte = [S+2+2] (used reg = )
19411 53F1           8A46         04            mov	al,4[bp]
19412 53F4           30E4                       xor	ah,ah
19413 53F6           50                         push	ax
19414                                           ! Debug: list int = const $60 (used reg = )
19415 53F7           B8                   0060  mov	ax,*$60
19416 53FA           50                         push	ax
19417                                           ! Debug: func () void = outb+0 (used reg = )
19418 53FB           E8         B110            call	_outb
19419 53FE           89EC                       mov	sp,bp
19420                                           !BCC_EOS
19421                                           ! 3513 }
19422 5400           5D                         pop	bp
19423 5401           C3                         ret
19424                                           ! 3514   void
19425                                           ! Register BX used in function set_kbd_command_byte
19426                                           ! 3515 int09_function(DI, SI, BP, SP, BX, DX, CX, AX)
19427                                           ! 3516   Bit16u DI, SI, BP, SP, BX, DX, CX, AX;
19428                                           export	_int09_function
19429                       00005402            _int09_function:
19430                                           !BCC_EOS
19431                                           ! 3517 {
19432                                           ! 3518   Bit8u scancode, asciicode, shift_flags;
19433                                           !BCC_EOS
19434                                           ! 3519   Bit8u mf2_flags, mf2_state;
19435                                           !BCC_EOS
19436                                           ! 3520   scancode = ( AX & 0x00ff );
19437 5402           55                         push	bp
19438 5403           89E5                       mov	bp,sp
19439 5405           83C4                   FA  add	sp,*-6
19440                                           ! Debug: and int = const $FF to unsigned short AX = [S+8+$10] (used reg = )
19441 5408           8A46         12            mov	al,$12[bp]
19442                                           ! Debug: eq unsigned char = al+0 to unsigned char scancode = [S+8-3] (used reg = )
19443 540B           8846         FF            mov	-1[bp],al
19444                                           !BCC_EOS
19445                                           ! 3521   if (scancode == 0) {
19446                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
19447 540E           8A46         FF            mov	al,-1[bp]
19448 5411           84C0                       test	al,al
19449 5413           75           12            jne 	.4A6
19450                       00005415            .4A7:
19451                                           ! 3522     bios_printf(4, "KBD: int09 handler: AL=0\n");
19452                                           ! Debug: list * char = .4A8+0 (used reg = )
19453 5415           BB                   D2F0  mov	bx,#.4A8
19454 5418           53                         push	bx
19455                                           ! Debug: list int = const 4 (used reg = )
19456 5419           B8                   0004  mov	ax,*4
19457 541C           50                         push	ax
19458                                           ! Debug: func () void = bios_printf+0 (used reg = )
19459 541D           E8         B51E            call	_bios_printf
19460 5420           83C4                   04  add	sp,*4
19461                                           !BCC_EOS
19462                                           ! 3523     return;
19463 5423           89EC                       mov	sp,bp
19464 5425           5D                         pop	bp
19465 5426           C3                         ret
19466                                           !BCC_EOS
19467                                           ! 3524   }
19468                                           ! 3525   shift_flags = *((Bit8u *)(0x17));
19469                       00005427            .4A6:
19470                                           ! Debug: eq unsigned char = [+$17] to unsigned char shift_flags = [S+8-5] (used reg = )
19471 5427           A0         0017            mov	al,[$17]
19472 542A           8846         FD            mov	-3[bp],al
19473                                           !BCC_EOS
19474                                           ! 3526   mf2_flags = *((Bit8u *)(0x18));
19475                                           ! Debug: eq unsigned char = [+$18] to unsigned char mf2_flags = [S+8-6] (used reg = )
19476 542D           A0         0018            mov	al,[$18]
19477 5430           8846         FC            mov	-4[bp],al
19478                                           !BCC_EOS
19479                                           ! 3527   mf2_state = *((Bit8u *)(0x96));
19480                                           ! Debug: eq unsigned char = [+$96] to unsigned char mf2_state = [S+8-7] (used reg = )
19481 5433           A0         0096            mov	al,[$96]
19482 5436           8846         FB            mov	-5[bp],al
19483                                           !BCC_EOS
19484                                           ! 3528   asciicode = 0;
19485                                           ! Debug: eq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
19486 5439           30C0                       xor	al,al
19487 543B           8846         FE            mov	-2[bp],al
19488                                           !BCC_EOS
19489                                           ! 3529   switch (scancode) {
19490 543E           8A46         FF            mov	al,-1[bp]
19491 5441           E9         04B6            br 	.4AB
19492                                           ! 3530     case 0x3a:
19493                                           ! 3531       shift_flags ^= 0x40;
19494                       00005444            .4AC:
19495                                           ! Debug: eorab int = const $40 to unsigned char shift_flags = [S+8-5] (used reg = )
19496 5444           8A46         FD            mov	al,-3[bp]
19497 5447           34                     40  xor	al,*$40
19498 5449           8846         FD            mov	-3[bp],al
19499                                           !BCC_EOS
19500                                           ! 3532       *((Bit8u *)(0x17)) = (shift_flags);
19501                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19502 544C           8A46         FD            mov	al,-3[bp]
19503 544F           A2         0017            mov	[$17],al
19504                                           !BCC_EOS
19505                                           ! 3533       mf2_flags |= 0x40;
19506                                           ! Debug: orab int = const $40 to unsigned char mf2_flags = [S+8-6] (used reg = )
19507 5452           8A46         FC            mov	al,-4[bp]
19508 5455           0C                     40  or	al,*$40
19509 5457           8846         FC            mov	-4[bp],al
19510                                           !BCC_EOS
19511                                           ! 3534       *((Bit8u *)(0x18)) = (mf2_flags);
19512                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19513 545A           8A46         FC            mov	al,-4[bp]
19514 545D           A2         0018            mov	[$18],al
19515                                           !BCC_EOS
19516                                           ! 3535       break;
19517 5460           E9         04EE            br 	.4A9
19518                                           !BCC_EOS
19519                                           ! 3536     case 0xba:
19520                                           ! 3537       mf2_flags &= ~0x40;
19521                       00005463            .4AD:
19522                                           ! Debug: andab int = const -$41 to unsigned char mf2_flags = [S+8-6] (used reg = )
19523 5463           8A46         FC            mov	al,-4[bp]
19524 5466           24                     BF  and	al,#$BF
19525 5468           8846         FC            mov	-4[bp],al
19526                                           !BCC_EOS
19527                                           ! 3538       *((Bit8u *)(0x18)) = (mf2_flags);
19528                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19529 546B           8A46         FC            mov	al,-4[bp]
19530 546E           A2         0018            mov	[$18],al
19531                                           !BCC_EOS
19532                                           ! 3539       break;
19533 5471           E9         04DD            br 	.4A9
19534                                           !BCC_EOS
19535                                           ! 3540     case 0x2a:
19536                                           ! 3541       shift_flags |= 0x02;
19537                       00005474            .4AE:
19538                                           ! Debug: orab int = const 2 to unsigned char shift_flags = [S+8-5] (used reg = )
19539 5474           8A46         FD            mov	al,-3[bp]
19540 5477           0C                     02  or	al,*2
19541 5479           8846         FD            mov	-3[bp],al
19542                                           !BCC_EOS
19543                                           ! 3542       *((Bit8u *)(0x17)) = (shift_flags);
19544                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19545 547C           8A46         FD            mov	al,-3[bp]
19546 547F           A2         0017            mov	[$17],al
19547                                           !BCC_EOS
19548                                           ! 3543       break;
19549 5482           E9         04CC            br 	.4A9
19550                                           !BCC_EOS
19551                                           ! 3544     case 0xaa:
19552                                           ! 3545       shift_flags &= ~0x02;
19553                       00005485            .4AF:
19554                                           ! Debug: andab int = const -3 to unsigned char shift_flags = [S+8-5] (used reg = )
19555 5485           8A46         FD            mov	al,-3[bp]
19556 5488           24                     FD  and	al,#$FD
19557 548A           8846         FD            mov	-3[bp],al
19558                                           !BCC_EOS
19559                                           ! 3546       *((Bit8u *)(0x17)) = (shift_flags);
19560                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19561 548D           8A46         FD            mov	al,-3[bp]
19562 5490           A2         0017            mov	[$17],al
19563                                           !BCC_EOS
19564                                           ! 3547       break;
19565 5493           E9         04BB            br 	.4A9
19566                                           !BCC_EOS
19567                                           ! 3548     case 0x36:
19568                                           ! 3549       shift_flags |= 0x01;
19569                       00005496            .4B0:
19570                                           ! Debug: orab int = const 1 to unsigned char shift_flags = [S+8-5] (used reg = )
19571 5496           8A46         FD            mov	al,-3[bp]
19572 5499           0C                     01  or	al,*1
19573 549B           8846         FD            mov	-3[bp],al
19574                                           !BCC_EOS
19575                                           ! 3550       *((Bit8u *)(0x17)) = (shift_flags);
19576                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19577 549E           8A46         FD            mov	al,-3[bp]
19578 54A1           A2         0017            mov	[$17],al
19579                                           !BCC_EOS
19580                                           ! 3551       break;
19581 54A4           E9         04AA            br 	.4A9
19582                                           !BCC_EOS
19583                                           ! 3552     case 0xb6:
19584                                           ! 3553       shift_flags &= ~0x01;
19585                       000054A7            .4B1:
19586                                           ! Debug: andab int = const -2 to unsigned char shift_flags = [S+8-5] (used reg = )
19587 54A7           8A46         FD            mov	al,-3[bp]
19588 54AA           24                     FE  and	al,#$FE
19589 54AC           8846         FD            mov	-3[bp],al
19590                                           !BCC_EOS
19591                                           ! 3554     
19592                                           ! 3554   *((Bit8u *)(0x17)) = (shift_flags);
19593                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19594 54AF           8A46         FD            mov	al,-3[bp]
19595 54B2           A2         0017            mov	[$17],al
19596                                           !BCC_EOS
19597                                           ! 3555       break;
19598 54B5           E9         0499            br 	.4A9
19599                                           !BCC_EOS
19600                                           ! 3556     case 0x1d:
19601                                           ! 3557       if ((mf2_state & 0x01) == 0) {
19602                       000054B8            .4B2:
19603                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
19604 54B8           8A46         FB            mov	al,-5[bp]
19605 54BB           24                     01  and	al,*1
19606                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19607 54BD           84C0                       test	al,al
19608 54BF           75           35            jne 	.4B3
19609                       000054C1            .4B4:
19610                                           ! 3558         shift_flags |= 0x04;
19611                                           ! Debug: orab int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
19612 54C1           8A46         FD            mov	al,-3[bp]
19613 54C4           0C                     04  or	al,*4
19614 54C6           8846         FD            mov	-3[bp],al
19615                                           !BCC_EOS
19616                                           ! 3559         *((Bit8u *)(0x17)) = (shift_flags);
19617                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19618 54C9           8A46         FD            mov	al,-3[bp]
19619 54CC           A2         0017            mov	[$17],al
19620                                           !BCC_EOS
19621                                           ! 3560         if (mf2_state & 0x02) {
19622                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19623 54CF           8A46         FB            mov	al,-5[bp]
19624 54D2           24                     02  and	al,*2
19625 54D4           84C0                       test	al,al
19626 54D6           74           10            je  	.4B5
19627                       000054D8            .4B6:
19628                                           ! 3561           mf2_state |= 0x04;
19629                                           ! Debug: orab int = const 4 to unsigned char mf2_state = [S+8-7] (used reg = )
19630 54D8           8A46         FB            mov	al,-5[bp]
19631 54DB           0C                     04  or	al,*4
19632 54DD           8846         FB            mov	-5[bp],al
19633                                           !BCC_EOS
19634                                           ! 3562           *((Bit8u *)(0x96)) = (mf2_state);
19635                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
19636 54E0           8A46         FB            mov	al,-5[bp]
19637 54E3           A2         0096            mov	[$96],al
19638                                           !BCC_EOS
19639                                           ! 3563         } else {
19640 54E6           EB           0E            jmp .4B7
19641                       000054E8            .4B5:
19642                                           ! 3564           mf2_flags |= 0x01;
19643                                           ! Debug: orab int = const 1 to unsigned char mf2_flags = [S+8-6] (used reg = )
19644 54E8           8A46         FC            mov	al,-4[bp]
19645 54EB           0C                     01  or	al,*1
19646 54ED           8846         FC            mov	-4[bp],al
19647                                           !BCC_EOS
19648                                           ! 3565           *((Bit8u *)(0x18)) = (mf2_flags);
19649                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19650 54F0           8A46         FC            mov	al,-4[bp]
19651 54F3           A2         0018            mov	[$18],al
19652                                           !BCC_EOS
19653                                           ! 3566         }
19654                                           ! 3567       }
19655                       000054F6            .4B7:
19656                                           ! 3568       break;
19657                       000054F6            .4B3:
19658 54F6           E9         0458            br 	.4A9
19659                                           !BCC_EOS
19660                                           ! 3569     case 0x9d:
19661                                           ! 3570       if ((mf2_state & 0x01) == 0) {
19662                       000054F9            .4B8:
19663                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
19664 54F9           8A46         FB            mov	al,-5[bp]
19665 54FC           24                     01  and	al,*1
19666                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19667 54FE           84C0                       test	al,al
19668 5500           75           35            jne 	.4B9
19669                       00005502            .4BA:
19670                                           ! 3571         shift_flags &= ~0x04;
19671                                           ! Debug: andab int = const -5 to unsigned char shift_flags = [S+8-5] (used reg = )
19672 5502           8A46         FD            mov	al,-3[bp]
19673 5505           24                     FB  and	al,#$FB
19674 5507           8846         FD            mov	-3[bp],al
19675                                           !BCC_EOS
19676                                           ! 3572         *((Bit8u *)(0x17)) = (shift_flags);
19677                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19678 550A           8A46         FD            mov	al,-3[bp]
19679 550D           A2         0017            mov	[$17],al
19680                                           !BCC_EOS
19681                                           ! 3573         if (mf2_state & 0x02) {
19682                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19683 5510           8A46         FB            mov	al,-5[bp]
19684 5513           24                     02  and	al,*2
19685 5515           84C0                       test	al,al
19686 5517           74           10            je  	.4BB
19687                       00005519            .4BC:
19688                                           ! 3574           mf2_state &= ~0x04;
19689                                           ! Debug: andab int = const -5 to unsigned char mf2_state = [S+8-7] (used reg = )
19690 5519           8A46         FB            mov	al,-5[bp]
19691 551C           24                     FB  and	al,#$FB
19692 551E           8846         FB            mov	-5[bp],al
19693                                           !BCC_EOS
19694                                           ! 3575           *((Bit8u *)(0x96)) = (mf2_state);
19695                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
19696 5521           8A46         FB            mov	al,-5[bp]
19697 5524           A2         0096            mov	[$96],al
19698                                           !BCC_EOS
19699                                           ! 3576         } else {
19700 5527           EB           0E            jmp .4BD
19701                       00005529            .4BB:
19702                                           ! 3577           mf2_flags &= ~0x01;
19703                                           ! Debug: andab int = const -2 to unsigned char mf2_flags = [S+8-6] (used reg = )
19704 5529           8A46         FC            mov	al,-4[bp]
19705 552C           24                     FE  and	al,#$FE
19706 552E           8846         FC            mov	-4[bp],al
19707                                           !BCC_EOS
19708                                           ! 3578           *((Bit8u *)(0x18)) = (mf2_flags);
19709                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19710 5531           8A46         FC            mov	al,-4[bp]
19711 5534           A2         0018            mov	[$18],al
19712                                           !BCC_EOS
19713                                           ! 3579         }
19714                                           ! 3580       }
19715                       00005537            .4BD:
19716                                           ! 3581       break;
19717                       00005537            .4B9:
19718 5537           E9         0417            br 	.4A9
19719                                           !BCC_EOS
19720                                           ! 3582     case 0x38:
19721                                           ! 3583       shift_flags |= 0x08;
19722                       0000553A            .4BE:
19723                                           ! Debug: orab int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
19724 553A           8A46         FD            mov	al,-3[bp]
19725 553D           0C                     08  or	al,*8
19726 553F           8846         FD            mov	-3[bp],al
19727                                           !BCC_EOS
19728                                           ! 3584       *((Bit8u *)(0x17)) = (shift_flags);
19729                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19730 5542           8A46         FD            mov	al,-3[bp]
19731 5545           A2         0017            mov	[$17],al
19732                                           !BCC_EOS
19733                                           ! 3585       if (mf2_state & 0x02) {
19734                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19735 5548           8A46         FB            mov	al,-5[bp]
19736 554B           24                     02  and	al,*2
19737 554D           84C0                       test	al,al
19738 554F           74           10            je  	.4BF
19739                       00005551            .4C0:
19740                                           ! 3586         mf2_state |= 0x08;
19741                                           ! Debug: orab int = const 8 to unsigned char mf2_state = [S+8-7] (used reg = )
19742 5551           8A46         FB            mov	al,-5[bp]
19743 5554           0C                     08  or	al,*8
19744 5556           8846         FB            mov	-5[bp],al
19745                                           !BCC_EOS
19746                                           ! 3587         *((Bit8u *)(0x96)) = (mf2_state);
19747                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
19748 5559           8A46         FB            mov	al,-5[bp]
19749 555C           A2         0096            mov	[$96],al
19750                                           !BCC_EOS
19751                                           ! 3588       } else {
19752 555F           EB           0E            jmp .4C1
19753                       00005561            .4BF:
19754                                           ! 3589         mf2_flags |= 0x02;
19755                                           ! Debug: orab int = const 2 to unsigned char mf2_flags = [S+8-6] (used reg = )
19756 5561           8A46         FC            mov	al,-4[bp]
19757 5564           0C                     02  or	al,*2
19758 5566           8846         FC            mov	-4[bp],al
19759                                           !BCC_EOS
19760                                           ! 3590         *((Bit8u *)(0x18)) = (mf2_flags);
19761                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19762 5569           8A46         FC            mov	al,-4[bp]
19763 556C           A2         0018            mov	[$18],al
19764                                           !BCC_EOS
19765                                           ! 3591       }
19766                                           ! 3592       break;
19767                       0000556F            .4C1:
19768 556F           E9         03DF            br 	.4A9
19769                                           !BCC_EOS
19770                                           ! 3593     case 0xb8:
19771                                           ! 3594       shift_flags &= ~0x08;
19772                       00005572            .4C2:
19773                                           ! Debug: andab int = const -9 to unsigned char shift_flags = [S+8-5] (used reg = )
19774 5572           8A46         FD            mov	al,-3[bp]
19775 5575           24                     F7  and	al,#$F7
19776 5577           8846         FD            mov	-3[bp],al
19777                                           !BCC_EOS
19778                                           ! 3595       *((Bit8u *)(0x17)) = (shift_flags);
19779                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19780 557A           8A46         FD            mov	al,-3[bp]
19781 557D           A2         0017            mov	[$17],al
19782                                           !BCC_EOS
19783                                           ! 3596       if (mf2_state & 0x02) {
19784                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19785 5580           8A46         FB            mov	al,-5[bp]
19786 5583           24                     02  and	al,*2
19787 5585           84C0                       test	al,al
19788 5587           74           10            je  	.4C3
19789                       00005589            .4C4:
19790                                           ! 3597         mf2_state &= ~0x08;
19791                                           ! Debug: andab int = const -9 to unsigned char mf2_state = [S+8-7] (used reg = )
19792 5589           8A46         FB            mov	al,-5[bp]
19793 558C           24                     F7  and	al,#$F7
19794 558E           8846         FB            mov	-5[bp],al
19795                                           !BCC_EOS
19796                                           ! 3598         *((Bit8u *)(0x96)) = (mf2_state);
19797                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
19798 5591           8A46         FB            mov	al,-5[bp]
19799 5594           A2         0096            mov	[$96],al
19800                                           !BCC_EOS
19801                                           ! 3599       } else {
19802 5597           EB           0E            jmp .4C5
19803                       00005599            .4C3:
19804                                           ! 3600         mf2_flags &= ~0x02;
19805                                           ! Debug: andab int = const -3 to unsigned char mf2_flags = [S+8-6] (used reg = )
19806 5599           8A46         FC            mov	al,-4[bp]
19807 559C           24                     FD  and	al,#$FD
19808 559E           8846         FC            mov	-4[bp],al
19809                                           !BCC_EOS
19810                                           ! 3601         *((Bit8u *)(0x18)) = (mf2_flags);
19811                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19812 55A1           8A46         FC            mov	al,-4[bp]
19813 55A4           A2         0018            mov	[$18],al
19814                                           !BCC_EOS
19815                                           ! 3602       }
19816                                           ! 3603       break;
19817                       000055A7            .4C5:
19818 55A7           E9         03A7            br 	.4A9
19819                                           !BCC_EOS
19820                                           ! 3604     case 0x45:
19821                                           ! 3605       if ((mf2_state & 0x03) == 0) {
19822                       000055AA            .4C6:
19823                                           ! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
19824 55AA           8A46         FB            mov	al,-5[bp]
19825 55AD           24                     03  and	al,*3
19826                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19827 55AF           84C0                       test	al,al
19828 55B1           75           1C            jne 	.4C7
19829                       000055B3            .4C8:
19830                                           ! 3606         mf2_flags |= 0x20;
19831                                           ! Debug: orab int = const $20 to unsigned char mf2_flags = [S+8-6] (used reg = )
19832 55B3           8A46         FC            mov	al,-4[bp]
19833 55B6           0C                     20  or	al,*$20
19834 55B8           8846         FC            mov	-4[bp],al
19835                                           !BCC_EOS
19836                                           ! 3607         *((Bit8u *)(0x18)) = (mf2_flags);
19837                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19838 55BB           8A46         FC            mov	al,-4[bp]
19839 55BE           A2         0018            mov	[$18],al
19840                                           !BCC_EOS
19841                                           ! 3608         shift_flags ^= 0x20;
19842                                           ! Debug: eorab int = const $20 to unsigned char shift_flags = [S+8-5] (used reg = )
19843 55C1           8A46         FD            mov	al,-3[bp]
19844 55C4           34                     20  xor	al,*$20
19845 55C6           8846         FD            mov	-3[bp],al
19846                                           !BCC_EOS
19847                                           ! 3609         *((Bit8u *)(0x17)) = (shift_flags);
19848                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19849 55C9           8A46         FD            mov	al,-3[bp]
19850 55CC           A2         0017            mov	[$17],al
19851                                           !BCC_EOS
19852                                           ! 3610       }
19853                                           ! 3611       break;
19854                       000055CF            .4C7:
19855 55CF           E9         037F            br 	.4A9
19856                                           !BCC_EOS
19857                                           ! 3612     case 0xc5:
19858                                           ! 3613       if ((mf2_state & 0x03) == 0) {
19859                       000055D2            .4C9:
19860                                           ! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
19861 55D2           8A46         FB            mov	al,-5[bp]
19862 55D5           24                     03  and	al,*3
19863                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19864 55D7           84C0                       test	al,al
19865 55D9           75           0E            jne 	.4CA
19866                       000055DB            .4CB:
19867                                           ! 3614         mf2_flags &= ~0x20;
19868                                           ! Debug: andab int = const -$21 to unsigned char mf2_flags = [S+8-6] (used reg = )
19869 55DB           8A46         FC            mov	al,-4[bp]
19870 55DE           24                     DF  and	al,#$DF
19871 55E0           8846         FC            mov	-4[bp],al
19872                                           !BCC_EOS
19873                                           ! 3615         *((Bit8u *)(0x18)) = (mf2_flags);
19874                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19875 55E3           8A46         FC            mov	al,-4[bp]
19876 55E6           A2         0018            mov	[$18],al
19877                                           !BCC_EOS
19878                                           ! 3616       }
19879                                           ! 3617       break;
19880                       000055E9            .4CA:
19881 55E9           E9         0365            br 	.4A9
19882                                           !BCC_EOS
19883                                           ! 3618     case 0x46:
19884                                           ! 3619       if ((mf2_state & 0x02) || (!(mf2_state & 0x10) && (shift_flags & 0x04))) {
19885                       000055EC            .4CC:
19886                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
19887 55EC           8A46         FB            mov	al,-5[bp]
19888 55EF           24                     02  and	al,*2
19889 55F1           84C0                       test	al,al
19890 55F3           75           12            jne 	.4CE
19891                       000055F5            .4CF:
19892                                           ! Debug: and int = const $10 to unsigned char mf2_state = [S+8-7] (used reg = )
19893 55F5           8A46         FB            mov	al,-5[bp]
19894 55F8           24                     10  and	al,*$10
19895 55FA           84C0                       test	al,al
19896 55FC           75           32            jne 	.4CD
19897                       000055FE            .4D0:
19898                                           ! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
19899 55FE           8A46         FD            mov	al,-3[bp]
19900 5601           24                     04  and	al,*4
19901 5603           84C0                       test	al,al
19902 5605           74           29            je  	.4CD
19903                       00005607            .4CE:
19904                                           ! 3620         mf2_state &= ~0x02;
19905                                           ! Debug: andab int = const -3 to unsigned char mf2_state = [S+8-7] (used reg = )
19906 5607           8A46         FB            mov	al,-5[bp]
19907 560A           24                     FD  and	al,#$FD
19908 560C           8846         FB            mov	-5[bp],al
19909                                           !BCC_EOS
19910                                           ! 3621         *((Bit8u *)(0x96)) = (mf2_state);
19911                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
19912 560F           8A46         FB            mov	al,-5[bp]
19913 5612           A2         0096            mov	[$96],al
19914                                           !BCC_EOS
19915                                           ! 3622         *((Bit8u *)(0x71)) = (0x80);
19916                                           ! Debug: eq int = const $80 to unsigned char = [+$71] (used reg = )
19917 5615           B0                     80  mov	al,#$80
19918 5617           A2         0071            mov	[$71],al
19919                                           !BCC_EOS
19920                                           ! 3623         *((Bit16u *)(0x001C)) = (*((Bit16u *)(0x001A)));
19921                                           ! Debug: eq unsigned short = [+$1A] to unsigned short = [+$1C] (used reg = )
19922 561A           A1         001A            mov	ax,[$1A]
19923 561D           A3         001C            mov	[$1C],ax
19924                                           !BCC_EOS
19925                                           ! 3624 #asm
19926                                           !BCC_EOS
19927                                           !BCC_ASM
19928                       0000000E            _int09_function.BP	set	$E
19929                       00000008            .int09_function.BP	set	8
19930                       00000016            _int09_function.CX	set	$16
19931                       00000010            .int09_function.CX	set	$10
19932                       0000000A            _int09_function.DI	set	$A
19933                       00000004            .int09_function.DI	set	4
19934                       00000014            _int09_function.DX	set	$14
19935                       0000000E            .int09_function.DX	set	$E
19936                       00000002            _int09_function.mf2_flags	set	2
19937                       FFFFFFFC            .int09_function.mf2_flags	set	-4
19938                       0000000C            _int09_function.SI	set	$C
19939                       00000006            .int09_function.SI	set	6
19940                       00000001            _int09_function.mf2_state	set	1
19941                       FFFFFFFB            .int09_function.mf2_state	set	-5
19942                       00000018            _int09_function.AX	set	$18
19943                       00000012            .int09_function.AX	set	$12
19944                       00000004            _int09_function.asciicode	set	4
19945                       FFFFFFFE            .int09_function.asciicode	set	-2
19946                       00000005            _int09_function.scancode	set	5
19947                       FFFFFFFF            .int09_function.scancode	set	-1
19948                       00000010            _int09_function.SP	set	$10
19949                       0000000A            .int09_function.SP	set	$A
19950                       00000012            _int09_function.BX	set	$12
19951                       0000000C            .int09_function.BX	set	$C
19952                       00000003            _int09_function.shift_flags	set	3
19953                       FFFFFFFD            .int09_function.shift_flags	set	-3
19954 5620           CD                     1B          int #0x1B
19955                                           ! 3626 endasm
19956                                           !BCC_ENDASM
19957                                           !BCC_EOS
19958                                           ! 3627         enqueue_key(0, 0);
19959                                           ! Debug: list int = const 0 (used reg = )
19960 5622           31C0                       xor	ax,ax
19961 5624           50                         push	ax
19962                                           ! Debug: list int = const 0 (used reg = )
19963 5625           31C0                       xor	ax,ax
19964 5627           50                         push	ax
19965                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
19966 5628           E8         0349            call	_enqueue_key
19967 562B           83C4                   04  add	sp,*4
19968                                           !BCC_EOS
19969                                           ! 3628       } else {
19970 562E           EB           1C            jmp .4D1
19971                       00005630            .4CD:
19972                                           ! 3629         mf2_flags |= 0
19973                                           ! 3629 x10;
19974                                           ! Debug: orab int = const $10 to unsigned char mf2_flags = [S+8-6] (used reg = )
19975 5630           8A46         FC            mov	al,-4[bp]
19976 5633           0C                     10  or	al,*$10
19977 5635           8846         FC            mov	-4[bp],al
19978                                           !BCC_EOS
19979                                           ! 3630         *((Bit8u *)(0x18)) = (mf2_flags);
19980                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
19981 5638           8A46         FC            mov	al,-4[bp]
19982 563B           A2         0018            mov	[$18],al
19983                                           !BCC_EOS
19984                                           ! 3631         shift_flags ^= 0x10;
19985                                           ! Debug: eorab int = const $10 to unsigned char shift_flags = [S+8-5] (used reg = )
19986 563E           8A46         FD            mov	al,-3[bp]
19987 5641           34                     10  xor	al,*$10
19988 5643           8846         FD            mov	-3[bp],al
19989                                           !BCC_EOS
19990                                           ! 3632         *((Bit8u *)(0x17)) = (shift_flags);
19991                                           ! Debug: eq unsigned char shift_flags = [S+8-5] to unsigned char = [+$17] (used reg = )
19992 5646           8A46         FD            mov	al,-3[bp]
19993 5649           A2         0017            mov	[$17],al
19994                                           !BCC_EOS
19995                                           ! 3633       }
19996                                           ! 3634       break;
19997                       0000564C            .4D1:
19998 564C           E9         0302            br 	.4A9
19999                                           !BCC_EOS
20000                                           ! 3635     case 0xc6:
20001                                           ! 3636       if ((mf2_state & 0x02) || (!(mf2_state & 0x10) && (shift_flags & 0x04))) {
20002                       0000564F            .4D2:
20003                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
20004 564F           8A46         FB            mov	al,-5[bp]
20005 5652           24                     02  and	al,*2
20006 5654           84C0                       test	al,al
20007 5656           75           12            jne 	.4D4
20008                       00005658            .4D5:
20009                                           ! Debug: and int = const $10 to unsigned char mf2_state = [S+8-7] (used reg = )
20010 5658           8A46         FB            mov	al,-5[bp]
20011 565B           24                     10  and	al,*$10
20012 565D           84C0                       test	al,al
20013 565F           75           0B            jne 	.4D3
20014                       00005661            .4D6:
20015                                           ! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
20016 5661           8A46         FD            mov	al,-3[bp]
20017 5664           24                     04  and	al,*4
20018 5666           84C0                       test	al,al
20019 5668           74           02            je  	.4D3
20020                       0000566A            .4D4:
20021                                           ! 3637       } else {
20022 566A           EB           0E            jmp .4D7
20023                       0000566C            .4D3:
20024                                           ! 3638         mf2_flags &= ~0x10;
20025                                           ! Debug: andab int = const -$11 to unsigned char mf2_flags = [S+8-6] (used reg = )
20026 566C           8A46         FC            mov	al,-4[bp]
20027 566F           24                     EF  and	al,#$EF
20028 5671           8846         FC            mov	-4[bp],al
20029                                           !BCC_EOS
20030                                           ! 3639         *((Bit8u *)(0x18)) = (mf2_flags);
20031                                           ! Debug: eq unsigned char mf2_flags = [S+8-6] to unsigned char = [+$18] (used reg = )
20032 5674           8A46         FC            mov	al,-4[bp]
20033 5677           A2         0018            mov	[$18],al
20034                                           !BCC_EOS
20035                                           ! 3640       }
20036                                           ! 3641       break;
20037                       0000567A            .4D7:
20038 567A           E9         02D4            br 	.4A9
20039                                           !BCC_EOS
20040                                           ! 3642     default:
20041                                           ! 3643       if (scancode & 0x80) {
20042                       0000567D            .4D8:
20043                                           ! Debug: and int = const $80 to unsigned char scancode = [S+8-3] (used reg = )
20044 567D           8A46         FF            mov	al,-1[bp]
20045 5680           24                     80  and	al,#$80
20046 5682           84C0                       test	al,al
20047 5684           74           03            je  	.4D9
20048                       00005686            .4DA:
20049                                           ! 3644         break;
20050 5686           E9         02C8            br 	.4A9
20051                                           !BCC_EOS
20052                                           ! 3645       }
20053                                           ! 3646       if (scancode > 0x58) {
20054                       00005689            .4D9:
20055                                           ! Debug: gt int = const $58 to unsigned char scancode = [S+8-3] (used reg = )
20056 5689           8A46         FF            mov	al,-1[bp]
20057 568C           3C                     58  cmp	al,*$58
20058 568E           76           18            jbe 	.4DB
20059                       00005690            .4DC:
20060                                           ! 3647         bios_printf(4, "KBD: int09h_handler(): unknown scancode read: 0x%02x!\n", scancode);
20061                                           ! Debug: list unsigned char scancode = [S+8-3] (used reg = )
20062 5690           8A46         FF            mov	al,-1[bp]
20063 5693           30E4                       xor	ah,ah
20064 5695           50                         push	ax
20065                                           ! Debug: list * char = .4DD+0 (used reg = )
20066 5696           BB                   D2B9  mov	bx,#.4DD
20067 5699           53                         push	bx
20068                                           ! Debug: list int = const 4 (used reg = )
20069 569A           B8                   0004  mov	ax,*4
20070 569D           50                         push	ax
20071                                           ! Debug: func () void = bios_printf+0 (used reg = )
20072 569E           E8         B29D            call	_bios_printf
20073 56A1           83C4                   06  add	sp,*6
20074                                           !BCC_EOS
20075                                           ! 3648         return;
20076 56A4           89EC                       mov	sp,bp
20077 56A6           5D                         pop	bp
20078 56A7           C3                         ret
20079                                           !BCC_EOS
20080                                           ! 3649       }
20081                                           ! 3650       if (scancode == 0x53) {
20082                       000056A8            .4DB:
20083                                           ! Debug: logeq int = const $53 to unsigned char scancode = [S+8-3] (used reg = )
20084 56A8           8A46         FF            mov	al,-1[bp]
20085 56AB           3C                     53  cmp	al,*$53
20086 56AD           75           14            jne 	.4DE
20087                       000056AF            .4DF:
20088                                           ! 3651         if ((shift_flags & 0x0f) == 0x0c) {
20089                                           ! Debug: and int = const $F to unsigned char shift_flags = [S+8-5] (used reg = )
20090 56AF           8A46         FD            mov	al,-3[bp]
20091 56B2           24                     0F  and	al,*$F
20092                                           ! Debug: logeq int = const $C to unsigned char = al+0 (used reg = )
20093 56B4           3C                     0C  cmp	al,*$C
20094 56B6           75           0B            jne 	.4E0
20095                       000056B8            .4E1:
20096                                           ! 3652           *((Bit16u *)(0x0072)) = (0x1234);
20097                                           ! Debug: eq int = const $1234 to unsigned short = [+$72] (used reg = )
20098 56B8           B8                   1234  mov	ax,#$1234
20099 56BB           A3         0072            mov	[$72],ax
20100                                           !BCC_EOS
20101                                           ! 3653 #asm
20102                                           !BCC_EOS
20103                                           !BCC_ASM
20104                       0000000E            _int09_function.BP	set	$E
20105                       00000008            .int09_function.BP	set	8
20106                       00000016            _int09_function.CX	set	$16
20107                       00000010            .int09_function.CX	set	$10
20108                       0000000A            _int09_function.DI	set	$A
20109                       00000004            .int09_function.DI	set	4
20110                       00000014            _int09_function.DX	set	$14
20111                       0000000E            .int09_function.DX	set	$E
20112                       00000002            _int09_function.mf2_flags	set	2
20113                       FFFFFFFC            .int09_function.mf2_flags	set	-4
20114                       0000000C            _int09_function.SI	set	$C
20115                       00000006            .int09_function.SI	set	6
20116                       00000001            _int09_function.mf2_state	set	1
20117                       FFFFFFFB            .int09_function.mf2_state	set	-5
20118                       00000018            _int09_function.AX	set	$18
20119                       00000012            .int09_function.AX	set	$12
20120                       00000004            _int09_function.asciicode	set	4
20121                       FFFFFFFE            .int09_function.asciicode	set	-2
20122                       00000005            _int09_function.scancode	set	5
20123                       FFFFFFFF            .int09_function.scancode	set	-1
20124                       00000010            _int09_function.SP	set	$10
20125                       0000000A            .int09_function.SP	set	$A
20126                       00000012            _int09_function.BX	set	$12
20127                       0000000C            .int09_function.BX	set	$C
20128                       00000003            _int09_function.shift_flags	set	3
20129                       FFFFFFFD            .int09_function.shift_flags	set	-3
20130 56BE           EA         E05B      F000            jmp 0xf000:post;
20131                                           ! 3655 endasm
20132                                           !BCC_ENDASM
20133                                           !BCC_EOS
20134                                           ! 3656         }
20135                                           ! 3657       }
20136                       000056C3            .4E0:
20137                                           ! 3658       set_DS(get_CS());
20138                       000056C3            .4DE:
20139                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
20140 56C3           E8         AF96            call	_get_CS
20141                                           ! Debug: list unsigned short = ax+0 (used reg = )
20142 56C6           50                         push	ax
20143                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
20144 56C7           E8         AF98            call	_set_DS
20145 56CA           44                         inc	sp
20146 56CB           44                         inc	sp
20147                                           !BCC_EOS
20148                                           ! 3659       if (shift_flags & 0x08) {
20149                                           ! Debug: and int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
20150 56CC           8A46         FD            mov	al,-3[bp]
20151 56CF           24                     08  and	al,*8
20152 56D1           84C0                       test	al,al
20153 56D3           74           3D            je  	.4E2
20154                       000056D5            .4E3:
20155                                           ! 3660         asciicode = scan_to_scanascii[scancode].alt;
20156                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20157 56D5           8A46         FF            mov	al,-1[bp]
20158 56D8           30E4                       xor	ah,ah
20159 56DA           89C2                       mov	dx,ax
20160 56DC           D1E0                       shl	ax,*1
20161 56DE           D1E0                       shl	ax,*1
20162 56E0           01D0                       add	ax,dx
20163 56E2           D1E0                       shl	ax,*1
20164 56E4           89C3                       mov	bx,ax
20165 56E6           81C3                 017E  add	bx,#_scan_to_scanascii
20166                                           ! Debug: eq unsigned short = [bx+6] to unsigned char asciicode = [S+8-4] (used reg = )
20167 56EA           8A47         06            mov	al,6[bx]
20168 56ED           8846         FE            mov	-2[bp],al
20169                                           !BCC_EOS
20170                                           ! 3661         scancode = scan_to_scanascii[scancode].alt >> 8;
20171                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20172 56F0           8A46         FF            mov	al,-1[bp]
20173 56F3           30E4                       xor	ah,ah
20174 56F5           89C2                       mov	dx,ax
20175 56F7           D1E0                       shl	ax,*1
20176 56F9           D1E0                       shl	ax,*1
20177 56FB           01D0                       add	ax,dx
20178 56FD           D1E0                       shl	ax,*1
20179 56FF           89C3                       mov	bx,ax
20180 5701           81C3                 017E  add	bx,#_scan_to_scanascii
20181                                           ! Debug: sr int = const 8 to unsigned short = [bx+6] (used reg = )
20182 5705           8B47         06            mov	ax,6[bx]
20183 5708           88E0                       mov	al,ah
20184 570A           30E4                       xor	ah,ah
20185                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20186 570C           8846         FF            mov	-1[bp],al
20187                                           !BCC_EOS
20188                                           ! 3662       } else if (shift_flags & 0x04) {
20189 570F           E9         01AD            br 	.4E4
20190                       00005712            .4E2:
20191                                           ! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
20192 5712           8A46         FD            mov	al,-3[bp]
20193 5715           24                     04  and	al,*4
20194 5717           84C0                       test	al,al
20195 5719           74           3D            je  	.4E5
20196                       0000571B            .4E6:
20197                                           ! 3663         asciicode = scan_to_scanascii[scancode].control;
20198                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20199 571B           8A46         FF            mov	al,-1[bp]
20200 571E           30E4                       xor	ah,ah
20201 5720           89C2                       mov	dx,ax
20202 5722           D1E0                       shl	ax,*1
20203 5724           D1E0                       shl	ax,*1
20204 5726           01D0                       add	ax,dx
20205 5728           D1E0                       shl	ax,*1
20206 572A           89C3                       mov	bx,ax
20207 572C           81C3                 017E  add	bx,#_scan_to_scanascii
20208                                           ! Debug: eq unsigned short = [bx+4] to unsigned char asciicode = [S+8-4] (used reg = )
20209 5730           8A47         04            mov	al,4[bx]
20210 5733           8846         FE            mov	-2[bp],al
20211                                           !BCC_EOS
20212                                           ! 3664         scancode = scan_to_scanascii[scancode].control >> 8;
20213                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20214 5736           8A46         FF            mov	al,-1[bp]
20215 5739           30E4                       xor	ah,ah
20216 573B           89C2                       mov	dx,ax
20217 573D           D1E0                       shl	ax,*1
20218 573F           D1E0                       shl	ax,*1
20219 5741           01D0                       add	ax,dx
20220 5743           D1E0                       shl	ax,*1
20221 5745           89C3                       mov	bx,ax
20222 5747           81C3                 017E  add	bx,#_scan_to_scanascii
20223                                           ! Debug: sr int = const 8 to unsigned short = [bx+4] (used reg = )
20224 574B           8B47         04            mov	ax,4[bx]
20225 574E           88E0                       mov	al,ah
20226 5750           30E4                       xor	ah,ah
20227                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20228 5752           8846         FF            mov	-1[bp],al
20229                                           !BCC_EOS
20230                                           ! 3665       } else if (((mf2_state & 0x02) > 0) && ((scancode >= 0x47) && (scancode <= 0x53))) {
20231 5755           E9         0167            br 	.4E7
20232                       00005758            .4E5:
20233                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
20234 5758           8A46         FB            mov	al,-5[bp]
20235 575B           24                     02  and	al,*2
20236                                           ! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
20237 575D           84C0                       test	al,al
20238 575F           74           32            je  	.4E8
20239                       00005761            .4EA:
20240                                           ! Debug: ge int = const $47 to unsigned char scancode = [S+8-3] (used reg = )
20241 5761           8A46         FF            mov	al,-1[bp]
20242 5764           3C                     47  cmp	al,*$47
20243 5766           72           2B            jb  	.4E8
20244                       00005768            .4EB:
20245                                           ! Debug: le int = const $53 to unsigned char scancode = [S+8-3] (used reg = )
20246 5768           8A46         FF            mov	al,-1[bp]
20247 576B           3C                     53  cmp	al,*$53
20248 576D           77           24            ja  	.4E8
20249                       0000576F            .4E9:
20250                                           ! 3666         asciicode = 0xe0;
20251                                           ! Debug: eq int = const $E0 to unsigned char asciicode = [S+8-4] (used reg = )
20252 576F           B0                     E0  mov	al,#$E0
20253 5771           8846         FE            mov	-2[bp],al
20254                                           !BCC_EOS
20255                                           ! 3667         scancode = scan_to_scanascii[scancode].normal >> 8;
20256                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20257 5774           8A46         FF            mov	al,-1[bp]
20258 5777           30E4                       xor	ah,ah
20259 5779           89C2                       mov	dx,ax
20260 577B           D1E0                       shl	ax,*1
20261 577D           D1E0                       shl	ax,*1
20262 577F           01D0                       add	ax,dx
20263 5781           D1E0                       shl	ax,*1
20264 5783           89C3                       mov	bx,ax
20265                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
20266 5785           8B87       017E            mov	ax,_scan_to_scanascii[bx]
20267 5789           88E0                       mov	al,ah
20268 578B           30E4                       xor	ah,ah
20269                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20270 578D           8846         FF            mov	-1[bp],al
20271                                           !BCC_EOS
20272                                           ! 3668       } else if (shift_flags & 0x03) {
20273 5790           E9         012C            br 	.4EC
20274                       00005793            .4E8:
20275                                           ! Debug: and int = const 3 to unsigned char shift_flags = [S+8-5] (used reg = )
20276 5793           8A46         FD            mov	al,-3[bp]
20277 5796           24                     03  and	al,*3
20278 5798           84C0                       test	al,al
20279 579A         0F84         0092            beq 	.4ED
20280                       0000579E            .4EE:
20281                                           ! 3669         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
20282                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20283 579E           8A46         FF            mov	al,-1[bp]
20284 57A1           30E4                       xor	ah,ah
20285 57A3           89C2                       mov	dx,ax
20286 57A5           D1E0                       shl	ax,*1
20287 57A7           D1E0                       shl	ax,*1
20288 57A9           01D0                       add	ax,dx
20289 57AB           D1E0                       shl	ax,*1
20290 57AD           89C3                       mov	bx,ax
20291 57AF           81C3                 017E  add	bx,#_scan_to_scanascii
20292                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
20293 57B3           8A46         FD            mov	al,-3[bp]
20294 57B6           2247         08            and	al,8[bx]
20295 57B9           84C0                       test	al,al
20296 57BB           74           36            je  	.4EF
20297                       000057BD            .4F0:
20298                                           ! 3670           asciicode = scan_to_scanascii[scancode].normal;
20299                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20300 57BD           8A46         FF            mov	al,-1[bp]
20301 57C0           30E4                       xor	ah,ah
20302 57C2           89C2                       mov	dx,ax
20303 57C4           D1E0                       shl	ax,*1
20304 57C6           D1E0                       shl	ax,*1
20305 57C8           01D0                       add	ax,dx
20306 57CA           D1E0                       shl	ax,*1
20307 57CC           89C3                       mov	bx,ax
20308                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
20309 57CE           8A87       017E            mov	al,_scan_to_scanascii[bx]
20310 57D2           8846         FE            mov	-2[bp],al
20311                                           !BCC_EOS
20312                                           ! 3671           scancode = scan_to_scanascii[scancode].normal >> 8;
20313                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20314 57D5           8A46         FF            mov	al,-1[bp]
20315 57D8           30E4                       xor	ah,ah
20316 57DA           89C2                       mov	dx,ax
20317 57DC           D1E0                       shl	ax,*1
20318 57DE           D1E0                       shl	ax,*1
20319 57E0           01D0                       add	ax,dx
20320 57E2           D1E0                       shl	ax,*1
20321 57E4           89C3                       mov	bx,ax
20322                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
20323 57E6           8B87       017E            mov	ax,_scan_to_scanascii[bx]
20324 57EA           88E0                       mov	al,ah
20325 57EC           30E4                       xor	ah,ah
20326                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20327 57EE           8846         FF            mov	-1[bp],al
20328                                           !BCC_EOS
20329                                           ! 3672         } else {
20330 57F1           EB           3A            jmp .4F1
20331                       000057F3            .4EF:
20332                                           ! 3673           asciicode = scan_to_scanascii[scancode].shift;
20333                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20334 57F3           8A46         FF            mov	al,-1[bp]
20335 57F6           30E4                       xor	ah,ah
20336 57F8           89C2                       mov	dx,ax
20337 57FA           D1E0                       shl	ax,*1
20338 57FC           D1E0                       shl	ax,*1
20339 57FE           01D0                       add	ax,dx
20340 5800           D1E0                       shl	ax,*1
20341 5802           89C3                       mov	bx,ax
20342 5804           81C3                 017E  add	bx,#_scan_to_scanascii
20343                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
20344 5808           8A47         02            mov	al,2[bx]
20345 580B           8846         FE            mov	-2[bp],al
20346                                           !BCC_EOS
20347                                           ! 3674           scancode = scan_to_scanascii[scancode].shift >> 8;
20348                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20349 580E           8A46         FF            mov	al,-1[bp]
20350 5811           30E4                       xor	ah,ah
20351 5813           89C2                       mov	dx,ax
20352 5815           D1E0                       shl	ax,*1
20353 5817           D1E0                       shl	ax,*1
20354 5819           01D0                       add	ax,dx
20355 581B           D1E0                       shl	ax,*1
20356 581D           89C3                       mov	bx,ax
20357 581F           81C3                 017E  add	bx,#_scan_to_scanascii
20358                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
20359 5823           8B47         02            mov	ax,2[bx]
20360 5826           88E0                       mov	al,ah
20361 5828           30E4                       xor	ah,ah
20362                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20363 582A           8846         FF            mov	-1[bp],al
20364                                           !BCC_EOS
20365                                           ! 3675         }
20366                                           ! 3676       } else {
20367                       0000582D            .4F1:
20368 582D           E9         008F            br 	.4F2
20369                       00005830            .4ED:
20370                                           ! 3677         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
20371                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20372 5830           8A46         FF            mov	al,-1[bp]
20373 5833           30E4                       xor	ah,ah
20374 5835           89C2                       mov	dx,ax
20375 5837           D1E0                       shl	ax,*1
20376 5839           D1E0                       shl	ax,*1
20377 583B           01D0                       add	ax,dx
20378 583D           D1E0                       shl	ax,*1
20379 583F           89C3                       mov	bx,ax
20380 5841           81C3                 017E  add	bx,#_scan_to_scanascii
20381                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
20382 5845           8A46         FD            mov	al,-3[bp]
20383 5848           2247         08            and	al,8[bx]
20384 584B           84C0                       test	al,al
20385 584D           74           3C            je  	.4F3
20386                       0000584F            .4F4:
20387                                           ! 3678           asciicode = scan_to_scanascii[scancode].shift;
20388                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20389 584F           8A46         FF            mov	al,-1[bp]
20390 5852           30E4                       xor	ah,ah
20391 5854           89C2                       mov	dx,ax
20392 5856           D1E0                       shl	ax,*1
20393 5858           D1E0                       shl	ax,*1
20394 585A           01D0                       add	ax,dx
20395 585C           D1E0                       shl	ax,*1
20396 585E           89C3                       mov	bx,ax
20397 5860           81C3                 017E  add	bx,#_scan_to_scanascii
20398                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
20399 5864           8A47         02            mov	al,2[bx]
20400 5867           8846         FE            mov	-2[bp],al
20401                                           !BCC_EOS
20402                                           ! 3679           scancode = scan_to_scanascii[scancode].shift >> 8;
20403                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20404 586A           8A46         FF            mov	al,-1[bp]
20405 586D           30E4                       xor	ah,ah
20406 586F           89C2                       mov	dx,ax
20407 5871           D1E0                       shl	ax,*1
20408 5873           D1E0                       shl	ax,*1
20409 5875           01D0                       add	ax,dx
20410 5877           D1E0                       shl	ax,*1
20411 5879           89C3                       mov	bx,ax
20412 587B           81C3                 017E  add	bx,#_scan_to_scanascii
20413                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
20414 587F           8B47         02            mov	ax,2[bx]
20415 5882           88E0                       mov	al,ah
20416 5884           30E4                       xor	ah,ah
20417                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20418 5886           8846         FF            mov	-1[bp],al
20419                                           !BCC_EOS
20420                                           ! 3680         } else {
20421 5889           EB           34            jmp .4F5
20422                       0000588B            .4F3:
20423                                           ! 3681           asciicode = scan_to_scanascii[scancode].normal;
20424                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20425 588B           8A46         FF            mov	al,-1[bp]
20426 588E           30E4                       xor	ah,ah
20427 5890           89C2                       mov	dx,ax
20428 5892           D1E0                       shl	ax,*1
20429 5894           D1E0                       shl	ax,*1
20430 5896           01D0                       add	ax,dx
20431 5898           D1E0                       shl	ax,*1
20432 589A           89C3                       mov	bx,ax
20433                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
20434 589C           8A87       017E            mov	al,_scan_to_scanascii[bx]
20435 58A0           8846         FE            mov	-2[bp],al
20436                                           !BCC_EOS
20437                                           ! 3682           scancode = scan_to_scanascii[scancode].normal >> 8;
20438                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20439 58A3           8A46         FF            mov	al,-1[bp]
20440 58A6           30E4                       xor	ah,ah
20441 58A8           89C2                       mov	dx,ax
20442 58AA           D1E0                       shl	ax,*1
20443 58AC           D1E0                       shl	ax,*1
20444 58AE           01D0                       add	ax,dx
20445 58B0           D1E0                       shl	ax,*1
20446 58B2           89C3                       mov	bx,ax
20447                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
20448 58B4           8B87       017E            mov	ax,_scan_to_scanascii[bx]
20449 58B8           88E0                       mov	al,ah
20450 58BA           30E4                       xor	ah,ah
20451                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20452 58BC           8846         FF            mov	-1[bp],al
20453                                           !BCC_EOS
20454                                           ! 3683         }
20455                                           ! 3684       }
20456                       000058BF            .4F5:
20457                                           ! 3685       set_DS(0x40);
20458                       000058BF            .4F2:
20459                       000058BF            .4EC:
20460                       000058BF            .4E7:
20461                       000058BF            .4E4:
20462                                           ! Debug: list int = const $40 (used reg = )
20463 58BF           B8                   0040  mov	ax,*$40
20464 58C2           50                         push	ax
20465                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
20466 58C3           E8         AD9C            call	_set_DS
20467 58C6           44                         inc	sp
20468 58C7           44                         inc	sp
20469                                           !BCC_EOS
20470                                           ! 3686       if (scancode==0 && asciicode==0) {
20471                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
20472 58C8           8A46         FF            mov	al,-1[bp]
20473 58CB           84C0                       test	al,al
20474 58CD           75           15            jne 	.4F6
20475                       000058CF            .4F8:
20476                                           ! Debug: logeq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
20477 58CF           8A46         FE            mov	al,-2[bp]
20478 58D2           84C0                       test	al,al
20479 58D4           75           0E            jne 	.4F6
20480                       000058D6            .4F7:
20481                                           ! 3687         bios_printf(4, "KBD: 
20482                                           ! 3687 int09h_handler(): scancode & asciicode are zero?\n");
20483                                           ! Debug: list * char = .4F9+0 (used reg = )
20484 58D6           BB                   D282  mov	bx,#.4F9
20485 58D9           53                         push	bx
20486                                           ! Debug: list int = const 4 (used reg = )
20487 58DA           B8                   0004  mov	ax,*4
20488 58DD           50                         push	ax
20489                                           ! Debug: func () void = bios_printf+0 (used reg = )
20490 58DE           E8         B05D            call	_bios_printf
20491 58E1           83C4                   04  add	sp,*4
20492                                           !BCC_EOS
20493                                           ! 3688       }
20494                                           ! 3689       enqueue_key(scancode, asciicode);
20495                       000058E4            .4F6:
20496                                           ! Debug: list unsigned char asciicode = [S+8-4] (used reg = )
20497 58E4           8A46         FE            mov	al,-2[bp]
20498 58E7           30E4                       xor	ah,ah
20499 58E9           50                         push	ax
20500                                           ! Debug: list unsigned char scancode = [S+$A-3] (used reg = )
20501 58EA           8A46         FF            mov	al,-1[bp]
20502 58ED           30E4                       xor	ah,ah
20503 58EF           50                         push	ax
20504                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
20505 58F0           E8         0081            call	_enqueue_key
20506 58F3           83C4                   04  add	sp,*4
20507                                           !BCC_EOS
20508                                           ! 3690       break;
20509 58F6           EB           59            jmp .4A9
20510                                           !BCC_EOS
20511                                           ! 3691   }
20512                                           ! 3692   if ((scancode & 0x7f) != 0x1d) {
20513 58F8           EB           57            jmp .4A9
20514                       000058FA            .4AB:
20515 58FA           2C                     1D  sub	al,*$1D
20516 58FC         0F84         FBB8            beq 	.4B2
20517 5900           2C                     0D  sub	al,*$D
20518 5902         0F84         FB6E            beq 	.4AE
20519 5906           2C                     0C  sub	al,*$C
20520 5908         0F84         FB8A            beq 	.4B0
20521 590C           2C                     02  sub	al,*2
20522 590E         0F84         FC28            beq 	.4BE
20523 5912           2C                     02  sub	al,*2
20524 5914         0F84         FB2C            beq 	.4AC
20525 5918           2C                     0B  sub	al,*$B
20526 591A         0F84         FC8C            beq 	.4C6
20527 591E           2C                     01  sub	al,*1
20528 5920         0F84         FCC8            beq 	.4CC
20529 5924           2C                     57  sub	al,*$57
20530 5926         0F84         FBCF            beq 	.4B8
20531 592A           2C                     0D  sub	al,*$D
20532 592C         0F84         FB55            beq 	.4AF
20533 5930           2C                     0C  sub	al,*$C
20534 5932         0F84         FB71            beq 	.4B1
20535 5936           2C                     02  sub	al,*2
20536 5938         0F84         FC36            beq 	.4C2
20537 593C           2C                     02  sub	al,*2
20538 593E         0F84         FB21            beq 	.4AD
20539 5942           2C                     0B  sub	al,*$B
20540 5944         0F84         FC8A            beq 	.4C9
20541 5948           2C                     01  sub	al,*1
20542 594A         0F84         FD01            beq 	.4D2
20543 594E           E9         FD2C            br 	.4D8
20544                       00005951            .4A9:
20545                       FFFFFFF8            ..FFF2	=	-8
20546                                           ! Debug: and int = const $7F to unsigned char scancode = [S+8-3] (used reg = )
20547 5951           8A46         FF            mov	al,-1[bp]
20548 5954           24                     7F  and	al,*$7F
20549                                           ! Debug: ne int = const $1D to unsigned char = al+0 (used reg = )
20550 5956           3C                     1D  cmp	al,*$1D
20551 5958           74           08            je  	.4FA
20552                       0000595A            .4FB:
20553                                           ! 3693     mf2_state &= ~0x01;
20554                                           ! Debug: andab int = const -2 to unsigned char mf2_state = [S+8-7] (used reg = )
20555 595A           8A46         FB            mov	al,-5[bp]
20556 595D           24                     FE  and	al,#$FE
20557 595F           8846         FB            mov	-5[bp],al
20558                                           !BCC_EOS
20559                                           ! 3694   }
20560                                           ! 3695   mf2_state &= ~0x02;
20561                       00005962            .4FA:
20562                                           ! Debug: andab int = const -3 to unsigned char mf2_state = [S+8-7] (used reg = )
20563 5962           8A46         FB            mov	al,-5[bp]
20564 5965           24                     FD  and	al,#$FD
20565 5967           8846         FB            mov	-5[bp],al
20566                                           !BCC_EOS
20567                                           ! 3696   *((Bit8u *)(0x96)) = (mf2_state);
20568                                           ! Debug: eq unsigned char mf2_state = [S+8-7] to unsigned char = [+$96] (used reg = )
20569 596A           8A46         FB            mov	al,-5[bp]
20570 596D           A2         0096            mov	[$96],al
20571                                           !BCC_EOS
20572                                           ! 3697 }
20573 5970           89EC                       mov	sp,bp
20574 5972           5D                         pop	bp
20575 5973           C3                         ret
20576                                           ! 3698   unsigned int
20577                                           ! Register BX used in function int09_function
20578                                           ! 3699 enqueue_key(scan_code, ascii_code)
20579                                           ! 3700   Bit8u scan_code, ascii_code;
20580                                           export	_enqueue_key
20581                       00005974            _enqueue_key:
20582                                           !BCC_EOS
20583                                           ! 3701 {
20584                                           ! 3702   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail, temp_tail, old_ds;
20585                                           !BCC_EOS
20586                                           ! 3703   old_ds = set_DS(0x40);
20587 5974           55                         push	bp
20588 5975           89E5                       mov	bp,sp
20589 5977           83C4                   F4  add	sp,*-$C
20590                                           ! Debug: list int = const $40 (used reg = )
20591 597A           B8                   0040  mov	ax,*$40
20592 597D           50                         push	ax
20593                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
20594 597E           E8         ACE1            call	_set_DS
20595 5981           44                         inc	sp
20596 5982           44                         inc	sp
20597                                           ! Debug: eq unsigned short = ax+0 to unsigned short old_ds = [S+$E-$E] (used reg = )
20598 5983           8946         F4            mov	-$C[bp],ax
20599                                           !BCC_EOS
20600                                           ! 3704   buffer_start = *((Bit16u *)(0x0080));
20601                                           ! Debug: eq unsigned short = [+$80] to unsigned short buffer_start = [S+$E-4] (used reg = )
20602 5986           A1         0080            mov	ax,[$80]
20603 5989           8946         FE            mov	-2[bp],ax
20604                                           !BCC_EOS
20605                                           ! 3705   buffer_end = *((Bit16u *)(0x0082));
20606                                           ! Debug: eq unsigned short = [+$82] to unsigned short buffer_end = [S+$E-6] (used reg = )
20607 598C           A1         0082            mov	ax,[$82]
20608 598F           8946         FC            mov	-4[bp],ax
20609                                           !BCC_EOS
20610                                           ! 3706   buffer_head = *((Bit16u *)(0x001A));
20611                                           ! Debug: eq unsigned short = [+$1A] to unsigned short buffer_head = [S+$E-8] (used reg = )
20612 5992           A1         001A            mov	ax,[$1A]
20613 5995           8946         FA            mov	-6[bp],ax
20614                                           !BCC_EOS
20615                                           ! 3707   buffer_tail = *((Bit16u *)(0x001C));
20616                                           ! Debug: eq unsigned short = [+$1C] to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20617 5998           A1         001C            mov	ax,[$1C]
20618 599B           8946         F8            mov	-8[bp],ax
20619                                           !BCC_EOS
20620                                           ! 3708   temp_tail = buffer_tail;
20621                                           ! Debug: eq unsigned short buffer_tail = [S+$E-$A] to unsigned short temp_tail = [S+$E-$C] (used reg = )
20622 599E           8B46         F8            mov	ax,-8[bp]
20623 59A1           8946         F6            mov	-$A[bp],ax
20624                                           !BCC_EOS
20625                                           ! 3709   buffer_tail += 2;
20626                                           ! Debug: addab int = const 2 to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20627 59A4           8B46         F8            mov	ax,-8[bp]
20628 59A7           40                         inc	ax
20629 59A8           40                         inc	ax
20630 59A9           8946         F8            mov	-8[bp],ax
20631                                           !BCC_EOS
20632                                           ! 3710   if (buffer_tail >= buffer_end)
20633                                           ! Debug: ge unsigned short buffer_end = [S+$E-6] to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20634 59AC           8B46         F8            mov	ax,-8[bp]
20635 59AF           3B46         FC            cmp	ax,-4[bp]
20636 59B2           72           06            jb  	.4FC
20637                       000059B4            .4FD:
20638                                           ! 3711     buffer_tail = buffer_start;
20639                                           ! Debug: eq unsigned short buffer_start = [S+$E-4] to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20640 59B4           8B46         FE            mov	ax,-2[bp]
20641 59B7           8946         F8            mov	-8[bp],ax
20642                                           !BCC_EOS
20643                                           ! 3712   if (buffer_tail == buffer_head) {
20644                       000059BA            .4FC:
20645                                           ! Debug: logeq unsigned short buffer_head = [S+$E-8] to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20646 59BA           8B46         F8            mov	ax,-8[bp]
20647 59BD           3B46         FA            cmp	ax,-6[bp]
20648 59C0           75           0E            jne 	.4FE
20649                       000059C2            .4FF:
20650                                           ! 3713     set_DS(old_ds);
20651                                           ! Debug: list unsigned short old_ds = [S+$E-$E] (used reg = )
20652 59C2           FF76         F4            push	-$C[bp]
20653                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
20654 59C5           E8         AC9A            call	_set_DS
20655 59C8           44                         inc	sp
20656 59C9           44                         inc	sp
20657                                           !BCC_EOS
20658                                           ! 3714     return(0);
20659 59CA           31C0                       xor	ax,ax
20660 59CC           89EC                       mov	sp,bp
20661 59CE           5D                         pop	bp
20662 59CF           C3                         ret
20663                                           !BCC_EOS
20664                                           ! 3715   }
20665                                           ! 3716   *((Bit8u *)(temp_tail)) = (ascii_code);
20666                       000059D0            .4FE:
20667 59D0           8B5E         F6            mov	bx,-$A[bp]
20668                                           ! Debug: eq unsigned char ascii_code = [S+$E+4] to unsigned char = [bx+0] (used reg = )
20669 59D3           8A46         06            mov	al,6[bp]
20670 59D6           8807                       mov	[bx],al
20671                                           !BCC_EOS
20672                                           ! 3717   *((Bit8u *)(temp_tail+1)) = (scan_code);
20673                                           ! Debug: add int = const 1 to unsigned short temp_tail = [S+$E-$C] (used reg = )
20674 59D8           8B46         F6            mov	ax,-$A[bp]
20675                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+1 (used reg = )
20676 59DB           89C3                       mov	bx,ax
20677                                           ! Debug: eq unsigned char scan_code = [S+$E+2] to unsigned char = [bx+1] (used reg = )
20678 59DD           8A46         04            mov	al,4[bp]
20679 59E0           8847         01            mov	1[bx],al
20680                                           !BCC_EOS
20681                                           ! 3718   *((Bit16u *)(0x001C)) = (buffer_tail);
20682                                           ! Debug: eq unsigned short buffer_tail = [S+$E-$A] to unsigned short = [+$1C] (used reg = )
20683 59E3           8B46         F8            mov	ax,-8[bp]
20684 59E6           A3         001C            mov	[$1C],ax
20685                                           !BCC_EOS
20686                                           ! 3719   set_DS(old_ds);
20687                                           ! Debug: list unsigned short old_ds = [S+$E-$E] (used reg = )
20688 59E9           FF76         F4            push	-$C[bp]
20689                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
20690 59EC           E8         AC73            call	_set_DS
20691 59EF           44                         inc	sp
20692 59F0           44                         inc	sp
20693                                           !BCC_EOS
20694                                           ! 3720   return(1);
20695 59F1           B8                   0001  mov	ax,*1
20696 59F4           89EC                       mov	sp,bp
20697 59F6           5D                         pop	bp
20698 59F7           C3                         ret
20699                                           !BCC_EOS
20700                                           ! 3721 }
20701                                           ! 3722   void
20702                                           ! Register BX used in function enqueue_key
20703                                           ! 3723 int74_function(make_farcall, Z, Y, X, status)
20704                                           ! 3724   Bit16u make_farcall, Z, Y, X, status;
20705                                           export	_int74_function
20706                       000059F8            _int74_function:
20707                                           !BCC_EOS
20708                                           ! 3725 {
20709                                           ! 3726   Bit8u in_byte, index, package_count;
20710                                           !BCC_EOS
20711                                           ! 3727   Bit8u mouse_flags_1, mouse_flags_2;
20712                                           !BCC_EOS
20713                                           ! 3728 ;
20714 59F8           55                         push	bp
20715 59F9           89E5                       mov	bp,sp
20716 59FB           83C4                   FA  add	sp,*-6
20717                                           !BCC_EOS
20718                                           ! 3729   make_farcall = 0;
20719                                           ! Debug: eq int = const 0 to unsigned short make_farcall = [S+8+2] (used reg = )
20720 59FE           31C0                       xor	ax,ax
20721 5A00           8946         04            mov	4[bp],ax
20722                                           !BCC_EOS
20723                                           ! 3730   in_byte = inb(0x0064);
20724                                           ! Debug: list int = const $64 (used reg = )
20725 5A03           B8                   0064  mov	ax,*$64
20726 5A06           50                         push	ax
20727                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20728 5A07           E8         AAEE            call	_inb
20729 5A0A           44                         inc	sp
20730 5A0B           44                         inc	sp
20731                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+8-3] (used reg = )
20732 5A0C           8846         FF            mov	-1[bp],al
20733                                           !BCC_EOS
20734                                           ! 3731   if ((in_byte & 0x21) != 0x21) {
20735                                           ! Debug: and int = const $21 to unsigned char in_byte = [S+8-3] (used reg = )
20736 5A0F           8A46         FF            mov	al,-1[bp]
20737 5A12           24                     21  and	al,*$21
20738                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
20739 5A14           3C                     21  cmp	al,*$21
20740 5A16           74           04            je  	.500
20741                       00005A18            .501:
20742                                           ! 3732     return;
20743 5A18           89EC                       mov	sp,bp
20744 5A1A           5D                         pop	bp
20745 5A1B           C3                         ret
20746                                           !BCC_EOS
20747                                           ! 3733   }
20748                                           ! 3734   in_byte = inb(0x0060);
20749                       00005A1C            .500:
20750                                           ! Debug: list int = const $60 (used reg = )
20751 5A1C           B8                   0060  mov	ax,*$60
20752 5A1F           50                         push	ax
20753                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20754 5A20           E8         AAD5            call	_inb
20755 5A23           44                         inc	sp
20756 5A24           44                         inc	sp
20757                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+8-3] (used reg = )
20758 5A25           8846         FF            mov	-1[bp],al
20759                                           !BCC_EOS
20760                                           ! 3735 ;
20761                                           !BCC_EOS
20762                                           ! 3736   mouse_flags_1 = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_flag1));
20763                                           ! Debug: eq unsigned char = [+$26] to unsigned char mouse_flags_1 = [S+8-6] (used reg = )
20764 5A28           A0         0026            mov	al,[$26]
20765 5A2B           8846         FC            mov	-4[bp],al
20766                                           !BCC_EOS
20767                                           ! 3737   mouse_flags_2 = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_flag2));
20768                                           ! Debug: eq unsigned char = [+$27] to unsigned char mouse_flags_2 = [S+8-7] (used reg = )
20769 5A2E           A0         0027            mov	al,[$27]
20770 5A31           8846         FB            mov	-5[bp],al
20771                                           !BCC_EOS
20772                                           ! 3738   if ((mouse_flags_2 & 0x80) != 0x80) {
20773                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+8-7] (used reg = )
20774 5A34           8A46         FB            mov	al,-5[bp]
20775 5A37           24                     80  and	al,#$80
20776                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
20777 5A39           3C                     80  cmp	al,#$80
20778 5A3B           74           04            je  	.502
20779                       00005A3D            .503:
20780                                           ! 3739       return;
20781 5A3D           89EC                       mov	sp,bp
20782 5A3F           5D                         pop	bp
20783 5A40           C3                         ret
20784                                           !BCC_EOS
20785                                           ! 3740   }
20786                                           ! 3741   package_count = mouse_flags_2 & 0x07;
20787                       00005A41            .502:
20788                                           ! Debug: and int = const 7 to unsigned char mouse_flags_2 = [S+8-7] (used reg = )
20789 5A41           8A46         FB            mov	al,-5[bp]
20790 5A44           24                     07  and	al,*7
20791                                           ! Debug: eq unsigned char = al+0 to unsigned char package_count = [S+8-5] (used reg = )
20792 5A46           8846         FD            mov	-3[bp],al
20793                                           !BCC_EOS
20794                                           ! 3742   index = mouse_flags_1 & 0x07;
20795                                           ! Debug: and int = const 7 to unsigned char mouse_flags_1 = [S+8-6] (used reg = )
20796 5A49           8A46         FC            mov	al,-4[bp]
20797 5A4C           24                     07  and	al,*7
20798                                           ! Debug: eq unsigned char = al+0 to unsigned char index = [S+8-4] (used reg = )
20799 5A4E           8846         FE            mov	-2[bp],al
20800                                           !BCC_EOS
20801                                           ! 3743   *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[index])) = (in_byte);
20802                                           ! Debug: ptradd unsigned char index = [S+8-4] to [8] unsigned char = const $28 (used reg = )
20803 5A51           8A46         FE            mov	al,-2[bp]
20804 5A54           30E4                       xor	ah,ah
20805 5A56           89C3                       mov	bx,ax
20806                                           ! Debug: address unsigned char = [bx+$28] (used reg = )
20807                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$28 (used reg = )
20808                                           ! Debug: eq unsigned char in_byte = [S+8-3] to unsigned char = [bx+$28] (used reg = )
20809 5A58           8A46         FF            mov	al,-1[bp]
20810 5A5B           8847         28            mov	$28[bx],al
20811                                           !BCC_EOS
20812                                           ! 3744   if (index >= package_count) {
20813                                           ! Debug: ge unsigned char package_count = [S+8-5] to unsigned char index = [S+8-4] (used reg = )
20814 5A5E           8A46         FE            mov	al,-2[bp]
20815 5A61           3A46         FD            cmp	al,-3[bp]
20816 5A64           72           5A            jb  	.504
20817                       00005A66            .505:
20818                                           ! 3745 ;
20819                                           !BCC_EOS
20820                                           ! 3746     if (package_count == 3) {
20821                                           ! Debug: logeq int = const 3 to unsigned char package_count = [S+8-5] (used reg = )
20822 5A66           8A46         FD            mov	al,-3[bp]
20823 5A69           3C                     03  cmp	al,*3
20824 5A6B           75           20            jne 	.506
20825                       00005A6D            .507:
20826                                           ! 3747       status = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[0]));
20827                                           ! Debug: eq unsigned char = [+$28] to unsigned short status = [S+8+$A] (used reg = )
20828 5A6D           A0         0028            mov	al,[$28]
20829 5A70           30E4                       xor	ah,ah
20830 5A72           8946         0C            mov	$C[bp],ax
20831                                           !BCC_EOS
20832                                           ! 3748       *(((Bit8u *)&status)+1) = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[1]));
20833                                           ! Debug: eq unsigned char = [+$29] to unsigned char status = [S+8+$B] (used reg = )
20834 5A75           A0         0029            mov	al,[$29]
20835 5A78           8846         0D            mov	$D[bp],al
20836                                           !BCC_EOS
20837                                           ! 3749       X = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[2]));
20838                                           ! Debug: eq unsigned char = [+$2A] to unsigned short X = [S+8+8] (used reg = )
20839 5A7B           A0         002A            mov	al,[$2A]
20840 5A7E           30E4                       xor	ah,ah
20841 5A80           8946         0A            mov	$A[bp],ax
20842                                           !BCC_EOS
20843                                           ! 3750       Y = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[3]));
20844                                           ! Debug: eq unsigned char = [+$2B] to unsigned short Y = [S+8+6] (used reg = )
20845 5A83           A0         002B            mov	al,[$2B]
20846 5A86           30E4                       xor	ah,ah
20847 5A88           8946         08            mov	8[bp],ax
20848                                           !BCC_EOS
20849                                           ! 3751     } else {
20850 5A8B           EB           18            jmp .508
20851                       00005A8D            .506:
20852                                           ! 3752       status = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[0]));
20853                                           ! Debug: eq unsigned char = [+$28] to unsigned short status = [S+8+$A] (used reg = )
20854 5A8D           A0         0028            mov	al,[$28]
20855 5A90           30E4                       xor	ah,ah
20856 5A92           8946         0C            mov	$C[bp],ax
20857                                           !BCC_EOS
20858                                           ! 3753       X = *((Bit8u *)(&((ebda_data_t *) 0)->mouse_data[1]));
20859                                           ! Debug: eq unsigned char = [+$29] to unsigned short X = [S+8+8] (used reg = )
20860 5A95           A0         0029            mov	al,[$29]
20861 5A98           30E4                       xor	ah,ah
20862 5A9A           8946         0A            mov	$A[bp],ax
20863                                           !BCC_EOS
20864                                           ! 3754       Y = *(
20865                                           ! 3754 (Bit8u *)(&((ebda_data_t *) 0)->mouse_data[2]));
20866                                           ! Debug: eq unsigned char = [+$2A] to unsigned short Y = [S+8+6] (used reg = )
20867 5A9D           A0         002A            mov	al,[$2A]
20868 5AA0           30E4                       xor	ah,ah
20869 5AA2           8946         08            mov	8[bp],ax
20870                                           !BCC_EOS
20871                                           ! 3755     }
20872                                           ! 3756     Z = 0;
20873                       00005AA5            .508:
20874                                           ! Debug: eq int = const 0 to unsigned short Z = [S+8+4] (used reg = )
20875 5AA5           31C0                       xor	ax,ax
20876 5AA7           8946         06            mov	6[bp],ax
20877                                           !BCC_EOS
20878                                           ! 3757     mouse_flags_1 = 0;
20879                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+8-6] (used reg = )
20880 5AAA           30C0                       xor	al,al
20881 5AAC           8846         FC            mov	-4[bp],al
20882                                           !BCC_EOS
20883                                           ! 3758     if (mouse_flags_2 & 0x80)
20884                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+8-7] (used reg = )
20885 5AAF           8A46         FB            mov	al,-5[bp]
20886 5AB2           24                     80  and	al,#$80
20887 5AB4           84C0                       test	al,al
20888 5AB6           74           06            je  	.509
20889                       00005AB8            .50A:
20890                                           ! 3759       make_farcall = 1;
20891                                           ! Debug: eq int = const 1 to unsigned short make_farcall = [S+8+2] (used reg = )
20892 5AB8           B8                   0001  mov	ax,*1
20893 5ABB           8946         04            mov	4[bp],ax
20894                                           !BCC_EOS
20895                                           ! 3760   } else {
20896                       00005ABE            .509:
20897 5ABE           EB           07            jmp .50B
20898                       00005AC0            .504:
20899                                           ! 3761     mouse_flags_1++;
20900                                           ! Debug: postinc unsigned char mouse_flags_1 = [S+8-6] (used reg = )
20901 5AC0           8A46         FC            mov	al,-4[bp]
20902 5AC3           40                         inc	ax
20903 5AC4           8846         FC            mov	-4[bp],al
20904                                           !BCC_EOS
20905                                           ! 3762   }
20906                                           ! 3763   *((Bit8u *)(&((ebda_data_t *) 0)->mouse_flag1)) = (mouse_flags_1);
20907                       00005AC7            .50B:
20908                                           ! Debug: eq unsigned char mouse_flags_1 = [S+8-6] to unsigned char = [+$26] (used reg = )
20909 5AC7           8A46         FC            mov	al,-4[bp]
20910 5ACA           A2         0026            mov	[$26],al
20911                                           !BCC_EOS
20912                                           ! 3764 }
20913 5ACD           89EC                       mov	sp,bp
20914 5ACF           5D                         pop	bp
20915 5AD0           C3                         ret
20916                                           ! 3765   int
20917                                           ! Register BX used in function int74_function
20918                                           ! 3766 int13_edd(DS, SI, device)
20919                                           ! 3767   Bit16u DS, SI;
20920                                           export	_int13_edd
20921                       00005AD1            _int13_edd:
20922                                           !BCC_EOS
20923                                           ! 3768   Bit8u device;
20924                                           !BCC_EOS
20925                                           ! 3769 {
20926                                           ! 3770   Bit32u lba_low, lba_high;
20927                                           !BCC_EOS
20928                                           ! 3771   Bit16u npc, nph, npspt, size, t13;
20929                                           !BCC_EOS
20930                                           ! 3772   Bit16u ebda_seg=get_ebda_seg();
20931 5AD1           55                         push	bp
20932 5AD2           89E5                       mov	bp,sp
20933 5AD4           83C4                   EC  add	sp,*-$14
20934                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
20935 5AD7           E8         AB92            call	_get_ebda_seg
20936                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$16-$16] (used reg = )
20937 5ADA           8946         EC            mov	-$14[bp],ax
20938                                           !BCC_EOS
20939                                           ! 3773   Bit8u type=*((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].type));
20940 5ADD           4C                         dec	sp
20941                                           ! Debug: ptradd unsigned char device = [S+$17+6] to [8] struct  = const $142 (used reg = )
20942 5ADE           8A46         08            mov	al,8[bp]
20943 5AE1           30E4                       xor	ah,ah
20944 5AE3           B9                   001E  mov	cx,*$1E
20945 5AE6           F7E9                       imul	cx
20946 5AE8           89C3                       mov	bx,ax
20947                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
20948                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$142 (used reg = )
20949                                           ! Debug: eq unsigned char = [bx+$142] to unsigned char type = [S+$17-$17] (used reg = )
20950 5AEA           8A87       0142            mov	al,$142[bx]
20951 5AEE           8846         EB            mov	-$15[bp],al
20952                                           !BCC_EOS
20953                                           ! 3774   size=_read_word(SI+(Bit16u)&((dpt_t *) 0)->size, DS);
20954 5AF1           4C                         dec	sp
20955                                           ! Debug: list unsigned short DS = [S+$18+2] (used reg = )
20956 5AF2           FF76         04            push	4[bp]
20957                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$1A+4] (used reg = )
20958 5AF5           8B46         06            mov	ax,6[bp]
20959                                           ! Debug: list unsigned int = ax+0 (used reg = )
20960 5AF8           50                         push	ax
20961                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
20962 5AF9           E8         AAF6            call	__read_word
20963 5AFC           83C4                   04  add	sp,*4
20964                                           ! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$18-$12] (used reg = )
20965 5AFF           8946         F0            mov	-$10[bp],ax
20966                                           !BCC_EOS
20967                                           ! 3775   t13 = size == 74;
20968                                           ! Debug: logeq int = const $4A to unsigned short size = [S+$18-$12] (used reg = )
20969 5B02           8B46         F0            mov	ax,-$10[bp]
20970 5B05           3D                   004A  cmp	ax,*$4A
20971 5B08           75           04            jne	.50C
20972 5B0A           B0                     01  mov	al,*1
20973 5B0C           EB           02            jmp	.50D
20974                       00005B0E            .50C:
20975 5B0E           30C0                       xor	al,al
20976                       00005B10            .50D:
20977                                           ! Debug: eq char = al+0 to unsigned short t13 = [S+$18-$14] (used reg = )
20978 5B10           30E4                       xor	ah,ah
20979 5B12           8946         EE            mov	-$12[bp],ax
20980                                           !BCC_EOS
20981                                           ! 3776   if(size < 26)
20982                                           ! Debug: lt int = const $1A to unsigned short size = [S+$18-$12] (used reg = )
20983 5B15           8B46         F0            mov	ax,-$10[bp]
20984 5B18           3D                   001A  cmp	ax,*$1A
20985 5B1B           73           07            jae 	.50E
20986                       00005B1D            .50F:
20987                                           ! 3777     return 1;
20988 5B1D           B8                   0001  mov	ax,*1
20989 5B20           89EC                       mov	sp,bp
20990 5B22           5D                         pop	bp
20991 5B23           C3                         ret
20992                                           !BCC_EOS
20993                                           ! 3778   if(size >= 26) {
20994                       00005B24            .50E:
20995                                           ! Debug: ge int = const $1A to unsigned short size = [S+$18-$12] (used reg = )
20996 5B24           8B46         F0            mov	ax,-$10[bp]
20997 5B27           3D                   001A  cmp	ax,*$1A
20998 5B2A         0F82         01DB            blo 	.510
20999                       00005B2E            .511:
21000                                           ! 3779     Bit16u blksize, infos;
21001                                           !BCC_EOS
21002                                           ! 3780     _write_word(26, SI+(Bit16u)&((dpt_t *) 0)->size, DS);
21003 5B2E           83C4                   FC  add	sp,*-4
21004                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21005 5B31           FF76         04            push	4[bp]
21006                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$1E+4] (used reg = )
21007 5B34           8B46         06            mov	ax,6[bp]
21008                                           ! Debug: list unsigned int = ax+0 (used reg = )
21009 5B37           50                         push	ax
21010                                           ! Debug: list int = const $1A (used reg = )
21011 5B38           B8                   001A  mov	ax,*$1A
21012 5B3B           50                         push	ax
21013                                           ! Debug: func () void = _write_word+0 (used reg = )
21014 5B3C           E8         AAD4            call	__write_word
21015 5B3F           83C4                   06  add	sp,*6
21016                                           !BCC_EOS
21017                                           ! 3781     blksize = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].blksize));
21018                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
21019 5B42           8A46         08            mov	al,8[bp]
21020 5B45           30E4                       xor	ah,ah
21021 5B47           B9                   001E  mov	cx,*$1E
21022 5B4A           F7E9                       imul	cx
21023 5B4C           89C3                       mov	bx,ax
21024                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
21025                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$148 (used reg = )
21026                                           ! Debug: eq unsigned short = [bx+$148] to unsigned short blksize = [S+$1C-$1A] (used reg = )
21027 5B4E           8B9F       0148            mov	bx,$148[bx]
21028 5B52           895E         E8            mov	-$18[bp],bx
21029                                           !BCC_EOS
21030                                           ! 3782     if (type == 0x02)
21031                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$1C-$17] (used reg = )
21032 5B55           8A46         EB            mov	al,-$15[bp]
21033 5B58           3C                     02  cmp	al,*2
21034 5B5A         0F85         00DB            bne 	.512
21035                       00005B5E            .513:
21036                                           ! 3783     {
21037                                           ! 3784       npc = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders));
21038                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
21039 5B5E           8A46         08            mov	al,8[bp]
21040 5B61           30E4                       xor	ah,ah
21041 5B63           B9                   001E  mov	cx,*$1E
21042 5B66           F7E9                       imul	cx
21043 5B68           89C3                       mov	bx,ax
21044                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
21045                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$154 (used reg = )
21046                                           ! Debug: eq unsigned short = [bx+$154] to unsigned short npc = [S+$1C-$C] (used reg = )
21047 5B6A           8B9F       0154            mov	bx,$154[bx]
21048 5B6E           895E         F6            mov	-$A[bp],bx
21049                                           !BCC_EOS
21050                                           ! 3785       nph = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.heads));
21051                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
21052 5B71           8A46         08            mov	al,8[bp]
21053 5B74           30E4                       xor	ah,ah
21054 5B76           B9                   001E  mov	cx,*$1E
21055 5B79           F7E9                       imul	cx
21056 5B7B           89C3                       mov	bx,ax
21057                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
21058                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$152 (used reg = )
21059                                           ! Debug: eq unsigned short = [bx+$152] to unsigned short nph = [S+$1C-$E] (used reg = )
21060 5B7D           8B9F       0152            mov	bx,$152[bx]
21061 5B81           895E         F4            mov	-$C[bp],bx
21062                                           !BCC_EOS
21063                                           ! 3786       npspt = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.spt));
21064                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
21065 5B84           8A46         08            mov	al,8[bp]
21066 5B87           30E4                       xor	ah,ah
21067 5B89           B9                   001E  mov	cx,*$1E
21068 5B8C           F7E9                       imul	cx
21069 5B8E           89C3                       mov	bx,ax
21070                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
21071                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$156 (used reg = )
21072                                           ! Debug: eq unsigned short = [bx+$156] to unsigned short npspt = [S+$1C-$10] (used reg = )
21073 5B90           8B9F       0156            mov	bx,$156[bx]
21074 5B94           895E         F2            mov	-$E[bp],bx
21075                                           !BCC_EOS
21076                                           ! 3787       lba_low = *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_low));
21077                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
21078 5B97           8A46         08            mov	al,8[bp]
21079 5B9A           30E4                       xor	ah,ah
21080 5B9C           B9                   001E  mov	cx,*$1E
21081 5B9F           F7E9                       imul	cx
21082 5BA1           89C3                       mov	bx,ax
21083                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
21084                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$158 (used reg = )
21085                                           ! Debug: eq unsigned long = [bx+$158] to unsigned long lba_low = [S+$1C-6] (used reg = )
21086 5BA3           8B87       0158            mov	ax,$158[bx]
21087 5BA7           8B9F       015A            mov	bx,$15A[bx]
21088 5BAB           8946         FC            mov	-4[bp],ax
21089 5BAE           895E         FE            mov	-2[bp],bx
21090                                           !BCC_EOS
21091                                           ! 3788       lba_high = *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high));
21092                                           ! Debug: ptradd unsigned char device = [S+$1C+6] to [8] struct  = const $142 (used reg = )
21093 5BB1           8A46         08            mov	al,8[bp]
21094 5BB4           30E4                       xor	ah,ah
21095 5BB6           B9                   001E  mov	cx,*$1E
21096 5BB9           F7E9                       imul	cx
21097 5BBB           89C3                       mov	bx,ax
21098                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
21099                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
21100                                           ! Debug: eq unsigned long = [bx+$15C] to unsigned long lba_high = [S+$1C-$A] (used reg = )
21101 5BBD           8B87       015C            mov	ax,$15C[bx]
21102 5BC1           8B9F       015E            mov	bx,$15E[bx]
21103 5BC5           8946         F8            mov	-8[bp],ax
21104 5BC8           895E         FA            mov	-6[bp],bx
21105                                           !BCC_EOS
21106                                           ! 3789       if (lba_high || (lba_low/npspt)/nph > 0x3fff)
21107 5BCB           8B46         F8            mov	ax,-8[bp]
21108 5BCE           8B5E         FA            mov	bx,-6[bp]
21109 5BD1           E8         A511            call	ltstl
21110 5BD4           75           50            jne 	.515
21111                       00005BD6            .516:
21112                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$1C-$E] (used reg = )
21113 5BD6           8B46         F4            mov	ax,-$C[bp]
21114 5BD9           31DB                       xor	bx,bx
21115 5BDB           53                         push	bx
21116 5BDC           50                         push	ax
21117                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$20-$10] (used reg = )
21118 5BDD           8B46         F2            mov	ax,-$E[bp]
21119 5BE0           31DB                       xor	bx,bx
21120                                           ! Debug: div unsigned long = bx+0 to unsigned long lba_low = [S+$20-6] (used reg = )
21121 5BE2           53                         push	bx
21122 5BE3           50                         push	ax
21123 5BE4           8B46         FC            mov	ax,-4[bp]
21124 5BE7           8B5E         FE            mov	bx,-2[bp]
21125 5BEA           8D7E         DE            lea	di,-$22[bp]
21126 5BED           E8         A54F            call	ldivul
21127 5BF0           83C4                   04  add	sp,*4
21128                                           ! Debug: div unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
21129 5BF3           8D7E         E2            lea	di,-$1E[bp]
21130 5BF6           E8         A546            call	ldivul
21131 5BF9           83C4                   04  add	sp,*4
21132                                           ! Debug: gt unsigned long = const $3FFF to unsigned long = bx+0 (used reg = )
21133 5BFC           53                         push	bx
21134 5BFD           50                         push	ax
21135 5BFE           B8                   3FFF  mov	ax,#$3FFF
21136 5C01           31DB                       xor	bx,bx
21137 5C03           53                         push	bx
21138 5C04           50                         push	ax
21139 5C05           8B46         E2            mov	ax,-$1E[bp]
21140 5C08           8B5E         E4            mov	bx,-$1C[bp]
21141 5C0B           8D7E         DE            lea	di,-$22[bp]
21142 5C0E           E8         A48B            call	lcmpul
21143 5C11           76           04            jbe	.517
21144 5C13           B0                     01  mov	al,*1
21145 5C15           EB           02            jmp	.518
21146                       00005C17            .517:
21147 5C17           30C0                       xor	al,al
21148                       00005C19            .518:
21149 5C19           83C4                   08  add	sp,*8
21150                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
21151 5C1C           30E4                       xor	ah,ah
21152 5C1E           99                         cwd
21153 5C1F           89D3                       mov	bx,dx
21154 5C21           E8         A4C1            call	ltstl
21155 5C24           74           0D            je  	.514
21156                       00005C26            .515:
21157                                           ! 3790       {
21158                                           ! 3791         infos = 0 << 1;
21159                                           ! Debug: eq int = const 0 to unsigned short infos = [S+$1C-$1C] (used reg = )
21160 5C26           31C0                       xor	ax,ax
21161 5C28           8946         E6            mov	-$1A[bp],ax
21162                                           !BCC_EOS
21163                                           ! 3792         npc = 0x3fff;
21164                                           ! Debug: eq int = const $3FFF to unsigned short npc = [S+$1C-$C] (used reg = )
21165 5C2B           B8                   3FFF  mov	ax,#$3FFF
21166 5C2E           8946         F6            mov	-$A[bp],ax
21167                                           !BCC_EOS
21168                                           ! 3793       }
21169                                           ! 3794       else
21170                                           ! 3795       {
21171 5C31           EB           06            jmp .51A
21172                       00005C33            .514:
21173                                           ! 3796         infos = 1 << 1;
21174                                           ! Debug: eq int = const 2 to unsigned short infos = [S+$1C-$1C] (used reg = )
21175 5C33           B8                   0002  mov	ax,*2
21176 5C36           8946         E6            mov	-$1A[bp],ax
21177                                           !BCC_EOS
21178                                           ! 3797       }
21179                                           ! 3798     }
21180                       00005C39            .51A:
21181                                           ! 3799     if (type == 0x03)
21182                       00005C39            .512:
21183                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$1C-$17] (used reg = )
21184 5C39           8A46         EB            mov	al,-$15[bp]
21185 5C3C           3C                     03  cmp	al,*3
21186 5C3E           75           30            jne 	.51B
21187                       00005C40            .51C:
21188                                           ! 3800     {
21189                                           ! 3801       npc = 0xffffffff;
21190                                           ! Debug: eq unsigned long = const $FFFFFFFF to unsigned short npc = [S+$1C-$C] (used reg = )
21191 5C40           B8                   FFFF  mov	ax,#$FFFF
21192 5C43           8946         F6            mov	-$A[bp],ax
21193                                           !BCC_EOS
21194                                           ! 3802       nph = 0xffffffff;
21195                                           ! Debug: eq unsigned long = const $FFFFFFFF to unsigned short nph = [S+$1C-$E] (used reg = )
21196 5C46           B8                   FFFF  mov	ax,#$FFFF
21197 5C49           8946         F4            mov	-$C[bp],ax
21198                                           !BCC_EOS
21199                                           ! 3803       npspt = 0xffffffff;
21200                                           ! Debug: eq unsigned long = const $FFFFFFFF to unsigned short npspt = [S+$1C-$10] (used reg = )
21201 5C4C           B8                   FFFF  mov	ax,#$FFFF
21202 5C4F           8946         F2            mov	-$E[bp],ax
21203                                           !BCC_EOS
21204                                           ! 3804       lba_low = 0xffffffff;
21205                                           ! Debug: eq unsigned long = const $FFFFFFFF to unsigned long lba_low = [S+$1C-6] (used reg = )
21206 5C52           B8                   FFFF  mov	ax,#$FFFF
21207 5C55           BB                   FFFF  mov	bx,#$FFFF
21208 5C58           8946         FC            mov	-4[bp],ax
21209 5C5B           895E         FE            mov	-2[bp],bx
21210                                           !BCC_EOS
21211                                           ! 3805       lba_high = 0xffffffff;
21212                                           ! Debug: eq unsigned long = const $FFFFFFFF to unsigned long lba_high = [S+$1C-$A] (used reg = )
21213 5C5E           B8                   FFFF  mov	ax,#$FFFF
21214 5C61           BB                   FFFF  mov	bx,#$FFFF
21215 5C64           8946         F8            mov	-8[bp],ax
21216 5C67           895E         FA            mov	-6[bp],bx
21217                                           !BCC_EOS
21218                                           ! 3806       infos = 1 << 2 | 1 << 4 |
21219                                           ! 3807                1 << 5 | 1 << 6;
21220                                           ! Debug: eq int = const $74 to unsigned short infos = [S+$1C-$1C] (used reg = )
21221 5C6A           B8                   0074  mov	ax,*$74
21222 5C6D           8946         E6            mov	-$1A[bp],ax
21223                                           !BCC_EOS
21224                                           ! 3808     }
21225                                           ! 3809     _write_word(infos, SI+(Bit16u)&((dpt_t *) 0)->infos, DS);
21226                       00005C70            .51B:
21227                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21228 5C70           FF76         04            push	4[bp]
21229                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$1E+4] (used reg = )
21230 5C73           8B46         06            mov	ax,6[bp]
21231                                           ! Debug: list unsigned int = ax+2 (used reg = )
21232 5C76           40                         inc	ax
21233 5C77           40                         inc	ax
21234 5C78           50                         push	ax
21235                                           ! Debug: list unsigned short infos = [S+$20-$1C] (used reg = )
21236 5C79           FF76         E6            push	-$1A[bp]
21237                                           ! Debug: func () void = _write_word+0 (used reg = )
21238 5C7C           E8         A994            call	__write_word
21239 5C7F           83C4                   06  add	sp,*6
21240                                           !BCC_EOS
21241                                           ! 3810     _write_dword((Bit32u)npc, SI+(Bit16u)&((dpt_t *) 0)->cylinders, DS);
21242                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21243 5C82           FF76         04            push	4[bp]
21244                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$1E+4] (used reg = )
21245 5C85           8B46         06            mov	ax,6[bp]
21246                                           ! Debug: list unsigned int = ax+4 (used reg = )
21247 5C88           05                   0004  add	ax,*4
21248 5C8B           50                         push	ax
21249                                           ! Debug: cast unsigned long = const 0 to unsigned short npc = [S+$20-$C] (used reg = )
21250 5C8C           8B46         F6            mov	ax,-$A[bp]
21251 5C8F           31DB                       xor	bx,bx
21252                                           ! Debug: list unsigned long = bx+0 (used reg = )
21253 5C91           53                         push	bx
21254 5C92           50                         push	ax
21255                                           ! Debug: func () void = _write_dword+0 (used reg = )
21256 5C93           E8         A3D1            call	__write_dword
21257 5C96           83C4                   08  add	sp,*8
21258                                           !BCC_EOS
21259                                           ! 3811     _write_dword((Bit32u)nph, SI+(Bit16u)&((dpt_t *) 0)->heads, DS);
21260                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21261 5C99           FF76         04            push	4[bp]
21262                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$1E+4] (used reg = )
21263 5C9C           8B46         06            mov	ax,6[bp]
21264                                           ! Debug: list unsigned int = ax+8 (used reg = )
21265 5C9F           05                   0008  add	ax,*8
21266 5CA2           50                         push	ax
21267                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$20-$E] (used reg = )
21268 5CA3           8B46         F4            mov	ax,-$C[bp]
21269 5CA6           31DB                       xor	bx,bx
21270                                           ! Debug: list unsigned long = bx+0 (used reg = )
21271 5CA8           53                         push	bx
21272 5CA9           50                         push	ax
21273                                           ! Debug: func () void = _write_dword+0 (used reg = )
21274 5CAA           E8         A3BA            call	__write_dword
21275 5CAD           83C4                   08  add	sp,*8
21276                                           !BCC_EOS
21277                                           ! 3812     _write_dword((Bit32u)npspt, SI+(Bit16u)&((dpt_t *) 0)->spt, DS);
21278                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21279 5CB0           FF76         04            push	4[bp]
21280                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$1E+4] (used reg = )
21281 5CB3           8B46         06            mov	ax,6[bp]
21282                                           ! Debug: list unsigned int = ax+$C (used reg = )
21283 5CB6           05                   000C  add	ax,*$C
21284 5CB9           50                         push	ax
21285                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$20-$10] (used reg = )
21286 5CBA           8B46         F2            mov	ax,-$E[bp]
21287 5CBD           31DB                       xor	bx,bx
21288                                           ! Debug: list unsigned long = bx+0 (used reg = )
21289 5CBF           53                         push	bx
21290 5CC0           50                         push	ax
21291                                           ! Debug: func () void = _write_dword+0 (used reg = )
21292 5CC1           E8         A3A3            call	__write_dword
21293 5CC4           83C4                   08  add	sp,*8
21294                                           !BCC_EOS
21295                                           ! 3813     _write_dword(lba_low, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, DS);
21296                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21297 5CC7           FF76         04            push	4[bp]
21298                                           ! Debug: add unsigned short = const $10 to unsigned short SI = [S+$1E+4] (used reg = )
21299 5CCA           8B46         06            mov	ax,6[bp]
21300                                           ! Debug: list unsigned int = ax+$10 (used reg = )
21301 5CCD           05                   0010  add	ax,*$10
21302 5CD0           50                         push	ax
21303                                           ! Debug: list unsigned long lba_low = [S+$20-6] (used reg = )
21304 5CD1           FF76         FE            push	-2[bp]
21305 5CD4           FF76         FC            push	-4[bp]
21306                                           ! Debug: func () void = _write_dword+0 (used reg = )
21307 5CD7           E8         A38D            call	__write_dword
21308 5CDA           83C4                   08  add	sp,*8
21309                                           !BCC_EOS
21310                                           ! 3814     _write_dword(lba_high, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, DS)
21311                                           ! 3814 ;
21312                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21313 5CDD           FF76         04            push	4[bp]
21314                                           ! Debug: add unsigned short = const $14 to unsigned short SI = [S+$1E+4] (used reg = )
21315 5CE0           8B46         06            mov	ax,6[bp]
21316                                           ! Debug: list unsigned int = ax+$14 (used reg = )
21317 5CE3           05                   0014  add	ax,*$14
21318 5CE6           50                         push	ax
21319                                           ! Debug: list unsigned long lba_high = [S+$20-$A] (used reg = )
21320 5CE7           FF76         FA            push	-6[bp]
21321 5CEA           FF76         F8            push	-8[bp]
21322                                           ! Debug: func () void = _write_dword+0 (used reg = )
21323 5CED           E8         A377            call	__write_dword
21324 5CF0           83C4                   08  add	sp,*8
21325                                           !BCC_EOS
21326                                           ! 3815     _write_word(blksize, SI+(Bit16u)&((dpt_t *) 0)->blksize, DS);
21327                                           ! Debug: list unsigned short DS = [S+$1C+2] (used reg = )
21328 5CF3           FF76         04            push	4[bp]
21329                                           ! Debug: add unsigned short = const $18 to unsigned short SI = [S+$1E+4] (used reg = )
21330 5CF6           8B46         06            mov	ax,6[bp]
21331                                           ! Debug: list unsigned int = ax+$18 (used reg = )
21332 5CF9           05                   0018  add	ax,*$18
21333 5CFC           50                         push	ax
21334                                           ! Debug: list unsigned short blksize = [S+$20-$1A] (used reg = )
21335 5CFD           FF76         E8            push	-$18[bp]
21336                                           ! Debug: func () void = _write_word+0 (used reg = )
21337 5D00           E8         A910            call	__write_word
21338 5D03           83C4                   06  add	sp,*6
21339                                           !BCC_EOS
21340                                           ! 3816   }
21341 5D06           83C4                   04  add	sp,*4
21342                                           ! 3817   if(size >= 30) {
21343                       00005D09            .510:
21344                                           ! Debug: ge int = const $1E to unsigned short size = [S+$18-$12] (used reg = )
21345 5D09           8B46         F0            mov	ax,-$10[bp]
21346 5D0C           3D                   001E  cmp	ax,*$1E
21347 5D0F         0F82         01BC            blo 	.51D
21348                       00005D13            .51E:
21349                                           ! 3818     Bit8u channel, dev, irq, mode, checksum, i, translation;
21350                                           !BCC_EOS
21351                                           ! 3819     Bit16u iobase1, iobase2, options;
21352                                           !BCC_EOS
21353                                           ! 3820     _write_word(30, SI+(Bit16u)&((dpt_t *) 0)->size, DS);
21354 5D13           83C4                   F2  add	sp,*-$E
21355                                           ! Debug: list unsigned short DS = [S+$26+2] (used reg = )
21356 5D16           FF76         04            push	4[bp]
21357                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$28+4] (used reg = )
21358 5D19           8B46         06            mov	ax,6[bp]
21359                                           ! Debug: list unsigned int = ax+0 (used reg = )
21360 5D1C           50                         push	ax
21361                                           ! Debug: list int = const $1E (used reg = )
21362 5D1D           B8                   001E  mov	ax,*$1E
21363 5D20           50                         push	ax
21364                                           ! Debug: func () void = _write_word+0 (used reg = )
21365 5D21           E8         A8EF            call	__write_word
21366 5D24           83C4                   06  add	sp,*6
21367                                           !BCC_EOS
21368                                           ! 3821     _write_word(ebda_seg, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, DS);
21369                                           ! Debug: list unsigned short DS = [S+$26+2] (used reg = )
21370 5D27           FF76         04            push	4[bp]
21371                                           ! Debug: add unsigned short = const $1C to unsigned short SI = [S+$28+4] (used reg = )
21372 5D2A           8B46         06            mov	ax,6[bp]
21373                                           ! Debug: list unsigned int = ax+$1C (used reg = )
21374 5D2D           05                   001C  add	ax,*$1C
21375 5D30           50                         push	ax
21376                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$16] (used reg = )
21377 5D31           FF76         EC            push	-$14[bp]
21378                                           ! Debug: func () void = _write_word+0 (used reg = )
21379 5D34           E8         A8DC            call	__write_word
21380 5D37           83C4                   06  add	sp,*6
21381                                           !BCC_EOS
21382                                           ! 3822     _write_word(&((ebda_data_t *) 0)->ata.dpte, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, DS);
21383                                           ! Debug: list unsigned short DS = [S+$26+2] (used reg = )
21384 5D3A           FF76         04            push	4[bp]
21385                                           ! Debug: add unsigned short = const $1A to unsigned short SI = [S+$28+4] (used reg = )
21386 5D3D           8B46         06            mov	ax,6[bp]
21387                                           ! Debug: list unsigned int = ax+$1A (used reg = )
21388 5D40           05                   001A  add	ax,*$1A
21389 5D43           50                         push	ax
21390                                           ! Debug: list * struct  = const $244 (used reg = )
21391 5D44           B8                   0244  mov	ax,#$244
21392 5D47           50                         push	ax
21393                                           ! Debug: func () void = _write_word+0 (used reg = )
21394 5D48           E8         A8C8            call	__write_word
21395 5D4B           83C4                   06  add	sp,*6
21396                                           !BCC_EOS
21397                                           ! 3823     channel = device / 2;
21398                                           ! Debug: div int = const 2 to unsigned char device = [S+$26+6] (used reg = )
21399 5D4E           8A46         08            mov	al,8[bp]
21400 5D51           30E4                       xor	ah,ah
21401 5D53           D1E8                       shr	ax,*1
21402                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$26-$19] (used reg = )
21403 5D55           8846         E9            mov	-$17[bp],al
21404                                           !BCC_EOS
21405                                           ! 3824     iobase1 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1));
21406                                           ! Debug: ptradd unsigned char channel = [S+$26-$19] to [4] struct  = const $122 (used reg = )
21407 5D58           8A46         E9            mov	al,-$17[bp]
21408 5D5B           30E4                       xor	ah,ah
21409 5D5D           B1                     03  mov	cl,*3
21410 5D5F           D3E0                       shl	ax,cl
21411 5D61           89C3                       mov	bx,ax
21412                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
21413                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
21414                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$26-$22] (used reg = )
21415 5D63           8B9F       0124            mov	bx,$124[bx]
21416 5D67           895E         E0            mov	-$20[bp],bx
21417                                           !BCC_EOS
21418                                           ! 3825     iobase2 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase2));
21419                                           ! Debug: ptradd unsigned char channel = [S+$26-$19] to [4] struct  = const $122 (used reg = )
21420 5D6A           8A46         E9            mov	al,-$17[bp]
21421 5D6D           30E4                       xor	ah,ah
21422 5D6F           B1                     03  mov	cl,*3
21423 5D71           D3E0                       shl	ax,cl
21424 5D73           89C3                       mov	bx,ax
21425                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
21426                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$126 (used reg = )
21427                                           ! Debug: eq unsigned short = [bx+$126] to unsigned short iobase2 = [S+$26-$24] (used reg = )
21428 5D75           8B9F       0126            mov	bx,$126[bx]
21429 5D79           895E         DE            mov	-$22[bp],bx
21430                                           !BCC_EOS
21431                                           ! 3826     irq = *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[channel].irq));
21432                                           ! Debug: ptradd unsigned char channel = [S+$26-$19] to [4] struct  = const $122 (used reg = )
21433 5D7C           8A46         E9            mov	al,-$17[bp]
21434 5D7F           30E4                       xor	ah,ah
21435 5D81           B1                     03  mov	cl,*3
21436 5D83           D3E0                       shl	ax,cl
21437 5D85           89C3                       mov	bx,ax
21438                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
21439                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$128 (used reg = )
21440                                           ! Debug: eq unsigned char = [bx+$128] to unsigned char irq = [S+$26-$1B] (used reg = )
21441 5D87           8A87       0128            mov	al,$128[bx]
21442 5D8B           8846         E7            mov	-$19[bp],al
21443                                           !BCC_EOS
21444                                           ! 3827     mode = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].mode));
21445                                           ! Debug: ptradd unsigned char device = [S+$26+6] to [8] struct  = const $142 (used reg = )
21446 5D8E           8A46         08            mov	al,8[bp]
21447 5D91           30E4                       xor	ah,ah
21448 5D93           B9                   001E  mov	cx,*$1E
21449 5D96           F7E9                       imul	cx
21450 5D98           89C3                       mov	bx,ax
21451                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
21452                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$146 (used reg = )
21453                                           ! Debug: eq unsigned char = [bx+$146] to unsigned char mode = [S+$26-$1C] (used reg = )
21454 5D9A           8A87       0146            mov	al,$146[bx]
21455 5D9E           8846         E6            mov	-$1A[bp],al
21456                                           !BCC_EOS
21457                                           ! 3828     translation = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].translation));
21458                                           ! Debug: ptradd unsigned char device = [S+$26+6] to [8] struct  = const $142 (used reg = )
21459 5DA1           8A46         08            mov	al,8[bp]
21460 5DA4           30E4                       xor	ah,ah
21461 5DA6           B9                   001E  mov	cx,*$1E
21462 5DA9           F7E9                       imul	cx
21463 5DAB           89C3                       mov	bx,ax
21464                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
21465                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$14A (used reg = )
21466                                           ! Debug: eq unsigned char = [bx+$14A] to unsigned char translation = [S+$26-$1F] (used reg = )
21467 5DAD           8A87       014A            mov	al,$14A[bx]
21468 5DB1           8846         E3            mov	-$1D[bp],al
21469                                           !BCC_EOS
21470                                           ! 3829     options = (1<<4);
21471                                           ! Debug: eq int = const $10 to unsigned short options = [S+$26-$26] (used reg = )
21472 5DB4           B8                   0010  mov	ax,*$10
21473 5DB7           8946         DC            mov	-$24[bp],ax
21474                                           !BCC_EOS
21475                                           ! 3830     options |= (mode==0x01?1:0)<<7;
21476                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$26-$1C] (used reg = )
21477 5DBA           8A46         E6            mov	al,-$1A[bp]
21478 5DBD           3C                     01  cmp	al,*1
21479 5DBF           75           04            jne 	.51F
21480                       00005DC1            .520:
21481 5DC1           B0                     01  mov	al,*1
21482 5DC3           EB           02            jmp .521
21483                       00005DC5            .51F:
21484 5DC5           30C0                       xor	al,al
21485                       00005DC7            .521:
21486                                           ! Debug: sl int = const 7 to char = al+0 (used reg = )
21487 5DC7           30E4                       xor	ah,ah
21488 5DC9           B1                     07  mov	cl,*7
21489 5DCB           D3E0                       shl	ax,cl
21490                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$26-$26] (used reg = )
21491 5DCD           0B46         DC            or	ax,-$24[bp]
21492 5DD0           8946         DC            mov	-$24[bp],ax
21493                                           !BCC_EOS
21494                                           ! 3831     if (type == 0x02)
21495                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$26-$17] (used reg = )
21496 5DD3           8A46         EB            mov	al,-$15[bp]
21497 5DD6           3C                     02  cmp	al,*2
21498 5DD8           75           4F            jne 	.522
21499                       00005DDA            .523:
21500                                           ! 3832     {
21501                                           ! 3833       options |= (translation==0?0:1)<<3;
21502                                           ! Debug: logeq int = const 0 to unsigned char translation = [S+$26-$1F] (used reg = )
21503 5DDA           8A46         E3            mov	al,-$1D[bp]
21504 5DDD           84C0                       test	al,al
21505 5DDF           75           04            jne 	.524
21506                       00005DE1            .525:
21507 5DE1           30C0                       xor	al,al
21508 5DE3           EB           02            jmp .526
21509                       00005DE5            .524:
21510 5DE5           B0                     01  mov	al,*1
21511                       00005DE7            .526:
21512                                           ! Debug: sl int = const 3 to char = al+0 (used reg = )
21513 5DE7           30E4                       xor	ah,ah
21514 5DE9           B1                     03  mov	cl,*3
21515 5DEB           D3E0                       shl	ax,cl
21516                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$26-$26] (used reg = )
21517 5DED           0B46         DC            or	ax,-$24[bp]
21518 5DF0           8946         DC            mov	-$24[bp],ax
21519                                           !BCC_EOS
21520                                           ! 3834       options |= (translation==1?1:0)<<9;
21521                                           ! Debug: logeq int = const 1 to unsigned char translation = [S+$26-$1F] (used reg = )
21522 5DF3           8A46         E3            mov	al,-$1D[bp]
21523 5DF6           3C                     01  cmp	al,*1
21524 5DF8           75           04            jne 	.527
21525                       00005DFA            .528:
21526 5DFA           B0                     01  mov	al,*1
21527 5DFC           EB           02            jmp .529
21528                       00005DFE            .527:
21529 5DFE           30C0                       xor	al,al
21530                       00005E00            .529:
21531                                           ! Debug: sl int = const 9 to char = al+0 (used reg = )
21532 5E00           30E4                       xor	ah,ah
21533 5E02           88C4                       mov	ah,al
21534 5E04           30C0                       xor	al,al
21535 5E06           D1E0                       shl	ax,*1
21536                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$26-$26] (used reg = )
21537 5E08           0B46         DC            or	ax,-$24[bp]
21538 5E0B           8946         DC            mov	-$24[bp],ax
21539                                           !BCC_EOS
21540                                           ! 3835       options |= (translation==3?3:0)<<9;
21541                                           ! Debug: logeq int = const 3 to unsigned char translation = [S+$26-$1F] (used reg = )
21542 5E0E           8A46         E3            mov	al,-$1D[bp]
21543 5E11           3C                     03  cmp	al,*3
21544 5E13           75           04            jne 	.52A
21545                       00005E15            .52B:
21546 5E15           B0                     03  mov	al,*3
21547 5E17           EB           02            jmp .52C
21548                       00005E19            .52A:
21549 5E19           30C0                       xor	al,al
21550                       00005E1B            .52C:
21551                                           ! Debug: sl int = const 9 to char = al+0 (used reg = )
21552 5E1B           30E4                       xor	ah,ah
21553 5E1D           88C4                       mov	ah,al
21554 5E1F           30C0                       xor	al,al
21555 5E21           D1E0                       shl	ax,*1
21556                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$26-$26] (used reg = )
21557 5E23           0B46         DC            or	ax,-$24[bp]
21558 5E26           8946         DC            mov	-$24[bp],ax
21559                                           !BCC_EOS
21560                                           ! 3836     }
21561                                           ! 3837     if (type == 0x03)
21562                       00005E29            .522:
21563                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$26-$17] (used reg = )
21564 5E29           8A46         EB            mov	al,-$15[bp]
21565 5E2C           3C                     03  cmp	al,*3
21566 5E2E           75           10            jne 	.52D
21567                       00005E30            .52E:
21568                                           ! 3838     {
21569                                           ! 3839       options |= (1<<5);
21570                                           ! Debug: orab int = const $20 to unsigned short options = [S+$26-$26] (used reg = )
21571 5E30           8B46         DC            mov	ax,-$24[bp]
21572 5E33           0C                     20  or	al,*$20
21573 5E35           8946         DC            mov	-$24[bp],ax
21574                                           !BCC_EOS
21575                                           ! 3840       options |= (1<<6);
21576                                           ! Debug: orab int = const $40 to unsigned short options = [S+$26-$26] (used reg = )
21577 5E38           8B46         DC            mov	ax,-$24[bp]
21578 5E3B           0C                     40  or	al,*$40
21579 5E3D           8946         DC            mov	-$24[bp],ax
21580                                           !BCC_EOS
21581                                           ! 3841     }
21582                                           ! 3842     *((Bit16u *)(&((ebda_data_t *) 0)->ata.dpte.iobase1)) = (iobase1);
21583                       00005E40            .52D:
21584                                           ! Debug: eq unsigned short iobase1 = [S+$26-$22] to unsigned short = [+$244] (used reg = )
21585 5E40           8B46         E0            mov	ax,-$20[bp]
21586 5E43           A3         0244            mov	[$244],ax
21587                                           !BCC_EOS
21588                                           ! 3843     *((Bit16u *)(&((ebda_data_t *) 0)->ata.dpte.iobase2)) = (iobase2 + 6);
21589                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$26-$24] (used reg = )
21590 5E46           8B46         DE            mov	ax,-$22[bp]
21591                                           ! Debug: eq unsigned int = ax+6 to unsigned short = [+$246] (used reg = )
21592 5E49           05                   0006  add	ax,*6
21593 5E4C           A3         0246            mov	[$246],ax
21594                                           !BCC_EOS
21595                                           ! 3844     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.prefix)) = ((0xe | (device % 2))<<4);
21596                                           ! Debug: mod int = const 2 to unsigned char device = [S+$26+6] (used reg = )
21597 5E4F           8A46         08            mov	al,8[bp]
21598 5E52           30E4                       xor	ah,ah
21599 5E54           24                     01  and	al,*1
21600                                           ! Debug: or unsigned char = al+0 to int = const $E (used reg = )
21601                                           ! Debug: expression subtree swapping
21602 5E56           0C                     0E  or	al,*$E
21603                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
21604 5E58           30E4                       xor	ah,ah
21605 5E5A           B1                     04  mov	cl,*4
21606 5E5C           D3E0                       shl	ax,cl
21607                                           ! Debug: eq unsigned int = ax+0 to unsigned char = [+$248] (used reg = )
21608 5E5E           A2         0248            mov	[$248],al
21609                                           !BCC_EOS
21610                                           ! 3845     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.unused)) = (0xcb);
21611                                           ! Debug: eq int = const $CB to unsigned char = [+$249] (used reg = )
21612 5E61           B0                     CB  mov	al,#$CB
21613 5E63           A2         0249            mov	[$249],al
21614                                           !BCC_EOS
21615                                           ! 3846     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.irq)) = (irq);
21616                                           ! Debug: eq unsigned char irq = [S+$26-$1B] to unsigned char = [+$24A] (used reg = )
21617 5E66           8A46         E7            mov	al,-$19[bp]
21618 5E69           A2         024A            mov	[$24A],al
21619                                           !BCC_EOS
21620                                           ! 3847     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.blkcount)) = (1);
21621                                           ! Debug: eq int = const 1 to unsigned char = [+$24B] (used reg = )
21622 5E6C           B0                     01  mov	al,*1
21623 5E6E           A2         024B            mov	[$24B],al
21624                                           !BCC_EOS
21625                                           ! 3848     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.dma)) = (0);
21626                                           ! Debug: eq int = const 0 to unsigned char = [+$24C] (used reg = )
21627 5E71           30C0                       xor	al,al
21628 5E73           A2         024C            mov	[$24C],al
21629                                           !BCC_EOS
21630                                           ! 3849     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.pio)) = (0);
21631                                           ! Debug: eq int = const 0 to unsigned char = [+$24D] (used reg = )
21632 5E76           30C0                       xor	al,al
21633 5E78           A2         024D            mov	[$24D],al
21634                                           !BCC_EOS
21635                                           ! 3850     *((Bit16u *)(&((ebda_data_t *) 0)->ata.dpte.options)) = (options);
21636                                           ! Debug: eq unsigned short options = [S+$26-$26] to unsigned short = [+$24E] (used reg = )
21637 5E7B           8B46         DC            mov	ax,-$24[bp]
21638 5E7E           A3         024E            mov	[$24E],ax
21639                                           !BCC_EOS
21640                                           ! 3851     *((Bit16u *)(&((ebda_data_t *) 0)->ata.dpte.reserved)) = (0);
21641                                           ! Debug: eq int = const 0 to unsigned short = [+$250] (used reg = )
21642 5E81           31C0                       xor	ax,ax
21643 5E83           A3         0250            mov	[$250],ax
21644                                           !BCC_EOS
21645                                           ! 3852     *((Bit8u *)(&((ebda_data_t *) 0)->ata.dpte.revision)) = (0x11);
21646                                           ! Debug: eq int = const $11 to unsigned char = [+$252] (used reg = )
21647 5E86           B0                     11  mov	al,*$11
21648 5E88           A2         0252            mov	[$252],al
21649                                           !BCC_EOS
21650                                           ! 3853     checksum=0;
21651                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$26-$1D] (used reg = )
21652 5E8B           30C0                       xor	al,al
21653 5E8D           8846         E5            mov	-$1B[bp],al
21654                                           !BCC_EOS
21655                                           ! 3854     for (i=0; i<15; i++) checksum+=*((Bit8u *)(((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i));
21656                                           ! Debug: eq int = const 0 to unsigned char i = [S+$26-$1E] (used reg = )
21657 5E90           30C0                       xor	al,al
21658 5E92           8846         E4            mov	-$1C[bp],al
21659                                           !BCC_EOS
21660                                           !BCC_EOS
21661 5E95           EB           1D            jmp .531
21662                       00005E97            .532:
21663                                           ! Debug: ptradd unsigned char i = [S+$26-$1E] to * unsigned char = const $244 (used reg = )
21664 5E97           8A46         E4            mov	al,-$1C[bp]
21665 5E9A           30E4                       xor	ah,ah
21666                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = ax+$244 (used reg = )
21667 5E9C           89C3                       mov	bx,ax
21668                                           ! Debug: addab unsigned char = [bx+$244] to unsigned char checksum = [S+$26-$1D] (used reg = )
21669 5E9E           8A46         E5            mov	al,-$1B[bp]
21670 5EA1           30E4                       xor	ah,ah
21671 5EA3           0287       0244            add	al,$244[bx]
21672 5EA7           80D4                   00  adc	ah,*0
21673 5EAA           8846         E5            mov	-$1B[bp],al
21674                                           !BCC_EOS
21675                                           ! 3855     checksum = -checksum;
21676                       00005EAD            .530:
21677                                           ! Debug: postinc unsigned char i = [S+$26-$1E] (used reg = )
21678 5EAD           8A46         E4            mov	al,-$1C[bp]
21679 5EB0           40                         inc	ax
21680 5EB1           8846         E4            mov	-$1C[bp],al
21681                       00005EB4            .531:
21682                                           ! Debug: lt int = const $F to unsigned char i = [S+$26-$1E] (used reg = )
21683 5EB4           8A46         E4            mov	al,-$1C[bp]
21684 5EB7           3C                     0F  cmp	al,*$F
21685 5EB9           72           DC            jb 	.532
21686                       00005EBB            .533:
21687                       00005EBB            .52F:
21688                                           ! Debug: neg unsigned char checksum = [S+$26-$1D] (used reg = )
21689 5EBB           31C0                       xor	ax,ax
21690 5EBD           2A46         E5            sub	al,-$1B[bp]
21691 5EC0           80DC                   00  sbb	ah,*0
21692                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$26-$1D] (used reg = )
21693 5EC3           8846         E5            mov	-$1B[bp],al
21694                                           !BCC_EOS
21695                                           ! 3856     *((Bit8u *)(&((ebd
21696                                           ! 3856 a_data_t *) 0)->ata.dpte.checksum)) = (checksum);
21697                                           ! Debug: eq unsigned char checksum = [S+$26-$1D] to unsigned char = [+$253] (used reg = )
21698 5EC6           8A46         E5            mov	al,-$1B[bp]
21699 5EC9           A2         0253            mov	[$253],al
21700                                           !BCC_EOS
21701                                           ! 3857   }
21702 5ECC           83C4                   0E  add	sp,*$E
21703                                           ! 3858   if(size >= 66) {
21704                       00005ECF            .51D:
21705                                           ! Debug: ge int = const $42 to unsigned short size = [S+$18-$12] (used reg = )
21706 5ECF           8B46         F0            mov	ax,-$10[bp]
21707 5ED2           3D                   0042  cmp	ax,*$42
21708 5ED5         0F82         0267            blo 	.534
21709                       00005ED9            .535:
21710                                           ! 3859     Bit8u channel, iface, checksum, i;
21711                                           !BCC_EOS
21712                                           ! 3860     Bit16u iobase1;
21713                                           !BCC_EOS
21714                                           ! 3861     channel = device / 2;
21715 5ED9           83C4                   FA  add	sp,*-6
21716                                           ! Debug: div int = const 2 to unsigned char device = [S+$1E+6] (used reg = )
21717 5EDC           8A46         08            mov	al,8[bp]
21718 5EDF           30E4                       xor	ah,ah
21719 5EE1           D1E8                       shr	ax,*1
21720                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$1E-$19] (used reg = )
21721 5EE3           8846         E9            mov	-$17[bp],al
21722                                           !BCC_EOS
21723                                           ! 3862     iface = *((Bit8u *)(&((ebda_data_t *) 0)->ata.channels[channel].iface));
21724                                           ! Debug: ptradd unsigned char channel = [S+$1E-$19] to [4] struct  = const $122 (used reg = )
21725 5EE6           8A46         E9            mov	al,-$17[bp]
21726 5EE9           30E4                       xor	ah,ah
21727 5EEB           B1                     03  mov	cl,*3
21728 5EED           D3E0                       shl	ax,cl
21729 5EEF           89C3                       mov	bx,ax
21730                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
21731                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$122 (used reg = )
21732                                           ! Debug: eq unsigned char = [bx+$122] to unsigned char iface = [S+$1E-$1A] (used reg = )
21733 5EF1           8A87       0122            mov	al,$122[bx]
21734 5EF5           8846         E8            mov	-$18[bp],al
21735                                           !BCC_EOS
21736                                           ! 3863     iobase1 = *((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[channel].iobase1));
21737                                           ! Debug: ptradd unsigned char channel = [S+$1E-$19] to [4] struct  = const $122 (used reg = )
21738 5EF8           8A46         E9            mov	al,-$17[bp]
21739 5EFB           30E4                       xor	ah,ah
21740 5EFD           B1                     03  mov	cl,*3
21741 5EFF           D3E0                       shl	ax,cl
21742 5F01           89C3                       mov	bx,ax
21743                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
21744                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
21745                                           ! Debug: eq unsigned short = [bx+$124] to unsigned short iobase1 = [S+$1E-$1E] (used reg = )
21746 5F03           8B9F       0124            mov	bx,$124[bx]
21747 5F07           895E         E4            mov	-$1C[bp],bx
21748                                           !BCC_EOS
21749                                           ! 3864     set_DS(DS);
21750                                           ! Debug: list unsigned short DS = [S+$1E+2] (used reg = )
21751 5F0A           FF76         04            push	4[bp]
21752                                           ! Debug: func () unsigned short = set_DS+0 (used reg = )
21753 5F0D           E8         A752            call	_set_DS
21754 5F10           44                         inc	sp
21755 5F11           44                         inc	sp
21756                                           !BCC_EOS
21757                                           ! 3865     *((Bit16u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.key)) = (0xbedd);
21758                                           ! Debug: add unsigned short = const $1E to unsigned short SI = [S+$1E+4] (used reg = )
21759 5F12           8B46         06            mov	ax,6[bp]
21760                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$1E (used reg = )
21761 5F15           89C3                       mov	bx,ax
21762                                           ! Debug: eq unsigned int = const $BEDD to unsigned short = [bx+$1E] (used reg = )
21763 5F17           B8                   BEDD  mov	ax,#$BEDD
21764 5F1A           8947         1E            mov	$1E[bx],ax
21765                                           !BCC_EOS
21766                                           ! 3866     *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.dpi_length)) = (t13 ? 44 : 36);
21767 5F1D           8B46         EE            mov	ax,-$12[bp]
21768 5F20           85C0                       test	ax,ax
21769 5F22           74           04            je  	.536
21770                       00005F24            .537:
21771 5F24           B0                     2C  mov	al,*$2C
21772 5F26           EB           02            jmp .538
21773                       00005F28            .536:
21774 5F28           B0                     24  mov	al,*$24
21775                       00005F2A            .538:
21776 5F2A           50                         push	ax
21777                                           ! Debug: add unsigned short = const $20 to unsigned short SI = [S+$20+4] (used reg = )
21778 5F2B           8B46         06            mov	ax,6[bp]
21779                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$20 (used reg = )
21780 5F2E           89C3                       mov	bx,ax
21781                                           ! Debug: eq char (temp) = [S+$20-$20] to unsigned char = [bx+$20] (used reg = )
21782 5F30           8A46         E2            mov	al,-$1E[bp]
21783 5F33           8847         20            mov	$20[bx],al
21784 5F36           44                         inc	sp
21785 5F37           44                         inc	sp
21786                                           !BCC_EOS
21787                                           ! 3867     *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.reserved1)) = (0);
21788                                           ! Debug: add unsigned short = const $21 to unsigned short SI = [S+$1E+4] (used reg = )
21789 5F38           8B46         06            mov	ax,6[bp]
21790                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$21 (used reg = )
21791 5F3B           89C3                       mov	bx,ax
21792                                           ! Debug: eq int = const 0 to unsigned char = [bx+$21] (used reg = )
21793 5F3D           30C0                       xor	al,al
21794 5F3F           8847         21            mov	$21[bx],al
21795                                           !BCC_EOS
21796                                           ! 3868     *((Bit16u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.reserved2)) = (0);
21797                                           ! Debug: add unsigned short = const $22 to unsigned short SI = [S+$1E+4] (used reg = )
21798 5F42           8B46         06            mov	ax,6[bp]
21799                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$22 (used reg = )
21800 5F45           89C3                       mov	bx,ax
21801                                           ! Debug: eq int = const 0 to unsigned short = [bx+$22] (used reg = )
21802 5F47           31C0                       xor	ax,ax
21803 5F49           8947         22            mov	$22[bx],ax
21804                                           !BCC_EOS
21805                                           ! 3869     if (iface==0x00) {
21806                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$1E-$1A] (used reg = )
21807 5F4C           8A46         E8            mov	al,-$18[bp]
21808 5F4F           84C0                       test	al,al
21809 5F51           75           2A            jne 	.539
21810                       00005F53            .53A:
21811                                           ! 3870       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.host_bus[0])) = ('I');
21812                                           ! Debug: add unsigned short = const $24 to unsigned short SI = [S+$1E+4] (used reg = )
21813 5F53           8B46         06            mov	ax,6[bp]
21814                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$24 (used reg = )
21815 5F56           89C3                       mov	bx,ax
21816                                           ! Debug: eq int = const $49 to unsigned char = [bx+$24] (used reg = )
21817 5F58           B0                     49  mov	al,*$49
21818 5F5A           8847         24            mov	$24[bx],al
21819                                           !BCC_EOS
21820                                           ! 3871       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.host_bus[1])) = ('S');
21821                                           ! Debug: add unsigned short = const $25 to unsigned short SI = [S+$1E+4] (used reg = )
21822 5F5D           8B46         06            mov	ax,6[bp]
21823                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$25 (used reg = )
21824 5F60           89C3                       mov	bx,ax
21825                                           ! Debug: eq int = const $53 to unsigned char = [bx+$25] (used reg = )
21826 5F62           B0                     53  mov	al,*$53
21827 5F64           8847         25            mov	$25[bx],al
21828                                           !BCC_EOS
21829                                           ! 3872       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.host_bus[2])) = ('A');
21830                                           ! Debug: add unsigned short = const $26 to unsigned short SI = [S+$1E+4] (used reg = )
21831 5F67           8B46         06            mov	ax,6[bp]
21832                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$26 (used reg = )
21833 5F6A           89C3                       mov	bx,ax
21834                                           ! Debug: eq int = const $41 to unsigned char = [bx+$26] (used reg = )
21835 5F6C           B0                     41  mov	al,*$41
21836 5F6E           8847         26            mov	$26[bx],al
21837                                           !BCC_EOS
21838                                           ! 3873       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.host_bus[3])) = (' ');
21839                                           ! Debug: add unsigned short = const $27 to unsigned short SI = [S+$1E+4] (used reg = )
21840 5F71           8B46         06            mov	ax,6[bp]
21841                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$27 (used reg = )
21842 5F74           89C3                       mov	bx,ax
21843                                           ! Debug: eq int = const $20 to unsigned char = [bx+$27] (used reg = )
21844 5F76           B0                     20  mov	al,*$20
21845 5F78           8847         27            mov	$27[bx],al
21846                                           !BCC_EOS
21847                                           ! 3874     }
21848                                           ! 3875     else {
21849 5F7B           EB           00            jmp .53B
21850                       00005F7D            .539:
21851                                           ! 3876     }
21852                                           ! 3877     if (type == 0x02) {
21853                       00005F7D            .53B:
21854                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$1E-$17] (used reg = )
21855 5F7D           8A46         EB            mov	al,-$15[bp]
21856 5F80           3C                     02  cmp	al,*2
21857 5F82         0F85         0052            bne 	.53C
21858                       00005F86            .53D:
21859                                           ! 3878         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[0])) = ('A');
21860                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$1E+4] (used reg = )
21861 5F86           8B46         06            mov	ax,6[bp]
21862                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$28 (used reg = )
21863 5F89           89C3                       mov	bx,ax
21864                                           ! Debug: eq int = const $41 to unsigned char = [bx+$28] (used reg = )
21865 5F8B           B0                     41  mov	al,*$41
21866 5F8D           8847         28            mov	$28[bx],al
21867                                           !BCC_EOS
21868                                           ! 3879         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[1])) = ('T');
21869                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$1E+4] (used reg = )
21870 5F90           8B46         06            mov	ax,6[bp]
21871                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$29 (used reg = )
21872 5F93           89C3                       mov	bx,ax
21873                                           ! Debug: eq int = const $54 to unsigned char = [bx+$29] (used reg = )
21874 5F95           B0                     54  mov	al,*$54
21875 5F97           8847         29            mov	$29[bx],al
21876                                           !BCC_EOS
21877                                           ! 3880         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[2])) = ('A');
21878                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$1E+4] (used reg = )
21879 5F9A           8B46         06            mov	ax,6[bp]
21880                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2A (used reg = )
21881 5F9D           89C3                       mov	bx,ax
21882                                           ! Debug: eq int = const $41 to unsigned char = [bx+$2A] (used reg = )
21883 5F9F           B0                     41  mov	al,*$41
21884 5FA1           8847         2A            mov	$2A[bx],al
21885                                           !BCC_EOS
21886                                           ! 3881         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[3])) = (' ');
21887                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$1E+4] (used reg = )
21888 5FA4           8B46         06            mov	ax,6[bp]
21889                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2B (used reg = )
21890 5FA7           89C3                       mov	bx,ax
21891                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2B] (used reg = )
21892 5FA9           B0                     20  mov	al,*$20
21893 5FAB           8847         2B            mov	$2B[bx],al
21894                                           !BCC_EOS
21895                                           ! 3882         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[4])) = (' ');
21896                                           ! Debug: add unsigned short = const $2C to unsigned short SI = [S+$1E+4] (used reg = )
21897 5FAE           8B46         06            mov	ax,6[bp]
21898                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2C (used reg = )
21899 5FB1           89C3                       mov	bx,ax
21900                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2C] (used reg = )
21901 5FB3           B0                     20  mov	al,*$20
21902 5FB5           8847         2C            mov	$2C[bx],al
21903                                           !BCC_EOS
21904                                           ! 3883         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[5])) = (' ');
21905                                           ! Debug: add unsigned short = const $2D to unsigned short SI = [S+$1E+4] (used reg = )
21906 5FB8           8B46         06            mov	ax,6[bp]
21907                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2D (used reg = )
21908 5FBB           89C3                       mov	bx,ax
21909                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2D] (used reg = )
21910 5FBD           B0                     20  mov	al,*$20
21911 5FBF           8847         2D            mov	$2D[bx],al
21912                                           !BCC_EOS
21913                                           ! 3884         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[6])) = (' ');
21914                                           ! Debug: add unsigned short = const $2E to unsigned short SI = [S+$1E+4] (used reg = )
21915 5FC2           8B46         06            mov	ax,6[bp]
21916                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2E (used reg = )
21917 5FC5           89C3                       mov	bx,ax
21918                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2E] (used reg = )
21919 5FC7           B0                     20  mov	al,*$20
21920 5FC9           8847         2E            mov	$2E[bx],al
21921                                           !BCC_EOS
21922                                           ! 3885         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[7])) = (' ');
21923                                           ! Debug: add unsigned short = const $2F to unsigned short SI = [S+$1E+4] (used reg = )
21924 5FCC           8B46         06            mov	ax,6[bp]
21925                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2F (used reg = )
21926 5FCF           89C3                       mov	bx,ax
21927                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2F] (used reg = )
21928 5FD1           B0                     20  mov	al,*$20
21929 5FD3           8847         2F            mov	$2F[bx],al
21930                                           !BCC_EOS
21931                                           ! 3886     } else if (type == 0x03) {
21932 5FD6           EB           57            jmp .53E
21933                       00005FD8            .53C:
21934                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$1E-$17] (used reg = )
21935 5FD8           8A46         EB            mov	al,-$15[bp]
21936 5FDB           3C                     03  cmp	al,*3
21937 5FDD           75           50            jne 	.53F
21938                       00005FDF            .540:
21939                                           ! 3887         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[0])) = ('A');
21940                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$1E+4] (used reg = )
21941 5FDF           8B46         06            mov	ax,6[bp]
21942                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$28 (used reg = )
21943 5FE2           89C3                       mov	bx,ax
21944                                           ! Debug: eq int = const $41 to unsigned char = [bx+$28] (used reg = )
21945 5FE4           B0                     41  mov	al,*$41
21946 5FE6           8847         28            mov	$28[bx],al
21947                                           !BCC_EOS
21948                                           ! 3888         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[1])) = ('T');
21949                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$1E+4] (used reg = )
21950 5FE9           8B46         06            mov	ax,6[bp]
21951                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$29 (used reg = )
21952 5FEC           89C3                       mov	bx,ax
21953                                           ! Debug: eq int = const $54 to unsigned char = [bx+$29] (used reg = )
21954 5FEE           B0                     54  mov	al,*$54
21955 5FF0           8847         29            mov	$29[bx],al
21956                                           !BCC_EOS
21957                                           ! 3889         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[2])) = ('A');
21958                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$1E+4] (used reg = )
21959 5FF3           8B46         06            mov	ax,6[bp]
21960                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2A (used reg = )
21961 5FF6           89C3                       mov	bx,ax
21962                                           ! Debug: eq int = const $41 to unsigned char = [bx+$2A] (used reg = )
21963 5FF8           B0                     41  mov	al,*$41
21964 5FFA           8847         2A            mov	$2A[bx],al
21965                                           !BCC_EOS
21966                                           ! 3890         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[3])) = ('P');
21967                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$1E+4] (used reg = )
21968 5FFD           8B46         06            mov	ax,6[bp]
21969                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2B (used reg = )
21970 6000           89C3                       mov	bx,ax
21971                                           ! Debug: eq int = const $50 to unsigned char = [bx+$2B] (used reg = )
21972 6002           B0                     50  mov	al,*$50
21973 6004           8847         2B            mov	$2B[bx],al
21974                                           !BCC_EOS
21975                                           ! 3891         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.i
21976                                           ! 3891 face_type[4])) = ('I');
21977                                           ! Debug: add unsigned short = const $2C to unsigned short SI = [S+$1E+4] (used reg = )
21978 6007           8B46         06            mov	ax,6[bp]
21979                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2C (used reg = )
21980 600A           89C3                       mov	bx,ax
21981                                           ! Debug: eq int = const $49 to unsigned char = [bx+$2C] (used reg = )
21982 600C           B0                     49  mov	al,*$49
21983 600E           8847         2C            mov	$2C[bx],al
21984                                           !BCC_EOS
21985                                           ! 3892         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[5])) = (' ');
21986                                           ! Debug: add unsigned short = const $2D to unsigned short SI = [S+$1E+4] (used reg = )
21987 6011           8B46         06            mov	ax,6[bp]
21988                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2D (used reg = )
21989 6014           89C3                       mov	bx,ax
21990                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2D] (used reg = )
21991 6016           B0                     20  mov	al,*$20
21992 6018           8847         2D            mov	$2D[bx],al
21993                                           !BCC_EOS
21994                                           ! 3893         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[6])) = (' ');
21995                                           ! Debug: add unsigned short = const $2E to unsigned short SI = [S+$1E+4] (used reg = )
21996 601B           8B46         06            mov	ax,6[bp]
21997                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2E (used reg = )
21998 601E           89C3                       mov	bx,ax
21999                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2E] (used reg = )
22000 6020           B0                     20  mov	al,*$20
22001 6022           8847         2E            mov	$2E[bx],al
22002                                           !BCC_EOS
22003                                           ! 3894         *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_type[7])) = (' ');
22004                                           ! Debug: add unsigned short = const $2F to unsigned short SI = [S+$1E+4] (used reg = )
22005 6025           8B46         06            mov	ax,6[bp]
22006                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$2F (used reg = )
22007 6028           89C3                       mov	bx,ax
22008                                           ! Debug: eq int = const $20 to unsigned char = [bx+$2F] (used reg = )
22009 602A           B0                     20  mov	al,*$20
22010 602C           8847         2F            mov	$2F[bx],al
22011                                           !BCC_EOS
22012                                           ! 3895     }
22013                                           ! 3896     if (iface==0x00) {
22014                       0000602F            .53F:
22015                       0000602F            .53E:
22016                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$1E-$1A] (used reg = )
22017 602F           8A46         E8            mov	al,-$18[bp]
22018 6032           84C0                       test	al,al
22019 6034           75           26            jne 	.541
22020                       00006036            .542:
22021                                           ! 3897       *((Bit16u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_path[0])) = (iobase1);
22022                                           ! Debug: add unsigned short = const $30 to unsigned short SI = [S+$1E+4] (used reg = )
22023 6036           8B46         06            mov	ax,6[bp]
22024                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$30 (used reg = )
22025 6039           89C3                       mov	bx,ax
22026                                           ! Debug: eq unsigned short iobase1 = [S+$1E-$1E] to unsigned short = [bx+$30] (used reg = )
22027 603B           8B46         E4            mov	ax,-$1C[bp]
22028 603E           8947         30            mov	$30[bx],ax
22029                                           !BCC_EOS
22030                                           ! 3898       *((Bit16u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_path[2])) = (0);
22031                                           ! Debug: add unsigned short = const $32 to unsigned short SI = [S+$1E+4] (used reg = )
22032 6041           8B46         06            mov	ax,6[bp]
22033                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$32 (used reg = )
22034 6044           89C3                       mov	bx,ax
22035                                           ! Debug: eq int = const 0 to unsigned short = [bx+$32] (used reg = )
22036 6046           31C0                       xor	ax,ax
22037 6048           8947         32            mov	$32[bx],ax
22038                                           !BCC_EOS
22039                                           ! 3899       *((Bit32u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.iface_path[4])) = (0L);
22040                                           ! Debug: add unsigned short = const $34 to unsigned short SI = [S+$1E+4] (used reg = )
22041 604B           8B46         06            mov	ax,6[bp]
22042                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+$34 (used reg = )
22043 604E           89C3                       mov	bx,ax
22044                                           ! Debug: eq long = const 0 to unsigned long = [bx+$34] (used reg = )
22045 6050           31C0                       xor	ax,ax
22046 6052           31F6                       xor	si,si
22047 6054           8947         34            mov	$34[bx],ax
22048 6057           8977         36            mov	$36[bx],si
22049                                           !BCC_EOS
22050                                           ! 3900     }
22051                                           ! 3901     else {
22052 605A           EB           00            jmp .543
22053                       0000605C            .541:
22054                                           ! 3902     }
22055                                           ! 3903     *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[0])) = (device%2);
22056                       0000605C            .543:
22057                                           ! Debug: mod int = const 2 to unsigned char device = [S+$1E+6] (used reg = )
22058 605C           8A46         08            mov	al,8[bp]
22059 605F           30E4                       xor	ah,ah
22060 6061           24                     01  and	al,*1
22061 6063           50                         push	ax
22062                                           ! Debug: add unsigned short = const $38 to unsigned short SI = [S+$20+4] (used reg = )
22063 6064           8B46         06            mov	ax,6[bp]
22064                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$38 (used reg = )
22065 6067           89C3                       mov	bx,ax
22066                                           ! Debug: eq unsigned char (temp) = [S+$20-$20] to unsigned char = [bx+$38] (used reg = )
22067 6069           8A46         E2            mov	al,-$1E[bp]
22068 606C           8847         38            mov	$38[bx],al
22069 606F           44                         inc	sp
22070 6070           44                         inc	sp
22071                                           !BCC_EOS
22072                                           ! 3904     *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[1])) = (0);
22073                                           ! Debug: add unsigned short = const $39 to unsigned short SI = [S+$1E+4] (used reg = )
22074 6071           8B46         06            mov	ax,6[bp]
22075                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$39 (used reg = )
22076 6074           89C3                       mov	bx,ax
22077                                           ! Debug: eq int = const 0 to unsigned char = [bx+$39] (used reg = )
22078 6076           30C0                       xor	al,al
22079 6078           8847         39            mov	$39[bx],al
22080                                           !BCC_EOS
22081                                           ! 3905     *((Bit16u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[2])) = (0);
22082                                           ! Debug: add unsigned short = const $3A to unsigned short SI = [S+$1E+4] (used reg = )
22083 607B           8B46         06            mov	ax,6[bp]
22084                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$3A (used reg = )
22085 607E           89C3                       mov	bx,ax
22086                                           ! Debug: eq int = const 0 to unsigned short = [bx+$3A] (used reg = )
22087 6080           31C0                       xor	ax,ax
22088 6082           8947         3A            mov	$3A[bx],ax
22089                                           !BCC_EOS
22090                                           ! 3906     *((Bit32u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[4])) = (0L);
22091                                           ! Debug: add unsigned short = const $3C to unsigned short SI = [S+$1E+4] (used reg = )
22092 6085           8B46         06            mov	ax,6[bp]
22093                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+$3C (used reg = )
22094 6088           89C3                       mov	bx,ax
22095                                           ! Debug: eq long = const 0 to unsigned long = [bx+$3C] (used reg = )
22096 608A           31C0                       xor	ax,ax
22097 608C           31F6                       xor	si,si
22098 608E           8947         3C            mov	$3C[bx],ax
22099 6091           8977         3E            mov	$3E[bx],si
22100                                           !BCC_EOS
22101                                           ! 3907     if (t13) {
22102 6094           8B46         EE            mov	ax,-$12[bp]
22103 6097           85C0                       test	ax,ax
22104 6099           74           1E            je  	.544
22105                       0000609B            .545:
22106                                           ! 3908       *((Bit32u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[8])) = (0L);
22107                                           ! Debug: add unsigned short = const $40 to unsigned short SI = [S+$1E+4] (used reg = )
22108 609B           8B46         06            mov	ax,6[bp]
22109                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+$40 (used reg = )
22110 609E           89C3                       mov	bx,ax
22111                                           ! Debug: eq long = const 0 to unsigned long = [bx+$40] (used reg = )
22112 60A0           31C0                       xor	ax,ax
22113 60A2           31F6                       xor	si,si
22114 60A4           8947         40            mov	$40[bx],ax
22115 60A7           8977         42            mov	$42[bx],si
22116                                           !BCC_EOS
22117                                           ! 3909       *((Bit32u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.device_path[12])) = (0L);
22118                                           ! Debug: add unsigned short = const $44 to unsigned short SI = [S+$1E+4] (used reg = )
22119 60AA           8B46         06            mov	ax,6[bp]
22120                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+$44 (used reg = )
22121 60AD           89C3                       mov	bx,ax
22122                                           ! Debug: eq long = const 0 to unsigned long = [bx+$44] (used reg = )
22123 60AF           31C0                       xor	ax,ax
22124 60B1           31F6                       xor	si,si
22125 60B3           8947         44            mov	$44[bx],ax
22126 60B6           8977         46            mov	$46[bx],si
22127                                           !BCC_EOS
22128                                           ! 3910     }
22129                                           ! 3911     if (t13)
22130                       000060B9            .544:
22131 60B9           8B46         EE            mov	ax,-$12[bp]
22132 60BC           85C0                       test	ax,ax
22133 60BE           74           0C            je  	.546
22134                       000060C0            .547:
22135                                           ! 3912       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.reserved3)) = (0);
22136                                           ! Debug: add unsigned short = const $48 to unsigned short SI = [S+$1E+4] (used reg = )
22137 60C0           8B46         06            mov	ax,6[bp]
22138                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$48 (used reg = )
22139 60C3           89C3                       mov	bx,ax
22140                                           ! Debug: eq int = const 0 to unsigned char = [bx+$48] (used reg = )
22141 60C5           30C0                       xor	al,al
22142 60C7           8847         48            mov	$48[bx],al
22143                                           !BCC_EOS
22144                                           ! 3913     else
22145                                           ! 3914       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.phoenix.reserved3)) = (0);
22146 60CA           EB           0A            jmp .548
22147                       000060CC            .546:
22148                                           ! Debug: add unsigned short = const $40 to unsigned short SI = [S+$1E+4] (used reg = )
22149 60CC           8B46         06            mov	ax,6[bp]
22150                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$40 (used reg = )
22151 60CF           89C3                       mov	bx,ax
22152                                           ! Debug: eq int = const 0 to unsigned char = [bx+$40] (used reg = )
22153 60D1           30C0                       xor	al,al
22154 60D3           8847         40            mov	$40[bx],al
22155                                           !BCC_EOS
22156                                           ! 3915     checksum = 0;
22157                       000060D6            .548:
22158                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$1E-$1B] (used reg = )
22159 60D6           30C0                       xor	al,al
22160 60D8           8846         E7            mov	-$19[bp],al
22161                                           !BCC_EOS
22162                                           ! 3916     for (i = 30; i < (t13 ? 73 : 65); i++) checksum += *((Bit8u *)(SI + i));
22163                                           ! Debug: eq int = const $1E to unsigned char i = [S+$1E-$1C] (used reg = )
22164 60DB           B0                     1E  mov	al,*$1E
22165 60DD           8846         E6            mov	-$1A[bp],al
22166                                           !BCC_EOS
22167                                           !BCC_EOS
22168 60E0           EB           1F            jmp .54B
22169                       000060E2            .54C:
22170                                           ! Debug: add unsigned char i = [S+$1E-$1C] to unsigned short SI = [S+$1E+4] (used reg = )
22171 60E2           8B46         06            mov	ax,6[bp]
22172 60E5           0246         E6            add	al,-$1A[bp]
22173 60E8           80D4                   00  adc	ah,*0
22174                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+0 (used reg = )
22175 60EB           89C3                       mov	bx,ax
22176                                           ! Debug: addab unsigned char = [bx+0] to unsigned char checksum = [S+$1E-$1B] (used reg = )
22177 60ED           8A46         E7            mov	al,-$19[bp]
22178 60F0           30E4                       xor	ah,ah
22179 60F2           0207                       add	al,[bx]
22180 60F4           80D4                   00  adc	ah,*0
22181 60F7           8846         E7            mov	-$19[bp],al
22182                                           !BCC_EOS
22183                                           ! 3917     checksum = -checksum;
22184                       000060FA            .54A:
22185                                           ! Debug: postinc unsigned char i = [S+$1E-$1C] (used reg = )
22186 60FA           8A46         E6            mov	al,-$1A[bp]
22187 60FD           40                         inc	ax
22188 60FE           8846         E6            mov	-$1A[bp],al
22189                       00006101            .54B:
22190 6101           8B46         EE            mov	ax,-$12[bp]
22191 6104           85C0                       test	ax,ax
22192 6106           74           04            je  	.54E
22193                       00006108            .54F:
22194 6108           B0                     49  mov	al,*$49
22195 610A           EB           02            jmp .550
22196                       0000610C            .54E:
22197 610C           B0                     41  mov	al,*$41
22198                       0000610E            .550:
22199                                           ! Debug: lt char = al+0 to unsigned char i = [S+$1E-$1C] (used reg = )
22200 610E           3A46         E6            cmp	al,-$1A[bp]
22201 6111           77           CF            ja 	.54C
22202                       00006113            .54D:
22203                       00006113            .549:
22204                                           ! Debug: neg unsigned char checksum = [S+$1E-$1B] (used reg = )
22205 6113           31C0                       xor	ax,ax
22206 6115           2A46         E7            sub	al,-$19[bp]
22207 6118           80DC                   00  sbb	ah,*0
22208                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$1E-$1B] (used reg = )
22209 611B           8846         E7            mov	-$19[bp],al
22210                                           !BCC_EOS
22211                                           ! 3918     if (t13)
22212 611E           8B46         EE            mov	ax,-$12[bp]
22213 6121           85C0                       test	ax,ax
22214 6123           74           0D            je  	.551
22215                       00006125            .552:
22216                                           ! 3919       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.t13.checksum)) = (checksum);
22217                                           ! Debug: add unsigned short = const $49 to unsigned short SI = [S+$1E+4] (used reg = )
22218 6125           8B46         06            mov	ax,6[bp]
22219                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$49 (used reg = )
22220 6128           89C3                       mov	bx,ax
22221                                           ! Debug: eq unsigned char checksum = [S+$1E-$1B] to unsigned char = [bx+$49] (used reg = )
22222 612A           8A46         E7            mov	al,-$19[bp]
22223 612D           8847         49            mov	$49[bx],al
22224                                           !BCC_EOS
22225                                           ! 3920     else
22226                                           ! 3921       *((Bit8u *)(SI+(Bit16u)&((dpt_t *) 0)->dpi.phoenix.checksum)) = (checksum);
22227 6130           EB           0B            jmp .553
22228                       00006132            .551:
22229                                           ! Debug: add unsigned short = const $41 to unsigned short SI = [S+$1E+4] (used reg = )
22230 6132           8B46         06            mov	ax,6[bp]
22231                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$41 (used reg = )
22232 6135           89C3                       mov	bx,ax
22233                                           ! Debug: eq unsigned char checksum = [S+$1E-$1B] to unsigned char = [bx+$41] (used reg = )
22234 6137           8A46         E7            mov	al,-$19[bp]
22235 613A           8847         41            mov	$41[bx],al
22236                                           !BCC_EOS
22237                                           ! 3922   }
22238                       0000613D            .553:
22239 613D           83C4                   06  add	sp,*6
22240                                           ! 3923   return 0;
22241                       00006140            .534:
22242 6140           31C0                       xor	ax,ax
22243 6142           89EC                       mov	sp,bp
22244 6144           5D                         pop	bp
22245 6145           C3                         ret
22246                                           !BCC_EOS
22247                                           ! 3924 }
22248                                           ! 3925   void
22249                                           ! Register BX used in function int13_edd
22250                                           ! 3926 int13_harddisk(EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
22251                                           ! 3927   Bit16u EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
22252                                           export	_int13_harddisk
22253                       00006146            _int13_harddisk:
22254                                           !BCC_EOS
22255                                           ! 3928 {
22256                                           ! 3929   Bit32u lba_low, lba_high;
22257                                           !BCC_EOS
22258                                           ! 3930   Bit16u cylinder, head, sector;
22259                                           !BCC_EOS
22260                                           ! 3931   Bit16u segment, offset;
22261                                           !BCC_EOS
22262                                           ! 3932   Bit16u npc, nph, npspt, nlc, nlh, nlspt;
22263                                           !BCC_EOS
22264                                           ! 3933   Bit16u size, count;
22265                                           !BCC_EOS
22266                                           ! 3934   Bit8u device, status;
22267                                           !BCC_EOS
22268                                           ! 3935   ;
22269 6146           55                         push	bp
22270 6147           89E5                       mov	bp,sp
22271 6149           83C4                   DC  add	sp,*-$24
22272                                           !BCC_EOS
22273                                           ! 3936   _write_byte(0, 0x008e, 0x0040);
22274                                           ! Debug: list int = const $40 (used reg = )
22275 614C           B8                   0040  mov	ax,*$40
22276 614F           50                         push	ax
22277                                           ! Debug: list int = const $8E (used reg = )
22278 6150           B8                   008E  mov	ax,#$8E
22279 6153           50                         push	ax
22280                                           ! Debug: list int = const 0 (used reg = )
22281 6154           31C0                       xor	ax,ax
22282 6156           50                         push	ax
22283                                           ! Debug: func () void = _write_byte+0 (used reg = )
22284 6157           E8         A4A6            call	__write_byte
22285 615A           83C4                   06  add	sp,*6
22286                                           !BCC_EOS
22287                                           ! 3937   if ( (( ELDX & 0x00ff ) < 0x80) || (( ELDX & 0x00ff ) >= 0x80 + (4*2)) ) {
22288                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$26+$E] (used reg = )
22289 615D           8A46         10            mov	al,$10[bp]
22290                                           ! Debug: lt int = const $80 to unsigned char = al+0 (used reg = )
22291 6160           3C                     80  cmp	al,#$80
22292 6162           72           07            jb  	.555
22293                       00006164            .556:
22294                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$26+$E] (used reg = )
22295 6164           8A46         10            mov	al,$10[bp]
22296                                           ! Debug: ge int = const $88 to unsigned char = al+0 (used reg = )
22297 6167           3C                     88  cmp	al,#$88
22298 6169           72           20            jb  	.554
22299                       0000616B            .555:
22300                                           ! 3938     bios_printf(4, "int13_harddisk: function %02x, ELDL out of 
22301                                           ! 3938 range %02x\n", *(((Bit8u *)&AX)+1), ( ELDX & 0x00ff ));
22302                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$26+$E] (used reg = )
22303 616B           8A46         10            mov	al,$10[bp]
22304                                           ! Debug: list unsigned char = al+0 (used reg = )
22305 616E           30E4                       xor	ah,ah
22306 6170           50                         push	ax
22307                                           ! Debug: list unsigned char AX = [S+$28+$17] (used reg = )
22308 6171           8A46         19            mov	al,$19[bp]
22309 6174           30E4                       xor	ah,ah
22310 6176           50                         push	ax
22311                                           ! Debug: list * char = .557+0 (used reg = )
22312 6177           BB                   D24B  mov	bx,#.557
22313 617A           53                         push	bx
22314                                           ! Debug: list int = const 4 (used reg = )
22315 617B           B8                   0004  mov	ax,*4
22316 617E           50                         push	ax
22317                                           ! Debug: func () void = bios_printf+0 (used reg = )
22318 617F           E8         A7BC            call	_bios_printf
22319 6182           83C4                   08  add	sp,*8
22320                                           !BCC_EOS
22321                                           ! 3939     goto int13_fail;
22322 6185           83C4                   00  add	sp,#..FFF1+$26
22323 6188           E9         0727            br 	.FFF1
22324                                           !BCC_EOS
22325                                           ! 3940   }
22326                                           ! 3941   device=*((Bit8u *)(&((ebda_data_t *) 0)->ata.hdidmap[( ELDX & 0x00ff )-0x80]));
22327                       0000618B            .554:
22328                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$26+$E] (used reg = )
22329 618B           8A46         10            mov	al,$10[bp]
22330                                           ! Debug: sub int = const $80 to unsigned char = al+0 (used reg = )
22331 618E           30E4                       xor	ah,ah
22332                                           ! Debug: ptradd unsigned int = ax-$80 to [8] unsigned char = const $233 (used reg = )
22333 6190           05                   FF80  add	ax,*-$80
22334 6193           89C3                       mov	bx,ax
22335                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
22336                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$233 (used reg = )
22337                                           ! Debug: eq unsigned char = [bx+$233] to unsigned char device = [S+$26-$25] (used reg = )
22338 6195           8A87       0233            mov	al,$233[bx]
22339 6199           8846         DD            mov	-$23[bp],al
22340                                           !BCC_EOS
22341                                           ! 3942   if (device >= (4*2)) {
22342                                           ! Debug: ge int = const 8 to unsigned char device = [S+$26-$25] (used reg = )
22343 619C           8A46         DD            mov	al,-$23[bp]
22344 619F           3C                     08  cmp	al,*8
22345 61A1           72           20            jb  	.558
22346                       000061A3            .559:
22347                                           ! 3943     bios_printf(4, "int13_harddisk: function %02x, unmapped device for ELDL=%02x\n", *(((Bit8u *)&AX)+1), ( ELDX & 0x00ff ));
22348                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$26+$E] (used reg = )
22349 61A3           8A46         10            mov	al,$10[bp]
22350                                           ! Debug: list unsigned char = al+0 (used reg = )
22351 61A6           30E4                       xor	ah,ah
22352 61A8           50                         push	ax
22353                                           ! Debug: list unsigned char AX = [S+$28+$17] (used reg = )
22354 61A9           8A46         19            mov	al,$19[bp]
22355 61AC           30E4                       xor	ah,ah
22356 61AE           50                         push	ax
22357                                           ! Debug: list * char = .55A+0 (used reg = )
22358 61AF           BB                   D20D  mov	bx,#.55A
22359 61B2           53                         push	bx
22360                                           ! Debug: list int = const 4 (used reg = )
22361 61B3           B8                   0004  mov	ax,*4
22362 61B6           50                         push	ax
22363                                           ! Debug: func () void = bios_printf+0 (used reg = )
22364 61B7           E8         A784            call	_bios_printf
22365 61BA           83C4                   08  add	sp,*8
22366                                           !BCC_EOS
22367                                           ! 3944     goto int13_fail;
22368 61BD           83C4                   00  add	sp,#..FFF1+$26
22369 61C0           E9         06EF            br 	.FFF1
22370                                           !BCC_EOS
22371                                           ! 3945   }
22372                                           ! 3946   switch (*(((Bit8u *)&AX)+1)) {
22373                       000061C3            .558:
22374 61C3           8A46         19            mov	al,$19[bp]
22375 61C6           E9         066E            br 	.55D
22376                                           ! 3947     case 0x00:
22377                                           ! 3948       ata_reset (device);
22378                       000061C9            .55E:
22379                                           ! Debug: list unsigned char device = [S+$26-$25] (used reg = )
22380 61C9           8A46         DD            mov	al,-$23[bp]
22381 61CC           30E4                       xor	ah,ah
22382 61CE           50                         push	ax
22383                                           ! Debug: func () void = ata_reset+0 (used reg = )
22384 61CF           E8         C68C            call	_ata_reset
22385 61D2           44                         inc	sp
22386 61D3           44                         inc	sp
22387                                           !BCC_EOS
22388                                           ! 3949       goto int13_success;
22389 61D4           83C4                   00  add	sp,#..FFEF-..FFF0
22390 61D7           E9         06FD            br 	.FFEF
22391                                           !BCC_EOS
22392                                           ! 3950       break;
22393 61DA           E9         06D5            br 	.55B
22394                                           !BCC_EOS
22395                                           ! 3951     case 0x01:
22396                                           ! 3952       status = _read_byte(0x0074, 0x0040);
22397                       000061DD            .55F:
22398                                           ! Debug: list int = const $40 (used reg = )
22399 61DD           B8                   0040  mov	ax,*$40
22400 61E0           50                         push	ax
22401                                           ! Debug: list int = const $74 (used reg = )
22402 61E1           B8                   0074  mov	ax,*$74
22403 61E4           50                         push	ax
22404                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
22405 61E5           E8         A3FC            call	__read_byte
22406 61E8           83C4                   04  add	sp,*4
22407                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$26-$26] (used reg = )
22408 61EB           8846         DC            mov	-$24[bp],al
22409                                           !BCC_EOS
22410                                           ! 3953       *(((Bit8u *)&AX)+1) = (status);
22411                                           ! Debug: eq unsigned char status = [S+$26-$26] to unsigned char AX = [S+$26+$17] (used reg = )
22412 61EE           8A46         DC            mov	al,-$24[bp]
22413 61F1           8846         19            mov	$19[bp],al
22414                                           !BCC_EOS
22415                                           ! 3954       _write_byte(0, 0x0074, 0x0040);
22416                                           ! Debug: list int = const $40 (used reg = )
22417 61F4           B8                   0040  mov	ax,*$40
22418 61F7           50                         push	ax
22419                                           ! Debug: list int = const $74 (used reg = )
22420 61F8           B8                   0074  mov	ax,*$74
22421 61FB           50                         push	ax
22422                                           ! Debug: list int = const 0 (used reg = )
22423 61FC           31C0                       xor	ax,ax
22424 61FE           50                         push	ax
22425                                           ! Debug: func () void = _write_byte+0 (used reg = )
22426 61FF           E8         A3FE            call	__write_byte
22427 6202           83C4                   06  add	sp,*6
22428                                           !BCC_EOS
22429                                           ! 3955       if (status) goto int13_fail_nostatus;
22430 6205           8A46         DC            mov	al,-$24[bp]
22431 6208           84C0                       test	al,al
22432 620A           74           08            je  	.560
22433                       0000620C            .561:
22434 620C           83C4                   00  add	sp,#..FFEE-..FFF0
22435 620F           E9         06B9            br 	.FFEE
22436                                           !BCC_EOS
22437                                           ! 3956       else goto int13_success_noah;
22438 6212           EB           06            jmp .562
22439                       00006214            .560:
22440 6214           83C4                   00  add	sp,#..FFED-..FFF0
22441 6217           E9         06C2            br 	.FFED
22442                                           !BCC_EOS
22443                                           ! 3957       break;
22444                       0000621A            .562:
22445 621A           E9         0695            br 	.55B
22446                                           !BCC_EOS
22447                                           ! 3958     case 0x02:
22448                                           ! 3959     case 0x03:
22449                       0000621D            .563:
22450                                           ! 3960     case 0x04:
22451                       0000621D            .564:
22452                                           ! 3961       count = ( AX & 0x00ff );
22453                       0000621D            .565:
22454                                           ! Debug: and int = const $FF to unsigned short AX = [S+$26+$16] (used reg = )
22455 621D           8A46         18            mov	al,$18[bp]
22456                                           ! Debug: eq unsigned char = al+0 to unsigned short count = [S+$26-$24] (used reg = )
22457 6220           30E4                       xor	ah,ah
22458 6222           8946         DE            mov	-$22[bp],ax
22459                                           !BCC_EOS
22460                                           ! 3962       cylinder = *(((Bit8u *)&CX)+1);
22461                                           ! Debug: eq unsigned char CX = [S+$26+$15] to unsigned short cylinder = [S+$26-$C] (used reg = )
22462 6225           8A46         17            mov	al,$17[bp]
22463 6228           30E4                       xor	ah,ah
22464 622A           8946         F6            mov	-$A[bp],ax
22465                                           !BCC_EOS
22466                                           ! 3963       cylinder |= ( ((Bit16u) ( CX & 0x00ff )) << 2) & 0x300;
22467                                           ! Debug: and int = const $FF to unsigned short CX = [S+$26+$14] (used reg = )
22468 622D           8A46         16            mov	al,$16[bp]
22469                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
22470 6230           30E4                       xor	ah,ah
22471                                           ! Debug: sl int = const 2 to unsigned short = ax+0 (used reg = )
22472 6232           D1E0                       shl	ax,*1
22473 6234           D1E0                       shl	ax,*1
22474                                           ! Debug: and int = const $300 to unsigned int = ax+0 (used reg = )
22475 6236           25                   0300  and	ax,#$300
22476                                           ! Debug: orab unsigned int = ax+0 to unsigned short cylinder = [S+$26-$C] (used reg = )
22477 6239           0B46         F6            or	ax,-$A[bp]
22478 623C           8946         F6            mov	-$A[bp],ax
22479                                           !BCC_EOS
22480                                           ! 3964       sector = (( CX & 0x00ff ) & 0x3f);
22481                                           ! Debug: and int = const $FF to unsigned short CX = [S+$26+$14] (used reg = )
22482 623F           8A46         16            mov	al,$16[bp]
22483                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
22484 6242           24                     3F  and	al,*$3F
22485                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$26-$10] (used reg = )
22486 6244           30E4                       xor	ah,ah
22487 6246           8946         F2            mov	-$E[bp],ax
22488                                           !BCC_EOS
22489                                           ! 3965       head = *(((Bit8u *)&DX)+1);
22490                                           ! Debug: eq unsigned char DX = [S+$26+$13] to unsigned short head = [S+$26-$E] (used reg = )
22491 6249           8A46         15            mov	al,$15[bp]
22492 624C           30E4                       xor	ah,ah
22493 624E           8946         F4            mov	-$C[bp],ax
22494                                           !BCC_EOS
22495                                           ! 3966       segment = ES;
22496                                           ! Debug: eq unsigned short ES = [S+$26+6] to unsigned short segment = [S+$26-$12] (used reg = )
22497 6251           8B46         08            mov	ax,8[bp]
22498 6254           8946         F0            mov	-$10[bp],ax
22499                                           !BCC_EOS
22500                                           ! 3967       offset = BX;
22501                                           ! Debug: eq unsigned short BX = [S+$26+$10] to unsigned short offset = [S+$26-$14] (used reg = )
22502 6257           8B46         12            mov	ax,$12[bp]
22503 625A           8946         EE            mov	-$12[bp],ax
22504                                           !BCC_EOS
22505                                           ! 3968       if ((count > 128) || (count == 0) || (sector == 0)) {
22506                                           ! Debug: gt int = const $80 to unsigned short count = [S+$26-$24] (used reg = )
22507 625D           8B46         DE            mov	ax,-$22[bp]
22508 6260           3D                   0080  cmp	ax,#$80
22509 6263           77           0E            ja  	.567
22510                       00006265            .569:
22511                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$26-$24] (used reg = )
22512 6265           8B46         DE            mov	ax,-$22[bp]
22513 6268           85C0                       test	ax,ax
22514 626A           74           07            je  	.567
22515                       0000626C            .568:
22516                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$26-$10] (used reg = )
22517 626C           8B46         F2            mov	ax,-$E[bp]
22518 626F           85C0                       test	ax,ax
22519 6271           75           1A            jne 	.566
22520                       00006273            .567:
22521                                           ! 3969         bios_printf(4, "int13_harddisk: function %02x, parameter out of range!\n",*(((Bit8u *)&AX)+1));
22522                                           ! Debug: list unsigned char AX = [S+$26+$17] (used reg = )
22523 6273           8A46         19            mov	al,$19[bp]
22524 6276           30E4                       xor	ah,ah
22525 6278           50                         push	ax
22526                                           ! Debug: list * char = .56A+0 (used reg = )
22527 6279           BB                   D1D5  mov	bx,#.56A
22528 627C           53                         push	bx
22529                                           ! Debug: list int = const 4 (used reg = )
22530 627D           B8                   0004  mov	ax,*4
22531 6280           50                         push	ax
22532                                           ! Debug: func () void = bios_printf+0 (used reg = )
22533 6281           E8         A6BA            call	_bios_printf
22534 6284           83C4                   06  add	sp,*6
22535                                           !BCC_EOS
22536                                           ! 3970         goto int13_fail;
22537 6287           83C4                   00  add	sp,#..FFF1-..FFF0
22538 628A           E9         0625            br 	.FFF1
22539                                           !BCC_EOS
22540                                           ! 3971       }
22541                                           ! 3972       nlc = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders));
22542                       0000628D            .566:
22543                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22544 628D           8A46         DD            mov	al,-$23[bp]
22545 6290           30E4                       xor	ah,ah
22546 6292           B9                   001E  mov	cx,*$1E
22547 6295           F7E9                       imul	cx
22548 6297           89C3                       mov	bx,ax
22549                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
22550                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14E (used reg = )
22551                                           ! Debug: eq unsigned short = [bx+$14E] to unsigned short nlc = [S+$26-$1C] (used reg = )
22552 6299           8B9F       014E            mov	bx,$14E[bx]
22553 629D           895E         E6            mov	-$1A[bp],bx
22554                                           !BCC_EOS
22555                                           ! 3973       nlh = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.heads));
22556                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22557 62A0           8A46         DD            mov	al,-$23[bp]
22558 62A3           30E4                       xor	ah,ah
22559 62A5           B9                   001E  mov	cx,*$1E
22560 62A8           F7E9                       imul	cx
22561 62AA           89C3                       mov	bx,ax
22562                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
22563                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14C (used reg = )
22564                                           ! Debug: eq unsigned short = [bx+$14C] to unsigned short nlh = [S+$26-$1E] (used reg = )
22565 62AC           8B9F       014C            mov	bx,$14C[bx]
22566 62B0           895E         E4            mov	-$1C[bp],bx
22567                                           !BCC_EOS
22568                                           ! 3974       nlspt = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.spt));
22569                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22570 62B3           8A46         DD            mov	al,-$23[bp]
22571 62B6           30E4                       xor	ah,ah
22572 62B8           B9                   001E  mov	cx,*$1E
22573 62BB           F7E9                       imul	cx
22574 62BD           89C3                       mov	bx,ax
22575                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
22576                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$150 (used reg = )
22577                                           ! Debug: eq unsigned short = [bx+$150] to unsigned short nlspt = [S+$26-$20] (used reg = )
22578 62BF           8B9F       0150            mov	bx,$150[bx]
22579 62C3           895E         E2            mov	-$1E[bp],bx
22580                                           !BCC_EOS
22581                                           ! 3975       if( (cylinder >= nlc) || (head >= nlh) || (sector > nlspt) ) {
22582                                           ! Debug: ge unsigned short nlc = [S+$26-$1C] to unsigned short cylinder = [S+$26-$C] (used reg = )
22583 62C6           8B46         F6            mov	ax,-$A[bp]
22584 62C9           3B46         E6            cmp	ax,-$1A[bp]
22585 62CC           73           10            jae 	.56C
22586                       000062CE            .56E:
22587                                           ! Debug: ge unsigned short nlh = [S+$26-$1E] to unsigned short head = [S+$26-$E] (used reg = )
22588 62CE           8B46         F4            mov	ax,-$C[bp]
22589 62D1           3B46         E4            cmp	ax,-$1C[bp]
22590 62D4           73           08            jae 	.56C
22591                       000062D6            .56D:
22592                                           ! Debug: gt unsigned short nlspt = [S+$26-$20] to unsigned short sector = [S+$26-$10] (used reg = )
22593 62D6           8B46         F2            mov	ax,-$E[bp]
22594 62D9           3B46         E2            cmp	ax,-$1E[bp]
22595 62DC           76           23            jbe 	.56B
22596                       000062DE            .56C:
22597                                           ! 3976         bios_printf(4, "int13_harddisk: function %02x, parameters out of range %04x/%04x/%04x!\n", *(((Bit8u *)&AX)+1), cylinder, head, sector);
22598                                           ! Debug: list unsigned short sector = [S+$26-$10] (used reg = )
22599 62DE           FF76         F2            push	-$E[bp]
22600                                           ! Debug: list unsigned short head = [S+$28-$E] (used reg = )
22601 62E1           FF76         F4            push	-$C[bp]
22602                                           ! Debug: list unsigned short cylinder = [S+$2A-$C] (used reg = )
22603 62E4           FF76         F6            push	-$A[bp]
22604                                           ! Debug: list unsigned char AX = [S+$2C+$17] (used reg = )
22605 62E7           8A46         19            mov	al,$19[bp]
22606 62EA           30E4                       xor	ah,ah
22607 62EC           50                         push	ax
22608                                           ! Debug: list * char = .56F+0 (used reg = )
22609 62ED           BB                   D18D  mov	bx,#.56F
22610 62F0           53                         push	bx
22611                                           ! Debug: list int = const 4 (used reg = )
22612 62F1           B8                   0004  mov	ax,*4
22613 62F4           50                         push	ax
22614                                           ! Debug: func () void = bios_printf+0 (used reg = )
22615 62F5           E8         A646            call	_bios_printf
22616 62F8           83C4                   0C  add	sp,*$C
22617                                           !BCC_EOS
22618                                           ! 3977         goto int13_fail;
22619 62FB           83C4                   00  add	sp,#..FFF1-..FFF0
22620 62FE           E9         05B1            br 	.FFF1
22621                                           !BCC_EOS
22622                                           ! 3978       }
22623                                           ! 3979       if (*(((Bit8u *)&AX)+1) == 0x04) goto int13_success;
22624                       00006301            .56B:
22625                                           ! Debug: logeq int = const 4 to unsigned char AX = [S+$26+$17] (used reg = )
22626 6301           8A46         19            mov	al,$19[bp]
22627 6304           3C                     04  cmp	al,*4
22628 6306           75           06            jne 	.570
22629                       00006308            .571:
22630 6308           83C4                   00  add	sp,#..FFEF-..FFF0
22631 630B           E9         05C9            br 	.FFEF
22632                                           !BCC_EOS
22633                                           ! 3980       nph = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.heads));
22634                       0000630E            .570:
22635                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22636 630E           8A46         DD            mov	al,-$23[bp]
22637 6311           30E4                       xor	ah,ah
22638 6313           B9                   001E  mov	cx,*$1E
22639 6316           F7E9                       imul	cx
22640 6318           89C3                       mov	bx,ax
22641                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
22642                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$152 (used reg = )
22643                                           ! Debug: eq unsigned short = [bx+$152] to unsigned short nph = [S+$26-$18] (used reg = )
22644 631A           8B9F       0152            mov	bx,$152[bx]
22645 631E           895E         EA            mov	-$16[bp],bx
22646                                           !BCC_EOS
22647                                           ! 3981       npspt = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].pchs.spt));
22648                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22649 6321           8A46         DD            mov	al,-$23[bp]
22650 6324           30E4                       xor	ah,ah
22651 6326           B9                   001E  mov	cx,*$1E
22652 6329           F7E9                       imul	cx
22653 632B           89C3                       mov	bx,ax
22654                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
22655                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$156 (used reg = )
22656                                           ! Debug: eq unsigned short = [bx+$156] to unsigned short npspt = [S+$26-$1A] (used reg = )
22657 632D           8B9F       0156            mov	bx,$156[bx]
22658 6331           895E         E8            mov	-$18[bp],bx
22659                                           !BCC_EOS
22660                                           ! 3982       if ( (nph != nlh) || (npspt != nlspt)) {
22661                                           ! Debug: ne unsigned short nlh = [S+$26-$1E] to unsigned short nph = [S+$26-$18] (used reg = )
22662 6334           8B46         EA            mov	ax,-$16[bp]
22663 6337           3B46         E4            cmp	ax,-$1C[bp]
22664 633A           75           08            jne 	.573
22665                       0000633C            .574:
22666                                           ! Debug: ne unsigned short nlspt = [S+$26-$20] to unsigned short npspt = [S+$26-$1A] (used reg = )
22667 633C           8B46         E8            mov	ax,-$18[bp]
22668 633F           3B46         E2            cmp	ax,-$1E[bp]
22669 6342           74           72            je  	.572
22670                       00006344            .573:
22671                                           ! 3983         lba_low = ((((Bit32u)cylinder * (Bit32u)nlh) + (Bit32u)head) * (Bit32u)nlspt) + (Bit32u)sector - 1;
22672                                           ! Debug: cast unsigned long = const 0 to unsigned short sector = [S+$26-$10] (used reg = )
22673 6344           8B46         F2            mov	ax,-$E[bp]
22674 6347           31DB                       xor	bx,bx
22675 6349           53                         push	bx
22676 634A           50                         push	ax
22677                                           ! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$2A-$20] (used reg = )
22678 634B           8B46         E2            mov	ax,-$1E[bp]
22679 634E           31DB                       xor	bx,bx
22680 6350           53                         push	bx
22681 6351           50                         push	ax
22682                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$2E-$E] (used reg = )
22683 6352           8B46         F4            mov	ax,-$C[bp]
22684 6355           31DB                       xor	bx,bx
22685 6357           53                         push	bx
22686 6358           50                         push	ax
22687                                           ! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$32-$1E] (used reg = )
22688 6359           8B46         E4            mov	ax,-$1C[bp]
22689 635C           31DB                       xor	bx,bx
22690 635E           53                         push	bx
22691 635F           50                         push	ax
22692                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$36-$C] (used reg = )
22693 6360           8B46         F6            mov	ax,-$A[bp]
22694 6363           31DB                       xor	bx,bx
22695                                           ! Debug: mul unsigned long (temp) = [S+$36-$36] to unsigned long = bx+0 (used reg = )
22696 6365           8D7E         CC            lea	di,-$E+..FFF0[bp]
22697 6368           E8         9D4F            call	lmulul
22698 636B           83C4                   04  add	sp,*4
22699                                           ! Debug: add unsigned long (temp) = [S+$32-$32] to unsigned long = bx+0 (used reg = )
22700 636E           8D7E         D0            lea	di,-$A+..FFF0[bp]
22701 6371           E8         9D20            call	laddul
22702 6374           83C4                   04  add	sp,*4
22703                                           ! Debug: mul unsigned long (temp) = [S+$2E-$2E] to unsigned long = bx+0 (used reg = )
22704 6377           8D7E         D4            lea	di,-6+..FFF0[bp]
22705 637A           E8         9D3D            call	lmulul
22706 637D           83C4                   04  add	sp,*4
22707                                           ! Debug: add unsigned long (temp) = [S+$2A-$2A] to unsigned long = bx+0 (used reg = )
22708 6380           8D7E         D8            lea	di,-2+..FFF0[bp]
22709 6383           E8         9D0E            call	laddul
22710 6386           83C4                   04  add	sp,*4
22711                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
22712 6389           53                         push	bx
22713 638A           50                         push	ax
22714 638B           B8                   0001  mov	ax,*1
22715 638E           31DB                       xor	bx,bx
22716 6390           53                         push	bx
22717 6391           50                         push	ax
22718 6392           8B46         D8            mov	ax,-2+..FFF0[bp]
22719 6395           8B5E         DA            mov	bx,0+..FFF0[bp]
22720 6398           8D7E         D4            lea	di,-6+..FFF0[bp]
22721 639B           E8         9D14            call	lsubul
22722 639E           83C4                   08  add	sp,*8
22723                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$26-6] (used reg = )
22724 63A1           8946         FC            mov	-4[bp],ax
22725 63A4           895E         FE            mov	-2[bp],bx
22726                                           !BCC_EOS
22727                                           ! 3984         lba_
22728                                           ! 3984 high = 0;
22729                                           ! Debug: eq int = const 0 to unsigned long lba_high = [S+$26-$A] (used reg = )
22730 63A7           31C0                       xor	ax,ax
22731 63A9           31DB                       xor	bx,bx
22732 63AB           8946         F8            mov	-8[bp],ax
22733 63AE           895E         FA            mov	-6[bp],bx
22734                                           !BCC_EOS
22735                                           ! 3985         sector = 0;
22736                                           ! Debug: eq int = const 0 to unsigned short sector = [S+$26-$10] (used reg = )
22737 63B1           31C0                       xor	ax,ax
22738 63B3           8946         F2            mov	-$E[bp],ax
22739                                           !BCC_EOS
22740                                           ! 3986       }
22741                                           ! 3987       if (*(((Bit8u *)&AX)+1) == 0x02)
22742                       000063B6            .572:
22743                                           ! Debug: logeq int = const 2 to unsigned char AX = [S+$26+$17] (used reg = )
22744 63B6           8A46         19            mov	al,$19[bp]
22745 63B9           3C                     02  cmp	al,*2
22746 63BB           75           36            jne 	.575
22747                       000063BD            .576:
22748                                           ! 3988         status=ata_cmd_data_io(0, device, 0x20, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
22749                                           ! Debug: list unsigned short offset = [S+$26-$14] (used reg = )
22750 63BD           FF76         EE            push	-$12[bp]
22751                                           ! Debug: list unsigned short segment = [S+$28-$12] (used reg = )
22752 63C0           FF76         F0            push	-$10[bp]
22753                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
22754 63C3           FF76         FA            push	-6[bp]
22755 63C6           FF76         F8            push	-8[bp]
22756                                           ! Debug: list unsigned long lba_low = [S+$2E-6] (used reg = )
22757 63C9           FF76         FE            push	-2[bp]
22758 63CC           FF76         FC            push	-4[bp]
22759                                           ! Debug: list unsigned short sector = [S+$32-$10] (used reg = )
22760 63CF           FF76         F2            push	-$E[bp]
22761                                           ! Debug: list unsigned short head = [S+$34-$E] (used reg = )
22762 63D2           FF76         F4            push	-$C[bp]
22763                                           ! Debug: list unsigned short cylinder = [S+$36-$C] (used reg = )
22764 63D5           FF76         F6            push	-$A[bp]
22765                                           ! Debug: list unsigned short count = [S+$38-$24] (used reg = )
22766 63D8           FF76         DE            push	-$22[bp]
22767                                           ! Debug: list int = const $20 (used reg = )
22768 63DB           B8                   0020  mov	ax,*$20
22769 63DE           50                         push	ax
22770                                           ! Debug: list unsigned char device = [S+$3C-$25] (used reg = )
22771 63DF           8A46         DD            mov	al,-$23[bp]
22772 63E2           30E4                       xor	ah,ah
22773 63E4           50                         push	ax
22774                                           ! Debug: list int = const 0 (used reg = )
22775 63E5           31C0                       xor	ax,ax
22776 63E7           50                         push	ax
22777                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
22778 63E8           E8         C59A            call	_ata_cmd_data_io
22779 63EB           83C4                   1A  add	sp,*$1A
22780                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$26-$26] (used reg = )
22781 63EE           8846         DC            mov	-$24[bp],al
22782                                           !BCC_EOS
22783                                           ! 3989       else
22784                                           ! 3990         status=ata_cmd_data_io(1, device, 0x30, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
22785 63F1           EB           35            jmp .577
22786                       000063F3            .575:
22787                                           ! Debug: list unsigned short offset = [S+$26-$14] (used reg = )
22788 63F3           FF76         EE            push	-$12[bp]
22789                                           ! Debug: list unsigned short segment = [S+$28-$12] (used reg = )
22790 63F6           FF76         F0            push	-$10[bp]
22791                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
22792 63F9           FF76         FA            push	-6[bp]
22793 63FC           FF76         F8            push	-8[bp]
22794                                           ! Debug: list unsigned long lba_low = [S+$2E-6] (used reg = )
22795 63FF           FF76         FE            push	-2[bp]
22796 6402           FF76         FC            push	-4[bp]
22797                                           ! Debug: list unsigned short sector = [S+$32-$10] (used reg = )
22798 6405           FF76         F2            push	-$E[bp]
22799                                           ! Debug: list unsigned short head = [S+$34-$E] (used reg = )
22800 6408           FF76         F4            push	-$C[bp]
22801                                           ! Debug: list unsigned short cylinder = [S+$36-$C] (used reg = )
22802 640B           FF76         F6            push	-$A[bp]
22803                                           ! Debug: list unsigned short count = [S+$38-$24] (used reg = )
22804 640E           FF76         DE            push	-$22[bp]
22805                                           ! Debug: list int = const $30 (used reg = )
22806 6411           B8                   0030  mov	ax,*$30
22807 6414           50                         push	ax
22808                                           ! Debug: list unsigned char device = [S+$3C-$25] (used reg = )
22809 6415           8A46         DD            mov	al,-$23[bp]
22810 6418           30E4                       xor	ah,ah
22811 641A           50                         push	ax
22812                                           ! Debug: list int = const 1 (used reg = )
22813 641B           B8                   0001  mov	ax,*1
22814 641E           50                         push	ax
22815                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
22816 641F           E8         C563            call	_ata_cmd_data_io
22817 6422           83C4                   1A  add	sp,*$1A
22818                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$26-$26] (used reg = )
22819 6425           8846         DC            mov	-$24[bp],al
22820                                           !BCC_EOS
22821                                           ! 3991       *((Bit8u *)&AX) = (*((Bit16u *)(&((ebda_data_t *) 0)->ata.trsfsectors)));
22822                       00006428            .577:
22823                                           ! Debug: eq unsigned short = [+$254] to unsigned char AX = [S+$26+$16] (used reg = )
22824 6428           A0         0254            mov	al,[$254]
22825 642B           8846         18            mov	$18[bp],al
22826                                           !BCC_EOS
22827                                           ! 3992       if (status != 0) {
22828                                           ! Debug: ne int = const 0 to unsigned char status = [S+$26-$26] (used reg = )
22829 642E           8A46         DC            mov	al,-$24[bp]
22830 6431           84C0                       test	al,al
22831 6433           74           25            je  	.578
22832                       00006435            .579:
22833                                           ! 3993         bios_printf(4, "int13_harddisk: function %02x, error %02x !\n",*(((Bit8u *)&AX)+1),status);
22834                                           ! Debug: list unsigned char status = [S+$26-$26] (used reg = )
22835 6435           8A46         DC            mov	al,-$24[bp]
22836 6438           30E4                       xor	ah,ah
22837 643A           50                         push	ax
22838                                           ! Debug: list unsigned char AX = [S+$28+$17] (used reg = )
22839 643B           8A46         19            mov	al,$19[bp]
22840 643E           30E4                       xor	ah,ah
22841 6440           50                         push	ax
22842                                           ! Debug: list * char = .57A+0 (used reg = )
22843 6441           BB                   D160  mov	bx,#.57A
22844 6444           53                         push	bx
22845                                           ! Debug: list int = const 4 (used reg = )
22846 6445           B8                   0004  mov	ax,*4
22847 6448           50                         push	ax
22848                                           ! Debug: func () void = bios_printf+0 (used reg = )
22849 6449           E8         A4F2            call	_bios_printf
22850 644C           83C4                   08  add	sp,*8
22851                                           !BCC_EOS
22852                                           ! 3994         *(((Bit8u *)&AX)+1) = (0x0c);
22853                                           ! Debug: eq int = const $C to unsigned char AX = [S+$26+$17] (used reg = )
22854 644F           B0                     0C  mov	al,*$C
22855 6451           8846         19            mov	$19[bp],al
22856                                           !BCC_EOS
22857                                           ! 3995         goto int13_fail_noah;
22858 6454           83C4                   00  add	sp,#..FFEC-..FFF0
22859 6457           E9         045D            br 	.FFEC
22860                                           !BCC_EOS
22861                                           ! 3996       }
22862                                           ! 3997       goto int13_success;
22863                       0000645A            .578:
22864 645A           83C4                   00  add	sp,#..FFEF-..FFF0
22865 645D           E9         0477            br 	.FFEF
22866                                           !BCC_EOS
22867                                           ! 3998       break;
22868 6460           E9         044F            br 	.55B
22869                                           !BCC_EOS
22870                                           ! 3999     case 0x05:
22871                                           ! 4000       bios_printf(4, "format disk track called\n");
22872                       00006463            .57B:
22873                                           ! Debug: list * char = .57C+0 (used reg = )
22874 6463           BB                   D146  mov	bx,#.57C
22875 6466           53                         push	bx
22876                                           ! Debug: list int = const 4 (used reg = )
22877 6467           B8                   0004  mov	ax,*4
22878 646A           50                         push	ax
22879                                           ! Debug: func () void = bios_printf+0 (used reg = )
22880 646B           E8         A4D0            call	_bios_printf
22881 646E           83C4                   04  add	sp,*4
22882                                           !BCC_EOS
22883                                           ! 4001       goto int13_success;
22884 6471           83C4                   00  add	sp,#..FFEF-..FFF0
22885 6474           E9         0460            br 	.FFEF
22886                                           !BCC_EOS
22887                                           ! 4002       return;
22888 6477           89EC                       mov	sp,bp
22889 6479           5D                         pop	bp
22890 647A           C3                         ret
22891                                           !BCC_EOS
22892                                           ! 4003       break;
22893 647B           E9         0434            br 	.55B
22894                                           !BCC_EOS
22895                                           ! 4004     case 0x08:
22896                                           ! 4005       nlc = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders));
22897                       0000647E            .57D:
22898                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22899 647E           8A46         DD            mov	al,-$23[bp]
22900 6481           30E4                       xor	ah,ah
22901 6483           B9                   001E  mov	cx,*$1E
22902 6486           F7E9                       imul	cx
22903 6488           89C3                       mov	bx,ax
22904                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
22905                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14E (used reg = )
22906                                           ! Debug: eq unsigned short = [bx+$14E] to unsigned short nlc = [S+$26-$1C] (used reg = )
22907 648A           8B9F       014E            mov	bx,$14E[bx]
22908 648E           895E         E6            mov	-$1A[bp],bx
22909                                           !BCC_EOS
22910                                           ! 4006       nlh = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.heads));
22911                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22912 6491           8A46         DD            mov	al,-$23[bp]
22913 6494           30E4                       xor	ah,ah
22914 6496           B9                   001E  mov	cx,*$1E
22915 6499           F7E9                       imul	cx
22916 649B           89C3                       mov	bx,ax
22917                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
22918                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14C (used reg = )
22919                                           ! Debug: eq unsigned short = [bx+$14C] to unsigned short nlh = [S+$26-$1E] (used reg = )
22920 649D           8B9F       014C            mov	bx,$14C[bx]
22921 64A1           895E         E4            mov	-$1C[bp],bx
22922                                           !BCC_EOS
22923                                           ! 4007       nlspt = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.spt));
22924                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
22925 64A4           8A46         DD            mov	al,-$23[bp]
22926 64A7           30E4                       xor	ah,ah
22927 64A9           B9                   001E  mov	cx,*$1E
22928 64AC           F7E9                       imul	cx
22929 64AE           89C3                       mov	bx,ax
22930                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
22931                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$150 (used reg = )
22932                                           ! Debug: eq unsigned short = [bx+$150] to unsigned short nlspt = [S+$26-$20] (used reg = )
22933 64B0           8B9F       0150            mov	bx,$150[bx]
22934 64B4           895E         E2            mov	-$1E[bp],bx
22935                                           !BCC_EOS
22936                                           ! 4008       count = *((Bit8u *)(&((ebda_data_t *) 0)->ata.hdcount));
22937                                           ! Debug: eq unsigned char = [+$232] to unsigned short count = [S+$26-$24] (used reg = )
22938 64B7           A0         0232            mov	al,[$232]
22939 64BA           30E4                       xor	ah,ah
22940 64BC           8946         DE            mov	-$22[bp],ax
22941                                           !BCC_EOS
22942                                           ! 4009       nlc = nlc - 1;
22943                                           ! Debug: sub int = const 1 to unsigned short nlc = [S+$26-$1C] (used reg = )
22944 64BF           8B46         E6            mov	ax,-$1A[bp]
22945                                           ! Debug: eq unsigned int = ax-1 to unsigned short nlc = [S+$26-$1C] (used reg = )
22946 64C2           48                         dec	ax
22947 64C3           8946         E6            mov	-$1A[bp],ax
22948                                           !BCC_EOS
22949                                           ! 4010       *((Bit8u *)&AX) = (0);
22950                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$26+$16] (used reg = )
22951 64C6           30C0                       xor	al,al
22952 64C8           8846         18            mov	$18[bp],al
22953                                           !BCC_EOS
22954                                           ! 4011       *(((Bit8u *)&CX)+1) = (nlc & 0xff);
22955                                           ! Debug: and int = const $FF to unsigned short nlc = [S+$26-$1C] (used reg = )
22956 64CB           8A46         E6            mov	al,-$1A[bp]
22957                                           ! Debug: eq unsigned char = al+0 to unsigned char CX = [S+$26+$15] (used reg = )
22958 64CE           8846         17            mov	$17[bp],al
22959                                           !BCC_EOS
22960                                           ! 4012       *((Bit8u *)&CX) = (((nlc >> 2) & 0xc0) | (nlspt & 0x3f));
22961                                           ! Debug: and int = const $3F to unsigned short nlspt = [S+$26-$20] (used reg = )
22962 64D1           8A46         E2            mov	al,-$1E[bp]
22963 64D4           24                     3F  and	al,*$3F
22964 64D6           50                         push	ax
22965                                           ! Debug: sr int = const 2 to unsigned short nlc = [S+$28-$1C] (used reg = )
22966 64D7           8B46         E6            mov	ax,-$1A[bp]
22967 64DA           D1E8                       shr	ax,*1
22968 64DC           D1E8                       shr	ax,*1
22969                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
22970 64DE           24                     C0  and	al,#$C0
22971                                           ! Debug: or unsigned char (temp) = [S+$28-$28] to unsigned char = al+0 (used reg = )
22972 64E0           0A46         DA            or	al,0+..FFF0[bp]
22973 64E3           44                         inc	sp
22974 64E4           44                         inc	sp
22975                                           ! Debug: eq unsigned char = al+0 to unsigned char CX = [S+$26+$14] (used reg = )
22976 64E5           8846         16            mov	$16[bp],al
22977                                           !BCC_EOS
22978                                           ! 4013       *(((Bit8u *)&DX)+1) = (nlh - 1);
22979                                           ! Debug: sub int = const 1 to unsigned short nlh = [S+$26-$1E] (used reg = )
22980 64E8           8B46         E4            mov	ax,-$1C[bp]
22981                                           ! Debug: eq unsigned int = ax-1 to unsigned char DX = [S+$26+$13] (used reg = )
22982 64EB           48                         dec	ax
22983 64EC           8846         15            mov	$15[bp],al
22984                                           !BCC_EOS
22985                                           ! 4014       *((Bit8u *)&DX) = (count);
22986                                           ! Debug: eq unsigned short count = [S+$26-$24] to unsigned char DX = [S+$26+$12] (used reg = )
22987 64EF           8A46         DE            mov	al,-$22[bp]
22988 64F2           8846         14            mov	$14[bp],al
22989                                           !BCC_EOS
22990                                           ! 4015       goto int13_success;
22991 64F5           83C4                   00  add	sp,#..FFEF-..FFF0
22992 64F8           E9         03DC            br 	.FFEF
22993                                           !BCC_EOS
22994                                           ! 4016       break;
22995 64FB           E9         03B4            br 	.55B
22996                                           !BCC_EOS
22997                                           ! 4017     case 0x10:
22998                                           ! 4018       status = inb(*((Bit16u *)(&((ebda_data_t *) 0)->ata.channels[device/2].iobase1)) + 7);
22999                       000064FE            .57E:
23000                                           ! Debug: div int = const 2 to unsigned char device = [S+$26-$25] (used reg = )
23001 64FE           8A46         DD            mov	al,-$23[bp]
23002 6501           30E4                       xor	ah,ah
23003 6503           D1E8                       shr	ax,*1
23004                                           ! Debug: ptradd unsigned int = ax+0 to [4] struct  = const $122 (used reg = )
23005 6505           B1                     03  mov	cl,*3
23006 6507           D3E0                       shl	ax,cl
23007 6509           89C3                       mov	bx,ax
23008                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
23009                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$124 (used reg = )
23010                                           ! Debug: add int = const 7 to unsigned short = [bx+$124] (used reg = )
23011 650B           8B9F       0124            mov	bx,$124[bx]
23012                                           ! Debug: list unsigned int = bx+7 (used reg = )
23013 650F           83C3                   07  add	bx,*7
23014 6512           53                         push	bx
23015                                           ! Debug: func () unsigned char = inb+0 (used reg = )
23016 6513           E8         9FE2            call	_inb
23017 6516           44                         inc	sp
23018 6517           44                         inc	sp
23019                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$26-$26] (used reg = )
23020 6518           8846         DC            mov	-$24[bp],al
23021                                           !BCC_EOS
23022                                           ! 4019       if ( (status & (0x80 | 0x40)) == 0x40 ) {
23023                                           ! Debug: and int = const $C0 to unsigned char status = [S+$26-$26] (used reg = )
23024 651B           8A46         DC            mov	al,-$24[bp]
23025 651E           24                     C0  and	al,#$C0
23026                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
23027 6520           3C                     40  cmp	al,*$40
23028 6522           75           08            jne 	.57F
23029                       00006524            .580:
23030                                           ! 4020         goto int13_success;
23031 6524           83C4                   00  add	sp,#..FFEF-..FFF0
23032 6527           E9         03AD            br 	.FFEF
23033                                           !BCC_EOS
23034                                           ! 4021       }
23035                                           ! 4022       else {
23036 652A           EB           0B            jmp .581
23037                       0000652C            .57F:
23038                                           ! 4023         *(((Bit8u *)&AX)+1) = (0xAA);
23039                                           ! Debug: eq int = const $AA to unsigned char AX = [S+$26+$17] (used reg = )
23040 652C           B0                     AA  mov	al,#$AA
23041 652E           8846         19            mov	$19[bp],al
23042                                           !BCC_EOS
23043                                           ! 4024         goto int13_fail_noah;
23044 6531           83C4                   00  add	sp,#..FFEC-..FFF0
23045 6534           E9         0380            br 	.FFEC
23046                                           !BCC_EOS
23047                                           ! 4025       }
23048                                           ! 4026       break;
23049                       00006537            .581:
23050 6537           E9         0378            br 	.55B
23051                                           !BCC_EOS
23052                                           ! 4027     case 0x15:
23053                                           ! 4028       nlc = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders));
23054                       0000653A            .582:
23055                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23056 653A           8A46         DD            mov	al,-$23[bp]
23057 653D           30E4                       xor	ah,ah
23058 653F           B9                   001E  mov	cx,*$1E
23059 6542           F7E9                       imul	cx
23060 6544           89C3                       mov	bx,ax
23061                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
23062                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14E (used reg = )
23063                                           ! Debug: eq unsigned short = [bx+$14E] to unsigned short nlc = [S+$26-$1C] (used reg = )
23064 6546           8B9F       014E            mov	bx,$14E[bx]
23065 654A           895E         E6            mov	-$1A[bp],bx
23066                                           !BCC_EOS
23067                                           ! 4029       nlh = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.heads));
23068                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23069 654D           8A46         DD            mov	al,-$23[bp]
23070 6550           30E4                       xor	ah,ah
23071 6552           B9                   001E  mov	cx,*$1E
23072 6555           F7E9                       imul	cx
23073 6557           89C3                       mov	bx,ax
23074                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
23075                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$14C (used reg = )
23076                                           ! Debug: eq unsigned short = [bx+$14C] to unsigned short nlh = [S+$26-$1E] (used reg = )
23077 6559           8B9F       014C            mov	bx,$14C[bx]
23078 655D           895E         E4            mov	-$1C[bp],bx
23079                                           !BCC_EOS
23080                                           ! 4030       nlspt = *((Bit16u *)(&((ebda_data_t *) 0)->ata.devices[device].lchs.spt));
23081                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23082 6560           8A46         DD            mov	al,-$23[bp]
23083 6563           30E4                       xor	ah,ah
23084 6565           B9                   001E  mov	cx,*$1E
23085 6568           F7E9                       imul	cx
23086 656A           89C3                       mov	bx,ax
23087                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
23088                                           ! Debug: cast * unsigned short = const 0 to * unsigned short = bx+$150 (used reg = )
23089                                           ! Debug: eq unsigned short = [bx+$150] to unsigned short nlspt = [S+$26-$20] (used reg = )
23090 656C           8B9F       0150            mov	bx,$150[bx]
23091 6570           895E         E2            mov	-$1E[bp],bx
23092                                           !BCC_EOS
23093                                           ! 4031       lba_low = (Bit32u)(nlc - 1) * (Bit32u)nlh * (Bit32u)nlspt;
23094                                           ! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$26-$20] (used reg = )
23095 6573           8B46         E2            mov	ax,-$1E[bp]
23096 6576           31DB                       xor	bx,bx
23097 6578           53                         push	bx
23098 6579           50                         push	ax
23099                                           ! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$2A-$1E] (used reg = )
23100 657A           8B46         E4            mov	ax,-$1C[bp]
23101 657D           31DB                       xor	bx,bx
23102 657F           53                         push	bx
23103 6580           50                         push	ax
23104                                           ! Debug: sub int = const 1 to unsigned short nlc = [S+$2E-$1C] (used reg = )
23105 6581           8B46         E6            mov	ax,-$1A[bp]
23106                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
23107 6584           48                         dec	ax
23108 6585           31DB                       xor	bx,bx
23109                                           ! Debug: mul unsigned long (temp) = [S+$2E-$2E] to unsigned long = bx+0 (used reg = )
23110 6587           8D7E         D4            lea	di,-6+..FFF0[bp]
23111 658A           E8         9B2D            call	lmulul
23112 658D           83C4                   04  add	sp,*4
23113                                           ! Debug: mul unsigned long (temp) = [S+$2A-$2A] to unsigned long = bx+0 (used reg = )
23114 6590           8D7E         D8            lea	di,-2+..FFF0[bp]
23115 6593           E8         9B24            call	lmulul
23116 6596           83C4                   04  add	sp,*4
23117                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$26-6] (used reg = )
23118 6599           8946         FC            mov	-4[bp],ax
23119 659C           895E         FE            mov	-2[bp],bx
23120                                           !BCC_EOS
23121                                           ! 4032       CX = *(((Bit16u *)&lba_low)+1);
23122                                           ! Debug: eq unsigned short lba_low = [S+$26-4] to unsigned short CX = [S+$26+$14] (used reg = )
23123 659F           8B46         FE            mov	ax,-2[bp]
23124 65A2           8946         16            mov	$16[bp],ax
23125                                           !BCC_EOS
23126                                           ! 4033       DX = *((Bit16u *)&lba_low);
23127                                           ! Debug: eq unsigned short lba_low = [S+$26-6] to unsigned short DX = [S+$26+$12] (used reg = )
23128 65A5           8B46         FC            mov	ax,-4[bp]
23129 65A8           8946         14            mov	$14[bp],ax
23130                                           !BCC_EOS
23131                                           ! 4034    
23132                                           ! 4034    *(((Bit8u *)&AX)+1) = (3);
23133                                           ! Debug: eq int = const 3 to unsigned char AX = [S+$26+$17] (used reg = )
23134 65AB           B0                     03  mov	al,*3
23135 65AD           8846         19            mov	$19[bp],al
23136                                           !BCC_EOS
23137                                           ! 4035       goto int13_success_noah;
23138 65B0           83C4                   00  add	sp,#..FFED-..FFF0
23139 65B3           E9         0326            br 	.FFED
23140                                           !BCC_EOS
23141                                           ! 4036       break;
23142 65B6           E9         02F9            br 	.55B
23143                                           !BCC_EOS
23144                                           ! 4037     case 0x41:
23145                                           ! 4038       BX=0xaa55;
23146                       000065B9            .583:
23147                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$26+$10] (used reg = )
23148 65B9           B8                   AA55  mov	ax,#$AA55
23149 65BC           8946         12            mov	$12[bp],ax
23150                                           !BCC_EOS
23151                                           ! 4039       *(((Bit8u *)&AX)+1) = (0x30);
23152                                           ! Debug: eq int = const $30 to unsigned char AX = [S+$26+$17] (used reg = )
23153 65BF           B0                     30  mov	al,*$30
23154 65C1           8846         19            mov	$19[bp],al
23155                                           !BCC_EOS
23156                                           ! 4040       CX=0x0007;
23157                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$26+$14] (used reg = )
23158 65C4           B8                   0007  mov	ax,*7
23159 65C7           8946         16            mov	$16[bp],ax
23160                                           !BCC_EOS
23161                                           ! 4041       goto int13_success_noah;
23162 65CA           83C4                   00  add	sp,#..FFED-..FFF0
23163 65CD           E9         030C            br 	.FFED
23164                                           !BCC_EOS
23165                                           ! 4042       break;
23166 65D0           E9         02DF            br 	.55B
23167                                           !BCC_EOS
23168                                           ! 4043     case 0x42:
23169                                           ! 4044     case 0x43:
23170                       000065D3            .584:
23171                                           ! 4045     case 0x44:
23172                       000065D3            .585:
23173                                           ! 4046     case 0x47:
23174                       000065D3            .586:
23175                                           ! 4047       count=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->count, DS);
23176                       000065D3            .587:
23177                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23178 65D3           FF76         06            push	6[bp]
23179                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$28+$A] (used reg = )
23180 65D6           8B46         0C            mov	ax,$C[bp]
23181                                           ! Debug: list unsigned int = ax+2 (used reg = )
23182 65D9           40                         inc	ax
23183 65DA           40                         inc	ax
23184 65DB           50                         push	ax
23185                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
23186 65DC           E8         A013            call	__read_word
23187 65DF           83C4                   04  add	sp,*4
23188                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$26-$24] (used reg = )
23189 65E2           8946         DE            mov	-$22[bp],ax
23190                                           !BCC_EOS
23191                                           ! 4048       segment=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->segment, DS);
23192                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23193 65E5           FF76         06            push	6[bp]
23194                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$28+$A] (used reg = )
23195 65E8           8B46         0C            mov	ax,$C[bp]
23196                                           ! Debug: list unsigned int = ax+6 (used reg = )
23197 65EB           05                   0006  add	ax,*6
23198 65EE           50                         push	ax
23199                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
23200 65EF           E8         A000            call	__read_word
23201 65F2           83C4                   04  add	sp,*4
23202                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$26-$12] (used reg = )
23203 65F5           8946         F0            mov	-$10[bp],ax
23204                                           !BCC_EOS
23205                                           ! 4049       offset=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->offset, DS);
23206                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23207 65F8           FF76         06            push	6[bp]
23208                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$28+$A] (used reg = )
23209 65FB           8B46         0C            mov	ax,$C[bp]
23210                                           ! Debug: list unsigned int = ax+4 (used reg = )
23211 65FE           05                   0004  add	ax,*4
23212 6601           50                         push	ax
23213                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
23214 6602           E8         9FED            call	__read_word
23215 6605           83C4                   04  add	sp,*4
23216                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$26-$14] (used reg = )
23217 6608           8946         EE            mov	-$12[bp],ax
23218                                           !BCC_EOS
23219                                           ! 4050       lba_high=_read_dword(SI+(Bit16u)&((int13ext_t *) 0)->lba2, DS);
23220                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23221 660B           FF76         06            push	6[bp]
23222                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$28+$A] (used reg = )
23223 660E           8B46         0C            mov	ax,$C[bp]
23224                                           ! Debug: list unsigned int = ax+$C (used reg = )
23225 6611           05                   000C  add	ax,*$C
23226 6614           50                         push	ax
23227                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
23228 6615           E8         9A3E            call	__read_dword
23229 6618           89D3                       mov	bx,dx
23230 661A           83C4                   04  add	sp,*4
23231                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$26-$A] (used reg = )
23232 661D           8946         F8            mov	-8[bp],ax
23233 6620           895E         FA            mov	-6[bp],bx
23234                                           !BCC_EOS
23235                                           ! 4051       if (lba_high > *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high)) ) {
23236                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23237 6623           8A46         DD            mov	al,-$23[bp]
23238 6626           30E4                       xor	ah,ah
23239 6628           B9                   001E  mov	cx,*$1E
23240 662B           F7E9                       imul	cx
23241 662D           89C3                       mov	bx,ax
23242                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
23243                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
23244                                           ! Debug: gt unsigned long = [bx+$15C] to unsigned long lba_high = [S+$26-$A] (used reg = )
23245 662F           8B87       015C            mov	ax,$15C[bx]
23246 6633           8B9F       015E            mov	bx,$15E[bx]
23247 6637           8D7E         F8            lea	di,-8[bp]
23248 663A           E8         9A5F            call	lcmpul
23249 663D           73           1A            jae 	.588
23250                       0000663F            .589:
23251                                           ! 4052         bios_printf(4, "int13_harddisk: function %02x. LBA out of range\n",*(((Bit8u *)&AX)+1));
23252                                           ! Debug: list unsigned char AX = [S+$26+$17] (used reg = )
23253 663F           8A46         19            mov	al,$19[bp]
23254 6642           30E4                       xor	ah,ah
23255 6644           50                         push	ax
23256                                           ! Debug: list * char = .58A+0 (used reg = )
23257 6645           BB                   D115  mov	bx,#.58A
23258 6648           53                         push	bx
23259                                           ! Debug: list int = const 4 (used reg = )
23260 6649           B8                   0004  mov	ax,*4
23261 664C           50                         push	ax
23262                                           ! Debug: func () void = bios_printf+0 (used reg = )
23263 664D           E8         A2EE            call	_bios_printf
23264 6650           83C4                   06  add	sp,*6
23265                                           !BCC_EOS
23266                                           ! 4053         goto int13_fail;
23267 6653           83C4                   00  add	sp,#..FFF1-..FFF0
23268 6656           E9         0259            br 	.FFF1
23269                                           !BCC_EOS
23270                                           ! 4054       }
23271                                           ! 4055       lba_low=_read_dword(SI+(Bit16u)&((int13ext_t *) 0)->lba1, DS);
23272                       00006659            .588:
23273                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23274 6659           FF76         06            push	6[bp]
23275                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$28+$A] (used reg = )
23276 665C           8B46         0C            mov	ax,$C[bp]
23277                                           ! Debug: list unsigned int = ax+8 (used reg = )
23278 665F           05                   0008  add	ax,*8
23279 6662           50                         push	ax
23280                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
23281 6663           E8         99F0            call	__read_dword
23282 6666           89D3                       mov	bx,dx
23283 6668           83C4                   04  add	sp,*4
23284                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$26-6] (used reg = )
23285 666B           8946         FC            mov	-4[bp],ax
23286 666E           895E         FE            mov	-2[bp],bx
23287                                           !BCC_EOS
23288                                           ! 4056       if (lba_high == *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_high))
23289                                           ! 4057           && lba_low >= *((Bit32u *)(&((ebda_data_t *) 0)->ata.devices[device].sectors_low)) ) {
23290                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23291 6671           8A46         DD            mov	al,-$23[bp]
23292 6674           30E4                       xor	ah,ah
23293 6676           B9                   001E  mov	cx,*$1E
23294 6679           F7E9                       imul	cx
23295 667B           89C3                       mov	bx,ax
23296                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
23297                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$15C (used reg = )
23298                                           ! Debug: logeq unsigned long = [bx+$15C] to unsigned long lba_high = [S+$26-$A] (used reg = )
23299 667D           8B87       015C            mov	ax,$15C[bx]
23300 6681           8B9F       015E            mov	bx,$15E[bx]
23301 6685           8D7E         F8            lea	di,-8[bp]
23302 6688           E8         9A11            call	lcmpul
23303 668B           75           36            jne 	.58B
23304                       0000668D            .58D:
23305                                           ! Debug: ptradd unsigned char device = [S+$26-$25] to [8] struct  = const $142 (used reg = )
23306 668D           8A46         DD            mov	al,-$23[bp]
23307 6690           30E4                       xor	ah,ah
23308 6692           B9                   001E  mov	cx,*$1E
23309 6695           F7E9                       imul	cx
23310 6697           89C3                       mov	bx,ax
23311                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
23312                                           ! Debug: cast * unsigned long = const 0 to * unsigned long = bx+$158 (used reg = )
23313                                           ! Debug: ge unsigned long = [bx+$158] to unsigned long lba_low = [S+$26-6] (used reg = )
23314 6699           8B87       0158            mov	ax,$158[bx]
23315 669D           8B9F       015A            mov	bx,$15A[bx]
23316 66A1           8D7E         FC            lea	di,-4[bp]
23317 66A4           E8         99F5            call	lcmpul
23318 66A7           77           1A            ja  	.58B
23319                       000066A9            .58C:
23320                                           ! 4058         bios_printf(4, "int13_harddisk: function %02x. LBA out of range\n",*(((Bit8u *)&AX)+1));
23321                                           ! Debug: list unsigned char AX = [S+$26+$17] (used reg = )
23322 66A9           8A46         19            mov	al,$19[bp]
23323 66AC           30E4                       xor	ah,ah
23324 66AE           50                         push	ax
23325                                           ! Debug: list * char = .58E+0 (used reg = )
23326 66AF           BB                   D0E4  mov	bx,#.58E
23327 66B2           53                         push	bx
23328                                           ! Debug: list int = const 4 (used reg = )
23329 66B3           B8                   0004  mov	ax,*4
23330 66B6           50                         push	ax
23331                                           ! Debug: func () void = bios_printf+0 (used reg = )
23332 66B7           E8         A284            call	_bios_printf
23333 66BA           83C4                   06  add	sp,*6
23334                                           !BCC_EOS
23335                                           ! 4059         goto int13_fail;
23336 66BD           83C4                   00  add	sp,#..FFF1-..FFF0
23337 66C0           E9         01EF            br 	.FFF1
23338                                           !BCC_EOS
23339                                           ! 4060       }
23340                                           ! 4061       if (( *(((Bit8u *)&AX)+1) == 0x44 ) || ( *(((Bit8u *)&AX)+1) == 0x47 ))
23341                       000066C3            .58B:
23342                                           ! Debug: logeq int = const $44 to unsigned char AX = [S+$26+$17] (used reg = )
23343 66C3           8A46         19            mov	al,$19[bp]
23344 66C6           3C                     44  cmp	al,*$44
23345 66C8           74           07            je  	.590
23346                       000066CA            .591:
23347                                           ! Debug: logeq int = const $47 to unsigned char AX = [S+$26+$17] (used reg = )
23348 66CA           8A46         19            mov	al,$19[bp]
23349 66CD           3C                     47  cmp	al,*$47
23350 66CF           75           06            jne 	.58F
23351                       000066D1            .590:
23352                                           ! 4062         goto int13_success;
23353 66D1           83C4                   00  add	sp,#..FFEF-..FFF0
23354 66D4           E9         0200            br 	.FFEF
23355                                           !BCC_EOS
23356                                           ! 4063       if (*(((Bit8u *)&AX)+1) == 0x42)
23357                       000066D7            .58F:
23358                                           ! Debug: logeq int = const $42 to unsigned char AX = [S+$26+$17] (used reg = )
23359 66D7           8A46         19            mov	al,$19[bp]
23360 66DA           3C                     42  cmp	al,*$42
23361 66DC           75           36            jne 	.592
23362                       000066DE            .593:
23363                                           ! 4064         status=ata_cmd_data_io(0, device, 0x20, count, 0, 0, 0, lba_low, lba_high, segment, offset);
23364                                           ! Debug: list unsigned short offset = [S+$26-$14] (used reg = )
23365 66DE           FF76         EE            push	-$12[bp]
23366                                           ! Debug: list unsigned short segment = [S+$28-$12] (used reg = )
23367 66E1           FF76         F0            push	-$10[bp]
23368                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
23369 66E4           FF76         FA            push	-6[bp]
23370 66E7           FF76         F8            push	-8[bp]
23371                                           ! Debug: list unsigned long lba_low = [S+$2E-6] (used reg = )
23372 66EA           FF76         FE            push	-2[bp]
23373 66ED           FF76         FC            push	-4[bp]
23374                                           ! Debug: list int = const 0 (used reg = )
23375 66F0           31C0                       xor	ax,ax
23376 66F2           50                         push	ax
23377                                           ! Debug: list int = const 0 (used reg = )
23378 66F3           31C0                       xor	ax,ax
23379 66F5           50                         push	ax
23380                                           ! Debug: list int = const 0 (used reg = )
23381 66F6           31C0                       xor	ax,ax
23382 66F8           50                         push	ax
23383                                           ! Debug: list unsigned short count = [S+$38-$24] (used reg = )
23384 66F9           FF76         DE            push	-$22[bp]
23385                                           ! Debug: list int = const $20 (used reg = )
23386 66FC           B8                   0020  mov	ax,*$20
23387 66FF           50                         push	ax
23388                                           ! Debug: list unsigned char device = [S+$3C-$25] (used reg = )
23389 6700           8A46         DD            mov	al,-$23[bp]
23390 6703           30E4                       xor	ah,ah
23391 6705           50                         push	ax
23392                                           ! Debug: list int = const 0 (used reg = )
23393 6706           31C0                       xor	ax,ax
23394 6708           50                         push	ax
23395                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
23396 6709           E8         C279            call	_ata_cmd_data_io
23397 670C           83C4                   1A  add	sp,*$1A
23398                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$26-$26] (used reg = )
23399 670F           8846         DC            mov	-$24[bp],al
23400                                           !BCC_EOS
23401                                           ! 4065       else
23402                                           ! 4066         status=ata_cmd_data_io(1, device, 0x30, count, 0, 0, 0, lba_low, lba_high, segment, offset);
23403 6712           EB           35            jmp .594
23404                       00006714            .592:
23405                                           ! Debug: list unsigned short offset = [S+$26-$14] (used reg = )
23406 6714           FF76         EE            push	-$12[bp]
23407                                           ! Debug: list unsigned short segment = [S+$28-$12] (used reg = )
23408 6717           FF76         F0            push	-$10[bp]
23409                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
23410 671A           FF76         FA            push	-6[bp]
23411 671D           FF76         F8            push	-8[bp]
23412                                           ! Debug: list unsigned long lba_low = [S+$2E-6] (used reg = )
23413 6720           FF76         FE            push	-2[bp]
23414 6723           FF76         FC            push	-4[bp]
23415                                           ! Debug: list int = const 0 (used reg = )
23416 6726           31C0                       xor	ax,ax
23417 6728           50                         push	ax
23418                                           ! Debug: list int = const 0 (used reg = )
23419 6729           31C0                       xor	ax,ax
23420 672B           50                         push	ax
23421                                           ! Debug: list int = const 0 (used reg = )
23422 672C           31C0                       xor	ax,ax
23423 672E           50                         push	ax
23424                                           ! Debug: list unsigned short count = [S+$38-$24] (used reg = )
23425 672F           FF76         DE            push	-$22[bp]
23426                                           ! Debug: list int = const $30 (used reg = )
23427 6732           B8                   0030  mov	ax,*$30
23428 6735           50                         push	ax
23429                                           ! Debug: list unsigned char device = [S+$3C-$25] (used reg = )
23430 6736           8A46         DD            mov	al,-$23[bp]
23431 6739           30E4                       xor	ah,ah
23432 673B           50                         push	ax
23433                                           ! Debug: list int = const 1 (used reg = )
23434 673C           B8                   0001  mov	ax,*1
23435 673F           50                         push	ax
23436                                           ! Debug: func () unsigned short = ata_cmd_data_io+0 (used reg = )
23437 6740           E8         C242            call	_ata_cmd_data_io
23438 6743           83C4                   1A  add	sp,*$1A
23439                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$26-$26] (used reg = )
23440 6746           8846         DC            mov	-$24[bp],al
23441                                           !BCC_EOS
23442                                           ! 4067       count=*((Bit16u *)(&((ebda_data_t *) 0)->ata.trsfsectors));
23443                       00006749            .594:
23444                                           ! Debug: eq unsigned short = [+$254] to unsigned short count = [S+$26-$24] (used reg = )
23445 6749           A1         0254            mov	ax,[$254]
23446 674C           8946         DE            mov	-$22[bp],ax
23447                                           !BCC_EOS
23448                                           ! 4068       _write_word(count, SI+(Bit16u)&((int13ext_t *) 0)->count, DS);
23449                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
23450 674F           FF76         06            push	6[bp]
23451                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$28+$A] (used reg = )
23452 6752           8B46         0C            mov	ax,$C[bp]
23453                                           ! Debug: list unsigned int = ax+2 (used reg = )
23454 6755           40                         inc	ax
23455 6756           40                         inc	ax
23456 6757           50                         push	ax
23457                                           ! Debug: list unsigned short count = [S+$2A-$24] (used reg = )
23458 6758           FF76         DE            push	-$22[bp]
23459                                           ! Debug: func () void = _write_word+0 (used reg = )
23460 675B           E8         9EB5            call	__write_word
23461 675E           83C4                   06  add	sp,*6
23462                                           !BCC_EOS
23463                                           ! 4069       if (status != 0) {
23464                                           ! Debug: ne int = const 0 to unsigned char status = [S+$26-$26] (used reg = )
23465 6761           8A46         DC            mov	al,-$24[bp]
23466 6764           84C0                       test	al,al
23467 6766           74           25            je  	.595
23468                       00006768            .596:
23469                                           ! 4070         bios_printf(4, "int13_harddisk: function %02x, error %02x !\n",*(((Bit8u *)&AX)+1),status);
23470                                           ! Debug: list unsigned char status = [S+$26-$26] (used reg = )
23471 6768           8A46         DC            mov	al,-$24[bp]
23472 676B           30E4                       xor	ah,ah
23473 676D           50                         push	ax
23474                                           ! Debug: list unsigned char AX = [S+$28+$17] (used reg = )
23475 676E           8A46         19            mov	al,$19[bp]
23476 6771           30E4                       xor	ah,ah
23477 6773           50                         push	ax
23478                                           ! Debug: list * char = .597+0 (used reg = )
23479 6774           BB                   D0B7  mov	bx,#.597
23480 6777           53                         push	bx
23481                                           ! Debug: list int = const 4 (used reg = )
23482 6778           B8                   0004  mov	ax,*4
23483 677B           50                         push	ax
23484                                           ! Debug: func () void = bios_printf+0 (used reg = )
23485 677C           E8         A1BF            call	_bios_printf
23486 677F           83C4                   08  add	sp,*8
23487                                           !BCC_EOS
23488                                           ! 4071         *(((Bit8u *)&AX)+1) = (0x0c);
23489                                           ! Debug: eq int = const $C to unsigned char AX = [S+$26+$17] (used reg = )
23490 6782           B0                     0C  mov	al,*$C
23491 6784           8846         19            mov	$19[bp],al
23492                                           !BCC_EOS
23493                                           ! 4072         goto int13_fail_noah;
23494 6787           83C4                   00  add	sp,#..FFEC-..FFF0
23495 678A           E9         012A            br 	.FFEC
23496                                           !BCC_EOS
23497                                           ! 4073       }
23498                                           ! 4074       goto int13_success;
23499                       0000678D            .595:
23500 678D           83C4                   00  add	sp,#..FFEF-..FFF0
23501 6790           E9         0144            br 	.FFEF
23502                                           !BCC_EOS
23503                                           ! 4075       break;
23504 6793           E9         011C            br 	.55B
23505                                           !BCC_EOS
23506                                           ! 4076     case 0x45:
23507                                           ! 4077     case 0x49:
23508                       00006796            .598:
23509                                           ! 4078       goto int13_success;
23510                       00006796            .599:
23511 6796           83C4                   00  add	sp,#..FFEF-..FFF0
23512 6799           E9         013B            br 	.FFEF
23513                                           !BCC_EOS
23514                                           ! 4079       break;
23515 679C           E9         0113            br 	.55B
23516                                           !BCC_EOS
23517                                           ! 4080     case 0x46:
23518                                           ! 4081       *(((Bit8u *)&AX)+1) = (0xb2);
23519                       0000679F            .59A:
23520                                           ! Debug: eq int = const $B2 to unsigned char AX = [S+$26+$17] (used reg = )
23521 679F           B0                     B2  mov	al,#$B2
23522 67A1           8846         19            mov	$19[bp],al
23523                                           !BCC_EOS
23524                                           ! 4082       goto int13_fail_noah;
23525 67A4           83C4                   00  add	sp,#..FFEC-..FFF0
23526 67A7           E9         010D            br 	.FFEC
23527                                           !BCC_EOS
23528                                           ! 4083       break;
23529 67AA           E9         0105            br 	.55B
23530                                           !BCC_EOS
23531                                           ! 4084  
23532                                           ! 4084    case 0x48:
23533                                           ! 4085       if (int13_edd(DS, SI, device))
23534                       000067AD            .59B:
23535                                           ! Debug: list unsigned char device = [S+$26-$25] (used reg = )
23536 67AD           8A46         DD            mov	al,-$23[bp]
23537 67B0           30E4                       xor	ah,ah
23538 67B2           50                         push	ax
23539                                           ! Debug: list unsigned short SI = [S+$28+$A] (used reg = )
23540 67B3           FF76         0C            push	$C[bp]
23541                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
23542 67B6           FF76         06            push	6[bp]
23543                                           ! Debug: func () int = int13_edd+0 (used reg = )
23544 67B9           E8         F315            call	_int13_edd
23545 67BC           83C4                   06  add	sp,*6
23546 67BF           85C0                       test	ax,ax
23547 67C1           74           06            je  	.59C
23548                       000067C3            .59D:
23549                                           ! 4086         goto int13_fail;
23550 67C3           83C4                   00  add	sp,#..FFF1-..FFF0
23551 67C6           E9         00E9            br 	.FFF1
23552                                           !BCC_EOS
23553                                           ! 4087       goto int13_success;
23554                       000067C9            .59C:
23555 67C9           83C4                   00  add	sp,#..FFEF-..FFF0
23556 67CC           E9         0108            br 	.FFEF
23557                                           !BCC_EOS
23558                                           ! 4088       break;
23559 67CF           E9         00E0            br 	.55B
23560                                           !BCC_EOS
23561                                           ! 4089     case 0x4e:
23562                                           ! 4090       switch (( AX & 0x00ff )) {
23563                       000067D2            .59E:
23564                                           ! Debug: and int = const $FF to unsigned short AX = [S+$26+$16] (used reg = )
23565 67D2           8A46         18            mov	al,$18[bp]
23566 67D5           EB           10            jmp .5A1
23567                                           ! 4091         case 0x01:
23568                                           ! 4092         case 0x03:
23569                       000067D7            .5A2:
23570                                           ! 4093         case 0x04:
23571                       000067D7            .5A3:
23572                                           ! 4094         case 0x06:
23573                       000067D7            .5A4:
23574                                           ! 4095           goto int13_success;
23575                       000067D7            .5A5:
23576 67D7           83C4                   00  add	sp,#..FFEF-..FFF0
23577 67DA           E9         00FA            br 	.FFEF
23578                                           !BCC_EOS
23579                                           ! 4096           break;
23580 67DD           EB           1A            jmp .59F
23581                                           !BCC_EOS
23582                                           ! 4097         default:
23583                                           ! 4098           goto int13_fail;
23584                       000067DF            .5A6:
23585 67DF           83C4                   00  add	sp,#..FFF1-..FFF0
23586 67E2           E9         00CD            br 	.FFF1
23587                                           !BCC_EOS
23588                                           ! 4099       }
23589                                           ! 4100       break;
23590 67E5           EB           12            jmp .59F
23591                       000067E7            .5A1:
23592 67E7           2C                     01  sub	al,*1
23593 67E9           74           EC            je 	.5A2
23594 67EB           2C                     02  sub	al,*2
23595 67ED           74           E8            je 	.5A3
23596 67EF           2C                     01  sub	al,*1
23597 67F1           74           E4            je 	.5A4
23598 67F3           2C                     02  sub	al,*2
23599 67F5           74           E0            je 	.5A5
23600 67F7           EB           E6            jmp	.5A6
23601                       000067F9            .59F:
23602 67F9           E9         00B6            br 	.55B
23603                                           !BCC_EOS
23604                                           ! 4101     case 0x09:
23605                                           ! 4102     case 0x0c:
23606                       000067FC            .5A7:
23607                                           ! 4103     case 0x0d:
23608                       000067FC            .5A8:
23609                                           ! 4104     case 0x11:
23610                       000067FC            .5A9:
23611                                           ! 4105     case 0x14:
23612                       000067FC            .5AA:
23613                                           ! 4106       bios_printf(4, "int13_harddisk: function %02xh unimplemented, returns success\n", *(((Bit8u *)&AX)+1));
23614                       000067FC            .5AB:
23615                                           ! Debug: list unsigned char AX = [S+$26+$17] (used reg = )
23616 67FC           8A46         19            mov	al,$19[bp]
23617 67FF           30E4                       xor	ah,ah
23618 6801           50                         push	ax
23619                                           ! Debug: list * char = .5AC+0 (used reg = )
23620 6802           BB                   D078  mov	bx,#.5AC
23621 6805           53                         push	bx
23622                                           ! Debug: list int = const 4 (used reg = )
23623 6806           B8                   0004  mov	ax,*4
23624 6809           50                         push	ax
23625                                           ! Debug: func () void = bios_printf+0 (used reg = )
23626 680A           E8         A131            call	_bios_printf
23627 680D           83C4                   06  add	sp,*6
23628                                           !BCC_EOS
23629                                           ! 4107       goto int13_success;
23630 6810           83C4                   00  add	sp,#..FFEF-..FFF0
23631 6813           E9         00C1            br 	.FFEF
23632                                           !BCC_EOS
23633                                           ! 4108       break;
23634 6816           E9         0099            br 	.55B
23635                                           !BCC_EOS
23636                                           ! 4109     case 0x0a:
23637                                           ! 4110     case 0x0b:
23638                       00006819            .5AD:
23639                                           ! 4111     case 0x18:
23640                       00006819            .5AE:
23641                                           ! 4112     case 0x50:
23642                       00006819            .5AF:
23643                                           ! 4113     default:
23644                       00006819            .5B0:
23645                                           ! 4114       bios_printf(4, "int13_harddisk: function %02xh unsupported, returns fail\n", *(((Bit8u *)&AX)+1));
23646                       00006819            .5B1:
23647                                           ! Debug: list unsigned char AX = [S+$26+$17] (used reg = )
23648 6819           8A46         19            mov	al,$19[bp]
23649 681C           30E4                       xor	ah,ah
23650 681E           50                         push	ax
23651                                           ! Debug: list * char = .5B2+0 (used reg = )
23652 681F           BB                   D03E  mov	bx,#.5B2
23653 6822           53                         push	bx
23654                                           ! Debug: list int = const 4 (used reg = )
23655 6823           B8                   0004  mov	ax,*4
23656 6826           50                         push	ax
23657                                           ! Debug: func () void = bios_printf+0 (used reg = )
23658 6827           E8         A114            call	_bios_printf
23659 682A           83C4                   06  add	sp,*6
23660                                           !BCC_EOS
23661                                           ! 4115       goto int13_fail;
23662 682D           83C4                   00  add	sp,#..FFF1-..FFF0
23663 6830           E9         007F            jmp .FFF1
23664                                           !BCC_EOS
23665                                           ! 4116       break;
23666 6833           EB           7D            jmp .55B
23667                                           !BCC_EOS
23668                                           ! 4117   }
23669                                           ! 4118 int13_fail:
23670 6835           EB           7B            jmp .55B
23671                       00006837            .55D:
23672 6837           2C                     00  sub	al,*0
23673 6839           72           DE            jb 	.5B1
23674 683B           3C                     18  cmp	al,*$18
23675 683D           77           3D            ja  	.5B3
23676 683F           30E4                       xor	ah,ah
23677 6841           D1E0                       shl	ax,*1
23678 6843           89C3                       mov	bx,ax
23679 6845           2E                         seg	cs
23680 6846           FFA7       684A            br	.5B4[bx]
23681                       0000684A            .5B4:
23682 684A                      61C9            .word	.55E
23683 684C                      61DD            .word	.55F
23684 684E                      621D            .word	.563
23685 6850                      621D            .word	.564
23686 6852                      621D            .word	.565
23687 6854                      6463            .word	.57B
23688 6856                      6819            .word	.5B1
23689 6858                      6819            .word	.5B1
23690 685A                      647E            .word	.57D
23691 685C                      67FC            .word	.5A7
23692 685E                      6819            .word	.5AD
23693 6860                      6819            .word	.5AE
23694 6862                      67FC            .word	.5A8
23695 6864                      67FC            .word	.5A9
23696 6866                      6819            .word	.5B1
23697 6868                      6819            .word	.5B1
23698 686A                      64FE            .word	.57E
23699 686C                      67FC            .word	.5AA
23700 686E                      6819            .word	.5B1
23701 6870                      6819            .word	.5B1
23702 6872                      67FC            .word	.5AB
23703 6874                      653A            .word	.582
23704 6876                      6819            .word	.5B1
23705 6878                      6819            .word	.5B1
23706 687A                      6819            .word	.5AF
23707                       0000687C            .5B3:
23708 687C           2C                     41  sub	al,*$41
23709 687E           72           99            jb 	.5B1
23710 6880           3C                     0F  cmp	al,*$F
23711 6882           77           2B            ja  	.5B5
23712 6884           30E4                       xor	ah,ah
23713 6886           D1E0                       shl	ax,*1
23714 6888           89C3                       mov	bx,ax
23715 688A           2E                         seg	cs
23716 688B           FFA7       688F            br	.5B6[bx]
23717                       0000688F            .5B6:
23718 688F                      65B9            .word	.583
23719 6891                      65D3            .word	.584
23720 6893                      65D3            .word	.585
23721 6895                      65D3            .word	.586
23722 6897                      6796            .word	.598
23723 6899                      679F            .word	.59A
23724 689B                      65D3            .word	.587
23725 689D                      67AD            .word	.59B
23726 689F                      6796            .word	.599
23727 68A1                      6819            .word	.5B1
23728 68A3                      6819            .word	.5B1
23729 68A5                      6819            .word	.5B1
23730 68A7                      6819            .word	.5B1
23731 68A9                      67D2            .word	.59E
23732 68AB                      6819            .word	.5B1
23733 68AD                      6819            .word	.5B0
23734                       000068AF            .5B5:
23735 68AF           E9         FF67            br 	.5B1
23736                       000068B2            .55B:
23737                       FFFFFFDA            ..FFF0	=	-$26
23738                       000068B2            .FFF1:
23739                       FFFFFFDA            ..FFF1	=	-$26
23740                                           ! 4119   *(((Bit8u *)&AX)+1) = (0x01);
23741                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$26+$17] (used reg = )
23742 68B2           B0                     01  mov	al,*1
23743 68B4           8846         19            mov	$19[bp],al
23744                                           !BCC_EOS
23745                                           ! 4120 int13_fail_noah:
23746                       000068B7            .FFEC:
23747                       FFFFFFDA            ..FFEC	=	-$26
23748                                           ! 4121   _write_byte(*(((Bit8u *)&AX)+1), 0x0074, 0x0040);
23749                                           ! Debug: list int = const $40 (used reg = )
23750 68B7           B8                   0040  mov	ax,*$40
23751 68BA           50                         push	ax
23752                                           ! Debug: list int = const $74 (used reg = )
23753 68BB           B8                   0074  mov	ax,*$74
23754 68BE           50                         push	ax
23755                                           ! Debug: list unsigned char AX = [S+$2A+$17] (used reg = )
23756 68BF           8A46         19            mov	al,$19[bp]
23757 68C2           30E4                       xor	ah,ah
23758 68C4           50                         push	ax
23759                                           ! Debug: func () void = _write_byte+0 (used reg = )
23760 68C5           E8         9D38            call	__write_byte
23761 68C8           83C4                   06  add	sp,*6
23762                                           !BCC_EOS
23763                                           ! 4122 int13_fail_nostatus:
23764                       000068CB            .FFEE:
23765                       FFFFFFDA            ..FFEE	=	-$26
23766                                           ! 4123   FLAGS |= 0x0001;
23767                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$26+$1C] (used reg = )
23768 68CB           8B46         1E            mov	ax,$1E[bp]
23769 68CE           0C                     01  or	al,*1
23770 68D0           8946         1E            mov	$1E[bp],ax
23771                                           !BCC_EOS
23772                                           ! 4124   return;
23773 68D3           89EC                       mov	sp,bp
23774 68D5           5D                         pop	bp
23775 68D6           C3                         ret
23776                                           !BCC_EOS
23777                                           ! 4125 int13_success:
23778                       000068D7            .FFEF:
23779                       FFFFFFDA            ..FFEF	=	-$26
23780                                           ! 4126   *(((Bit8u *)&AX)+1) = (0x00);
23781                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$26+$17] (used reg = )
23782 68D7           30C0                       xor	al,al
23783 68D9           8846         19            mov	$19[bp],al
23784                                           !BCC_EOS
23785                                           ! 4127 int13_success_noah:
23786                       000068DC            .FFED:
23787                       FFFFFFDA            ..FFED	=	-$26
23788                                           ! 4128   _write_byte(0x00, 0x0074, 0x0040);
23789                                           ! Debug: list int = const $40 (used reg = )
23790 68DC           B8                   0040  mov	ax,*$40
23791 68DF           50                         push	ax
23792                                           ! Debug: list int = const $74 (used reg = )
23793 68E0           B8                   0074  mov	ax,*$74
23794 68E3           50                         push	ax
23795                                           ! Debug: list int = const 0 (used reg = )
23796 68E4           31C0                       xor	ax,ax
23797 68E6           50                         push	ax
23798                                           ! Debug: func () void = _write_byte+0 (used reg = )
23799 68E7           E8         9D16            call	__write_byte
23800 68EA           83C4                   06  add	sp,*6
23801                                           !BCC_EOS
23802                                           ! 4129   FLAGS &= 0xfffe;
23803                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$26+$1C] (used reg = )
23804 68ED           8B46         1E            mov	ax,$1E[bp]
23805 68F0           24                     FE  and	al,#$FE
23806 68F2           8946         1E            mov	$1E[bp],ax
23807                                           !BCC_EOS
23808                                           ! 4130 }
23809 68F5           89EC                       mov	sp,bp
23810 68F7           5D                         pop	bp
23811 68F8           C3                         ret
23812                                           ! 4131   void
23813                                           ! Register BX used in function int13_harddisk
23814                                           ! 4132 int13_cdrom(EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
23815                                           ! 4133   Bit16u EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
23816                                           export	_int13_cdrom
23817                       000068F9            _int13_cdrom:
23818                                           !BCC_EOS
23819                                           ! 4134 {
23820                                           ! 4135   Bit8u device, status, locks;
23821                                           !BCC_EOS
23822                                           ! 4136   Bit8u atacmd[12];
23823                                           !BCC_EOS
23824                                           ! 4137   Bit32u lba;
23825                                           !BCC_EOS
23826                                           ! 4138   Bit16u count, segment, offset, i, size;
23827                                           !BCC_EOS
23828                                           ! 4139   ;
23829 68F9           55                         push	bp
23830 68FA           89E5                       mov	bp,sp
23831 68FC           83C4                   E2  add	sp,*-$1E
23832                                           !BCC_EOS
23833                                           ! 4140   _write_byte(0x00, 0x0074, 0x0040);
23834                                           ! Debug: list int = const $40 (used reg = )
23835 68FF           B8                   0040  mov	ax,*$40
23836 6902           50                         push	ax
23837                                           ! Debug: list int = const $74 (used reg = )
23838 6903           B8                   0074  mov	ax,*$74
23839 6906           50                         push	ax
23840                                           ! Debug: list int = const 0 (used reg = )
23841 6907           31C0                       xor	ax,ax
23842 6909           50                         push	ax
23843                                           ! Debug: func () void = _write_byte+0 (used reg = )
23844 690A           E8         9CF3            call	__write_byte
23845 690D           83C4                   06  add	sp,*6
23846                                           !BCC_EOS
23847                                           ! 4141   if( (( ELDX & 0x00ff ) < 0xE0) || (( ELDX & 0x00ff ) >= 0xE0+(4*2)) ) {
23848                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$E] (used reg = )
23849 6910           8A46         10            mov	al,$10[bp]
23850                                           ! Debug: lt int = const $E0 to unsigned char = al+0 (used reg = )
23851 6913           3C                     E0  cmp	al,#$E0
23852 6915           72           07            jb  	.5B8
23853                       00006917            .5B9:
23854                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$E] (used reg = )
23855 6917           8A46         10            mov	al,$10[bp]
23856                                           ! Debug: ge int = const $E8 to unsigned char = al+0 (used reg = )
23857 691A           3C                     E8  cmp	al,#$E8
23858 691C           72           20            jb  	.5B7
23859                       0000691E            .5B8:
23860                                           ! 4142     bios_printf(4, "int13_cdrom: function %02x, ELDL out of range %02x\n", *(((Bit8u *)&AX)+1), ( ELDX & 0x00ff ));
23861                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$E] (used reg = )
23862 691E           8A46         10            mov	al,$10[bp]
23863                                           ! Debug: list unsigned char = al+0 (used reg = )
23864 6921           30E4                       xor	ah,ah
23865 6923           50                         push	ax
23866                                           ! Debug: list unsigned char AX = [S+$22+$17] (used reg = )
23867 6924           8A46         19            mov	al,$19[bp]
23868 6927           30E4                       xor	ah,ah
23869 6929           50                         push	ax
23870                                           ! Debug: list * char = .5BA+0 (used reg = )
23871 692A           BB                   D00A  mov	bx,#.5BA
23872 692D           53                         push	bx
23873                                           ! Debug: list int = const 4 (used reg = )
23874 692E           B8                   0004  mov	ax,*4
23875 6931           50                         push	ax
23876                                           ! Debug: func () void = bios_printf+0 (used reg = )
23877 6932           E8         A009            call	_bios_printf
23878 6935           83C4                   08  add	sp,*8
23879                                           !BCC_EOS
23880                                           ! 4143     goto int13_fail;
23881 6938           83C4                   00  add	sp,#..FFEB+$20
23882 693B           E9         0469            br 	.FFEB
23883                                           !BCC_EOS
23884                                           ! 4144   }
23885                                           ! 4145   device=*((Bit8u *)(&((ebda_data_t *) 0)->ata.cdidmap[( ELDX & 0x00ff )-0xE0]));
23886                       0000693E            .5B7:
23887                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$E] (used reg = )
23888 693E           8A46         10            mov	al,$10[bp]
23889                                           ! Debug: sub int = const $E0 to unsigned char = al+0 (used reg = )
23890 6941           30E4                       xor	ah,ah
23891                                           ! Debug: ptradd unsigned int = ax-$E0 to [8] unsigned char = const $23C (used reg = )
23892 6943           05                   FF20  add	ax,#-$E0
23893 6946           89C3                       mov	bx,ax
23894                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
23895                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$23C (used reg = )
23896                                           ! Debug: eq unsigned char = [bx+$23C] to unsigned char device = [S+$20-3] (used reg = )
23897 6948           8A87       023C            mov	al,$23C[bx]
23898 694C           8846         FF            mov	-1[bp],al
23899                                           !BCC_EOS
23900                                           ! 4146   if (device >= (4*2)) {
23901                                           ! Debug: ge int = const 8 to unsigned char device = [S+$20-3] (used reg = )
23902 694F           8A46         FF            mov	al,-1[bp]
23903 6952           3C                     08  cmp	al,*8
23904 6954           72           20            jb  	.5BB
23905                       00006956            .5BC:
23906                                           ! 4147     bios_printf(4, "int13_cdrom: function %02x, unmapped device for ELDL=%02x\n", *(((Bit8u *)&AX)+1), ( ELDX & 0x00ff ));
23907                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$E] (used reg = )
23908 6956           8A46         10            mov	al,$10[bp]
23909                                           ! Debug: list unsigned char = al+0 (used reg = )
23910 6959           30E4                       xor	ah,ah
23911 695B           50                         push	ax
23912                                           ! Debug: list unsigned char AX = [S+$22+$17] (used reg = )
23913 695C           8A46         19            mov	al,$19[bp]
23914 695F           30E4                       xor	ah,ah
23915 6961           50                         push	ax
23916                                           ! Debug: list * char = .5BD+0 (used reg = )
23917 6962           BB                   CFCF  mov	bx,#.5BD
23918 6965           53                         push	bx
23919                                           ! Debug: list int = const 4 (used reg = )
23920 6966           B8                   0004  mov	ax,*4
23921 6969           50                         push	ax
23922                                           ! Debug: func () void = bios_printf+0 (used reg = )
23923 696A           E8         9FD1            call	_bios_printf
23924 696D           83C4                   08  add	sp,*8
23925                                           !BCC_EOS
23926                                           ! 4148     goto int13_fail;
23927 6970           83C4                   00  add	sp,#..FFEB+$20
23928 6973           E9         0431            br 	.FFEB
23929                                           !BCC_EOS
23930                                           ! 4149   }
23931                                           ! 4150   switch (*(((Bit8u *)&AX)+1)) {
23932                       00006976            .5BB:
23933 6976           8A46         19            mov	al,$19[bp]
23934 6979           E9         03B0            br 	.5C0
23935                                           ! 4151     case 0x00:
23936                                           ! 4152     case 0x09:
23937                       0000697C            .5C1:
23938                                           ! 4153     case 0x0c:
23939                       0000697C            .5C2:
23940                                           ! 4154     case 0x0d:
23941                       0000697C            .5C3:
23942                                           ! 4155     case 0x10:
23943                       0000697C            .5C4:
23944                                           ! 4156     case 0x11:
23945                       0000697C            .5C5:
23946                                           ! 4157     case 0x14:
23947                       0000697C            .5C6:
23948                                           ! 4158     case 0x16:
23949                       0000697C            .5C7:
23950                                           ! 4159       goto int13_success;
23951                       0000697C            .5C8:
23952 697C           83C4                   00  add	sp,#..FFE9-..FFEA
23953 697F           E9         044A            br 	.FFE9
23954                                           !BCC_EOS
23955                                           ! 4160       break;
23956 6982           E9         0422            br 	.5BE
23957                                           !BCC_EOS
23958                                           ! 4161  
23959                                           ! 4161    case 0x03:
23960                                           ! 4162     case 0x05:
23961                       00006985            .5C9:
23962                                           ! 4163     case 0x43:
23963                       00006985            .5CA:
23964                                           ! 4164       *(((Bit8u *)&AX)+1) = (0x03);
23965                       00006985            .5CB:
23966                                           ! Debug: eq int = const 3 to unsigned char AX = [S+$20+$17] (used reg = )
23967 6985           B0                     03  mov	al,*3
23968 6987           8846         19            mov	$19[bp],al
23969                                           !BCC_EOS
23970                                           ! 4165       goto int13_fail_noah;
23971 698A           83C4                   00  add	sp,#..FFE8-..FFEA
23972 698D           E9         041C            br 	.FFE8
23973                                           !BCC_EOS
23974                                           ! 4166       break;
23975 6990           E9         0414            br 	.5BE
23976                                           !BCC_EOS
23977                                           ! 4167     case 0x01:
23978                                           ! 4168       status = _read_byte(0x0074, 0x0040);
23979                       00006993            .5CC:
23980                                           ! Debug: list int = const $40 (used reg = )
23981 6993           B8                   0040  mov	ax,*$40
23982 6996           50                         push	ax
23983                                           ! Debug: list int = const $74 (used reg = )
23984 6997           B8                   0074  mov	ax,*$74
23985 699A           50                         push	ax
23986                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
23987 699B           E8         9C46            call	__read_byte
23988 699E           83C4                   04  add	sp,*4
23989                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$20-4] (used reg = )
23990 69A1           8846         FE            mov	-2[bp],al
23991                                           !BCC_EOS
23992                                           ! 4169       *(((Bit8u *)&AX)+1) = (status);
23993                                           ! Debug: eq unsigned char status = [S+$20-4] to unsigned char AX = [S+$20+$17] (used reg = )
23994 69A4           8A46         FE            mov	al,-2[bp]
23995 69A7           8846         19            mov	$19[bp],al
23996                                           !BCC_EOS
23997                                           ! 4170       _write_byte(0, 0x0074, 0x0040);
23998                                           ! Debug: list int = const $40 (used reg = )
23999 69AA           B8                   0040  mov	ax,*$40
24000 69AD           50                         push	ax
24001                                           ! Debug: list int = const $74 (used reg = )
24002 69AE           B8                   0074  mov	ax,*$74
24003 69B1           50                         push	ax
24004                                           ! Debug: list int = const 0 (used reg = )
24005 69B2           31C0                       xor	ax,ax
24006 69B4           50                         push	ax
24007                                           ! Debug: func () void = _write_byte+0 (used reg = )
24008 69B5           E8         9C48            call	__write_byte
24009 69B8           83C4                   06  add	sp,*6
24010                                           !BCC_EOS
24011                                           ! 4171       if (status) goto int13_fail_nostatus;
24012 69BB           8A46         FE            mov	al,-2[bp]
24013 69BE           84C0                       test	al,al
24014 69C0           74           08            je  	.5CD
24015                       000069C2            .5CE:
24016 69C2           83C4                   00  add	sp,#..FFE7-..FFEA
24017 69C5           E9         03F8            br 	.FFE7
24018                                           !BCC_EOS
24019                                           ! 4172       else goto int13_success_noah;
24020 69C8           EB           06            jmp .5CF
24021                       000069CA            .5CD:
24022 69CA           83C4                   00  add	sp,#..FFE6-..FFEA
24023 69CD           E9         0401            br 	.FFE6
24024                                           !BCC_EOS
24025                                           ! 4173       break;
24026                       000069D0            .5CF:
24027 69D0           E9         03D4            br 	.5BE
24028                                           !BCC_EOS
24029                                           ! 4174     case 0x15:
24030                                           ! 4175       *(((Bit8u *)&AX)+1) = (0x02);
24031                       000069D3            .5D0:
24032                                           ! Debug: eq int = const 2 to unsigned char AX = [S+$20+$17] (used reg = )
24033 69D3           B0                     02  mov	al,*2
24034 69D5           8846         19            mov	$19[bp],al
24035                                           !BCC_EOS
24036                                           ! 4176       goto int13_fail_noah;
24037 69D8           83C4                   00  add	sp,#..FFE8-..FFEA
24038 69DB           E9         03CE            br 	.FFE8
24039                                           !BCC_EOS
24040                                           ! 4177       break;
24041 69DE           E9         03C6            br 	.5BE
24042                                           !BCC_EOS
24043                                           ! 4178     case 0x41:
24044                                           ! 4179       BX=0xaa55;
24045                       000069E1            .5D1:
24046                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$20+$10] (used reg = )
24047 69E1           B8                   AA55  mov	ax,#$AA55
24048 69E4           8946         12            mov	$12[bp],ax
24049                                           !BCC_EOS
24050                                           ! 4180       *(((Bit8u *)&AX)+1) = (0x30);
24051                                           ! Debug: eq int = const $30 to unsigned char AX = [S+$20+$17] (used reg = )
24052 69E7           B0                     30  mov	al,*$30
24053 69E9           8846         19            mov	$19[bp],al
24054                                           !BCC_EOS
24055                                           ! 4181       CX=0x0007;
24056                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$20+$14] (used reg = )
24057 69EC           B8                   0007  mov	ax,*7
24058 69EF           8946         16            mov	$16[bp],ax
24059                                           !BCC_EOS
24060                                           ! 4182       goto int13_success_noah;
24061 69F2           83C4                   00  add	sp,#..FFE6-..FFEA
24062 69F5           E9         03D9            br 	.FFE6
24063                                           !BCC_EOS
24064                                           ! 4183       break;
24065 69F8           E9         03AC            br 	.5BE
24066                                           !BCC_EOS
24067                                           ! 4184     case 0x42:
24068                                           ! 4185     case 0x44:
24069                       000069FB            .5D2:
24070                                           ! 4186     case 0x47:
24071                       000069FB            .5D3:
24072                                           ! 4187       count=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->count, DS);
24073                       000069FB            .5D4:
24074                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24075 69FB           FF76         06            push	6[bp]
24076                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$22+$A] (used reg = )
24077 69FE           8B46         0C            mov	ax,$C[bp]
24078                                           ! Debug: list unsigned int = ax+2 (used reg = )
24079 6A01           40                         inc	ax
24080 6A02           40                         inc	ax
24081 6A03           50                         push	ax
24082                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
24083 6A04           E8         9BEB            call	__read_word
24084 6A07           83C4                   04  add	sp,*4
24085                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$20-$18] (used reg = )
24086 6A0A           8946         EA            mov	-$16[bp],ax
24087                                           !BCC_EOS
24088                                           ! 4188       segment=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->segment, DS);
24089                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24090 6A0D           FF76         06            push	6[bp]
24091                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$22+$A] (used reg = )
24092 6A10           8B46         0C            mov	ax,$C[bp]
24093                                           ! Debug: list unsigned int = ax+6 (used reg = )
24094 6A13           05                   0006  add	ax,*6
24095 6A16           50                         push	ax
24096                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
24097 6A17           E8         9BD8            call	__read_word
24098 6A1A           83C4                   04  add	sp,*4
24099                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$20-$1A] (used reg = )
24100 6A1D           8946         E8            mov	-$18[bp],ax
24101                                           !BCC_EOS
24102                                           ! 4189       offset=_read_word(SI+(Bit16u)&((int13ext_t *) 0)->offset, DS);
24103                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24104 6A20           FF76         06            push	6[bp]
24105                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$22+$A] (used reg = )
24106 6A23           8B46         0C            mov	ax,$C[bp]
24107                                           ! Debug: list unsigned int = ax+4 (used reg = )
24108 6A26           05                   0004  add	ax,*4
24109 6A29           50                         push	ax
24110                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
24111 6A2A           E8         9BC5            call	__read_word
24112 6A2D           83C4                   04  add	sp,*4
24113                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$20-$1C] (used reg = )
24114 6A30           8946         E6            mov	-$1A[bp],ax
24115                                           !BCC_EOS
24116                                           ! 4190       lba=_read_dword(SI+(Bit16u)&((int13ext_t *) 0)->lba2, DS);
24117                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24118 6A33           FF76         06            push	6[bp]
24119                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$22+$A] (used reg = )
24120 6A36           8B46         0C            mov	ax,$C[bp]
24121                                           ! Debug: list unsigned int = ax+$C (used reg = )
24122 6A39           05                   000C  add	ax,*$C
24123 6A3C           50                         push	ax
24124                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
24125 6A3D           E8         9616            call	__read_dword
24126 6A40           89D3                       mov	bx,dx
24127 6A42           83C4                   04  add	sp,*4
24128                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$20-$16] (used reg = )
24129 6A45           8946         EC            mov	-$14[bp],ax
24130 6A48           895E         EE            mov	-$12[bp],bx
24131                                           !BCC_EOS
24132                                           ! 4191       if (lba != 0L) {
24133                                           ! Debug: ne long = const 0 to unsigned long lba = [S+$20-$16] (used reg = )
24134                                           ! Debug: expression subtree swapping
24135 6A4B           31C0                       xor	ax,ax
24136 6A4D           31DB                       xor	bx,bx
24137 6A4F           53                         push	bx
24138 6A50           50                         push	ax
24139 6A51           8B46         EC            mov	ax,-$14[bp]
24140 6A54           8B5E         EE            mov	bx,-$12[bp]
24141 6A57           8D7E         DE            lea	di,-2+..FFEA[bp]
24142 6A5A           E8         963F            call	lcmpul
24143 6A5D           8D66         E2            lea	sp,2+..FFEA[bp]
24144 6A60           74           1A            je  	.5D5
24145                       00006A62            .5D6:
24146                                           ! 4192         bios_printf((2 | 4 | 1), "int13_cdrom: function %02x. Can't use 64bits lba\n",*(((Bit8u *)&AX)+1));
24147                                           ! Debug: list unsigned char AX = [S+$20+$17] (used reg = )
24148 6A62           8A46         19            mov	al,$19[bp]
24149 6A65           30E4                       xor	ah,ah
24150 6A67           50                         push	ax
24151                                           ! Debug: list * char = .5D7+0 (used reg = )
24152 6A68           BB                   CF9D  mov	bx,#.5D7
24153 6A6B           53                         push	bx
24154                                           ! Debug: list int = const 7 (used reg = )
24155 6A6C           B8                   0007  mov	ax,*7
24156 6A6F           50                         push	ax
24157                                           ! Debug: func () void = bios_printf+0 (used reg = )
24158 6A70           E8         9ECB            call	_bios_printf
24159 6A73           83C4                   06  add	sp,*6
24160                                           !BCC_EOS
24161                                           ! 4193         goto int13_fail;
24162 6A76           83C4                   00  add	sp,#..FFEB-..FFEA
24163 6A79           E9         032B            br 	.FFEB
24164                                           !BCC_EOS
24165                                           ! 4194       }
24166                                           ! 4195       lba=_read_dword(SI+(Bit16u)&((int13ext_t *) 0)->lba1, DS);
24167                       00006A7C            .5D5:
24168                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24169 6A7C           FF76         06            push	6[bp]
24170                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$22+$A] (used reg = )
24171 6A7F           8B46         0C            mov	ax,$C[bp]
24172                                           ! Debug: list unsigned int = ax+8 (used reg = )
24173 6A82           05                   0008  add	ax,*8
24174 6A85           50                         push	ax
24175                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
24176 6A86           E8         95CD            call	__read_dword
24177 6A89           89D3                       mov	bx,dx
24178 6A8B           83C4                   04  add	sp,*4
24179                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$20-$16] (used reg = )
24180 6A8E           8946         EC            mov	-$14[bp],ax
24181 6A91           895E         EE            mov	-$12[bp],bx
24182                                           !BCC_EOS
24183                                           ! 4196       if ((*(((Bit8u *)&AX)+1) == 0x44) || (*(((Bit8u *)&AX)+1) == 0x47))
24184                                           ! Debug: logeq int = const $44 to unsigned char AX = [S+$20+$17] (used reg = )
24185 6A94           8A46         19            mov	al,$19[bp]
24186 6A97           3C                     44  cmp	al,*$44
24187 6A99           74           07            je  	.5D9
24188                       00006A9B            .5DA:
24189                                           ! Debug: logeq int = const $47 to unsigned char AX = [S+$20+$17] (used reg = )
24190 6A9B           8A46         19            mov	al,$19[bp]
24191 6A9E           3C                     47  cmp	al,*$47
24192 6AA0           75           06            jne 	.5D8
24193                       00006AA2            .5D9:
24194                                           ! 4197         goto int13_success;
24195 6AA2           83C4                   00  add	sp,#..FFE9-..FFEA
24196 6AA5           E9         0324            br 	.FFE9
24197                                           !BCC_EOS
24198                                           ! 4198       _memsetb(0,atacmd,get_SS(),12);
24199                       00006AA8            .5D8:
24200                                           ! Debug: list int = const $C (used reg = )
24201 6AA8           B8                   000C  mov	ax,*$C
24202 6AAB           50                         push	ax
24203                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
24204 6AAC           E8         9BB0            call	_get_SS
24205                                           ! Debug: list unsigned short = ax+0 (used reg = )
24206 6AAF           50                         push	ax
24207                                           ! Debug: list * unsigned char atacmd = S+$24-$11 (used reg = )
24208 6AB0           8D5E         F1            lea	bx,-$F[bp]
24209 6AB3           53                         push	bx
24210                                           ! Debug: list int = const 0 (used reg = )
24211 6AB4           31C0                       xor	ax,ax
24212 6AB6           50                         push	ax
24213                                           ! Debug: func () void = _memsetb+0 (used reg = )
24214 6AB7           E8         9546            call	__memsetb
24215 6ABA           83C4                   08  add	sp,*8
24216                                           !BCC_EOS
24217                                           ! 4199       atacmd[0]=0x28;
24218                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$20-$11] (used reg = )
24219 6ABD           B0                     28  mov	al,*$28
24220 6ABF           8846         F1            mov	-$F[bp],al
24221                                           !BCC_EOS
24222                                           ! 4200       atacmd[7]=*(((Bit8u *)&count)+1);
24223                                           ! Debug: eq unsigned char count = [S+$20-$17] to unsigned char atacmd = [S+$20-$A] (used reg = )
24224 6AC2           8A46         EB            mov	al,-$15[bp]
24225 6AC5           8846         F8            mov	-8[bp],al
24226                                           !BCC_EOS
24227                                           ! 4201       atacmd[8]=*((Bit8u *)&count);
24228                                           ! Debug: eq unsigned char count = [S+$20-$18] to unsigned char atacmd = [S+$20-9] (used reg = )
24229 6AC8           8A46         EA            mov	al,-$16[bp]
24230 6ACB           8846         F9            mov	-7[bp],al
24231                                           !BCC_EOS
24232                                           ! 4202       atacmd[2]=*(((Bit8u *)&*(((Bit16u *)&lba)+1))+1);
24233                                           ! Debug: eq unsigned char lba = [S+$20-$13] to unsigned char atacmd = [S+$20-$F] (used reg = )
24234 6ACE           8A46         EF            mov	al,-$11[bp]
24235 6AD1           8846         F3            mov	-$D[bp],al
24236                                           !BCC_EOS
24237                                           ! 4203       atacmd[3]=*((Bit8u *)&*(((Bit16u *)&lba)+1));
24238                                           ! Debug: eq unsigned char lba = [S+$20-$14] to unsigned char atacmd = [S+$20-$E] (used reg = )
24239 6AD4           8A46         EE            mov	al,-$12[bp]
24240 6AD7           8846         F4            mov	-$C[bp],al
24241                                           !BCC_EOS
24242                                           ! 4204       atacmd[4]=*(((Bit8u *)&*((Bit16u *)&lba))+1);
24243                                           ! Debug: eq unsigned char lba = [S+$20-$15] to unsigned char atacmd = [S+$20-$D] (used reg = )
24244 6ADA           8A46         ED            mov	al,-$13[bp]
24245 6ADD           8846         F5            mov	-$B[bp],al
24246                                           !BCC_EOS
24247                                           ! 4205       atacmd[5]=*((Bit8u *)&lba);
24248                                           ! Debug: eq unsigned char lba = [S+$20-$16] to unsigned char atacmd = [S+$20-$C] (used reg = )
24249 6AE0           8A46         EC            mov	al,-$14[bp]
24250 6AE3           8846         F6            mov	-$A[bp],al
24251                                           !BCC_EOS
24252                                           ! 4206       status = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, count*2048L, 0x01, segment,offset);
24253                                           ! Debug: list unsigned short offset = [S+$20-$1C] (used reg = )
24254 6AE6           FF76         E6            push	-$1A[bp]
24255                                           ! Debug: list unsigned short segment = [S+$22-$1A] (used reg = )
24256 6AE9           FF76         E8            push	-$18[bp]
24257                                           ! Debug: list int = const 1 (used reg = )
24258 6AEC           B8                   0001  mov	ax,*1
24259 6AEF           50                         push	ax
24260                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$26-$18] (used reg = )
24261 6AF0           8B46         EA            mov	ax,-$16[bp]
24262 6AF3           31DB                       xor	bx,bx
24263                                           ! Debug: mul long = const $800 to unsigned long = bx+0 (used reg = )
24264 6AF5           53                         push	bx
24265 6AF6           50                         push	ax
24266 6AF7           B8                   0800  mov	ax,#$800
24267 6AFA           31DB                       xor	bx,bx
24268 6AFC           53                         push	bx
24269 6AFD           50                         push	ax
24270 6AFE           8B46         D8            mov	ax,-8+..FFEA[bp]
24271 6B01           8B5E         DA            mov	bx,-6+..FFEA[bp]
24272 6B04           8D7E         D4            lea	di,-$C+..FFEA[bp]
24273 6B07           E8         95B0            call	lmulul
24274 6B0A           83C4                   08  add	sp,*8
24275                                           ! Debug: list unsigned long = bx+0 (used reg = )
24276 6B0D           53                         push	bx
24277 6B0E           50                         push	ax
24278                                           ! Debug: list int = const 0 (used reg = )
24279 6B0F           31C0                       xor	ax,ax
24280 6B11           50                         push	ax
24281                                           ! Debug: list * unsigned char atacmd = S+$2C-$11 (used reg = )
24282 6B12           8D5E         F1            lea	bx,-$F[bp]
24283 6B15           53                         push	bx
24284                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
24285 6B16           E8         9B46            call	_get_SS
24286                                           ! Debug: list unsigned short = ax+0 (used reg = )
24287 6B19           50                         push	ax
24288                                           ! Debug: list int = const $C (used reg = )
24289 6B1A           B8                   000C  mov	ax,*$C
24290 6B1D           50                         push	ax
24291                                           ! Debug: list unsigned char device = [S+$32-3] (used reg = )
24292 6B1E           8A46         FF            mov	al,-1[bp]
24293 6B21           30E4                       xor	ah,ah
24294 6B23           50                         push	ax
24295                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
24296 6B24           E8         C223            call	_ata_cmd_packet
24297 6B27           83C4                   14  add	sp,*$14
24298                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$20-4] (used reg = )
24299 6B2A           8846         FE            mov	-2[bp],al
24300                                           !BCC_EOS
24301                                           ! 4207       count = (Bit16u)(*((Bit32u *)(&((ebda_data_t *) 0)->ata.trsfbytes)) >> 11);
24302                                           ! Debug: sr int = const $B to unsigned long = [+$256] (used reg = )
24303 6B2D           A1         0256            mov	ax,[$256]
24304 6B30           8B1E       0258            mov	bx,[$258]
24305 6B34           88E0                       mov	al,ah
24306 6B36           88DC                       mov	ah,bl
24307 6B38           88FB                       mov	bl,bh
24308 6B3A           28FF                       sub	bh,bh
24309 6B3C           BF                   0003  mov	di,*3
24310 6B3F           E8         95B8            call	lsrul
24311                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
24312                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$20-$18] (used reg = )
24313 6B42           8946         EA            mov	-$16[bp],ax
24314                                           !BCC_EOS
24315                                           ! 4208       _write_word(count, SI+(Bit16u)&((int13ext_t *) 0)->count, DS);
24316                                           ! Debug: list unsigned short DS = [S+$20+4] (used reg = )
24317 6B45           FF76         06            push	6[bp]
24318                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$22+$A] (used reg = )
24319 6B48           8B46         0C            mov	ax,$C[bp]
24320                                           ! Debug: list unsigned int = ax+2 (used reg = )
24321 6B4B           40                         inc	ax
24322 6B4C           40                         inc	ax
24323 6B4D           50                         push	ax
24324                                           ! Debug: list unsigned short count = [S+$24-$18] (used reg = )
24325 6B4E           FF76         EA            push	-$16[bp]
24326                                           ! Debug: func () void = _write_word+0 (used reg = )
24327 6B51           E8         9ABF            call	__write_word
24328 6B54           83C4                   06  add	sp,*6
24329                                           !BCC_EOS
24330                                           ! 4209       if (status != 0) {
24331                                           ! Debug: ne int = const 0 to unsigned char status = [S+$20-4] (used reg = )
24332 6B57           8A46         FE            mov	al,-2[bp]
24333 6B5A           84C0                       test	al,al
24334 6B5C           74           25            je  	.5DB
24335                       00006B5E            .5DC:
24336                                           ! 4210         bios_printf(4, "int13_cdrom: function %02x, status %02x !\n",*(((Bit8u *)&AX)+1),status);
24337                                           ! Debug: list unsigned char status = [S+$20-4] (used reg = )
24338 6B5E           8A46         FE            mov	al,-2[bp]
24339 6B61           30E4                       xor	ah,ah
24340 6B63           50                         push	ax
24341                                           ! Debug: list unsigned char AX = [S+$22+$17] (used reg = )
24342 6B64           8A46         19            mov	al,$19[bp]
24343 6B67           30E4                       xor	ah,ah
24344 6B69           50                         push	ax
24345                                           ! Debug: list * char = .5DD+0 (used reg = )
24346 6B6A           BB                   CF72  mov	bx,#.5DD
24347 6B6D           53                         push	bx
24348                                           ! Debug: list int = const 4 (used reg = )
24349 6B6E           B8                   0004  mov	ax,*4
24350 6B71           50                         push	ax
24351                                           ! Debug: func () void = bios_printf+0 (used reg = )
24352 6B72           E8         9DC9            call	_bios_printf
24353 6B75           83C4                   08  add	sp,*8
24354                                           !BCC_EOS
24355                                           ! 4211         *(((Bit8u *)&AX)+1) = (0x0c);
24356                                           ! Debug: eq int = const $C to unsigned char AX = [S+$20+$17] (used reg = )
24357 6B78           B0                     0C  mov	al,*$C
24358 6B7A           8846         19            mov	$19[bp],al
24359                                           !BCC_EOS
24360                                           ! 4212         goto int13_fail_noah;
24361 6B7D           83C4                   00  add	sp,#..FFE8-..FFEA
24362 6B80           E9         0229            br 	.FFE8
24363                                           !BCC_EOS
24364                                           ! 4213       }
24365                                           ! 4214       goto int13_success;
24366                       00006B83            .5DB:
24367 6B83           83C4                   00  add	sp,#..FFE9-..FFEA
24368 6B86           E9         0243            br 	.FFE9
24369                                           !BCC_EOS
24370                                           ! 4215       break;
24371 6B89           E9         021B            br 	.5BE
24372                                           !BCC_EOS
24373                                           ! 4216     case 0x45
24374                                           ! 4216 :
24375                                           ! 4217       if (( AX & 0x00ff ) > 2) goto int13_fail;
24376                       00006B8C            .5DE:
24377                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$16] (used reg = )
24378 6B8C           8A46         18            mov	al,$18[bp]
24379                                           ! Debug: gt int = const 2 to unsigned char = al+0 (used reg = )
24380 6B8F           3C                     02  cmp	al,*2
24381 6B91           76           06            jbe 	.5DF
24382                       00006B93            .5E0:
24383 6B93           83C4                   00  add	sp,#..FFEB-..FFEA
24384 6B96           E9         020E            br 	.FFEB
24385                                           !BCC_EOS
24386                                           ! 4218       locks = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].lock));
24387                       00006B99            .5DF:
24388                                           ! Debug: ptradd unsigned char device = [S+$20-3] to [8] struct  = const $142 (used reg = )
24389 6B99           8A46         FF            mov	al,-1[bp]
24390 6B9C           30E4                       xor	ah,ah
24391 6B9E           B9                   001E  mov	cx,*$1E
24392 6BA1           F7E9                       imul	cx
24393 6BA3           89C3                       mov	bx,ax
24394                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
24395                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$145 (used reg = )
24396                                           ! Debug: eq unsigned char = [bx+$145] to unsigned char locks = [S+$20-5] (used reg = )
24397 6BA5           8A87       0145            mov	al,$145[bx]
24398 6BA9           8846         FD            mov	-3[bp],al
24399                                           !BCC_EOS
24400                                           ! 4219       switch (( AX & 0x00ff )) {
24401                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$16] (used reg = )
24402 6BAC           8A46         18            mov	al,$18[bp]
24403 6BAF           E9         0095            br 	.5E3
24404                                           ! 4220         case 0 :
24405                                           ! 4221           if (locks == 0xff) {
24406                       00006BB2            .5E4:
24407                                           ! Debug: logeq int = const $FF to unsigned char locks = [S+$20-5] (used reg = )
24408 6BB2           8A46         FD            mov	al,-3[bp]
24409 6BB5           3C                     FF  cmp	al,#$FF
24410 6BB7           75           10            jne 	.5E5
24411                       00006BB9            .5E6:
24412                                           ! 4222             *(((Bit8u *)&AX)+1) = (0xb4);
24413                                           ! Debug: eq int = const $B4 to unsigned char AX = [S+$20+$17] (used reg = )
24414 6BB9           B0                     B4  mov	al,#$B4
24415 6BBB           8846         19            mov	$19[bp],al
24416                                           !BCC_EOS
24417                                           ! 4223             *((Bit8u *)&AX) = (1);
24418                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$20+$16] (used reg = )
24419 6BBE           B0                     01  mov	al,*1
24420 6BC0           8846         18            mov	$18[bp],al
24421                                           !BCC_EOS
24422                                           ! 4224             goto int13_fail_noah;
24423 6BC3           83C4                   00  add	sp,#..FFE8-..FFEA
24424 6BC6           E9         01E3            br 	.FFE8
24425                                           !BCC_EOS
24426                                           ! 4225           }
24427                                           ! 4226           *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].lock)) = (++locks);
24428                       00006BC9            .5E5:
24429                                           ! Debug: preinc unsigned char locks = [S+$20-5] (used reg = )
24430 6BC9           8A46         FD            mov	al,-3[bp]
24431 6BCC           40                         inc	ax
24432 6BCD           8846         FD            mov	-3[bp],al
24433 6BD0           50                         push	ax
24434                                           ! Debug: ptradd unsigned char device = [S+$22-3] to [8] struct  = const $142 (used reg = )
24435 6BD1           8A46         FF            mov	al,-1[bp]
24436 6BD4           30E4                       xor	ah,ah
24437 6BD6           B9                   001E  mov	cx,*$1E
24438 6BD9           F7E9                       imul	cx
24439 6BDB           89C3                       mov	bx,ax
24440                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
24441                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$145 (used reg = )
24442                                           ! Debug: eq unsigned char (temp) = [S+$22-$22] to unsigned char = [bx+$145] (used reg = )
24443 6BDD           8A46         E0            mov	al,0+..FFEA[bp]
24444 6BE0           8887       0145            mov	$145[bx],al
24445 6BE4           44                         inc	sp
24446 6BE5           44                         inc	sp
24447                                           !BCC_EOS
24448                                           ! 4227           *((Bit8u *)&AX) = (1);
24449                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$20+$16] (used reg = )
24450 6BE6           B0                     01  mov	al,*1
24451 6BE8           8846         18            mov	$18[bp],al
24452                                           !BCC_EOS
24453                                           ! 4228           break;
24454 6BEB           EB           68            jmp .5E1
24455                                           !BCC_EOS
24456                                           ! 4229         case 1 :
24457                                           ! 4230           if (locks == 0x00) {
24458                       00006BED            .5E7:
24459                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$20-5] (used reg = )
24460 6BED           8A46         FD            mov	al,-3[bp]
24461 6BF0           84C0                       test	al,al
24462 6BF2           75           10            jne 	.5E8
24463                       00006BF4            .5E9:
24464                                           ! 4231             *(((Bit8u *)&AX)+1) = (0xb0);
24465                                           ! Debug: eq int = const $B0 to unsigned char AX = [S+$20+$17] (used reg = )
24466 6BF4           B0                     B0  mov	al,#$B0
24467 6BF6           8846         19            mov	$19[bp],al
24468                                           !BCC_EOS
24469                                           ! 4232             *((Bit8u *)&AX) = (0);
24470                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$20+$16] (used reg = )
24471 6BF9           30C0                       xor	al,al
24472 6BFB           8846         18            mov	$18[bp],al
24473                                           !BCC_EOS
24474                                           ! 4233             goto int13_fail_noah;
24475 6BFE           83C4                   00  add	sp,#..FFE8-..FFEA
24476 6C01           E9         01A8            br 	.FFE8
24477                                           !BCC_EOS
24478                                           ! 4234           }
24479                                           ! 4235           *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].lock)) = (--locks);
24480                       00006C04            .5E8:
24481                                           ! Debug: predec unsigned char locks = [S+$20-5] (used reg = )
24482 6C04           8A46         FD            mov	al,-3[bp]
24483 6C07           48                         dec	ax
24484 6C08           8846         FD            mov	-3[bp],al
24485 6C0B           50                         push	ax
24486                                           ! Debug: ptradd unsigned char device = [S+$22-3] to [8] struct  = const $142 (used reg = )
24487 6C0C           8A46         FF            mov	al,-1[bp]
24488 6C0F           30E4                       xor	ah,ah
24489 6C11           B9                   001E  mov	cx,*$1E
24490 6C14           F7E9                       imul	cx
24491 6C16           89C3                       mov	bx,ax
24492                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
24493                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$145 (used reg = )
24494                                           ! Debug: eq unsigned char (temp) = [S+$22-$22] to unsigned char = [bx+$145] (used reg = )
24495 6C18           8A46         E0            mov	al,0+..FFEA[bp]
24496 6C1B           8887       0145            mov	$145[bx],al
24497 6C1F           44                         inc	sp
24498 6C20           44                         inc	sp
24499                                           !BCC_EOS
24500                                           ! 4236           *((Bit8u *)&AX) = (locks==0?0:1);
24501                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$20-5] (used reg = )
24502 6C21           8A46         FD            mov	al,-3[bp]
24503 6C24           84C0                       test	al,al
24504 6C26           75           04            jne 	.5EA
24505                       00006C28            .5EB:
24506 6C28           30C0                       xor	al,al
24507 6C2A           EB           02            jmp .5EC
24508                       00006C2C            .5EA:
24509 6C2C           B0                     01  mov	al,*1
24510                       00006C2E            .5EC:
24511                                           ! Debug: eq char = al+0 to unsigned char AX = [S+$20+$16] (used reg = )
24512 6C2E           8846         18            mov	$18[bp],al
24513                                           !BCC_EOS
24514                                           ! 4237           break;
24515 6C31           EB           22            jmp .5E1
24516                                           !BCC_EOS
24517                                           ! 4238         case 2 :
24518                                           ! 4239           *((Bit8u *)&AX) = (locks==0?0:1);
24519                       00006C33            .5ED:
24520                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$20-5] (used reg = )
24521 6C33           8A46         FD            mov	al,-3[bp]
24522 6C36           84C0                       test	al,al
24523 6C38           75           04            jne 	.5EE
24524                       00006C3A            .5EF:
24525 6C3A           30C0                       xor	al,al
24526 6C3C           EB           02            jmp .5F0
24527                       00006C3E            .5EE:
24528 6C3E           B0                     01  mov	al,*1
24529                       00006C40            .5F0:
24530                                           ! Debug: eq char = al+0 to unsigned char AX = [S+$20+$16] (used reg = )
24531 6C40           8846         18            mov	$18[bp],al
24532                                           !BCC_EOS
24533                                           ! 4240           break;
24534 6C43           EB           10            jmp .5E1
24535                                           !BCC_EOS
24536                                           ! 4241       }
24537                                           ! 4242       goto int13_success;
24538 6C45           EB           0E            jmp .5E1
24539                       00006C47            .5E3:
24540 6C47           2C                     00  sub	al,*0
24541 6C49         0F84         FF65            beq 	.5E4
24542 6C4D           2C                     01  sub	al,*1
24543 6C4F           74           9C            je 	.5E7
24544 6C51           2C                     01  sub	al,*1
24545 6C53           74           DE            je 	.5ED
24546                       00006C55            .5E1:
24547 6C55           83C4                   00  add	sp,#..FFE9-..FFEA
24548 6C58           E9         0171            br 	.FFE9
24549                                           !BCC_EOS
24550                                           ! 4243       break;
24551 6C5B           E9         0149            br 	.5BE
24552                                           !BCC_EOS
24553                                           ! 4244     case 0x46:
24554                                           ! 4245       locks = *((Bit8u *)(&((ebda_data_t *) 0)->ata.devices[device].lock));
24555                       00006C5E            .5F1:
24556                                           ! Debug: ptradd unsigned char device = [S+$20-3] to [8] struct  = const $142 (used reg = )
24557 6C5E           8A46         FF            mov	al,-1[bp]
24558 6C61           30E4                       xor	ah,ah
24559 6C63           B9                   001E  mov	cx,*$1E
24560 6C66           F7E9                       imul	cx
24561 6C68           89C3                       mov	bx,ax
24562                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
24563                                           ! Debug: cast * unsigned char = const 0 to * unsigned char = bx+$145 (used reg = )
24564                                           ! Debug: eq unsigned char = [bx+$145] to unsigned char locks = [S+$20-5] (used reg = )
24565 6C6A           8A87       0145            mov	al,$145[bx]
24566 6C6E           8846         FD            mov	-3[bp],al
24567                                           !BCC_EOS
24568                                           ! 4246       if (locks != 0) {
24569                                           ! Debug: ne int = const 0 to unsigned char locks = [S+$20-5] (used reg = )
24570 6C71           8A46         FD            mov	al,-3[bp]
24571 6C74           84C0                       test	al,al
24572 6C76           74           0B            je  	.5F2
24573                       00006C78            .5F3:
24574                                           ! 4247         *(((Bit8u *)&AX)+1) = (0xb1);
24575                                           ! Debug: eq int = const $B1 to unsigned char AX = [S+$20+$17] (used reg = )
24576 6C78           B0                     B1  mov	al,#$B1
24577 6C7A           8846         19            mov	$19[bp],al
24578                                           !BCC_EOS
24579                                           ! 4248         goto int13_fail_noah;
24580 6C7D           83C4                   00  add	sp,#..FFE8-..FFEA
24581 6C80           E9         0129            br 	.FFE8
24582                                           !BCC_EOS
24583                                           ! 4249       }
24584                                           ! 4250 #asm
24585                       00006C83            .5F2:
24586                                           !BCC_EOS
24587                                           !BCC_ASM
24588                       0000002C            _int13_cdrom.BP	set	$2C
24589                       0000000E            .int13_cdrom.BP	set	$E
24590                       00000022            _int13_cdrom.EHBX	set	$22
24591                       00000004            .int13_cdrom.EHBX	set	4
24592                       0000003A            _int13_cdrom.CS	set	$3A
24593                       0000001C            .int13_cdrom.CS	set	$1C
24594                       00000008            _int13_cdrom.count	set	8
24595                       FFFFFFEA            .int13_cdrom.count	set	-$16
24596                       00000034            _int13_cdrom.CX	set	$34
24597                       00000016            .int13_cdrom.CX	set	$16
24598                       00000006            _int13_cdrom.segment	set	6
24599                       FFFFFFE8            .int13_cdrom.segment	set	-$18
24600                       00000028            _int13_cdrom.DI	set	$28
24601                       0000000A            .int13_cdrom.DI	set	$A
24602                       0000003C            _int13_cdrom.FLAGS	set	$3C
24603                       0000001E            .int13_cdrom.FLAGS	set	$1E
24604                       00000024            _int13_cdrom.DS	set	$24
24605                       00000006            .int13_cdrom.DS	set	6
24606                       0000002E            _int13_cdrom.ELDX	set	$2E
24607                       00000010            .int13_cdrom.ELDX	set	$10
24608                       00000032            _int13_cdrom.DX	set	$32
24609                       00000014            .int13_cdrom.DX	set	$14
24610                       00000000            _int13_cdrom.size	set	0
24611                       FFFFFFE2            .int13_cdrom.size	set	-$1E
24612                       00000002            _int13_cdrom.i	set	2
24613                       FFFFFFE4            .int13_cdrom.i	set	-$1C
24614                       0000001D            _int13_cdrom.device	set	$1D
24615                       FFFFFFFF            .int13_cdrom.device	set	-1
24616                       00000026            _int13_cdrom.ES	set	$26
24617                       00000008            .int13_cdrom.ES	set	8
24618                       0000002A            _int13_cdrom.SI	set	$2A
24619                       0000000C            .int13_cdrom.SI	set	$C
24620                       00000038            _int13_cdrom.IP	set	$38
24621                       0000001A            .int13_cdrom.IP	set	$1A
24622                       0000000A            _int13_cdrom.lba	set	$A
24623                       FFFFFFEC            .int13_cdrom.lba	set	-$14
24624                       0000001C            _int13_cdrom.status	set	$1C
24625                       FFFFFFFE            .int13_cdrom.status	set	-2
24626                       0000000F            _int13_cdrom.atacmd	set	$F
24627                       FFFFFFF1            .int13_cdrom.atacmd	set	-$F
24628                       00000036            _int13_cdrom.AX	set	$36
24629                       00000018            .int13_cdrom.AX	set	$18
24630                       00000004            _int13_cdrom.offset	set	4
24631                       FFFFFFE6            .int13_cdrom.offset	set	-$1A
24632                       00000030            _int13_cdrom.BX	set	$30
24633                       00000012            .int13_cdrom.BX	set	$12
24634                       0000001B            _int13_cdrom.locks	set	$1B
24635                       FFFFFFFD            .int13_cdrom.locks	set	-3
24636 6C83           55                                 push bp
24637 6C84           89E5                               mov bp, sp
24638 6C86           B4                     52          mov ah, #0x52
24639 6C88           CD                     15          int #0x15
24640 6C8A           8866         1E                    mov _int13_cdrom.status + 2[bp], ah
24641 6C8D           73           06                    jnc int13_cdrom_rme_end
24642 6C8F           C706       001C      0001          mov _int13_cdrom.status, #1
24643                       00006C95            int13_cdrom_rme_end:
24644 6C95           5D                                 pop bp
24645                                           ! 4260 endasm
24646                                           !BCC_ENDASM
24647                                           !BCC_EOS
24648                                           ! 4261       if (status != 0) {
24649                                           ! Debug: ne int = const 0 to unsigned char status = [S+$20-4] (used reg = )
24650 6C96           8A46         FE            mov	al,-2[bp]
24651 6C99           84C0                       test	al,al
24652 6C9B           74           0B            je  	.5F4
24653                       00006C9D            .5F5:
24654                                           ! 4262         *(((Bit8u *)&AX)+1) = (0xb1);
24655                                           ! Debug: eq int = const $B1 to unsigned char AX = [S+$20+$17] (used reg = )
24656 6C9D           B0                     B1  mov	al,#$B1
24657 6C9F           8846         19            mov	$19[bp],al
24658                                           !BCC_EOS
24659                                           ! 4263         goto int13_fail_noah;
24660 6CA2           83C4                   00  add	sp,#..FFE8-..FFEA
24661 6CA5           E9         0104            br 	.FFE8
24662                                           !BCC_EOS
24663                                           ! 4264       }
24664                                           ! 4265       goto int13_success;
24665                       00006CA8            .5F4:
24666 6CA8           83C4                   00  add	sp,#..FFE9-..FFEA
24667 6CAB           E9         011E            br 	.FFE9
24668                                           !BCC_EOS
24669                                           ! 4266       break;
24670 6CAE           E9         00F6            br 	.5BE
24671                                           !BCC_EOS
24672                                           ! 4267     case 0x48:
24673                                           ! 4268       if (int13_edd(DS, SI, device))
24674                       00006CB1            .5F6:
24675                                           ! Debug: list unsigned char device = [S+$20-3] (used reg = )
24676 6CB1           8A46         FF            mov	al,-1[bp]
24677 6CB4           30E4                       xor	ah,ah
24678 6CB6           50                         push	ax
24679                                           ! Debug: list unsigned short SI = [S+$22+$A] (used reg = )
24680 6CB7           FF76         0C            push	$C[bp]
24681                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
24682 6CBA           FF76         06            push	6[bp]
24683                                           ! Debug: func () int = int13_edd+0 (used reg = )
24684 6CBD           E8         EE11            call	_int13_edd
24685 6CC0           83C4                   06  add	sp,*6
24686 6CC3           85C0                       test	ax,ax
24687 6CC5           74           06            je  	.5F7
24688                       00006CC7            .5F8:
24689                                           ! 4269         goto int13_fail;
24690 6CC7           83C4                   00  add	sp,#..FFEB-..FFEA
24691 6CCA           E9         00DA            br 	.FFEB
24692                                           !BCC_EOS
24693                                           ! 4270       goto int13_success;
24694                       00006CCD            .5F7:
24695 6CCD           83C4                   00  add	sp,#..FFE9-..FFEA
24696 6CD0           E9         00F9            br 	.FFE9
24697                                           !BCC_EOS
24698                                           ! 4271       break;
24699 6CD3           E9         00D1            br 	.5BE
24700                                           !BCC_EOS
24701                                           ! 4272     case 0x49:
24702                                           ! 4273       *(((Bit8u *)&AX)+1) = (06);
24703                       00006CD6            .5F9:
24704                                           ! Debug: eq int = const 6 to unsigned char AX = [S+$20+$17] (used reg = )
24705 6CD6           B0                     06  mov	al,*6
24706 6CD8           8846         19            mov	$19[bp],al
24707                                           !BCC_EOS
24708                                           ! 4274       goto int13_fail_nostatus;
24709 6CDB           83C4                   00  add	sp,#..FFE7-..FFEA
24710 6CDE           E9         00DF            br 	.FFE7
24711                                           !BCC_EOS
24712                                           ! 4275       break;
24713 6CE1           E9         00C3            br 	.5BE
24714                                           !BCC_EOS
24715                                           ! 4276     case 0x4e:
24716                                           ! 4277       switch (( AX & 0x00ff )) {
24717                       00006CE4            .5FA:
24718                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$16] (used reg = )
24719 6CE4           8A46         18            mov	al,$18[bp]
24720 6CE7           EB           10            jmp .5FD
24721                                           ! 4278         case 0x01:
24722                                           ! 4279         case 0x03:
24723                       00006CE9            .5FE:
24724                                           ! 4280         case 0x04:
24725                       00006CE9            .5FF:
24726                                           ! 4281         case 0x06:
24727                       00006CE9            .600:
24728                                           ! 4282           goto int13_success;
24729                       00006CE9            .601:
24730 6CE9           83C4                   00  add	sp,#..FFE9-..FFEA
24731 6CEC           E9         00DD            br 	.FFE9
24732                                           !BCC_EOS
24733                                           ! 4283           break;
24734 6CEF           EB           1A            jmp .5FB
24735                                           !BCC_EOS
24736                                           ! 4284         default:
24737                                           ! 4285           goto int13_fail;
24738                       00006CF1            .602:
24739 6CF1           83C4                   00  add	sp,#..FFEB-..FFEA
24740 6CF4           E9         00B0            br 	.FFEB
24741                                           !BCC_EOS
24742                                           ! 4286       }
24743                                           ! 4287       break;
24744 6CF7           EB           12            jmp .5FB
24745                       00006CF9            .5FD:
24746 6CF9           2C                     01  sub	al,*1
24747 6CFB           74           EC            je 	.5FE
24748 6CFD           2C                     02  sub	al,*2
24749 6CFF           74           E8            je 	.5FF
24750 6D01           2C                     01  sub	al,*1
24751 6D03           74           E4            je 	.600
24752 6D05           2C                     02  sub	al,*2
24753 6D07           74           E0            je 	.601
24754 6D09           EB           E6            jmp	.602
24755                       00006D0B            .5FB:
24756 6D0B           E9         0099            br 	.5BE
24757                                           !BCC_EOS
24758                                           ! 4288     case 0x02:
24759                                           ! 4289     case 0x04:
24760                       00006D0E            .603:
24761                                           ! 4290     case 0x08:
24762                       00006D0E            .604:
24763                                           ! 4291     case 0x0a:
24764                       00006D0E            .605:
24765                                           ! 4292     case 0x0b:
24766                       00006D0E            .606:
24767                                           ! 4293     case 0x18:
24768                       00006D0E            .607:
24769                                           ! 4294     case 0x50:
24770                       00006D0E            .608:
24771                                           ! 4295     default:
24772                       00006D0E            .609:
24773                                           ! 4296       bios_p
24774                                           ! 4296 rintf(4, "int13_cdrom: unsupported AH=%02x\n", *(((Bit8u *)&AX)+1));
24775                       00006D0E            .60A:
24776                                           ! Debug: list unsigned char AX = [S+$20+$17] (used reg = )
24777 6D0E           8A46         19            mov	al,$19[bp]
24778 6D11           30E4                       xor	ah,ah
24779 6D13           50                         push	ax
24780                                           ! Debug: list * char = .60B+0 (used reg = )
24781 6D14           BB                   CF50  mov	bx,#.60B
24782 6D17           53                         push	bx
24783                                           ! Debug: list int = const 4 (used reg = )
24784 6D18           B8                   0004  mov	ax,*4
24785 6D1B           50                         push	ax
24786                                           ! Debug: func () void = bios_printf+0 (used reg = )
24787 6D1C           E8         9C1F            call	_bios_printf
24788 6D1F           83C4                   06  add	sp,*6
24789                                           !BCC_EOS
24790                                           ! 4297       goto int13_fail;
24791 6D22           83C4                   00  add	sp,#..FFEB-..FFEA
24792 6D25           E9         007F            jmp .FFEB
24793                                           !BCC_EOS
24794                                           ! 4298       break;
24795 6D28           EB           7D            jmp .5BE
24796                                           !BCC_EOS
24797                                           ! 4299   }
24798                                           ! 4300 int13_fail:
24799 6D2A           EB           7B            jmp .5BE
24800                       00006D2C            .5C0:
24801 6D2C           2C                     00  sub	al,*0
24802 6D2E           72           DE            jb 	.60A
24803 6D30           3C                     18  cmp	al,*$18
24804 6D32           77           3D            ja  	.60C
24805 6D34           30E4                       xor	ah,ah
24806 6D36           D1E0                       shl	ax,*1
24807 6D38           89C3                       mov	bx,ax
24808 6D3A           2E                         seg	cs
24809 6D3B           FFA7       6D3F            br	.60D[bx]
24810                       00006D3F            .60D:
24811 6D3F                      697C            .word	.5C1
24812 6D41                      6993            .word	.5CC
24813 6D43                      6D0E            .word	.603
24814 6D45                      6985            .word	.5C9
24815 6D47                      6D0E            .word	.604
24816 6D49                      6985            .word	.5CA
24817 6D4B                      6D0E            .word	.60A
24818 6D4D                      6D0E            .word	.60A
24819 6D4F                      6D0E            .word	.605
24820 6D51                      697C            .word	.5C2
24821 6D53                      6D0E            .word	.606
24822 6D55                      6D0E            .word	.607
24823 6D57                      697C            .word	.5C3
24824 6D59                      697C            .word	.5C4
24825 6D5B                      6D0E            .word	.60A
24826 6D5D                      6D0E            .word	.60A
24827 6D5F                      697C            .word	.5C5
24828 6D61                      697C            .word	.5C6
24829 6D63                      6D0E            .word	.60A
24830 6D65                      6D0E            .word	.60A
24831 6D67                      697C            .word	.5C7
24832 6D69                      69D3            .word	.5D0
24833 6D6B                      697C            .word	.5C8
24834 6D6D                      6D0E            .word	.60A
24835 6D6F                      6D0E            .word	.608
24836                       00006D71            .60C:
24837 6D71           2C                     41  sub	al,*$41
24838 6D73           72           99            jb 	.60A
24839 6D75           3C                     0F  cmp	al,*$F
24840 6D77           77           2B            ja  	.60E
24841 6D79           30E4                       xor	ah,ah
24842 6D7B           D1E0                       shl	ax,*1
24843 6D7D           89C3                       mov	bx,ax
24844 6D7F           2E                         seg	cs
24845 6D80           FFA7       6D84            br	.60F[bx]
24846                       00006D84            .60F:
24847 6D84                      69E1            .word	.5D1
24848 6D86                      69FB            .word	.5D2
24849 6D88                      6985            .word	.5CB
24850 6D8A                      69FB            .word	.5D3
24851 6D8C                      6B8C            .word	.5DE
24852 6D8E                      6C5E            .word	.5F1
24853 6D90                      69FB            .word	.5D4
24854 6D92                      6CB1            .word	.5F6
24855 6D94                      6CD6            .word	.5F9
24856 6D96                      6D0E            .word	.60A
24857 6D98                      6D0E            .word	.60A
24858 6D9A                      6D0E            .word	.60A
24859 6D9C                      6D0E            .word	.60A
24860 6D9E                      6CE4            .word	.5FA
24861 6DA0                      6D0E            .word	.60A
24862 6DA2                      6D0E            .word	.609
24863                       00006DA4            .60E:
24864 6DA4           E9         FF67            br 	.60A
24865                       00006DA7            .5BE:
24866                       FFFFFFE0            ..FFEA	=	-$20
24867                       00006DA7            .FFEB:
24868                       FFFFFFE0            ..FFEB	=	-$20
24869                                           ! 4301   *(((Bit8u *)&AX)+1) = (0x01);
24870                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$20+$17] (used reg = )
24871 6DA7           B0                     01  mov	al,*1
24872 6DA9           8846         19            mov	$19[bp],al
24873                                           !BCC_EOS
24874                                           ! 4302 int13_fail_noah:
24875                       00006DAC            .FFE8:
24876                       FFFFFFE0            ..FFE8	=	-$20
24877                                           ! 4303   _write_byte(*(((Bit8u *)&AX)+1), 0x0074, 0x0040);
24878                                           ! Debug: list int = const $40 (used reg = )
24879 6DAC           B8                   0040  mov	ax,*$40
24880 6DAF           50                         push	ax
24881                                           ! Debug: list int = const $74 (used reg = )
24882 6DB0           B8                   0074  mov	ax,*$74
24883 6DB3           50                         push	ax
24884                                           ! Debug: list unsigned char AX = [S+$24+$17] (used reg = )
24885 6DB4           8A46         19            mov	al,$19[bp]
24886 6DB7           30E4                       xor	ah,ah
24887 6DB9           50                         push	ax
24888                                           ! Debug: func () void = _write_byte+0 (used reg = )
24889 6DBA           E8         9843            call	__write_byte
24890 6DBD           83C4                   06  add	sp,*6
24891                                           !BCC_EOS
24892                                           ! 4304 int13_fail_nostatus:
24893                       00006DC0            .FFE7:
24894                       FFFFFFE0            ..FFE7	=	-$20
24895                                           ! 4305   FLAGS |= 0x0001;
24896                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1C] (used reg = )
24897 6DC0           8B46         1E            mov	ax,$1E[bp]
24898 6DC3           0C                     01  or	al,*1
24899 6DC5           8946         1E            mov	$1E[bp],ax
24900                                           !BCC_EOS
24901                                           ! 4306   return;
24902 6DC8           89EC                       mov	sp,bp
24903 6DCA           5D                         pop	bp
24904 6DCB           C3                         ret
24905                                           !BCC_EOS
24906                                           ! 4307 int13_success:
24907                       00006DCC            .FFE9:
24908                       FFFFFFE0            ..FFE9	=	-$20
24909                                           ! 4308   *(((Bit8u *)&AX)+1) = (0x00);
24910                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$20+$17] (used reg = )
24911 6DCC           30C0                       xor	al,al
24912 6DCE           8846         19            mov	$19[bp],al
24913                                           !BCC_EOS
24914                                           ! 4309 int13_success_noah:
24915                       00006DD1            .FFE6:
24916                       FFFFFFE0            ..FFE6	=	-$20
24917                                           ! 4310   _write_byte(0x00, 0x0074, 0x0040);
24918                                           ! Debug: list int = const $40 (used reg = )
24919 6DD1           B8                   0040  mov	ax,*$40
24920 6DD4           50                         push	ax
24921                                           ! Debug: list int = const $74 (used reg = )
24922 6DD5           B8                   0074  mov	ax,*$74
24923 6DD8           50                         push	ax
24924                                           ! Debug: list int = const 0 (used reg = )
24925 6DD9           31C0                       xor	ax,ax
24926 6DDB           50                         push	ax
24927                                           ! Debug: func () void = _write_byte+0 (used reg = )
24928 6DDC           E8         9821            call	__write_byte
24929 6DDF           83C4                   06  add	sp,*6
24930                                           !BCC_EOS
24931                                           ! 4311   FLAGS &= 0xfffe;
24932                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1C] (used reg = )
24933 6DE2           8B46         1E            mov	ax,$1E[bp]
24934 6DE5           24                     FE  and	al,#$FE
24935 6DE7           8946         1E            mov	$1E[bp],ax
24936                                           !BCC_EOS
24937                                           ! 4312 }
24938 6DEA           89EC                       mov	sp,bp
24939 6DEC           5D                         pop	bp
24940 6DED           C3                         ret
24941                                           ! 4313   void
24942                                           ! Register BX used in function int13_cdrom
24943                                           ! 4314 int13_eltorito(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
24944                                           ! 4315   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
24945                                           export	_int13_eltorito
24946                       00006DEE            _int13_eltorito:
24947                                           !BCC_EOS
24948                                           ! 4316 {
24949                                           ! 4317   Bit16u ebda_seg=get_ebda_seg();
24950 6DEE           55                         push	bp
24951 6DEF           89E5                       mov	bp,sp
24952 6DF1           4C                         dec	sp
24953 6DF2           4C                         dec	sp
24954                                           ! Debug: func () unsigned short = get_ebda_seg+0 (used reg = )
24955 6DF3           E8         9876            call	_get_ebda_seg
24956                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
24957 6DF6           8946         FE            mov	-2[bp],ax
24958                                           !BCC_EOS
24959                                           ! 4318   ;
24960                                           !BCC_EOS
24961                                           ! 4319   switch (*(((Bit8u *)&AX)+1)) {
24962 6DF9           8A46         17            mov	al,$17[bp]
24963 6DFC           E9         0191            br 	.612
24964                                           ! 4320     case 0x4a:
24965                                           ! 4321     case 0x4c:
24966                       00006DFF            .613:
24967                                           ! 4322     case 0x4d:
24968                       00006DFF            .614:
24969                                           ! 4323       bios_printf((2 | 4 | 1), "Int13 eltorito call with AX=%04x. Please report\n",AX);
24970                       00006DFF            .615:
24971                                           ! Debug: list unsigned short AX = [S+4+$14] (used reg = )
24972 6DFF           FF76         16            push	$16[bp]
24973                                           ! Debug: list * char = .616+0 (used reg = )
24974 6E02           BB                   CF1F  mov	bx,#.616
24975 6E05           53                         push	bx
24976                                           ! Debug: list int = const 7 (used reg = )
24977 6E06           B8                   0007  mov	ax,*7
24978 6E09           50                         push	ax
24979                                           ! Debug: func () void = bios_printf+0 (used reg = )
24980 6E0A           E8         9B31            call	_bios_printf
24981 6E0D           83C4                   06  add	sp,*6
24982                                           !BCC_EOS
24983                                           ! 4324       goto int13_fail;
24984 6E10           83C4                   00  add	sp,#..FFE4-..FFE5
24985 6E13           E9         0194            br 	.FFE4
24986                                           !BCC_EOS
24987                                           ! 4325       break;
24988 6E16           E9         0191            br 	.610
24989                                           !BCC_EOS
24990                                           ! 4326     case 0x4b:
24991                                           ! 4327       *((Bit8u *)(SI+0x00)) = (0x13);
24992                       00006E19            .617:
24993                                           ! Debug: add int = const 0 to unsigned short SI = [S+4+8] (used reg = )
24994 6E19           8B46         0A            mov	ax,$A[bp]
24995                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+0 (used reg = )
24996 6E1C           89C3                       mov	bx,ax
24997                                           ! Debug: eq int = const $13 to unsigned char = [bx+0] (used reg = )
24998 6E1E           B0                     13  mov	al,*$13
24999 6E20           8807                       mov	[bx],al
25000                                           !BCC_EOS
25001                                           ! 4328       *((Bit8u *)(SI+0x01)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.media, ebda_seg));
25002                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25003 6E22           FF76         FE            push	-2[bp]
25004                                           ! Debug: list * unsigned char = const $25B (used reg = )
25005 6E25           B8                   025B  mov	ax,#$25B
25006 6E28           50                         push	ax
25007                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25008 6E29           E8         97B8            call	__read_byte
25009 6E2C           83C4                   04  add	sp,*4
25010 6E2F           50                         push	ax
25011                                           ! Debug: add int = const 1 to unsigned short SI = [S+6+8] (used reg = )
25012 6E30           8B46         0A            mov	ax,$A[bp]
25013                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+1 (used reg = )
25014 6E33           89C3                       mov	bx,ax
25015                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+1] (used reg = )
25016 6E35           8A46         FC            mov	al,0+..FFE5[bp]
25017 6E38           8847         01            mov	1[bx],al
25018 6E3B           44                         inc	sp
25019 6E3C           44                         inc	sp
25020                                           !BCC_EOS
25021                                           ! 4329       *((Bit8u *)(SI+0x02)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.emulated_drive, ebda_seg));
25022                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25023 6E3D           FF76         FE            push	-2[bp]
25024                                           ! Debug: list * unsigned char = const $25C (used reg = )
25025 6E40           B8                   025C  mov	ax,#$25C
25026 6E43           50                         push	ax
25027                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25028 6E44           E8         979D            call	__read_byte
25029 6E47           83C4                   04  add	sp,*4
25030 6E4A           50                         push	ax
25031                                           ! Debug: add int = const 2 to unsigned short SI = [S+6+8] (used reg = )
25032 6E4B           8B46         0A            mov	ax,$A[bp]
25033                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+2 (used reg = )
25034 6E4E           89C3                       mov	bx,ax
25035                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+2] (used reg = )
25036 6E50           8A46         FC            mov	al,0+..FFE5[bp]
25037 6E53           8847         02            mov	2[bx],al
25038 6E56           44                         inc	sp
25039 6E57           44                         inc	sp
25040                                           !BCC_EOS
25041                                           ! 4330       *((Bit8u *)(SI+0x03)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.controller_index, ebda_seg));
25042                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25043 6E58           FF76         FE            push	-2[bp]
25044                                           ! Debug: list * unsigned char = const $25D (used reg = )
25045 6E5B           B8                   025D  mov	ax,#$25D
25046 6E5E           50                         push	ax
25047                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25048 6E5F           E8         9782            call	__read_byte
25049 6E62           83C4                   04  add	sp,*4
25050 6E65           50                         push	ax
25051                                           ! Debug: add int = const 3 to unsigned short SI = [S+6+8] (used reg = )
25052 6E66           8B46         0A            mov	ax,$A[bp]
25053                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+3 (used reg = )
25054 6E69           89C3                       mov	bx,ax
25055                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+3] (used reg = )
25056 6E6B           8A46         FC            mov	al,0+..FFE5[bp]
25057 6E6E           8847         03            mov	3[bx],al
25058 6E71           44                         inc	sp
25059 6E72           44                         inc	sp
25060                                           !BCC_EOS
25061                                           ! 4331       *((Bit32u *)(SI+0x04)) = (_read_dword(&((ebda_data_t *) 0)->cdemu.ilba, ebda_seg));
25062                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25063 6E73           FF76         FE            push	-2[bp]
25064                                           ! Debug: list * unsigned long = const $260 (used reg = )
25065 6E76           B8                   0260  mov	ax,#$260
25066 6E79           50                         push	ax
25067                                           ! Debug: func () unsigned long = _read_dword+0 (used reg = )
25068 6E7A           E8         91D9            call	__read_dword
25069 6E7D           89D3                       mov	bx,dx
25070 6E7F           83C4                   04  add	sp,*4
25071 6E82           53                         push	bx
25072 6E83           50                         push	ax
25073                                           ! Debug: add int = const 4 to unsigned short SI = [S+8+8] (used reg = )
25074 6E84           8B46         0A            mov	ax,$A[bp]
25075                                           ! Debug: cast * unsigned long = const 0 to unsigned int = ax+4 (used reg = )
25076 6E87           89C3                       mov	bx,ax
25077                                           ! Debug: eq unsigned long (temp) = [S+8-8] to unsigned long = [bx+4] (used reg = )
25078 6E89           8B46         FA            mov	ax,-2+..FFE5[bp]
25079 6E8C           8B76         FC            mov	si,0+..FFE5[bp]
25080 6E8F           8947         04            mov	4[bx],ax
25081 6E92           8977         06            mov	6[bx],si
25082 6E95           83C4                   04  add	sp,*4
25083                                           !BCC_EOS
25084                                           ! 4332       *((Bit16u *)(SI+0x08)) = (_read_word(&((ebda_data_t *) 0)->cdemu.device_spec, ebda_seg));
25085                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25086 6E98           FF76         FE            push	-2[bp]
25087                                           ! Debug: list * unsigned short = const $25E (used reg = )
25088 6E9B           B8                   025E  mov	ax,#$25E
25089 6E9E           50                         push	ax
25090                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
25091 6E9F           E8         9750            call	__read_word
25092 6EA2           83C4                   04  add	sp,*4
25093 6EA5           50                         push	ax
25094                                           ! Debug: add int = const 8 to unsigned short SI = [S+6+8] (used reg = )
25095 6EA6           8B46         0A            mov	ax,$A[bp]
25096                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+8 (used reg = )
25097 6EA9           89C3                       mov	bx,ax
25098                                           ! Debug: eq unsigned short (temp) = [S+6-6] to unsigned short = [bx+8] (used reg = )
25099 6EAB           8B46         FC            mov	ax,0+..FFE5[bp]
25100 6EAE           8947         08            mov	8[bx],ax
25101 6EB1           44                         inc	sp
25102 6EB2           44                         inc	sp
25103                                           !BCC_EOS
25104                                           ! 4333       *((Bit16u *)(SI+0x0a)) = (_read_word(&((ebda_data_t *) 0)->cdemu.buffer_segment, ebda_seg));
25105                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25106 6EB3           FF76         FE            push	-2[bp]
25107                                           ! Debug: list * unsigned short = const $264 (used reg = )
25108 6EB6           B8                   0264  mov	ax,#$264
25109 6EB9           50                         push	ax
25110                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
25111 6EBA           E8         9735            call	__read_word
25112 6EBD           83C4                   04  add	sp,*4
25113 6EC0           50                         push	ax
25114                                           ! Debug: add int = const $A to unsigned short SI = [S+6+8] (used reg = )
25115 6EC1           8B46         0A            mov	ax,$A[bp]
25116                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$A (used reg = )
25117 6EC4           89C3                       mov	bx,ax
25118                                           ! Debug: eq unsigned short (temp) = [S+6-6] to unsigned short = [bx+$A] (used reg = )
25119 6EC6           8B46         FC            mov	ax,0+..FFE5[bp]
25120 6EC9           8947         0A            mov	$A[bx],ax
25121 6ECC           44                         inc	sp
25122 6ECD           44                         inc	sp
25123                                           !BCC_EOS
25124                                           ! 4334       *((Bit16u *)(SI+0x0c)) = (_read_word(&((ebda_data_t *) 0)->cdemu.load_segment, ebda_seg));
25125                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25126 6ECE           FF76         FE            push	-2[bp]
25127                                           ! Debug: list * unsigned short = const $266 (used reg = )
25128 6ED1           B8                   0266  mov	ax,#$266
25129 6ED4           50                         push	ax
25130                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
25131 6ED5           E8         971A            call	__read_word
25132 6ED8           83C4                   04  add	sp,*4
25133 6EDB           50                         push	ax
25134                                           ! Debug: add int = const $C to unsigned short SI = [S+6+8] (used reg = )
25135 6EDC           8B46         0A            mov	ax,$A[bp]
25136                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$C (used reg = )
25137 6EDF           89C3                       mov	bx,ax
25138                                           ! Debug: eq unsigned short (temp) = [S+6-6] to unsigned short = [bx+$C] (used reg = )
25139 6EE1           8B46         FC            mov	ax,0+..FFE5[bp]
25140 6EE4           8947         0C            mov	$C[bx],ax
25141 6EE7           44                         inc	sp
25142 6EE8           44                         inc	sp
25143                                           !BCC_EOS
25144                                           ! 4335       *((Bit16u *)(SI+0x0e)) = (_read_word(&((ebda_data_t *) 0)->cdemu.sector_count, ebda_seg));
25145                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25146 6EE9           FF76         FE            push	-2[bp]
25147                                           ! Debug: list * unsigned short = const $268 (used reg = )
25148 6EEC           B8                   0268  mov	ax,#$268
25149 6EEF           50                         push	ax
25150                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
25151 6EF0           E8         96FF            call	__read_word
25152 6EF3           83C4                   04  add	sp,*4
25153 6EF6           50                         push	ax
25154                                           ! Debug: add int = const $E to unsigned short SI = [S+6+8] (used reg = )
25155 6EF7           8B46         0A            mov	ax,$A[bp]
25156                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$E (used reg = )
25157 6EFA           89C3                       mov	bx,ax
25158                                           ! Debug: eq unsigned short (temp) = [S+6-6] to unsigned short = [bx+$E] (used reg = )
25159 6EFC           8B46         FC            mov	ax,0+..FFE5[bp]
25160 6EFF           8947         0E            mov	$E[bx],ax
25161 6F02           44                         inc	sp
25162 6F03           44                         inc	sp
25163                                           !BCC_EOS
25164                                           ! 4336       *((Bit8u *)(SI+0x10)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders, ebda_seg));
25165                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25166 6F04           FF76         FE            push	-2[bp]
25167                                           ! Debug: list * unsigned short = const $26C (used reg = )
25168 6F07           B8                   026C  mov	ax,#$26C
25169 6F0A           50                         push	ax
25170                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25171 6F0B           E8         96D6            call	__read_byte
25172 6F0E           83C4                   04  add	sp,*4
25173 6F11           50                         push	ax
25174                                           ! Debug: add int = const $10 to unsigned short SI = [S+6+8] (used reg = )
25175 6F12           8B46         0A            mov	ax,$A[bp]
25176                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$10 (used reg = )
25177 6F15           89C3                       mov	bx,ax
25178                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+$10] (used reg = )
25179 6F17           8A46         FC            mov	al,0+..FFE5[bp]
25180 6F1A           8847         10            mov	$10[bx],al
25181 6F1D           44                         inc	sp
25182 6F1E           44                         inc	sp
25183                                           !BCC_EOS
25184                                           ! 4337       *((Bit8u *)(SI+0x11)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.vdevice.spt, ebda_seg));
25185                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25186 6F1F           FF76         FE            push	-2[bp]
25187                                           ! Debug: list * unsigned short = const $26E (used reg = )
25188 6F22           B8                   026E  mov	ax,#$26E
25189 6F25           50                         push	ax
25190                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25191 6F26           E8         96BB            call	__read_byte
25192 6F29           83C4                   04  add	sp,*4
25193 6F2C           50                         push	ax
25194                                           ! Debug: add int = const $11 to unsigned short SI = [S+6+8] (used reg = )
25195 6F2D           8B46         0A            mov	ax,$A[bp]
25196                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$11 (used reg = )
25197 6F30           89C3                       mov	bx,ax
25198                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+$11] (used reg = )
25199 6F32           8A46         FC            mov	al,0+..FFE5[bp]
25200 6F35           8847         11            mov	$11[bx],al
25201 6F38           44                         inc	sp
25202 6F39           44                         inc	sp
25203                                           !BCC_EOS
25204                                           ! 4338       *((Bit8u *)(SI+0x12)) = (_read_byte(&((ebda_data_t *) 0)->cdemu.vdevice.heads, ebda_seg));
25205                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25206 6F3A           FF76         FE            push	-2[bp]
25207                                           ! Debug: list * unsigned short = const $26A (used reg = )
25208 6F3D           B8                   026A  mov	ax,#$26A
25209 6F40           50                         push	ax
25210                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25211 6F41           E8         96A0            call	__read_byte
25212 6F44           83C4                   04  add	sp,*4
25213 6F47           50                         push	ax
25214                                           ! Debug: add int = const $12 to unsigned short SI = [S+6+8] (used reg = )
25215 6F48           8B46         0A            mov	ax,$A[bp]
25216                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$12 (used reg = )
25217 6F4B           89C3                       mov	bx,ax
25218                                           ! Debug: eq unsigned char (temp) = [S+6-6] to unsigned char = [bx+$12] (used reg = )
25219 6F4D           8A46         FC            mov	al,0+..FFE5[bp]
25220 6F50           8847         12            mov	$12[bx],al
25221 6F53           44                         inc	sp
25222 6F54           44                         inc	sp
25223                                           !BCC_EOS
25224                                           ! 4339       if(( AX & 0x00ff ) == 0x00) {
25225                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
25226 6F55           8A46         16            mov	al,$16[bp]
25227                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
25228 6F58           84C0                       test	al,al
25229 6F5A           75           10            jne 	.618
25230                       00006F5C            .619:
25231                                           ! 4340         _write_byte(0x00, &((ebda_data_t *) 0)->cdemu.active, ebda_seg);
25232                                           ! Debug: list unsigned short ebda_seg = [S+4-4] (used reg = )
25233 6F5C           FF76         FE            push	-2[bp]
25234                                           ! Debug: list * unsigned char = const $25A (used reg = )
25235 6F5F           B8                   025A  mov	ax,#$25A
25236 6F62           50                         push	ax
25237                                           ! Debug: list int = const 0 (used reg = )
25238 6F63           31C0                       xor	ax,ax
25239 6F65           50                         push	ax
25240                                           ! Debug: func () void = _write_byte+0 (used reg = )
25241 6F66           E8         9697            call	__write_byte
25242 6F69           83C4                   06  add	sp,*6
25243                                           !BCC_EOS
25244                                           ! 4341       }
25245                                           ! 4342       goto int13_success;
25246                       00006F6C            .618:
25247 6F6C           83C4                   00  add	sp,#..FFE3-..FFE5
25248 6F6F           EB           5E            jmp .FFE3
25249                                           !BCC_EOS
25250                                           ! 4343       break;
25251 6F71           EB           37            jmp .610
25252                                           !BCC_EOS
25253                                           ! 4344 
25254                                           ! 4344     default:
25255                                           ! 4345       bios_printf(4, "int13_eltorito: unsupported AH=%02x\n", *(((Bit8u *)&AX)+1));
25256                       00006F73            .61A:
25257                                           ! Debug: list unsigned char AX = [S+4+$15] (used reg = )
25258 6F73           8A46         17            mov	al,$17[bp]
25259 6F76           30E4                       xor	ah,ah
25260 6F78           50                         push	ax
25261                                           ! Debug: list * char = .61B+0 (used reg = )
25262 6F79           BB                   CEFA  mov	bx,#.61B
25263 6F7C           53                         push	bx
25264                                           ! Debug: list int = const 4 (used reg = )
25265 6F7D           B8                   0004  mov	ax,*4
25266 6F80           50                         push	ax
25267                                           ! Debug: func () void = bios_printf+0 (used reg = )
25268 6F81           E8         99BA            call	_bios_printf
25269 6F84           83C4                   06  add	sp,*6
25270                                           !BCC_EOS
25271                                           ! 4346       goto int13_fail;
25272 6F87           83C4                   00  add	sp,#..FFE4-..FFE5
25273 6F8A           EB           1E            jmp .FFE4
25274                                           !BCC_EOS
25275                                           ! 4347       break;
25276 6F8C           EB           1C            jmp .610
25277                                           !BCC_EOS
25278                                           ! 4348   }
25279                                           ! 4349 int13_fail:
25280 6F8E           EB           1A            jmp .610
25281                       00006F90            .612:
25282 6F90           2C                     4A  sub	al,*$4A
25283 6F92         0F84         FE69            beq 	.613
25284 6F96           2C                     01  sub	al,*1
25285 6F98         0F84         FE7D            beq 	.617
25286 6F9C           2C                     01  sub	al,*1
25287 6F9E         0F84         FE5D            beq 	.614
25288 6FA2           2C                     01  sub	al,*1
25289 6FA4         0F84         FE57            beq 	.615
25290 6FA8           EB           C9            jmp	.61A
25291                       00006FAA            .610:
25292                       FFFFFFFC            ..FFE5	=	-4
25293                       00006FAA            .FFE4:
25294                       FFFFFFFC            ..FFE4	=	-4
25295                                           ! 4350   *(((Bit8u *)&AX)+1) = (0x01);
25296                                           ! Debug: eq int = const 1 to unsigned char AX = [S+4+$15] (used reg = )
25297 6FAA           B0                     01  mov	al,*1
25298 6FAC           8846         17            mov	$17[bp],al
25299                                           !BCC_EOS
25300                                           ! 4351   _write_byte(*(((Bit8u *)&AX)+1), 0x0074, 0x0040);
25301                                           ! Debug: list int = const $40 (used reg = )
25302 6FAF           B8                   0040  mov	ax,*$40
25303 6FB2           50                         push	ax
25304                                           ! Debug: list int = const $74 (used reg = )
25305 6FB3           B8                   0074  mov	ax,*$74
25306 6FB6           50                         push	ax
25307                                           ! Debug: list unsigned char AX = [S+8+$15] (used reg = )
25308 6FB7           8A46         17            mov	al,$17[bp]
25309 6FBA           30E4                       xor	ah,ah
25310 6FBC           50                         push	ax
25311                                           ! Debug: func () void = _write_byte+0 (used reg = )
25312 6FBD           E8         9640            call	__write_byte
25313 6FC0           83C4                   06  add	sp,*6
25314                                           !BCC_EOS
25315                                           ! 4352   FLAGS |= 0x0001;
25316                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$1A] (used reg = )
25317 6FC3           8B46         1C            mov	ax,$1C[bp]
25318 6FC6           0C                     01  or	al,*1
25319 6FC8           8946         1C            mov	$1C[bp],ax
25320                                           !BCC_EOS
25321                                           ! 4353   return;
25322 6FCB           89EC                       mov	sp,bp
25323 6FCD           5D                         pop	bp
25324 6FCE           C3                         ret
25325                                           !BCC_EOS
25326                                           ! 4354 int13_success:
25327                       00006FCF            .FFE3:
25328                       FFFFFFFC            ..FFE3	=	-4
25329                                           ! 4355   *(((Bit8u *)&AX)+1) = (0x00);
25330                                           ! Debug: eq int = const 0 to unsigned char AX = [S+4+$15] (used reg = )
25331 6FCF           30C0                       xor	al,al
25332 6FD1           8846         17            mov	$17[bp],al
25333                                           !BCC_EOS
25334                                           ! 4356   _write_byte(0x00, 0x0074, 0x0040);
25335                                           ! Debug: list int = const $40 (used reg = )
25336 6FD4           B8                   0040  mov	ax,*$40
25337 6FD7           50                         push	ax
25338                                           ! Debug: list int = const $74 (used reg = )
25339 6FD8           B8                   0074  mov	ax,*$74
25340 6FDB           50                         push	ax
25341                                           ! Debug: list int = const 0 (used reg = )
25342 6FDC           31C0                       xor	ax,ax
25343 6FDE           50                         push	ax
25344                                           ! Debug: func () void = _write_byte+0 (used reg = )
25345 6FDF           E8         961E            call	__write_byte
25346 6FE2           83C4                   06  add	sp,*6
25347                                           !BCC_EOS
25348                                           ! 4357   FLAGS &= 0xfffe;
25349                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+4+$1A] (used reg = )
25350 6FE5           8B46         1C            mov	ax,$1C[bp]
25351 6FE8           24                     FE  and	al,#$FE
25352 6FEA           8946         1C            mov	$1C[bp],ax
25353                                           !BCC_EOS
25354                                           ! 4358 }
25355 6FED           89EC                       mov	sp,bp
25356 6FEF           5D                         pop	bp
25357 6FF0           C3                         ret
25358                                           ! 4359   void
25359                                           ! Register BX used in function int13_eltorito
25360                                           ! 4360 int13_cdemu(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
25361                                           ! 4361   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
25362                                           export	_int13_cdemu
25363                       00006FF1            _int13_cdemu:
25364                                           !BCC_EOS
25365                                           ! 4362 {
25366                                           ! 4363   Bit8u device, status;
25367                                           !BCC_EOS
25368                                           ! 4364   Bit16u vheads, vspt, vcylinders;
25369                                           !BCC_EOS
25370                                           ! 4365   Bit16u head, sector, cylinder, nbsectors, count;
25371                                           !BCC_EOS
25372                                           ! 4366   Bit32u vlba, ilba, slba, elba, lba;
25373                                           !BCC_EOS
25374                                           ! 4367   Bit16u before, segment, offset;
25375                                           !BCC_EOS
25376                                           ! 4368   Bit8u atacmd[12];
25377                                           !BCC_EOS
25378                                           ! 4369   ;
25379 6FF1           55                         push	bp
25380 6FF2           89E5                       mov	bp,sp
25381 6FF4           83C4                   C8  add	sp,*-$38
25382                                           !BCC_EOS
25383                                           ! 4370   device = *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.controller_index)) * 2;
25384                                           ! Debug: mul int = const 2 to unsigned char = [+$25D] (used reg = )
25385 6FF7           A0         025D            mov	al,[$25D]
25386 6FFA           30E4                       xor	ah,ah
25387 6FFC           D1E0                       shl	ax,*1
25388                                           ! Debug: eq unsigned int = ax+0 to unsigned char device = [S+$3A-3] (used reg = )
25389 6FFE           8846         FF            mov	-1[bp],al
25390                                           !BCC_EOS
25391                                           ! 4371   device += *((Bit8u *)(&((ebda_data_t *) 0)->cdemu.device_spec));
25392                                           ! Debug: addab unsigned char = [+$25E] to unsigned char device = [S+$3A-3] (used reg = )
25393 7001           8A46         FF            mov	al,-1[bp]
25394 7004           30E4                       xor	ah,ah
25395 7006           0206       025E            add	al,[$25E]
25396 700A           80D4                   00  adc	ah,*0
25397 700D           8846         FF            mov	-1[bp],al
25398                                           !BCC_EOS
25399                                           ! 4372   _write_byte(0x00, 0x0074, 0x0040);
25400                                           ! Debug: list int = const $40 (used reg = )
25401 7010           B8                   0040  mov	ax,*$40
25402 7013           50                         push	ax
25403                                           ! Debug: list int = const $74 (used reg = )
25404 7014           B8                   0074  mov	ax,*$74
25405 7017           50                         push	ax
25406                                           ! Debug: list int = const 0 (used reg = )
25407 7018           31C0                       xor	ax,ax
25408 701A           50                         push	ax
25409                                           ! Debug: func () void = _write_byte+0 (used reg = )
25410 701B           E8         95E2            call	__write_byte
25411 701E           83C4                   06  add	sp,*6
25412                                           !BCC_EOS
25413                                           ! 4373   if( (*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.active)) ==0) ||
25414                                           ! 4374       (*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.emulated_drive)) != ( DX & 0x00ff ))) {
25415                                           ! Debug: logeq int = const 0 to unsigned char = [+$25A] (used reg = )
25416 7021           A0         025A            mov	al,[$25A]
25417 7024           84C0                       test	al,al
25418 7026           74           09            je  	.61D
25419                       00007028            .61E:
25420                                           ! Debug: and int = const $FF to unsigned short DX = [S+$3A+$10] (used reg = )
25421 7028           8A46         12            mov	al,$12[bp]
25422                                           ! Debug: ne unsigned char = al+0 to unsigned char = [+$25C] (used reg = )
25423                                           ! Debug: expression subtree swapping
25424 702B           3A06       025C            cmp	al,[$25C]
25425 702F           74           20            je  	.61C
25426                       00007031            .61D:
25427                                           ! 4375     bios_printf(4, "int13_cdemu: function %02x, emulation not active for DL= %02x\n", *(((Bit8u *)&AX)+1), ( DX & 0x00ff ));
25428                                           ! Debug: and int = const $FF to unsigned short DX = [S+$3A+$10] (used reg = )
25429 7031           8A46         12            mov	al,$12[bp]
25430                                           ! Debug: list unsigned char = al+0 (used reg = )
25431 7034           30E4                       xor	ah,ah
25432 7036           50                         push	ax
25433                                           ! Debug: list unsigned char AX = [S+$3C+$15] (used reg = )
25434 7037           8A46         17            mov	al,$17[bp]
25435 703A           30E4                       xor	ah,ah
25436 703C           50                         push	ax
25437                                           ! Debug: list * char = .61F+0 (used reg = )
25438 703D           BB                   CEBB  mov	bx,#.61F
25439 7040           53                         push	bx
25440                                           ! Debug: list int = const 4 (used reg = )
25441 7041           B8                   0004  mov	ax,*4
25442 7044           50                         push	ax
25443                                           ! Debug: func () void = bios_printf+0 (used reg = )
25444 7045           E8         98F6            call	_bios_printf
25445 7048           83C4                   08  add	sp,*8
25446                                           !BCC_EOS
25447                                           ! 4376     goto int13_fail;
25448 704B           83C4                   00  add	sp,#..FFE2+$3A
25449 704E           E9         03CA            br 	.FFE2
25450                                           !BCC_EOS
25451                                           ! 4377   }
25452                                           ! 4378   switch (*(((Bit8u *)&AX)+1)) {
25453                       00007051            .61C:
25454 7051           8A46         17            mov	al,$17[bp]
25455 7054           E9         0349            br 	.622
25456                                           ! 4379     case 0x00:
25457                                           ! 4380     case 0x09:
25458                       00007057            .623:
25459                                           ! 4381     case 0x0c:
25460                       00007057            .624:
25461                                           ! 4382     case 0x0d:
25462                       00007057            .625:
25463                                           ! 4383     case 0x10:
25464                       00007057            .626:
25465                                           ! 4384     case 0x11:
25466                       00007057            .627:
25467                                           ! 4385     case 0x14:
25468                       00007057            .628:
25469                                           ! 4386     case 0x16:
25470                       00007057            .629:
25471                                           ! 4387       goto int13_success;
25472                       00007057            .62A:
25473 7057           83C4                   00  add	sp,#..FFE0-..FFE1
25474 705A           E9         03E3            br 	.FFE0
25475                                           !BCC_EOS
25476                                           ! 4388       break;
25477 705D           E9         03BB            br 	.620
25478                                           !BCC_EOS
25479                                           ! 4389     case 0x03:
25480                                           ! 4390     case 0x05:
25481                       00007060            .62B:
25482                                           ! 4391       *(((Bit8u *)&AX)+1) = (0x03);
25483                       00007060            .62C:
25484                                           ! Debug: eq int = const 3 to unsigned char AX = [S+$3A+$15] (used reg = )
25485 7060           B0                     03  mov	al,*3
25486 7062           8846         17            mov	$17[bp],al
25487                                           !BCC_EOS
25488                                           ! 4392       goto int13_fail_noah;
25489 7065           83C4                   00  add	sp,#..FFDF-..FFE1
25490 7068           E9         03B5            br 	.FFDF
25491                                           !BCC_EOS
25492                                           ! 4393       break;
25493 706B           E9         03AD            br 	.620
25494                                           !BCC_EOS
25495                                           ! 4394     case 0x01:
25496                                           ! 4395       status=_read_byte(0x0074, 0x0040);
25497                       0000706E            .62D:
25498                                           ! Debug: list int = const $40 (used reg = )
25499 706E           B8                   0040  mov	ax,*$40
25500 7071           50                         push	ax
25501                                           ! Debug: list int = const $74 (used reg = )
25502 7072           B8                   0074  mov	ax,*$74
25503 7075           50                         push	ax
25504                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
25505 7076           E8         956B            call	__read_byte
25506 7079           83C4                   04  add	sp,*4
25507                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$3A-4] (used reg = )
25508 707C           8846         FE            mov	-2[bp],al
25509                                           !BCC_EOS
25510                                           ! 4396       *(((Bit8u *)&AX)+1) = (status);
25511                                           ! Debug: eq unsigned char status = [S+$3A-4] to unsigned char AX = [S+$3A+$15] (used reg = )
25512 707F           8A46         FE            mov	al,-2[bp]
25513 7082           8846         17            mov	$17[bp],al
25514                                           !BCC_EOS
25515                                           ! 4397       _write_byte(0, 0x0074, 0x0040);
25516                                           ! Debug: list int = const $40 (used reg = )
25517 7085           B8                   0040  mov	ax,*$40
25518 7088           50                         push	ax
25519                                           ! Debug: list int = const $74 (used reg = )
25520 7089           B8                   0074  mov	ax,*$74
25521 708C           50                         push	ax
25522                                           ! Debug: list int = const 0 (used reg = )
25523 708D           31C0                       xor	ax,ax
25524 708F           50                         push	ax
25525                                           ! Debug: func () void = _write_byte+0 (used reg = )
25526 7090           E8         956D            call	__write_byte
25527 7093           83C4                   06  add	sp,*6
25528                                           !BCC_EOS
25529                                           ! 4398       if (status) goto int13_fail_nostatus;
25530 7096           8A46         FE            mov	al,-2[bp]
25531 7099           84C0                       test	al,al
25532 709B           74           08            je  	.62E
25533                       0000709D            .62F:
25534 709D           83C4                   00  add	sp,#..FFDE-..FFE1
25535 70A0           E9         0391            br 	.FFDE
25536                                           !BCC_EOS
25537                                           ! 4399       else goto int13_success_noah;
25538 70A3           EB           06            jmp .630
25539                       000070A5            .62E:
25540 70A5           83C4                   00  add	sp,#..FFDD-..FFE1
25541 70A8           E9         039A            br 	.FFDD
25542                                           !BCC_EOS
25543                                           ! 4400       break;
25544                       000070AB            .630:
25545 70AB           E9         036D            br 	.620
25546                                           !BCC_EOS
25547                                           ! 4401     case 0x02:
25548                                           ! 4402     case 0x04:
25549                       000070AE            .631:
25550                                           ! 4403       vspt = *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt));
25551                       000070AE            .632:
25552                                           ! Debug: eq unsigned short = [+$26E] to unsigned short vspt = [S+$3A-8] (used reg = )
25553 70AE           A1         026E            mov	ax,[$26E]
25554 70B1           8946         FA            mov	-6[bp],ax
25555                                           !BCC_EOS
25556                                           ! 4404       vcylinders = *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders));
25557                                           ! Debug: eq unsigned short = [+$26C] to unsigned short vcylinders = [S+$3A-$A] (used reg = )
25558 70B4           A1         026C            mov	ax,[$26C]
25559 70B7           8946         F8            mov	-8[bp],ax
25560                                           !BCC_EOS
25561                                           ! 4405       vheads = *((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads));
25562                                           ! Debug: eq unsigned short = [+$26A] to unsigned short vheads = [S+$3A-6] (used reg = )
25563 70BA           A1         026A            mov	ax,[$26A]
25564 70BD           8946         FC            mov	-4[bp],ax
25565                                           !BCC_EOS
25566                                           ! 4406       ilba = *((Bit32u *)(&((ebda_data_t *) 0)->cdemu.ilba));
25567                                           ! Debug: eq unsigned long = [+$260] to unsigned long ilba = [S+$3A-$1C] (used reg = )
25568 70C0           A1         0260            mov	ax,[$260]
25569 70C3           8B1E       0262            mov	bx,[$262]
25570 70C7           8946         E6            mov	-$1A[bp],ax
25571 70CA           895E         E8            mov	-$18[bp],bx
25572                                           !BCC_EOS
25573                                           ! 4407       sector = (
25574                                           ! 4407  CX & 0x00ff ) & 0x003f;
25575                                           ! Debug: and int = const $FF to unsigned short CX = [S+$3A+$12] (used reg = )
25576 70CD           8A46         14            mov	al,$14[bp]
25577                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
25578 70D0           24                     3F  and	al,*$3F
25579                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$3A-$E] (used reg = )
25580 70D2           30E4                       xor	ah,ah
25581 70D4           8946         F4            mov	-$C[bp],ax
25582                                           !BCC_EOS
25583                                           ! 4408       cylinder = (( CX & 0x00ff ) & 0x00c0) << 2 | *(((Bit8u *)&CX)+1);
25584                                           ! Debug: and int = const $FF to unsigned short CX = [S+$3A+$12] (used reg = )
25585 70D7           8A46         14            mov	al,$14[bp]
25586                                           ! Debug: and int = const $C0 to unsigned char = al+0 (used reg = )
25587 70DA           24                     C0  and	al,#$C0
25588                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
25589 70DC           30E4                       xor	ah,ah
25590 70DE           D1E0                       shl	ax,*1
25591 70E0           D1E0                       shl	ax,*1
25592                                           ! Debug: or unsigned char CX = [S+$3A+$13] to unsigned int = ax+0 (used reg = )
25593 70E2           0A46         15            or	al,$15[bp]
25594                                           ! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$3A-$10] (used reg = )
25595 70E5           8946         F2            mov	-$E[bp],ax
25596                                           !BCC_EOS
25597                                           ! 4409       head = *(((Bit8u *)&DX)+1);
25598                                           ! Debug: eq unsigned char DX = [S+$3A+$11] to unsigned short head = [S+$3A-$C] (used reg = )
25599 70E8           8A46         13            mov	al,$13[bp]
25600 70EB           30E4                       xor	ah,ah
25601 70ED           8946         F6            mov	-$A[bp],ax
25602                                           !BCC_EOS
25603                                           ! 4410       nbsectors = ( AX & 0x00ff );
25604                                           ! Debug: and int = const $FF to unsigned short AX = [S+$3A+$14] (used reg = )
25605 70F0           8A46         16            mov	al,$16[bp]
25606                                           ! Debug: eq unsigned char = al+0 to unsigned short nbsectors = [S+$3A-$12] (used reg = )
25607 70F3           30E4                       xor	ah,ah
25608 70F5           8946         F0            mov	-$10[bp],ax
25609                                           !BCC_EOS
25610                                           ! 4411       segment = ES;
25611                                           ! Debug: eq unsigned short ES = [S+$3A+4] to unsigned short segment = [S+$3A-$2C] (used reg = )
25612 70F8           8B46         06            mov	ax,6[bp]
25613 70FB           8946         D6            mov	-$2A[bp],ax
25614                                           !BCC_EOS
25615                                           ! 4412       offset = BX;
25616                                           ! Debug: eq unsigned short BX = [S+$3A+$E] to unsigned short offset = [S+$3A-$2E] (used reg = )
25617 70FE           8B46         10            mov	ax,$10[bp]
25618 7101           8946         D4            mov	-$2C[bp],ax
25619                                           !BCC_EOS
25620                                           ! 4413       if(nbsectors==0) goto int13_success;
25621                                           ! Debug: logeq int = const 0 to unsigned short nbsectors = [S+$3A-$12] (used reg = )
25622 7104           8B46         F0            mov	ax,-$10[bp]
25623 7107           85C0                       test	ax,ax
25624 7109           75           06            jne 	.633
25625                       0000710B            .634:
25626 710B           83C4                   00  add	sp,#..FFE0-..FFE1
25627 710E           E9         032F            br 	.FFE0
25628                                           !BCC_EOS
25629                                           ! 4414       if ((sector > vspt)
25630                       00007111            .633:
25631                                           ! 4415        || (cylinder >= vcylinders)
25632                                           ! 4416        || (head >= vheads)) {
25633                                           ! Debug: gt unsigned short vspt = [S+$3A-8] to unsigned short sector = [S+$3A-$E] (used reg = )
25634 7111           8B46         F4            mov	ax,-$C[bp]
25635 7114           3B46         FA            cmp	ax,-6[bp]
25636 7117           77           10            ja  	.636
25637                       00007119            .638:
25638                                           ! Debug: ge unsigned short vcylinders = [S+$3A-$A] to unsigned short cylinder = [S+$3A-$10] (used reg = )
25639 7119           8B46         F2            mov	ax,-$E[bp]
25640 711C           3B46         F8            cmp	ax,-8[bp]
25641 711F           73           08            jae 	.636
25642                       00007121            .637:
25643                                           ! Debug: ge unsigned short vheads = [S+$3A-6] to unsigned short head = [S+$3A-$C] (used reg = )
25644 7121           8B46         F6            mov	ax,-$A[bp]
25645 7124           3B46         FC            cmp	ax,-4[bp]
25646 7127           72           06            jb  	.635
25647                       00007129            .636:
25648                                           ! 4417         goto int13_fail;
25649 7129           83C4                   00  add	sp,#..FFE2-..FFE1
25650 712C           E9         02EC            br 	.FFE2
25651                                           !BCC_EOS
25652                                           ! 4418       }
25653                                           ! 4419       if (*(((Bit8u *)&AX)+1) == 0x04) goto int13_success;
25654                       0000712F            .635:
25655                                           ! Debug: logeq int = const 4 to unsigned char AX = [S+$3A+$15] (used reg = )
25656 712F           8A46         17            mov	al,$17[bp]
25657 7132           3C                     04  cmp	al,*4
25658 7134           75           06            jne 	.639
25659                       00007136            .63A:
25660 7136           83C4                   00  add	sp,#..FFE0-..FFE1
25661 7139           E9         0304            br 	.FFE0
25662                                           !BCC_EOS
25663                                           ! 4420       segment = ES+(BX / 16);
25664                       0000713C            .639:
25665                                           ! Debug: div int = const $10 to unsigned short BX = [S+$3A+$E] (used reg = )
25666 713C           8B46         10            mov	ax,$10[bp]
25667 713F           B1                     04  mov	cl,*4
25668 7141           D3E8                       shr	ax,cl
25669                                           ! Debug: add unsigned int = ax+0 to unsigned short ES = [S+$3A+4] (used reg = )
25670                                           ! Debug: expression subtree swapping
25671 7143           0346         06            add	ax,6[bp]
25672                                           ! Debug: eq unsigned int = ax+0 to unsigned short segment = [S+$3A-$2C] (used reg = )
25673 7146           8946         D6            mov	-$2A[bp],ax
25674                                           !BCC_EOS
25675                                           ! 4421       offset = BX % 16;
25676                                           ! Debug: mod int = const $10 to unsigned short BX = [S+$3A+$E] (used reg = )
25677 7149           8B46         10            mov	ax,$10[bp]
25678 714C           24                     0F  and	al,*$F
25679                                           ! Debug: eq unsigned char = al+0 to unsigned short offset = [S+$3A-$2E] (used reg = )
25680 714E           30E4                       xor	ah,ah
25681 7150           8946         D4            mov	-$2C[bp],ax
25682                                           !BCC_EOS
25683                                           ! 4422       vlba=((((Bit32u)cylinder*(Bit32u)vheads)+(Bit32u)head)*(Bit32u)vspt)+((Bit32u)(sector-1));
25684                                           ! Debug: sub int = const 1 to unsigned short sector = [S+$3A-$E] (used reg = )
25685 7153           8B46         F4            mov	ax,-$C[bp]
25686                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
25687 7156           48                         dec	ax
25688 7157           31DB                       xor	bx,bx
25689 7159           53                         push	bx
25690 715A           50                         push	ax
25691                                           ! Debug: cast unsigned long = const 0 to unsigned short vspt = [S+$3E-8] (used reg = )
25692 715B           8B46         FA            mov	ax,-6[bp]
25693 715E           31DB                       xor	bx,bx
25694 7160           53                         push	bx
25695 7161           50                         push	ax
25696                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$42-$C] (used reg = )
25697 7162           8B46         F6            mov	ax,-$A[bp]
25698 7165           31DB                       xor	bx,bx
25699 7167           53                         push	bx
25700 7168           50                         push	ax
25701                                           ! Debug: cast unsigned long = const 0 to unsigned short vheads = [S+$46-6] (used reg = )
25702 7169           8B46         FC            mov	ax,-4[bp]
25703 716C           31DB                       xor	bx,bx
25704 716E           53                         push	bx
25705 716F           50                         push	ax
25706                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$4A-$10] (used reg = )
25707 7170           8B46         F2            mov	ax,-$E[bp]
25708 7173           31DB                       xor	bx,bx
25709                                           ! Debug: mul unsigned long (temp) = [S+$4A-$4A] to unsigned long = bx+0 (used reg = )
25710 7175           8D7E         B8            lea	di,-$E+..FFE1[bp]
25711 7178           E8         8F3F            call	lmulul
25712 717B           83C4                   04  add	sp,*4
25713                                           ! Debug: add unsigned long (temp) = [S+$46-$46] to unsigned long = bx+0 (used reg = )
25714 717E           8D7E         BC            lea	di,-$A+..FFE1[bp]
25715 7181           E8         8F10            call	laddul
25716 7184           83C4                   04  add	sp,*4
25717                                           ! Debug: mul unsigned long (temp) = [S+$42-$42] to unsigned long = bx+0 (used reg = )
25718 7187           8D7E         C0            lea	di,-6+..FFE1[bp]
25719 718A           E8         8F2D            call	lmulul
25720 718D           83C4                   04  add	sp,*4
25721                                           ! Debug: add unsigned long (temp) = [S+$3E-$3E] to unsigned long = bx+0 (used reg = )
25722 7190           8D7E         C4            lea	di,-2+..FFE1[bp]
25723 7193           E8         8EFE            call	laddul
25724 7196           83C4                   04  add	sp,*4
25725                                           ! Debug: eq unsigned long = bx+0 to unsigned long vlba = [S+$3A-$18] (used reg = )
25726 7199           8946         EA            mov	-$16[bp],ax
25727 719C           895E         EC            mov	-$14[bp],bx
25728                                           !BCC_EOS
25729                                           ! 4423       *((Bit8u *)&AX) = (nbsectors);
25730                                           ! Debug: eq unsigned short nbsectors = [S+$3A-$12] to unsigned char AX = [S+$3A+$14] (used reg = )
25731 719F           8A46         F0            mov	al,-$10[bp]
25732 71A2           8846         16            mov	$16[bp],al
25733                                           !BCC_EOS
25734                                           ! 4424       slba = (Bit32u)vlba/4;
25735                                           ! Debug: div unsigned long = const 4 to unsigned long vlba = [S+$3A-$18] (used reg = )
25736 71A5           B8                   0004  mov	ax,*4
25737 71A8           31DB                       xor	bx,bx
25738 71AA           53                         push	bx
25739 71AB           50                         push	ax
25740 71AC           8B46         EA            mov	ax,-$16[bp]
25741 71AF           8B5E         EC            mov	bx,-$14[bp]
25742 71B2           8D7E         C4            lea	di,-2+..FFE1[bp]
25743 71B5           E8         8F87            call	ldivul
25744 71B8           83C4                   04  add	sp,*4
25745                                           ! Debug: eq unsigned long = bx+0 to unsigned long slba = [S+$3A-$20] (used reg = )
25746 71BB           8946         E2            mov	-$1E[bp],ax
25747 71BE           895E         E4            mov	-$1C[bp],bx
25748                                           !BCC_EOS
25749                                           ! 4425       before= (Bit16u)vlba%4;
25750                                           ! Debug: mod int = const 4 to unsigned short vlba = [S+$3A-$18] (used reg = )
25751 71C1           8B46         EA            mov	ax,-$16[bp]
25752 71C4           24                     03  and	al,*3
25753                                           ! Debug: eq unsigned char = al+0 to unsigned short before = [S+$3A-$2A] (used reg = )
25754 71C6           30E4                       xor	ah,ah
25755 71C8           8946         D8            mov	-$28[bp],ax
25756                                           !BCC_EOS
25757                                           ! 4426       elba = (Bit32u)(vlba+nbsectors-1)/4;
25758                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$3A-$12] (used reg = )
25759 71CB           8B46         F0            mov	ax,-$10[bp]
25760 71CE           31DB                       xor	bx,bx
25761                                           ! Debug: add unsigned long = bx+0 to unsigned long vlba = [S+$3A-$18] (used reg = )
25762                                           ! Debug: expression subtree swapping
25763 71D0           8D7E         EA            lea	di,-$16[bp]
25764 71D3           E8         8EBE            call	laddul
25765                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
25766 71D6           53                         push	bx
25767 71D7           50                         push	ax
25768 71D8           B8                   0001  mov	ax,*1
25769 71DB           31DB                       xor	bx,bx
25770 71DD           53                         push	bx
25771 71DE           50                         push	ax
25772 71DF           8B46         C4            mov	ax,-2+..FFE1[bp]
25773 71E2           8B5E         C6            mov	bx,0+..FFE1[bp]
25774 71E5           8D7E         C0            lea	di,-6+..FFE1[bp]
25775 71E8           E8         8EC7            call	lsubul
25776 71EB           83C4                   08  add	sp,*8
25777                                           ! Debug: cast unsigned long = const 0 to unsigned long = bx+0 (used reg = )
25778                                           ! Debug: div unsigned long = const 4 to unsigned long = bx+0 (used reg = )
25779 71EE           53                         push	bx
25780 71EF           50                         push	ax
25781 71F0           B8                   0004  mov	ax,*4
25782 71F3           31DB                       xor	bx,bx
25783 71F5           53                         push	bx
25784 71F6           50                         push	ax
25785 71F7           8B46         C4            mov	ax,-2+..FFE1[bp]
25786 71FA           8B5E         C6            mov	bx,0+..FFE1[bp]
25787 71FD           8D7E         C0            lea	di,-6+..FFE1[bp]
25788 7200           E8         8F3C            call	ldivul
25789 7203           83C4                   08  add	sp,*8
25790                                           ! Debug: eq unsigned long = bx+0 to unsigned long elba = [S+$3A-$24] (used reg = )
25791 7206           8946         DE            mov	-$22[bp],ax
25792 7209           895E         E0            mov	-$20[bp],bx
25793                                           !BCC_EOS
25794                                           ! 4427       _memsetb(0,atacmd,get_SS(),12);
25795                                           ! Debug: list int = const $C (used reg = )
25796 720C           B8                   000C  mov	ax,*$C
25797 720F           50                         push	ax
25798                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
25799 7210           E8         944C            call	_get_SS
25800                                           ! Debug: list unsigned short = ax+0 (used reg = )
25801 7213           50                         push	ax
25802                                           ! Debug: list * unsigned char atacmd = S+$3E-$3A (used reg = )
25803 7214           8D5E         C8            lea	bx,-$38[bp]
25804 7217           53                         push	bx
25805                                           ! Debug: list int = const 0 (used reg = )
25806 7218           31C0                       xor	ax,ax
25807 721A           50                         push	ax
25808                                           ! Debug: func () void = _memsetb+0 (used reg = )
25809 721B           E8         8DE2            call	__memsetb
25810 721E           83C4                   08  add	sp,*8
25811                                           !BCC_EOS
25812                                           ! 4428       atacmd[0]=0x28;
25813                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$3A-$3A] (used reg = )
25814 7221           B0                     28  mov	al,*$28
25815 7223           8846         C8            mov	-$38[bp],al
25816                                           !BCC_EOS
25817                                           ! 4429       count = (Bit16u)(elba-slba)+1;
25818                                           ! Debug: sub unsigned long slba = [S+$3A-$20] to unsigned long elba = [S+$3A-$24] (used reg = )
25819 7226           8B46         DE            mov	ax,-$22[bp]
25820 7229           8B5E         E0            mov	bx,-$20[bp]
25821 722C           8D7E         E2            lea	di,-$1E[bp]
25822 722F           E8         8E80            call	lsubul
25823                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
25824                                           ! Debug: add int = const 1 to unsigned short = ax+0 (used reg = )
25825                                           ! Debug: eq unsigned int = ax+1 to unsigned short count = [S+$3A-$14] (used reg = )
25826 7232           40                         inc	ax
25827 7233           8946         EE            mov	-$12[bp],ax
25828                                           !BCC_EOS
25829                                           ! 4430       atacmd[7]=*(((Bit8u *)&count)+1);
25830                                           ! Debug: eq unsigned char count = [S+$3A-$13] to unsigned char atacmd = [S+$3A-$33] (used reg = )
25831 7236           8A46         EF            mov	al,-$11[bp]
25832 7239           8846         CF            mov	-$31[bp],al
25833                                           !BCC_EOS
25834                                           ! 4431       atacmd[8]=*((Bit8u *)&count);
25835                                           ! Debug: eq unsigned char count = [S+$3A-$14] to unsigned char atacmd = [S+$3A-$32] (used reg = )
25836 723C           8A46         EE            mov	al,-$12[bp]
25837 723F           8846         D0            mov	-$30[bp],al
25838                                           !BCC_EOS
25839                                           ! 4432       lba = ilba+slba;
25840                                           ! Debug: add unsigned long slba = [S+$3A-$20] to unsigned long ilba = [S+$3A-$1C] (used reg = )
25841 7242           8B46         E6            mov	ax,-$1A[bp]
25842 7245           8B5E         E8            mov	bx,-$18[bp]
25843 7248           8D7E         E2            lea	di,-$1E[bp]
25844 724B           E8         8E46            call	laddul
25845                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$3A-$28] (used reg = )
25846 724E           8946         DA            mov	-$26[bp],ax
25847 7251           895E         DC            mov	-$24[bp],bx
25848                                           !BCC_EOS
25849                                           ! 4433       atacmd[2]=*(((Bit8u *)&*(((Bit16u *)&lba)+1))+1);
25850                                           ! Debug: eq unsigned char lba = [S+$3A-$25] to unsigned char atacmd = [S+$3A-$38] (used reg = )
25851 7254           8A46         DD            mov	al,-$23[bp]
25852 7257           8846         CA            mov	-$36[bp],al
25853                                           !BCC_EOS
25854                                           ! 4434       atacmd[3]=*((Bit8u *)&*(((Bit16u *)&lba)+1));
25855                                           ! Debug: eq unsigned char lba = [S+$3A-$26] to unsigned char atacmd = [S+$3A-$37] (used reg = )
25856 725A           8A46         DC            mov	al,-$24[bp]
25857 725D           8846         CB            mov	-$35[bp],al
25858                                           !BCC_EOS
25859                                           ! 4435       atacmd[4]=*(((Bit8u *)&*((Bit16u *)&lba))+1);
25860                                           ! Debug: eq unsigned char lba = [S+$3A-$27] to unsigned char atacmd = [S+$3A-$36] (used reg = )
25861 7260           8A46         DB            mov	al,-$25[bp]
25862 7263           8846         CC            mov	-$34[bp],al
25863                                           !BCC_EOS
25864                                           ! 4436       atacmd[5]=*((Bit8u *)&lba);
25865                                           ! Debug: eq unsigned char lba = [S+$3A-$28] to unsigned char atacmd = [S+$3A-$35] (used reg = )
25866 7266           8A46         DA            mov	al,-$26[bp]
25867 7269           8846         CD            mov	-$33[bp],al
25868                                           !BCC_EOS
25869                                           ! 4437       if((status = ata_cmd_packet(device, 12, get_SS(), atacmd, before*512, nbsectors*512L, 0x01, segment,offset)) != 0) {
25870                                           ! Debug: list unsigned short offset = [S+$3A-$2E] (used reg = )
25871 726C           FF76         D4            push	-$2C[bp]
25872                                           ! Debug: list unsigned short segment = [S+$3C-$2C] (used reg = )
25873 726F           FF76         D6            push	-$2A[bp]
25874                                           ! Debug: list int = const 1 (used reg = )
25875 7272           B8                   0001  mov	ax,*1
25876 7275           50                         push	ax
25877                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$40-$12] (used reg = )
25878 7276           8B46         F0            mov	ax,-$10[bp]
25879 7279           31DB                       xor	bx,bx
25880                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
25881 727B           53                         push	bx
25882 727C           50                         push	ax
25883 727D           B8                   0200  mov	ax,#$200
25884 7280           31DB                       xor	bx,bx
25885 7282           53                         push	bx
25886 7283           50                         push	ax
25887 7284           8B46         BE            mov	ax,-8+..FFE1[bp]
25888 7287           8B5E         C0            mov	bx,-6+..FFE1[bp]
25889 728A           8D7E         BA            lea	di,-$C+..FFE1[bp]
25890 728D           E8         8E2A            call	lmulul
25891 7290           83C4                   08  add	sp,*8
25892                                           ! Debug: list unsigned long = bx+0 (used reg = )
25893 7293           53                         push	bx
25894 7294           50                         push	ax
25895                                           ! Debug: mul int = const $200 to unsigned short before = [S+$44-$2A] (used reg = )
25896 7295           8B46         D8            mov	ax,-$28[bp]
25897 7298           B9                   0200  mov	cx,#$200
25898 729B           F7E9                       imul	cx
25899                                           ! Debug: list unsigned int = ax+0 (used reg = )
25900 729D           50                         push	ax
25901                                           ! Debug: list * unsigned char atacmd = S+$46-$3A (used reg = )
25902 729E           8D5E         C8            lea	bx,-$38[bp]
25903 72A1           53                         push	bx
25904                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
25905 72A2           E8         93BA            call	_get_SS
25906                                           ! Debug: list unsigned short = ax+0 (used reg = )
25907 72A5           50                         push	ax
25908                                           ! Debug: list int = const $C (used reg = )
25909 72A6           B8                   000C  mov	ax,*$C
25910 72A9           50                         push	ax
25911                                           ! Debug: list unsigned char device = [S+$4C-3] (used reg = )
25912 72AA           8A46         FF            mov	al,-1[bp]
25913 72AD           30E4                       xor	ah,ah
25914 72AF           50                         push	ax
25915                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
25916 72B0           E8         BA97            call	_ata_cmd_packet
25917 72B3           83C4                   14  add	sp,*$14
25918                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$3A-4] (used reg = )
25919 72B6           8846         FE            mov	-2[bp],al
25920                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
25921 72B9           84C0                       test	al,al
25922 72BB           74           2A            je  	.63B
25923                       000072BD            .63C:
25924                                           ! 4438         bios_printf(4, "int13_cdemu: function %02x, error %02x !\n",*(((Bit8u *)&AX)+1),status);
25925                                           ! Debug: list unsigned char status = [S+$3A-4] (used reg = )
25926 72BD           8A46         FE            mov	al,-2[bp]
25927 72C0           30E4                       xor	ah,ah
25928 72C2           50                         push	ax
25929                                           ! Debug: list unsigned char AX = [S+$3C+$15] (used reg = )
25930 72C3           8A46         17            mov	al,$17[bp]
25931 72C6           30E4                       xor	ah,ah
25932 72C8           50                         push	ax
25933                                           ! Debug: list * char = .63D+0 (used reg = )
25934 72C9           BB                   CE91  mov	bx,#.63D
25935 72CC           53                         push	bx
25936                                           ! Debug: list int = const 4 (used reg = )
25937 72CD           B8                   0004  mov	ax,*4
25938 72D0           50                         push	ax
25939                                           ! Debug: func () void = bios_printf+0 (used reg = )
25940 72D1           E8         966A            call	_bios_printf
25941 72D4           83C4                   08  add	sp,*8
25942                                           !BCC_EOS
25943                                           ! 4439         *(((Bit8u *)&AX)+1) = (0x02);
25944                                           ! Debug: eq int = const 2 to unsigned char AX = [S+$3A+$15] (used reg = )
25945 72D7           B0                     02  mov	al,*2
25946 72D9           8846         17            mov	$17[bp],al
25947                                           !BCC_EOS
25948                                           ! 4440         *((Bit8u *)&AX) = (0);
25949                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$3A+$14] (used reg = )
25950 72DC           30C0                       xor	al,al
25951 72DE           8846         16            mov	$16[bp],al
25952                                           !BCC_EOS
25953                                           ! 4441         goto int13_fail_noah;
25954 72E1           83C4                   00  add	sp,#..FFDF-..FFE1
25955 72E4           E9         0139            br 	.FFDF
25956                                           !BCC_EOS
25957                                           ! 4442       }
25958                                           ! 4443       goto int13_success;
25959                       000072E7            .63B:
25960 72E7           83C4                   00  add	sp,#..FFE0-..FFE1
25961 72EA           E9         0153            br 	.FFE0
25962                                           !BCC_EOS
25963                                           ! 4444       break;
25964 72ED           E9         012B            br 	.620
25965                                           !BCC_EOS
25966                                           ! 4445     case 0x08:
25967                                           ! 4446       vspt=*((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.spt));
25968                       000072F0            .63E:
25969                                           ! Debug: eq unsigned short = [+$26E] to unsigned short vspt = [S+$3A-8] (used reg = )
25970 72F0           A1         026E            mov	ax,[$26E]
25971 72F3           8946         FA            mov	-6[bp],ax
25972                                           !BCC_EOS
25973                                           ! 4447       vcylinders=*((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.cylinders)) - 1;
25974                                           ! Debug: sub int = const 1 to unsigned short = [+$26C] (used reg = )
25975 72F6           A1         026C            mov	ax,[$26C]
25976                                           ! Debug: eq unsigned int = ax-1 to unsigned short vcylinders = [S+$3A-$A] (used reg = )
25977 72F9           48                         dec	ax
25978 72FA           8946         F8            mov	-8[bp],ax
25979                                           !BCC_EOS
25980                                           ! 4448       vheads=*((Bit16u *)(&((ebda_data_t *) 0)->cdemu.vdevice.heads)) - 1;
25981                                           ! Debug: sub int = const 1 to unsigned short = [+$26A] (used reg = )
25982 72FD           A1         026A            mov	ax,[$26A]
25983                                           ! Debug: eq unsigned int = ax-1 to unsigned short vheads = [S+$3A-6] (used reg = )
25984 7300           48                         dec	ax
25985 7301           8946         FC            mov	-4[bp],ax
25986                                           !BCC_EOS
25987                                           ! 4449       *((Bit8u *)&AX) = (0x00);
25988                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$3A+$14] (used reg = )
25989 7304           30C0                       xor	al,al
25990 7306           8846         16            mov	$16[bp],al
25991                                           !BCC_EOS
25992                                           ! 4450       *((Bit8u *)&BX) = (0x00);
25993                                           ! Debug: eq int = const 0 to unsigned char BX = [S+$3A+$E] (used reg = )
25994 7309           30C0                       xor	al,al
25995 730B           8846         10            mov	$10[bp],al
25996                                           !BCC_EOS
25997                                           ! 4451       *(((Bit8u *)&CX)+1) = (vcylinders & 0xff);
25998                                           ! Debug: and int = const $FF to unsigned short vcylinders = [S+$3A-$A] (used reg = )
25999 730E           8A46         F8            mov	al,-8[bp]
26000                                           ! Debug: eq unsigned char = al+0 to unsigned char CX = [S+$3A+$13] (used reg = )
26001 7311           8846         15            mov	$15[bp],al
26002                                           !BCC_EOS
26003                                           ! 4452       *((Bit8u *)&CX) = (((vcylinders >> 2) & 0xc0) | (vspt & 0x3f));
26004                                           ! Debug: and int = const $3F to unsigned short vspt = [S+$3A-8] (used reg = )
26005 7314           8A46         FA            mov	al,-6[bp]
26006 7317           24                     3F  and	al,*$3F
26007 7319           50                         push	ax
26008                                           ! Debug: sr int = const 2 to unsigned short vcylinders = [S+$3C-$A] (used reg = )
26009 731A           8B46         F8            mov	ax,-8[bp]
26010 731D           D1E8                       shr	ax,*1
26011 731F           D1E8                       shr	ax,*1
26012                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
26013 7321           24                     C0  and	al,#$C0
26014                                           ! Debug: or unsigned char (temp) = [S+$3C-$3C] to unsigned char = al+0 (used reg = )
26015 7323           0A46         C6            or	al,0+..FFE1[bp]
26016 7326           44                         inc	sp
26017 7327           44                         inc	sp
26018                                           ! Debug: eq unsigned char = al+0 to unsigned char CX = [S+$3A+$12] (used reg = )
26019 7328           8846         14            mov	$14[bp],al
26020                                           !BCC_EOS
26021                                           ! 4453       *(((Bit8u *)&DX)+1) = (vheads);
26022                                           ! Debug: eq unsigned short vheads = [S+$3A-6] to unsigned char DX = [S+$3A+$11] (used reg = )
26023 732B           8A46         FC            mov	al,-4[bp]
26024 732E           8846         13            mov	$13[bp],al
26025                                           !BCC_EOS
26026                                           ! 4454       *((Bit8u *)&DX) = (0x02);
26027                                           ! Debug: eq int = const 2 to unsigned char DX = [S+$3A+$10] (used reg = )
26028 7331           B0                     02  mov	al,*2
26029 7333           8846         12            mov	$12[bp],al
26030                                           !BCC_EOS
26031                                           ! 4455       switch(*((Bit8u *)(&((ebda_data_t *) 0)->cdemu.media))) {
26032 7336           A0         025B            mov	al,[$25B]
26033 7339           EB           17            jmp .641
26034                                           ! 4456         case 0
26035                                           ! 4456 x01: *((Bit8u *)&BX) = (0x02); break;
26036                       0000733B            .642:
26037                                           ! Debug: eq int = const 2 to unsigned char BX = [S+$3A+$E] (used reg = )
26038 733B           B0                     02  mov	al,*2
26039 733D           8846         10            mov	$10[bp],al
26040                                           !BCC_EOS
26041 7340           EB           1C            jmp .63F
26042                                           !BCC_EOS
26043                                           ! 4457         case 0x02: *((Bit8u *)&BX) = (0x04); break;
26044                       00007342            .643:
26045                                           ! Debug: eq int = const 4 to unsigned char BX = [S+$3A+$E] (used reg = )
26046 7342           B0                     04  mov	al,*4
26047 7344           8846         10            mov	$10[bp],al
26048                                           !BCC_EOS
26049 7347           EB           15            jmp .63F
26050                                           !BCC_EOS
26051                                           ! 4458         case 0x03: *((Bit8u *)&BX) = (0x06); break;
26052                       00007349            .644:
26053                                           ! Debug: eq int = const 6 to unsigned char BX = [S+$3A+$E] (used reg = )
26054 7349           B0                     06  mov	al,*6
26055 734B           8846         10            mov	$10[bp],al
26056                                           !BCC_EOS
26057 734E           EB           0E            jmp .63F
26058                                           !BCC_EOS
26059                                           ! 4459     }
26060                                           ! 4460 #asm
26061 7350           EB           0C            jmp .63F
26062                       00007352            .641:
26063 7352           2C                     01  sub	al,*1
26064 7354           74           E5            je 	.642
26065 7356           2C                     01  sub	al,*1
26066 7358           74           E8            je 	.643
26067 735A           2C                     01  sub	al,*1
26068 735C           74           EB            je 	.644
26069                       0000735E            .63F:
26070                                           !BCC_EOS
26071                                           !BCC_ASM
26072                       00000044            _int13_cdemu.BP	set	$44
26073                       0000000C            .int13_cdemu.BP	set	$C
26074                       00000052            _int13_cdemu.CS	set	$52
26075                       0000001A            .int13_cdemu.CS	set	$1A
26076                       00000028            _int13_cdemu.nbsectors	set	$28
26077                       FFFFFFF0            .int13_cdemu.nbsectors	set	-$10
26078                       00000026            _int13_cdemu.count	set	$26
26079                       FFFFFFEE            .int13_cdemu.count	set	-$12
26080                       0000004C            _int13_cdemu.CX	set	$4C
26081                       00000014            .int13_cdemu.CX	set	$14
26082                       00000016            _int13_cdemu.elba	set	$16
26083                       FFFFFFDE            .int13_cdemu.elba	set	-$22
26084                       0000000E            _int13_cdemu.segment	set	$E
26085                       FFFFFFD6            .int13_cdemu.segment	set	-$2A
26086                       00000040            _int13_cdemu.DI	set	$40
26087                       00000008            .int13_cdemu.DI	set	8
26088                       00000054            _int13_cdemu.FLAGS	set	$54
26089                       0000001C            .int13_cdemu.FLAGS	set	$1C
26090                       00000030            _int13_cdemu.vcylinders	set	$30
26091                       FFFFFFF8            .int13_cdemu.vcylinders	set	-8
26092                       0000002C            _int13_cdemu.sector	set	$2C
26093                       FFFFFFF4            .int13_cdemu.sector	set	-$C
26094                       0000003C            _int13_cdemu.DS	set	$3C
26095                       00000004            .int13_cdemu.DS	set	4
26096                       0000002E            _int13_cdemu.head	set	$2E
26097                       FFFFFFF6            .int13_cdemu.head	set	-$A
26098                       0000002A            _int13_cdemu.cylinder	set	$2A
26099                       FFFFFFF2            .int13_cdemu.cylinder	set	-$E
26100                       0000004A            _int13_cdemu.DX	set	$4A
26101                       00000012            .int13_cdemu.DX	set	$12
26102                       00000037            _int13_cdemu.device	set	$37
26103                       FFFFFFFF            .int13_cdemu.device	set	-1
26104                       0000003E            _int13_cdemu.ES	set	$3E
26105                       00000006            .int13_cdemu.ES	set	6
26106                       00000032            _int13_cdemu.vspt	set	$32
26107                       FFFFFFFA            .int13_cdemu.vspt	set	-6
26108                       00000022            _int13_cdemu.vlba	set	$22
26109                       FFFFFFEA            .int13_cdemu.vlba	set	-$16
26110                       00000042            _int13_cdemu.SI	set	$42
26111                       0000000A            .int13_cdemu.SI	set	$A
26112                       00000050            _int13_cdemu.IP	set	$50
26113                       00000018            .int13_cdemu.IP	set	$18
26114                       00000012            _int13_cdemu.lba	set	$12
26115                       FFFFFFDA            .int13_cdemu.lba	set	-$26
26116                       00000036            _int13_cdemu.status	set	$36
26117                       FFFFFFFE            .int13_cdemu.status	set	-2
26118                       00000000            _int13_cdemu.atacmd	set	0
26119                       FFFFFFC8            .int13_cdemu.atacmd	set	-$38
26120                       0000004E            _int13_cdemu.AX	set	$4E
26121                       00000016            .int13_cdemu.AX	set	$16
26122                       0000001E            _int13_cdemu.ilba	set	$1E
26123                       FFFFFFE6            .int13_cdemu.ilba	set	-$1A
26124                       00000010            _int13_cdemu.before	set	$10
26125                       FFFFFFD8            .int13_cdemu.before	set	-$28
26126                       0000000C            _int13_cdemu.offset	set	$C
26127                       FFFFFFD4            .int13_cdemu.offset	set	-$2C
26128                       0000001A            _int13_cdemu.slba	set	$1A
26129                       FFFFFFE2            .int13_cdemu.slba	set	-$1E
26130                       00000046            _int13_cdemu.SP	set	$46
26131                       0000000E            .int13_cdemu.SP	set	$E
26132                       00000034            _int13_cdemu.vheads	set	$34
26133                       FFFFFFFC            .int13_cdemu.vheads	set	-4
26134                       00000048            _int13_cdemu.BX	set	$48
26135                       00000010            .int13_cdemu.BX	set	$10
26136 735E           55                               push bp
26137 735F           89E5                             mov bp, sp
26138 7361           B8                   EFDE        mov ax, #diskette_param_table2
26139 7364           8946         42                  mov _int13_cdemu.DI+2[bp], ax
26140 7367           8C4E         40                  mov _int13_cdemu.ES+2[bp], cs
26141 736A           5D                               pop bp
26142                                           ! 4467 endasm
26143                                           !BCC_ENDASM
26144                                           !BCC_EOS
26145                                           ! 4468       goto int13_success;
26146 736B           83C4                   00  add	sp,#..FFE0-..FFE1
26147 736E           E9         00CF            br 	.FFE0
26148                                           !BCC_EOS
26149                                           ! 4469       break;
26150 7371           E9         00A7            br 	.620
26151                                           !BCC_EOS
26152                                           ! 4470     case 0x15:
26153                                           ! 4471       *(((Bit8u *)&AX)+1) = (0x03);
26154                       00007374            .645:
26155                                           ! Debug: eq int = const 3 to unsigned char AX = [S+$3A+$15] (used reg = )
26156 7374           B0                     03  mov	al,*3
26157 7376           8846         17            mov	$17[bp],al
26158                                           !BCC_EOS
26159                                           ! 4472       goto int13_success_noah;
26160 7379           83C4                   00  add	sp,#..FFDD-..FFE1
26161 737C           E9         00C6            br 	.FFDD
26162                                           !BCC_EOS
26163                                           ! 4473       break;
26164 737F           E9         0099            br 	.620
26165                                           !BCC_EOS
26166                                           ! 4474     case 0x0a:
26167                                           ! 4475     case 0x0b:
26168                       00007382            .646:
26169                                           ! 4476     case 0x18:
26170                       00007382            .647:
26171                                           ! 4477     case 0x41:
26172                       00007382            .648:
26173                                           ! 4478     case 0x42:
26174                       00007382            .649:
26175                                           ! 4479     case 0x43:
26176                       00007382            .64A:
26177                                           ! 4480     case 0x44:
26178                       00007382            .64B:
26179                                           ! 4481     case 0x45:
26180                       00007382            .64C:
26181                                           ! 4482     case 0x46:
26182                       00007382            .64D:
26183                                           ! 4483     case 0x47:
26184                       00007382            .64E:
26185                                           ! 4484     case 0x48:
26186                       00007382            .64F:
26187                                           ! 4485     case 0x49:
26188                       00007382            .650:
26189                                           ! 4486     case 0x4e:
26190                       00007382            .651:
26191                                           ! 4487     case 0x50:
26192                       00007382            .652:
26193                                           ! 4488     default:
26194                       00007382            .653:
26195                                           ! 4489       bios_printf(4, "int13_cdemu function AH=%02x unsupported, returns fail\n", *(((Bit8u *)&AX)+1));
26196                       00007382            .654:
26197                                           ! Debug: list unsigned char AX = [S+$3A+$15] (used reg = )
26198 7382           8A46         17            mov	al,$17[bp]
26199 7385           30E4                       xor	ah,ah
26200 7387           50                         push	ax
26201                                           ! Debug: list * char = .655+0 (used reg = )
26202 7388           BB                   CE59  mov	bx,#.655
26203 738B           53                         push	bx
26204                                           ! Debug: list int = const 4 (used reg = )
26205 738C           B8                   0004  mov	ax,*4
26206 738F           50                         push	ax
26207                                           ! Debug: func () void = bios_printf+0 (used reg = )
26208 7390           E8         95AB            call	_bios_printf
26209 7393           83C4                   06  add	sp,*6
26210                                           !BCC_EOS
26211                                           ! 4490       goto int13_fail;
26212 7396           83C4                   00  add	sp,#..FFE2-..FFE1
26213 7399           E9         007F            jmp .FFE2
26214                                           !BCC_EOS
26215                                           ! 4491       break;
26216 739C           EB           7D            jmp .620
26217                                           !BCC_EOS
26218                                           ! 4492   }
26219                                           ! 4493 int13_fail:
26220 739E           EB           7B            jmp .620
26221                       000073A0            .622:
26222 73A0           2C                     00  sub	al,*0
26223 73A2           72           DE            jb 	.654
26224 73A4           3C                     18  cmp	al,*$18
26225 73A6           77           3D            ja  	.656
26226 73A8           30E4                       xor	ah,ah
26227 73AA           D1E0                       shl	ax,*1
26228 73AC           89C3                       mov	bx,ax
26229 73AE           2E                         seg	cs
26230 73AF           FFA7       73B3            br	.657[bx]
26231                       000073B3            .657:
26232 73B3                      7057            .word	.623
26233 73B5                      706E            .word	.62D
26234 73B7                      70AE            .word	.631
26235 73B9                      7060            .word	.62B
26236 73BB                      70AE            .word	.632
26237 73BD                      7060            .word	.62C
26238 73BF                      7382            .word	.654
26239 73C1                      7382            .word	.654
26240 73C3                      72F0            .word	.63E
26241 73C5                      7057            .word	.624
26242 73C7                      7382            .word	.646
26243 73C9                      7382            .word	.647
26244 73CB                      7057            .word	.625
26245 73CD                      7057            .word	.626
26246 73CF                      7382            .word	.654
26247 73D1                      7382            .word	.654
26248 73D3                      7057            .word	.627
26249 73D5                      7057            .word	.628
26250 73D7                      7382            .word	.654
26251 73D9                      7382            .word	.654
26252 73DB                      7057            .word	.629
26253 73DD                      7374            .word	.645
26254 73DF                      7057            .word	.62A
26255 73E1                      7382            .word	.654
26256 73E3                      7382            .word	.648
26257                       000073E5            .656:
26258 73E5           2C                     41  sub	al,*$41
26259 73E7           72           99            jb 	.654
26260 73E9           3C                     0F  cmp	al,*$F
26261 73EB           77           2B            ja  	.658
26262 73ED           30E4                       xor	ah,ah
26263 73EF           D1E0                       shl	ax,*1
26264 73F1           89C3                       mov	bx,ax
26265 73F3           2E                         seg	cs
26266 73F4           FFA7       73F8            br	.659[bx]
26267                       000073F8            .659:
26268 73F8                      7382            .word	.649
26269 73FA                      7382            .word	.64A
26270 73FC                      7382            .word	.64B
26271 73FE                      7382            .word	.64C
26272 7400                      7382            .word	.64D
26273 7402                      7382            .word	.64E
26274 7404                      7382            .word	.64F
26275 7406                      7382            .word	.650
26276 7408                      7382            .word	.651
26277 740A                      7382            .word	.654
26278 740C                      7382            .word	.654
26279 740E                      7382            .word	.654
26280 7410                      7382            .word	.654
26281 7412                      7382            .word	.652
26282 7414                      7382            .word	.654
26283 7416                      7382            .word	.653
26284                       00007418            .658:
26285 7418           E9         FF67            br 	.654
26286                       0000741B            .620:
26287                       FFFFFFC6            ..FFE1	=	-$3A
26288                       0000741B            .FFE2:
26289                       FFFFFFC6            ..FFE2	=	-$3A
26290                                           ! 4494   *(((Bit8u *)&AX)+1) = (0x01);
26291                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$3A+$15] (used reg = )
26292 741B           B0                     01  mov	al,*1
26293 741D           8846         17            mov	$17[bp],al
26294                                           !BCC_EOS
26295                                           ! 4495 int13_fail_noah:
26296                       00007420            .FFDF:
26297                       FFFFFFC6            ..FFDF	=	-$3A
26298                                           ! 4496   _write_byte(*(((Bit8u *)&AX)+1), 0x0074, 0x0040);
26299                                           ! Debug: list int = const $40 (used reg = )
26300 7420           B8                   0040  mov	ax,*$40
26301 7423           50                         push	ax
26302                                           ! Debug: list int = const $74 (used reg = )
26303 7424           B8                   0074  mov	ax,*$74
26304 7427           50                         push	ax
26305                                           ! Debug: list unsigned char AX = [S+$3E+$15] (used reg = )
26306 7428           8A46         17            mov	al,$17[bp]
26307 742B           30E4                       xor	ah,ah
26308 742D           50                         push	ax
26309                                           ! Debug: func () void = _write_byte+0 (used reg = )
26310 742E           E8         91CF            call	__write_byte
26311 7431           83C4                   06  add	sp,*6
26312                                           !BCC_EOS
26313                                           ! 4497 int13_fail_nostatus:
26314                       00007434            .FFDE:
26315                       FFFFFFC6            ..FFDE	=	-$3A
26316                                           ! 4498   FLAGS |= 0x0001;
26317                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$3A+$1A] (used reg = )
26318 7434           8B46         1C            mov	ax,$1C[bp]
26319 7437           0C                     01  or	al,*1
26320 7439           8946         1C            mov	$1C[bp],ax
26321                                           !BCC_EOS
26322                                           ! 4499   return;
26323 743C           89EC                       mov	sp,bp
26324 743E           5D                         pop	bp
26325 743F           C3                         ret
26326                                           !BCC_EOS
26327                                           ! 4500 int13_success:
26328                       00007440            .FFE0:
26329                       FFFFFFC6            ..FFE0	=	-$3A
26330                                           ! 4501   *(((Bit8u *)&AX)+1) = (0x00);
26331                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$3A+$15] (used reg = )
26332 7440           30C0                       xor	al,al
26333 7442           8846         17            mov	$17[bp],al
26334                                           !BCC_EOS
26335                                           ! 4502 int13_success_noah:
26336                       00007445            .FFDD:
26337                       FFFFFFC6            ..FFDD	=	-$3A
26338                                           ! 4503   _write_byte(0x00, 0x0074, 0x0040);
26339                                           ! Debug: list int = const $40 (used reg = )
26340 7445           B8                   0040  mov	ax,*$40
26341 7448           50                         push	ax
26342                                           ! Debug: list int = const $74 (used reg = )
26343 7449           B8                   0074  mov	ax,*$74
26344 744C           50                         push	ax
26345                                           ! Debug: list int = const 0 (used reg = )
26346 744D           31C0                       xor	ax,ax
26347 744F           50                         push	ax
26348                                           ! Debug: func () void = _write_byte+0 (used reg = )
26349 7450           E8         91AD            call	__write_byte
26350 7453           83C4                   06  add	sp,*6
26351                                           !BCC_EOS
26352                                           ! 4504   FLAGS &= 0xfffe;
26353                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$3A+$1A] (used reg = )
26354 7456           8B46         1C            mov	ax,$1C[bp]
26355 7459           24                     FE  and	al,#$FE
26356 745B           8946         1C            mov	$1C[bp],ax
26357                                           !BCC_EOS
26358                                           ! 4505 }
26359 745E           89EC                       mov	sp,bp
26360 7460           5D                         pop	bp
26361 7461           C3                         ret
26362                                           ! 4506 void floppy_reset_controller()
26363                                           ! Register BX used in function int13_cdemu
26364                                           ! 4507 {
26365                                           export	_floppy_reset_controller
26366                       00007462            _floppy_reset_controller:
26367                                           ! 4508   Bit8u val8;
26368                                           !BCC_EOS
26369                                           ! 4509   val8 = inb(0x03f2);
26370 7462           55                         push	bp
26371 7463           89E5                       mov	bp,sp
26372 7465           4C                         dec	sp
26373 7466           4C                         dec	sp
26374                                           ! Debug: list int = const $3F2 (used reg = )
26375 7467           B8                   03F2  mov	ax,#$3F2
26376 746A           50                         push	ax
26377                                           ! Debug: func () unsigned char = inb+0 (used reg = )
26378 746B           E8         908A            call	_inb
26379 746E           44                         inc	sp
26380 746F           44                         inc	sp
26381                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
26382 7470           8846         FF            mov	-1[bp],al
26383                                           !BCC_EOS
26384                                           ! 4510   outb(0x03f2, val8 & ~0x04);
26385                                           ! Debug: and int = const -5 to unsigned char val8 = [S+4-3] (used reg = )
26386 7473           8A46         FF            mov	al,-1[bp]
26387 7476           24                     FB  and	al,#$FB
26388                                           ! Debug: list unsigned char = al+0 (used reg = )
26389 7478           30E4                       xor	ah,ah
26390 747A           50                         push	ax
26391                                           ! Debug: list int = const $3F2 (used reg = )
26392 747B           B8                   03F2  mov	ax,#$3F2
26393 747E           50                         push	ax
26394                                           ! Debug: func () void = outb+0 (used reg = )
26395 747F           E8         908C            call	_outb
26396 7482           83C4                   04  add	sp,*4
26397                                           !BCC_EOS
26398                                           ! 4511   outb(0x03f2, val8 | 0x04);
26399                                           ! Debug: or int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
26400 7485           8A46         FF            mov	al,-1[bp]
26401 7488           0C                     04  or	al,*4
26402                                           ! Debug: list unsigned char = al+0 (used reg = )
26403 748A           30E4                       xor	ah,ah
26404 748C           50                         push	ax
26405                                           ! Debug: list int = const $3F2 (used reg = )
26406 748D           B8                   03F2  mov	ax,#$3F2
26407 7490           50                         push	ax
26408                                           ! Debug: func () void = outb+0 (used reg = )
26409 7491           E8         907A            call	_outb
26410 7494           83C4                   04  add	sp,*4
26411                                           !BCC_EOS
26412                                           ! 4512   do {
26413                       00007497            .65C:
26414                                           ! 4513     val8 = inb(0x03f4);
26415                                           ! Debug: list int = const $3F4 (used reg = )
26416 7497           B8                   03F4  mov	ax,#$3F4
26417 749A           50                         push	ax
26418                                           ! Debug: func () unsigned char = inb+0 (used reg = )
26419 749B           E8         905A            call	_inb
26420 749E           44                         inc	sp
26421 749F           44                         inc	sp
26422                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
26423 74A0           8846         FF            mov	-1[bp],al
26424                                           !BCC_EOS
26425                                           ! 4514   } while ((val8 & 0xc0) != 0x80);
26426                       000074A3            .65B:
26427                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+4-3] (used reg = )
26428 74A3           8A46         FF            mov	al,-1[bp]
26429 74A6           24                     C0  and	al,#$C0
26430                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
26431 74A8           3C                     80  cmp	al,#$80
26432 74AA           75           EB            jne	.65C
26433                       000074AC            .65D:
26434                                           !BCC_EOS
26435                                           ! 4515 }
26436                       000074AC            .65A:
26437 74AC           89EC                       mov	sp,bp
26438 74AE           5D                         pop	bp
26439 74AF           C3                         ret
26440                                           ! 4516 void floppy_prepare_controller(drive)
26441                                           ! 4517   Bit16u drive;
26442                                           export	_floppy_prepare_controller
26443                       000074B0            _floppy_prepare_controller:
26444                                           !BCC_EOS
26445                                           ! 4518 {
26446                                           ! 4519   Bit8u val8, dor, prev_reset;
26447                                           !BCC_EOS
26448                                           ! 4520   val8 = *((Bit8u *)(0x003e));
26449 74B0           55                         push	bp
26450 74B1           89E5                       mov	bp,sp
26451 74B3           83C4                   FC  add	sp,*-4
26452                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+6-3] (used reg = )
26453 74B6           A0         003E            mov	al,[$3E]
26454 74B9           8846         FF            mov	-1[bp],al
26455                                           !BCC_EOS
26456                                           ! 4521   val8 &= 0x7f;
26457                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
26458 74BC           8A46         FF            mov	al,-1[bp]
26459 74BF           24                     7F  and	al,*$7F
26460 74C1           8846         FF            mov	-1[bp],al
26461                                           !BCC_EOS
26462                                           ! 4522   *((Bit8u *)(0x003e)) = (val8);
26463                                           ! Debug: eq unsigned char val8 = [S+6-3] to unsigned char = [+$3E] (used reg = )
26464 74C4           8A46         FF            mov	al,-1[bp]
26465 74C7           A2         003E            mov	[$3E],al
26466                                           !BCC_EOS
26467                                           ! 4523   prev_reset = inb(0x03f2) & 0x04;
26468                                           ! Debug: list int = const $3F2 (used reg = )
26469 74CA           B8                   03F2  mov	ax,#$3F2
26470 74CD           50                         push	ax
26471                                           ! Debug: func () unsigned char = inb+0 (used reg = )
26472 74CE           E8         9027            call	_inb
26473 74D1           44                         inc	sp
26474 74D2           44                         inc	sp
26475                                           ! Debug: and int = const 4 to unsigned char = al+0 (used reg = )
26476 74D3           24                     04  and	al,*4
26477                                           ! Debug: eq unsigned char = al+0 to unsigned char prev_reset = [S+6-5] (used reg = )
26478 74D5           8846         FD            mov	-3[bp],al
26479                                           !BCC_EOS
26480                                           ! 4524   if (drive)
26481 74D8           8B46         04            mov	ax,4[bp]
26482 74DB           85C0                       test	ax,ax
26483 74DD           74           07            je  	.65E
26484                       000074DF            .65F:
26485                                           ! 4525     dor = 0x20;
26486                                           ! Debug: eq int = const $20 to unsigned char dor = [S+6-4] (used reg = )
26487 74DF           B0                     20  mov	al,*$20
26488 74E1           8846         FE            mov	-2[bp],al
26489                                           !BCC_EOS
26490                                           ! 4526   else
26491                                           ! 4527     dor = 0x10;
26492 74E4           EB           05            jmp .660
26493                       000074E6            .65E:
26494                                           ! Debug: eq int = const $10 to unsigned char dor = [S+6-4] (used reg = )
26495 74E6           B0                     10  mov	al,*$10
26496 74E8           8846         FE            mov	-2[bp],al
26497                                           !BCC_EOS
26498                                           ! 4528   dor |= 0x0c;
26499                       000074EB            .660:
26500                                           ! Debug: orab int = const $C to unsigned char dor = [S+6-4] (used reg = )
26501 74EB           8A46         FE            mov	al,-2[bp]
26502 74EE           0C                     0C  or	al,*$C
26503 74F0           8846         FE            mov	-2[bp],al
26504                                           !BCC_EOS
26505                                           ! 4529   dor |= drive;
26506                                           ! Debug: orab unsigned short drive = [S+6+2] to unsigned char dor = [S+6-4] (used reg = )
26507 74F3           8B46         04            mov	ax,4[bp]
26508 74F6           0A46         FE            or	al,-2[bp]
26509 74F9           8846         FE            mov	-2[bp],al
26510                                           !BCC_EOS
26511                                           ! 4530   outb(0x03f2, dor);
26512                                           ! Debug: list unsigned char dor = [S+6-4] (used reg = )
26513 74FC           8A46         FE            mov	al,-2[bp]
26514 74FF           30E4                       xor	ah,ah
26515 7501           50                         push	ax
26516                                           ! Debug: list int = const $3F2 (used reg = )
26517 7502           B8                   03F2  mov	ax,#$3F2
26518 7505           50                         push	ax
26519                                           ! Debug: func () void = outb+0 (used reg = )
26520 7506           E8         9005            call	_outb
26521 7509           83C4                   04  add	sp,*4
26522                                           !BCC_EOS
26523                                           ! 4531   *((Bit8u *)(0x40)) = (37);
26524                                           ! Debug: eq int = const $25 to unsigned char = [+$40] (used reg = )
26525 750C           B0                     25  mov	al,*$25
26526 750E           A2         0040            mov	[$40],al
26527                                           !BCC_EOS
26528                                           ! 4532   do {
26529                       00007511            .663:
26530                                           ! 4533     val8 = inb(0x03f4);
26531                                           ! Debug: list int = const $3F4 (used reg = )
26532 7511           B8                   03F4  mov	ax,#$3F4
26533 7514           50                         push	ax
26534                                           ! Debug: func () unsigned char = inb+0 (used reg = )
26535 7515           E8         8FE0            call	_inb
26536 7518           44                         inc	sp
26537 7519           44                         inc	sp
26538                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
26539 751A           8846         FF            mov	-1[bp],al
26540                                           !BCC_EOS
26541                                           ! 4534   } while ( (val8 & 0xc0) != 0x80 );
26542                       0000751D            .662:
26543                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+6-3] (used reg = )
26544 751D           8A46         FF            mov	al,-1[bp]
26545 7520           24                     C0  and	al,#$C0
26546                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
26547 7522           3C                     80  cmp	al,#$80
26548 7524           75           EB            jne	.663
26549                       00007526            .664:
26550                                           !BCC_EOS
26551                                           ! 4535   if (prev_reset == 0) {
26552                       00007526            .661:
26553                                           ! Debug: logeq int = const 0 to unsigned char prev_reset = [S+6-5] (used reg = )
26554 7526           8A46         FD            mov	al,-3[bp]
26555 7529           84C0                       test	al,al
26556 752B           75           1F            jne 	.665
26557                       0000752D            .666:
26558                                           ! 4536 #asm
26559                                           !BCC_EOS
26560                                           !BCC_ASM
26561                       00000002            _floppy_prepare_controller.dor	set	2
26562                       FFFFFFFE            .floppy_prepare_controller.dor	set	-2
26563                       00000001            _floppy_prepare_controller.prev_reset	set	1
26564                       FFFFFFFD            .floppy_prepare_controller.prev_reset	set	-3
26565                       00000003            _floppy_prepare_controller.val8	set	3
26566                       FFFFFFFF            .floppy_prepare_controller.val8	set	-1
26567                       00000008            _floppy_prepare_controller.drive	set	8
26568                       00000004            .floppy_prepare_controller.drive	set	4
26569 752D           FB                             sti
26570                                           ! 4538 endasm
26571                                           !BCC_ENDASM
26572                                           !BCC_EOS
26573                                           ! 4539     do {
26574                       0000752E            .669:
26575                                           ! 4540       val8 = *((Bit8u *)(0x003e));
26576                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+6-3] (used reg = )
26577 752E           A0         003E            mov	al,[$3E]
26578 7531           8846         FF            mov	-1[bp],al
26579                                           !BCC_EOS
26580                                           ! 4541     } while ( (val8 & 0x80) == 0 );
26581                       00007534            .668:
26582                                           ! Debug: and int = const $80 to unsigned char val8 = [S+6-3] (used reg = )
26583 7534           8A46         FF            mov	al,-1[bp]
26584 7537           24                     80  and	al,#$80
26585                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
26586 7539           84C0                       test	al,al
26587 753B           74           F1            je 	.669
26588                       0000753D            .66A:
26589                                           !BCC_EOS
26590                                           ! 4542     val8 &= 0x7f;
26591                       0000753D            .667:
26592                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
26593 753D           8A46         FF            mov	al,-1[bp]
26594 7540           24                     7F  and	al,*$7F
26595 7542           8846         FF            mov	-1[bp],al
26596                                           !BCC_EOS
26597                                           ! 4543 #asm
26598                                           !BCC_EOS
26599                                           !BCC_ASM
26600                       00000002            _floppy_prepare_controller.dor	set	2
26601                       FFFFFFFE            .floppy_prepare_controller.dor	set	-2
26602                       00000001            _floppy_prepare_controller.prev_reset	set	1
26603                       FFFFFFFD            .floppy_prepare_controller.prev_reset	set	-3
26604                       00000003            _floppy_prepare_controller.val8	set	3
26605                       FFFFFFFF            .floppy_prepare_controller.val8	set	-1
26606                       00000008            _floppy_prepare_controller.drive	set	8
26607                       00000004            .floppy_prepare_controller.drive	set	4
26608 7545           FA                             cli
26609                                           ! 4545 endasm
26610                                           !BCC_ENDASM
26611                                           !BCC_EOS
26612                                           ! 4546     *((Bit8u *)(0x003e)) = (val8);
26613                                           ! Debug: eq unsigned char val8 = [S+6-3] to unsigned char = [+$3E] (used reg = )
26614 7546           8A46         FF            mov	al,-1[bp]
26615 7549           A2         003E            mov	[$3E],al
26616                                           !BCC_EOS
26617                                           ! 4547   }
26618                                           ! 4548 }
26619                       0000754C            .665:
26620 754C           89EC                       mov	sp,bp
26621 754E           5D                         pop	bp
26622 754F           C3                         ret
26623                                           ! 4549   bx_bool
26624                                           ! 4550 floppy_media_known(drive)
26625                                           ! 4551   Bit16u drive;
26626                                           export	_floppy_media_known
26627                       00007550            _floppy_media_known:
26628                                           !BCC_EOS
26629                                           ! 4552 {
26630                                           ! 4553   Bit8u val8;
26631                                           !BCC_EOS
26632                                           ! 4554   Bit16u media_state_offset;
26633                                           !BCC_EOS
26634                                           ! 4555   val8 = *((Bit8u *)(0x003e));
26635 7550           55                         push	bp
26636 7551           89E5                       mov	bp,sp
26637 7553           83C4                   FC  add	sp,*-4
26638                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+6-3] (used reg = )
26639 7556           A0         003E            mov	al,[$3E]
26640 7559           8846         FF            mov	-1[bp],al
26641                                           !BCC_EOS
26642                                           ! 4556   if (drive)
26643 755C           8B46         04            mov	ax,4[bp]
26644 755F           85C0                       test	ax,ax
26645 7561           74           0A            je  	.66B
26646                       00007563            .66C:
26647                                           ! 4557 
26648                                           ! 4557     val8 >>= 1;
26649                                           ! Debug: srab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
26650 7563           8A46         FF            mov	al,-1[bp]
26651 7566           30E4                       xor	ah,ah
26652 7568           D1E8                       shr	ax,*1
26653 756A           8846         FF            mov	-1[bp],al
26654                                           !BCC_EOS
26655                                           ! 4558   val8 &= 0x01;
26656                       0000756D            .66B:
26657                                           ! Debug: andab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
26658 756D           8A46         FF            mov	al,-1[bp]
26659 7570           24                     01  and	al,*1
26660 7572           8846         FF            mov	-1[bp],al
26661                                           !BCC_EOS
26662                                           ! 4559   if (val8 == 0)
26663                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
26664 7575           8A46         FF            mov	al,-1[bp]
26665 7578           84C0                       test	al,al
26666 757A           75           06            jne 	.66D
26667                       0000757C            .66E:
26668                                           ! 4560     return(0);
26669 757C           31C0                       xor	ax,ax
26670 757E           89EC                       mov	sp,bp
26671 7580           5D                         pop	bp
26672 7581           C3                         ret
26673                                           !BCC_EOS
26674                                           ! 4561   media_state_offset = 0x0090;
26675                       00007582            .66D:
26676                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+6-6] (used reg = )
26677 7582           B8                   0090  mov	ax,#$90
26678 7585           8946         FC            mov	-4[bp],ax
26679                                           !BCC_EOS
26680                                           ! 4562   if (drive)
26681 7588           8B46         04            mov	ax,4[bp]
26682 758B           85C0                       test	ax,ax
26683 758D           74           07            je  	.66F
26684                       0000758F            .670:
26685                                           ! 4563     media_state_offset += 1;
26686                                           ! Debug: addab int = const 1 to unsigned short media_state_offset = [S+6-6] (used reg = )
26687 758F           8B46         FC            mov	ax,-4[bp]
26688 7592           40                         inc	ax
26689 7593           8946         FC            mov	-4[bp],ax
26690                                           !BCC_EOS
26691                                           ! 4564   val8 = *((Bit8u *)(media_state_offset));
26692                       00007596            .66F:
26693 7596           8B5E         FC            mov	bx,-4[bp]
26694                                           ! Debug: eq unsigned char = [bx+0] to unsigned char val8 = [S+6-3] (used reg = )
26695 7599           8A07                       mov	al,[bx]
26696 759B           8846         FF            mov	-1[bp],al
26697                                           !BCC_EOS
26698                                           ! 4565   val8 = (val8 >> 4) & 0x01;
26699                                           ! Debug: sr int = const 4 to unsigned char val8 = [S+6-3] (used reg = )
26700 759E           8A46         FF            mov	al,-1[bp]
26701 75A1           30E4                       xor	ah,ah
26702 75A3           B1                     04  mov	cl,*4
26703 75A5           D3E8                       shr	ax,cl
26704                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
26705 75A7           24                     01  and	al,*1
26706                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
26707 75A9           8846         FF            mov	-1[bp],al
26708                                           !BCC_EOS
26709                                           ! 4566   if (val8 == 0)
26710                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
26711 75AC           8A46         FF            mov	al,-1[bp]
26712 75AF           84C0                       test	al,al
26713 75B1           75           06            jne 	.671
26714                       000075B3            .672:
26715                                           ! 4567     return(0);
26716 75B3           31C0                       xor	ax,ax
26717 75B5           89EC                       mov	sp,bp
26718 75B7           5D                         pop	bp
26719 75B8           C3                         ret
26720                                           !BCC_EOS
26721                                           ! 4568   return(1);
26722                       000075B9            .671:
26723 75B9           B8                   0001  mov	ax,*1
26724 75BC           89EC                       mov	sp,bp
26725 75BE           5D                         pop	bp
26726 75BF           C3                         ret
26727                                           !BCC_EOS
26728                                           ! 4569 }
26729                                           ! 4570   bx_bool
26730                                           ! Register BX used in function floppy_media_known
26731                                           ! 4571 floppy_media_sense(drive)
26732                                           ! 4572   Bit16u drive;
26733                                           export	_floppy_media_sense
26734                       000075C0            _floppy_media_sense:
26735                                           !BCC_EOS
26736                                           ! 4573 {
26737                                           ! 4574   bx_bool retval;
26738                                           !BCC_EOS
26739                                           ! 4575   Bit16u media_state_offset;
26740                                           !BCC_EOS
26741                                           ! 4576   Bit8u drive_type, config_data, media_state;
26742                                           !BCC_EOS
26743                                           ! 4577   if (floppy_drive_recal(drive) == 0) {
26744 75C0           55                         push	bp
26745 75C1           89E5                       mov	bp,sp
26746 75C3           83C4                   F8  add	sp,*-8
26747                                           ! Debug: list unsigned short drive = [S+$A+2] (used reg = )
26748 75C6           FF76         04            push	4[bp]
26749                                           ! Debug: func () unsigned short = floppy_drive_recal+0 (used reg = )
26750 75C9           E8         00E4            call	_floppy_drive_recal
26751 75CC           44                         inc	sp
26752 75CD           44                         inc	sp
26753                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
26754 75CE           85C0                       test	ax,ax
26755 75D0           75           06            jne 	.673
26756                       000075D2            .674:
26757                                           ! 4578     return(0);
26758 75D2           31C0                       xor	ax,ax
26759 75D4           89EC                       mov	sp,bp
26760 75D6           5D                         pop	bp
26761 75D7           C3                         ret
26762                                           !BCC_EOS
26763                                           ! 4579   }
26764                                           ! 4580   drive_type = inb_cmos(0x10);
26765                       000075D8            .673:
26766                                           ! Debug: list int = const $10 (used reg = )
26767 75D8           B8                   0010  mov	ax,*$10
26768 75DB           50                         push	ax
26769                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
26770 75DC           E8         8F5E            call	_inb_cmos
26771 75DF           44                         inc	sp
26772 75E0           44                         inc	sp
26773                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$A-7] (used reg = )
26774 75E1           8846         FB            mov	-5[bp],al
26775                                           !BCC_EOS
26776                                           ! 4581   if (drive == 0)
26777                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
26778 75E4           8B46         04            mov	ax,4[bp]
26779 75E7           85C0                       test	ax,ax
26780 75E9           75           0E            jne 	.675
26781                       000075EB            .676:
26782                                           ! 4582     drive_type >>= 4;
26783                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
26784 75EB           8A46         FB            mov	al,-5[bp]
26785 75EE           30E4                       xor	ah,ah
26786 75F0           B1                     04  mov	cl,*4
26787 75F2           D3E8                       shr	ax,cl
26788 75F4           8846         FB            mov	-5[bp],al
26789                                           !BCC_EOS
26790                                           ! 4583   else
26791                                           ! 4584     drive_type &= 0x0f;
26792 75F7           EB           08            jmp .677
26793                       000075F9            .675:
26794                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$A-7] (used reg = )
26795 75F9           8A46         FB            mov	al,-5[bp]
26796 75FC           24                     0F  and	al,*$F
26797 75FE           8846         FB            mov	-5[bp],al
26798                                           !BCC_EOS
26799                                           ! 4585   switch(drive_type) {
26800                       00007601            .677:
26801 7601           8A46         FB            mov	al,-5[bp]
26802 7604           EB           5B            jmp .67A
26803                                           ! 4586     case 1:
26804                                           ! 4587     case 2:
26805                       00007606            .67B:
26806                                           ! 4588       config_data = 0x00;
26807                       00007606            .67C:
26808                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
26809 7606           30C0                       xor	al,al
26810 7608           8846         FA            mov	-6[bp],al
26811                                           !BCC_EOS
26812                                           ! 4589       media_state = 0x25;
26813                                           ! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
26814 760B           B0                     25  mov	al,*$25
26815 760D           8846         F9            mov	-7[bp],al
26816                                           !BCC_EOS
26817                                           ! 4590       retval = 1;
26818                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
26819 7610           B8                   0001  mov	ax,*1
26820 7613           8946         FE            mov	-2[bp],ax
26821                                           !BCC_EOS
26822                                           ! 4591       break;
26823 7616           EB           6E            jmp .678
26824                                           !BCC_EOS
26825                                           ! 4592     case 3:
26826                                           ! 4593     case 4:
26827                       00007618            .67D:
26828                                           ! 4594       config_data = 0x00;
26829                       00007618            .67E:
26830                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
26831 7618           30C0                       xor	al,al
26832 761A           8846         FA            mov	-6[bp],al
26833                                           !BCC_EOS
26834                                           ! 4595       media_state = 0x17;
26835                                           ! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
26836 761D           B0                     17  mov	al,*$17
26837 761F           8846         F9            mov	-7[bp],al
26838                                           !BCC_EOS
26839                                           ! 4596       retval = 1;
26840                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
26841 7622           B8                   0001  mov	ax,*1
26842 7625           8946         FE            mov	-2[bp],ax
26843                                           !BCC_EOS
26844                                           ! 4597       break;
26845 7628           EB           5C            jmp .678
26846                                           !BCC_EOS
26847                                           ! 4598     case 5:
26848                                           ! 4599       config_data = 0xCC;
26849                       0000762A            .67F:
26850                                           ! Debug: eq int = const $CC to unsigned char config_data = [S+$A-8] (used reg = )
26851 762A           B0                     CC  mov	al,#$CC
26852 762C           8846         FA            mov	-6[bp],al
26853                                           !BCC_EOS
26854                                           ! 4600       media_state = 0xD7;
26855                                           ! Debug: eq int = const $D7 to unsigned char media_state = [S+$A-9] (used reg = )
26856 762F           B0                     D7  mov	al,#$D7
26857 7631           8846         F9            mov	-7[bp],al
26858                                           !BCC_EOS
26859                                           ! 4601       retval = 1;
26860                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
26861 7634           B8                   0001  mov	ax,*1
26862 7637           8946         FE            mov	-2[bp],ax
26863                                           !BCC_EOS
26864                                           ! 4602       break;
26865 763A           EB           4A            jmp .678
26866                                           !BCC_EOS
26867                                           ! 4603     case 6:
26868                                           ! 4604     case 7:
26869                       0000763C            .680:
26870                                           ! 4605     case 8:
26871                       0000763C            .681:
26872                                           ! 4606       config_data = 0x00;
26873                       0000763C            .682:
26874                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
26875 763C           30C0                       xor	al,al
26876 763E           8846         FA            mov	-6[bp],al
26877                                           !BCC_EOS
26878                                           ! 4607       media_state = 0x27;
26879                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
26880 7641           B0                     27  mov	al,*$27
26881 7643           8846         F9            mov	-7[bp],al
26882                                           !BCC_EOS
26883                                           ! 4608       retval = 1;
26884                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
26885 7646           B8                   0001  mov	ax,*1
26886 7649           8946         FE            mov	-2[bp],ax
26887                                           !BCC_EOS
26888                                           ! 4609       break;
26889 764C           EB           38            jmp .678
26890                                           !BCC_EOS
26891                                           ! 4610     default:
26892                                           ! 4611       config_data = 0x00;
26893                       0000764E            .683:
26894                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
26895 764E           30C0                       xor	al,al
26896 7650           8846         FA            mov	-6[bp],al
26897                                           !BCC_EOS
26898                                           ! 4612       media_state = 0x00;
26899                                           ! Debug: eq int = const 0 to unsigned char media_state = [S+$A-9] (used reg = )
26900 7653           30C0                       xor	al,al
26901 7655           8846         F9            mov	-7[bp],al
26902                                           !BCC_EOS
26903                                           ! 4613       retval = 0;
26904                                           ! Debug: eq int = const 0 to unsigned short retval = [S+$A-4] (used reg = )
26905 7658           31C0                       xor	ax,ax
26906 765A           8946         FE            mov	-2[bp],ax
26907                                           !BCC_EOS
26908                                           ! 4614       break;
26909 765D           EB           27            jmp .678
26910                                           !BCC_EOS
26911                                           ! 4615   }
26912                                           ! 4616   if (drive == 0)
26913 765F           EB           25            jmp .678
26914                       00007661            .67A:
26915 7661           2C                     01  sub	al,*1
26916 7663           72           E9            jb 	.683
26917 7665           3C                     07  cmp	al,*7
26918 7667           77           1B            ja  	.684
26919 7669           30E4                       xor	ah,ah
26920 766B           D1E0                       shl	ax,*1
26921 766D           89C3                       mov	bx,ax
26922 766F           2E                         seg	cs
26923 7670           FFA7       7674            br	.685[bx]
26924                       00007674            .685:
26925 7674                      7606            .word	.67B
26926 7676                      7606            .word	.67C
26927 7678                      7618            .word	.67D
26928 767A                      7618            .word	.67E
26929 767C                      762A            .word	.67F
26930 767E                      763C            .word	.680
26931 7680                      763C            .word	.681
26932 7682                      763C            .word	.682
26933                       00007684            .684:
26934 7684           EB           C8            jmp	.683
26935                       00007686            .678:
26936                       FFFFFFF6            ..FFDC	=	-$A
26937                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
26938 7686           8B46         04            mov	ax,4[bp]
26939 7689           85C0                       test	ax,ax
26940 768B           75           08            jne 	.686
26941                       0000768D            .687:
26942                                           ! 4617     media_state_offset = 0x90;
26943                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+$A-6] (used reg = )
26944 768D           B8                   0090  mov	ax,#$90
26945 7690           8946         FC            mov	-4[bp],ax
26946                                           !BCC_EOS
26947                                           ! 4618   else
26948                                           ! 4619     media_state_offset = 0x91;
26949 7693           EB           06            jmp .688
26950                       00007695            .686:
26951                                           ! Debug: eq int = const $91 to unsigned short media_state_offset = [S+$A-6] (used reg = )
26952 7695           B8                   0091  mov	ax,#$91
26953 7698           8946         FC            mov	-4[bp],ax
26954                                           !BCC_EOS
26955                                           ! 4620   *((Bit8u *)(0x008B)) = (config_data);
26956                       0000769B            .688:
26957                                           ! Debug: eq unsigned char config_data = [S+$A-8] to unsigned char = [+$8B] (used reg = )
26958 769B           8A46         FA            mov	al,-6[bp]
26959 769E           A2         008B            mov	[$8B],al
26960                                           !BCC_EOS
26961                                           ! 4621   *((Bit8u *)(media_state_offset)) = (media_state);
26962 76A1           8B5E         FC            mov	bx,-4[bp]
26963                                           ! Debug: eq unsigned char media_state = [S+$A-9] to unsigned char = [bx+0] (used reg = )
26964 76A4           8A46         F9            mov	al,-7[bp]
26965 76A7           8807                       mov	[bx],al
26966                                           !BCC_EOS
26967                                           ! 4622   return(retval);
26968 76A9           8B46         FE            mov	ax,-2[bp]
26969 76AC           89EC                       mov	sp,bp
26970 76AE           5D                         pop	bp
26971 76AF           C3                         ret
26972                                           !BCC_EOS
26973                                           ! 4623 }
26974                                           ! 4624   bx_bool
26975                                           ! Register BX used in function floppy_media_sense
26976                                           ! 4625 floppy_drive_recal(drive)
26977                                           ! 4626   Bit16u drive;
26978                                           export	_floppy_drive_recal
26979                       000076B0            _floppy_drive_recal:
26980                                           !BCC_EOS
26981                                           ! 4627 {
26982                                           ! 4628   Bit8u val8;
26983                                           !BCC_EOS
26984                                           ! 4629   Bit16u curr_cyl_offset;
26985                                           !BCC_EOS
26986                                           ! 4630   floppy_prepare_controller(drive);
26987 76B0           55                         push	bp
26988 76B1           89E5                       mov	bp,sp
26989 76B3           83C4                   FC  add	sp,*-4
26990                                           ! Debug: list unsigned short drive = [S+6+2] (used reg = )
26991 76B6           FF76         04            push	4[bp]
26992                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
26993 76B9           E8         FDF4            call	_floppy_prepare_controller
26994 76BC           44                         inc	sp
26995 76BD           44                         inc	sp
26996                                           !BCC_EOS
26997                                           ! 4631   outb(0x03f5, 0x07);
26998                                           ! Debug: list int = const 7 (used reg = )
26999 76BE           B8                   0007  mov	ax,*7
27000 76C1           50                         push	ax
27001                                           ! Debug: list int = const $3F5 (used reg = )
27002 76C2           B8                   03F5  mov	ax,#$3F5
27003 76C5           50                         push	ax
27004                                           ! Debug: func () void = outb+0 (used reg = )
27005 76C6           E8         8E45            call	_outb
27006 76C9           83C4                   04  add	sp,*4
27007                                           !BCC_EOS
27008                                           ! 4632   outb(0x03f5, drive);
27009                                           ! Debug: list unsigned short drive = [S+6+2] (used reg = )
27010 76CC           FF76         04            push	4[bp]
27011                                           ! Debug: list int = const $3F5 (used reg = )
27012 76CF           B8                   03F5  mov	ax,#$3F5
27013 76D2           50                         push	ax
27014                                           ! Debug: func () void = outb+0 (used reg = )
27015 76D3           E8         8E38            call	_outb
27016 76D6           83C4                   04  add	sp,*4
27017                                           !BCC_EOS
27018                                           ! 4633 #asm
27019                                           !BCC_EOS
27020                                           !BCC_ASM
27021                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
27022                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
27023                       00000003            _floppy_drive_recal.val8	set	3
27024                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
27025                       00000008            _floppy_drive_recal.drive	set	8
27026                       00000004            .floppy_drive_recal.drive	set	4
27027 76D9           FB                           sti
27028                                           ! 4635 endasm
27029                                           !BCC_ENDASM
27030                                           !BCC_EOS
27031                                           ! 4636   do {
27032                       000076DA            .68B:
27033                                           ! 4637     val8 = (*((Bit8u *)(0x003e)) & 0x80);
27034                                           ! Debug: and int = const $80 to unsigned char = [+$3E] (used reg = )
27035 76DA           A0         003E            mov	al,[$3E]
27036 76DD           24                     80  and	al,#$80
27037                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
27038 76DF           8846         FF            mov	-1[bp],al
27039                                           !BCC_EOS
27040                                           ! 4638   } while ( val8 == 0 );
27041                       000076E2            .68A:
27042                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
27043 76E2           8A46         FF            mov	al,-1[bp]
27044 76E5           84C0                       test	al,al
27045 76E7           74           F1            je 	.68B
27046                       000076E9            .68C:
27047                                           !BCC_EOS
27048                                           ! 4639   val8 = 0;
27049                       000076E9            .689:
27050                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
27051 76E9           30C0                       xor	al,al
27052 76EB           8846         FF            mov	-1[bp],al
27053                                           !BCC_EOS
27054                                           ! 4640 #asm
27055                                           !BCC_EOS
27056                                           !BCC_ASM
27057                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
27058                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
27059                       00000003            _floppy_drive_recal.val8	set	3
27060                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
27061                       00000008            _floppy_drive_recal.drive	set	8
27062                       00000004            .floppy_drive_recal.drive	set	4
27063 76EE           FA                           cli
27064                                           ! 4642 endasm
27065                                           !BCC_ENDASM
27066                                           !BCC_EOS
27067                                           ! 4643   val8 = *((Bit8u *)(0x003e));
27068                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+6-3] (used reg = )
27069 76EF           A0         003E            mov	al,[$3E]
27070 76F2           8846         FF            mov	-1[bp],al
27071                                           !BCC_EOS
27072                                           ! 4644   val8 &= 0x7f;
27073                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
27074 76F5           8A46         FF            mov	al,-1[bp]
27075 76F8           24                     7F  and	al,*$7F
27076 76FA           8846         FF            mov	-1[bp],al
27077                                           !BCC_EOS
27078                                           ! 4645   if (drive) {
27079 76FD           8B46         04            mov	ax,4[bp]
27080 7700           85C0                       test	ax,ax
27081 7702           74           10            je  	.68D
27082                       00007704            .68E:
27083                                           ! 4646     val8 |= 0x02;
27084                                           ! Debug: orab int = const 2 to unsigned char val8 = [S+6-3] (used reg = )
27085 7704           8A46         FF            mov	al,-1[bp]
27086 7707           0C                     02  or	al,*2
27087 7709           8846         FF            mov	-1[bp],al
27088                                           !BCC_EOS
27089                                           ! 4647     curr_cyl_offset = 0x0095;
27090                                           ! Debug: eq int = const $95 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
27091 770C           B8                   0095  mov	ax,#$95
27092 770F           8946         FC            mov	-4[bp],ax
27093                                           !BCC_EOS
27094                                           ! 4648   } else {
27095 7712           EB           0E            jmp .68F
27096                       00007714            .68D:
27097                                           ! 4649     val8 |= 0x01;
27098                                           ! Debug: orab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
27099 7714           8A46         FF            mov	al,-1[bp]
27100 7717           0C                     01  or	al,*1
27101 7719           8846         FF            mov	-1[bp],al
27102                                           !BCC_EOS
27103                                           ! 4650     curr_cyl_offset = 0x0094;
27104                                           ! Debug: eq int = const $94 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
27105 771C           B8                   0094  mov	ax,#$94
27106 771F           8946         FC            mov	-4[bp],ax
27107                                           !BCC_EOS
27108                                           ! 4651   }
27109                                           ! 4652   *((Bit8u *)(0x003e)) = (val8);
27110                       00007722            .68F:
27111                                           ! Debug: eq unsigned char val8 = [S+6-3] to unsigned char = [+$3E] (used reg = )
27112 7722           8A46         FF            mov	al,-1[bp]
27113 7725           A2         003E            mov	[$3E],al
27114                                           !BCC_EOS
27115                                           ! 4653   *((Bit8u *)(curr_cyl_offset)) = (0);
27116 7728           8B5E         FC            mov	bx,-4[bp]
27117                                           ! Debug: eq int = const 0 to unsigned char = [bx+0] (used reg = )
27118 772B           30C0                       xor	al,al
27119 772D           8807                       mov	[bx],al
27120                                           !BCC_EOS
27121                                           ! 4654   return(1);
27122 772F           B8                   0001  mov	ax,*1
27123 7732           89EC                       mov	sp,bp
27124 7734           5D                         pop	bp
27125 7735           C3                         ret
27126                                           !BCC_EOS
27127                                           ! 4655 }
27128                                           ! 4656   bx_bool
27129                                           ! Register BX used in function floppy_drive_recal
27130                                           ! 4657 floppy_drive_exists(drive)
27131                                           ! 4658   Bit16u drive;
27132                                           export	_floppy_drive_exists
27133                       00007736            _floppy_drive_exists:
27134                                           !BCC_EOS
27135                                           ! 4659 {
27136                                           ! 4660   Bit8u drive_type;
27137                                           !BCC_EOS
27138                                           ! 4661   drive_type = inb_cmos(0x10);
27139 7736           55                         push	bp
27140 7737           89E5                       mov	bp,sp
27141 7739           4C                         dec	sp
27142 773A           4C                         dec	sp
27143                                           ! Debug: list int = const $10 (used reg = )
27144 773B           B8                   0010  mov	ax,*$10
27145 773E           50                         push	ax
27146                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
27147 773F           E8         8DFB            call	_inb_cmos
27148 7742           44                         inc	sp
27149 7743           44                         inc	sp
27150                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+4-3] (used reg = )
27151 7744           8846         FF            mov	-1[bp],al
27152                                           !BCC_EOS
27153                                           ! 4662   if (drive == 0)
27154                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+4+2] (used reg = )
27155 7747           8B46         04            mov	ax,4[bp]
27156 774A           85C0                       test	ax,ax
27157 774C           75           0E            jne 	.690
27158                       0000774E            .691:
27159                                           ! 4663     drive_type >>= 4;
27160                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+4-3] (used reg = )
27161 774E           8A46         FF            mov	al,-1[bp]
27162 7751           30E4                       xor	ah,ah
27163 7753           B1                     04  mov	cl,*4
27164 7755           D3E8                       shr	ax,cl
27165 7757           8846         FF            mov	-1[bp],al
27166                                           !BCC_EOS
27167                                           ! 4664   else
27168                                           ! 4665     drive_type &= 0x0f
27169 775A           EB           08            jmp .692
27170                       0000775C            .690:
27171                                           ! 4665 ;
27172                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+4-3] (used reg = )
27173 775C           8A46         FF            mov	al,-1[bp]
27174 775F           24                     0F  and	al,*$F
27175 7761           8846         FF            mov	-1[bp],al
27176                                           !BCC_EOS
27177                                           ! 4666   if ( drive_type == 0 )
27178                       00007764            .692:
27179                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+4-3] (used reg = )
27180 7764           8A46         FF            mov	al,-1[bp]
27181 7767           84C0                       test	al,al
27182 7769           75           08            jne 	.693
27183                       0000776B            .694:
27184                                           ! 4667     return(0);
27185 776B           31C0                       xor	ax,ax
27186 776D           89EC                       mov	sp,bp
27187 776F           5D                         pop	bp
27188 7770           C3                         ret
27189                                           !BCC_EOS
27190                                           ! 4668   else
27191                                           ! 4669     return(1);
27192 7771           EB           07            jmp .695
27193                       00007773            .693:
27194 7773           B8                   0001  mov	ax,*1
27195 7776           89EC                       mov	sp,bp
27196 7778           5D                         pop	bp
27197 7779           C3                         ret
27198                                           !BCC_EOS
27199                                           ! 4670 }
27200                       0000777A            .695:
27201 777A           89EC                       mov	sp,bp
27202 777C           5D                         pop	bp
27203 777D           C3                         ret
27204                                           ! 4671   void
27205                                           ! 4672 int13_diskette_function(DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
27206                                           ! 4673   Bit16u DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
27207                                           export	_int13_diskette_function
27208                       0000777E            _int13_diskette_function:
27209                                           !BCC_EOS
27210                                           ! 4674 {
27211                                           ! 4675   Bit8u drive, num_sectors, track, sector, head, status;
27212                                           !BCC_EOS
27213                                           ! 4676   Bit16u base_address, base_count, base_es;
27214                                           !BCC_EOS
27215                                           ! 4677   Bit8u page, mode_register, val8, dor;
27216                                           !BCC_EOS
27217                                           ! 4678   Bit8u return_status[7];
27218                                           !BCC_EOS
27219                                           ! 4679   Bit8u drive_type, num_floppies, ah, spt;
27220                                           !BCC_EOS
27221                                           ! 4680   Bit16u es, last_addr, maxCyl;
27222                                           !BCC_EOS
27223                                           ! 4681   ;
27224 777E           55                         push	bp
27225 777F           89E5                       mov	bp,sp
27226 7781           83C4                   DE  add	sp,*-$22
27227                                           !BCC_EOS
27228                                           ! 4682   ah = *(((Bit8u *)&AX)+1);
27229                                           ! Debug: eq unsigned char AX = [S+$24+$15] to unsigned char ah = [S+$24-$1C] (used reg = )
27230 7784           8A46         17            mov	al,$17[bp]
27231 7787           8846         E6            mov	-$1A[bp],al
27232                                           !BCC_EOS
27233                                           ! 4683   switch ( ah ) {
27234 778A           8A46         E6            mov	al,-$1A[bp]
27235 778D           E9         0E5C            br 	.698
27236                                           ! 4684     case 0x00:
27237                                           ! 4685 ;
27238                       00007790            .699:
27239                                           !BCC_EOS
27240                                           ! 4686       drive = ( ELDX & 0x00ff );
27241                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
27242 7790           8A46         0E            mov	al,$E[bp]
27243                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
27244 7793           8846         FF            mov	-1[bp],al
27245                                           !BCC_EOS
27246                                           ! 4687       if (drive > 1) {
27247                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
27248 7796           8A46         FF            mov	al,-1[bp]
27249 7799           3C                     01  cmp	al,*1
27250 779B           76           1A            jbe 	.69A
27251                       0000779D            .69B:
27252                                           ! 4688         *(((Bit8u *)&AX)+1) = (1);
27253                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
27254 779D           B0                     01  mov	al,*1
27255 779F           8846         17            mov	$17[bp],al
27256                                           !BCC_EOS
27257                                           ! 4689         set_diskette_ret_status(1);
27258                                           ! Debug: list int = const 1 (used reg = )
27259 77A2           B8                   0001  mov	ax,*1
27260 77A5           50                         push	ax
27261                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27262 77A6           E8         0E86            call	_set_diskette_ret_status
27263 77A9           44                         inc	sp
27264 77AA           44                         inc	sp
27265                                           !BCC_EOS
27266                                           ! 4690         FLAGS |= 0x0001;
27267                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27268 77AB           8B46         1C            mov	ax,$1C[bp]
27269 77AE           0C                     01  or	al,*1
27270 77B0           8946         1C            mov	$1C[bp],ax
27271                                           !BCC_EOS
27272                                           ! 4691         return;
27273 77B3           89EC                       mov	sp,bp
27274 77B5           5D                         pop	bp
27275 77B6           C3                         ret
27276                                           !BCC_EOS
27277                                           ! 4692       }
27278                                           ! 4693       drive_type = inb_cmos(0x10);
27279                       000077B7            .69A:
27280                                           ! Debug: list int = const $10 (used reg = )
27281 77B7           B8                   0010  mov	ax,*$10
27282 77BA           50                         push	ax
27283                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
27284 77BB           E8         8D7F            call	_inb_cmos
27285 77BE           44                         inc	sp
27286 77BF           44                         inc	sp
27287                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
27288 77C0           8846         E8            mov	-$18[bp],al
27289                                           !BCC_EOS
27290                                           ! 4694       if (drive == 0)
27291                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$24-3] (used reg = )
27292 77C3           8A46         FF            mov	al,-1[bp]
27293 77C6           84C0                       test	al,al
27294 77C8           75           0E            jne 	.69C
27295                       000077CA            .69D:
27296                                           ! 4695         drive_type >>= 4;
27297                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$24-$1A] (used reg = )
27298 77CA           8A46         E8            mov	al,-$18[bp]
27299 77CD           30E4                       xor	ah,ah
27300 77CF           B1                     04  mov	cl,*4
27301 77D1           D3E8                       shr	ax,cl
27302 77D3           8846         E8            mov	-$18[bp],al
27303                                           !BCC_EOS
27304                                           ! 4696       else
27305                                           ! 4697         drive_type &= 0x0f;
27306 77D6           EB           08            jmp .69E
27307                       000077D8            .69C:
27308                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$24-$1A] (used reg = )
27309 77D8           8A46         E8            mov	al,-$18[bp]
27310 77DB           24                     0F  and	al,*$F
27311 77DD           8846         E8            mov	-$18[bp],al
27312                                           !BCC_EOS
27313                                           ! 4698       if (drive_type == 0) {
27314                       000077E0            .69E:
27315                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
27316 77E0           8A46         E8            mov	al,-$18[bp]
27317 77E3           84C0                       test	al,al
27318 77E5           75           1A            jne 	.69F
27319                       000077E7            .6A0:
27320                                           ! 4699         *(((Bit8u *)&AX)+1) = (0x80);
27321                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
27322 77E7           B0                     80  mov	al,#$80
27323 77E9           8846         17            mov	$17[bp],al
27324                                           !BCC_EOS
27325                                           ! 4700         set_diskette_ret_status(0x80);
27326                                           ! Debug: list int = const $80 (used reg = )
27327 77EC           B8                   0080  mov	ax,#$80
27328 77EF           50                         push	ax
27329                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27330 77F0           E8         0E3C            call	_set_diskette_ret_status
27331 77F3           44                         inc	sp
27332 77F4           44                         inc	sp
27333                                           !BCC_EOS
27334                                           ! 4701         FLAGS |= 0x0001;
27335                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27336 77F5           8B46         1C            mov	ax,$1C[bp]
27337 77F8           0C                     01  or	al,*1
27338 77FA           8946         1C            mov	$1C[bp],ax
27339                                           !BCC_EOS
27340                                           ! 4702         return;
27341 77FD           89EC                       mov	sp,bp
27342 77FF           5D                         pop	bp
27343 7800           C3                         ret
27344                                           !BCC_EOS
27345                                           ! 4703       }
27346                                           ! 4704       *(((Bit8u *)&AX)+1) = (0);
27347                       00007801            .69F:
27348                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
27349 7801           30C0                       xor	al,al
27350 7803           8846         17            mov	$17[bp],al
27351                                           !BCC_EOS
27352                                           ! 4705       set_diskette_ret_status(0);
27353                                           ! Debug: list int = const 0 (used reg = )
27354 7806           31C0                       xor	ax,ax
27355 7808           50                         push	ax
27356                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27357 7809           E8         0E23            call	_set_diskette_ret_status
27358 780C           44                         inc	sp
27359 780D           44                         inc	sp
27360                                           !BCC_EOS
27361                                           ! 4706       FLAGS &= 0xfffe;
27362                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27363 780E           8B46         1C            mov	ax,$1C[bp]
27364 7811           24                     FE  and	al,#$FE
27365 7813           8946         1C            mov	$1C[bp],ax
27366                                           !BCC_EOS
27367                                           ! 4707       set_diskette_current_cyl(drive, 0);
27368                                           ! Debug: list int = const 0 (used reg = )
27369 7816           31C0                       xor	ax,ax
27370 7818           50                         push	ax
27371                                           ! Debug: list unsigned char drive = [S+$26-3] (used reg = )
27372 7819           8A46         FF            mov	al,-1[bp]
27373 781C           30E4                       xor	ah,ah
27374 781E           50                         push	ax
27375                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
27376 781F           E8         0E25            call	_set_diskette_current_cyl
27377 7822           83C4                   04  add	sp,*4
27378                                           !BCC_EOS
27379                                           ! 4708       return;
27380 7825           89EC                       mov	sp,bp
27381 7827           5D                         pop	bp
27382 7828           C3                         ret
27383                                           !BCC_EOS
27384                                           ! 4709     case 0x01:
27385                                           ! 4710       FLAGS &= 0xfffe;
27386                       00007829            .6A1:
27387                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27388 7829           8B46         1C            mov	ax,$1C[bp]
27389 782C           24                     FE  and	al,#$FE
27390 782E           8946         1C            mov	$1C[bp],ax
27391                                           !BCC_EOS
27392                                           ! 4711       val8 = *((Bit8u *)(0x0041));
27393                                           ! Debug: eq unsigned char = [+$41] to unsigned char val8 = [S+$24-$11] (used reg = )
27394 7831           A0         0041            mov	al,[$41]
27395 7834           8846         F1            mov	-$F[bp],al
27396                                           !BCC_EOS
27397                                           ! 4712       *(((Bit8u *)&AX)+1) = (val8);
27398                                           ! Debug: eq unsigned char val8 = [S+$24-$11] to unsigned char AX = [S+$24+$15] (used reg = )
27399 7837           8A46         F1            mov	al,-$F[bp]
27400 783A           8846         17            mov	$17[bp],al
27401                                           !BCC_EOS
27402                                           ! 4713       if (val8) {
27403 783D           8A46         F1            mov	al,-$F[bp]
27404 7840           84C0                       test	al,al
27405 7842           74           08            je  	.6A2
27406                       00007844            .6A3:
27407                                           ! 4714         FLAGS |= 0x0001;
27408                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27409 7844           8B46         1C            mov	ax,$1C[bp]
27410 7847           0C                     01  or	al,*1
27411 7849           8946         1C            mov	$1C[bp],ax
27412                                           !BCC_EOS
27413                                           ! 4715       }
27414                                           ! 4716       return;
27415                       0000784C            .6A2:
27416 784C           89EC                       mov	sp,bp
27417 784E           5D                         pop	bp
27418 784F           C3                         ret
27419                                           !BCC_EOS
27420                                           ! 4717     case 0x02:
27421                                           ! 4718     case 0x03:
27422                       00007850            .6A4:
27423                                           ! 4719     case 0x04:
27424                       00007850            .6A5:
27425                                           ! 4720       num_sectors = ( AX & 0x00ff );
27426                       00007850            .6A6:
27427                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
27428 7850           8A46         16            mov	al,$16[bp]
27429                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$24-4] (used reg = )
27430 7853           8846         FE            mov	-2[bp],al
27431                                           !BCC_EOS
27432                                           ! 4721       track = *(((Bit8u *)&CX)+1);
27433                                           ! Debug: eq unsigned char CX = [S+$24+$13] to unsigned char track = [S+$24-5] (used reg = )
27434 7856           8A46         15            mov	al,$15[bp]
27435 7859           8846         FD            mov	-3[bp],al
27436                                           !BCC_EOS
27437                                           ! 4722       sector = ( CX & 0x00ff );
27438                                           ! Debug: and int = const $FF to unsigned short CX = [S+$24+$12] (used reg = )
27439 785C           8A46         14            mov	al,$14[bp]
27440                                           ! Debug: eq unsigned char = al+0 to unsigned char sector = [S+$24-6] (used reg = )
27441 785F           8846         FC            mov	-4[bp],al
27442                                           !BCC_EOS
27443                                           ! 4723       head = *(((Bit8u *)&DX)+1);
27444                                           ! Debug: eq unsigned char DX = [S+$24+$11] to unsigned char head = [S+$24-7] (used reg = )
27445 7862           8A46         13            mov	al,$13[bp]
27446 7865           8846         FB            mov	-5[bp],al
27447                                           !BCC_EOS
27448                                           ! 4724       drive = ( ELDX & 0x00ff );
27449                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
27450 7868           8A46         0E            mov	al,$E[bp]
27451                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
27452 786B           8846         FF            mov	-1[bp],al
27453                                           !BCC_EOS
27454                                           ! 4725       if ((drive > 1) || (head > 1) || (sector == 0) ||
27455                                           ! 4726           (num_sectors == 0) || (num_sectors > 72)) {
27456                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
27457 786E           8A46         FF            mov	al,-1[bp]
27458 7871           3C                     01  cmp	al,*1
27459 7873         0F87         001C            bhi 	.6A8
27460                       00007877            .6AC:
27461                                           ! Debug: gt int = const 1 to unsigned char head = [S+$24-7] (used reg = )
27462 7877           8A46         FB            mov	al,-5[bp]
27463 787A           3C                     01  cmp	al,*1
27464 787C           77           15            ja  	.6A8
27465                       0000787E            .6AB:
27466                                           ! Debug: logeq int = const 0 to unsigned char sector = [S+$24-6] (used reg = )
27467 787E           8A46         FC            mov	al,-4[bp]
27468 7881           84C0                       test	al,al
27469 7883           74           0E            je  	.6A8
27470                       00007885            .6AA:
27471                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$24-4] (used reg = )
27472 7885           8A46         FE            mov	al,-2[bp]
27473 7888           84C0                       test	al,al
27474 788A           74           07            je  	.6A8
27475                       0000788C            .6A9:
27476                                           ! Debug: gt int = const $48 to unsigned char num_sectors = [S+$24-4] (used reg = )
27477 788C           8A46         FE            mov	al,-2[bp]
27478 788F           3C                     48  cmp	al,*$48
27479 7891           76           2D            jbe 	.6A7
27480                       00007893            .6A8:
27481                                           ! 4727         bios_printf(4, "int13_diskette: read/write/verify: parameter out of range\n");
27482                                           ! Debug: list * char = .6AD+0 (used reg = )
27483 7893           BB                   CE1E  mov	bx,#.6AD
27484 7896           53                         push	bx
27485                                           ! Debug: list int = const 4 (used reg = )
27486 7897           B8                   0004  mov	ax,*4
27487 789A           50                         push	ax
27488                                           ! Debug: func () void = bios_printf+0 (used reg = )
27489 789B           E8         90A0            call	_bios_printf
27490 789E           83C4                   04  add	sp,*4
27491                                           !BCC_EOS
27492                                           ! 4728         *(((Bit8u *)&AX)+1) = (1);
27493                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
27494 78A1           B0                     01  mov	al,*1
27495 78A3           8846         17            mov	$17[bp],al
27496                                           !BCC_EOS
27497                                           ! 4729         set_diskette_ret_status(1);
27498                                           ! Debug: list int = const 1 (used reg = )
27499 78A6           B8                   0001  mov	ax,*1
27500 78A9           50                         push	ax
27501                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27502 78AA           E8         0D82            call	_set_diskette_ret_status
27503 78AD           44                         inc	sp
27504 78AE           44                         inc	sp
27505                                           !BCC_EOS
27506                                           ! 4730         *((Bit8u *)&AX) = (0);
27507                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
27508 78AF           30C0                       xor	al,al
27509 78B1           8846         16            mov	$16[bp],al
27510                                           !BCC_EOS
27511                                           ! 4731         FLAGS |= 0x0001;
27512                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27513 78B4           8B46         1C            mov	ax,$1C[bp]
27514 78B7           0C                     01  or	al,*1
27515 78B9           8946         1C            mov	$1C[bp],ax
27516                                           !BCC_EOS
27517                                           ! 4732         return;
27518 78BC           89EC                       mov	sp,bp
27519 78BE           5D                         pop	bp
27520 78BF           C3                         ret
27521                                           !BCC_EOS
27522                                           ! 4733       }
27523                                           ! 4734       if (floppy_drive_exists(drive) == 0) {
27524                       000078C0            .6A7:
27525                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
27526 78C0           8A46         FF            mov	al,-1[bp]
27527 78C3           30E4                       xor	ah,ah
27528 78C5           50                         push	ax
27529                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
27530 78C6           E8         FE6D            call	_floppy_drive_exists
27531 78C9           44                         inc	sp
27532 78CA           44                         inc	sp
27533                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
27534 78CB           85C0                       test	ax,ax
27535 78CD           75           1F            jne 	.6AE
27536                       000078CF            .6AF:
27537                                           ! 4735         *(((Bit8u *)&AX)+1) = (0x80);
27538                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
27539 78CF           B0                     80  mov	al,#$80
27540 78D1           8846         17            mov	$17[bp],al
27541                                           !BCC_EOS
27542                                           ! 4736         set_diskette_ret_status(0x80);
27543                                           ! Debug: list int = const $80 (used reg = )
27544 78D4           B8                   0080  mov	ax,#$80
27545 78D7           50                         push	ax
27546                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27547 78D8           E8         0D54            call	_set_diskette_ret_status
27548 78DB           44                         inc	sp
27549 78DC           44                         inc	sp
27550                                           !BCC_EOS
27551                                           ! 4737         *((Bit8u *)&AX) = (0);
27552                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
27553 78DD           30C0                       xor	al,al
27554 78DF           8846         16            mov	$16[bp],al
27555                                           !BCC_EOS
27556                                           ! 4738         FLAGS |= 0x0001;
27557                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27558 78E2           8B46         1C            mov	ax,$1C[bp]
27559 78E5           0C                     01  or	al,*1
27560 78E7           8946         1C            mov	$1C[bp],ax
27561                                           !BCC_EOS
27562                                           ! 4739   
27563                                           ! 4739       return;
27564 78EA           89EC                       mov	sp,bp
27565 78EC           5D                         pop	bp
27566 78ED           C3                         ret
27567                                           !BCC_EOS
27568                                           ! 4740       }
27569                                           ! 4741       if (floppy_media_known(drive) == 0) {
27570                       000078EE            .6AE:
27571                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
27572 78EE           8A46         FF            mov	al,-1[bp]
27573 78F1           30E4                       xor	ah,ah
27574 78F3           50                         push	ax
27575                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
27576 78F4           E8         FC59            call	_floppy_media_known
27577 78F7           44                         inc	sp
27578 78F8           44                         inc	sp
27579                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
27580 78F9           85C0                       test	ax,ax
27581 78FB           75           2E            jne 	.6B0
27582                       000078FD            .6B1:
27583                                           ! 4742         if (floppy_media_sense(drive) == 0) {
27584                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
27585 78FD           8A46         FF            mov	al,-1[bp]
27586 7900           30E4                       xor	ah,ah
27587 7902           50                         push	ax
27588                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
27589 7903           E8         FCBA            call	_floppy_media_sense
27590 7906           44                         inc	sp
27591 7907           44                         inc	sp
27592                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
27593 7908           85C0                       test	ax,ax
27594 790A           75           1F            jne 	.6B2
27595                       0000790C            .6B3:
27596                                           ! 4743           *(((Bit8u *)&AX)+1) = (0x0C);
27597                                           ! Debug: eq int = const $C to unsigned char AX = [S+$24+$15] (used reg = )
27598 790C           B0                     0C  mov	al,*$C
27599 790E           8846         17            mov	$17[bp],al
27600                                           !BCC_EOS
27601                                           ! 4744           set_diskette_ret_status(0x0C);
27602                                           ! Debug: list int = const $C (used reg = )
27603 7911           B8                   000C  mov	ax,*$C
27604 7914           50                         push	ax
27605                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27606 7915           E8         0D17            call	_set_diskette_ret_status
27607 7918           44                         inc	sp
27608 7919           44                         inc	sp
27609                                           !BCC_EOS
27610                                           ! 4745           *((Bit8u *)&AX) = (0);
27611                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
27612 791A           30C0                       xor	al,al
27613 791C           8846         16            mov	$16[bp],al
27614                                           !BCC_EOS
27615                                           ! 4746           FLAGS |= 0x0001;
27616                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27617 791F           8B46         1C            mov	ax,$1C[bp]
27618 7922           0C                     01  or	al,*1
27619 7924           8946         1C            mov	$1C[bp],ax
27620                                           !BCC_EOS
27621                                           ! 4747           return;
27622 7927           89EC                       mov	sp,bp
27623 7929           5D                         pop	bp
27624 792A           C3                         ret
27625                                           !BCC_EOS
27626                                           ! 4748         }
27627                                           ! 4749       }
27628                       0000792B            .6B2:
27629                                           ! 4750       if(ah == 0x04) {
27630                       0000792B            .6B0:
27631                                           ! Debug: logeq int = const 4 to unsigned char ah = [S+$24-$1C] (used reg = )
27632 792B           8A46         E6            mov	al,-$1A[bp]
27633 792E           3C                     04  cmp	al,*4
27634 7930           75           06            jne 	.6B4
27635                       00007932            .6B5:
27636                                           ! 4751         goto floppy_return_success;
27637 7932           83C4                   00  add	sp,#..FFDA-..FFDB
27638 7935           E9         034C            br 	.FFDA
27639                                           !BCC_EOS
27640                                           ! 4752       }
27641                                           ! 4753       page = (ES >> 12);
27642                       00007938            .6B4:
27643                                           ! Debug: sr int = const $C to unsigned short ES = [S+$24+4] (used reg = )
27644 7938           8B46         06            mov	ax,6[bp]
27645 793B           88E0                       mov	al,ah
27646 793D           30E4                       xor	ah,ah
27647 793F           B1                     04  mov	cl,*4
27648 7941           D3E8                       shr	ax,cl
27649                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$24-$F] (used reg = )
27650 7943           8846         F3            mov	-$D[bp],al
27651                                           !BCC_EOS
27652                                           ! 4754       base_es = (ES << 4);
27653                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$24+4] (used reg = )
27654 7946           8B46         06            mov	ax,6[bp]
27655 7949           B1                     04  mov	cl,*4
27656 794B           D3E0                       shl	ax,cl
27657                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$24-$E] (used reg = )
27658 794D           8946         F4            mov	-$C[bp],ax
27659                                           !BCC_EOS
27660                                           ! 4755       base_address = base_es + BX;
27661                                           ! Debug: add unsigned short BX = [S+$24+$E] to unsigned short base_es = [S+$24-$E] (used reg = )
27662 7950           8B46         F4            mov	ax,-$C[bp]
27663 7953           0346         10            add	ax,$10[bp]
27664                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$24-$A] (used reg = )
27665 7956           8946         F8            mov	-8[bp],ax
27666                                           !BCC_EOS
27667                                           ! 4756       if ( base_address < base_es ) {
27668                                           ! Debug: lt unsigned short base_es = [S+$24-$E] to unsigned short base_address = [S+$24-$A] (used reg = )
27669 7959           8B46         F8            mov	ax,-8[bp]
27670 795C           3B46         F4            cmp	ax,-$C[bp]
27671 795F           73           07            jae 	.6B6
27672                       00007961            .6B7:
27673                                           ! 4757         page++;
27674                                           ! Debug: postinc unsigned char page = [S+$24-$F] (used reg = )
27675 7961           8A46         F3            mov	al,-$D[bp]
27676 7964           40                         inc	ax
27677 7965           8846         F3            mov	-$D[bp],al
27678                                           !BCC_EOS
27679                                           ! 4758       }
27680                                           ! 4759       base_count = (num_sectors * 512) - 1;
27681                       00007968            .6B6:
27682                                           ! Debug: mul int = const $200 to unsigned char num_sectors = [S+$24-4] (used reg = )
27683 7968           8A46         FE            mov	al,-2[bp]
27684 796B           30E4                       xor	ah,ah
27685 796D           B9                   0200  mov	cx,#$200
27686 7970           F7E9                       imul	cx
27687                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
27688                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$24-$C] (used reg = )
27689 7972           48                         dec	ax
27690 7973           8946         F6            mov	-$A[bp],ax
27691                                           !BCC_EOS
27692                                           ! 4760       last_addr = base_address + base_count;
27693                                           ! Debug: add unsigned short base_count = [S+$24-$C] to unsigned short base_address = [S+$24-$A] (used reg = )
27694 7976           8B46         F8            mov	ax,-8[bp]
27695 7979           0346         F6            add	ax,-$A[bp]
27696                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$24-$22] (used reg = )
27697 797C           8946         E0            mov	-$20[bp],ax
27698                                           !BCC_EOS
27699                                           ! 4761       if (last_addr < base_address) {
27700                                           ! Debug: lt unsigned short base_address = [S+$24-$A] to unsigned short last_addr = [S+$24-$22] (used reg = )
27701 797F           8B46         E0            mov	ax,-$20[bp]
27702 7982           3B46         F8            cmp	ax,-8[bp]
27703 7985           73           1F            jae 	.6B8
27704                       00007987            .6B9:
27705                                           ! 4762         *(((Bit8u *)&AX)+1) = (0x09);
27706                                           ! Debug: eq int = const 9 to unsigned char AX = [S+$24+$15] (used reg = )
27707 7987           B0                     09  mov	al,*9
27708 7989           8846         17            mov	$17[bp],al
27709                                           !BCC_EOS
27710                                           ! 4763         set_diskette_ret_status(0x09);
27711                                           ! Debug: list int = const 9 (used reg = )
27712 798C           B8                   0009  mov	ax,*9
27713 798F           50                         push	ax
27714                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
27715 7990           E8         0C9C            call	_set_diskette_ret_status
27716 7993           44                         inc	sp
27717 7994           44                         inc	sp
27718                                           !BCC_EOS
27719                                           ! 4764         *((Bit8u *)&AX) = (0);
27720                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
27721 7995           30C0                       xor	al,al
27722 7997           8846         16            mov	$16[bp],al
27723                                           !BCC_EOS
27724                                           ! 4765         FLAGS |= 0x0001;
27725                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
27726 799A           8B46         1C            mov	ax,$1C[bp]
27727 799D           0C                     01  or	al,*1
27728 799F           8946         1C            mov	$1C[bp],ax
27729                                           !BCC_EOS
27730                                           ! 4766         return;
27731 79A2           89EC                       mov	sp,bp
27732 79A4           5D                         pop	bp
27733 79A5           C3                         ret
27734                                           !BCC_EOS
27735                                           ! 4767       }
27736                                           ! 4768       ;
27737                       000079A6            .6B8:
27738                                           !BCC_EOS
27739                                           ! 4769       outb(0x000a, 0x06);
27740                                           ! Debug: list int = const 6 (used reg = )
27741 79A6           B8                   0006  mov	ax,*6
27742 79A9           50                         push	ax
27743                                           ! Debug: list int = const $A (used reg = )
27744 79AA           B8                   000A  mov	ax,*$A
27745 79AD           50                         push	ax
27746                                           ! Debug: func () void = outb+0 (used reg = )
27747 79AE           E8         8B5D            call	_outb
27748 79B1           83C4                   04  add	sp,*4
27749                                           !BCC_EOS
27750                                           ! 4770   ;
27751                                           !BCC_EOS
27752                                           ! 4771       outb(0x000c, 0x00);
27753                                           ! Debug: list int = const 0 (used reg = )
27754 79B4           31C0                       xor	ax,ax
27755 79B6           50                         push	ax
27756                                           ! Debug: list int = const $C (used reg = )
27757 79B7           B8                   000C  mov	ax,*$C
27758 79BA           50                         push	ax
27759                                           ! Debug: func () void = outb+0 (used reg = )
27760 79BB           E8         8B50            call	_outb
27761 79BE           83C4                   04  add	sp,*4
27762                                           !BCC_EOS
27763                                           ! 4772       outb(0x0004, base_address);
27764                                           ! Debug: list unsigned short base_address = [S+$24-$A] (used reg = )
27765 79C1           FF76         F8            push	-8[bp]
27766                                           ! Debug: list int = const 4 (used reg = )
27767 79C4           B8                   0004  mov	ax,*4
27768 79C7           50                         push	ax
27769                                           ! Debug: func () void = outb+0 (used reg = )
27770 79C8           E8         8B43            call	_outb
27771 79CB           83C4                   04  add	sp,*4
27772                                           !BCC_EOS
27773                                           ! 4773       outb(0x0004, *(((Bit8u *)&base_address)+1));
27774                                           ! Debug: list unsigned char base_address = [S+$24-9] (used reg = )
27775 79CE           8A46         F9            mov	al,-7[bp]
27776 79D1           30E4                       xor	ah,ah
27777 79D3           50                         push	ax
27778                                           ! Debug: list int = const 4 (used reg = )
27779 79D4           B8                   0004  mov	ax,*4
27780 79D7           50                         push	ax
27781                                           ! Debug: func () void = outb+0 (used reg = )
27782 79D8           E8         8B33            call	_outb
27783 79DB           83C4                   04  add	sp,*4
27784                                           !BCC_EOS
27785                                           ! 4774   ;
27786                                           !BCC_EOS
27787                                           ! 4775       outb(0x000c, 0x00);
27788                                           ! Debug: list int = const 0 (used reg = )
27789 79DE           31C0                       xor	ax,ax
27790 79E0           50                         push	ax
27791                                           ! Debug: list int = const $C (used reg = )
27792 79E1           B8                   000C  mov	ax,*$C
27793 79E4           50                         push	ax
27794                                           ! Debug: func () void = outb+0 (used reg = )
27795 79E5           E8         8B26            call	_outb
27796 79E8           83C4                   04  add	sp,*4
27797                                           !BCC_EOS
27798                                           ! 4776       outb(0x0005, base_count);
27799                                           ! Debug: list unsigned short base_count = [S+$24-$C] (used reg = )
27800 79EB           FF76         F6            push	-$A[bp]
27801                                           ! Debug: list int = const 5 (used reg = )
27802 79EE           B8                   0005  mov	ax,*5
27803 79F1           50                         push	ax
27804                                           ! Debug: func () void = outb+0 (used reg = )
27805 79F2           E8         8B19            call	_outb
27806 79F5           83C4                   04  add	sp,*4
27807                                           !BCC_EOS
27808                                           ! 4777       outb(0x0005, *(((Bit8u *)&base_count)+1));
27809                                           ! Debug: list unsigned char base_count = [S+$24-$B] (used reg = )
27810 79F8           8A46         F7            mov	al,-9[bp]
27811 79FB           30E4                       xor	ah,ah
27812 79FD           50                         push	ax
27813                                           ! Debug: list int = const 5 (used reg = )
27814 79FE           B8                   0005  mov	ax,*5
27815 7A01           50                         push	ax
27816                                           ! Debug: func () void = outb+0 (used reg = )
27817 7A02           E8         8B09            call	_outb
27818 7A05           83C4                   04  add	sp,*4
27819                                           !BCC_EOS
27820                                           ! 4778       if (ah == 0x02) {
27821                                           ! Debug: logeq int = const 2 to unsigned char ah = [S+$24-$1C] (used reg = )
27822 7A08           8A46         E6            mov	al,-$1A[bp]
27823 7A0B           3C                     02  cmp	al,*2
27824 7A0D           75           5C            jne 	.6BA
27825                       00007A0F            .6BB:
27826                                           ! 4779         mode_register = 0x46;
27827                                           ! Debug: eq int = const $46 to unsigned char mode_register = [S+$24-$10] (used reg = )
27828 7A0F           B0                     46  mov	al,*$46
27829 7A11           8846         F2            mov	-$E[bp],al
27830                                           !BCC_EOS
27831                                           ! 4780   ;
27832                                           !BCC_EOS
27833                                           ! 4781         outb(0x000b, mode_register);
27834                                           ! Debug: list unsigned char mode_register = [S+$24-$10] (used reg = )
27835 7A14           8A46         F2            mov	al,-$E[bp]
27836 7A17           30E4                       xor	ah,ah
27837 7A19           50                         push	ax
27838                                           ! Debug: list int = const $B (used reg = )
27839 7A1A           B8                   000B  mov	ax,*$B
27840 7A1D           50                         push	ax
27841                                           ! Debug: func () void = outb+0 (used reg = )
27842 7A1E           E8         8AED            call	_outb
27843 7A21           83C4                   04  add	sp,*4
27844                                           !BCC_EOS
27845                                           ! 4782   ;
27846                                           !BCC_EOS
27847                                           ! 4783         outb(0x0081, page);
27848                                           ! Debug: list unsigned char page = [S+$24-$F] (used reg = )
27849 7A24           8A46         F3            mov	al,-$D[bp]
27850 7A27           30E4                       xor	ah,ah
27851 7A29           50                         push	ax
27852                                           ! Debug: list int = const $81 (used reg = )
27853 7A2A           B8                   0081  mov	ax,#$81
27854 7A2D           50                         push	ax
27855                                           ! Debug: func () void = outb+0 (used reg = )
27856 7A2E           E8         8ADD            call	_outb
27857 7A31           83C4                   04  add	sp,*4
27858                                           !BCC_EOS
27859                                           ! 4784   ;
27860                                           !BCC_EOS
27861                                           ! 4785         outb(0x000a, 0x02);
27862                                           ! Debug: list int = const 2 (used reg = )
27863 7A34           B8                   0002  mov	ax,*2
27864 7A37           50                         push	ax
27865                                           ! Debug: list int = const $A (used reg = )
27866 7A38           B8                   000A  mov	ax,*$A
27867 7A3B           50                         push	ax
27868                                           ! Debug: func () void = outb+0 (used reg = )
27869 7A3C           E8         8ACF            call	_outb
27870 7A3F           83C4                   04  add	sp,*4
27871                                           !BCC_EOS
27872                                           ! 4786         ;
27873                                           !BCC_EOS
27874                                           ! 4787         outb(0x000a, 0x02);
27875                                           ! Debug: list int = const 2 (used reg = )
27876 7A42           B8                   0002  mov	ax,*2
27877 7A45           50                         push	ax
27878                                           ! Debug: list int = const $A (used reg = )
27879 7A46           B8                   000A  mov	ax,*$A
27880 7A49           50                         push	ax
27881                                           ! Debug: func () void = outb+0 (used reg = )
27882 7A4A           E8         8AC1            call	_outb
27883 7A4D           83C4                   04  add	sp,*4
27884                                           !BCC_EOS
27885                                           ! 4788         floppy_prepare_controller(drive);
27886                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
27887 7A50           8A46         FF            mov	al,-1[bp]
27888 7A53           30E4                       xor	ah,ah
27889 7A55           50                         push	ax
27890                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
27891 7A56           E8         FA57            call	_floppy_prepare_controller
27892 7A59           44                         inc	sp
27893 7A5A           44                         inc	sp
27894                                           !BCC_EOS
27895                                           ! 4789         outb(0x03f5, 0xe6);
27896                                           ! Debug: list int = const $E6 (used reg = )
27897 7A5B           B8                   00E6  mov	ax,#$E6
27898 7A5E           50                         push	ax
27899                                           ! Debug: list int = const $3F5 (used reg = )
27900 7A5F           B8                   03F5  mov	ax,#$3F5
27901 7A62           50                         push	ax
27902                                           ! Debug: func () void = outb+0 (used reg = )
27903 7A63           E8         8AA8            call	_outb
27904 7A66           83C4                   04  add	sp,*4
27905                                           !BCC_EOS
27906                                           ! 4790       } else {
27907 7A69           EB           4C            jmp .6BC
27908                       00007A6B            .6BA:
27909                                           ! 4791         mode_register = 0x4a;
27910                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$24-$10] (used reg = )
27911 7A6B           B0                     4A  mov	al,*$4A
27912 7A6D           8846         F2            mov	-$E[bp],al
27913                                           !BCC_EOS
27914                                           ! 4792         outb(0x000b, mode_register);
27915                                           ! Debug: list unsigned char mode_register = [S+$24-$10] (used reg = )
27916 7A70           8A46         F2            mov	al,-$E[bp]
27917 7A73           30E4                       xor	ah,ah
27918 7A75           50                         push	ax
27919                                           ! Debug: list int = const $B (used reg = )
27920 7A76           B8                   000B  mov	ax,*$B
27921 7A79           50                         push	ax
27922                                           ! Debug: func () void = outb+0 (used reg = )
27923 7A7A           E8         8A91            call	_outb
27924 7A7D           83C4                   04  add	sp,*4
27925                                           !BCC_EOS
27926                                           ! 4793         outb(0x0081, page);
27927                                           ! Debug: list unsigned char page = [S+$24-$F] (used reg = )
27928 7A80           8A46         F3            mov	al,-$D[bp]
27929 7A83           30E4                       xor	ah,ah
27930 7A85           50                         push	ax
27931                                           ! Debug: list int = const $81 (used reg = )
27932 7A86           B8                   0081  mov	ax,#$81
27933 7A89           50                         push	ax
27934                                           ! Debug: func () void = outb+0 (used reg = )
27935 7A8A           E8         8A81            call	_outb
27936 7A8D           83C4                   04  add	sp,*4
27937                                           !BCC_EOS
27938                                           ! 4794         ;
27939                                           !BCC_EOS
27940                                           ! 4795         outb(0x000a, 0x02);
27941                                           ! Debug: list int = const 2 (used reg = )
27942 7A90           B8                   0002  mov	ax,*2
27943 7A93           50                         push	ax
27944                                           ! Debug: list int = const $A (used reg = )
27945 7A94           B8                   000A  mov	ax,*$A
27946 7A97           50                         push	ax
27947                                           ! Debug: func () void = outb+0 (used reg = )
27948 7A98           E8         8A73            call	_outb
27949 7A9B           83C4                   04  add	sp,*4
27950                                           !BCC_EOS
27951                                           ! 4796         floppy_prepare_controller(drive);
27952                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
27953 7A9E           8A46         FF            mov	al,-1[bp]
27954 7AA1           30E4                       xor	ah,ah
27955 7AA3           50                         push	ax
27956                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
27957 7AA4           E8         FA09            call	_floppy_prepare_controller
27958 7AA7           44                         inc	sp
27959 7AA8           44                         inc	sp
27960                                           !BCC_EOS
27961                                           ! 4797         outb(0x03f5, 0xc5);
27962                                           ! Debug: list int = const $C5 (used reg = )
27963 7AA9           B8                   00C5  mov	ax,#$C5
27964 7AAC           50                         push	ax
27965                                           ! Debug: list int = const $3F5 (used reg = )
27966 7AAD           B8                   03F5  mov	ax,#$3F5
27967 7AB0           50                         push	ax
27968                                           ! Debug: func () void = outb+0 (used reg = )
27969 7AB1           E8         8A5A            call	_outb
27970 7AB4           83C4                   04  add	sp,*4
27971                                           !BCC_EOS
27972                                           ! 4798       }
27973                                           ! 4799       outb(0x03f5, (head << 2) | drive);
27974                       00007AB7            .6BC:
27975                                           ! Debug: sl int = const 2 to unsigned char head = [S+$24-7] (used reg = )
27976 7AB7           8A46         FB            mov	al,-5[bp]
27977 7ABA           30E4                       xor	ah,ah
27978 7ABC           D1E0                       shl	ax,*1
27979 7ABE           D1E0                       shl	ax,*1
27980                                           ! Debug: or unsigned char drive = [S+$24-3] to unsigned int = ax+0 (used reg = )
27981 7AC0           0A46         FF            or	al,-1[bp]
27982                                           ! Debug: list unsigned int = ax+0 (used reg = )
27983 7AC3           50                         push	ax
27984                                           ! Debug: list int = const $3F5 (used reg = )
27985 7AC4           B8                   03F5  mov	ax,#$3F5
27986 7AC7           50                         push	ax
27987                                           ! Debug: func () void = outb+0 (used reg = )
27988 7AC8           E8         8A43            call	_outb
27989 7ACB           83C4                   04  add	sp,*4
27990                                           !BCC_EOS
27991                                           ! 4800       outb(0x03f5, track);
27992                                           ! Debug: list unsigned char track = [S+$24-5] (used reg = )
27993 7ACE           8A46         FD            mov	al,-3[bp]
27994 7AD1           30E4                       xor	ah,ah
27995 7AD3           50                         push	ax
27996                                           ! Debug: list int = const $3F5 (used reg = )
27997 7AD4           B8                   03F5  mov	ax,#$3F5
27998 7AD7           50                         push	ax
27999                                           ! Debug: func () void = outb+0 (used reg = )
28000 7AD8           E8         8A33            call	_outb
28001 7ADB           83C4                   04  add	sp,*4
28002                                           !BCC_EOS
28003                                           ! 4801       outb(0x03f5, head);
28004                                           ! Debug: list unsigned char head = [S+$24-7] (used reg = )
28005 7ADE           8A46         FB            mov	al,-5[bp]
28006 7AE1           30E4                       xor	ah,ah
28007 7AE3           50                         push	ax
28008                                           ! Debug: list int = const $3F5 (used reg = )
28009 7AE4           B8                   03F5  mov	ax,#$3F5
28010 7AE7           50                         push	ax
28011                                           ! Debug: func () void = outb+0 (used reg = )
28012 7AE8           E8         8A23            call	_outb
28013 7AEB           83C4                   04  add	sp,*4
28014                                           !BCC_EOS
28015                                           ! 4802       outb(0x03f5, sector);
28016                                           ! Debug: list unsigned char sector = [S+$24-6] (used reg = )
28017 7AEE           8A46         FC            mov	al,-4[bp]
28018 7AF1           30E4                       xor	ah,ah
28019 7AF3           50                         push	ax
28020                                           ! Debug: list int = const $3F5 (used reg = )
28021 7AF4           B8                   03F5  mov	ax,#$3F5
28022 7AF7           50                         push	ax
28023                                           ! Debug: func () void = outb+0 (used reg = )
28024 7AF8           E8         8A13            call	_outb
28025 7AFB           83C4                   04  add	sp,*4
28026                                           !BCC_EOS
28027                                           ! 4803       outb(0x03f5, 2);
28028                                           ! Debug: list int = const 2 (used reg = )
28029 7AFE           B8                   0002  mov	ax,*2
28030 7B01           50                         push	ax
28031                                           ! Debug: list int = const $3F5 (used reg = )
28032 7B02           B8                   03F5  mov	ax,#$3F5
28033 7B05           50                         push	ax
28034                                           ! Debug: func () void = outb+0 (used reg = )
28035 7B06           E8         8A05            call	_outb
28036 7B09           83C4                   04  add	sp,*4
28037                                           !BCC_EOS
28038                                           ! 4804       outb(0x03f5, sector + num_sectors - 1);
28039                                           ! Debug: add unsigned char num_sectors = [S+$24-4] to unsigned char sector = [S+$24-6] (used reg = )
28040 7B0C           8A46         FC            mov	al,-4[bp]
28041 7B0F           30E4                       xor	ah,ah
28042 7B11           0246         FE            add	al,-2[bp]
28043 7B14           80D4                   00  adc	ah,*0
28044                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
28045                                           ! Debug: list unsigned int = ax-1 (used reg = )
28046 7B17           48                         dec	ax
28047 7B18           50                         push	ax
28048                                           ! Debug: list int = const $3F5 (used reg = )
28049 7B19           B8                   03F5  mov	ax,#$3F5
28050 7B1C           50                         push	ax
28051                                           ! Debug: func () void = outb+0 (used reg = )
28052 7B1D           E8         89EE            call	_outb
28053 7B20           83C4                   04  add	sp,*4
28054                                           !BCC_EOS
28055                                           ! 4805       outb(0x03f5, 0);
28056                                           ! Debug: list int = const 0 (used reg = )
28057 7B23           31C0                       xor	ax,ax
28058 7B25           50                         push	ax
28059                                           ! Debug: list int = const $3F5 (used reg = )
28060 7B26           B8                   03F5  mov	ax,#$3F5
28061 7B29           50                         push	ax
28062                                           ! Debug: func () void = outb+0 (used reg = )
28063 7B2A           E8         89E1            call	_outb
28064 7B2D           83C4                   04  add	sp,*4
28065                                           !BCC_EOS
28066                                           ! 4806       outb(0x03f5, 0xff);
28067                                           ! Debug: list int = const $FF (used reg = )
28068 7B30           B8                   00FF  mov	ax,#$FF
28069 7B33           50                         push	ax
28070                                           ! Debug: list int = const $3F5 (used reg = )
28071 7B34           B8                   03F5  mov	ax,#$3F5
28072 7B37           50                         push	ax
28073                                           ! Debug: func () void = outb+0 (used reg = )
28074 7B38           E8         89D3            call	_outb
28075 7B3B           83C4                   04  add	sp,*4
28076                                           !BCC_EOS
28077                                           ! 4807 #asm
28078                                           !BCC_EOS
28079                                           !BCC_ASM
28080                       0000002E            _int13_diskette_function.BP	set	$2E
28081                       0000000C            .int13_diskette_function.BP	set	$C
28082                       0000003C            _int13_diskette_function.CS	set	$3C
28083                       0000001A            .int13_diskette_function.CS	set	$1A
28084                       00000036            _int13_diskette_function.CX	set	$36
28085                       00000014            .int13_diskette_function.CX	set	$14
28086                       0000001A            _int13_diskette_function.base_address	set	$1A
28087                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
28088                       0000002A            _int13_diskette_function.DI	set	$2A
28089                       00000008            .int13_diskette_function.DI	set	8
28090                       0000003E            _int13_diskette_function.FLAGS	set	$3E
28091                       0000001C            .int13_diskette_function.FLAGS	set	$1C
28092                       00000018            _int13_diskette_function.base_count	set	$18
28093                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
28094                       0000001E            _int13_diskette_function.sector	set	$1E
28095                       FFFFFFFC            .int13_diskette_function.sector	set	-4
28096                       00000026            _int13_diskette_function.DS	set	$26
28097                       00000004            .int13_diskette_function.DS	set	4
28098                       0000001D            _int13_diskette_function.head	set	$1D
28099                       FFFFFFFB            .int13_diskette_function.head	set	-5
28100                       00000030            _int13_diskette_function.ELDX	set	$30
28101                       0000000E            .int13_diskette_function.ELDX	set	$E
28102                       00000012            _int13_diskette_function.dor	set	$12
28103                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
28104                       00000034            _int13_diskette_function.DX	set	$34
28105                       00000012            .int13_diskette_function.DX	set	$12
28106                       0000000B            _int13_diskette_function.return_status	set	$B
28107                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
28108                       00000004            _int13_diskette_function.es	set	4
28109                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
28110                       00000014            _int13_diskette_function.mode_register	set	$14
28111                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
28112                       00000028            _int13_diskette_function.ES	set	$28
28113                       00000006            .int13_diskette_function.ES	set	6
28114                       00000016            _int13_diskette_function.base_es	set	$16
28115                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
28116                       0000001F            _int13_diskette_function.track	set	$1F
28117                       FFFFFFFD            .int13_diskette_function.track	set	-3
28118                       0000002C            _int13_diskette_function.SI	set	$2C
28119                       0000000A            .int13_diskette_function.SI	set	$A
28120                       0000000A            _int13_diskette_function.drive_type	set	$A
28121                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
28122                       00000020            _int13_diskette_function.num_sectors	set	$20
28123                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
28124                       0000003A            _int13_diskette_function.IP	set	$3A
28125                       00000018            .int13_diskette_function.IP	set	$18
28126                       00000007            _int13_diskette_function.spt	set	7
28127                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
28128                       0000001C            _int13_diskette_function.status	set	$1C
28129                       FFFFFFFA            .int13_diskette_function.status	set	-6
28130                       00000000            _int13_diskette_function.maxCyl	set	0
28131                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
28132                       00000038            _int13_diskette_function.AX	set	$38
28133                       00000016            .int13_diskette_function.AX	set	$16
28134                       00000013            _int13_diskette_function.val8	set	$13
28135                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
28136                       00000002            _int13_diskette_function.last_addr	set	2
28137                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
28138                       00000015            _int13_diskette_function.page	set	$15
28139                       FFFFFFF3            .int13_diskette_function.page	set	-$D
28140                       00000008            _int13_diskette_function.ah	set	8
28141                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
28142                       00000021            _int13_diskette_function.drive	set	$21
28143                       FFFFFFFF            .int13_diskette_function.drive	set	-1
28144                       00000009            _int13_diskette_function.num_floppies	set	9
28145                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
28146                       00000032            _int13_diskette_function.BX	set	$32
28147                       00000010            .int13_diskette_function.BX	set	$10
28148 7B3E           FB                               sti
28149                                           ! 4809 endasm
28150                                           !BCC_ENDASM
28151                                           !BCC_EOS
28152                                           ! 4810       do {
28153                       00007B3F            .6BF:
28154                                           ! 4811         val8 = *((Bit8u *)(0x0040));
28155                                           ! Debug: eq unsigned char = [+$40] to unsigned char val8 = [S+$24-$11] (used reg = )
28156 7B3F           A0         0040            mov	al,[$40]
28157 7B42           8846         F1            mov	-$F[bp],al
28158                                           !BCC_EOS
28159                                           ! 4812         if (val8 == 0) {
28160                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
28161 7B45           8A46         F1            mov	al,-$F[bp]
28162 7B48           84C0                       test	al,al
28163 7B4A           75           22            jne 	.6C0
28164                       00007B4C            .6C1:
28165                                           ! 4813           floppy_reset_controller();
28166                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
28167 7B4C           E8         F913            call	_floppy_reset_controller
28168                                           !BCC_EOS
28169                                           ! 4814           *(((Bit8u *)&AX)+1) = (0x80);
28170                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
28171 7B4F           B0                     80  mov	al,#$80
28172 7B51           8846         17            mov	$17[bp],al
28173                                           !BCC_EOS
28174                                           ! 4815           set_diskette_ret_status(0x80);
28175                                           ! Debug: list int = const $80 (used reg = )
28176 7B54           B8                   0080  mov	ax,#$80
28177 7B57           50                         push	ax
28178                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28179 7B58           E8         0AD4            call	_set_diskette_ret_status
28180 7B5B           44                         inc	sp
28181 7B5C           44                         inc	sp
28182                                           !BCC_EOS
28183                                           ! 4816           *((Bit8u *)&AX) = (0);
28184                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
28185 7B5D           30C0                       xor	al,al
28186 7B5F           8846         16            mov	$16[bp],al
28187                                           !BCC_EOS
28188                                           ! 4817           FLAGS |= 
28189                                           ! 4817 0x0001;
28190                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28191 7B62           8B46         1C            mov	ax,$1C[bp]
28192 7B65           0C                     01  or	al,*1
28193 7B67           8946         1C            mov	$1C[bp],ax
28194                                           !BCC_EOS
28195                                           ! 4818           return;
28196 7B6A           89EC                       mov	sp,bp
28197 7B6C           5D                         pop	bp
28198 7B6D           C3                         ret
28199                                           !BCC_EOS
28200                                           ! 4819         }
28201                                           ! 4820         val8 = (*((Bit8u *)(0x003e)) & 0x80);
28202                       00007B6E            .6C0:
28203                                           ! Debug: and int = const $80 to unsigned char = [+$3E] (used reg = )
28204 7B6E           A0         003E            mov	al,[$3E]
28205 7B71           24                     80  and	al,#$80
28206                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
28207 7B73           8846         F1            mov	-$F[bp],al
28208                                           !BCC_EOS
28209                                           ! 4821       } while ( val8 == 0 );
28210                       00007B76            .6BE:
28211                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
28212 7B76           8A46         F1            mov	al,-$F[bp]
28213 7B79           84C0                       test	al,al
28214 7B7B           74           C2            je 	.6BF
28215                       00007B7D            .6C2:
28216                                           !BCC_EOS
28217                                           ! 4822       val8 = 0;
28218                       00007B7D            .6BD:
28219                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
28220 7B7D           30C0                       xor	al,al
28221 7B7F           8846         F1            mov	-$F[bp],al
28222                                           !BCC_EOS
28223                                           ! 4823 #asm
28224                                           !BCC_EOS
28225                                           !BCC_ASM
28226                       0000002E            _int13_diskette_function.BP	set	$2E
28227                       0000000C            .int13_diskette_function.BP	set	$C
28228                       0000003C            _int13_diskette_function.CS	set	$3C
28229                       0000001A            .int13_diskette_function.CS	set	$1A
28230                       00000036            _int13_diskette_function.CX	set	$36
28231                       00000014            .int13_diskette_function.CX	set	$14
28232                       0000001A            _int13_diskette_function.base_address	set	$1A
28233                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
28234                       0000002A            _int13_diskette_function.DI	set	$2A
28235                       00000008            .int13_diskette_function.DI	set	8
28236                       0000003E            _int13_diskette_function.FLAGS	set	$3E
28237                       0000001C            .int13_diskette_function.FLAGS	set	$1C
28238                       00000018            _int13_diskette_function.base_count	set	$18
28239                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
28240                       0000001E            _int13_diskette_function.sector	set	$1E
28241                       FFFFFFFC            .int13_diskette_function.sector	set	-4
28242                       00000026            _int13_diskette_function.DS	set	$26
28243                       00000004            .int13_diskette_function.DS	set	4
28244                       0000001D            _int13_diskette_function.head	set	$1D
28245                       FFFFFFFB            .int13_diskette_function.head	set	-5
28246                       00000030            _int13_diskette_function.ELDX	set	$30
28247                       0000000E            .int13_diskette_function.ELDX	set	$E
28248                       00000012            _int13_diskette_function.dor	set	$12
28249                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
28250                       00000034            _int13_diskette_function.DX	set	$34
28251                       00000012            .int13_diskette_function.DX	set	$12
28252                       0000000B            _int13_diskette_function.return_status	set	$B
28253                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
28254                       00000004            _int13_diskette_function.es	set	4
28255                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
28256                       00000014            _int13_diskette_function.mode_register	set	$14
28257                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
28258                       00000028            _int13_diskette_function.ES	set	$28
28259                       00000006            .int13_diskette_function.ES	set	6
28260                       00000016            _int13_diskette_function.base_es	set	$16
28261                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
28262                       0000001F            _int13_diskette_function.track	set	$1F
28263                       FFFFFFFD            .int13_diskette_function.track	set	-3
28264                       0000002C            _int13_diskette_function.SI	set	$2C
28265                       0000000A            .int13_diskette_function.SI	set	$A
28266                       0000000A            _int13_diskette_function.drive_type	set	$A
28267                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
28268                       00000020            _int13_diskette_function.num_sectors	set	$20
28269                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
28270                       0000003A            _int13_diskette_function.IP	set	$3A
28271                       00000018            .int13_diskette_function.IP	set	$18
28272                       00000007            _int13_diskette_function.spt	set	7
28273                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
28274                       0000001C            _int13_diskette_function.status	set	$1C
28275                       FFFFFFFA            .int13_diskette_function.status	set	-6
28276                       00000000            _int13_diskette_function.maxCyl	set	0
28277                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
28278                       00000038            _int13_diskette_function.AX	set	$38
28279                       00000016            .int13_diskette_function.AX	set	$16
28280                       00000013            _int13_diskette_function.val8	set	$13
28281                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
28282                       00000002            _int13_diskette_function.last_addr	set	2
28283                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
28284                       00000015            _int13_diskette_function.page	set	$15
28285                       FFFFFFF3            .int13_diskette_function.page	set	-$D
28286                       00000008            _int13_diskette_function.ah	set	8
28287                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
28288                       00000021            _int13_diskette_function.drive	set	$21
28289                       FFFFFFFF            .int13_diskette_function.drive	set	-1
28290                       00000009            _int13_diskette_function.num_floppies	set	9
28291                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
28292                       00000032            _int13_diskette_function.BX	set	$32
28293                       00000010            .int13_diskette_function.BX	set	$10
28294 7B82           FA                               cli
28295                                           ! 4825 endasm
28296                                           !BCC_ENDASM
28297                                           !BCC_EOS
28298                                           ! 4826       val8 = *((Bit8u *)(0x003e));
28299                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+$24-$11] (used reg = )
28300 7B83           A0         003E            mov	al,[$3E]
28301 7B86           8846         F1            mov	-$F[bp],al
28302                                           !BCC_EOS
28303                                           ! 4827       val8 &= 0x7f;
28304                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$24-$11] (used reg = )
28305 7B89           8A46         F1            mov	al,-$F[bp]
28306 7B8C           24                     7F  and	al,*$7F
28307 7B8E           8846         F1            mov	-$F[bp],al
28308                                           !BCC_EOS
28309                                           ! 4828       *((Bit8u *)(0x003e)) = (val8);
28310                                           ! Debug: eq unsigned char val8 = [S+$24-$11] to unsigned char = [+$3E] (used reg = )
28311 7B91           8A46         F1            mov	al,-$F[bp]
28312 7B94           A2         003E            mov	[$3E],al
28313                                           !BCC_EOS
28314                                           ! 4829       val8 = inb(0x03f4);
28315                                           ! Debug: list int = const $3F4 (used reg = )
28316 7B97           B8                   03F4  mov	ax,#$3F4
28317 7B9A           50                         push	ax
28318                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28319 7B9B           E8         895A            call	_inb
28320 7B9E           44                         inc	sp
28321 7B9F           44                         inc	sp
28322                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
28323 7BA0           8846         F1            mov	-$F[bp],al
28324                                           !BCC_EOS
28325                                           ! 4830       if ( (val8 & 0xc0) != 0xc0 )
28326                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$24-$11] (used reg = )
28327 7BA3           8A46         F1            mov	al,-$F[bp]
28328 7BA6           24                     C0  and	al,#$C0
28329                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
28330 7BA8           3C                     C0  cmp	al,#$C0
28331 7BAA           74           0E            je  	.6C3
28332                       00007BAC            .6C4:
28333                                           ! 4831         bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
28334                                           ! Debug: list * char = .6C5+0 (used reg = )
28335 7BAC           BB                   CDFE  mov	bx,#.6C5
28336 7BAF           53                         push	bx
28337                                           ! Debug: list int = const 7 (used reg = )
28338 7BB0           B8                   0007  mov	ax,*7
28339 7BB3           50                         push	ax
28340                                           ! Debug: func () void = bios_printf+0 (used reg = )
28341 7BB4           E8         8D87            call	_bios_printf
28342 7BB7           83C4                   04  add	sp,*4
28343                                           !BCC_EOS
28344                                           ! 4832       return_status[0] = inb(0x03f5);
28345                       00007BBA            .6C3:
28346                                           ! Debug: list int = const $3F5 (used reg = )
28347 7BBA           B8                   03F5  mov	ax,#$3F5
28348 7BBD           50                         push	ax
28349                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28350 7BBE           E8         8937            call	_inb
28351 7BC1           44                         inc	sp
28352 7BC2           44                         inc	sp
28353                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$19] (used reg = )
28354 7BC3           8846         E9            mov	-$17[bp],al
28355                                           !BCC_EOS
28356                                           ! 4833       return_status[1] = inb(0x03f5);
28357                                           ! Debug: list int = const $3F5 (used reg = )
28358 7BC6           B8                   03F5  mov	ax,#$3F5
28359 7BC9           50                         push	ax
28360                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28361 7BCA           E8         892B            call	_inb
28362 7BCD           44                         inc	sp
28363 7BCE           44                         inc	sp
28364                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$18] (used reg = )
28365 7BCF           8846         EA            mov	-$16[bp],al
28366                                           !BCC_EOS
28367                                           ! 4834       return_status[2] = inb(0x03f5);
28368                                           ! Debug: list int = const $3F5 (used reg = )
28369 7BD2           B8                   03F5  mov	ax,#$3F5
28370 7BD5           50                         push	ax
28371                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28372 7BD6           E8         891F            call	_inb
28373 7BD9           44                         inc	sp
28374 7BDA           44                         inc	sp
28375                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$17] (used reg = )
28376 7BDB           8846         EB            mov	-$15[bp],al
28377                                           !BCC_EOS
28378                                           ! 4835       return_status[3] = inb(0x03f5);
28379                                           ! Debug: list int = const $3F5 (used reg = )
28380 7BDE           B8                   03F5  mov	ax,#$3F5
28381 7BE1           50                         push	ax
28382                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28383 7BE2           E8         8913            call	_inb
28384 7BE5           44                         inc	sp
28385 7BE6           44                         inc	sp
28386                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$16] (used reg = )
28387 7BE7           8846         EC            mov	-$14[bp],al
28388                                           !BCC_EOS
28389                                           ! 4836       return_status[4] = inb(0x03f5);
28390                                           ! Debug: list int = const $3F5 (used reg = )
28391 7BEA           B8                   03F5  mov	ax,#$3F5
28392 7BED           50                         push	ax
28393                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28394 7BEE           E8         8907            call	_inb
28395 7BF1           44                         inc	sp
28396 7BF2           44                         inc	sp
28397                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$15] (used reg = )
28398 7BF3           8846         ED            mov	-$13[bp],al
28399                                           !BCC_EOS
28400                                           ! 4837       return_status[5] = inb(0x03f5);
28401                                           ! Debug: list int = const $3F5 (used reg = )
28402 7BF6           B8                   03F5  mov	ax,#$3F5
28403 7BF9           50                         push	ax
28404                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28405 7BFA           E8         88FB            call	_inb
28406 7BFD           44                         inc	sp
28407 7BFE           44                         inc	sp
28408                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$14] (used reg = )
28409 7BFF           8846         EE            mov	-$12[bp],al
28410                                           !BCC_EOS
28411                                           ! 4838       return_status[6] = inb(0x03f5);
28412                                           ! Debug: list int = const $3F5 (used reg = )
28413 7C02           B8                   03F5  mov	ax,#$3F5
28414 7C05           50                         push	ax
28415                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28416 7C06           E8         88EF            call	_inb
28417 7C09           44                         inc	sp
28418 7C0A           44                         inc	sp
28419                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$13] (used reg = )
28420 7C0B           8846         EF            mov	-$11[bp],al
28421                                           !BCC_EOS
28422                                           ! 4839       _memcpyb(0x0042,0x0040,return_status,get_SS(),7);
28423                                           ! Debug: list int = const 7 (used reg = )
28424 7C0E           B8                   0007  mov	ax,*7
28425 7C11           50                         push	ax
28426                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
28427 7C12           E8         8A4A            call	_get_SS
28428                                           ! Debug: list unsigned short = ax+0 (used reg = )
28429 7C15           50                         push	ax
28430                                           ! Debug: list * unsigned char return_status = S+$28-$19 (used reg = )
28431 7C16           8D5E         E9            lea	bx,-$17[bp]
28432 7C19           53                         push	bx
28433                                           ! Debug: list int = const $40 (used reg = )
28434 7C1A           B8                   0040  mov	ax,*$40
28435 7C1D           50                         push	ax
28436                                           ! Debug: list int = const $42 (used reg = )
28437 7C1E           B8                   0042  mov	ax,*$42
28438 7C21           50                         push	ax
28439                                           ! Debug: func () void = _memcpyb+0 (used reg = )
28440 7C22           E8         83F6            call	__memcpyb
28441 7C25           83C4                   0A  add	sp,*$A
28442                                           !BCC_EOS
28443                                           ! 4840       if ( (return_status[0] & 0xc0) != 0 ) {
28444                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$24-$19] (used reg = )
28445 7C28           8A46         E9            mov	al,-$17[bp]
28446 7C2B           24                     C0  and	al,#$C0
28447                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
28448 7C2D           84C0                       test	al,al
28449 7C2F           74           53            je  	.6C6
28450                       00007C31            .6C7:
28451                                           ! 4841         if (ah == 0x02) {
28452                                           ! Debug: logeq int = const 2 to unsigned char ah = [S+$24-$1C] (used reg = )
28453 7C31           8A46         E6            mov	al,-$1A[bp]
28454 7C34           3C                     02  cmp	al,*2
28455 7C36           75           21            jne 	.6C8
28456                       00007C38            .6C9:
28457                                           ! 4842           *(((Bit8u *)&AX)+1) = (0x20);
28458                                           ! Debug: eq int = const $20 to unsigned char AX = [S+$24+$15] (used reg = )
28459 7C38           B0                     20  mov	al,*$20
28460 7C3A           8846         17            mov	$17[bp],al
28461                                           !BCC_EOS
28462                                           ! 4843           set_diskette_ret_status(0x20);
28463                                           ! Debug: list int = const $20 (used reg = )
28464 7C3D           B8                   0020  mov	ax,*$20
28465 7C40           50                         push	ax
28466                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28467 7C41           E8         09EB            call	_set_diskette_ret_status
28468 7C44           44                         inc	sp
28469 7C45           44                         inc	sp
28470                                           !BCC_EOS
28471                                           ! 4844           *((Bit8u *)&AX) = (0);
28472                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
28473 7C46           30C0                       xor	al,al
28474 7C48           8846         16            mov	$16[bp],al
28475                                           !BCC_EOS
28476                                           ! 4845           FLAGS |= 0x0001;
28477                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28478 7C4B           8B46         1C            mov	ax,$1C[bp]
28479 7C4E           0C                     01  or	al,*1
28480 7C50           8946         1C            mov	$1C[bp],ax
28481                                           !BCC_EOS
28482                                           ! 4846           return;
28483 7C53           89EC                       mov	sp,bp
28484 7C55           5D                         pop	bp
28485 7C56           C3                         ret
28486                                           !BCC_EOS
28487                                           ! 4847         } else {
28488 7C57           EB           2B            jmp .6CA
28489                       00007C59            .6C8:
28490                                           ! 4848           if ( (return_status[1] & 0x02) != 0 ) {
28491                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$24-$18] (used reg = )
28492 7C59           8A46         EA            mov	al,-$16[bp]
28493 7C5C           24                     02  and	al,*2
28494                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
28495 7C5E           84C0                       test	al,al
28496 7C60           74           14            je  	.6CB
28497                       00007C62            .6CC:
28498                                           ! 4849             AX = 0x0300;
28499                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$24+$14] (used reg = )
28500 7C62           B8                   0300  mov	ax,#$300
28501 7C65           8946         16            mov	$16[bp],ax
28502                                           !BCC_EOS
28503                                           ! 4850             FLAGS |= 0x0001;
28504                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28505 7C68           8B46         1C            mov	ax,$1C[bp]
28506 7C6B           0C                     01  or	al,*1
28507 7C6D           8946         1C            mov	$1C[bp],ax
28508                                           !BCC_EOS
28509                                           ! 4851             return;
28510 7C70           89EC                       mov	sp,bp
28511 7C72           5D                         pop	bp
28512 7C73           C3                         ret
28513                                           !BCC_EOS
28514                                           ! 4852           } else {
28515 7C74           EB           0E            jmp .6CD
28516                       00007C76            .6CB:
28517                                           ! 4853             bios_printf((2 | 4 | 1), "int13_diskette_function: write error\n");
28518                                           ! Debug: list * char = .6CE+0 (used reg = )
28519 7C76           BB                   CDD8  mov	bx,#.6CE
28520 7C79           53                         push	bx
28521                                           ! Debug: list int = const 7 (used reg = )
28522 7C7A           B8                   0007  mov	ax,*7
28523 7C7D           50                         push	ax
28524                                           ! Debug: func () void = bios_printf+0 (used reg = )
28525 7C7E           E8         8CBD            call	_bios_printf
28526 7C81           83C4                   04  add	sp,*4
28527                                           !BCC_EOS
28528                                           ! 4854           }
28529                                           ! 4855         }
28530                       00007C84            .6CD:
28531                                           ! 4856       }
28532                       00007C84            .6CA:
28533                                           ! 4857 floppy_return_success:
28534                       00007C84            .6C6:
28535                       00007C84            .FFDA:
28536                                           ! 4858       set_diskette_current_cyl(drive, track);
28537                                           ! Debug: list unsigned char track = [S+$24-5] (used reg = )
28538 7C84           8A46         FD            mov	al,-3[bp]
28539 7C87           30E4                       xor	ah,ah
28540 7C89           50                         push	ax
28541                                           ! Debug: list unsigned char drive = [S+$26-3] (used reg = )
28542 7C8A           8A46         FF            mov	al,-1[bp]
28543 7C8D           30E4                       xor	ah,ah
28544 7C8F           50                         push	ax
28545                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
28546 7C90           E8         09B4            call	_set_diskette_current_cyl
28547 7C93           83C4                   04  add	sp,*4
28548                                           !BCC_EOS
28549                                           ! 4859       *(((Bit8u *)&AX)+1) = (0x00);
28550                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
28551 7C96           30C0                       xor	al,al
28552 7C98           8846         17            mov	$17[bp],al
28553                                           !BCC_EOS
28554                                           ! 4860       FLAGS &= 0xfffe;
28555                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28556 7C9B           8B46         1C            mov	ax,$1C[bp]
28557 7C9E           24                     FE  and	al,#$FE
28558 7CA0           8946         1C            mov	$1C[bp],ax
28559                                           !BCC_EOS
28560                                           ! 4861       break;
28561 7CA3           E9         0985            br 	.696
28562                                           !BCC_EOS
28563                                           ! 4862     case 0x05:
28564                                           ! 4863 ;
28565                       00007CA6            .6CF:
28566                                           !BCC_EOS
28567                                           ! 4864       num_sectors = ( AX & 0x00ff );
28568                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
28569 7CA6           8A46         16            mov	al,$16[bp]
28570                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$24-4] (used reg = )
28571 7CA9           8846         FE            mov	-2[bp],al
28572                                           !BCC_EOS
28573                                           ! 4865       track = *(((Bit8u *)&CX)+1);
28574                                           ! Debug: eq unsigned char CX = [S+$24+$13] to unsigned char track = [S+$24-5] (used reg = )
28575 7CAC           8A46         15            mov	al,$15[bp]
28576 7CAF           8846         FD            mov	-3[bp],al
28577                                           !BCC_EOS
28578                                           ! 4866       head = *(((Bit8u *)&DX)+1);
28579                                           ! Debug: eq unsigned char DX = [S+$24+$11] to unsigned char head = [S+$24-7] (used reg = )
28580 7CB2           8A46         13            mov	al,$13[bp]
28581 7CB5           8846         FB            mov	-5[bp],al
28582                                           !BCC_EOS
28583                                           ! 4867       drive = ( ELDX & 0x00ff );
28584                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
28585 7CB8           8A46         0E            mov	al,$E[bp]
28586                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
28587 7CBB           8846         FF            mov	-1[bp],al
28588                                           !BCC_EOS
28589                                           ! 4868       if ((drive > 1) || (head > 1) || (track > 79) ||
28590                                           ! 4869           (num_sectors == 0) || (num_sectors > 18)) {
28591                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
28592 7CBE           8A46         FF            mov	al,-1[bp]
28593 7CC1           3C                     01  cmp	al,*1
28594 7CC3           77           1C            ja  	.6D1
28595                       00007CC5            .6D5:
28596                                           ! Debug: gt int = const 1 to unsigned char head = [S+$24-7] (used reg = )
28597 7CC5           8A46         FB            mov	al,-5[bp]
28598 7CC8           3C                     01  cmp	al,*1
28599 7CCA           77           15            ja  	.6D1
28600                       00007CCC            .6D4:
28601                                           ! Debug: gt int = const $4F to unsigned char track = [S+$24-5] (used reg = )
28602 7CCC           8A46         FD            mov	al,-3[bp]
28603 7CCF           3C                     4F  cmp	al,*$4F
28604 7CD1           77           0E            ja  	.6D1
28605                       00007CD3            .6D3:
28606                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$24-4] (used reg = )
28607 7CD3           8A46         FE            mov	al,-2[bp]
28608 7CD6           84C0                       test	al,al
28609 7CD8           74           07            je  	.6D1
28610                       00007CDA            .6D2:
28611                                           ! Debug: gt int = const $12 to unsigned char num_sectors = [S+$24-4] (used reg = )
28612 7CDA           8A46         FE            mov	al,-2[bp]
28613 7CDD           3C                     12  cmp	al,*$12
28614 7CDF           76           16            jbe 	.6D0
28615                       00007CE1            .6D1:
28616                                           ! 4870         *(((Bit8u *)&AX)+1) = (1);
28617                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
28618 7CE1           B0                     01  mov	al,*1
28619 7CE3           8846         17            mov	$17[bp],al
28620                                           !BCC_EOS
28621                                           ! 4871         set_diskette_ret_status(1);
28622                                           ! Debug: list int = const 1 (used reg = )
28623 7CE6           B8                   0001  mov	ax,*1
28624 7CE9           50                         push	ax
28625                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28626 7CEA           E8         0942            call	_set_diskette_ret_status
28627 7CED           44                         inc	sp
28628 7CEE           44                         inc	sp
28629                                           !BCC_EOS
28630                                           ! 4872         FLAGS |= 0x0001;
28631                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28632 7CEF           8B46         1C            mov	ax,$1C[bp]
28633 7CF2           0C                     01  or	al,*1
28634 7CF4           8946         1C            mov	$1C[bp],ax
28635                                           !BCC_EOS
28636                                           ! 4873       }
28637                                           ! 4874       if (floppy_drive_exists(drive) == 0) {
28638                       00007CF7            .6D0:
28639                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
28640 7CF7           8A46         FF            mov	al,-1[bp]
28641 7CFA           30E4                       xor	ah,ah
28642 7CFC           50                         push	ax
28643                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
28644 7CFD           E8         FA36            call	_floppy_drive_exists
28645 7D00           44                         inc	sp
28646 7D01           44                         inc	sp
28647                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
28648 7D02           85C0                       test	ax,ax
28649 7D04           75           1A            jne 	.6D6
28650                       00007D06            .6D7:
28651                                           ! 4875         *(((Bit8u *)&AX)+1) = (0x80);
28652                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
28653 7D06           B0                     80  mov	al,#$80
28654 7D08           8846         17            mov	$17[bp],al
28655                                           !BCC_EOS
28656                                           ! 4876         set_diskette_ret_status(0x80);
28657                                           ! Debug: list int = const $80 (used reg = )
28658 7D0B           B8                   0080  mov	ax,#$80
28659 7D0E           50                         push	ax
28660                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28661 7D0F           E8         091D            call	_set_diskette_ret_status
28662 7D12           44                         inc	sp
28663 7D13           44                         inc	sp
28664                                           !BCC_EOS
28665                                           ! 4877         FLAGS |= 0x0001;
28666                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28667 7D14           8B46         1C            mov	ax,$1C[bp]
28668 7D17           0C                     01  or	al,*1
28669 7D19           8946         1C            mov	$1C[bp],ax
28670                                           !BCC_EOS
28671                                           ! 4878         return;
28672 7D1C           89EC                       mov	sp,bp
28673 7D1E           5D                         pop	bp
28674 7D1F           C3                         ret
28675                                           !BCC_EOS
28676                                           ! 4879       }
28677                                           ! 4880       if (floppy_media_known(drive) == 0) {
28678                       00007D20            .6D6:
28679                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
28680 7D20           8A46         FF            mov	al,-1[bp]
28681 7D23           30E4                       xor	ah,ah
28682 7D25           50                         push	ax
28683                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
28684 7D26           E8         F827            call	_floppy_media_known
28685 7D29           44                         inc	sp
28686 7D2A           44                         inc	sp
28687                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
28688 7D2B           85C0                       test	ax,ax
28689 7D2D           75           2E            jne 	.6D8
28690                       00007D2F            .6D9:
28691                                           ! 4881         if (floppy_media_sense(drive) == 0) {
28692                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
28693 7D2F           8A46         FF            mov	al,-1[bp]
28694 7D32           30E4                       xor	ah,ah
28695 7D34           50                         push	ax
28696                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
28697 7D35           E8         F888            call	_floppy_media_sense
28698 7D38           44                         inc	sp
28699 7D39           44                         inc	sp
28700                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
28701 7D3A           85C0                       test	ax,ax
28702 7D3C           75           1F            jne 	.6DA
28703                       00007D3E            .6DB:
28704                                           ! 4882           *(((Bit8u *)&AX)+1) = (0x0C);
28705                                           ! Debug: eq int = const $C to unsigned char AX = [S+$24+$15] (used reg = )
28706 7D3E           B0                     0C  mov	al,*$C
28707 7D40           8846         17            mov	$17[bp],al
28708                                           !BCC_EOS
28709                                           ! 4883           set_diskette_ret_status(0x0C);
28710                                           ! Debug: list int = const $C (used reg = )
28711 7D43           B8                   000C  mov	ax,*$C
28712 7D46           50                         push	ax
28713                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28714 7D47           E8         08E5            call	_set_diskette_ret_status
28715 7D4A           44                         inc	sp
28716 7D4B           44                         inc	sp
28717                                           !BCC_EOS
28718                                           ! 4884 
28719                                           ! 4884           *((Bit8u *)&AX) = (0);
28720                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
28721 7D4C           30C0                       xor	al,al
28722 7D4E           8846         16            mov	$16[bp],al
28723                                           !BCC_EOS
28724                                           ! 4885           FLAGS |= 0x0001;
28725                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28726 7D51           8B46         1C            mov	ax,$1C[bp]
28727 7D54           0C                     01  or	al,*1
28728 7D56           8946         1C            mov	$1C[bp],ax
28729                                           !BCC_EOS
28730                                           ! 4886           return;
28731 7D59           89EC                       mov	sp,bp
28732 7D5B           5D                         pop	bp
28733 7D5C           C3                         ret
28734                                           !BCC_EOS
28735                                           ! 4887         }
28736                                           ! 4888       }
28737                       00007D5D            .6DA:
28738                                           ! 4889       page = (ES >> 12);
28739                       00007D5D            .6D8:
28740                                           ! Debug: sr int = const $C to unsigned short ES = [S+$24+4] (used reg = )
28741 7D5D           8B46         06            mov	ax,6[bp]
28742 7D60           88E0                       mov	al,ah
28743 7D62           30E4                       xor	ah,ah
28744 7D64           B1                     04  mov	cl,*4
28745 7D66           D3E8                       shr	ax,cl
28746                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$24-$F] (used reg = )
28747 7D68           8846         F3            mov	-$D[bp],al
28748                                           !BCC_EOS
28749                                           ! 4890       base_es = (ES << 4);
28750                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$24+4] (used reg = )
28751 7D6B           8B46         06            mov	ax,6[bp]
28752 7D6E           B1                     04  mov	cl,*4
28753 7D70           D3E0                       shl	ax,cl
28754                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$24-$E] (used reg = )
28755 7D72           8946         F4            mov	-$C[bp],ax
28756                                           !BCC_EOS
28757                                           ! 4891       base_address = base_es + BX;
28758                                           ! Debug: add unsigned short BX = [S+$24+$E] to unsigned short base_es = [S+$24-$E] (used reg = )
28759 7D75           8B46         F4            mov	ax,-$C[bp]
28760 7D78           0346         10            add	ax,$10[bp]
28761                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$24-$A] (used reg = )
28762 7D7B           8946         F8            mov	-8[bp],ax
28763                                           !BCC_EOS
28764                                           ! 4892       if ( base_address < base_es ) {
28765                                           ! Debug: lt unsigned short base_es = [S+$24-$E] to unsigned short base_address = [S+$24-$A] (used reg = )
28766 7D7E           8B46         F8            mov	ax,-8[bp]
28767 7D81           3B46         F4            cmp	ax,-$C[bp]
28768 7D84           73           07            jae 	.6DC
28769                       00007D86            .6DD:
28770                                           ! 4893         page++;
28771                                           ! Debug: postinc unsigned char page = [S+$24-$F] (used reg = )
28772 7D86           8A46         F3            mov	al,-$D[bp]
28773 7D89           40                         inc	ax
28774 7D8A           8846         F3            mov	-$D[bp],al
28775                                           !BCC_EOS
28776                                           ! 4894       }
28777                                           ! 4895       base_count = (num_sectors * 4) - 1;
28778                       00007D8D            .6DC:
28779                                           ! Debug: mul int = const 4 to unsigned char num_sectors = [S+$24-4] (used reg = )
28780 7D8D           8A46         FE            mov	al,-2[bp]
28781 7D90           30E4                       xor	ah,ah
28782 7D92           D1E0                       shl	ax,*1
28783 7D94           D1E0                       shl	ax,*1
28784                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
28785                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$24-$C] (used reg = )
28786 7D96           48                         dec	ax
28787 7D97           8946         F6            mov	-$A[bp],ax
28788                                           !BCC_EOS
28789                                           ! 4896       last_addr = base_address + base_count;
28790                                           ! Debug: add unsigned short base_count = [S+$24-$C] to unsigned short base_address = [S+$24-$A] (used reg = )
28791 7D9A           8B46         F8            mov	ax,-8[bp]
28792 7D9D           0346         F6            add	ax,-$A[bp]
28793                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$24-$22] (used reg = )
28794 7DA0           8946         E0            mov	-$20[bp],ax
28795                                           !BCC_EOS
28796                                           ! 4897       if (last_addr < base_address) {
28797                                           ! Debug: lt unsigned short base_address = [S+$24-$A] to unsigned short last_addr = [S+$24-$22] (used reg = )
28798 7DA3           8B46         E0            mov	ax,-$20[bp]
28799 7DA6           3B46         F8            cmp	ax,-8[bp]
28800 7DA9           73           1F            jae 	.6DE
28801                       00007DAB            .6DF:
28802                                           ! 4898         *(((Bit8u *)&AX)+1) = (0x09);
28803                                           ! Debug: eq int = const 9 to unsigned char AX = [S+$24+$15] (used reg = )
28804 7DAB           B0                     09  mov	al,*9
28805 7DAD           8846         17            mov	$17[bp],al
28806                                           !BCC_EOS
28807                                           ! 4899         set_diskette_ret_status(0x09);
28808                                           ! Debug: list int = const 9 (used reg = )
28809 7DB0           B8                   0009  mov	ax,*9
28810 7DB3           50                         push	ax
28811                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28812 7DB4           E8         0878            call	_set_diskette_ret_status
28813 7DB7           44                         inc	sp
28814 7DB8           44                         inc	sp
28815                                           !BCC_EOS
28816                                           ! 4900         *((Bit8u *)&AX) = (0);
28817                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
28818 7DB9           30C0                       xor	al,al
28819 7DBB           8846         16            mov	$16[bp],al
28820                                           !BCC_EOS
28821                                           ! 4901         FLAGS |= 0x0001;
28822                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
28823 7DBE           8B46         1C            mov	ax,$1C[bp]
28824 7DC1           0C                     01  or	al,*1
28825 7DC3           8946         1C            mov	$1C[bp],ax
28826                                           !BCC_EOS
28827                                           ! 4902         return;
28828 7DC6           89EC                       mov	sp,bp
28829 7DC8           5D                         pop	bp
28830 7DC9           C3                         ret
28831                                           !BCC_EOS
28832                                           ! 4903       }
28833                                           ! 4904       outb(0x000a, 0x06);
28834                       00007DCA            .6DE:
28835                                           ! Debug: list int = const 6 (used reg = )
28836 7DCA           B8                   0006  mov	ax,*6
28837 7DCD           50                         push	ax
28838                                           ! Debug: list int = const $A (used reg = )
28839 7DCE           B8                   000A  mov	ax,*$A
28840 7DD1           50                         push	ax
28841                                           ! Debug: func () void = outb+0 (used reg = )
28842 7DD2           E8         8739            call	_outb
28843 7DD5           83C4                   04  add	sp,*4
28844                                           !BCC_EOS
28845                                           ! 4905       outb(0x000c, 0x00);
28846                                           ! Debug: list int = const 0 (used reg = )
28847 7DD8           31C0                       xor	ax,ax
28848 7DDA           50                         push	ax
28849                                           ! Debug: list int = const $C (used reg = )
28850 7DDB           B8                   000C  mov	ax,*$C
28851 7DDE           50                         push	ax
28852                                           ! Debug: func () void = outb+0 (used reg = )
28853 7DDF           E8         872C            call	_outb
28854 7DE2           83C4                   04  add	sp,*4
28855                                           !BCC_EOS
28856                                           ! 4906       outb(0x0004, base_address);
28857                                           ! Debug: list unsigned short base_address = [S+$24-$A] (used reg = )
28858 7DE5           FF76         F8            push	-8[bp]
28859                                           ! Debug: list int = const 4 (used reg = )
28860 7DE8           B8                   0004  mov	ax,*4
28861 7DEB           50                         push	ax
28862                                           ! Debug: func () void = outb+0 (used reg = )
28863 7DEC           E8         871F            call	_outb
28864 7DEF           83C4                   04  add	sp,*4
28865                                           !BCC_EOS
28866                                           ! 4907       outb(0x0004, *(((Bit8u *)&base_address)+1));
28867                                           ! Debug: list unsigned char base_address = [S+$24-9] (used reg = )
28868 7DF2           8A46         F9            mov	al,-7[bp]
28869 7DF5           30E4                       xor	ah,ah
28870 7DF7           50                         push	ax
28871                                           ! Debug: list int = const 4 (used reg = )
28872 7DF8           B8                   0004  mov	ax,*4
28873 7DFB           50                         push	ax
28874                                           ! Debug: func () void = outb+0 (used reg = )
28875 7DFC           E8         870F            call	_outb
28876 7DFF           83C4                   04  add	sp,*4
28877                                           !BCC_EOS
28878                                           ! 4908       outb(0x000c, 0x00);
28879                                           ! Debug: list int = const 0 (used reg = )
28880 7E02           31C0                       xor	ax,ax
28881 7E04           50                         push	ax
28882                                           ! Debug: list int = const $C (used reg = )
28883 7E05           B8                   000C  mov	ax,*$C
28884 7E08           50                         push	ax
28885                                           ! Debug: func () void = outb+0 (used reg = )
28886 7E09           E8         8702            call	_outb
28887 7E0C           83C4                   04  add	sp,*4
28888                                           !BCC_EOS
28889                                           ! 4909       outb(0x0005, base_count);
28890                                           ! Debug: list unsigned short base_count = [S+$24-$C] (used reg = )
28891 7E0F           FF76         F6            push	-$A[bp]
28892                                           ! Debug: list int = const 5 (used reg = )
28893 7E12           B8                   0005  mov	ax,*5
28894 7E15           50                         push	ax
28895                                           ! Debug: func () void = outb+0 (used reg = )
28896 7E16           E8         86F5            call	_outb
28897 7E19           83C4                   04  add	sp,*4
28898                                           !BCC_EOS
28899                                           ! 4910       outb(0x0005, *(((Bit8u *)&base_count)+1));
28900                                           ! Debug: list unsigned char base_count = [S+$24-$B] (used reg = )
28901 7E1C           8A46         F7            mov	al,-9[bp]
28902 7E1F           30E4                       xor	ah,ah
28903 7E21           50                         push	ax
28904                                           ! Debug: list int = const 5 (used reg = )
28905 7E22           B8                   0005  mov	ax,*5
28906 7E25           50                         push	ax
28907                                           ! Debug: func () void = outb+0 (used reg = )
28908 7E26           E8         86E5            call	_outb
28909 7E29           83C4                   04  add	sp,*4
28910                                           !BCC_EOS
28911                                           ! 4911       mode_register = 0x4a;
28912                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$24-$10] (used reg = )
28913 7E2C           B0                     4A  mov	al,*$4A
28914 7E2E           8846         F2            mov	-$E[bp],al
28915                                           !BCC_EOS
28916                                           ! 4912       outb(0x000b, mode_register);
28917                                           ! Debug: list unsigned char mode_register = [S+$24-$10] (used reg = )
28918 7E31           8A46         F2            mov	al,-$E[bp]
28919 7E34           30E4                       xor	ah,ah
28920 7E36           50                         push	ax
28921                                           ! Debug: list int = const $B (used reg = )
28922 7E37           B8                   000B  mov	ax,*$B
28923 7E3A           50                         push	ax
28924                                           ! Debug: func () void = outb+0 (used reg = )
28925 7E3B           E8         86D0            call	_outb
28926 7E3E           83C4                   04  add	sp,*4
28927                                           !BCC_EOS
28928                                           ! 4913       outb(0x0081, page);
28929                                           ! Debug: list unsigned char page = [S+$24-$F] (used reg = )
28930 7E41           8A46         F3            mov	al,-$D[bp]
28931 7E44           30E4                       xor	ah,ah
28932 7E46           50                         push	ax
28933                                           ! Debug: list int = const $81 (used reg = )
28934 7E47           B8                   0081  mov	ax,#$81
28935 7E4A           50                         push	ax
28936                                           ! Debug: func () void = outb+0 (used reg = )
28937 7E4B           E8         86C0            call	_outb
28938 7E4E           83C4                   04  add	sp,*4
28939                                           !BCC_EOS
28940                                           ! 4914       outb(0x000a, 0x02);
28941                                           ! Debug: list int = const 2 (used reg = )
28942 7E51           B8                   0002  mov	ax,*2
28943 7E54           50                         push	ax
28944                                           ! Debug: list int = const $A (used reg = )
28945 7E55           B8                   000A  mov	ax,*$A
28946 7E58           50                         push	ax
28947                                           ! Debug: func () void = outb+0 (used reg = )
28948 7E59           E8         86B2            call	_outb
28949 7E5C           83C4                   04  add	sp,*4
28950                                           !BCC_EOS
28951                                           ! 4915       floppy_prepare_controller(drive);
28952                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
28953 7E5F           8A46         FF            mov	al,-1[bp]
28954 7E62           30E4                       xor	ah,ah
28955 7E64           50                         push	ax
28956                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
28957 7E65           E8         F648            call	_floppy_prepare_controller
28958 7E68           44                         inc	sp
28959 7E69           44                         inc	sp
28960                                           !BCC_EOS
28961                                           ! 4916       outb(0x03f5, 0x4d);
28962                                           ! Debug: list int = const $4D (used reg = )
28963 7E6A           B8                   004D  mov	ax,*$4D
28964 7E6D           50                         push	ax
28965                                           ! Debug: list int = const $3F5 (used reg = )
28966 7E6E           B8                   03F5  mov	ax,#$3F5
28967 7E71           50                         push	ax
28968                                           ! Debug: func () void = outb+0 (used reg = )
28969 7E72           E8         8699            call	_outb
28970 7E75           83C4                   04  add	sp,*4
28971                                           !BCC_EOS
28972                                           ! 4917       outb(0x03f5, (head << 2) | drive);
28973                                           ! Debug: sl int = const 2 to unsigned char head = [S+$24-7] (used reg = )
28974 7E78           8A46         FB            mov	al,-5[bp]
28975 7E7B           30E4                       xor	ah,ah
28976 7E7D           D1E0                       shl	ax,*1
28977 7E7F           D1E0                       shl	ax,*1
28978                                           ! Debug: or unsigned char drive = [S+$24-3] to unsigned int = ax+0 (used reg = )
28979 7E81           0A46         FF            or	al,-1[bp]
28980                                           ! Debug: list unsigned int = ax+0 (used reg = )
28981 7E84           50                         push	ax
28982                                           ! Debug: list int = const $3F5 (used reg = )
28983 7E85           B8                   03F5  mov	ax,#$3F5
28984 7E88           50                         push	ax
28985                                           ! Debug: func () void = outb+0 (used reg = )
28986 7E89           E8         8682            call	_outb
28987 7E8C           83C4                   04  add	sp,*4
28988                                           !BCC_EOS
28989                                           ! 4918       outb(0x03f5, 2);
28990                                           ! Debug: list int = const 2 (used reg = )
28991 7E8F           B8                   0002  mov	ax,*2
28992 7E92           50                         push	ax
28993                                           ! Debug: list int = const $3F5 (used reg = )
28994 7E93           B8                   03F5  mov	ax,#$3F5
28995 7E96           50                         push	ax
28996                                           ! Debug: func () void = outb+0 (used reg = )
28997 7E97           E8         8674            call	_outb
28998 7E9A           83C4                   04  add	sp,*4
28999                                           !BCC_EOS
29000                                           ! 4919       outb(0x03f5, num_sectors);
29001                                           ! Debug: list unsigned char num_sectors = [S+$24-4] (used reg = )
29002 7E9D           8A46         FE            mov	al,-2[bp]
29003 7EA0           30E4                       xor	ah,ah
29004 7EA2           50                         push	ax
29005                                           ! Debug: list int = const $3F5 (used reg = )
29006 7EA3           B8                   03F5  mov	ax,#$3F5
29007 7EA6           50                         push	ax
29008                                           ! Debug: func () void = outb+0 (used reg = )
29009 7EA7           E8         8664            call	_outb
29010 7EAA           83C4                   04  add	sp,*4
29011                                           !BCC_EOS
29012                                           ! 4920       outb(0x03f5, 0);
29013                                           ! Debug: list int = const 0 (used reg = )
29014 7EAD           31C0                       xor	ax,ax
29015 7EAF           50                         push	ax
29016                                           ! Debug: list int = const $3F5 (used reg = )
29017 7EB0           B8                   03F5  mov	ax,#$3F5
29018 7EB3           50                         push	ax
29019                                           ! Debug: func () void = outb+0 (used reg = )
29020 7EB4           E8         8657            call	_outb
29021 7EB7           83C4                   04  add	sp,*4
29022                                           !BCC_EOS
29023                                           ! 4921       outb(0x03f5, 0xf6);
29024                                           ! Debug: list int = const $F6 (used reg = )
29025 7EBA           B8                   00F6  mov	ax,#$F6
29026 7EBD           50                         push	ax
29027                                           ! Debug: list int = const $3F5 (used reg = )
29028 7EBE           B8                   03F5  mov	ax,#$3F5
29029 7EC1           50                         push	ax
29030                                           ! Debug: func () void = outb+0 (used reg = )
29031 7EC2           E8         8649            call	_outb
29032 7EC5           83C4                   04  add	sp,*4
29033                                           !BCC_EOS
29034                                           ! 4922 #asm
29035                                           !BCC_EOS
29036                                           !BCC_ASM
29037                       0000002E            _int13_diskette_function.BP	set	$2E
29038                       0000000C            .int13_diskette_function.BP	set	$C
29039                       0000003C            _int13_diskette_function.CS	set	$3C
29040                       0000001A            .int13_diskette_function.CS	set	$1A
29041                       00000036            _int13_diskette_function.CX	set	$36
29042                       00000014            .int13_diskette_function.CX	set	$14
29043                       0000001A            _int13_diskette_function.base_address	set	$1A
29044                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
29045                       0000002A            _int13_diskette_function.DI	set	$2A
29046                       00000008            .int13_diskette_function.DI	set	8
29047                       0000003E            _int13_diskette_function.FLAGS	set	$3E
29048                       0000001C            .int13_diskette_function.FLAGS	set	$1C
29049                       00000018            _int13_diskette_function.base_count	set	$18
29050                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
29051                       0000001E            _int13_diskette_function.sector	set	$1E
29052                       FFFFFFFC            .int13_diskette_function.sector	set	-4
29053                       00000026            _int13_diskette_function.DS	set	$26
29054                       00000004            .int13_diskette_function.DS	set	4
29055                       0000001D            _int13_diskette_function.head	set	$1D
29056                       FFFFFFFB            .int13_diskette_function.head	set	-5
29057                       00000030            _int13_diskette_function.ELDX	set	$30
29058                       0000000E            .int13_diskette_function.ELDX	set	$E
29059                       00000012            _int13_diskette_function.dor	set	$12
29060                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
29061                       00000034            _int13_diskette_function.DX	set	$34
29062                       00000012            .int13_diskette_function.DX	set	$12
29063                       0000000B            _int13_diskette_function.return_status	set	$B
29064                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
29065                       00000004            _int13_diskette_function.es	set	4
29066                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
29067                       00000014            _int13_diskette_function.mode_register	set	$14
29068                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
29069                       00000028            _int13_diskette_function.ES	set	$28
29070                       00000006            .int13_diskette_function.ES	set	6
29071                       00000016            _int13_diskette_function.base_es	set	$16
29072                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
29073                       0000001F            _int13_diskette_function.track	set	$1F
29074                       FFFFFFFD            .int13_diskette_function.track	set	-3
29075                       0000002C            _int13_diskette_function.SI	set	$2C
29076                       0000000A            .int13_diskette_function.SI	set	$A
29077                       0000000A            _int13_diskette_function.drive_type	set	$A
29078                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
29079                       00000020            _int13_diskette_function.num_sectors	set	$20
29080                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
29081                       0000003A            _int13_diskette_function.IP	set	$3A
29082                       00000018            .int13_diskette_function.IP	set	$18
29083                       00000007            _int13_diskette_function.spt	set	7
29084                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
29085                       0000001C            _int13_diskette_function.status	set	$1C
29086                       FFFFFFFA            .int13_diskette_function.status	set	-6
29087                       00000000            _int13_diskette_function.maxCyl	set	0
29088                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
29089                       00000038            _int13_diskette_function.AX	set	$38
29090                       00000016            .int13_diskette_function.AX	set	$16
29091                       00000013            _int13_diskette_function.val8	set	$13
29092                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
29093                       00000002            _int13_diskette_function.last_addr	set	2
29094                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
29095                       00000015            _int13_diskette_function.page	set	$15
29096                       FFFFFFF3            .int13_diskette_function.page	set	-$D
29097                       00000008            _int13_diskette_function.ah	set	8
29098                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
29099                       00000021            _int13_diskette_function.drive	set	$21
29100                       FFFFFFFF            .int13_diskette_function.drive	set	-1
29101                       00000009            _int13_diskette_function.num_floppies	set	9
29102                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
29103                       00000032            _int13_diskette_function.BX	set	$32
29104                       00000010            .int13_diskette_function.BX	set	$10
29105 7EC8           FB                               sti
29106                                           ! 4924 endasm
29107                                           !BCC_ENDASM
29108                                           !BCC_EOS
29109                                           ! 4925       do {
29110                       00007EC9            .6E2:
29111                                           ! 4926         val8 = *((Bit8u *)(0x0040));
29112                                           ! Debug: eq unsigned char = [+$40] to unsigned char val8 = [S+$24-$11] (used reg = )
29113 7EC9           A0         0040            mov	al,[$40]
29114 7ECC           8846         F1            mov	-$F[bp],al
29115                                           !BCC_EOS
29116                                           ! 4927         if (val8 == 0) {
29117                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
29118 7ECF           8A46         F1            mov	al,-$F[bp]
29119 7ED2           84C0                       test	al,al
29120 7ED4           75           1D            jne 	.6E3
29121                       00007ED6            .6E4:
29122                                           ! 4928           floppy_reset_controller();
29123                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
29124 7ED6           E8         F589            call	_floppy_reset_controller
29125                                           !BCC_EOS
29126                                           ! 4929           *(((Bit8u *)&AX)+1) = (0x80);
29127                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
29128 7ED9           B0                     80  mov	al,#$80
29129 7EDB           8846         17            mov	$17[bp],al
29130                                           !BCC_EOS
29131                                           ! 4930           set_diskette_ret_status(0x80);
29132                                           ! Debug: list int = const $80 (used reg = )
29133 7EDE           B8                   0080  mov	ax,#$80
29134 7EE1           50                         push	ax
29135                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
29136 7EE2           E8         074A            call	_set_diskette_ret_status
29137 7EE5           44                         inc	sp
29138 7EE6           44                         inc	sp
29139                                           !BCC_EOS
29140                                           ! 4931           FLAGS |= 0x0001;
29141                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29142 7EE7           8B46         1C            mov	ax,$1C[bp]
29143 7EEA           0C                     01  or	al,*1
29144 7EEC           8946         1C            mov	$1C[bp],ax
29145                                           !BCC_EOS
29146                                           ! 4932           return;
29147 7EEF           89EC                       mov	sp,bp
29148 7EF1           5D                         pop	bp
29149 7EF2           C3                         ret
29150                                           !BCC_EOS
29151                                           ! 4933         }
29152                                           ! 4934         val8 = (*((Bit8u *)(0x003e)) & 0x80);
29153                       00007EF3            .6E3:
29154                                           ! Debug: and int = const $80 to unsigned char = [+$3E] (used reg = )
29155 7EF3           A0         003E            mov	al,[$3E]
29156 7EF6           24                     80  and	al,#$80
29157                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
29158 7EF8           8846         F1            mov	-$F[bp],al
29159                                           !BCC_EOS
29160                                           ! 4935       } while ( val8 == 0 );
29161                       00007EFB            .6E1:
29162                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
29163 7EFB           8A46         F1            mov	al,-$F[bp]
29164 7EFE           84C0                       test	al,al
29165 7F00           74           C7            je 	.6E2
29166                       00007F02            .6E5:
29167                                           !BCC_EOS
29168                                           ! 4936       val8 = 0;
29169                       00007F02            .6E0:
29170                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$24-$11] (used reg = )
29171 7F02           30C0                       xor	al,al
29172 7F04           8846         F1            mov	-$F[bp],al
29173                                           !BCC_EOS
29174                                           ! 4937 #asm
29175                                           !BCC_EOS
29176                                           !BCC_ASM
29177                       0000002E            _int13_diskette_function.BP	set	$2E
29178                       0000000C            .int13_diskette_function.BP	set	$C
29179                       0000003C            _int13_diskette_function.CS	set	$3C
29180                       0000001A            .int13_diskette_function.CS	set	$1A
29181                       00000036            _int13_diskette_function.CX	set	$36
29182                       00000014            .int13_diskette_function.CX	set	$14
29183                       0000001A            _int13_diskette_function.base_address	set	$1A
29184                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
29185                       0000002A            _int13_diskette_function.DI	set	$2A
29186                       00000008            .int13_diskette_function.DI	set	8
29187                       0000003E            _int13_diskette_function.FLAGS	set	$3E
29188                       0000001C            .int13_diskette_function.FLAGS	set	$1C
29189                       00000018            _int13_diskette_function.base_count	set	$18
29190                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
29191                       0000001E            _int13_diskette_function.sector	set	$1E
29192                       FFFFFFFC            .int13_diskette_function.sector	set	-4
29193                       00000026            _int13_diskette_function.DS	set	$26
29194                       00000004            .int13_diskette_function.DS	set	4
29195                       0000001D            _int13_diskette_function.head	set	$1D
29196                       FFFFFFFB            .int13_diskette_function.head	set	-5
29197                       00000030            _int13_diskette_function.ELDX	set	$30
29198                       0000000E            .int13_diskette_function.ELDX	set	$E
29199                       00000012            _int13_diskette_function.dor	set	$12
29200                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
29201                       00000034            _int13_diskette_function.DX	set	$34
29202                       00000012            .int13_diskette_function.DX	set	$12
29203                       0000000B            _int13_diskette_function.return_status	set	$B
29204                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
29205                       00000004            _int13_diskette_function.es	set	4
29206                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
29207                       00000014            _int13_diskette_function.mode_register	set	$14
29208                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
29209                       00000028            _int13_diskette_function.ES	set	$28
29210                       00000006            .int13_diskette_function.ES	set	6
29211                       00000016            _int13_diskette_function.base_es	set	$16
29212                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
29213                       0000001F            _int13_diskette_function.track	set	$1F
29214                       FFFFFFFD            .int13_diskette_function.track	set	-3
29215                       0000002C            _int13_diskette_function.SI	set	$2C
29216                       0000000A            .int13_diskette_function.SI	set	$A
29217                       0000000A            _int13_diskette_function.drive_type	set	$A
29218                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
29219                       00000020            _int13_diskette_function.num_sectors	set	$20
29220                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
29221                       0000003A            _int13_diskette_function.IP	set	$3A
29222                       00000018            .int13_diskette_function.IP	set	$18
29223                       00000007            _int13_diskette_function.spt	set	7
29224                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
29225                       0000001C            _int13_diskette_function.status	set	$1C
29226                       FFFFFFFA            .int13_diskette_function.status	set	-6
29227                       00000000            _int13_diskette_function.maxCyl	set	0
29228                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
29229                       00000038            _int13_diskette_function.AX	set	$38
29230                       00000016            .int13_diskette_function.AX	set	$16
29231                       00000013            _int13_diskette_function.val8	set	$13
29232                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
29233                       00000002            _int13_diskette_function.last_addr	set	2
29234                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
29235                       00000015            _int13_diskette_function.page	set	$15
29236                       FFFFFFF3            .int13_diskette_function.page	set	-$D
29237                       00000008            _int13_diskette_function.ah	set	8
29238                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
29239                       00000021            _int13_diskette_function.drive	set	$21
29240                       FFFFFFFF            .int13_diskette_function.drive	set	-1
29241                       00000009            _int13_diskette_function.num_floppies	set	9
29242                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
29243                       00000032            _int13_diskette_function.BX	set	$32
29244                       00000010            .int13_diskette_function.BX	set	$10
29245 7F07           FA                               cli
29246                                           ! 4939 endasm
29247                                           !BCC_ENDASM
29248                                           !BCC_EOS
29249                                           ! 4940       val8 = *((Bit8u *)(0x003e));
29250                                           ! Debug: eq unsigned char = [+$3E] to unsigned char val8 = [S+$24-$11] (used reg = )
29251 7F08           A0         003E            mov	al,[$3E]
29252 7F0B           8846         F1            mov	-$F[bp],al
29253                                           !BCC_EOS
29254                                           ! 4941       val8 &= 0x7f;
29255                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$24-$11] (used reg = )
29256 7F0E           8A46         F1            mov	al,-$F[bp]
29257 7F11           24                     7F  and	al,*$7F
29258 7F13           8846         F1            mov	-$F[bp],al
29259                                           !BCC_EOS
29260                                           ! 4942       *((Bit8u *)(0x003e)) = (val8);
29261                                           ! Debug: eq unsigned char val8 = [S+$24-$11] to unsigned char = [+$3E] (used reg = )
29262 7F16           8A46         F1            mov	al,-$F[bp]
29263 7F19           A2         003E            mov	[$3E],al
29264                                           !BCC_EOS
29265                                           ! 4943       val8 = inb(0x03f4);
29266                                           ! Debug: list int = const $3F4 (used reg = )
29267 7F1C           B8                   03F4  mov	ax,#$3F4
29268 7F1F           50                         push	ax
29269                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29270 7F20           E8         85D5            call	_inb
29271 7F23           44                         inc	sp
29272 7F24           44                         inc	sp
29273                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
29274 7F25           8846         F1            mov	-$F[bp],al
29275                                           !BCC_EOS
29276                                           ! 4944       if ( (val8 & 0xc0) != 0xc0 )
29277                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$24-$11] (used reg = )
29278 7F28           8A46         F1            mov	al,-$F[bp]
29279 7F2B           24                     C0  and	al,#$C0
29280                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
29281 7F2D           3C                     C0  cmp	al,#$C0
29282 7F2F           74           0E            je  	.6E6
29283                       00007F31            .6E7:
29284                                           ! 4945         bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
29285                                           ! Debug: list * char = .6E8+0 (used reg = )
29286 7F31           BB                   CDB8  mov	bx,#.6E8
29287 7F34           53                         push	bx
29288                                           ! Debug: list int = const 7 (used reg = )
29289 7F35           B8                   0007  mov	ax,*7
29290 7F38           50                         push	ax
29291                                           ! Debug: func () void = bios_printf+0 (used reg = )
29292 7F39           E8         8A02            call	_bios_printf
29293 7F3C           83C4                   04  add	sp,*4
29294                                           !BCC_EOS
29295                                           ! 4946       return_status[0] = inb(0x03f5);
29296                       00007F3F            .6E6:
29297                                           ! Debug: list int = const $3F5 (used reg = )
29298 7F3F           B8                   03F5  mov	ax,#$3F5
29299 7F42           50                         push	ax
29300                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29301 7F43           E8         85B2            call	_inb
29302 7F46           44                         inc	sp
29303 7F47           44                         inc	sp
29304                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$19] (used reg = )
29305 7F48           8846         E9            mov	-$17[bp],al
29306                                           !BCC_EOS
29307                                           ! 4947       return_status[1] = inb(0x03f5);
29308                                           ! Debug: list int = const $3F5 (used reg = )
29309 7F4B           B8                   03F5  mov	ax,#$3F5
29310 7F4E           50                         push	ax
29311                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29312 7F4F           E8         85A6            call	_inb
29313 7F52           44                         inc	sp
29314 7F53           44                         inc	sp
29315                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$18] (used reg = )
29316 7F54           8846         EA            mov	-$16[bp],al
29317                                           !BCC_EOS
29318                                           ! 4948       return_status[2] = inb(0x03f5);
29319                                           ! Debug: list int = const $3F5 (used reg = )
29320 7F57           B8                   03F5  mov	ax,#$3F5
29321 7F5A           50                         push	ax
29322                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29323 7F5B           E8         859A            call	_inb
29324 7F5E           44                         inc	sp
29325 7F5F           44                         inc	sp
29326                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$17] (used reg = )
29327 7F60           8846         EB            mov	-$15[bp],al
29328                                           !BCC_EOS
29329                                           ! 4949       return_status[3] = inb(0x03f5);
29330                                           ! Debug: list int = const $3F5 (used reg = )
29331 7F63           B8                   03F5  mov	ax,#$3F5
29332 7F66           50                         push	ax
29333                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29334 7F67           E8         858E            call	_inb
29335 7F6A           44                         inc	sp
29336 7F6B           44                         inc	sp
29337                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$16] (used reg = )
29338 7F6C           8846         EC            mov	-$14[bp],al
29339                                           !BCC_EOS
29340                                           ! 4950       return_status[4] = inb(0x03f5);
29341                                           ! Debug: list int = const $3F5 (used reg = )
29342 7F6F           B8                   03F5  mov	ax,#$3F5
29343 7F72           50                         push	ax
29344                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29345 7F73           E8         8582            call	_inb
29346 7F76           44                         inc	sp
29347 7F77           44                         inc	sp
29348                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$15] (used reg = )
29349 7F78           8846         ED            mov	-$13[bp],al
29350                                           !BCC_EOS
29351                                           ! 4951       return_status[5] = inb(0x03f5);
29352                                           ! Debug: list int = const $3F5 (used reg = )
29353 7F7B           B8                   03F5  mov	ax,#$3F5
29354 7F7E           50                         push	ax
29355                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29356 7F7F           E8         8576            call	_inb
29357 7F82           44                         inc	sp
29358 7F83           44                         inc	sp
29359                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$14] (used reg = )
29360 7F84           8846         EE            mov	-$12[bp],al
29361                                           !BCC_EOS
29362                                           ! 4952       return_status[6] = inb(0x03f5);
29363                                           ! Debug: list int = const $3F5 (used reg = )
29364 7F87           B8                   03F5  mov	ax,#$3F5
29365 7F8A           50                         push	ax
29366                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29367 7F8B           E8         856A            call	_inb
29368 7F8E           44                         inc	sp
29369 7F8F           44                         inc	sp
29370                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$24-$13] (used reg = )
29371 7F90           8846         EF            mov	-$11[bp],al
29372                                           !BCC_EOS
29373                                           ! 4953       _memcpyb(0x0042,0x0040,return_status,get_SS(),7);
29374                                           ! Debug: list int = const 7 (used reg = )
29375 7F93           B8                   0007  mov	ax,*7
29376 7F96           50                         push	ax
29377                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
29378 7F97           E8         86C5            call	_get_SS
29379                                           ! Debug: list unsigned short = ax+0 (used reg = )
29380 7F9A           50                         push	ax
29381                                           ! Debug: list * unsigned char return_status = S+$28-$19 (used reg = )
29382 7F9B           8D5E         E9            lea	bx,-$17[bp]
29383 7F9E           53                         push	bx
29384                                           ! Debug: list int = const $40 (used reg = )
29385 7F9F           B8                   0040  mov	ax,*$40
29386 7FA2           50                         push	ax
29387                                           ! Debug: list int = const $42 (used reg = )
29388 7FA3           B8                   0042  mov	ax,*$42
29389 7FA6           50                         push	ax
29390                                           ! Debug: func () void = _memcpyb+0 (used reg = )
29391 7FA7           E8         8071            call	__memcpyb
29392 7FAA           83C4                   0A  add	sp,*$A
29393                                           !BCC_EOS
29394                                           ! 4954       if ( (return_sta
29395                                           ! 4954 tus[0] & 0xc0) != 0 ) {
29396                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$24-$19] (used reg = )
29397 7FAD           8A46         E9            mov	al,-$17[bp]
29398 7FB0           24                     C0  and	al,#$C0
29399                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
29400 7FB2           84C0                       test	al,al
29401 7FB4           74           2C            je  	.6E9
29402                       00007FB6            .6EA:
29403                                           ! 4955         if ( (return_status[1] & 0x02) != 0 ) {
29404                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$24-$18] (used reg = )
29405 7FB6           8A46         EA            mov	al,-$16[bp]
29406 7FB9           24                     02  and	al,*2
29407                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
29408 7FBB           84C0                       test	al,al
29409 7FBD           74           15            je  	.6EB
29410                       00007FBF            .6EC:
29411                                           ! 4956           AX = 0x0300;
29412                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$24+$14] (used reg = )
29413 7FBF           B8                   0300  mov	ax,#$300
29414 7FC2           8946         16            mov	$16[bp],ax
29415                                           !BCC_EOS
29416                                           ! 4957           FLAGS |= 0x0001;
29417                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29418 7FC5           8B46         1C            mov	ax,$1C[bp]
29419 7FC8           0C                     01  or	al,*1
29420 7FCA           8946         1C            mov	$1C[bp],ax
29421                                           !BCC_EOS
29422                                           ! 4958           return;
29423 7FCD           89EC                       mov	sp,bp
29424 7FCF           5D                         pop	bp
29425 7FD0           C3                         ret
29426                                           !BCC_EOS
29427                                           ! 4959         } else {
29428 7FD1           E9         000E            br 	.6ED
29429                       00007FD4            .6EB:
29430                                           ! 4960           bios_printf((2 | 4 | 1), "int13_diskette_function: write error\n");
29431                                           ! Debug: list * char = .6EE+0 (used reg = )
29432 7FD4           BB                   CD92  mov	bx,#.6EE
29433 7FD7           53                         push	bx
29434                                           ! Debug: list int = const 7 (used reg = )
29435 7FD8           B8                   0007  mov	ax,*7
29436 7FDB           50                         push	ax
29437                                           ! Debug: func () void = bios_printf+0 (used reg = )
29438 7FDC           E8         895F            call	_bios_printf
29439 7FDF           83C4                   04  add	sp,*4
29440                                           !BCC_EOS
29441                                           ! 4961         }
29442                                           ! 4962       }
29443                       00007FE2            .6ED:
29444                                           ! 4963       *(((Bit8u *)&AX)+1) = (0);
29445                       00007FE2            .6E9:
29446                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
29447 7FE2           30C0                       xor	al,al
29448 7FE4           8846         17            mov	$17[bp],al
29449                                           !BCC_EOS
29450                                           ! 4964       set_diskette_ret_status(0);
29451                                           ! Debug: list int = const 0 (used reg = )
29452 7FE7           31C0                       xor	ax,ax
29453 7FE9           50                         push	ax
29454                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
29455 7FEA           E8         0642            call	_set_diskette_ret_status
29456 7FED           44                         inc	sp
29457 7FEE           44                         inc	sp
29458                                           !BCC_EOS
29459                                           ! 4965       set_diskette_current_cyl(drive, 0);
29460                                           ! Debug: list int = const 0 (used reg = )
29461 7FEF           31C0                       xor	ax,ax
29462 7FF1           50                         push	ax
29463                                           ! Debug: list unsigned char drive = [S+$26-3] (used reg = )
29464 7FF2           8A46         FF            mov	al,-1[bp]
29465 7FF5           30E4                       xor	ah,ah
29466 7FF7           50                         push	ax
29467                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
29468 7FF8           E8         064C            call	_set_diskette_current_cyl
29469 7FFB           83C4                   04  add	sp,*4
29470                                           !BCC_EOS
29471                                           ! 4966       FLAGS &= 0xfffe;
29472                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29473 7FFE           8B46         1C            mov	ax,$1C[bp]
29474 8001           24                     FE  and	al,#$FE
29475 8003           8946         1C            mov	$1C[bp],ax
29476                                           !BCC_EOS
29477                                           ! 4967       return;
29478 8006           89EC                       mov	sp,bp
29479 8008           5D                         pop	bp
29480 8009           C3                         ret
29481                                           !BCC_EOS
29482                                           ! 4968     case 0x08:
29483                                           ! 4969 ;
29484                       0000800A            .6EF:
29485                                           !BCC_EOS
29486                                           ! 4970       drive = ( ELDX & 0x00ff );
29487                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
29488 800A           8A46         0E            mov	al,$E[bp]
29489                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
29490 800D           8846         FF            mov	-1[bp],al
29491                                           !BCC_EOS
29492                                           ! 4971       if (drive > 1) {
29493                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
29494 8010           8A46         FF            mov	al,-1[bp]
29495 8013           3C                     01  cmp	al,*1
29496 8015           76           30            jbe 	.6F0
29497                       00008017            .6F1:
29498                                           ! 4972         AX = 0;
29499                                           ! Debug: eq int = const 0 to unsigned short AX = [S+$24+$14] (used reg = )
29500 8017           31C0                       xor	ax,ax
29501 8019           8946         16            mov	$16[bp],ax
29502                                           !BCC_EOS
29503                                           ! 4973         BX = 0;
29504                                           ! Debug: eq int = const 0 to unsigned short BX = [S+$24+$E] (used reg = )
29505 801C           31C0                       xor	ax,ax
29506 801E           8946         10            mov	$10[bp],ax
29507                                           !BCC_EOS
29508                                           ! 4974         CX = 0;
29509                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$24+$12] (used reg = )
29510 8021           31C0                       xor	ax,ax
29511 8023           8946         14            mov	$14[bp],ax
29512                                           !BCC_EOS
29513                                           ! 4975         DX = 0;
29514                                           ! Debug: eq int = const 0 to unsigned short DX = [S+$24+$10] (used reg = )
29515 8026           31C0                       xor	ax,ax
29516 8028           8946         12            mov	$12[bp],ax
29517                                           !BCC_EOS
29518                                           ! 4976         ES = 0;
29519                                           ! Debug: eq int = const 0 to unsigned short ES = [S+$24+4] (used reg = )
29520 802B           31C0                       xor	ax,ax
29521 802D           8946         06            mov	6[bp],ax
29522                                           !BCC_EOS
29523                                           ! 4977         DI = 0;
29524                                           ! Debug: eq int = const 0 to unsigned short DI = [S+$24+6] (used reg = )
29525 8030           31C0                       xor	ax,ax
29526 8032           8946         08            mov	8[bp],ax
29527                                           !BCC_EOS
29528                                           ! 4978         *((Bit8u *)&DX) = (num_floppies);
29529                                           ! Debug: eq unsigned char num_floppies = [S+$24-$1B] to unsigned char DX = [S+$24+$10] (used reg = )
29530 8035           8A46         E7            mov	al,-$19[bp]
29531 8038           8846         12            mov	$12[bp],al
29532                                           !BCC_EOS
29533                                           ! 4979         FLAGS |= 0x0001;
29534                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29535 803B           8B46         1C            mov	ax,$1C[bp]
29536 803E           0C                     01  or	al,*1
29537 8040           8946         1C            mov	$1C[bp],ax
29538                                           !BCC_EOS
29539                                           ! 4980         return;
29540 8043           89EC                       mov	sp,bp
29541 8045           5D                         pop	bp
29542 8046           C3                         ret
29543                                           !BCC_EOS
29544                                           ! 4981       }
29545                                           ! 4982       drive_type = inb_cmos(0x10);
29546                       00008047            .6F0:
29547                                           ! Debug: list int = const $10 (used reg = )
29548 8047           B8                   0010  mov	ax,*$10
29549 804A           50                         push	ax
29550                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
29551 804B           E8         84EF            call	_inb_cmos
29552 804E           44                         inc	sp
29553 804F           44                         inc	sp
29554                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29555 8050           8846         E8            mov	-$18[bp],al
29556                                           !BCC_EOS
29557                                           ! 4983       num_floppies = 0;
29558                                           ! Debug: eq int = const 0 to unsigned char num_floppies = [S+$24-$1B] (used reg = )
29559 8053           30C0                       xor	al,al
29560 8055           8846         E7            mov	-$19[bp],al
29561                                           !BCC_EOS
29562                                           ! 4984       if (drive_type & 0xf0)
29563                                           ! Debug: and int = const $F0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29564 8058           8A46         E8            mov	al,-$18[bp]
29565 805B           24                     F0  and	al,#$F0
29566 805D           84C0                       test	al,al
29567 805F           74           07            je  	.6F2
29568                       00008061            .6F3:
29569                                           ! 4985         num_floppies++;
29570                                           ! Debug: postinc unsigned char num_floppies = [S+$24-$1B] (used reg = )
29571 8061           8A46         E7            mov	al,-$19[bp]
29572 8064           40                         inc	ax
29573 8065           8846         E7            mov	-$19[bp],al
29574                                           !BCC_EOS
29575                                           ! 4986       if (drive_type & 0x0f)
29576                       00008068            .6F2:
29577                                           ! Debug: and int = const $F to unsigned char drive_type = [S+$24-$1A] (used reg = )
29578 8068           8A46         E8            mov	al,-$18[bp]
29579 806B           24                     0F  and	al,*$F
29580 806D           84C0                       test	al,al
29581 806F           74           07            je  	.6F4
29582                       00008071            .6F5:
29583                                           ! 4987         num_floppies++;
29584                                           ! Debug: postinc unsigned char num_floppies = [S+$24-$1B] (used reg = )
29585 8071           8A46         E7            mov	al,-$19[bp]
29586 8074           40                         inc	ax
29587 8075           8846         E7            mov	-$19[bp],al
29588                                           !BCC_EOS
29589                                           ! 4988       if (drive == 0)
29590                       00008078            .6F4:
29591                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$24-3] (used reg = )
29592 8078           8A46         FF            mov	al,-1[bp]
29593 807B           84C0                       test	al,al
29594 807D           75           0E            jne 	.6F6
29595                       0000807F            .6F7:
29596                                           ! 4989         drive_type >>= 4;
29597                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29598 807F           8A46         E8            mov	al,-$18[bp]
29599 8082           30E4                       xor	ah,ah
29600 8084           B1                     04  mov	cl,*4
29601 8086           D3E8                       shr	ax,cl
29602 8088           8846         E8            mov	-$18[bp],al
29603                                           !BCC_EOS
29604                                           ! 4990       else
29605                                           ! 4991         drive_type &= 0x0f;
29606 808B           EB           08            jmp .6F8
29607                       0000808D            .6F6:
29608                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$24-$1A] (used reg = )
29609 808D           8A46         E8            mov	al,-$18[bp]
29610 8090           24                     0F  and	al,*$F
29611 8092           8846         E8            mov	-$18[bp],al
29612                                           !BCC_EOS
29613                                           ! 4992       *(((Bit8u *)&BX)+1) = (0);
29614                       00008095            .6F8:
29615                                           ! Debug: eq int = const 0 to unsigned char BX = [S+$24+$F] (used reg = )
29616 8095           30C0                       xor	al,al
29617 8097           8846         11            mov	$11[bp],al
29618                                           !BCC_EOS
29619                                           ! 4993       *((Bit8u *)&BX) = (drive_type);
29620                                           ! Debug: eq unsigned char drive_type = [S+$24-$1A] to unsigned char BX = [S+$24+$E] (used reg = )
29621 809A           8A46         E8            mov	al,-$18[bp]
29622 809D           8846         10            mov	$10[bp],al
29623                                           !BCC_EOS
29624                                           ! 4994       *(((Bit8u *)&AX)+1) = (0);
29625                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
29626 80A0           30C0                       xor	al,al
29627 80A2           8846         17            mov	$17[bp],al
29628                                           !BCC_EOS
29629                                           ! 4995       *((Bit8u *)&AX) = (0);
29630                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$14] (used reg = )
29631 80A5           30C0                       xor	al,al
29632 80A7           8846         16            mov	$16[bp],al
29633                                           !BCC_EOS
29634                                           ! 4996       *((Bit8u *)&DX) = (num_floppies);
29635                                           ! Debug: eq unsigned char num_floppies = [S+$24-$1B] to unsigned char DX = [S+$24+$10] (used reg = )
29636 80AA           8A46         E7            mov	al,-$19[bp]
29637 80AD           8846         12            mov	$12[bp],al
29638                                           !BCC_EOS
29639                                           ! 4997       switch (drive_type) {
29640 80B0           8A46         E8            mov	al,-$18[bp]
29641 80B3           E9         0087            br 	.6FB
29642                                           ! 4998         case 0:
29643                                           ! 4999           CX = 0;
29644                       000080B6            .6FC:
29645                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$24+$12] (used reg = )
29646 80B6           31C0                       xor	ax,ax
29647 80B8           8946         14            mov	$14[bp],ax
29648                                           !BCC_EOS
29649                                           ! 5000           *(((Bit8u *)&DX)+1) = (0);
29650                                           ! Debug: eq int = const 0 to unsigned char DX = [S+$24+$11] (used reg = )
29651 80BB           30C0                       xor	al,al
29652 80BD           8846         13            mov	$13[bp],al
29653                                           !BCC_EOS
29654                                           ! 5001           break;
29655 80C0           E9         00A1            br 	.6F9
29656                                           !BCC_EOS
29657                                           ! 5002         case 1:
29658                                           ! 5003           CX = 0x2709;
29659                       000080C3            .6FD:
29660                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$24+$12] (used reg = )
29661 80C3           B8                   2709  mov	ax,#$2709
29662 80C6           8946         14            mov	$14[bp],ax
29663                                           !BCC_EOS
29664                                           ! 5004           *(((Bit8u *)&DX)+1) = (1);
29665                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29666 80C9           B0                     01  mov	al,*1
29667 80CB           8846         13            mov	$13[bp],al
29668                                           !BCC_EOS
29669                                           ! 5005           break;
29670 80CE           E9         0093            br 	.6F9
29671                                           !BCC_EOS
29672                                           ! 5006         case 2:
29673                                           ! 5007           CX = 0x4f0f;
29674                       000080D1            .6FE:
29675                                           ! Debug: eq int = const $4F0F to unsigned short CX = [S+$24+$12] (used reg = )
29676 80D1           B8                   4F0F  mov	ax,#$4F0F
29677 80D4           8946         14            mov	$14[bp],ax
29678                                           !BCC_EOS
29679                                           ! 5008           *(((Bit8u *)&DX)+1) = (1);
29680                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29681 80D7           B0                     01  mov	al,*1
29682 80D9           8846         13            mov	$13[bp],al
29683                                           !BCC_EOS
29684                                           ! 5009           break;
29685 80DC           E9         0085            br 	.6F9
29686                                           !BCC_EOS
29687                                           ! 5010         case 3:
29688                                           ! 5011           CX = 0x4f09;
29689                       000080DF            .6FF:
29690                                           ! Debug: eq int = const $4F09 to unsigned short CX = [S+$24+$12] (used reg = )
29691 80DF           B8                   4F09  mov	ax,#$4F09
29692 80E2           8946         14            mov	$14[bp],ax
29693                                           !BCC_EOS
29694                                           ! 5012           *(((Bit8u *)&DX)+1) = (1);
29695                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29696 80E5           B0                     01  mov	al,*1
29697 80E7           8846         13            mov	$13[bp],al
29698                                           !BCC_EOS
29699                                           ! 5013           break;
29700 80EA           EB           78            jmp .6F9
29701                                           !BCC_EOS
29702                                           ! 5014         case 4:
29703                                           ! 5015           CX = 0x4f12;
29704                       000080EC            .700:
29705                                           ! Debug: eq int = const $4F12 to unsigned short CX = [S+$24+$12] (used reg = )
29706 80EC           B8                   4F12  mov	ax,#$4F12
29707 80EF           8946         14            mov	$14[bp],ax
29708                                           !BCC_EOS
29709                                           ! 5016           *(((Bit8u *)&DX)+1) = (1);
29710                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29711 80F2           B0                     01  mov	al,*1
29712 80F4           8846         13            mov	$13[bp],al
29713                                           !BCC_EOS
29714                                           ! 5017           break;
29715 80F7           EB           6B            jmp .6F9
29716                                           !BCC_EOS
29717                                           ! 5018         case 5:
29718                                           ! 5019           CX = 0x4f24;
29719                       000080F9            .701:
29720                                           ! Debug: eq int = const $4F24 to unsigned short CX = [S+$24+$12] (used reg = )
29721 80F9           B8                   4F24  mov	ax,#$4F24
29722 80FC           8946         14            mov	$14[bp],ax
29723                                           !BCC_EOS
29724                                           ! 5020           *(((Bit8u *)&DX)+1) = (1);
29725                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29726 80FF           B0                     01  mov	al,*1
29727 8101           8846         13            mov	$13[bp],al
29728                                           !BCC_EOS
29729                                           ! 5021           break;
29730 8104           EB           5E            jmp .6F9
29731                                           !BCC_EOS
29732                                           ! 5022         case 6:
29733                                           ! 5023           CX = 0x2708;
29734                       00008106            .702:
29735                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$24+$12] (used reg = )
29736 8106           B8                   2708  mov	ax,#$2708
29737 8109           8946         14            mov	$14[bp],ax
29738                                           !BCC_EOS
29739                                           ! 5024           *(((Bit8u *)&DX)+1) = (0);
29740                                           ! Debug: eq int = const 0 to unsigned char DX = [S+$24+$11] (used reg = )
29741 810C           30C0                       xor	al,al
29742 810E           8846         13            mov	$13[bp],al
29743                                           !BCC_EOS
29744                                           ! 5025           break;
29745 8111           EB           51            jmp .6F9
29746                                           !BCC_EOS
29747                                           ! 5026         case 7:
29748                                           ! 5027           CX = 0x2709;
29749                       00008113            .703:
29750                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$24+$12] (used reg = )
29751 8113           B8                   2709  mov	ax,#$2709
29752 8116           8946         14            mov	$14[bp],ax
29753                                           !BCC_EOS
29754                                           ! 5028           *(((Bit8u *)&DX)+1) = (0);
29755                                           ! Debug: eq int = const 0 to unsigned char DX = [S+$24+$11] (used reg = )
29756 8119           30C0                       xor	al,al
29757 811B           8846         13            mov	$13[bp],al
29758                                           !BCC_EOS
29759                                           ! 5029           break;
29760 811E           EB           44            jmp .6F9
29761                                           !BCC_EOS
29762                                           ! 5030         case 8:
29763                                           ! 5031           CX = 0x2708;
29764                       00008120            .704:
29765                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$24+$12] (used reg = )
29766 8120           B8                   2708  mov	ax,#$2708
29767 8123           8946         14            mov	$14[bp],ax
29768                                           !BCC_EOS
29769                                           ! 5032           *(((Bit8u *)&DX)+1) = (1);
29770                                           ! Debug: eq int = const 1 to unsigned char DX = [S+$24+$11] (used reg = )
29771 8126           B0                     01  mov	al,*1
29772 8128           8846         13            mov	$13[bp],al
29773                                           !BCC_EOS
29774                                           ! 5033           break;
29775 812B           EB           37            jmp .6F9
29776                                           !BCC_EOS
29777                                           ! 5034         default:
29778                                           ! 5035           bios_printf((2 | 4 | 1), "floppy: int13: bad floppy type\n");
29779                       0000812D            .705:
29780                                           ! Debug: list * char = .706+0 (used reg = )
29781 812D           BB                   CD72  mov	bx,#.706
29782 8130           53                         push	bx
29783                                           ! Debug: list int = const 7 (used reg = )
29784 8131           B8                   0007  mov	ax,*7
29785 8134           50                         push	ax
29786                                           ! Debug: func () void = bios_printf+0 (used reg = )
29787 8135           E8         8806            call	_bios_printf
29788 8138           83C4                   04  add	sp,*4
29789                                           !BCC_EOS
29790                                           ! 5036         }
29791                                           ! 5037 #asm
29792 813B           EB           27            jmp .6F9
29793                       0000813D            .6FB:
29794 813D           2C                     00  sub	al,*0
29795 813F           72           EC            jb 	.705
29796 8141           3C                     08  cmp	al,*8
29797 8143           77           1D            ja  	.707
29798 8145           30E4                       xor	ah,ah
29799 8147           D1E0                       shl	ax,*1
29800 8149           89C3                       mov	bx,ax
29801 814B           2E                         seg	cs
29802 814C           FFA7       8150            br	.708[bx]
29803                       00008150            .708:
29804 8150                      80B6            .word	.6FC
29805 8152                      80C3            .word	.6FD
29806 8154                      80D1            .word	.6FE
29807 8156                      80DF            .word	.6FF
29808 8158                      80EC            .word	.700
29809 815A                      80F9            .word	.701
29810 815C                      8106            .word	.702
29811 815E                      8113            .word	.703
29812 8160                      8120            .word	.704
29813                       00008162            .707:
29814 8162           EB           C9            jmp	.705
29815                       00008164            .6F9:
29816                                           !BCC_EOS
29817                                           !BCC_ASM
29818                       0000002E            _int13_diskette_function.BP	set	$2E
29819                       0000000C            .int13_diskette_function.BP	set	$C
29820                       0000003C            _int13_diskette_function.CS	set	$3C
29821                       0000001A            .int13_diskette_function.CS	set	$1A
29822                       00000036            _int13_diskette_function.CX	set	$36
29823                       00000014            .int13_diskette_function.CX	set	$14
29824                       0000001A            _int13_diskette_function.base_address	set	$1A
29825                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
29826                       0000002A            _int13_diskette_function.DI	set	$2A
29827                       00000008            .int13_diskette_function.DI	set	8
29828                       0000003E            _int13_diskette_function.FLAGS	set	$3E
29829                       0000001C            .int13_diskette_function.FLAGS	set	$1C
29830                       00000018            _int13_diskette_function.base_count	set	$18
29831                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
29832                       0000001E            _int13_diskette_function.sector	set	$1E
29833                       FFFFFFFC            .int13_diskette_function.sector	set	-4
29834                       00000026            _int13_diskette_function.DS	set	$26
29835                       00000004            .int13_diskette_function.DS	set	4
29836                       0000001D            _int13_diskette_function.head	set	$1D
29837                       FFFFFFFB            .int13_diskette_function.head	set	-5
29838                       00000030            _int13_diskette_function.ELDX	set	$30
29839                       0000000E            .int13_diskette_function.ELDX	set	$E
29840                       00000012            _int13_diskette_function.dor	set	$12
29841                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
29842                       00000034            _int13_diskette_function.DX	set	$34
29843                       00000012            .int13_diskette_function.DX	set	$12
29844                       0000000B            _int13_diskette_function.return_status	set	$B
29845                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
29846                       00000004            _int13_diskette_function.es	set	4
29847                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
29848                       00000014            _int13_diskette_function.mode_register	set	$14
29849                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
29850                       00000028            _int13_diskette_function.ES	set	$28
29851                       00000006            .int13_diskette_function.ES	set	6
29852                       00000016            _int13_diskette_function.base_es	set	$16
29853                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
29854                       0000001F            _int13_diskette_function.track	set	$1F
29855                       FFFFFFFD            .int13_diskette_function.track	set	-3
29856                       0000002C            _int13_diskette_function.SI	set	$2C
29857                       0000000A            .int13_diskette_function.SI	set	$A
29858                       0000000A            _int13_diskette_function.drive_type	set	$A
29859                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
29860                       00000020            _int13_diskette_function.num_sectors	set	$20
29861                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
29862                       0000003A            _int13_diskette_function.IP	set	$3A
29863                       00000018            .int13_diskette_function.IP	set	$18
29864                       00000007            _int13_diskette_function.spt	set	7
29865                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
29866                       0000001C            _int13_diskette_function.status	set	$1C
29867                       FFFFFFFA            .int13_diskette_function.status	set	-6
29868                       00000000            _int13_diskette_function.maxCyl	set	0
29869                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
29870                       00000038            _int13_diskette_function.AX	set	$38
29871                       00000016            .int13_diskette_function.AX	set	$16
29872                       00000013            _int13_diskette_function.val8	set	$13
29873                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
29874                       00000002            _int13_diskette_function.last_addr	set	2
29875                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
29876                       00000015            _int13_diskette_function.page	set	$15
29877                       FFFFFFF3            .int13_diskette_function.page	set	-$D
29878                       00000008            _int13_diskette_function.ah	set	8
29879                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
29880                       00000021            _int13_diskette_function.drive	set	$21
29881                       FFFFFFFF            .int13_diskette_function.drive	set	-1
29882                       00000009            _int13_diskette_function.num_floppies	set	9
29883                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
29884                       00000032            _int13_diskette_function.BX	set	$32
29885                       00000010            .int13_diskette_function.BX	set	$10
29886 8164           55                               push bp
29887 8165           89E5                             mov bp, sp
29888 8167           B8                   EFDE        mov ax, #diskette_param_table2
29889 816A           8946         2C                  mov _int13_diskette_function.DI+2[bp], ax
29890 816D           8C4E         2A                  mov _int13_diskette_function.ES+2[bp], cs
29891 8170           5D                               pop bp
29892                                           ! 5044 endasm
29893                                           !BCC_ENDASM
29894                                           !BCC_EOS
29895                                           ! 5045       FLAGS &= 0xfffe;
29896                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29897 8171           8B46         1C            mov	ax,$1C[bp]
29898 8174           24                     FE  and	al,#$FE
29899 8176           8946         1C            mov	$1C[bp],ax
29900                                           !BCC_EOS
29901                                           ! 5046       return;
29902 8179           89EC                       mov	sp,bp
29903 817B           5D                         pop	bp
29904 817C           C3                         ret
29905                                           !BCC_EOS
29906                                           ! 5047     case 0x15:
29907                                           ! 5048 ;
29908                       0000817D            .709:
29909                                           !BCC_EOS
29910                                           ! 5049       drive = ( ELDX & 0x00ff );
29911                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
29912 817D           8A46         0E            mov	al,$E[bp]
29913                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
29914 8180           8846         FF            mov	-1[bp],al
29915                                           !BCC_EOS
29916                                           ! 5050       if (drive > 1) {
29917                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
29918 8183           8A46         FF            mov	al,-1[bp]
29919 8186           3C                     01  cmp	al,*1
29920 8188           76           11            jbe 	.70A
29921                       0000818A            .70B:
29922                                           ! 5051         *(((Bit8u *)&AX)+1) = (0);
29923                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
29924 818A           30C0                       xor	al,al
29925 818C           8846         17            mov	$17[bp],al
29926                                           !BCC_EOS
29927                                           ! 5052         FLAGS |= 0x0001;
29928                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29929 818F           8B46         1C            mov	ax,$1C[bp]
29930 8192           0C                     01  or	al,*1
29931 8194           8946         1C            mov	$1C[bp],ax
29932                                           !BCC_EOS
29933                                           ! 5053         return;
29934 8197           89EC                       mov	sp,bp
29935 8199           5D                         pop	bp
29936 819A           C3                         ret
29937                                           !BCC_EOS
29938                                           ! 5054       }
29939                                           ! 5055       drive_type = inb_cmos(0x10);
29940                       0000819B            .70A:
29941                                           ! Debug: list int = const $10 (used reg = )
29942 819B           B8                   0010  mov	ax,*$10
29943 819E           50                         push	ax
29944                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
29945 819F           E8         839B            call	_inb_cmos
29946 81A2           44                         inc	sp
29947 81A3           44                         inc	sp
29948                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29949 81A4           8846         E8            mov	-$18[bp],al
29950                                           !BCC_EOS
29951                                           ! 5056       if (drive == 0)
29952                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$24-3] (used reg = )
29953 81A7           8A46         FF            mov	al,-1[bp]
29954 81AA           84C0                       test	al,al
29955 81AC           75           0E            jne 	.70C
29956                       000081AE            .70D:
29957                                           ! 5057         drive_type >>= 4;
29958                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29959 81AE           8A46         E8            mov	al,-$18[bp]
29960 81B1           30E4                       xor	ah,ah
29961 81B3           B1                     04  mov	cl,*4
29962 81B5           D3E8                       shr	ax,cl
29963 81B7           8846         E8            mov	-$18[bp],al
29964                                           !BCC_EOS
29965                                           ! 5058       else
29966                                           ! 5059         drive_type &= 0x0f;
29967 81BA           EB           08            jmp .70E
29968                       000081BC            .70C:
29969                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$24-$1A] (used reg = )
29970 81BC           8A46         E8            mov	al,-$18[bp]
29971 81BF           24                     0F  and	al,*$F
29972 81C1           8846         E8            mov	-$18[bp],al
29973                                           !BCC_EOS
29974                                           ! 5060       FLAGS &= 0xfffe;
29975                       000081C4            .70E:
29976                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
29977 81C4           8B46         1C            mov	ax,$1C[bp]
29978 81C7           24                     FE  and	al,#$FE
29979 81C9           8946         1C            mov	$1C[bp],ax
29980                                           !BCC_EOS
29981                                           ! 5061       if (drive_type==0) {
29982                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
29983 81CC           8A46         E8            mov	al,-$18[bp]
29984 81CF           84C0                       test	al,al
29985 81D1           75           07            jne 	.70F
29986                       000081D3            .710:
29987                                           ! 5062         *(((Bit8u *)&AX)+1) = (0);
29988                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
29989 81D3           30C0                       xor	al,al
29990 81D5           8846         17            mov	$17[bp],al
29991                                           !BCC_EOS
29992                                           ! 5063       }
29993                                           ! 5064       else {
29994 81D8           EB           05            jmp .711
29995                       000081DA            .70F:
29996                                           ! 5065         *(((Bit8u *)&AX)+1) = (1);
29997                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
29998 81DA           B0                     01  mov	al,*1
29999 81DC           8846         17            mov	$17[bp],al
30000                                           !BCC_EOS
30001                                           ! 5066       }
30002                                           ! 5067       return;
30003                       000081DF            .711:
30004 81DF           89EC                       mov	sp,bp
30005 81E1           5D                         pop	bp
30006 81E2           C3                         ret
30007                                           !BCC_EOS
30008                                           ! 5068     case 0x16:
30009                                           ! 5069 ;
30010                       000081E3            .712:
30011                                           !BCC_EOS
30012                                           ! 5070       drive = ( ELDX & 0x00ff );
30013                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
30014 81E3           8A46         0E            mov	al,$E[bp]
30015                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
30016 81E6           8846         FF            mov	-1[bp],al
30017                                           !BCC_EOS
30018                                           ! 5071       if (drive > 1) {
30019                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
30020 81E9           8A46         FF            mov	al,-1[bp]
30021 81EC           3C                     01  cmp	al,*1
30022 81EE           76           1A            jbe 	.713
30023                       000081F0            .714:
30024                                           ! 5072         *(((Bit8u *)&AX)+1) = (0x01);
30025                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
30026 81F0           B0                     01  mov	al,*1
30027 81F2           8846         17            mov	$17[bp],al
30028                                           !BCC_EOS
30029                                           ! 5073         set_diskette_ret_status(0x01);
30030                                           ! Debug: list int = const 1 (used reg = )
30031 81F5           B8                   0001  mov	ax,*1
30032 81F8           50                         push	ax
30033                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30034 81F9           E8         0433            call	_set_diskette_ret_status
30035 81FC           44                         inc	sp
30036 81FD           44                         inc	sp
30037                                           !BCC_EOS
30038                                           ! 5074         FLAGS |= 0x0001;
30039                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30040 81FE           8B46         1C            mov	ax,$1C[bp]
30041 8201           0C                     01  or	al,*1
30042 8203           8946         1C            mov	$1C[bp],ax
30043                                           !BCC_EOS
30044                                           ! 5075         return;
30045 8206           89EC                       mov	sp,bp
30046 8208           5D                         pop	bp
30047 8209           C3                         ret
30048                                           !BCC_EOS
30049                                           ! 5076       }
30050                                           ! 5077       *(((Bit8u *)&AX)+1) = (0x06);
30051                       0000820A            .713:
30052                                           ! Debug: eq int = const 6 to unsigned char AX = [S+$24+$15] (used reg = )
30053 820A           B0                     06  mov	al,*6
30054 820C           8846         17            mov	$17[bp],al
30055                                           !BCC_EOS
30056                                           ! 5078       set_diskette_ret_status(0x06);
30057                                           ! Debug: list int = const 6 (used reg = )
30058 820F           B8                   0006  mov	ax,*6
30059 8212           50                         push	ax
30060                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30061 8213           E8         0419            call	_set_diskette_ret_status
30062 8216           44                         inc	sp
30063 8217           44                         inc	sp
30064                                           !BCC_EOS
30065                                           ! 5079       FLAGS |= 0x0001;
30066                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30067 8218           8B46         1C            mov	ax,$1C[bp]
30068 821B           0C                     01  or	al,*1
30069 821D           8946         1C            mov	$1C[bp],ax
30070                                           !BCC_EOS
30071                                           ! 5080       return;
30072 8220           89EC                       mov	sp,bp
30073 8222           5D                         pop	bp
30074 8223           C3                         ret
30075                                           !BCC_EOS
30076                                           ! 5081     case 0x17:
30077                                           ! 5082 ;
30078                       00008224            .715:
30079                                           !BCC_EOS
30080                                           ! 5083       drive = ( ELDX & 0x00ff );
30081                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
30082 8224           8A46         0E            mov	al,$E[bp]
30083                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
30084 8227           8846         FF            mov	-1[bp],al
30085                                           !BCC_EOS
30086                                           ! 5084       drive_type = ( AX & 0x00ff );
30087                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
30088 822A           8A46         16            mov	al,$16[bp]
30089                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
30090 822D           8846         E8            mov	-$18[bp],al
30091                                           !BCC_EOS
30092                                           ! 5085       if (drive > 1) {
30093                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
30094 8230           8A46         FF            mov	al,-1[bp]
30095 8233           3C                     01  cmp	al,*1
30096 8235           76           1A            jbe 	.716
30097                       00008237            .717:
30098                                           ! 5086         *(((Bit8u *)&AX)+1) = (0x01);
30099                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
30100 8237           B0                     01  mov	al,*1
30101 8239           8846         17            mov	$17[bp],al
30102                                           !BCC_EOS
30103                                           ! 5087         set_diskette_ret_status(1);
30104                                           ! Debug: list int = const 1 (used reg = )
30105 823C           B8                   0001  mov	ax,*1
30106 823F           50                         push	ax
30107                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30108 8240           E8         03EC            call	_set_diskette_ret_status
30109 8243           44                         inc	sp
30110 8244           44                         inc	sp
30111                                           !BCC_EOS
30112                                           ! 5088         FLAGS |= 0x0001;
30113                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30114 8245           8B46         1C            mov	ax,$1C[bp]
30115 8248           0C                     01  or	al,*1
30116 824A           8946         1C            mov	$1C[bp],ax
30117                                           !BCC_EOS
30118                                           ! 5089         return;
30119 824D           89EC                       mov	sp,bp
30120 824F           5D                         pop	bp
30121 8250           C3                         ret
30122                                           !BCC_EOS
30123                                           ! 5090       }
30124                                           ! 5091       if (floppy_drive_exists(drive) == 0) {
30125                       00008251            .716:
30126                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
30127 8251           8A46         FF            mov	al,-1[bp]
30128 8254           30E4                       xor	ah,ah
30129 8256           50                         push	ax
30130                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
30131 8257           E8         F4DC            call	_floppy_drive_exists
30132 825A           44                         inc	sp
30133 825B           44                         inc	sp
30134                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
30135 825C           85C0                       test	ax,ax
30136 825E           75           1A            jne 	.718
30137                       00008260            .719:
30138                                           ! 5092         *(((Bit8u *)&AX)+1) = (0x80);
30139                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
30140 8260           B0                     80  mov	al,#$80
30141 8262           8846         17            mov	$17[bp],al
30142                                           !BCC_EOS
30143                                           ! 5093         set_diskette_ret_status(0x80);
30144                                           ! Debug: list int = const $80 (used reg = )
30145 8265           B8                   0080  mov	ax,#$80
30146 8268           50                         push	ax
30147                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30148 8269           E8         03C3            call	_set_diskette_ret_status
30149 826C           44                         inc	sp
30150 826D           44                         inc	sp
30151                                           !BCC_EOS
30152                                           ! 5094         FLAGS |= 0x0001;
30153                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30154 826E           8B46         1C            mov	ax,$1C[bp]
30155 8271           0C                     01  or	al,*1
30156 8273           8946         1C            mov	$1C[bp],ax
30157                                           !BCC_EOS
30158                                           ! 5095         return;
30159 8276           89EC                       mov	sp,bp
30160 8278           5D                         pop	bp
30161 8279           C3                         ret
30162                                           !BCC_EOS
30163                                           ! 5096       }
30164                                           ! 5097       base_address = (drive) ? 0x0091 : 0x0090;
30165                       0000827A            .718:
30166 827A           8A46         FF            mov	al,-1[bp]
30167 827D           84C0                       test	al,al
30168 827F           74           04            je  	.71A
30169                       00008281            .71B:
30170 8281           B0                     91  mov	al,#$91
30171 8283           EB           02            jmp .71C
30172                       00008285            .71A:
30173 8285           B0                     90  mov	al,#$90
30174                       00008287            .71C:
30175                                           ! Debug: eq char = al+0 to unsigned short base_address = [S+$24-$A] (used reg = )
30176 8287           30E4                       xor	ah,ah
30177 8289           8946         F8            mov	-8[bp],ax
30178                                           !BCC_EOS
30179                                           ! 5098       status = *((Bit8u *)(base_address));
30180 828C           8B5E         F8            mov	bx,-8[bp]
30181                                           ! Debug: eq unsigned char = [bx+0] to unsigned char status = [S+$24-8] (used reg = )
30182 828F           8A07                       mov	al,[bx]
30183 8291           8846         FA            mov	-6[bp],al
30184                                           !BCC_EOS
30185                                           ! 5099       val8 = status & 0x0f;
30186                                           ! Debug: and int = const $F to unsigned char status = [S+$24-8] (used reg = )
30187 8294           8A46         FA            mov	al,-6[bp]
30188 8297           24                     0F  and	al,*$F
30189                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
30190 8299           8846         F1            mov	-$F[bp],al
30191                                           !BCC_EOS
30192                                           ! 5100       switch(drive_type) {
30193 829C           8A46         E8            mov	al,-$18[bp]
30194 829F           EB           6A            jmp .71F
30195                                           ! 5101         case 1:
30196                                           ! 5102           val8 |= 0x90;
30197                       000082A1            .720:
30198                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30199 82A1           8A46         F1            mov	al,-$F[bp]
30200 82A4           0C                     90  or	al,#$90
30201 82A6           8846         F1            mov	-$F[bp],al
30202                                           !BCC_EOS
30203                                           ! 5103           break;
30204 82A9           EB           72            jmp .71D
30205                                           !BCC_EOS
30206                                           ! 5104         case 2:
30207                                           ! 5105           val8 |= 0x70;
30208                       000082AB            .721:
30209                                           ! Debug: orab int = const $70 to unsigned char val8 = [S+$24-$11] (used reg = )
30210 82AB           8A46         F1            mov	al,-$F[bp]
30211 82AE           0C                     70  or	al,*$70
30212 82B0           8846         F1            mov	-$F[bp],al
30213                                           !BCC_EOS
30214                                           ! 5106           break;
30215 82B3           EB           68            jmp .71D
30216                                           !BCC_EOS
30217                                           ! 5107         case 3:
30218                                           ! 5108           val8 |= 0x10;
30219                       000082B5            .722:
30220                                           ! Debug: orab int = const $10 to unsigned char val8 = [S+$24-$11] (used reg = )
30221 82B5           8A46         F1            mov	al,-$F[bp]
30222 82B8           0C                     10  or	al,*$10
30223 82BA           8846         F1            mov	-$F[bp],al
30224                                           !BCC_EOS
30225                                           ! 5109           break;
30226 82BD           EB           5E            jmp .71D
30227                                           !BCC_EOS
30228                                           ! 5110         case 4:
30229                                           ! 5111           if (((status >> 4) & 0x01) && ((status >> 1) & 0x01))
30230                       000082BF            .723:
30231                                           ! Debug: sr int = const 4 to unsigned char status = [S+$24-8] (used reg = )
30232 82BF           8A46         FA            mov	al,-6[bp]
30233 82C2           30E4                       xor	ah,ah
30234 82C4           B1                     04  mov	cl,*4
30235 82C6           D3E8                       shr	ax,cl
30236                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
30237 82C8           24                     01  and	al,*1
30238 82CA           84C0                       test	al,al
30239 82CC           74           17            je  	.724
30240                       000082CE            .726:
30241                                           ! Debug: sr int = const 1 to unsigned char status = [S+$24-8] (used reg = )
30242 82CE           8A46         FA            mov	al,-6[bp]
30243 82D1           30E4                       xor	ah,ah
30244 82D3           D1E8                       shr	ax,*1
30245                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
30246 82D5           24                     01  and	al,*1
30247 82D7           84C0                       test	al,al
30248 82D9           74           0A            je  	.724
30249                       000082DB            .725:
30250                                           ! 5112           {
30251                                           ! 5113             val8 |= 0x50;
30252                                           ! Debug: orab int = const $50 to unsigned char val8 = [S+$24-$11] (used reg = )
30253 82DB           8A46         F1            mov	al,-$F[bp]
30254 82DE           0C                     50  or	al,*$50
30255 82E0           8846         F1            mov	-$F[bp],al
30256                                           !BCC_EOS
30257                                           ! 5114           }
30258                                           ! 5115           else
30259                                           ! 5116           {
30260 82E3           EB           08            jmp .727
30261                       000082E5            .724:
30262                                           ! 5117             val8 |= 0x90;
30263                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30264 82E5           8A46         F1            mov	al,-$F[bp]
30265 82E8           0C                     90  or	al,#$90
30266 82EA           8846         F1            mov	-$F[bp],al
30267                                           !BCC_EOS
30268                                           ! 5118           }
30269                                           ! 5119           break;
30270                       000082ED            .727:
30271 82ED           EB           2E            jmp .71D
30272                                           !BCC_EOS
30273                                           ! 5120         default:
30274                                           ! 5121           *(((Bit8u *)&AX)+1) = (0x01);
30275                       000082EF            .728:
30276                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
30277 82EF           B0                     01  mov	al,*1
30278 82F1           8846         17            mov	$17[bp],al
30279                                           !BCC_EOS
30280                                           ! 5122           set_diskette_ret_status(1);
30281                                           ! Debug: list int = const 1 (used reg = )
30282 82F4           B8                   0001  mov	ax,*1
30283 82F7           50                         push	ax
30284                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30285 82F8           E8         0334            call	_set_diskette_ret_status
30286 82FB           44                         inc	sp
30287 82FC           44                         inc	sp
30288                                           !BCC_EOS
30289                                           ! 5123           FLAGS |= 0x0001;
30290                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30291 82FD           8B46         1C            mov	ax,$1C[bp]
30292 8300           0C                     01  or	al,*1
30293 8302           8946         1C            mov	$1C[bp],ax
30294                                           !BCC_EOS
30295                                           ! 5124           return;
30296 8305           89EC                       mov	sp,bp
30297 8307           5D                         pop	bp
30298 8308           C3                         ret
30299                                           !BCC_EOS
30300                                           ! 5125    
30301                                           ! 5125    }
30302                                           ! 5126 ;
30303 8309           EB           12            jmp .71D
30304                       0000830B            .71F:
30305 830B           2C                     01  sub	al,*1
30306 830D           74           92            je 	.720
30307 830F           2C                     01  sub	al,*1
30308 8311           74           98            je 	.721
30309 8313           2C                     01  sub	al,*1
30310 8315           74           9E            je 	.722
30311 8317           2C                     01  sub	al,*1
30312 8319           74           A4            je 	.723
30313 831B           EB           D2            jmp	.728
30314                       0000831D            .71D:
30315                                           !BCC_EOS
30316                                           ! 5127       *((Bit8u *)(base_address)) = (val8);
30317 831D           8B5E         F8            mov	bx,-8[bp]
30318                                           ! Debug: eq unsigned char val8 = [S+$24-$11] to unsigned char = [bx+0] (used reg = )
30319 8320           8A46         F1            mov	al,-$F[bp]
30320 8323           8807                       mov	[bx],al
30321                                           !BCC_EOS
30322                                           ! 5128       *(((Bit8u *)&AX)+1) = (0);
30323                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30324 8325           30C0                       xor	al,al
30325 8327           8846         17            mov	$17[bp],al
30326                                           !BCC_EOS
30327                                           ! 5129       set_diskette_ret_status(0);
30328                                           ! Debug: list int = const 0 (used reg = )
30329 832A           31C0                       xor	ax,ax
30330 832C           50                         push	ax
30331                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30332 832D           E8         02FF            call	_set_diskette_ret_status
30333 8330           44                         inc	sp
30334 8331           44                         inc	sp
30335                                           !BCC_EOS
30336                                           ! 5130       FLAGS &= 0xfffe;
30337                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30338 8332           8B46         1C            mov	ax,$1C[bp]
30339 8335           24                     FE  and	al,#$FE
30340 8337           8946         1C            mov	$1C[bp],ax
30341                                           !BCC_EOS
30342                                           ! 5131       return;
30343 833A           89EC                       mov	sp,bp
30344 833C           5D                         pop	bp
30345 833D           C3                         ret
30346                                           !BCC_EOS
30347                                           ! 5132     case 0x18:
30348                                           ! 5133 ;
30349                       0000833E            .729:
30350                                           !BCC_EOS
30351                                           ! 5134       drive = ( ELDX & 0x00ff );
30352                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
30353 833E           8A46         0E            mov	al,$E[bp]
30354                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$24-3] (used reg = )
30355 8341           8846         FF            mov	-1[bp],al
30356                                           !BCC_EOS
30357                                           ! 5135       val8 = ( CX & 0x00ff );
30358                                           ! Debug: and int = const $FF to unsigned short CX = [S+$24+$12] (used reg = )
30359 8344           8A46         14            mov	al,$14[bp]
30360                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
30361 8347           8846         F1            mov	-$F[bp],al
30362                                           !BCC_EOS
30363                                           ! 5136       spt = val8 & 0x3f;
30364                                           ! Debug: and int = const $3F to unsigned char val8 = [S+$24-$11] (used reg = )
30365 834A           8A46         F1            mov	al,-$F[bp]
30366 834D           24                     3F  and	al,*$3F
30367                                           ! Debug: eq unsigned char = al+0 to unsigned char spt = [S+$24-$1D] (used reg = )
30368 834F           8846         E5            mov	-$1B[bp],al
30369                                           !BCC_EOS
30370                                           ! 5137       maxCyl = ((val8 >> 6) << 8) + *(((Bit8u *)&CX)+1);
30371                                           ! Debug: sr int = const 6 to unsigned char val8 = [S+$24-$11] (used reg = )
30372 8352           8A46         F1            mov	al,-$F[bp]
30373 8355           30E4                       xor	ah,ah
30374 8357           B1                     06  mov	cl,*6
30375 8359           D3E8                       shr	ax,cl
30376                                           ! Debug: sl int = const 8 to unsigned int = ax+0 (used reg = )
30377 835B           88C4                       mov	ah,al
30378 835D           30C0                       xor	al,al
30379                                           ! Debug: add unsigned char CX = [S+$24+$13] to unsigned int = ax+0 (used reg = )
30380 835F           0246         15            add	al,$15[bp]
30381 8362           80D4                   00  adc	ah,*0
30382                                           ! Debug: eq unsigned int = ax+0 to unsigned short maxCyl = [S+$24-$24] (used reg = )
30383 8365           8946         DE            mov	-$22[bp],ax
30384                                           !BCC_EOS
30385                                           ! 5138 ;
30386                                           !BCC_EOS
30387                                           ! 5139       if (drive > 1) {
30388                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$24-3] (used reg = )
30389 8368           8A46         FF            mov	al,-1[bp]
30390 836B           3C                     01  cmp	al,*1
30391 836D           76           1A            jbe 	.72A
30392                       0000836F            .72B:
30393                                           ! 5140         *(((Bit8u *)&AX)+1) = (0x01);
30394                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
30395 836F           B0                     01  mov	al,*1
30396 8371           8846         17            mov	$17[bp],al
30397                                           !BCC_EOS
30398                                           ! 5141         set_diskette_ret_status(1);
30399                                           ! Debug: list int = const 1 (used reg = )
30400 8374           B8                   0001  mov	ax,*1
30401 8377           50                         push	ax
30402                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30403 8378           E8         02B4            call	_set_diskette_ret_status
30404 837B           44                         inc	sp
30405 837C           44                         inc	sp
30406                                           !BCC_EOS
30407                                           ! 5142         FLAGS |= 0x0001;
30408                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30409 837D           8B46         1C            mov	ax,$1C[bp]
30410 8380           0C                     01  or	al,*1
30411 8382           8946         1C            mov	$1C[bp],ax
30412                                           !BCC_EOS
30413                                           ! 5143         return;
30414 8385           89EC                       mov	sp,bp
30415 8387           5D                         pop	bp
30416 8388           C3                         ret
30417                                           !BCC_EOS
30418                                           ! 5144       }
30419                                           ! 5145       if (floppy_drive_exists(drive) == 0) {
30420                       00008389            .72A:
30421                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
30422 8389           8A46         FF            mov	al,-1[bp]
30423 838C           30E4                       xor	ah,ah
30424 838E           50                         push	ax
30425                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
30426 838F           E8         F3A4            call	_floppy_drive_exists
30427 8392           44                         inc	sp
30428 8393           44                         inc	sp
30429                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
30430 8394           85C0                       test	ax,ax
30431 8396           75           1A            jne 	.72C
30432                       00008398            .72D:
30433                                           ! 5146         *(((Bit8u *)&AX)+1) = (0x80);
30434                                           ! Debug: eq int = const $80 to unsigned char AX = [S+$24+$15] (used reg = )
30435 8398           B0                     80  mov	al,#$80
30436 839A           8846         17            mov	$17[bp],al
30437                                           !BCC_EOS
30438                                           ! 5147         set_diskette_ret_status(0x80);
30439                                           ! Debug: list int = const $80 (used reg = )
30440 839D           B8                   0080  mov	ax,#$80
30441 83A0           50                         push	ax
30442                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30443 83A1           E8         028B            call	_set_diskette_ret_status
30444 83A4           44                         inc	sp
30445 83A5           44                         inc	sp
30446                                           !BCC_EOS
30447                                           ! 5148         FLAGS |= 0x0001;
30448                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30449 83A6           8B46         1C            mov	ax,$1C[bp]
30450 83A9           0C                     01  or	al,*1
30451 83AB           8946         1C            mov	$1C[bp],ax
30452                                           !BCC_EOS
30453                                           ! 5149         return;
30454 83AE           89EC                       mov	sp,bp
30455 83B0           5D                         pop	bp
30456 83B1           C3                         ret
30457                                           !BCC_EOS
30458                                           ! 5150       }
30459                                           ! 5151       if (floppy_media_known(drive) == 0) {
30460                       000083B2            .72C:
30461                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
30462 83B2           8A46         FF            mov	al,-1[bp]
30463 83B5           30E4                       xor	ah,ah
30464 83B7           50                         push	ax
30465                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
30466 83B8           E8         F195            call	_floppy_media_known
30467 83BB           44                         inc	sp
30468 83BC           44                         inc	sp
30469                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
30470 83BD           85C0                       test	ax,ax
30471 83BF           75           29            jne 	.72E
30472                       000083C1            .72F:
30473                                           ! 5152         if (floppy_media_sense(drive) == 0) {
30474                                           ! Debug: list unsigned char drive = [S+$24-3] (used reg = )
30475 83C1           8A46         FF            mov	al,-1[bp]
30476 83C4           30E4                       xor	ah,ah
30477 83C6           50                         push	ax
30478                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
30479 83C7           E8         F1F6            call	_floppy_media_sense
30480 83CA           44                         inc	sp
30481 83CB           44                         inc	sp
30482                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
30483 83CC           85C0                       test	ax,ax
30484 83CE           75           1A            jne 	.730
30485                       000083D0            .731:
30486                                           ! 5153           *(((Bit8u *)&AX)+1) = (0x0C);
30487                                           ! Debug: eq int = const $C to unsigned char AX = [S+$24+$15] (used reg = )
30488 83D0           B0                     0C  mov	al,*$C
30489 83D2           8846         17            mov	$17[bp],al
30490                                           !BCC_EOS
30491                                           ! 5154           set_diskette_ret_status(0x0C);
30492                                           ! Debug: list int = const $C (used reg = )
30493 83D5           B8                   000C  mov	ax,*$C
30494 83D8           50                         push	ax
30495                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30496 83D9           E8         0253            call	_set_diskette_ret_status
30497 83DC           44                         inc	sp
30498 83DD           44                         inc	sp
30499                                           !BCC_EOS
30500                                           ! 5155           FLAGS |= 0x0001;
30501                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30502 83DE           8B46         1C            mov	ax,$1C[bp]
30503 83E1           0C                     01  or	al,*1
30504 83E3           8946         1C            mov	$1C[bp],ax
30505                                           !BCC_EOS
30506                                           ! 5156           return;
30507 83E6           89EC                       mov	sp,bp
30508 83E8           5D                         pop	bp
30509 83E9           C3                         ret
30510                                           !BCC_EOS
30511                                           ! 5157         }
30512                                           ! 5158       }
30513                       000083EA            .730:
30514                                           ! 5159       drive_type = inb_cmos(0x10);
30515                       000083EA            .72E:
30516                                           ! Debug: list int = const $10 (used reg = )
30517 83EA           B8                   0010  mov	ax,*$10
30518 83ED           50                         push	ax
30519                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
30520 83EE           E8         814C            call	_inb_cmos
30521 83F1           44                         inc	sp
30522 83F2           44                         inc	sp
30523                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$24-$1A] (used reg = )
30524 83F3           8846         E8            mov	-$18[bp],al
30525                                           !BCC_EOS
30526                                           ! 5160       if (drive == 0)
30527                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$24-3] (used reg = )
30528 83F6           8A46         FF            mov	al,-1[bp]
30529 83F9           84C0                       test	al,al
30530 83FB           75           0E            jne 	.732
30531                       000083FD            .733:
30532                                           ! 5161         drive_type >>= 4;
30533                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$24-$1A] (used reg = )
30534 83FD           8A46         E8            mov	al,-$18[bp]
30535 8400           30E4                       xor	ah,ah
30536 8402           B1                     04  mov	cl,*4
30537 8404           D3E8                       shr	ax,cl
30538 8406           8846         E8            mov	-$18[bp],al
30539                                           !BCC_EOS
30540                                           ! 5162       else
30541                                           ! 5163         drive_type &= 0x0f;
30542 8409           EB           08            jmp .734
30543                       0000840B            .732:
30544                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$24-$1A] (used reg = )
30545 840B           8A46         E8            mov	al,-$18[bp]
30546 840E           24                     0F  and	al,*$F
30547 8410           8846         E8            mov	-$18[bp],al
30548                                           !BCC_EOS
30549                                           ! 5164       base_address = (drive) ? 0x0091 : 0x0090;
30550                       00008413            .734:
30551 8413           8A46         FF            mov	al,-1[bp]
30552 8416           84C0                       test	al,al
30553 8418           74           04            je  	.735
30554                       0000841A            .736:
30555 841A           B0                     91  mov	al,#$91
30556 841C           EB           02            jmp .737
30557                       0000841E            .735:
30558 841E           B0                     90  mov	al,#$90
30559                       00008420            .737:
30560                                           ! Debug: eq char = al+0 to unsigned short base_address = [S+$24-$A] (used reg = )
30561 8420           30E4                       xor	ah,ah
30562 8422           8946         F8            mov	-8[bp],ax
30563                                           !BCC_EOS
30564                                           ! 5165       status = *((Bit8u *)(base_address));
30565 8425           8B5E         F8            mov	bx,-8[bp]
30566                                           ! Debug: eq unsigned char = [bx+0] to unsigned char status = [S+$24-8] (used reg = )
30567 8428           8A07                       mov	al,[bx]
30568 842A           8846         FA            mov	-6[bp],al
30569                                           !BCC_EOS
30570                                           ! 5166       val8 = status & 0x0f;
30571                                           ! Debug: and int = const $F to unsigned char status = [S+$24-8] (used reg = )
30572 842D           8A46         FA            mov	al,-6[bp]
30573 8430           24                     0F  and	al,*$F
30574                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$24-$11] (used reg = )
30575 8432           8846         F1            mov	-$F[bp],al
30576                                           !BCC_EOS
30577                                           ! 5167       *(((Bit8u *)&AX)+1) = (0x0C);
30578                                           ! Debug: eq int = const $C to unsigned char AX = [S+$24+$15] (used reg = )
30579 8435           B0                     0C  mov	al,*$C
30580 8437           8846         17            mov	$17[bp],al
30581                                           !BCC_EOS
30582                                           ! 5168       switch (drive_type) {
30583 843A           8A46         E8            mov	al,-$18[bp]
30584 843D           E9         010E            br 	.73A
30585                                           ! 5169         case 0:
30586                                           ! 5170           break;
30587                       00008440            .73B:
30588 8440           E9         0132            br 	.738
30589                                           !BCC_EOS
30590                                           ! 5171         case 1:
30591                                           ! 5172         case 6:
30592                       00008443            .73C:
30593                                           ! 5173         case 7:
30594                       00008443            .73D:
30595                                           ! 5174         case 8:
30596                       00008443            .73E:
30597                                           ! 5175           if (maxCyl == 39 && (spt == 8 || spt == 9))
30598                       00008443            .73F:
30599                                           ! Debug: logeq int = const $27 to unsigned short maxCyl = [S+$24-$24] (used reg = )
30600 8443           8B46         DE            mov	ax,-$22[bp]
30601 8446           3D                   0027  cmp	ax,*$27
30602 8449           75           1B            jne 	.740
30603                       0000844B            .742:
30604                                           ! Debug: logeq int = const 8 to unsigned char spt = [S+$24-$1D] (used reg = )
30605 844B           8A46         E5            mov	al,-$1B[bp]
30606 844E           3C                     08  cmp	al,*8
30607 8450           74           07            je  	.741
30608                       00008452            .743:
30609                                           ! Debug: logeq int = const 9 to unsigned char spt = [S+$24-$1D] (used reg = )
30610 8452           8A46         E5            mov	al,-$1B[bp]
30611 8455           3C                     09  cmp	al,*9
30612 8457           75           0D            jne 	.740
30613                       00008459            .741:
30614                                           ! 5176           {
30615                                           ! 5177             val8 |= 0x90;
30616                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30617 8459           8A46         F1            mov	al,-$F[bp]
30618 845C           0C                     90  or	al,#$90
30619 845E           8846         F1            mov	-$F[bp],al
30620                                           !BCC_EOS
30621                                           ! 5178             *(((Bit8u *)&AX)+1) = (0);
30622                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30623 8461           30C0                       xor	al,al
30624 8463           8846         17            mov	$17[bp],al
30625                                           !BCC_EOS
30626                                           ! 5179           }
30627                                           ! 5180           break;
30628                       00008466            .740:
30629 8466           E9         010C            br 	.738
30630                                           !BCC_EOS
30631                                           ! 5181         case 2:
30632                                           ! 5182           if (maxCyl == 39 && (spt == 8 || spt == 9))
30633                       00008469            .744:
30634                                           ! Debug: logeq int = const $27 to unsigned short maxCyl = [S+$24-$24] (used reg = )
30635 8469           8B46         DE            mov	ax,-$22[bp]
30636 846C           3D                   0027  cmp	ax,*$27
30637 846F           75           1D            jne 	.745
30638                       00008471            .747:
30639                                           ! Debug: logeq int = const 8 to unsigned char spt = [S+$24-$1D] (used reg = )
30640 8471           8A46         E5            mov	al,-$1B[bp]
30641 8474           3C                     08  cmp	al,*8
30642 8476           74           07            je  	.746
30643                       00008478            .748:
30644                                           ! Debug: logeq int = const 9 to unsigned char spt = [S+$24-$1D] (used reg = )
30645 8478           8A46         E5            mov	al,-$1B[bp]
30646 847B           3C                     09  cmp	al,*9
30647 847D           75           0F            jne 	.745
30648                       0000847F            .746:
30649                                           ! 5183           {
30650                                           ! 5184             val8 |= 0x70;
30651                                           ! Debug: orab int = const $70 to unsigned char val8 = [S+$24-$11] (used reg = )
30652 847F           8A46         F1            mov	al,-$F[bp]
30653 8482           0C                     70  or	al,*$70
30654 8484           8846         F1            mov	-$F[bp],al
30655                                           !BCC_EOS
30656                                           ! 5185             *(((Bit8u *)&AX)+1) = (0);
30657                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30658 8487           30C0                       xor	al,al
30659 8489           8846         17            mov	$17[bp],al
30660                                           !BCC_EOS
30661                                           ! 5186           }
30662                                           ! 5187           else if (maxCyl == 79 && spt == 15)
30663 848C           EB           1C            jmp .749
30664                       0000848E            .745:
30665                                           ! Debug: logeq int = const $4F to unsigned short maxCyl = [S+$24-$24] (used reg = )
30666 848E           8B46         DE            mov	ax,-$22[bp]
30667 8491           3D                   004F  cmp	ax,*$4F
30668 8494           75           14            jne 	.74A
30669                       00008496            .74C:
30670                                           ! Debug: logeq int = const $F to unsigned char spt = [S+$24-$1D] (used reg = )
30671 8496           8A46         E5            mov	al,-$1B[bp]
30672 8499           3C                     0F  cmp	al,*$F
30673 849B           75           0D            jne 	.74A
30674                       0000849D            .74B:
30675                                           ! 5188           {
30676                                           ! 5189             val8 |= 0x10;
30677                                           ! Debug: orab int = const $10 to unsigned char val8 = [S+$24-$11] (used reg = )
30678 849D           8A46         F1            mov	al,-$F[bp]
30679 84A0           0C                     10  or	al,*$10
30680 84A2           8846         F1            mov	-$F[bp],al
30681                                           !BCC_EOS
30682                                           ! 5190             *(((Bit8u *)&AX)+1) = (0);
30683                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30684 84A5           30C0                       xor	al,al
30685 84A7           8846         17            mov	$17[bp],al
30686                                           !BCC_EOS
30687                                           ! 5191           }
30688                                           ! 5192           break;
30689                       000084AA            .74A:
30690                       000084AA            .749:
30691 84AA           E9         00C8            br 	.738
30692                                           !BCC_EOS
30693                                           ! 5193         case 3:
30694                                           ! 5194           if (maxCyl == 79 && spt == 9)
30695                       000084AD            .74D:
30696                                           ! Debug: logeq int = const $4F to unsigned short maxCyl = [S+$24-$24] (used reg = )
30697 84AD           8B46         DE            mov	ax,-$22[bp]
30698 84B0           3D                   004F  cmp	ax,*$4F
30699 84B3           75           14            jne 	.74E
30700                       000084B5            .750:
30701                                           ! Debug: logeq int = const 9 to unsigned char spt = [S+$24-$1D] (used reg = )
30702 84B5           8A46         E5            mov	al,-$1B[bp]
30703 84B8           3C                     09  cmp	al,*9
30704 84BA           75           0D            jne 	.74E
30705                       000084BC            .74F:
30706                                           ! 5195           {
30707                                           ! 5196             val8 |= 0x90;
30708                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30709 84BC           8A46         F1            mov	al,-$F[bp]
30710 84BF           0C                     90  or	al,#$90
30711 84C1           8846         F1            mov	-$F[bp],al
30712                                           !BCC_EOS
30713                                           ! 5197             *(((Bit8u *)&AX)+1) = (0);
30714                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30715 84C4           30C0                       xor	al,al
30716 84C6           8846         17            mov	$17[bp],al
30717                                           !BCC_EOS
30718                                           ! 5198           }
30719                                           ! 5199           break;
30720                       000084C9            .74E:
30721 84C9           E9         00A9            br 	.738
30722                                           !BCC_EOS
30723                                           ! 5200         case 4:
30724                                           ! 5201           if (maxCyl == 79)
30725                       000084CC            .751:
30726                                           ! Debug: logeq int = const $4F to unsigned short maxCyl = [S+$24-$24] (used reg = )
30727 84CC           8B46         DE            mov	ax,-$22[bp]
30728 84CF           3D                   004F  cmp	ax,*$4F
30729 84D2           75           2A            jne 	.752
30730                       000084D4            .753:
30731                                           ! 5202           {
30732                                           ! 5203             if (spt == 9)
30733                                           ! Debug: logeq int = const 9 to unsigned char spt = [S+$24-$1D] (used reg = )
30734 84D4           8A46         E5            mov	al,-$1B[bp]
30735 84D7           3C                     09  cmp	al,*9
30736 84D9           75           0F            jne 	.754
30737                       000084DB            .755:
30738                                           ! 5204             {
30739                                           ! 5205               val8 |= 0x90;
30740                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30741 84DB           8A46         F1            mov	al,-$F[bp]
30742 84DE           0C                     90  or	al,#$90
30743 84E0           8846         F1            mov	-$F[bp],al
30744                                           !BCC_EOS
30745                                           ! 5206               *(((Bi
30746                                           ! 5206 t8u *)&AX)+1) = (0);
30747                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30748 84E3           30C0                       xor	al,al
30749 84E5           8846         17            mov	$17[bp],al
30750                                           !BCC_EOS
30751                                           ! 5207             }
30752                                           ! 5208             else if (spt == 18)
30753 84E8           EB           14            jmp .756
30754                       000084EA            .754:
30755                                           ! Debug: logeq int = const $12 to unsigned char spt = [S+$24-$1D] (used reg = )
30756 84EA           8A46         E5            mov	al,-$1B[bp]
30757 84ED           3C                     12  cmp	al,*$12
30758 84EF           75           0D            jne 	.757
30759                       000084F1            .758:
30760                                           ! 5209             {
30761                                           ! 5210               val8 |= 0x10;
30762                                           ! Debug: orab int = const $10 to unsigned char val8 = [S+$24-$11] (used reg = )
30763 84F1           8A46         F1            mov	al,-$F[bp]
30764 84F4           0C                     10  or	al,*$10
30765 84F6           8846         F1            mov	-$F[bp],al
30766                                           !BCC_EOS
30767                                           ! 5211               *(((Bit8u *)&AX)+1) = (0);
30768                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30769 84F9           30C0                       xor	al,al
30770 84FB           8846         17            mov	$17[bp],al
30771                                           !BCC_EOS
30772                                           ! 5212             }
30773                                           ! 5213           }
30774                       000084FE            .757:
30775                       000084FE            .756:
30776                                           ! 5214           break;
30777                       000084FE            .752:
30778 84FE           EB           75            jmp .738
30779                                           !BCC_EOS
30780                                           ! 5215         case 5:
30781                                           ! 5216           if (maxCyl == 79)
30782                       00008500            .759:
30783                                           ! Debug: logeq int = const $4F to unsigned short maxCyl = [S+$24-$24] (used reg = )
30784 8500           8B46         DE            mov	ax,-$22[bp]
30785 8503           3D                   004F  cmp	ax,*$4F
30786 8506           75           40            jne 	.75A
30787                       00008508            .75B:
30788                                           ! 5217           {
30789                                           ! 5218             if (spt == 9)
30790                                           ! Debug: logeq int = const 9 to unsigned char spt = [S+$24-$1D] (used reg = )
30791 8508           8A46         E5            mov	al,-$1B[bp]
30792 850B           3C                     09  cmp	al,*9
30793 850D           75           0F            jne 	.75C
30794                       0000850F            .75D:
30795                                           ! 5219             {
30796                                           ! 5220               val8 |= 0x90;
30797                                           ! Debug: orab int = const $90 to unsigned char val8 = [S+$24-$11] (used reg = )
30798 850F           8A46         F1            mov	al,-$F[bp]
30799 8512           0C                     90  or	al,#$90
30800 8514           8846         F1            mov	-$F[bp],al
30801                                           !BCC_EOS
30802                                           ! 5221               *(((Bit8u *)&AX)+1) = (0);
30803                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30804 8517           30C0                       xor	al,al
30805 8519           8846         17            mov	$17[bp],al
30806                                           !BCC_EOS
30807                                           ! 5222             }
30808                                           ! 5223             else if (spt == 18)
30809 851C           EB           2A            jmp .75E
30810                       0000851E            .75C:
30811                                           ! Debug: logeq int = const $12 to unsigned char spt = [S+$24-$1D] (used reg = )
30812 851E           8A46         E5            mov	al,-$1B[bp]
30813 8521           3C                     12  cmp	al,*$12
30814 8523           75           0F            jne 	.75F
30815                       00008525            .760:
30816                                           ! 5224             {
30817                                           ! 5225               val8 |= 0x10;
30818                                           ! Debug: orab int = const $10 to unsigned char val8 = [S+$24-$11] (used reg = )
30819 8525           8A46         F1            mov	al,-$F[bp]
30820 8528           0C                     10  or	al,*$10
30821 852A           8846         F1            mov	-$F[bp],al
30822                                           !BCC_EOS
30823                                           ! 5226               *(((Bit8u *)&AX)+1) = (0);
30824                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30825 852D           30C0                       xor	al,al
30826 852F           8846         17            mov	$17[bp],al
30827                                           !BCC_EOS
30828                                           ! 5227             }
30829                                           ! 5228             else if (spt == 36)
30830 8532           EB           14            jmp .761
30831                       00008534            .75F:
30832                                           ! Debug: logeq int = const $24 to unsigned char spt = [S+$24-$1D] (used reg = )
30833 8534           8A46         E5            mov	al,-$1B[bp]
30834 8537           3C                     24  cmp	al,*$24
30835 8539           75           0D            jne 	.762
30836                       0000853B            .763:
30837                                           ! 5229             {
30838                                           ! 5230               val8 |= 0xD0;
30839                                           ! Debug: orab int = const $D0 to unsigned char val8 = [S+$24-$11] (used reg = )
30840 853B           8A46         F1            mov	al,-$F[bp]
30841 853E           0C                     D0  or	al,#$D0
30842 8540           8846         F1            mov	-$F[bp],al
30843                                           !BCC_EOS
30844                                           ! 5231               *(((Bit8u *)&AX)+1) = (0);
30845                                           ! Debug: eq int = const 0 to unsigned char AX = [S+$24+$15] (used reg = )
30846 8543           30C0                       xor	al,al
30847 8545           8846         17            mov	$17[bp],al
30848                                           !BCC_EOS
30849                                           ! 5232             }
30850                                           ! 5233           }
30851                       00008548            .762:
30852                       00008548            .761:
30853                       00008548            .75E:
30854                                           ! 5234           break;
30855                       00008548            .75A:
30856 8548           EB           2B            jmp .738
30857                                           !BCC_EOS
30858                                           ! 5235         default:
30859                                           ! 5236           break;
30860                       0000854A            .764:
30861 854A           EB           29            jmp .738
30862                                           !BCC_EOS
30863                                           ! 5237       }
30864                                           ! 5238       if (0 != *(((Bit8u *)&AX)+1))
30865 854C           EB           27            jmp .738
30866                       0000854E            .73A:
30867 854E           2C                     00  sub	al,*0
30868 8550           72           F8            jb 	.764
30869 8552           3C                     08  cmp	al,*8
30870 8554           77           1D            ja  	.765
30871 8556           30E4                       xor	ah,ah
30872 8558           D1E0                       shl	ax,*1
30873 855A           89C3                       mov	bx,ax
30874 855C           2E                         seg	cs
30875 855D           FFA7       8561            br	.766[bx]
30876                       00008561            .766:
30877 8561                      8440            .word	.73B
30878 8563                      8443            .word	.73C
30879 8565                      8469            .word	.744
30880 8567                      84AD            .word	.74D
30881 8569                      84CC            .word	.751
30882 856B                      8500            .word	.759
30883 856D                      8443            .word	.73D
30884 856F                      8443            .word	.73E
30885 8571                      8443            .word	.73F
30886                       00008573            .765:
30887 8573           EB           D5            jmp	.764
30888                       00008575            .738:
30889                                           ! Debug: ne unsigned char AX = [S+$24+$15] to int = const 0 (used reg = )
30890                                           ! Debug: expression subtree swapping
30891 8575           8A46         17            mov	al,$17[bp]
30892 8578           84C0                       test	al,al
30893 857A           74           17            je  	.767
30894                       0000857C            .768:
30895                                           ! 5239       {
30896                                           ! 5240         set_diskette_ret_status(*(((Bit8u *)&AX)+1));
30897                                           ! Debug: list unsigned char AX = [S+$24+$15] (used reg = )
30898 857C           8A46         17            mov	al,$17[bp]
30899 857F           30E4                       xor	ah,ah
30900 8581           50                         push	ax
30901                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30902 8582           E8         00AA            call	_set_diskette_ret_status
30903 8585           44                         inc	sp
30904 8586           44                         inc	sp
30905                                           !BCC_EOS
30906                                           ! 5241         FLAGS |= 0x0001;
30907                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
30908 8587           8B46         1C            mov	ax,$1C[bp]
30909 858A           0C                     01  or	al,*1
30910 858C           8946         1C            mov	$1C[bp],ax
30911                                           !BCC_EOS
30912                                           ! 5242         return;
30913 858F           89EC                       mov	sp,bp
30914 8591           5D                         pop	bp
30915 8592           C3                         ret
30916                                           !BCC_EOS
30917                                           ! 5243       }
30918                                           ! 5244 ;
30919                       00008593            .767:
30920                                           !BCC_EOS
30921                                           ! 5245       *((Bit8u *)(base_address)) = (val8);
30922 8593           8B5E         F8            mov	bx,-8[bp]
30923                                           ! Debug: eq unsigned char val8 = [S+$24-$11] to unsigned char = [bx+0] (used reg = )
30924 8596           8A46         F1            mov	al,-$F[bp]
30925 8599           8807                       mov	[bx],al
30926                                           !BCC_EOS
30927                                           ! 5246 #asm
30928                                           !BCC_EOS
30929                                           !BCC_ASM
30930                       0000002E            _int13_diskette_function.BP	set	$2E
30931                       0000000C            .int13_diskette_function.BP	set	$C
30932                       0000003C            _int13_diskette_function.CS	set	$3C
30933                       0000001A            .int13_diskette_function.CS	set	$1A
30934                       00000036            _int13_diskette_function.CX	set	$36
30935                       00000014            .int13_diskette_function.CX	set	$14
30936                       0000001A            _int13_diskette_function.base_address	set	$1A
30937                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
30938                       0000002A            _int13_diskette_function.DI	set	$2A
30939                       00000008            .int13_diskette_function.DI	set	8
30940                       0000003E            _int13_diskette_function.FLAGS	set	$3E
30941                       0000001C            .int13_diskette_function.FLAGS	set	$1C
30942                       00000018            _int13_diskette_function.base_count	set	$18
30943                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
30944                       0000001E            _int13_diskette_function.sector	set	$1E
30945                       FFFFFFFC            .int13_diskette_function.sector	set	-4
30946                       00000026            _int13_diskette_function.DS	set	$26
30947                       00000004            .int13_diskette_function.DS	set	4
30948                       0000001D            _int13_diskette_function.head	set	$1D
30949                       FFFFFFFB            .int13_diskette_function.head	set	-5
30950                       00000030            _int13_diskette_function.ELDX	set	$30
30951                       0000000E            .int13_diskette_function.ELDX	set	$E
30952                       00000012            _int13_diskette_function.dor	set	$12
30953                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
30954                       00000034            _int13_diskette_function.DX	set	$34
30955                       00000012            .int13_diskette_function.DX	set	$12
30956                       0000000B            _int13_diskette_function.return_status	set	$B
30957                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
30958                       00000004            _int13_diskette_function.es	set	4
30959                       FFFFFFE2            .int13_diskette_function.es	set	-$1E
30960                       00000014            _int13_diskette_function.mode_register	set	$14
30961                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
30962                       00000028            _int13_diskette_function.ES	set	$28
30963                       00000006            .int13_diskette_function.ES	set	6
30964                       00000016            _int13_diskette_function.base_es	set	$16
30965                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
30966                       0000001F            _int13_diskette_function.track	set	$1F
30967                       FFFFFFFD            .int13_diskette_function.track	set	-3
30968                       0000002C            _int13_diskette_function.SI	set	$2C
30969                       0000000A            .int13_diskette_function.SI	set	$A
30970                       0000000A            _int13_diskette_function.drive_type	set	$A
30971                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
30972                       00000020            _int13_diskette_function.num_sectors	set	$20
30973                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
30974                       0000003A            _int13_diskette_function.IP	set	$3A
30975                       00000018            .int13_diskette_function.IP	set	$18
30976                       00000007            _int13_diskette_function.spt	set	7
30977                       FFFFFFE5            .int13_diskette_function.spt	set	-$1B
30978                       0000001C            _int13_diskette_function.status	set	$1C
30979                       FFFFFFFA            .int13_diskette_function.status	set	-6
30980                       00000000            _int13_diskette_function.maxCyl	set	0
30981                       FFFFFFDE            .int13_diskette_function.maxCyl	set	-$22
30982                       00000038            _int13_diskette_function.AX	set	$38
30983                       00000016            .int13_diskette_function.AX	set	$16
30984                       00000013            _int13_diskette_function.val8	set	$13
30985                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
30986                       00000002            _int13_diskette_function.last_addr	set	2
30987                       FFFFFFE0            .int13_diskette_function.last_addr	set	-$20
30988                       00000015            _int13_diskette_function.page	set	$15
30989                       FFFFFFF3            .int13_diskette_function.page	set	-$D
30990                       00000008            _int13_diskette_function.ah	set	8
30991                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
30992                       00000021            _int13_diskette_function.drive	set	$21
30993                       FFFFFFFF            .int13_diskette_function.drive	set	-1
30994                       00000009            _int13_diskette_function.num_floppies	set	9
30995                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
30996                       00000032            _int13_diskette_function.BX	set	$32
30997                       00000010            .int13_diskette_function.BX	set	$10
30998 859B           55                               push bp
30999 859C           89E5                             mov bp, sp
31000 859E           B8                   EFDE        mov ax, #diskette_param_table2
31001 85A1           8946         2C                  mov _int13_diskette_function.DI+2[bp], ax
31002 85A4           8C4E         2A                  mov _int13_diskette_function.ES+2[bp], cs
31003 85A7           5D                               pop bp
31004                                           ! 5253 endasm
31005                                           !BCC_ENDASM
31006                                           !BCC_EOS
31007                                           ! 5254       set_diskette_ret_status(0);
31008                                           ! Debug: list int = const 0 (used reg = )
31009 85A8           31C0                       xor	ax,ax
31010 85AA           50                         push	ax
31011                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31012 85AB           E8         0081            call	_set_diskette_ret_status
31013 85AE           44                         inc	sp
31014 85AF           44                         inc	sp
31015                                           !BCC_EOS
31016                                           ! 5255       FLAGS &= 0xfffe;
31017                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
31018 85B0           8B46         1C            mov	ax,$1C[bp]
31019 85B3           24                     FE  and	al,#$FE
31020 85B5           8946         1C            mov	$1C[bp],ax
31021                                           !BCC_EOS
31022                                           ! 5256       return;
31023 85B8           89EC                       mov	sp,bp
31024 85BA           5D                         pop	bp
31025 85BB           C3                         ret
31026                                           !BCC_EOS
31027                                           ! 5257     default:
31028                                           ! 5258         bios_printf(4, "int13_diskette: unsupported AH=%02x\n", *(((Bit8u *)&AX)+1));
31029                       000085BC            .769:
31030                                           ! Debug: list unsigned char AX = [S+$24+$15] (used reg = )
31031 85BC           8A46         17            mov	al,$17[bp]
31032 85BF           30E4                       xor	ah,ah
31033 85C1           50                         push	ax
31034                                           ! Debug: list * char = .76A+0 (used reg = )
31035 85C2           BB                   CD4D  mov	bx,#.76A
31036 85C5           53                         push	bx
31037                                           ! Debug: list int = const 4 (used reg = )
31038 85C6           B8                   0004  mov	ax,*4
31039 85C9           50                         push	ax
31040                                           ! Debug: func () void = bios_printf+0 (used reg = )
31041 85CA           E8         8371            call	_bios_printf
31042 85CD           83C4                   06  add	sp,*6
31043                                           !BCC_EOS
31044                                           ! 5259         *(((Bit8u *)&AX)+1) = (0x01);
31045                                           ! Debug: eq int = const 1 to unsigned char AX = [S+$24+$15] (used reg = )
31046 85D0           B0                     01  mov	al,*1
31047 85D2           8846         17            mov	$17[bp],al
31048                                           !BCC_EOS
31049                                           ! 5260         set_diskette_ret_status(1);
31050                                           ! Debug: list int = const 1 (used reg = )
31051 85D5           B8                   0001  mov	ax,*1
31052 85D8           50                         push	ax
31053                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31054 85D9           E8         0053            call	_set_diskette_ret_status
31055 85DC           44                         inc	sp
31056 85DD           44                         inc	sp
31057                                           !BCC_EOS
31058                                           ! 5261         FLAGS |= 0x0001;
31059                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
31060 85DE           8B46         1C            mov	ax,$1C[bp]
31061 85E1           0C                     01  or	al,*1
31062 85E3           8946         1C            mov	$1C[bp],ax
31063                                           !BCC_EOS
31064                                           ! 5262         return;
31065 85E6           89EC                       mov	sp,bp
31066 85E8           5D                         pop	bp
31067 85E9           C3                         ret
31068                                           !BCC_EOS
31069                                           ! 5263     }
31070                                           ! 5264 }
31071 85EA           EB           3F            jmp .696
31072                       000085EC            .698:
31073 85EC           2C                     00  sub	al,*0
31074 85EE           72           CC            jb 	.769
31075 85F0           3C                     08  cmp	al,*8
31076 85F2           77           1D            ja  	.76B
31077 85F4           30E4                       xor	ah,ah
31078 85F6           D1E0                       shl	ax,*1
31079 85F8           89C3                       mov	bx,ax
31080 85FA           2E                         seg	cs
31081 85FB           FFA7       85FF            br	.76C[bx]
31082                       000085FF            .76C:
31083 85FF                      7790            .word	.699
31084 8601                      7829            .word	.6A1
31085 8603                      7850            .word	.6A4
31086 8605                      7850            .word	.6A5
31087 8607                      7850            .word	.6A6
31088 8609                      7CA6            .word	.6CF
31089 860B                      85BC            .word	.769
31090 860D                      85BC            .word	.769
31091 860F                      800A            .word	.6EF
31092                       00008611            .76B:
31093 8611           2C                     15  sub	al,*$15
31094 8613         0F84         FB66            beq 	.709
31095 8617           2C                     01  sub	al,*1
31096 8619         0F84         FBC6            beq 	.712
31097 861D           2C                     01  sub	al,*1
31098 861F         0F84         FC01            beq 	.715
31099 8623           2C                     01  sub	al,*1
31100 8625         0F84         FD15            beq 	.729
31101 8629           EB           91            jmp	.769
31102                       0000862B            .696:
31103                       FFFFFFDC            ..FFDB	=	-$24
31104                       FFFFFFDC            ..FFDA	=	-$24
31105 862B           89EC                       mov	sp,bp
31106 862D           5D                         pop	bp
31107 862E           C3                         ret
31108                                           ! 5265  void
31109                                           ! Register BX used in function int13_diskette_function
31110                                           ! 5266 set_diskette_ret_status(value)
31111                                           ! 5267   Bit8u value;
31112                                           export	_set_diskette_ret_status
31113                       0000862F            _set_diskette_ret_status:
31114                                           !BCC_EOS
31115                                           ! 5268 {
31116                                           ! 5269   _write_byte(value, 0x0041, 0x0040);
31117 862F           55                         push	bp
31118 8630           89E5                       mov	bp,sp
31119                                           ! Debug: list int = const $40 (used reg = )
31120 8632           B8                   0040  mov	ax,*$40
31121 8635           50                         push	ax
31122                                           ! Debug: list int = const $41 (used reg = )
31123 8636           B8                   0041  mov	ax,*$41
31124 8639           50                         push	ax
31125                                           ! Debug: list unsigned char value = [S+6+2] (used reg = )
31126 863A           8A46         04            mov	al,4[bp]
31127 863D           30E4                       xor	ah,ah
31128 863F           50                         push	ax
31129                                           ! Debug: func () void = _write_byte+0 (used reg = )
31130 8640           E8         7FBD            call	__write_byte
31131 8643           89EC                       mov	sp,bp
31132                                           !BCC_EOS
31133                                           ! 5270 }
31134 8645           5D                         pop	bp
31135 8646           C3                         ret
31136                                           ! 5271   void
31137                                           ! 5272 set_diskette_current_cyl(drive, cyl)
31138                                           ! 5273   Bit8u drive;
31139                                           export	_set_diskette_current_cyl
31140                       00008647            _set_diskette_current_cyl:
31141                                           !BCC_EOS
31142                                           ! 5274   Bit8u cyl;
31143                                           !BCC_EOS
31144                                           ! 5275 {
31145                                           ! 5276   if (drive > 1)
31146 8647           55                         push	bp
31147 8648           89E5                       mov	bp,sp
31148                                           ! Debug: gt int = const 1 to unsigned char drive = [S+2+2] (used reg = )
31149 864A           8A46         04            mov	al,4[bp]
31150 864D           3C                     01  cmp	al,*1
31151 864F           76           0D            jbe 	.76D
31152                       00008651            .76E:
31153                                           ! 5277     bios_printf((2 | 4 | 1), "set_diskette_current_cyl(): drive > 1\n");
31154                                           ! Debug: list * char = .76F+0 (used reg = )
31155 8651           BB                   CD26  mov	bx,#.76F
31156 8654           53                         push	bx
31157                                           ! Debug: list int = const 7 (used reg = )
31158 8655           B8                   0007  mov	ax,*7
31159 8658           50                         push	ax
31160                                           ! Debug: func () void = bios_printf+0 (used reg = )
31161 8659           E8         82E2            call	_bios_printf
31162 865C           89EC                       mov	sp,bp
31163                                           !BCC_EOS
31164                                           ! 5278   _write_byte(cyl, 0x0094+drive, 0x0040);
31165                       0000865E            .76D:
31166                                           ! Debug: list int = const $40 (used reg = )
31167 865E           B8                   0040  mov	ax,*$40
31168 8661           50                         push	ax
31169                                           ! Debug: add unsigned char drive = [S+4+2] to int = const $94 (used reg = )
31170                                           ! Debug: expression subtree swapping
31171 8662           8A46         04            mov	al,4[bp]
31172 8665           30E4                       xor	ah,ah
31173                                           ! Debug: list unsigned int = ax+$94 (used reg = )
31174 8667           05                   0094  add	ax,#$94
31175 866A           50                         push	ax
31176                                           ! Debug: list unsigned char cyl = [S+6+4] (used reg = )
31177 866B           8A46         06            mov	al,6[bp]
31178 866E           30E4                       xor	ah,ah
31179 8670           50                         push	ax
31180                                           ! Debug: func () void = _write_byte+0 (used reg = )
31181 8671           E8         7F8C            call	__write_byte
31182 8674           89EC                       mov	sp,bp
31183                                           !BCC_EOS
31184                                           ! 5279 }
31185 8676           5D                         pop	bp
31186 8677           C3                         ret
31187                                           ! 5280   void
31188                                           ! Register BX used in function set_diskette_current_cyl
31189                                           ! 5281 determine_floppy_media(drive)
31190                                           ! 5282   Bit16u drive;
31191                                           export	_determine_floppy_media
31192                       00008678            _determine_floppy_media:
31193                                           !BCC_EOS
31194                                           ! 5283 {
31195                                           ! 5284 }
31196 8678           C3                         ret
31197                                           ! 5285   void
31198                                           ! 5286 int17_function(regs, ds, iret_addr)
31199                                           ! 5287   pusha_regs_t regs;
31200                                           export	_int17_function
31201                       00008679            _int17_function:
31202                                           !BCC_EOS
31203                                           ! 5288   Bit16u ds;
31204                                           !BCC_EOS
31205                                           ! 5289   iret_addr_t iret_addr;
31206                                           !BCC_EOS
31207                                           ! 5290 {
31208                                           ! 5291   Bit16u addr,timeout;
31209                                           !BCC_EOS
31210                                           ! 5292   Bit8u val8;
31211                                           !BCC_EOS
31212                                           ! 5293 #asm
31213 8679           55                         push	bp
31214 867A           89E5                       mov	bp,sp
31215 867C           83C4                   FA  add	sp,*-6
31216                                           !BCC_EOS
31217                                           !BCC_ASM
31218                       0000001A            _int17_function.ds	set	$1A
31219                       00000014            .int17_function.ds	set	$14
31220                       00000002            _int17_function.timeout	set	2
31221                       FFFFFFFC            .int17_function.timeout	set	-4
31222                       00000001            _int17_function.val8	set	1
31223                       FFFFFFFB            .int17_function.val8	set	-5
31224                       0000001C            _int17_function.iret_addr	set	$1C
31225                       00000016            .int17_function.iret_addr	set	$16
31226                       00000004            _int17_function.addr	set	4
31227                       FFFFFFFE            .int17_function.addr	set	-2
31228                       0000000A            _int17_function.regs	set	$A
31229                       00000004            .int17_function.regs	set	4
31230 867F           FB                           sti
31231                                           ! 5295 endasm
31232                                           !BCC_ENDASM
31233                                           !BCC_EOS
31234                                           ! 5296   addr = *((Bit16u *)(0x0400 + (regs.u.r16.dx << 1) + 8));
31235                                           ! Debug: sl int = const 1 to unsigned short regs = [S+8+$C] (used reg = )
31236 8680           8B46         0E            mov	ax,$E[bp]
31237 8683           D1E0                       shl	ax,*1
31238                                           ! Debug: add unsigned int = ax+0 to int = const $400 (used reg = )
31239                                           ! Debug: expression subtree swapping
31240                                           ! Debug: add int = const 8 to unsigned int = ax+$400 (used reg = )
31241                                           ! Debug: cast * unsigned short = const 0 to unsigned int = ax+$408 (used reg = )
31242 8685           89C3                       mov	bx,ax
31243                                           ! Debug: eq unsigned short = [bx+$408] to unsigned short addr = [S+8-4] (used reg = )
31244 8687           8B9F       0408            mov	bx,$408[bx]
31245 868B           895E         FE            mov	-2[bp],bx
31246                                           !BCC_EOS
31247                                           ! 5297   if ((regs.u.r8.ah < 3) && (regs.u.r16.dx < 3) && (addr > 0)) {
31248                                           ! Debug: lt int = const 3 to unsigned char regs = [S+8+$11] (used reg = )
31249 868E           8A46         13            mov	al,$13[bp]
31250 8691           3C                     03  cmp	al,*3
31251 8693         0F83         00FD            bhis	.770
31252                       00008697            .773:
31253                                           ! Debug: lt int = const 3 to unsigned short regs = [S+8+$C] (used reg = )
31254 8697           8B46         0E            mov	ax,$E[bp]
31255 869A           3D                   0003  cmp	ax,*3
31256 869D         0F83         00F3            bhis	.770
31257                       000086A1            .772:
31258                                           ! Debug: gt int = const 0 to unsigned short addr = [S+8-4] (used reg = )
31259 86A1           8B46         FE            mov	ax,-2[bp]
31260 86A4           85C0                       test	ax,ax
31261 86A6         0F84         00EA            beq 	.770
31262                       000086AA            .771:
31263                                           ! 5298     *(((Bit8u *)&timeout)+1) 
31264                                           ! 5298 = *((Bit8u *)(0x0478 + regs.u.r16.dx));
31265                                           ! Debug: add unsigned short regs = [S+8+$C] to int = const $478 (used reg = )
31266                                           ! Debug: expression subtree swapping
31267 86AA           8B46         0E            mov	ax,$E[bp]
31268                                           ! Debug: cast * unsigned char = const 0 to unsigned int = ax+$478 (used reg = )
31269 86AD           89C3                       mov	bx,ax
31270                                           ! Debug: eq unsigned char = [bx+$478] to unsigned char timeout = [S+8-5] (used reg = )
31271 86AF           8A87       0478            mov	al,$478[bx]
31272 86B3           8846         FD            mov	-3[bp],al
31273                                           !BCC_EOS
31274                                           ! 5299     *((Bit8u *)&timeout) = 0;
31275                                           ! Debug: eq int = const 0 to unsigned char timeout = [S+8-6] (used reg = )
31276 86B6           30C0                       xor	al,al
31277 86B8           8846         FC            mov	-4[bp],al
31278                                           !BCC_EOS
31279                                           ! 5300     if (regs.u.r8.ah == 0) {
31280                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+8+$11] (used reg = )
31281 86BB           8A46         13            mov	al,$13[bp]
31282 86BE           84C0                       test	al,al
31283 86C0           75           66            jne 	.774
31284                       000086C2            .775:
31285                                           ! 5301       outb(addr, regs.u.r8.al);
31286                                           ! Debug: list unsigned char regs = [S+8+$10] (used reg = )
31287 86C2           8A46         12            mov	al,$12[bp]
31288 86C5           30E4                       xor	ah,ah
31289 86C7           50                         push	ax
31290                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
31291 86C8           FF76         FE            push	-2[bp]
31292                                           ! Debug: func () void = outb+0 (used reg = )
31293 86CB           E8         7E40            call	_outb
31294 86CE           83C4                   04  add	sp,*4
31295                                           !BCC_EOS
31296                                           ! 5302       val8 = inb(addr+2);
31297                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
31298 86D1           8B46         FE            mov	ax,-2[bp]
31299                                           ! Debug: list unsigned int = ax+2 (used reg = )
31300 86D4           40                         inc	ax
31301 86D5           40                         inc	ax
31302 86D6           50                         push	ax
31303                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31304 86D7           E8         7E1E            call	_inb
31305 86DA           44                         inc	sp
31306 86DB           44                         inc	sp
31307                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
31308 86DC           8846         FB            mov	-5[bp],al
31309                                           !BCC_EOS
31310                                           ! 5303       outb(addr+2, val8 | 0x01);
31311                                           ! Debug: or int = const 1 to unsigned char val8 = [S+8-7] (used reg = )
31312 86DF           8A46         FB            mov	al,-5[bp]
31313 86E2           0C                     01  or	al,*1
31314                                           ! Debug: list unsigned char = al+0 (used reg = )
31315 86E4           30E4                       xor	ah,ah
31316 86E6           50                         push	ax
31317                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
31318 86E7           8B46         FE            mov	ax,-2[bp]
31319                                           ! Debug: list unsigned int = ax+2 (used reg = )
31320 86EA           40                         inc	ax
31321 86EB           40                         inc	ax
31322 86EC           50                         push	ax
31323                                           ! Debug: func () void = outb+0 (used reg = )
31324 86ED           E8         7E1E            call	_outb
31325 86F0           83C4                   04  add	sp,*4
31326                                           !BCC_EOS
31327                                           ! 5304 #asm
31328                                           !BCC_EOS
31329                                           !BCC_ASM
31330                       0000001A            _int17_function.ds	set	$1A
31331                       00000014            .int17_function.ds	set	$14
31332                       00000002            _int17_function.timeout	set	2
31333                       FFFFFFFC            .int17_function.timeout	set	-4
31334                       00000001            _int17_function.val8	set	1
31335                       FFFFFFFB            .int17_function.val8	set	-5
31336                       0000001C            _int17_function.iret_addr	set	$1C
31337                       00000016            .int17_function.iret_addr	set	$16
31338                       00000004            _int17_function.addr	set	4
31339                       FFFFFFFE            .int17_function.addr	set	-2
31340                       0000000A            _int17_function.regs	set	$A
31341                       00000004            .int17_function.regs	set	4
31342 86F3           90                               nop
31343                                           ! 5306 endasm
31344                                           !BCC_ENDASM
31345                                           !BCC_EOS
31346                                           ! 5307       outb(addr+2, val8 & ~0x01);
31347                                           ! Debug: and int = const -2 to unsigned char val8 = [S+8-7] (used reg = )
31348 86F4           8A46         FB            mov	al,-5[bp]
31349 86F7           24                     FE  and	al,#$FE
31350                                           ! Debug: list unsigned char = al+0 (used reg = )
31351 86F9           30E4                       xor	ah,ah
31352 86FB           50                         push	ax
31353                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
31354 86FC           8B46         FE            mov	ax,-2[bp]
31355                                           ! Debug: list unsigned int = ax+2 (used reg = )
31356 86FF           40                         inc	ax
31357 8700           40                         inc	ax
31358 8701           50                         push	ax
31359                                           ! Debug: func () void = outb+0 (used reg = )
31360 8702           E8         7E09            call	_outb
31361 8705           83C4                   04  add	sp,*4
31362                                           !BCC_EOS
31363                                           ! 5308       while (((inb(addr+1) & 0x40) == 0x40) && (timeout)) {
31364 8708           EB           07            jmp .777
31365                       0000870A            .778:
31366                                           ! 5309         timeout--;
31367                                           ! Debug: postdec unsigned short timeout = [S+8-6] (used reg = )
31368 870A           8B46         FC            mov	ax,-4[bp]
31369 870D           48                         dec	ax
31370 870E           8946         FC            mov	-4[bp],ax
31371                                           !BCC_EOS
31372                                           ! 5310       }
31373                                           ! 5311     }
31374                       00008711            .777:
31375                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
31376 8711           8B46         FE            mov	ax,-2[bp]
31377                                           ! Debug: list unsigned int = ax+1 (used reg = )
31378 8714           40                         inc	ax
31379 8715           50                         push	ax
31380                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31381 8716           E8         7DDF            call	_inb
31382 8719           44                         inc	sp
31383 871A           44                         inc	sp
31384                                           ! Debug: and int = const $40 to unsigned char = al+0 (used reg = )
31385 871B           24                     40  and	al,*$40
31386                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
31387 871D           3C                     40  cmp	al,*$40
31388 871F           75           07            jne 	.779
31389                       00008721            .77A:
31390 8721           8B46         FC            mov	ax,-4[bp]
31391 8724           85C0                       test	ax,ax
31392 8726           75           E2            jne	.778
31393                       00008728            .779:
31394                       00008728            .776:
31395                                           ! 5312     if (regs.u.r8.ah == 1) {
31396                       00008728            .774:
31397                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
31398 8728           8A46         13            mov	al,$13[bp]
31399 872B           3C                     01  cmp	al,*1
31400 872D           75           37            jne 	.77B
31401                       0000872F            .77C:
31402                                           ! 5313       val8 = inb(addr+2);
31403                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
31404 872F           8B46         FE            mov	ax,-2[bp]
31405                                           ! Debug: list unsigned int = ax+2 (used reg = )
31406 8732           40                         inc	ax
31407 8733           40                         inc	ax
31408 8734           50                         push	ax
31409                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31410 8735           E8         7DC0            call	_inb
31411 8738           44                         inc	sp
31412 8739           44                         inc	sp
31413                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
31414 873A           8846         FB            mov	-5[bp],al
31415                                           !BCC_EOS
31416                                           ! 5314       outb(addr+2, val8 & ~0x04);
31417                                           ! Debug: and int = const -5 to unsigned char val8 = [S+8-7] (used reg = )
31418 873D           8A46         FB            mov	al,-5[bp]
31419 8740           24                     FB  and	al,#$FB
31420                                           ! Debug: list unsigned char = al+0 (used reg = )
31421 8742           30E4                       xor	ah,ah
31422 8744           50                         push	ax
31423                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
31424 8745           8B46         FE            mov	ax,-2[bp]
31425                                           ! Debug: list unsigned int = ax+2 (used reg = )
31426 8748           40                         inc	ax
31427 8749           40                         inc	ax
31428 874A           50                         push	ax
31429                                           ! Debug: func () void = outb+0 (used reg = )
31430 874B           E8         7DC0            call	_outb
31431 874E           83C4                   04  add	sp,*4
31432                                           !BCC_EOS
31433                                           ! 5315 #asm
31434                                           !BCC_EOS
31435                                           !BCC_ASM
31436                       0000001A            _int17_function.ds	set	$1A
31437                       00000014            .int17_function.ds	set	$14
31438                       00000002            _int17_function.timeout	set	2
31439                       FFFFFFFC            .int17_function.timeout	set	-4
31440                       00000001            _int17_function.val8	set	1
31441                       FFFFFFFB            .int17_function.val8	set	-5
31442                       0000001C            _int17_function.iret_addr	set	$1C
31443                       00000016            .int17_function.iret_addr	set	$16
31444                       00000004            _int17_function.addr	set	4
31445                       FFFFFFFE            .int17_function.addr	set	-2
31446                       0000000A            _int17_function.regs	set	$A
31447                       00000004            .int17_function.regs	set	4
31448 8751           90                               nop
31449                                           ! 5317 endasm
31450                                           !BCC_ENDASM
31451                                           !BCC_EOS
31452                                           ! 5318       outb(addr+2, val8 | 0x04);
31453                                           ! Debug: or int = const 4 to unsigned char val8 = [S+8-7] (used reg = )
31454 8752           8A46         FB            mov	al,-5[bp]
31455 8755           0C                     04  or	al,*4
31456                                           ! Debug: list unsigned char = al+0 (used reg = )
31457 8757           30E4                       xor	ah,ah
31458 8759           50                         push	ax
31459                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
31460 875A           8B46         FE            mov	ax,-2[bp]
31461                                           ! Debug: list unsigned int = ax+2 (used reg = )
31462 875D           40                         inc	ax
31463 875E           40                         inc	ax
31464 875F           50                         push	ax
31465                                           ! Debug: func () void = outb+0 (used reg = )
31466 8760           E8         7DAB            call	_outb
31467 8763           83C4                   04  add	sp,*4
31468                                           !BCC_EOS
31469                                           ! 5319     }
31470                                           ! 5320     val8 = inb(addr+1);
31471                       00008766            .77B:
31472                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
31473 8766           8B46         FE            mov	ax,-2[bp]
31474                                           ! Debug: list unsigned int = ax+1 (used reg = )
31475 8769           40                         inc	ax
31476 876A           50                         push	ax
31477                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31478 876B           E8         7D8A            call	_inb
31479 876E           44                         inc	sp
31480 876F           44                         inc	sp
31481                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
31482 8770           8846         FB            mov	-5[bp],al
31483                                           !BCC_EOS
31484                                           ! 5321     regs.u.r8.ah = (val8 ^ 0x48);
31485                                           ! Debug: eor int = const $48 to unsigned char val8 = [S+8-7] (used reg = )
31486 8773           8A46         FB            mov	al,-5[bp]
31487 8776           34                     48  xor	al,*$48
31488                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+8+$11] (used reg = )
31489 8778           8846         13            mov	$13[bp],al
31490                                           !BCC_EOS
31491                                           ! 5322     if (!timeout) regs.u.r8.ah |= 0x01;
31492 877B           8B46         FC            mov	ax,-4[bp]
31493 877E           85C0                       test	ax,ax
31494 8780           75           08            jne 	.77D
31495                       00008782            .77E:
31496                                           ! Debug: orab int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
31497 8782           8A46         13            mov	al,$13[bp]
31498 8785           0C                     01  or	al,*1
31499 8787           8846         13            mov	$13[bp],al
31500                                           !BCC_EOS
31501                                           ! 5323     iret_addr.flags.u.r8.flagsl &= 0xfe;
31502                       0000878A            .77D:
31503                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+8+$18] (used reg = )
31504 878A           8A46         1A            mov	al,$1A[bp]
31505 878D           24                     FE  and	al,#$FE
31506 878F           8846         1A            mov	$1A[bp],al
31507                                           !BCC_EOS
31508                                           ! 5324   } else {
31509 8792           EB           08            jmp .77F
31510                       00008794            .770:
31511                                           ! 5325     iret_addr.flags.u.r8.flagsl |= 0x01;
31512                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+8+$18] (used reg = )
31513 8794           8A46         1A            mov	al,$1A[bp]
31514 8797           0C                     01  or	al,*1
31515 8799           8846         1A            mov	$1A[bp],al
31516                                           !BCC_EOS
31517                                           ! 5326   }
31518                                           ! 5327 }
31519                       0000879C            .77F:
31520 879C           89EC                       mov	sp,bp
31521 879E           5D                         pop	bp
31522 879F           C3                         ret
31523                                           ! 5328 void
31524                                           ! Register BX used in function int17_function
31525                                           ! 5329 int19_function(seq_nr)
31526                                           ! 5330 Bit16u seq_nr;
31527                                           export	_int19_function
31528                       000087A0            _int19_function:
31529                                           !BCC_EOS
31530                                           ! 5331 {
31531                                           ! 5332   Bit16u ebda_seg=*((Bit16u *)(0x040E));
31532 87A0           55                         push	bp
31533 87A1           89E5                       mov	bp,sp
31534 87A3           4C                         dec	sp
31535 87A4           4C                         dec	sp
31536                                           ! Debug: eq unsigned short = [+$40E] to unsigned short ebda_seg = [S+4-4] (used reg = )
31537 87A5           A1         040E            mov	ax,[$40E]
31538 87A8           8946         FE            mov	-2[bp],ax
31539                                           !BCC_EOS
31540                                           ! 5333   Bit16u bootdev;
31541                                           !BCC_EOS
31542                                           ! 5334   Bit8u bootdrv;
31543                                           !BCC_EOS
31544                                           ! 5335   Bit8u bootchk;
31545                                           !BCC_EOS
31546                                           ! 5336   Bit16u bootseg;
31547                                           !BCC_EOS
31548                                           ! 5337   Bit16u bootip;
31549                                           !BCC_EOS
31550                                           ! 5338   Bit16u status;
31551                                           !BCC_EOS
31552                                           ! 5339   Bit16u bootfirst;
31553                                           !BCC_EOS
31554                                           ! 5340   ipl_entry_t e;
31555                                           !BCC_EOS
31556                                           ! 5341   bootdev = inb_cmos(0x3d);
31557 87AB           83C4                   E4  add	sp,*-$1C
31558                                           ! Debug: list int = const $3D (used reg = )
31559 87AE           B8                   003D  mov	ax,*$3D
31560 87B1           50                         push	ax
31561                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
31562 87B2           E8         7D88            call	_inb_cmos
31563 87B5           44                         inc	sp
31564 87B6           44                         inc	sp
31565                                           ! Debug: eq unsigned char = al+0 to unsigned short bootdev = [S+$20-6] (used reg = )
31566 87B7           30E4                       xor	ah,ah
31567 87B9           8946         FC            mov	-4[bp],ax
31568                                           !BCC_EOS
31569                                           ! 5342   bootdev |= ((inb_cmos(0x38) & 0xf0) << 4);
31570                                           ! Debug: list int = const $38 (used reg = )
31571 87BC           B8                   0038  mov	ax,*$38
31572 87BF           50                         push	ax
31573                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
31574 87C0           E8         7D7A            call	_inb_cmos
31575 87C3           44                         inc	sp
31576 87C4           44                         inc	sp
31577                                           ! Debug: and int = const $F0 to unsigned char = al+0 (used reg = )
31578 87C5           24                     F0  and	al,#$F0
31579                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
31580 87C7           30E4                       xor	ah,ah
31581 87C9           B1                     04  mov	cl,*4
31582 87CB           D3E0                       shl	ax,cl
31583                                           ! Debug: orab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
31584 87CD           0B46         FC            or	ax,-4[bp]
31585 87D0           8946         FC            mov	-4[bp],ax
31586                                           !BCC_EOS
31587                                           ! 5343   bootdev >>= 4 * seq_nr;
31588                                           ! Debug: mul unsigned short seq_nr = [S+$20+2] to int = const 4 (used reg = )
31589                                           ! Debug: expression subtree swapping
31590 87D3           8B46         04            mov	ax,4[bp]
31591 87D6           D1E0                       shl	ax,*1
31592 87D8           D1E0                       shl	ax,*1
31593                                           ! Debug: srab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
31594 87DA           89C3                       mov	bx,ax
31595 87DC           8B46         FC            mov	ax,-4[bp]
31596 87DF           89D9                       mov	cx,bx
31597 87E1           D3E8                       shr	ax,cl
31598 87E3           8946         FC            mov	-4[bp],ax
31599                                           !BCC_EOS
31600                                           ! 5344   bootdev &= 0xf;
31601                                           ! Debug: andab int = const $F to unsigned short bootdev = [S+$20-6] (used reg = )
31602 87E6           8A46         FC            mov	al,-4[bp]
31603 87E9           24                     0F  and	al,*$F
31604 87EB           30E4                       xor	ah,ah
31605 87ED           8946         FC            mov	-4[bp],ax
31606                                           !BCC_EOS
31607                                           ! 5345   bootfirst = _read_word(0x0084, 0x9ff0);
31608                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
31609 87F0           B8                   9FF0  mov	ax,#$9FF0
31610 87F3           50                         push	ax
31611                                           ! Debug: list int = const $84 (used reg = )
31612 87F4           B8                   0084  mov	ax,#$84
31613 87F7           50                         push	ax
31614                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
31615 87F8           E8         7DF7            call	__read_word
31616 87FB           83C4                   04  add	sp,*4
31617                                           ! Debug: eq unsigned short = ax+0 to unsigned short bootfirst = [S+$20-$10] (used reg = )
31618 87FE           8946         F2            mov	-$E[bp],ax
31619                                           !BCC_EOS
31620                                           ! 5346   if (bootfirst != 0xFFFF) {
31621                                           ! Debug: ne unsigned int = const $FFFF to unsigned short bootfirst = [S+$20-$10] (used reg = )
31622 8801           8B46         F2            mov	ax,-$E[bp]
31623 8804           3D                   FFFF  cmp	ax,#$FFFF
31624 8807           74           2C            je  	.780
31625                       00008809            .781:
31626                                           ! 5347     bootdev = bootfirst;
31627                                           ! Debug: eq unsigned short bootfirst = [S+$20-$10] to unsigned short bootdev = [S+$20-6] (used reg = )
31628 8809           8B46         F2            mov	ax,-$E[bp]
31629 880C           8946         FC            mov	-4[bp],ax
31630                                           !BCC_EOS
31631                                           ! 5348     _write_word(0xFFFF, 0x0084, 0x9ff0);
31632                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
31633 880F           B8                   9FF0  mov	ax,#$9FF0
31634 8812           50                         push	ax
31635                                           ! Debug: list int = const $84 (used reg = )
31636 8813           B8                   0084  mov	ax,#$84
31637 8816           50                         push	ax
31638                                           ! Debug: list unsigned int = const $FFFF (used reg = )
31639 8817           B8                   FFFF  mov	ax,#$FFFF
31640 881A           50                         push	ax
31641                                           ! Debug: func () void = _write_word+0 (used reg = )
31642 881B           E8         7DF5            call	__write_word
31643 881E           83C4                   06  add	sp,*6
31644                                           !BCC_EOS
31645                                           ! 5349     _write_word(0xFFFF, 0x0082, 0x9ff0);
31646                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
31647 8821           B8                   9FF0  mov	ax,#$9FF0
31648 8824           50                         push	ax
31649                                           ! Debug: list int = const $82 (used reg = )
31650 8825           B8                   0082  mov	ax,#$82
31651 8828           50                         push	ax
31652                                           ! Debug: list unsigned int = const $FFFF (used reg = )
31653 8829           B8                   FFFF  mov	ax,#$FFFF
31654 882C           50                         push	ax
31655                                           ! Debug: func () void = _write_word+0 (used reg = )
31656 882D           E8         7DE3            call	__write_word
31657 8830           83C4                   06  add	sp,*6
31658                                           !BCC_EOS
31659                                           ! 5350   } else if (bootdev == 0) bios_printf((2 | 4 | 1), "No bootable device.\n");
31660 8833           EB           15            jmp .782
31661                       00008835            .780:
31662                                           ! Debug: logeq int = const 0 to unsigned short bootdev = [S+$20-6] (used reg = )
31663 8835           8B46         FC            mov	ax,-4[bp]
31664 8838           85C0                       test	ax,ax
31665 883A           75           0E            jne 	.783
31666                       0000883C            .784:
31667                                           ! Debug: list * char = .785+0 (used reg = )
31668 883C           BB                   CD11  mov	bx,#.785
31669 883F           53                         push	bx
31670                                           ! Debug: list int = const 7 (used reg = )
31671 8840           B8                   0007  mov	ax,*7
31672 8843           50                         push	ax
31673                                           ! Debug: func () void = bios_printf+0 (used reg = )
31674 8844           E8         80F7            call	_bios_printf
31675 8847           83C4                   04  add	sp,*4
31676                                           !BCC_EOS
31677                                           ! 5351   bootdev -= 1;
31678                       0000884A            .783:
31679                       0000884A            .782:
31680                                           ! Debug: subab int = const 1 to unsigned short bootdev = [S+$20-6] (used reg = )
31681 884A           8B46         FC            mov	ax,-4[bp]
31682 884D           48                         dec	ax
31683 884E           8946         FC            mov	-4[bp],ax
31684                                           !BCC_EOS
31685                                           ! 5352   if (get_boot_vector(bootdev, &e) == 0) {
31686                                           ! Debug: list * struct  e = S+$20-$20 (used reg = )
31687 8851           8D5E         E2            lea	bx,-$1E[bp]
31688 8854           53                         push	bx
31689                                           ! Debug: list unsigned short bootdev = [S+$22-6] (used reg = )
31690 8855           FF76         FC            push	-4[bp]
31691                                           ! Debug: func () unsigned char = get_boot_vector+0 (used reg = )
31692 8858           E8         8B13            call	_get_boot_vector
31693 885B           83C4                   04  add	sp,*4
31694                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
31695 885E           84C0                       test	al,al
31696 8860           75           15            jne 	.786
31697                       00008862            .787:
31698                                           ! 5353     bios_printf(4, "Invalid boot device (0x%x)\n", bootdev);
31699                                           ! Debug: list unsigned short bootdev = [S+$20-6] (used reg = )
31700 8862           FF76         FC            push	-4[bp]
31701                                           ! Debug: list * char = .788+0 (used reg = )
31702 8865           BB                   CCF5  mov	bx,#.788
31703 8868           53                         push	bx
31704                                           ! Debug: list int = const 4 (used reg = )
31705 8869           B8                   0004  mov	ax,*4
31706 886C           50                         push	ax
31707                                           ! Debug: func () void = bios_printf+0 (used reg = )
31708 886D           E8         80CE            call	_bios_printf
31709 8870           83C4                   06  add	sp,*6
31710                                           !BCC_EOS
31711                                           ! 5354     return;
31712 8873           89EC                       mov	sp,bp
31713 8875           5D                         pop	bp
31714 8876           C3                         ret
31715                                           !BCC_EOS
31716                                           ! 5355   }
31717                                           ! 5356   print_boot_device(&e);
31718                       00008877            .786:
31719                                           ! Debug: list * struct  e = S+$20-$20 (used reg = )
31720 8877           8D5E         E2            lea	bx,-$1E[bp]
31721 887A           53                         push	bx
31722                                           ! Debug: func () void = print_boot_device+0 (used reg = )
31723 887B           E8         8D39            call	_print_boot_device
31724 887E           44                         inc	sp
31725 887F           44                         inc	sp
31726                                           !BCC_EOS
31727                                           ! 5357   switch(e.type) {
31728 8880           8B46         E2            mov	ax,-$1E[bp]
31729 8883           E9         0106            br 	.78B
31730                                           ! 5358   case 0x01:
31731                                           ! 5359   case 0x02:
31732                       00008886            .78C:
31733                                           ! 5360     bootdrv = (e.type == 0x02) ? 0x80 : 0x00;
31734                       00008886            .78D:
31735                                           ! Debug: logeq int = const 2 to unsigned short e = [S+$20-$20] (used reg = )
31736 8886           8B46         E2            mov	ax,-$1E[bp]
31737 8889           3D                   0002  cmp	ax,*2
31738 888C           75           04            jne 	.78E
31739                       0000888E            .78F:
31740 888E           B0                     80  mov	al,#$80
31741 8890           EB           02            jmp .790
31742                       00008892            .78E:
31743 8892           30C0                       xor	al,al
31744                       00008894            .790:
31745                                           ! Debug: eq char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
31746 8894           8846         FB            mov	-5[bp],al
31747                                           !BCC_EOS
31748                                           ! 5361     bootseg = 0x07c0;
31749                                           ! Debug: eq int = const $7C0 to unsigned short bootseg = [S+$20-$A] (used reg = )
31750 8897           B8                   07C0  mov	ax,#$7C0
31751 889A           8946         F8            mov	-8[bp],ax
31752                                           !BCC_EOS
31753                                           ! 5362     status = 0;
31754                                           ! Debug: eq int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
31755 889D           31C0                       xor	ax,ax
31756 889F           8946         F4            mov	-$C[bp],ax
31757                                           !BCC_EOS
31758                                           ! 5363 #asm
31759                                           !BCC_EOS
31760                                           !BCC_ASM
31761                       00000014            _int19_function.bootip	set	$14
31762                       FFFFFFF6            .int19_function.bootip	set	-$A
31763                       00000022            _int19_function.seq_nr	set	$22
31764                       00000004            .int19_function.seq_nr	set	4
31765                       00000018            _int19_function.bootchk	set	$18
31766                       FFFFFFFA            .int19_function.bootchk	set	-6
31767                       00000016            _int19_function.bootseg	set	$16
31768                       FFFFFFF8            .int19_function.bootseg	set	-8
31769                       0000001C            _int19_function.ebda_seg	set	$1C
31770                       FFFFFFFE            .int19_function.ebda_seg	set	-2
31771                       00000012            _int19_function.status	set	$12
31772                       FFFFFFF4            .int19_function.status	set	-$C
31773                       00000010            _int19_function.bootfirst	set	$10
31774                       FFFFFFF2            .int19_function.bootfirst	set	-$E
31775                       00000019            _int19_function.bootdrv	set	$19
31776                       FFFFFFFB            .int19_function.bootdrv	set	-5
31777                       0000001A            _int19_function.bootdev	set	$1A
31778                       FFFFFFFC            .int19_function.bootdev	set	-4
31779                       00000000            _int19_function.e	set	0
31780                       FFFFFFE2            .int19_function.e	set	-$1E
31781 88A2           55                             push bp
31782 88A3           89E5                           mov bp, sp
31783 88A5           50                             push ax
31784 88A6           53                             push bx
31785 88A7           51                             push cx
31786 88A8           52                             push dx
31787 88A9           8A56         1B                mov dl, _int19_function.bootdrv + 2[bp]
31788 88AC           8B46         18                mov ax, _int19_function.bootseg + 2[bp]
31789 88AF           8EC0                           mov es, ax ;; segment
31790 88B1           31DB                           xor bx, bx ;; offset
31791 88B3           B4                     02      mov ah, #0x02 ;; function 2, read diskette sector
31792 88B5           B0                     01      mov al, #0x01 ;; read 1 sector
31793 88B7           B5                     00      mov ch, #0x00 ;; track 0
31794 88B9           B1                     01      mov cl, #0x01 ;; sector 1
31795 88BB           B6                     00      mov dh, #0x00 ;; head 0
31796 88BD           CD                     13      int #0x13 ;; read sector
31797 88BF           73           06                jnc int19_load_done
31798 88C1           B8                   0001      mov ax, #0x0001
31799 88C4           8946         14                mov _int19_function.status + 2[bp], ax
31800                       000088C7            int19_load_done:
31801 88C7           5A                             pop dx
31802 88C8           59                             pop cx
31803 88C9           5B                             pop bx
31804 88CA           58                             pop ax
31805 88CB           5D                             pop bp
31806                                           ! 5389 endasm
31807                                           !BCC_ENDASM
31808                                           !BCC_EOS
31809                                           ! 5390     if (status != 0) {
31810                                           ! Debug: ne int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
31811 88CC           8B46         F4            mov	ax,-$C[bp]
31812 88CF           85C0                       test	ax,ax
31813 88D1           74           11            je  	.791
31814                       000088D3            .792:
31815                                           ! 5391       print_boot_failure(e.type, 1);
31816                                           ! Debug: list int = const 1 (used reg = )
31817 88D3           B8                   0001  mov	ax,*1
31818 88D6           50                         push	ax
31819                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
31820 88D7           FF76         E2            push	-$1E[bp]
31821                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
31822 88DA           E8         8DA4            call	_print_boot_failure
31823 88DD           83C4                   04  add	sp,*4
31824                                           !BCC_EOS
31825                                           ! 5392       return;
31826 88E0           89EC                       mov	sp,bp
31827 88E2           5D                         pop	bp
31828 88E3           C3                         ret
31829                                           !BCC_EOS
31830                                           ! 5393     }
31831                                           ! 5394     if ((e.type != 0x01) || !((inb_cmos(0x38) & 0x01))) {
31832                       000088E4            .791:
31833                                           ! Debug: ne int = const 1 to unsigned short e = [S+$20-$20] (used reg = )
31834 88E4           8B46         E2            mov	ax,-$1E[bp]
31835 88E7           3D                   0001  cmp	ax,*1
31836 88EA           75           0F            jne 	.794
31837                       000088EC            .795:
31838                                           ! Debug: list int = const $38 (used reg = )
31839 88EC           B8                   0038  mov	ax,*$38
31840 88EF           50                         push	ax
31841                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
31842 88F0           E8         7C4A            call	_inb_cmos
31843 88F3           44                         inc	sp
31844 88F4           44                         inc	sp
31845                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
31846 88F5           24                     01  and	al,*1
31847 88F7           84C0                       test	al,al
31848 88F9           75           22            jne 	.793
31849                       000088FB            .794:
31850                                           ! 5395       if (_read_word(0x1fe, bootseg) != 0xaa55) {
31851                                           ! Debug: list unsigned short bootseg = [S+$20-$A] (used reg = )
31852 88FB           FF76         F8            push	-8[bp]
31853                                           ! Debug: list int = const $1FE (used reg = )
31854 88FE           B8                   01FE  mov	ax,#$1FE
31855 8901           50                         push	ax
31856                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
31857 8902           E8         7CED            call	__read_word
31858 8905           83C4                   04  add	sp,*4
31859                                           ! Debug: ne unsigned int = const $AA55 to unsigned short = ax+0 (used reg = )
31860 8908           3D                   AA55  cmp	ax,#$AA55
31861 890B           74           10            je  	.796
31862                       0000890D            .797:
31863                                           ! 5396         print_boot_failure(e.type, 0);
31864                                           ! Debug: list int = const 0 (used reg = )
31865 890D           31C0                       xor	ax,ax
31866 890F           50                         push	ax
31867                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
31868 8910           FF76         E2            push	-$1E[bp]
31869                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
31870 8913           E8         8D6B            call	_print_boot_failure
31871 8916           83C4                   04  add	sp,*4
31872                                           !BCC_EOS
31873                                           ! 5397         return;
31874 8919           89EC                       mov	sp,bp
31875 891B           5D                         pop	bp
31876 891C           C3                         ret
31877                                           !BCC_EOS
31878                                           ! 5398       }
31879                                           ! 5399     }
31880                       0000891D            .796:
31881                                           ! 5400     bootip = (bootseg & 0x0fff) << 4;
31882                       0000891D            .793:
31883                                           ! Debug: and int = const $FFF to unsigned short bootseg = [S+$20-$A] (used reg = )
31884 891D           8B46         F8            mov	ax,-8[bp]
31885 8920           25                   0FFF  and	ax,#$FFF
31886                                           ! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
31887 8923           B1                     04  mov	cl,*4
31888 8925           D3E0                       shl	ax,cl
31889                                           ! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$20-$C] (used reg = )
31890 8927           8946         F6            mov	-$A[bp],ax
31891                                           !BCC_EOS
31892                                           ! 5401     bootseg &= 0xf000;
31893                                           ! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$20-$A] (used reg = )
31894 892A           8B46         F8            mov	ax,-8[bp]
31895 892D           25                   F000  and	ax,#$F000
31896 8930           8946         F8            mov	-8[bp],ax
31897                                           !BCC_EOS
31898                                           ! 5402   break;
31899 8933           EB           71            jmp .789
31900                                           !BCC_EOS
31901                                           ! 5403   case 0x03:
31902                                           ! 5404     status = cdrom_boot();
31903                       00008935            .798:
31904                                           ! Debug: func () unsigned short = cdrom_boot+0 (used reg = )
31905 8935           E8         AC80            call	_cdrom_boot
31906                                           ! Debug: eq unsigned short = ax+0 to unsigned short status = [S+$20-$E] (used reg = )
31907 8938           8946         F4            mov	-$C[bp],ax
31908                                           !BCC_EOS
31909                                           ! 5405     if ( (status & 0x00ff) !=0 ) {
31910                                           ! Debug: and int = const $FF to unsigned short status = [S+$20-$E] (used reg = )
31911 893B           8A46         F4            mov	al,-$C[bp]
31912                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
31913 893E           84C0                       test	al,al
31914 8940           74           19            je  	.799
31915                       00008942            .79A:
31916                                           ! 5406       print_cdromboot_failure(status);
31917                                           ! Debug: list unsigned short status = [S+$20-$E] (used reg = )
31918 8942           FF76         F4            push	-$C[bp]
31919                                           ! Debug: func () void = print_cdromboot_failure+0 (used reg = )
31920 8945           E8         8D9F            call	_print_cdromboot_failure
31921 8948           44                         inc	sp
31922 8949           44                         inc	sp
31923                                           !BCC_EOS
31924                                           ! 5407       print_boot_failure(e.type, 1);
31925                                           ! Debug: list int = const 1 (used reg = )
31926 894A           B8                   0001  mov	ax,*1
31927 894D           50                         push	ax
31928                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
31929 894E           FF76         E2            push	-$1E[bp]
31930                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
31931 8951           E8         8D2D            call	_print_boot_failure
31932 8954           83C4                   04  add	sp,*4
31933                                           !BCC_EOS
31934                                           ! 5408       return;
31935 8957           89EC                       mov	sp,bp
31936 8959           5D                         pop	bp
31937 895A           C3                         ret
31938                                           !BCC_EOS
31939                                           ! 5409     }
31940                                           ! 5410     bootdrv = *(((Bit8u *)&status)+1);
31941                       0000895B            .799:
31942                                           ! Debug: eq unsigned char status = [S+$20-$D] to unsigned char bootdrv = [S+$20-7] (used reg = )
31943 895B           8A46         F5            mov	al,-$B[bp]
31944 895E           8846         FB            mov	-5[bp],al
31945                                           !BCC_EOS
31946                                           ! 5411     bootseg = _read_word(&((ebda_data_t *) 0)->cdemu.load_segment, ebda_seg);
31947                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
31948 8961           FF76         FE            push	-2[bp]
31949                                           ! Debug: list * unsigned short = const $266 (used reg = )
31950 8964           B8                   0266  mov	ax,#$266
31951 8967           50                         push	ax
31952                                           ! Debug: func () unsigned short = _read_word+0 (used reg = )
31953 8968           E8         7C87            call	__read_word
31954 896B           83C4                   04  add	sp,*4
31955                                           ! Debug: eq unsigned short = ax+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
31956 896E           8946         F8            mov	-8[bp],ax
31957                                           !BCC_EOS
31958                                           ! 5412     bootip = 0;
31959                                           ! Debug: eq int = const 0 to unsigned short bootip = [S+$20-$C] (used reg = )
31960 8971           31C0                       xor	ax,ax
31961 8973           8946         F6            mov	-$A[bp],ax
31962                                           !BCC_EOS
31963                                           ! 5413     break;
31964 8976           EB           2E            jmp .789
31965                                           !BCC_EOS
31966                                           ! 5414   case 0x80:
31967                                           ! 5415     bootseg = *(((Bit16u *)&e.vector)+1);
31968                       00008978            .79B:
31969                                           ! Debug: eq unsigned short e = [S+$20-$1A] to unsigned short bootseg = [S+$20-$A] (used reg = )
31970 8978           8B46         E8            mov	ax,-$18[bp]
31971 897B           8946         F8            mov	-8[bp],ax
31972                                           !BCC_EOS
31973                                           ! 5416     bootip = *((Bit16u *)&e.vector);
31974                                           ! Debug: eq unsigned short e = [S+$20-$1C] to unsigned short bootip = [S+$20-$C] (used reg = )
31975 897E           8B46         E6            mov	ax,-$1A[bp]
31976 8981           8946         F6            mov	-$A[bp],ax
31977                                           !BCC_EOS
31978                                           ! 5417     break;
31979 8984           EB           20            jmp .789
31980                                           !BCC_EOS
31981                                           ! 5418   default: return;
31982                       00008986            .79C:
31983 8986           89EC                       mov	sp,bp
31984 8988           5D                         pop	bp
31985 8989           C3                         ret
31986                                           !BCC_EOS
31987                                           ! 5419   }
31988                                           ! 5420   bios_printf(4, "Booting from %x:%x\n", bootseg, bootip);
31989 898A           EB           1A            jmp .789
31990                       0000898C            .78B:
31991 898C           2D                   0001  sub	ax,*1
31992 898F         0F84         FEF3            beq 	.78C
31993 8993           2D                   0001  sub	ax,*1
31994 8996         0F84         FEEC            beq 	.78D
31995 899A           2D                   0001  sub	ax,*1
31996 899D           74           96            je 	.798
31997 899F           2D                   007D  sub	ax,*$7D
31998 89A2           74           D4            je 	.79B
31999 89A4           EB           E0            jmp	.79C
32000                       000089A6            .789:
32001                       FFFFFFE0            ..FFD9	=	-$20
32002                                           ! Debug: list unsigned short bootip = [S+$20-$C] (used reg = )
32003 89A6           FF76         F6            push	-$A[bp]
32004                                           ! Debug: list unsigned short bootseg = [S+$22-$A] (used reg = )
32005 89A9           FF76         F8            push	-8[bp]
32006                                           ! Debug: list * char = .79D+0 (used reg = )
32007 89AC           BB                   CCE1  mov	bx,#.79D
32008 89AF           53                         push	bx
32009                                           ! Debug: list int = const 4 (used reg = )
32010 89B0           B8                   0004  mov	ax,*4
32011 89B3           50                         push	ax
32012                                           ! Debug: func () void = bios_printf+0 (used reg = )
32013 89B4           E8         7F87            call	_bios_printf
32014 89B7           83C4                   08  add	sp,*8
32015                                           !BCC_EOS
32016                                           ! 5421 #asm
32017                                           !BCC_EOS
32018                                           !BCC_ASM
32019                       00000014            _int19_function.bootip	set	$14
32020                       FFFFFFF6            .int19_function.bootip	set	-$A
32021                       00000022            _int19_function.seq_nr	set	$22
32022                       00000004            .int19_function.seq_nr	set	4
32023                       00000018            _int19_function.bootchk	set	$18
32024                       FFFFFFFA            .int19_function.bootchk	set	-6
32025                       00000016            _int19_function.bootseg	set	$16
32026                       FFFFFFF8            .int19_function.bootseg	set	-8
32027                       0000001C            _int19_function.ebda_seg	set	$1C
32028                       FFFFFFFE            .int19_function.ebda_seg	set	-2
32029                       00000012            _int19_function.status	set	$12
32030                       FFFFFFF4            .int19_function.status	set	-$C
32031                       00000010            _int19_function.bootfirst	set	$10
32032                       FFFFFFF2            .int19_function.bootfirst	set	-$E
32033                       00000019            _int19_function.bootdrv	set	$19
32034                       FFFFFFFB            .int19_function.bootdrv	set	-5
32035                       0000001A            _int19_function.bootdev	set	$1A
32036                       FFFFFFFC            .int19_function.bootdev	set	-4
32037                       00000000            _int19_function.e	set	0
32038                       FFFFFFE2            .int19_function.e	set	-$1E
32039 89BA           89E5                           mov bp, sp
32040 89BC           0E                             push cs
32041 89BD           68                   9270      push #int18_handler
32042                                               ;; Build an iret stack frame that will take us to the boot vector.
32043                                               ;; iret pops ip, then cs, then flags, so push them in the opposite order.
32044 89C0           9C                             pushf
32045 89C1           8B46         16                mov ax, _int19_function.bootseg + 0[bp]
32046 89C4           50                             push ax
32047 89C5           8B46         14                mov ax, _int19_function.bootip + 0[bp]
32048 89C8           50                             push ax
32049                                               ;; Set the magic number in ax and the boot drive in dl.
32050 89C9           B8                   AA55      mov ax, #0xaa55
32051 89CC           8A56         19                mov dl, _int19_function.bootdrv + 0[bp]
32052                                               ;; Zero some of the other registers.
32053 89CF           31DB                           xor bx, bx
32054 89D1           8EDB                           mov ds, bx
32055 89D3           8EC3                           mov es, bx
32056 89D5           89DD                           mov bp, bx
32057                                               ;; Go!
32058 89D7           CF                             iret
32059                                           ! 5442 endasm
32060                                           !BCC_ENDASM
32061                                           !BCC_EOS
32062                                           ! 5443 }
32063 89D8           89EC                       mov	sp,bp
32064 89DA           5D                         pop	bp
32065 89DB           C3                         ret
32066                                           ! 5444   void
32067                                           ! Register BX used in function int19_function
32068                                           ! 5445 int1a_function(regs, ds, iret_addr)
32069                                           ! 5446   pusha_regs_t regs;
32070                                           export	_int1a_function
32071                       000089DC            _int1a_function:
32072                                           !BCC_EOS
32073                                           ! 5447   Bit16u ds;
32074                                           !BCC_EOS
32075                                           ! 5448   iret_addr_t iret_addr;
32076                                           !BCC_EOS
32077                                           ! 5449 {
32078                                           ! 5450   Bit8u val8,hr;
32079                                           !BCC_EOS
32080                                           ! 5451   ;
32081 89DC           55                         push	bp
32082 89DD           89E5                       mov	bp,sp
32083 89DF           4C                         dec	sp
32084 89E0           4C                         dec	sp
32085                                           !BCC_EOS
32086                                           ! 5452 #asm
32087                                           !BCC_EOS
32088                                           !BCC_ASM
32089                       00000016            _int1a_function.ds	set	$16
32090                       00000014            .int1a_function.ds	set	$14
32091                       00000000            _int1a_function.hr	set	0
32092                       FFFFFFFE            .int1a_function.hr	set	-2
32093                       00000001            _int1a_function.val8	set	1
32094                       FFFFFFFF            .int1a_function.val8	set	-1
32095                       00000018            _int1a_function.iret_addr	set	$18
32096                       00000016            .int1a_function.iret_addr	set	$16
32097                       00000006            _int1a_function.regs	set	6
32098                       00000004            .int1a_function.regs	set	4
32099 89E1           FB                           sti
32100                                           ! 5454 endasm
32101                                           !BCC_ENDASM
32102                                           !BCC_EOS
32103                                           ! 5455   switch (regs.u.r8.ah) {
32104 89E2           8A46         13            mov	al,$13[bp]
32105 89E5           E9         069C            br 	.7A0
32106                                           ! 5456     case 0:
32107                                           ! 5457 #asm
32108                       000089E8            .7A1:
32109                                           !BCC_EOS
32110                                           !BCC_ASM
32111                       00000016            _int1a_function.ds	set	$16
32112                       00000014            .int1a_function.ds	set	$14
32113                       00000000            _int1a_function.hr	set	0
32114                       FFFFFFFE            .int1a_function.hr	set	-2
32115                       00000001            _int1a_function.val8	set	1
32116                       FFFFFFFF            .int1a_function.val8	set	-1
32117                       00000018            _int1a_function.iret_addr	set	$18
32118                       00000016            .int1a_function.iret_addr	set	$16
32119                       00000006            _int1a_function.regs	set	6
32120                       00000004            .int1a_function.regs	set	4
32121 89E8           FA                               cli
32122                                           ! 5459 endasm
32123                                           !BCC_ENDASM
32124                                           !BCC_EOS
32125                                           ! 5460       regs.u.r16.cx = ((bios_data_t *) 0)->ticks_high;
32126                                           ! Debug: eq unsigned short = [+$46E] to unsigned short regs = [S+4+$E] (used reg = )
32127 89E9           A1         046E            mov	ax,[$46E]
32128 89EC           8946         10            mov	$10[bp],ax
32129                                           !BCC_EOS
32130                                           ! 5461       regs.u.r16.dx = ((bios_data_t *) 0)->ticks_low;
32131                                           ! Debug: eq unsigned short = [+$46C] to unsigned short regs = [S+4+$C] (used reg = )
32132 89EF           A1         046C            mov	ax,[$46C]
32133 89F2           8946         0E            mov	$E[bp],ax
32134                                           !BCC_EOS
32135                                           ! 5462       regs.u.r8.al = ((bios_data_t *) 0)->midnight_flag;
32136                                           ! Debug: eq unsigned char = [+$470] to unsigned char regs = [S+4+$10] (used reg = )
32137 89F5           A0         0470            mov	al,[$470]
32138 89F8           8846         12            mov	$12[bp],al
32139                                           !BCC_EOS
32140                                           ! 5463       ((bios_data_t *) 0)->midnight_flag = 0;
32141                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
32142 89FB           30C0                       xor	al,al
32143 89FD           A2         0470            mov	[$470],al
32144                                           !BCC_EOS
32145                                           ! 5464 #asm
32146                                           !BCC_EOS
32147                                           !BCC_ASM
32148                       00000016            _int1a_function.ds	set	$16
32149                       00000014            .int1a_function.ds	set	$14
32150                       00000000            _int1a_function.hr	set	0
32151                       FFFFFFFE            .int1a_function.hr	set	-2
32152                       00000001            _int1a_function.val8	set	1
32153                       FFFFFFFF            .int1a_function.val8	set	-1
32154                       00000018            _int1a_function.iret_addr	set	$18
32155                       00000016            .int1a_function.iret_addr	set	$16
32156                       00000006            _int1a_function.regs	set	6
32157                       00000004            .int1a_function.regs	set	4
32158 8A00           FB                               sti
32159                                           ! 5466 endasm
32160                                           !BCC_ENDASM
32161                                           !BCC_EOS
32162                                           ! 5467       iret_addr.flags.u.r8.flagsl &= 0xfe;
32163                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32164 8A01           8A46         1A            mov	al,$1A[bp]
32165 8A04           24                     FE  and	al,#$FE
32166 8A06           8846         1A            mov	$1A[bp],al
32167                                           !BCC_EOS
32168                                           ! 5468       break;
32169 8A09           E9         06A3            br 	.79E
32170                                           !BCC_EOS
32171                                           ! 5469     case 1:
32172                                           ! 5470 #asm
32173                       00008A0C            .7A2:
32174                                           !BCC_EOS
32175                                           !BCC_ASM
32176                       00000016            _int1a_function.ds	set	$16
32177                       00000014            .int1a_function.ds	set	$14
32178                       00000000            _int1a_function.hr	set	0
32179                       FFFFFFFE            .int1a_function.hr	set	-2
32180                       00000001            _int1a_function.val8	set	1
32181                       FFFFFFFF            .int1a_function.val8	set	-1
32182                       00000018            _int1a_function.iret_addr	set	$18
32183                       00000016            .int1a_function.iret_addr	set	$16
32184                       00000006            _int1a_function.regs	set	6
32185                       00000004            .int1a_function.regs	set	4
32186 8A0C           FA                               cli
32187                                           ! 5472 endasm
32188                                           !BCC_ENDASM
32189                                           !BCC_EOS
32190                                           ! 5473       ((bios_data_t *) 0)->ticks_high = regs.u.r16.cx;
32191                                           ! Debug: eq unsigned short regs = [S+4+$E] to unsigned short = [+$46E] (used reg = )
32192 8A0D           8B46         10            mov	ax,$10[bp]
32193 8A10           A3         046E            mov	[$46E],ax
32194                                           !BCC_EOS
32195                                           ! 5474       ((bios_data_t *) 0)->ticks_low = regs.u.r16.dx;
32196                                           ! Debug: eq unsigned short regs = [S+4+$C] to unsigned short = [+$46C] (used reg = )
32197 8A13           8B46         0E            mov	ax,$E[bp]
32198 8A16           A3         046C            mov	[$46C],ax
32199                                           !BCC_EOS
32200                                           ! 5475       ((bios_data_t *) 0)->midnight_flag = 0;
32201                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
32202 8A19           30C0                       xor	al,al
32203 8A1B           A2         0470            mov	[$470],al
32204                                           !BCC_EOS
32205                                           ! 5476 #asm
32206                                           !BCC_EOS
32207                                           !BCC_ASM
32208                       00000016            _int1a_function.ds	set	$16
32209                       00000014            .int1a_function.ds	set	$14
32210                       00000000            _int1a_function.hr	set	0
32211                       FFFFFFFE            .int1a_function.hr	set	-2
32212                       00000001            _int1a_function.val8	set	1
32213                       FFFFFFFF            .int1a_function.val8	set	-1
32214                       00000018            _int1a_function.iret_addr	set	$18
32215                       00000016            .int1a_function.iret_addr	set	$16
32216                       00000006            _int1a_function.regs	set	6
32217                       00000004            .int1a_function.regs	set	4
32218 8A1E           FB                               sti
32219                                           ! 5478 endasm
32220                                           !BCC_ENDASM
32221                                           !BCC_EOS
32222                                           ! 5479       regs.u.r8.ah = 0;
32223                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
32224 8A1F           30C0                       xor	al,al
32225 8A21           8846         13            mov	$13[bp],al
32226                                           !BCC_EOS
32227                                           ! 5480       iret_addr.flags.u.r8.flagsl &= 0xfe;
32228                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32229 8A24           8A46         1A            mov	al,$1A[bp]
32230 8A27           24                     FE  and	al,#$FE
32231 8A29           8846         1A            mov	$1A[bp],al
32232                                           !BCC_EOS
32233                                           ! 5481       break;
32234 8A2C           E9         0680            br 	.79E
32235                                           !BCC_EOS
32236                                           ! 5482     case 2:
32237                                           ! 5483       if (rtc_updating()) {
32238                       00008A2F            .7A3:
32239                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
32240 8A2F           E8         7B48            call	_rtc_updating
32241 8A32           85C0                       test	ax,ax
32242 8A34           74           0B            je  	.7A4
32243                       00008A36            .7A5:
32244                                           ! 5484         iret_addr.flags.u.r8.flagsl |= 0x01;
32245                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
32246 8A36           8A46         1A            mov	al,$1A[bp]
32247 8A39           0C                     01  or	al,*1
32248 8A3B           8846         1A            mov	$1A[bp],al
32249                                           !BCC_EOS
32250                                           ! 5485         break;
32251 8A3E           E9         066E            br 	.79E
32252                                           !BCC_EOS
32253                                           ! 5486       }
32254                                           ! 5487       val8 = inb_cmos(0x0b);
32255                       00008A41            .7A4:
32256                                           ! Debug: list int = const $B (used reg = )
32257 8A41           B8                   000B  mov	ax,*$B
32258 8A44           50                         push	ax
32259                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32260 8A45           E8         7AF5            call	_inb_cmos
32261 8A48           44                         inc	sp
32262 8A49           44                         inc	sp
32263                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
32264 8A4A           8846         FF            mov	-1[bp],al
32265                                           !BCC_EOS
32266                                           ! 5488       if(val8&0x04){
32267                                           ! Debug: and int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
32268 8A4D           8A46         FF            mov	al,-1[bp]
32269 8A50           24                     04  and	al,*4
32270 8A52           84C0                       test	al,al
32271 8A54         0F84         0085            beq 	.7A6
32272                       00008A58            .7A7:
32273                                           ! 5489         regs.u.r8.dh = bin2bcd(inb_cmos(0x00));
32274                                           ! Debug: list int = const 0 (used reg = )
32275 8A58           31C0                       xor	ax,ax
32276 8A5A           50                         push	ax
32277                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32278 8A5B           E8         7ADF            call	_inb_cmos
32279 8A5E           44                         inc	sp
32280 8A5F           44                         inc	sp
32281                                           ! Debug: list unsigned char = al+0 (used reg = )
32282 8A60           30E4                       xor	ah,ah
32283 8A62           50                         push	ax
32284                                           ! Debug: func () unsigned char = bin2bcd+0 (used reg = )
32285 8A63           E8         7B48            call	_bin2bcd
32286 8A66           44                         inc	sp
32287 8A67           44                         inc	sp
32288                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
32289 8A68           8846         0F            mov	$F[bp],al
32290                                           !BCC_EOS
32291                                           ! 5490         regs.u.r8.cl = bin2bcd(inb_cmos(0x02));
32292                                           ! Debug: list int = const 2 (used reg = )
32293 8A6B           B8                   0002  mov	ax,*2
32294 8A6E           50                         push	ax
32295                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32296 8A6F           E8         7ACB            call	_inb_cmos
32297 8A72           44                         inc	sp
32298 8A73           44                         inc	sp
32299                                           ! Debug: list unsigned char = al+0 (used reg = )
32300 8A74           30E4                       xor	ah,ah
32301 8A76           50                         push	ax
32302                                           ! Debug: func () unsigned char = bin2bcd+0 (used reg = )
32303 8A77           E8         7B34            call	_bin2bcd
32304 8A7A           44                         inc	sp
32305 8A7B           44                         inc	sp
32306                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
32307 8A7C           8846         10            mov	$10[bp],al
32308                                           !BCC_EOS
32309                                           ! 5491         hr = inb_cmos(0x04);
32310                                           ! Debug: list int = const 4 (used reg = )
32311 8A7F           B8                   0004  mov	ax,*4
32312 8A82           50                         push	ax
32313                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32314 8A83           E8         7AB7            call	_inb_cmos
32315 8A86           44                         inc	sp
32316 8A87           44                         inc	sp
32317                                           ! Debug: eq unsigned char = al+0 to unsigned char hr = [S+4-4] (used reg = )
32318 8A88           8846         FE            mov	-2[bp],al
32319                                           !BCC_EOS
32320                                           ! 5492         if((val8&0x02)&&(hr&0x80)) hr = (hr & 0x7f) + 12;
32321                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
32322 8A8B           8A46         FF            mov	al,-1[bp]
32323 8A8E           24                     02  and	al,*2
32324 8A90           84C0                       test	al,al
32325 8A92           74           16            je  	.7A8
32326                       00008A94            .7AA:
32327                                           ! Debug: and int = const $80 to unsigned char hr = [S+4-4] (used reg = )
32328 8A94           8A46         FE            mov	al,-2[bp]
32329 8A97           24                     80  and	al,#$80
32330 8A99           84C0                       test	al,al
32331 8A9B           74           0D            je  	.7A8
32332                       00008A9D            .7A9:
32333                                           ! Debug: and int = const $7F to unsigned char hr = [S+4-4] (used reg = )
32334 8A9D           8A46         FE            mov	al,-2[bp]
32335 8AA0           24                     7F  and	al,*$7F
32336                                           ! Debug: add int = const $C to unsigned char = al+0 (used reg = )
32337 8AA2           30E4                       xor	ah,ah
32338                                           ! Debug: eq unsigned int = ax+$C to unsigned char hr = [S+4-4] (used reg = )
32339 8AA4           05                   000C  add	ax,*$C
32340 8AA7           8846         FE            mov	-2[bp],al
32341                                           !BCC_EOS
32342                                           ! 5493         if((val8&0x02)&&(!(hr%12))) hr -= 12;
32343                       00008AAA            .7A8:
32344                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
32345 8AAA           8A46         FF            mov	al,-1[bp]
32346 8AAD           24                     02  and	al,*2
32347 8AAF           84C0                       test	al,al
32348 8AB1           74           1A            je  	.7AB
32349                       00008AB3            .7AD:
32350                                           ! Debug: mod int = const $C to unsigned char hr = [S+4-4] (used reg = )
32351 8AB3           8A46         FE            mov	al,-2[bp]
32352 8AB6           30E4                       xor	ah,ah
32353 8AB8           BB                   000C  mov	bx,*$C
32354 8ABB           E8         76A7            call	imodu
32355 8ABE           85C0                       test	ax,ax
32356 8AC0           75           0B            jne 	.7AB
32357                       00008AC2            .7AC:
32358                                           ! Debug: subab int = const $C to unsigned char hr = [S+4-4] (used reg = )
32359 8AC2           8A46         FE            mov	al,-2[bp]
32360 8AC5           30E4                       xor	ah,ah
32361 8AC7           05                   FFF4  add	ax,*-$C
32362 8ACA           8846         FE            mov	-2[bp],al
32363                                           !BCC_EOS
32364                                           ! 5494         regs.u.r8.ch = bin2bcd(hr);
32365                       00008ACD            .7AB:
32366                                           ! Debug: list unsigned char hr = [S+4-4] (used reg = )
32367 8ACD           8A46         FE            mov	al,-2[bp]
32368 8AD0           30E4                       xor	ah,ah
32369 8AD2           50                         push	ax
32370                                           ! Debug: func () unsigned char = bin2bcd+0 (used reg = )
32371 8AD3           E8         7AD8            call	_bin2bcd
32372 8AD6           44                         inc	sp
32373 8AD7           44                         inc	sp
32374                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
32375 8AD8           8846         11            mov	$11[bp],al
32376                                           !BCC_EOS
32377                                           ! 5495       }else{
32378 8ADB           EB           6B            jmp .7AE
32379                       00008ADD            .7A6:
32380                                           ! 5496         regs.u.r8.dh = inb_cmos(0x00);
32381                                           ! Debug: list int = const 0 (used reg = )
32382 8ADD           31C0                       xor	ax,ax
32383 8ADF           50                         push	ax
32384                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32385 8AE0           E8         7A5A            call	_inb_cmos
32386 8AE3           44                         inc	sp
32387 8AE4           44                         inc	sp
32388                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
32389 8AE5           8846         0F            mov	$F[bp],al
32390                                           !BCC_EOS
32391                                           ! 5497         regs.u.r8.cl = inb_cmos(0x02);
32392                                           ! Debug: list int = const 2 (used reg = )
32393 8AE8           B8                   0002  mov	ax,*2
32394 8AEB           50                         push	ax
32395                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32396 8AEC           E8         7A4E            call	_inb_cmos
32397 8AEF           44                         inc	sp
32398 8AF0           44                         inc	sp
32399                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
32400 8AF1           8846         10            mov	$10[bp],al
32401                                           !BCC_EOS
32402                                           ! 5498         hr = inb_cmos(0x04);
32403                                           ! Debug: list int = const 4 (used reg = )
32404 8AF4           B8                   0004  mov	ax,*4
32405 8AF7           50                         push	ax
32406                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32407 8AF8           E8         7A42            call	_inb_cmos
32408 8AFB           44                         inc	sp
32409 8AFC           44                         inc	sp
32410                                           ! Debug: eq unsigned char = al+0 to unsigned char hr = [S+4-4] (used reg = )
32411 8AFD           8846         FE            mov	-2[bp],al
32412                                           !BCC_EOS
32413                                           ! 5499         if((val8&0x02)&&(hr&0x80)) hr = (hr & 0x7f) + 0x12;
32414                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
32415 8B00           8A46         FF            mov	al,-1[bp]
32416 8B03           24                     02  and	al,*2
32417 8B05           84C0                       test	al,al
32418 8B07           74           16            je  	.7AF
32419                       00008B09            .7B1:
32420                                           ! Debug: and int = const $80 to unsigned char hr = [S+4-4] (used reg = )
32421 8B09           8A46         FE            mov	al,-2[bp]
32422 8B0C           24                     80  and	al,#$80
32423 8B0E           84C0                       test	al,al
32424 8B10           74           0D            je  	.7AF
32425                       00008B12            .7B0:
32426                                           ! Debug: and int = const $7F to unsigned char hr = [S+4-4] (used reg = )
32427 8B12           8A46         FE            mov	al,-2[bp]
32428 8B15           24                     7F  and	al,*$7F
32429                                           ! Debug: add int = const $12 to unsigned char = al+0 (used reg = )
32430 8B17           30E4                       xor	ah,ah
32431                                           ! Debug: eq unsigned int = ax+$12 to unsigned char hr = [S+4-4] (used reg = )
32432 8B19           05                   0012  add	ax,*$12
32433 8B1C           8846         FE            mov	-2[bp],al
32434                                           !BCC_EOS
32435                                           ! 5500         if((val8&0x02)&&(!(hr%0x12))) hr -= 0x12;
32436                       00008B1F            .7AF:
32437                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
32438 8B1F           8A46         FF            mov	al,-1[bp]
32439 8B22           24                     02  and	al,*2
32440 8B24           84C0                       test	al,al
32441 8B26           74           1A            je  	.7B2
32442                       00008B28            .7B4:
32443                                           ! Debug: mod int = const $12 to unsigned char hr = [S+4-4] (used reg = )
32444 8B28           8A46         FE            mov	al,-2[bp]
32445 8B2B           30E4                       xor	ah,ah
32446 8B2D           BB                   0012  mov	bx,*$12
32447 8B30           E8         7632            call	imodu
32448 8B33           85C0                       test	ax,ax
32449 8B35           75           0B            jne 	.7B2
32450                       00008B37            .7B3:
32451                                           ! Debug: subab int = const $12 to unsigned char hr = [S+4-4] (used reg = )
32452 8B37           8A46         FE            mov	al,-2[bp]
32453 8B3A           30E4                       xor	ah,ah
32454 8B3C           05                   FFEE  add	ax,*-$12
32455 8B3F           8846         FE            mov	-2[bp],al
32456                                           !BCC_EOS
32457                                           ! 5501         regs.u.r8.ch = hr;
32458                       00008B42            .7B2:
32459                                           ! Debug: eq unsigned char hr = [S+4-4] to unsigned char regs = [S+4+$F] (used reg = )
32460 8B42           8A46         FE            mov	al,-2[bp]
32461 8B45           8846         11            mov	$11[bp],al
32462                                           !BCC_EOS
32463                                           ! 5502       }
32464                                           ! 5503       regs.u.r8.dl = val8 & 0x01;
32465                       00008B48            .7AE:
32466                                           ! Debug: and int = const 1 to unsigned char val8 = [S+4-3] (used reg = )
32467 8B48           8A46         FF            mov	al,-1[bp]
32468 8B4B           24                     01  and	al,*1
32469                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
32470 8B4D           8846         0E            mov	$E[bp],al
32471                                           !BCC_EOS
32472                                           ! 5504       regs.u.r8.ah = 0;
32473                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
32474 8B50           30C0                       xor	al,al
32475 8B52           8846         13            mov	$13[bp],al
32476                                           !BCC_EOS
32477                                           ! 5505       regs.u.r8.al = regs.u.r8.ch;
32478                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
32479 8B55           8A46         11            mov	al,$11[bp]
32480 8B58           8846         12            mov	$12[bp],al
32481                                           !BCC_EOS
32482                                           ! 5506       iret_addr.flags.u.r8.flagsl &= 0xfe;
32483                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32484 8B5B           8A46         1A            mov	al,$1A[bp]
32485 8B5E           24                     FE  and	al,#$FE
32486 8B60           8846         1A            mov	$1A[bp],al
32487                                           !BCC_EOS
32488                                           ! 5507       break;
32489 8B63           E9         0549            br 	.79E
32490                                           !BCC_EOS
32491                                           ! 5508     case 3:
32492                                           ! 5509       if (rtc_updating()) {
32493                       00008B66            .7B5:
32494                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
32495 8B66           E8         7A11            call	_rtc_updating
32496 8B69           85C0                       test	ax,ax
32497 8B6B           74           03            je  	.7B6
32498                       00008B6D            .7B7:
32499                                           ! 5510         init_rtc();
32500                                           ! Debug: func () void = init_rtc+0 (used reg = )
32501 8B6D           E8         79D9            call	_init_rtc
32502                                           !BCC_EOS
32503                                           ! 5511       }
32504                                           ! 5512       val8 = inb_cmos(0x0b);
32505                       00008B70            .7B6:
32506                                           ! Debug: list int = const $B (used reg = )
32507 8B70           B8                   000B  mov	ax,*$B
32508 8B73           50                         push	ax
32509                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32510 8B74           E8         79C6            call	_inb_cmos
32511 8B77           44                         inc	sp
32512 8B78           44                         inc	sp
32513                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
32514 8B79           8846         FF            mov	-1[bp],al
32515                                           !BCC_EOS
32516                                           ! 5513       if(val8 & 0x04){
32517                                           ! Debug: and int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
32518 8B7C           8A46         FF            mov	al,-1[bp]
32519 8B7F           24                     04  and	al,*4
32520 8B81           84C0                       test	al,al
32521 8B83           74           7C            je  	.7B8
32522                       00008B85            .7B9:
32523                                           ! 5514         hr = bcd2bin(regs.u.r8.ch);
32524                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
32525 8B85           8A46         11            mov	al,$11[bp]
32526 8B88           30E4                       xor	ah,ah
32527 8B8A           50                         push	ax
32528                                           ! Debug: func () unsigned char = bcd2bin+0 (used reg = )
32529 8B8B           E8         7A3D            call	_bcd2bin
32530 8B8E           44                         inc	sp
32531 8B8F           44                         inc	sp
32532                                           ! Debug: eq unsigned char = al+0 to unsigned char hr = [S+4-4] (used reg = )
32533 8B90           8846         FE            mov	-2[bp],al
32534                                           !BCC_EOS
32535                                           ! 5515         if((val8&0x02)&&(hr>=12)) hr |= 0x80;
32536                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
32537 8B93           8A46         FF            mov	al,-1[bp]
32538 8B96           24                     02  and	al,*2
32539 8B98           84C0                       test	al,al
32540 8B9A           74           0F            je  	.7BA
32541                       00008B9C            .7BC:
32542                                           ! Debug: ge int = const $C to unsigned char hr = [S+4-4] (used reg = )
32543 8B9C           8A46         FE            mov	al,-2[bp]
32544 8B9F           3C                     0C  cmp	al,*$C
32545 8BA1           72           08            jb  	.7BA
32546                       00008BA3            .7BB:
32547                                           ! Debug: orab int = const $80 to unsigned char hr = [S+4-4] (used reg = )
32548 8BA3           8A46         FE            mov	al,-2[bp]
32549 8BA6           0C                     80  or	al,#$80
32550 8BA8           8846         FE            mov	-2[bp],al
32551                                           !BCC_EOS
32552                                           ! 5516         if((val8&0x02)&&(hr==00)) hr = 12;
32553                       00008BAB            .7BA:
32554                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
32555 8BAB           8A46         FF            mov	al,-1[bp]
32556 8BAE           24                     02  and	al,*2
32557 8BB0           84C0                       test	al,al
32558 8BB2           74           0C            je  	.7BD
32559                       00008BB4            .7BF:
32560                                           ! Debug: logeq int = const 0 to unsigned char hr = [S+4-4] (used reg = )
32561 8BB4           8A46         FE            mov	al,-2[bp]
32562 8BB7           84C0                       test	al,al
32563 8BB9           75           05            jne 	.7BD
32564                       00008BBB            .7BE:
32565                                           ! Debug: eq int = const $C to unsigned char hr = [S+4-4] (used reg = )
32566 8BBB           B0                     0C  mov	al,*$C
32567 8BBD           8846         FE            mov	-2[bp],al
32568                                           !BCC_EOS
32569                                           ! 5517         outb_cmos(0x00, bcd2bin(regs.u.r8.dh));
32570                       00008BC0            .7BD:
32571                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
32572 8BC0           8A46         0F            mov	al,$F[bp]
32573 8BC3           30E4                       xor	ah,ah
32574 8BC5           50                         push	ax
32575                                           ! Debug: func () unsigned char = bcd2bin+0 (used reg = )
32576 8BC6           E8         7A02            call	_bcd2bin
32577 8BC9           44                         inc	sp
32578 8BCA           44                         inc	sp
32579                                           ! Debug: list unsigned char = al+0 (used reg = )
32580 8BCB           30E4                       xor	ah,ah
32581 8BCD           50                         push	ax
32582                                           ! Debug: list int = const 0 (used reg = )
32583 8BCE           31C0                       xor	ax,ax
32584 8BD0           50                         push	ax
32585                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32586 8BD1           E8         795A            call	_outb_cmos
32587 8BD4           83C4                   04  add	sp,*4
32588                                           !BCC_EOS
32589                                           ! 5518         outb_cmos(0x02, bcd2bin(regs.u.r8.cl));
32590                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
32591 8BD7           8A46         10            mov	al,$10[bp]
32592 8BDA           30E4                       xor	ah,ah
32593 8BDC           50                         push	ax
32594                                           ! Debug: func () unsigned char = bcd2bin+0 (used reg = )
32595 8BDD           E8         79EB            call	_bcd2bin
32596 8BE0           44                         inc	sp
32597 8BE1           44                         inc	sp
32598                                           ! Debug: list unsigned char = al+0 (used reg = )
32599 8BE2           30E4                       xor	ah,ah
32600 8BE4           50                         push	ax
32601                                           ! Debug: list int = const 2 (used reg = )
32602 8BE5           B8                   0002  mov	ax,*2
32603 8BE8           50                         push	ax
32604                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32605 8BE9           E8         7942            call	_outb_cmos
32606 8BEC           83C4                   04  add	sp,*4
32607                                           !BCC_EOS
32608                                           ! 5519         outb_cmos(0x04, hr);
32609                                           ! Debug: list unsigned char hr = [S+4-4] (used reg = )
32610 8BEF           8A46         FE            mov	al,-2[bp]
32611 8BF2           30E4                       xor	ah,ah
32612 8BF4           50                         push	ax
32613                                           ! Debug: list int = const 4 (used reg = )
32614 8BF5           B8                   0004  mov	ax,*4
32615 8BF8           50                         push	ax
32616                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32617 8BF9           E8         7932            call	_outb_cmos
32618 8BFC           83C4                   04  add	sp,*4
32619                                           !BCC_EOS
32620                                           ! 5520       }else{
32621 8BFF           EB           62            jmp .7C0
32622                       00008C01            .7B8:
32623                                           ! 5521         hr = regs.u.r8.ch;
32624                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char hr = [S+4-4] (used reg = )
32625 8C01           8A46         11            mov	al,$11[bp]
32626 8C04           8846         FE            mov	-2[bp],al
32627                                           !BCC_EOS
32628                                           ! 5522         if((val8&0x02)&&(hr>=0x12)) hr |= 0x80;
32629                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
32630 8C07           8A46         FF            mov	al,-1[bp]
32631 8C0A           24                     02  and	al,*2
32632 8C0C           84C0                       test	al,al
32633 8C0E           74           0F            je  	.7C1
32634                       00008C10            .7C3:
32635                                           ! Debug: ge int = const $12 to unsigned char hr = [S+4-4] (used reg = )
32636 8C10           8A46         FE            mov	al,-2[bp]
32637 8C13           3C                     12  cmp	al,*$12
32638 8C15           72           08            jb  	.7C1
32639                       00008C17            .7C2:
32640                                           ! Debug: orab int = const $80 to unsigned char hr = [S+4-4] (used reg = )
32641 8C17           8A46         FE            mov	al,-2[bp]
32642 8C1A           0C                     80  or	al,#$80
32643 8C1C           8846         FE            mov	-2[bp],al
32644                                           !BCC_EOS
32645                                           ! 5523         if((val8&0x02)&&(hr==0x00)) hr = 0x12;
32646                       00008C1F            .7C1:
32647                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
32648 8C1F           8A46         FF            mov	al,-1[bp]
32649 8C22           24                     02  and	al,*2
32650 8C24           84C0                       test	al,al
32651 8C26           74           0C            je  	.7C4
32652                       00008C28            .7C6:
32653                                           ! Debug: logeq int = const 0 to unsigned char hr = [S+4-4] (used reg = )
32654 8C28           8A46         FE            mov	al,-2[bp]
32655 8C2B           84C0                       test	al,al
32656 8C2D           75           05            jne 	.7C4
32657                       00008C2F            .7C5:
32658                                           ! Debug: eq int = const $12 to unsigned char hr = [S+4-4] (used reg = )
32659 8C2F           B0                     12  mov	al,*$12
32660 8C31           8846         FE            mov	-2[bp],al
32661                                           !BCC_EOS
32662                                           ! 5524         outb_cmos(0x00, regs.u.r8.dh);
32663                       00008C34            .7C4:
32664                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
32665 8C34           8A46         0F            mov	al,$F[bp]
32666 8C37           30E4                       xor	ah,ah
32667 8C39           50                         push	ax
32668                                           ! Debug: list int = const 0 (used reg = )
32669 8C3A           31C0                       xor	ax,ax
32670 8C3C           50                         push	ax
32671                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32672 8C3D           E8         78EE            call	_outb_cmos
32673 8C40           83C4                   04  add	sp,*4
32674                                           !BCC_EOS
32675                                           ! 5525         outb_cmos(0x02, regs.u.r8.cl);
32676                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
32677 8C43           8A46         10            mov	al,$10[bp]
32678 8C46           30E4                       xor	ah,ah
32679 8C48           50                         push	ax
32680                                           ! Debug: list int = const 2 (used reg = )
32681 8C49           B8                   0002  mov	ax,*2
32682 8C4C           50                         push	ax
32683                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32684 8C4D           E8         78DE            call	_outb_cmos
32685 8C50           83C4                   04  add	sp,*4
32686                                           !BCC_EOS
32687                                           ! 5526         outb_cmos(0x04, hr);
32688                                           ! Debug: list unsigned char hr = [S+4-4] (used reg = )
32689 8C53           8A46         FE            mov	al,-2[bp]
32690 8C56           30E4                       xor	ah,ah
32691 8C58           50                         push	ax
32692                                           ! Debug: list int = const 4 (used reg = )
32693 8C59           B8                   0004  mov	ax,*4
32694 8C5C           50                         push	ax
32695                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32696 8C5D           E8         78CE            call	_outb_cmos
32697 8C60           83C4                   04  add	sp,*4
32698                                           !BCC_EOS
32699                                           ! 5527       }
32700                                           ! 5528       val8 = (val8 & 0x66) | (regs.u.r8.dl & 0x01);
32701                       00008C63            .7C0:
32702                                           ! Debug: and int = const 1 to unsigned char regs = [S+4+$C] (used reg = )
32703 8C63           8A46         0E            mov	al,$E[bp]
32704 8C66           24                     01  and	al,*1
32705 8C68           50                         push	ax
32706                                           ! Debug: and int = const $66 to unsigned char val8 = [S+6-3] (used reg = )
32707 8C69           8A46         FF            mov	al,-1[bp]
32708 8C6C           24                     66  and	al,*$66
32709                                           ! Debug: or unsigned char (temp) = [S+6-6] to unsigned char = al+0 (used reg = )
32710 8C6E           0A46         FC            or	al,0+..FFD8[bp]
32711 8C71           44                         inc	sp
32712 8C72           44                         inc	sp
32713                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
32714 8C73           8846         FF            mov	-1[bp],al
32715                                           !BCC_EOS
32716                                           ! 5529       outb_cmos(0x0b, val8);
32717                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
32718 8C76           8A46         FF            mov	al,-1[bp]
32719 8C79           30E4                       xor	ah,ah
32720 8C7B           50                         push	ax
32721                                           ! Debug: list int = const $B (used reg = )
32722 8C7C           B8                   000B  mov	ax,*$B
32723 8C7F           50                         push	ax
32724                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32725 8C80           E8         78AB            call	_outb_cmos
32726 8C83           83C4                   04  add	sp,*4
32727                                           !BCC_EOS
32728                                           ! 5530       regs.u.r8.ah = 0;
32729                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
32730 8C86           30C0                       xor	al,al
32731 8C88           8846         13            mov	$13[bp],al
32732                                           !BCC_EOS
32733                                           ! 5531       regs.u.r8.al = val8;
32734                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
32735 8C8B           8A46         FF            mov	al,-1[bp]
32736 8C8E           8846         12            mov	$12[bp],al
32737                                           !BCC_EOS
32738                                           ! 5532       iret_addr.flags.u.r8.flagsl &= 0xfe;
32739                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32740 8C91           8A46         1A            mov	al,$1A[bp]
32741 8C94           24                     FE  and	al,#$FE
32742 8C96           8846         1A            mov	$1A[bp],al
32743                                           !BCC_EOS
32744                                           ! 5533       break;
32745 8C99           E9         0413            br 	.79E
32746                                           !BCC_EOS
32747                                           ! 5534     case 4:
32748                                           ! 5535       regs.u.r8.ah = 0;
32749                       00008C9C            .7C7:
32750                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
32751 8C9C           30C0                       xor	al,al
32752 8C9E           8846         13            mov	$13[bp],al
32753                                           !BCC_EOS
32754                                           ! 5536       if (rtc_updating()) {
32755                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
32756 8CA1           E8         78D6            call	_rtc_updating
32757 8CA4           85C0                       test	ax,ax
32758 8CA6           74           0B            je  	.7C8
32759                       00008CA8            .7C9:
32760                                           ! 5537         iret_addr.flags.u.r8.flagsl |= 0x01;
32761                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
32762 8CA8           8A46         1A            mov	al,$1A[bp]
32763 8CAB           0C                     01  or	al,*1
32764 8CAD           8846         1A            mov	$1A[bp],al
32765                                           !BCC_EOS
32766                                           ! 5538         break;
32767 8CB0           E9         03FC            br 	.79E
32768                                           !BCC_EOS
32769                                           ! 5539       }
32770                                           ! 5540  
32771                                           ! 5540      val8 = inb_cmos(0x0b);
32772                       00008CB3            .7C8:
32773                                           ! Debug: list int = const $B (used reg = )
32774 8CB3           B8                   000B  mov	ax,*$B
32775 8CB6           50                         push	ax
32776                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32777 8CB7           E8         7883            call	_inb_cmos
32778 8CBA           44                         inc	sp
32779 8CBB           44                         inc	sp
32780                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
32781 8CBC           8846         FF            mov	-1[bp],al
32782                                           !BCC_EOS
32783                                           ! 5541       if(val8 & 0x04){
32784                                           ! Debug: and int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
32785 8CBF           8A46         FF            mov	al,-1[bp]
32786 8CC2           24                     04  and	al,*4
32787 8CC4           84C0                       test	al,al
32788 8CC6           74           52            je  	.7CA
32789                       00008CC8            .7CB:
32790                                           ! 5542         regs.u.r8.cl = bin2bcd(inb_cmos(0x09));
32791                                           ! Debug: list int = const 9 (used reg = )
32792 8CC8           B8                   0009  mov	ax,*9
32793 8CCB           50                         push	ax
32794                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32795 8CCC           E8         786E            call	_inb_cmos
32796 8CCF           44                         inc	sp
32797 8CD0           44                         inc	sp
32798                                           ! Debug: list unsigned char = al+0 (used reg = )
32799 8CD1           30E4                       xor	ah,ah
32800 8CD3           50                         push	ax
32801                                           ! Debug: func () unsigned char = bin2bcd+0 (used reg = )
32802 8CD4           E8         78D7            call	_bin2bcd
32803 8CD7           44                         inc	sp
32804 8CD8           44                         inc	sp
32805                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
32806 8CD9           8846         10            mov	$10[bp],al
32807                                           !BCC_EOS
32808                                           ! 5543         regs.u.r8.dh = bin2bcd(inb_cmos(0x08));
32809                                           ! Debug: list int = const 8 (used reg = )
32810 8CDC           B8                   0008  mov	ax,*8
32811 8CDF           50                         push	ax
32812                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32813 8CE0           E8         785A            call	_inb_cmos
32814 8CE3           44                         inc	sp
32815 8CE4           44                         inc	sp
32816                                           ! Debug: list unsigned char = al+0 (used reg = )
32817 8CE5           30E4                       xor	ah,ah
32818 8CE7           50                         push	ax
32819                                           ! Debug: func () unsigned char = bin2bcd+0 (used reg = )
32820 8CE8           E8         78C3            call	_bin2bcd
32821 8CEB           44                         inc	sp
32822 8CEC           44                         inc	sp
32823                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
32824 8CED           8846         0F            mov	$F[bp],al
32825                                           !BCC_EOS
32826                                           ! 5544         regs.u.r8.dl = bin2bcd(inb_cmos(0x07));
32827                                           ! Debug: list int = const 7 (used reg = )
32828 8CF0           B8                   0007  mov	ax,*7
32829 8CF3           50                         push	ax
32830                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32831 8CF4           E8         7846            call	_inb_cmos
32832 8CF7           44                         inc	sp
32833 8CF8           44                         inc	sp
32834                                           ! Debug: list unsigned char = al+0 (used reg = )
32835 8CF9           30E4                       xor	ah,ah
32836 8CFB           50                         push	ax
32837                                           ! Debug: func () unsigned char = bin2bcd+0 (used reg = )
32838 8CFC           E8         78AF            call	_bin2bcd
32839 8CFF           44                         inc	sp
32840 8D00           44                         inc	sp
32841                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
32842 8D01           8846         0E            mov	$E[bp],al
32843                                           !BCC_EOS
32844                                           ! 5545         regs.u.r8.ch = bin2bcd(inb_cmos(0x32));
32845                                           ! Debug: list int = const $32 (used reg = )
32846 8D04           B8                   0032  mov	ax,*$32
32847 8D07           50                         push	ax
32848                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32849 8D08           E8         7832            call	_inb_cmos
32850 8D0B           44                         inc	sp
32851 8D0C           44                         inc	sp
32852                                           ! Debug: list unsigned char = al+0 (used reg = )
32853 8D0D           30E4                       xor	ah,ah
32854 8D0F           50                         push	ax
32855                                           ! Debug: func () unsigned char = bin2bcd+0 (used reg = )
32856 8D10           E8         789B            call	_bin2bcd
32857 8D13           44                         inc	sp
32858 8D14           44                         inc	sp
32859                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
32860 8D15           8846         11            mov	$11[bp],al
32861                                           !BCC_EOS
32862                                           ! 5546       }else{
32863 8D18           EB           30            jmp .7CC
32864                       00008D1A            .7CA:
32865                                           ! 5547         regs.u.r8.cl = inb_cmos(0x09);
32866                                           ! Debug: list int = const 9 (used reg = )
32867 8D1A           B8                   0009  mov	ax,*9
32868 8D1D           50                         push	ax
32869                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32870 8D1E           E8         781C            call	_inb_cmos
32871 8D21           44                         inc	sp
32872 8D22           44                         inc	sp
32873                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
32874 8D23           8846         10            mov	$10[bp],al
32875                                           !BCC_EOS
32876                                           ! 5548         regs.u.r8.dh = inb_cmos(0x08);
32877                                           ! Debug: list int = const 8 (used reg = )
32878 8D26           B8                   0008  mov	ax,*8
32879 8D29           50                         push	ax
32880                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32881 8D2A           E8         7810            call	_inb_cmos
32882 8D2D           44                         inc	sp
32883 8D2E           44                         inc	sp
32884                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
32885 8D2F           8846         0F            mov	$F[bp],al
32886                                           !BCC_EOS
32887                                           ! 5549         regs.u.r8.dl = inb_cmos(0x07);
32888                                           ! Debug: list int = const 7 (used reg = )
32889 8D32           B8                   0007  mov	ax,*7
32890 8D35           50                         push	ax
32891                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32892 8D36           E8         7804            call	_inb_cmos
32893 8D39           44                         inc	sp
32894 8D3A           44                         inc	sp
32895                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
32896 8D3B           8846         0E            mov	$E[bp],al
32897                                           !BCC_EOS
32898                                           ! 5550         regs.u.r8.ch = inb_cmos(0x32);
32899                                           ! Debug: list int = const $32 (used reg = )
32900 8D3E           B8                   0032  mov	ax,*$32
32901 8D41           50                         push	ax
32902                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32903 8D42           E8         77F8            call	_inb_cmos
32904 8D45           44                         inc	sp
32905 8D46           44                         inc	sp
32906                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
32907 8D47           8846         11            mov	$11[bp],al
32908                                           !BCC_EOS
32909                                           ! 5551       }
32910                                           ! 5552       regs.u.r8.al = regs.u.r8.ch;
32911                       00008D4A            .7CC:
32912                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
32913 8D4A           8A46         11            mov	al,$11[bp]
32914 8D4D           8846         12            mov	$12[bp],al
32915                                           !BCC_EOS
32916                                           ! 5553       iret_addr.flags.u.r8.flagsl &= 0xfe;
32917                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
32918 8D50           8A46         1A            mov	al,$1A[bp]
32919 8D53           24                     FE  and	al,#$FE
32920 8D55           8846         1A            mov	$1A[bp],al
32921                                           !BCC_EOS
32922                                           ! 5554       break;
32923 8D58           E9         0354            br 	.79E
32924                                           !BCC_EOS
32925                                           ! 5555     case 5:
32926                                           ! 5556       if (rtc_updating()) {
32927                       00008D5B            .7CD:
32928                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
32929 8D5B           E8         781C            call	_rtc_updating
32930 8D5E           85C0                       test	ax,ax
32931 8D60           74           0E            je  	.7CE
32932                       00008D62            .7CF:
32933                                           ! 5557         init_rtc();
32934                                           ! Debug: func () void = init_rtc+0 (used reg = )
32935 8D62           E8         77E4            call	_init_rtc
32936                                           !BCC_EOS
32937                                           ! 5558         iret_addr.flags.u.r8.flagsl |= 0x01;
32938                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
32939 8D65           8A46         1A            mov	al,$1A[bp]
32940 8D68           0C                     01  or	al,*1
32941 8D6A           8846         1A            mov	$1A[bp],al
32942                                           !BCC_EOS
32943                                           ! 5559         break;
32944 8D6D           E9         033F            br 	.79E
32945                                           !BCC_EOS
32946                                           ! 5560         }
32947                                           ! 5561       val8=inb_cmos(0x0b);
32948                       00008D70            .7CE:
32949                                           ! Debug: list int = const $B (used reg = )
32950 8D70           B8                   000B  mov	ax,*$B
32951 8D73           50                         push	ax
32952                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32953 8D74           E8         77C6            call	_inb_cmos
32954 8D77           44                         inc	sp
32955 8D78           44                         inc	sp
32956                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
32957 8D79           8846         FF            mov	-1[bp],al
32958                                           !BCC_EOS
32959                                           ! 5562       if(val8&0x04){
32960                                           ! Debug: and int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
32961 8D7C           8A46         FF            mov	al,-1[bp]
32962 8D7F           24                     04  and	al,*4
32963 8D81           84C0                       test	al,al
32964 8D83           74           62            je  	.7D0
32965                       00008D85            .7D1:
32966                                           ! 5563         outb_cmos(0x09, bcd2bin(regs.u.r8.cl));
32967                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
32968 8D85           8A46         10            mov	al,$10[bp]
32969 8D88           30E4                       xor	ah,ah
32970 8D8A           50                         push	ax
32971                                           ! Debug: func () unsigned char = bcd2bin+0 (used reg = )
32972 8D8B           E8         783D            call	_bcd2bin
32973 8D8E           44                         inc	sp
32974 8D8F           44                         inc	sp
32975                                           ! Debug: list unsigned char = al+0 (used reg = )
32976 8D90           30E4                       xor	ah,ah
32977 8D92           50                         push	ax
32978                                           ! Debug: list int = const 9 (used reg = )
32979 8D93           B8                   0009  mov	ax,*9
32980 8D96           50                         push	ax
32981                                           ! Debug: func () void = outb_cmos+0 (used reg = )
32982 8D97           E8         7794            call	_outb_cmos
32983 8D9A           83C4                   04  add	sp,*4
32984                                           !BCC_EOS
32985                                           ! 5564         outb_cmos(0x08, bcd2bin(regs.u.r8.dh));
32986                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
32987 8D9D           8A46         0F            mov	al,$F[bp]
32988 8DA0           30E4                       xor	ah,ah
32989 8DA2           50                         push	ax
32990                                           ! Debug: func () unsigned char = bcd2bin+0 (used reg = )
32991 8DA3           E8         7825            call	_bcd2bin
32992 8DA6           44                         inc	sp
32993 8DA7           44                         inc	sp
32994                                           ! Debug: list unsigned char = al+0 (used reg = )
32995 8DA8           30E4                       xor	ah,ah
32996 8DAA           50                         push	ax
32997                                           ! Debug: list int = const 8 (used reg = )
32998 8DAB           B8                   0008  mov	ax,*8
32999 8DAE           50                         push	ax
33000                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33001 8DAF           E8         777C            call	_outb_cmos
33002 8DB2           83C4                   04  add	sp,*4
33003                                           !BCC_EOS
33004                                           ! 5565         outb_cmos(0x07, bcd2bin(regs.u.r8.dl));
33005                                           ! Debug: list unsigned char regs = [S+4+$C] (used reg = )
33006 8DB5           8A46         0E            mov	al,$E[bp]
33007 8DB8           30E4                       xor	ah,ah
33008 8DBA           50                         push	ax
33009                                           ! Debug: func () unsigned char = bcd2bin+0 (used reg = )
33010 8DBB           E8         780D            call	_bcd2bin
33011 8DBE           44                         inc	sp
33012 8DBF           44                         inc	sp
33013                                           ! Debug: list unsigned char = al+0 (used reg = )
33014 8DC0           30E4                       xor	ah,ah
33015 8DC2           50                         push	ax
33016                                           ! Debug: list int = const 7 (used reg = )
33017 8DC3           B8                   0007  mov	ax,*7
33018 8DC6           50                         push	ax
33019                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33020 8DC7           E8         7764            call	_outb_cmos
33021 8DCA           83C4                   04  add	sp,*4
33022                                           !BCC_EOS
33023                                           ! 5566         outb_cmos(0x32, bcd2bin(regs.u.r8.ch));
33024                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
33025 8DCD           8A46         11            mov	al,$11[bp]
33026 8DD0           30E4                       xor	ah,ah
33027 8DD2           50                         push	ax
33028                                           ! Debug: func () unsigned char = bcd2bin+0 (used reg = )
33029 8DD3           E8         77F5            call	_bcd2bin
33030 8DD6           44                         inc	sp
33031 8DD7           44                         inc	sp
33032                                           ! Debug: list unsigned char = al+0 (used reg = )
33033 8DD8           30E4                       xor	ah,ah
33034 8DDA           50                         push	ax
33035                                           ! Debug: list int = const $32 (used reg = )
33036 8DDB           B8                   0032  mov	ax,*$32
33037 8DDE           50                         push	ax
33038                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33039 8DDF           E8         774C            call	_outb_cmos
33040 8DE2           83C4                   04  add	sp,*4
33041                                           !BCC_EOS
33042                                           ! 5567       }else{
33043 8DE5           EB           40            jmp .7D2
33044                       00008DE7            .7D0:
33045                                           ! 5568         outb_cmos(0x09, regs.u.r8.cl);
33046                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
33047 8DE7           8A46         10            mov	al,$10[bp]
33048 8DEA           30E4                       xor	ah,ah
33049 8DEC           50                         push	ax
33050                                           ! Debug: list int = const 9 (used reg = )
33051 8DED           B8                   0009  mov	ax,*9
33052 8DF0           50                         push	ax
33053                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33054 8DF1           E8         773A            call	_outb_cmos
33055 8DF4           83C4                   04  add	sp,*4
33056                                           !BCC_EOS
33057                                           ! 5569         outb_cmos(0x08, regs.u.r8.dh);
33058                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
33059 8DF7           8A46         0F            mov	al,$F[bp]
33060 8DFA           30E4                       xor	ah,ah
33061 8DFC           50                         push	ax
33062                                           ! Debug: list int = const 8 (used reg = )
33063 8DFD           B8                   0008  mov	ax,*8
33064 8E00           50                         push	ax
33065                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33066 8E01           E8         772A            call	_outb_cmos
33067 8E04           83C4                   04  add	sp,*4
33068                                           !BCC_EOS
33069                                           ! 5570         outb_cmos(0x07, regs.u.r8.dl);
33070                                           ! Debug: list unsigned char regs = [S+4+$C] (used reg = )
33071 8E07           8A46         0E            mov	al,$E[bp]
33072 8E0A           30E4                       xor	ah,ah
33073 8E0C           50                         push	ax
33074                                           ! Debug: list int = const 7 (used reg = )
33075 8E0D           B8                   0007  mov	ax,*7
33076 8E10           50                         push	ax
33077                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33078 8E11           E8         771A            call	_outb_cmos
33079 8E14           83C4                   04  add	sp,*4
33080                                           !BCC_EOS
33081                                           ! 5571         outb_cmos(0x32, regs.u.r8.ch);
33082                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
33083 8E17           8A46         11            mov	al,$11[bp]
33084 8E1A           30E4                       xor	ah,ah
33085 8E1C           50                         push	ax
33086                                           ! Debug: list int = const $32 (used reg = )
33087 8E1D           B8                   0032  mov	ax,*$32
33088 8E20           50                         push	ax
33089                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33090 8E21           E8         770A            call	_outb_cmos
33091 8E24           83C4                   04  add	sp,*4
33092                                           !BCC_EOS
33093                                           ! 5572       }
33094                                           ! 5573       val8 = val8 & 0x7f;
33095                       00008E27            .7D2:
33096                                           ! Debug: and int = const $7F to unsigned char val8 = [S+4-3] (used reg = )
33097 8E27           8A46         FF            mov	al,-1[bp]
33098 8E2A           24                     7F  and	al,*$7F
33099                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
33100 8E2C           8846         FF            mov	-1[bp],al
33101                                           !BCC_EOS
33102                                           ! 5574       outb_cmos(0x0b, val8);
33103                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
33104 8E2F           8A46         FF            mov	al,-1[bp]
33105 8E32           30E4                       xor	ah,ah
33106 8E34           50                         push	ax
33107                                           ! Debug: list int = const $B (used reg = )
33108 8E35           B8                   000B  mov	ax,*$B
33109 8E38           50                         push	ax
33110                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33111 8E39           E8         76F2            call	_outb_cmos
33112 8E3C           83C4                   04  add	sp,*4
33113                                           !BCC_EOS
33114                                           ! 5575       regs.u.r8.ah = 0;
33115                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
33116 8E3F           30C0                       xor	al,al
33117 8E41           8846         13            mov	$13[bp],al
33118                                           !BCC_EOS
33119                                           ! 5576       regs.u.r8.al = val8;
33120                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
33121 8E44           8A46         FF            mov	al,-1[bp]
33122 8E47           8846         12            mov	$12[bp],al
33123                                           !BCC_EOS
33124                                           ! 5577       iret_addr.flags.u.r8.flagsl &= 0xfe;
33125                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
33126 8E4A           8A46         1A            mov	al,$1A[bp]
33127 8E4D           24                     FE  and	al,#$FE
33128 8E4F           8846         1A            mov	$1A[bp],al
33129                                           !BCC_EOS
33130                                           ! 5578       break;
33131 8E52           E9         025A            br 	.79E
33132                                           !BCC_EOS
33133                                           ! 5579     case 6:
33134                                           ! 5580       val8 = inb_cmos(0x0b);
33135                       00008E55            .7D3:
33136                                           ! Debug: list int = const $B (used reg = )
33137 8E55           B8                   000B  mov	ax,*$B
33138 8E58           50                         push	ax
33139                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
33140 8E59           E8         76E1            call	_inb_cmos
33141 8E5C           44                         inc	sp
33142 8E5D           44                         inc	sp
33143                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
33144 8E5E           8846         FF            mov	-1[bp],al
33145                                           !BCC_EOS
33146                                           ! 5581       regs.u.r16.ax = 0;
33147                                           ! Debug: eq int = const 0 to unsigned short regs = [S+4+$10] (used reg = )
33148 8E61           31C0                       xor	ax,ax
33149 8E63           8946         12            mov	$12[bp],ax
33150                                           !BCC_EOS
33151                                           ! 5582       if (val8 & 0x20) {
33152                                           ! Debug: and int = const $20 to unsigned char val8 = [S+4-3] (used reg = )
33153 8E66           8A46         FF            mov	al,-1[bp]
33154 8E69           24                     20  and	al,*$20
33155 8E6B           84C0                       test	al,al
33156 8E6D           74           0B            je  	.7D4
33157                       00008E6F            .7D5:
33158                                           ! 5583         iret_addr.flags.u.r8.flagsl |= 0x01;
33159                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
33160 8E6F           8A46         1A            mov	al,$1A[bp]
33161 8E72           0C                     01  or	al,*1
33162 8E74           8846         1A            mov	$1A[bp],al
33163                                           !BCC_EOS
33164                                           ! 5584         break;
33165 8E77           E9         0235            br 	.79E
33166                                           !BCC_EOS
33167                                           ! 5585       }
33168                                           ! 5586       if (rtc_updating()) {
33169                       00008E7A            .7D4:
33170                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
33171 8E7A           E8         76FD            call	_rtc_updating
33172 8E7D           85C0                       test	ax,ax
33173 8E7F           74           03            je  	.7D6
33174                       00008E81            .7D7:
33175                                           ! 5587         init_rtc();
33176                                           ! Debug: func () void = init_rtc+0 (used reg = )
33177 8E81           E8         76C5            call	_init_rtc
33178                                           !BCC_EOS
33179                                           ! 5588       }
33180                                           ! 5589       if(val8&0x04){
33181                       00008E84            .7D6:
33182                                           ! Debug: and int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
33183 8E84           8A46         FF            mov	al,-1[bp]
33184 8E87           24                     04  and	al,*4
33185 8E89           84C0                       test	al,al
33186 8E8B   7503    E9         007D            je  	.7D8
33187                       00008E90            .7D9:
33188                                           ! 5590         hr = bcd2bin(regs.u.r8.ch);
33189                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
33190 8E90           8A46         11            mov	al,$11[bp]
33191 8E93           30E4                       xor	ah,ah
33192 8E95           50                         push	ax
33193                                           ! Debug: func () unsigned char = bcd2bin+0 (used reg = )
33194 8E96           E8         7732            call	_bcd2bin
33195 8E99           44                         inc	sp
33196 8E9A           44                         inc	sp
33197                                           ! Debug: eq unsigned char = al+0 to unsigned char hr = [S+4-4] (used reg = )
33198 8E9B           8846         FE            mov	-2[bp],al
33199                                           !BCC_EOS
33200                                           ! 5591         outb_cmos(0x01, bcd2bin(regs.u.r8.dh));
33201                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
33202 8E9E           8A46         0F            mov	al,$F[bp]
33203 8EA1           30E4                       xor	ah,ah
33204 8EA3           50                         push	ax
33205                                           ! Debug: func () unsigned char = bcd2bin+0 (used reg = )
33206 8EA4           E8         7724            call	_bcd2bin
33207 8EA7           44                         inc	sp
33208 8EA8           44                         inc	sp
33209                                           ! Debug: list unsigned char = al+0 (used reg = )
33210 8EA9           30E4                       xor	ah,ah
33211 8EAB           50                         push	ax
33212                                           ! Debug: list int = const 1 (used reg = )
33213 8EAC           B8                   0001  mov	ax,*1
33214 8EAF           50                         push	ax
33215                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33216 8EB0           E8         767B            call	_outb_cmos
33217 8EB3           83C4                   04  add	sp,*4
33218                                           !BCC_EOS
33219                                           ! 5592         outb_cmos(0x03, bcd2bin(regs.u.r8.cl));
33220                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
33221 8EB6           8A46         10            mov	al,$10[bp]
33222 8EB9           30E4                       xor	ah,ah
33223 8EBB           50                         push	ax
33224                                           ! Debug: func () unsigned char = bcd2bin+0 (used reg = )
33225 8EBC           E8         770C            call	_bcd2bin
33226 8EBF           44                         inc	sp
33227 8EC0           44                         inc	sp
33228                                           ! Debug: list unsigned char = al+0 (used reg = )
33229 8EC1           30E4                       xor	ah,ah
33230 8EC3           50                         push	ax
33231                                           ! Debug: list int = const 3 (used reg = )
33232 8EC4           B8                   0003  mov	ax,*3
33233 8EC7           50                         push	ax
33234                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33235 8EC8           E8         7663            call	_outb_cmos
33236 8ECB           83C4                   04  add	sp,*4
33237                                           !BCC_EOS
33238                                           ! 5593         if((val8&0x02)&&(hr>=12)) hr |= 0x80;
33239                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
33240 8ECE           8A46         FF            mov	al,-1[bp]
33241 8ED1           24                     02  and	al,*2
33242 8ED3           84C0                       test	al,al
33243 8ED5           74           0F            je  	.7DA
33244                       00008ED7            .7DC:
33245                                           ! Debug: ge int = const $C to unsigned char hr = [S+4-4] (used reg = )
33246 8ED7           8A46         FE            mov	al,-2[bp]
33247 8EDA           3C                     0C  cmp	al,*$C
33248 8EDC           72           08            jb  	.7DA
33249                       00008EDE            .7DB:
33250                                           ! Debug: orab int = const $80 to unsigned char hr = [S+4-4] (used reg = )
33251 8EDE           8A46         FE            mov	al,-2[bp]
33252 8EE1           0C                     80  or	al,#$80
33253 8EE3           8846         FE            mov	-2[bp],al
33254                                           !BCC_EOS
33255                                           ! 5594         if((val8&0x02)&&(hr==00)) hr = 12;
33256                       00008EE6            .7DA:
33257                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
33258 8EE6           8A46         FF            mov	al,-1[bp]
33259 8EE9           24                     02  and	al,*2
33260 8EEB           84C0                       test	al,al
33261 8EED           74           0C            je  	.7DD
33262                       00008EEF            .7DF:
33263                                           ! Debug: logeq int = const 0 to unsigned char hr = [S+4-4] (used reg = )
33264 8EEF           8A46         FE            mov	al,-2[bp]
33265 8EF2           84C0                       test	al,al
33266 8EF4           75           05            jne 	.7DD
33267                       00008EF6            .7DE:
33268                                           ! Debug: eq int = const $C to unsigned char hr = [S+4-4] (used reg = )
33269 8EF6           B0                     0C  mov	al,*$C
33270 8EF8           8846         FE            mov	-2[bp],al
33271                                           !BCC_EOS
33272                                           ! 5595         outb_cmos(0x05, hr);
33273                       00008EFB            .7DD:
33274                                           ! Debug: list unsigned char hr = [S+4-4] (used reg = )
33275 8EFB           8A46         FE            mov	al,-2[bp]
33276 8EFE           30E4                       xor	ah,ah
33277 8F00           50                         push	ax
33278                                           ! Debug: list int = const 5 (used reg = )
33279 8F01           B8                   0005  mov	ax,*5
33280 8F04           50                         push	ax
33281                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33282 8F05           E8         7626            call	_outb_cmos
33283 8F08           83C4                   04  add	sp,*4
33284                                           !BCC_EOS
33285                                           ! 5596       }else{
33286 8F0B           EB           63            jmp .7E0
33287                       00008F0D            .7D8:
33288                                           ! 5597         hr = regs.u.r8.ch;
33289                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char hr = [S+4-4] (used reg = )
33290 8F0D           8A46         11            mov	al,$11[bp]
33291 8F10           8846         FE            mov	-2[bp],al
33292                                           !BCC_EOS
33293                                           ! 5598         outb_cmos(0x01, regs.u.r8.dh);
33294                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
33295 8F13           8A46         0F            mov	al,$F[bp]
33296 8F16           30E4                       xor	ah,ah
33297 8F18           50                         push	ax
33298                                           ! Debug: list int = const 1 (used reg = )
33299 8F19           B8                   0001  mov	ax,*1
33300 8F1C           50                         push	ax
33301                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33302 8F1D           E8         760E            call	_outb_cmos
33303 8F20           83C4                   04  add	sp,*4
33304                                           !BCC_EOS
33305                                           ! 5599         outb_cmos(0x03, regs.u.r8.cl);
33306                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
33307 8F23           8A46         10            mov	al,$10[bp]
33308 8F26           30E4                       xor	ah,ah
33309 8F28           50                         push	ax
33310                                           ! Debug: list int = const 3 (used reg = )
33311 8F29           B8                   0003  mov	ax,*3
33312 8F2C           50                         push	ax
33313                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33314 8F2D           E8         75FE            call	_outb_cmos
33315 8F30           83C4                   04  add	sp,*4
33316                                           !BCC_EOS
33317                                           ! 5600         if((val8&0x02)&&(hr>=0x12)) hr |= 0x80;
33318                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
33319 8F33           8A46         FF            mov	al,-1[bp]
33320 8F36           24                     02  and	al,*2
33321 8F38           84C0                       test	al,al
33322 8F3A           74           0F            je  	.7E1
33323                       00008F3C            .7E3:
33324                                           ! Debug: ge int = const $12 to unsigned char hr = [S+4-4] (used reg = )
33325 8F3C           8A46         FE            mov	al,-2[bp]
33326 8F3F           3C                     12  cmp	al,*$12
33327 8F41           72           08            jb  	.7E1
33328                       00008F43            .7E2:
33329                                           ! Debug: orab int = const $80 to unsigned char hr = [S+4-4] (used reg = )
33330 8F43           8A46         FE            mov	al,-2[bp]
33331 8F46           0C                     80  or	al,#$80
33332 8F48           8846         FE            mov	-2[bp],al
33333                                           !BCC_EOS
33334                                           ! 5601         if((val8&0x02)&&(hr==0x00)) hr = 0x12;
33335                       00008F4B            .7E1:
33336                                           ! Debug: and int = const 2 to unsigned char val8 = [S+4-3] (used reg = )
33337 8F4B           8A46         FF            mov	al,-1[bp]
33338 8F4E           24                     02  and	al,*2
33339 8F50           84C0                       test	al,al
33340 8F52           74           0C            je  	.7E4
33341                       00008F54            .7E6:
33342                                           ! Debug: logeq int = const 0 to unsigned char hr = [S+4-4] (used reg = )
33343 8F54           8A46         FE            mov	al,-2[bp]
33344 8F57           84C0                       test	al,al
33345 8F59           75           05            jne 	.7E4
33346                       00008F5B            .7E5:
33347                                           ! Debug: eq int = const $12 to unsigned char hr = [S+4-4] (used reg = )
33348 8F5B           B0                     12  mov	al,*$12
33349 8F5D           8846         FE            mov	-2[bp],al
33350                                           !BCC_EOS
33351                                           ! 5602         outb_cmos(0x05, hr);
33352                       00008F60            .7E4:
33353                                           ! Debug: list unsigned char hr = [S+4-4] (used reg = )
33354 8F60           8A46         FE            mov	al,-2[bp]
33355 8F63           30E4                       xor	ah,ah
33356 8F65           50                         push	ax
33357                                           ! Debug: list int = const 5 (used reg = )
33358 8F66           B8                   0005  mov	ax,*5
33359 8F69           50                         push	ax
33360                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33361 8F6A           E8         75C1            call	_outb_cmos
33362 8F6D           83C4                   04  add	sp,*4
33363                                           !BCC_EOS
33364                                           ! 5603       }
33365                                           ! 5604       outb(0x00a1, inb(0x00a1) & 0xfe);
33366                       00008F70            .7E0:
33367                                           ! Debug: list int = const $A1 (used reg = )
33368 8F70           B8                   00A1  mov	ax,#$A1
33369 8F73           50                         push	ax
33370                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33371 8F74           E8         7581            call	_inb
33372 8F77           44                         inc	sp
33373 8F78           44                         inc	sp
33374                                           ! Debug: and int = const $FE to unsigned char = al+0 (used reg = )
33375 8F79           24                     FE  and	al,#$FE
33376                                           ! Debug: list unsigned char = al+0 (used reg = )
33377 8F7B           30E4                       xor	ah,ah
33378 8F7D           50                         push	ax
33379                                           ! Debug: list int = const $A1 (used reg = )
33380 8F7E           B8                   00A1  mov	ax,#$A1
33381 8F81           50                         push	ax
33382                                           ! Debug: func () void = outb+0 (used reg = )
33383 8F82           E8         7589            call	_outb
33384 8F85           83C4                   04  add	sp,*4
33385                                           !BCC_EOS
33386                                           ! 5605       outb_cmos(0x0b, (val8 & 0x7f) | 0x20);
33387                                           ! Debug: and int = const $7F to unsigned char val8 = [S+4-3] (used reg = )
33388 8F88           8A46         FF            mov	al,-1[bp]
33389 8F8B           24                     7F  and	al,*$7F
33390                                           ! Debug: or int = const $20 to unsigned char = al+0 (used reg = )
33391 8F8D           0C                     20  or	al,*$20
33392                                           ! Debug: list unsigned char = al+0 (used reg = )
33393 8F8F           30E4                       xor	ah,ah
33394 8F91           50                         push	ax
33395                                           ! Debug: list int = const $B (used reg = )
33396 8F92           B8                   000B  mov	ax,*$B
33397 8F95           50                         push	ax
33398                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33399 8F96           E8         7595            call	_outb_cmos
33400 8F99           83C4                   04  add	sp,*4
33401                                           !BCC_EOS
33402                                           ! 5606       i
33403                                           ! 5606 ret_addr.flags.u.r8.flagsl &= 0xfe;
33404                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
33405 8F9C           8A46         1A            mov	al,$1A[bp]
33406 8F9F           24                     FE  and	al,#$FE
33407 8FA1           8846         1A            mov	$1A[bp],al
33408                                           !BCC_EOS
33409                                           ! 5607       break;
33410 8FA4           E9         0108            br 	.79E
33411                                           !BCC_EOS
33412                                           ! 5608     case 7:
33413                                           ! 5609       val8 = inb_cmos(0x0b);
33414                       00008FA7            .7E7:
33415                                           ! Debug: list int = const $B (used reg = )
33416 8FA7           B8                   000B  mov	ax,*$B
33417 8FAA           50                         push	ax
33418                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
33419 8FAB           E8         758F            call	_inb_cmos
33420 8FAE           44                         inc	sp
33421 8FAF           44                         inc	sp
33422                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
33423 8FB0           8846         FF            mov	-1[bp],al
33424                                           !BCC_EOS
33425                                           ! 5610       outb_cmos(0x0b, val8 & 0x57);
33426                                           ! Debug: and int = const $57 to unsigned char val8 = [S+4-3] (used reg = )
33427 8FB3           8A46         FF            mov	al,-1[bp]
33428 8FB6           24                     57  and	al,*$57
33429                                           ! Debug: list unsigned char = al+0 (used reg = )
33430 8FB8           30E4                       xor	ah,ah
33431 8FBA           50                         push	ax
33432                                           ! Debug: list int = const $B (used reg = )
33433 8FBB           B8                   000B  mov	ax,*$B
33434 8FBE           50                         push	ax
33435                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33436 8FBF           E8         756C            call	_outb_cmos
33437 8FC2           83C4                   04  add	sp,*4
33438                                           !BCC_EOS
33439                                           ! 5611       regs.u.r8.ah = 0;
33440                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
33441 8FC5           30C0                       xor	al,al
33442 8FC7           8846         13            mov	$13[bp],al
33443                                           !BCC_EOS
33444                                           ! 5612       regs.u.r8.al = val8;
33445                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
33446 8FCA           8A46         FF            mov	al,-1[bp]
33447 8FCD           8846         12            mov	$12[bp],al
33448                                           !BCC_EOS
33449                                           ! 5613       iret_addr.flags.u.r8.flagsl &= 0xfe;
33450                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
33451 8FD0           8A46         1A            mov	al,$1A[bp]
33452 8FD3           24                     FE  and	al,#$FE
33453 8FD5           8846         1A            mov	$1A[bp],al
33454                                           !BCC_EOS
33455                                           ! 5614       break;
33456 8FD8           E9         00D4            br 	.79E
33457                                           !BCC_EOS
33458                                           ! 5615     case 0xb1:
33459                                           ! 5616       if (regs.u.r8.bl == 0xff) {
33460                       00008FDB            .7E8:
33461                                           ! Debug: logeq int = const $FF to unsigned char regs = [S+4+$A] (used reg = )
33462 8FDB           8A46         0C            mov	al,$C[bp]
33463 8FDE           3C                     FF  cmp	al,#$FF
33464 8FE0           75           10            jne 	.7E9
33465                       00008FE2            .7EA:
33466                                           ! 5617         bios_printf(4, "PCI BIOS: PCI not present\n");
33467                                           ! Debug: list * char = .7EB+0 (used reg = )
33468 8FE2           BB                   CCC6  mov	bx,#.7EB
33469 8FE5           53                         push	bx
33470                                           ! Debug: list int = const 4 (used reg = )
33471 8FE6           B8                   0004  mov	ax,*4
33472 8FE9           50                         push	ax
33473                                           ! Debug: func () void = bios_printf+0 (used reg = )
33474 8FEA           E8         7951            call	_bios_printf
33475 8FED           83C4                   04  add	sp,*4
33476                                           !BCC_EOS
33477                                           ! 5618       } else if (regs.u.r8.bl == 0x81) {
33478 8FF0           EB           78            jmp .7EC
33479                       00008FF2            .7E9:
33480                                           ! Debug: logeq int = const $81 to unsigned char regs = [S+4+$A] (used reg = )
33481 8FF2           8A46         0C            mov	al,$C[bp]
33482 8FF5           3C                     81  cmp	al,#$81
33483 8FF7           75           16            jne 	.7ED
33484                       00008FF9            .7EE:
33485                                           ! 5619         bios_printf(4, "unsupported PCI BIOS function 0x%02x\n", regs.u.r8.al);
33486                                           ! Debug: list unsigned char regs = [S+4+$10] (used reg = )
33487 8FF9           8A46         12            mov	al,$12[bp]
33488 8FFC           30E4                       xor	ah,ah
33489 8FFE           50                         push	ax
33490                                           ! Debug: list * char = .7EF+0 (used reg = )
33491 8FFF           BB                   CCA0  mov	bx,#.7EF
33492 9002           53                         push	bx
33493                                           ! Debug: list int = const 4 (used reg = )
33494 9003           B8                   0004  mov	ax,*4
33495 9006           50                         push	ax
33496                                           ! Debug: func () void = bios_printf+0 (used reg = )
33497 9007           E8         7934            call	_bios_printf
33498 900A           83C4                   06  add	sp,*6
33499                                           !BCC_EOS
33500                                           ! 5620       } else if (regs.u.r8.bl == 0x83) {
33501 900D           EB           5B            jmp .7F0
33502                       0000900F            .7ED:
33503                                           ! Debug: logeq int = const $83 to unsigned char regs = [S+4+$A] (used reg = )
33504 900F           8A46         0C            mov	al,$C[bp]
33505 9012           3C                     83  cmp	al,#$83
33506 9014           75           13            jne 	.7F1
33507                       00009016            .7F2:
33508                                           ! 5621         bios_printf(4, "bad PCI vendor ID %04x\n", regs.u.r16.dx);
33509                                           ! Debug: list unsigned short regs = [S+4+$C] (used reg = )
33510 9016           FF76         0E            push	$E[bp]
33511                                           ! Debug: list * char = .7F3+0 (used reg = )
33512 9019           BB                   CC88  mov	bx,#.7F3
33513 901C           53                         push	bx
33514                                           ! Debug: list int = const 4 (used reg = )
33515 901D           B8                   0004  mov	ax,*4
33516 9020           50                         push	ax
33517                                           ! Debug: func () void = bios_printf+0 (used reg = )
33518 9021           E8         791A            call	_bios_printf
33519 9024           83C4                   06  add	sp,*6
33520                                           !BCC_EOS
33521                                           ! 5622       } else if (regs.u.r8.bl == 0x86) {
33522 9027           EB           41            jmp .7F4
33523                       00009029            .7F1:
33524                                           ! Debug: logeq int = const $86 to unsigned char regs = [S+4+$A] (used reg = )
33525 9029           8A46         0C            mov	al,$C[bp]
33526 902C           3C                     86  cmp	al,#$86
33527 902E           75           3A            jne 	.7F5
33528                       00009030            .7F6:
33529                                           ! 5623         if (regs.u.r8.al == 0x02) {
33530                                           ! Debug: logeq int = const 2 to unsigned char regs = [S+4+$10] (used reg = )
33531 9030           8A46         12            mov	al,$12[bp]
33532 9033           3C                     02  cmp	al,*2
33533 9035           75           19            jne 	.7F7
33534                       00009037            .7F8:
33535                                           ! 5624           bios_printf(4, "PCI device %04x:%04x not found at index %d\n", regs.u.r16.dx, regs.u.r16.cx, regs.u.r16.si);
33536                                           ! Debug: list unsigned short regs = [S+4+4] (used reg = )
33537 9037           FF76         06            push	6[bp]
33538                                           ! Debug: list unsigned short regs = [S+6+$E] (used reg = )
33539 903A           FF76         10            push	$10[bp]
33540                                           ! Debug: list unsigned short regs = [S+8+$C] (used reg = )
33541 903D           FF76         0E            push	$E[bp]
33542                                           ! Debug: list * char = .7F9+0 (used reg = )
33543 9040           BB                   CC5C  mov	bx,#.7F9
33544 9043           53                         push	bx
33545                                           ! Debug: list int = const 4 (used reg = )
33546 9044           B8                   0004  mov	ax,*4
33547 9047           50                         push	ax
33548                                           ! Debug: func () void = bios_printf+0 (used reg = )
33549 9048           E8         78F3            call	_bios_printf
33550 904B           83C4                   0A  add	sp,*$A
33551                                           !BCC_EOS
33552                                           ! 5625         } else {
33553 904E           EB           1A            jmp .7FA
33554                       00009050            .7F7:
33555                                           ! 5626           bios_printf(4, "no PCI device with class code 0x%02x%04x found at index %d\n", regs.u.r8.cl, regs.u.r16.dx, regs.u.r16.si);
33556                                           ! Debug: list unsigned short regs = [S+4+4] (used reg = )
33557 9050           FF76         06            push	6[bp]
33558                                           ! Debug: list unsigned short regs = [S+6+$C] (used reg = )
33559 9053           FF76         0E            push	$E[bp]
33560                                           ! Debug: list unsigned char regs = [S+8+$E] (used reg = )
33561 9056           8A46         10            mov	al,$10[bp]
33562 9059           30E4                       xor	ah,ah
33563 905B           50                         push	ax
33564                                           ! Debug: list * char = .7FB+0 (used reg = )
33565 905C           BB                   CC20  mov	bx,#.7FB
33566 905F           53                         push	bx
33567                                           ! Debug: list int = const 4 (used reg = )
33568 9060           B8                   0004  mov	ax,*4
33569 9063           50                         push	ax
33570                                           ! Debug: func () void = bios_printf+0 (used reg = )
33571 9064           E8         78D7            call	_bios_printf
33572 9067           83C4                   0A  add	sp,*$A
33573                                           !BCC_EOS
33574                                           ! 5627         }
33575                                           ! 5628       }
33576                       0000906A            .7FA:
33577                                           ! 5629       regs.u.r8.ah = regs.u.r8.bl;
33578                       0000906A            .7F5:
33579                       0000906A            .7F4:
33580                       0000906A            .7F0:
33581                       0000906A            .7EC:
33582                                           ! Debug: eq unsigned char regs = [S+4+$A] to unsigned char regs = [S+4+$11] (used reg = )
33583 906A           8A46         0C            mov	al,$C[bp]
33584 906D           8846         13            mov	$13[bp],al
33585                                           !BCC_EOS
33586                                           ! 5630       iret_addr.flags.u.r8.flagsl |= 0x01;
33587                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
33588 9070           8A46         1A            mov	al,$1A[bp]
33589 9073           0C                     01  or	al,*1
33590 9075           8846         1A            mov	$1A[bp],al
33591                                           !BCC_EOS
33592                                           ! 5631       break;
33593 9078           EB           35            jmp .79E
33594                                           !BCC_EOS
33595                                           ! 5632     default:
33596                                           ! 5633       iret_addr.flags.u.r8.flagsl |= 0x01;
33597                       0000907A            .7FC:
33598                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
33599 907A           8A46         1A            mov	al,$1A[bp]
33600 907D           0C                     01  or	al,*1
33601 907F           8846         1A            mov	$1A[bp],al
33602                                           !BCC_EOS
33603                                           ! 5634   }
33604                                           ! 5635 }
33605 9082           EB           2B            jmp .79E
33606                       00009084            .7A0:
33607 9084           2C                     00  sub	al,*0
33608 9086           72           F2            jb 	.7FC
33609 9088           3C                     07  cmp	al,*7
33610 908A           77           1B            ja  	.7FD
33611 908C           30E4                       xor	ah,ah
33612 908E           D1E0                       shl	ax,*1
33613 9090           89C3                       mov	bx,ax
33614 9092           2E                         seg	cs
33615 9093           FFA7       9097            br	.7FE[bx]
33616                       00009097            .7FE:
33617 9097                      89E8            .word	.7A1
33618 9099                      8A0C            .word	.7A2
33619 909B                      8A2F            .word	.7A3
33620 909D                      8B66            .word	.7B5
33621 909F                      8C9C            .word	.7C7
33622 90A1                      8D5B            .word	.7CD
33623 90A3                      8E55            .word	.7D3
33624 90A5                      8FA7            .word	.7E7
33625                       000090A7            .7FD:
33626 90A7           2C                     B1  sub	al,#$B1
33627 90A9         0F84         FF2E            beq 	.7E8
33628 90AD           EB           CB            jmp	.7FC
33629                       000090AF            .79E:
33630                       FFFFFFFC            ..FFD8	=	-4
33631 90AF           89EC                       mov	sp,bp
33632 90B1           5D                         pop	bp
33633 90B2           C3                         ret
33634                                           ! 5636   void
33635                                           ! Register BX used in function int1a_function
33636                                           ! 5637 int70_function(regs, ds, iret_addr)
33637                                           ! 5638   pusha_regs_t regs;
33638                                           export	_int70_function
33639                       000090B3            _int70_function:
33640                                           !BCC_EOS
33641                                           ! 5639   Bit16u ds;
33642                                           !BCC_EOS
33643                                           ! 5640   iret_addr_t iret_addr;
33644                                           !BCC_EOS
33645                                           ! 5641 {
33646                                           ! 5642   Bit8u registerB = 0, registerC = 0;
33647 90B3           55                         push	bp
33648 90B4           89E5                       mov	bp,sp
33649 90B6           4C                         dec	sp
33650                                           ! Debug: eq int = const 0 to unsigned char registerB = [S+3-3] (used reg = )
33651 90B7           30C0                       xor	al,al
33652 90B9           8846         FF            mov	-1[bp],al
33653 90BC           4C                         dec	sp
33654                                           ! Debug: eq int = const 0 to unsigned char registerC = [S+4-4] (used reg = )
33655 90BD           30C0                       xor	al,al
33656 90BF           8846         FE            mov	-2[bp],al
33657                                           !BCC_EOS
33658                                           ! 5643   registerB = inb_cmos( 0xB );
33659                                           ! Debug: list int = const $B (used reg = )
33660 90C2           B8                   000B  mov	ax,*$B
33661 90C5           50                         push	ax
33662                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
33663 90C6           E8         7474            call	_inb_cmos
33664 90C9           44                         inc	sp
33665 90CA           44                         inc	sp
33666                                           ! Debug: eq unsigned char = al+0 to unsigned char registerB = [S+4-3] (used reg = )
33667 90CB           8846         FF            mov	-1[bp],al
33668                                           !BCC_EOS
33669                                           ! 5644   registerC = inb_cmos( 0xC );
33670                                           ! Debug: list int = const $C (used reg = )
33671 90CE           B8                   000C  mov	ax,*$C
33672 90D1           50                         push	ax
33673                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
33674 90D2           E8         7468            call	_inb_cmos
33675 90D5           44                         inc	sp
33676 90D6           44                         inc	sp
33677                                           ! Debug: eq unsigned char = al+0 to unsigned char registerC = [S+4-4] (used reg = )
33678 90D7           8846         FE            mov	-2[bp],al
33679                                           !BCC_EOS
33680                                           ! 5645   if( ( registerB & 0x60 ) != 0 ) {
33681                                           ! Debug: and int = const $60 to unsigned char registerB = [S+4-3] (used reg = )
33682 90DA           8A46         FF            mov	al,-1[bp]
33683 90DD           24                     60  and	al,*$60
33684                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
33685 90DF           84C0                       test	al,al
33686 90E1         0F84         00B2            beq 	.7FF
33687                       000090E5            .800:
33688                                           ! 5646     if( ( registerC & 0x20 ) != 0 ) {
33689                                           ! Debug: and int = const $20 to unsigned char registerC = [S+4-4] (used reg = )
33690 90E5           8A46         FE            mov	al,-2[bp]
33691 90E8           24                     20  and	al,*$20
33692                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
33693 90EA           84C0                       test	al,al
33694 90EC           74           04            je  	.801
33695                       000090EE            .802:
33696                                           ! 5647 #asm
33697                                           !BCC_EOS
33698                                           !BCC_ASM
33699                       00000000            _int70_function.registerC	set	0
33700                       FFFFFFFE            .int70_function.registerC	set	-2
33701                       00000016            _int70_function.ds	set	$16
33702                       00000014            .int70_function.ds	set	$14
33703                       00000001            _int70_function.registerB	set	1
33704                       FFFFFFFF            .int70_function.registerB	set	-1
33705                       00000018            _int70_function.iret_addr	set	$18
33706                       00000016            .int70_function.iret_addr	set	$16
33707                       00000006            _int70_function.regs	set	6
33708                       00000004            .int70_function.regs	set	4
33709 90EE           FB                               sti
33710 90EF           CD                     4A        int #0x4a
33711 90F1           FA                               cli
33712                                           ! 5651 endasm
33713                                           !BCC_ENDASM
33714                                           !BCC_EOS
33715                                           ! 5652     }
33716                                           ! 5653     if( ( registerC & 0x40 ) != 0 ) {
33717                       000090F2            .801:
33718                                           ! Debug: and int = const $40 to unsigned char registerC = [S+4-4] (used reg = )
33719 90F2           8A46         FE            mov	al,-2[bp]
33720 90F5           24                     40  and	al,*$40
33721                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
33722 90F7           84C0                       test	al,al
33723 90F9         0F84         009A            beq 	.803
33724                       000090FD            .804:
33725                                           ! 5654       if( *((Bit8u *)(0x4A0)) != 0 ) {
33726                                           ! Debug: ne int = const 0 to unsigned char = [+$4A0] (used reg = )
33727 90FD           A0         04A0            mov	al,[$4A0]
33728 9100           84C0                       test	al,al
33729 9102         0F84         0091            beq 	.805
33730                       00009106            .806:
33731                                           ! 5655         Bit32u time, toggle;
33732                                           !BCC_EOS
33733                                           ! 5656         time = *((Bit32u *)(0x49C));
33734 9106           83C4                   F8  add	sp,*-8
33735                                           ! Debug: eq unsigned long = [+$49C] to unsigned long time = [S+$C-8] (used reg = )
33736 9109           A1         049C            mov	ax,[$49C]
33737 910C           8B1E       049E            mov	bx,[$49E]
33738 9110           8946         FA            mov	-6[bp],ax
33739 9113           895E         FC            mov	-4[bp],bx
33740                                           !BCC_EOS
33741                                           ! 5657         if( time < 0x3D1 ) {
33742                                           ! Debug: lt unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
33743 9116           B8                   03D1  mov	ax,#$3D1
33744 9119           31DB                       xor	bx,bx
33745 911B           8D7E         FA            lea	di,-6[bp]
33746 911E           E8         6F7B            call	lcmpul
33747 9121           76           48            jbe 	.807
33748                       00009123            .808:
33749                                           ! 5658           Bit16u segment, offset;
33750                                           !BCC_EOS
33751                                           ! 5659           segment = *((Bit16u *)(0x498));
33752 9123           83C4                   FC  add	sp,*-4
33753                                           ! Debug: eq unsigned short = [+$498] to unsigned short segment = [S+$10-$E] (used reg = )
33754 9126           A1         0498            mov	ax,[$498]
33755 9129           8946         F4            mov	-$C[bp],ax
33756                                           !BCC_EOS
33757                                           ! 5660           offset = *((Bit16u *)(0x49A));
33758                                           ! Debug: eq unsigned short = [+$49A] to unsigned short offset = [S+$10-$10] (used reg = )
33759 912C           A1         049A            mov	ax,[$49A]
33760 912F           8946         F2            mov	-$E[bp],ax
33761                                           !BCC_EOS
33762                                           ! 5661           *((Bit8u *)(0x4A0)) = (0);
33763                                           ! Debug: eq int = const 0 to unsigned char = [+$4A0] (used reg = )
33764 9132           30C0                       xor	al,al
33765 9134           A2         04A0            mov	[$4A0],al
33766                                           !BCC_EOS
33767                                           ! 5662           outb_cmos( 0xB, registerB & 0x37 );
33768                                           ! Debug: and int = const $37 to unsigned char registerB = [S+$10-3] (used reg = )
33769 9137           8A46         FF            mov	al,-1[bp]
33770 913A           24                     37  and	al,*$37
33771                                           ! Debug: list unsigned char = al+0 (used reg = )
33772 913C           30E4                       xor	ah,ah
33773 913E           50                         push	ax
33774                                           ! Debug: list int = const $B (used reg = )
33775 913F           B8                   000B  mov	ax,*$B
33776 9142           50                         push	ax
33777                                           ! Debug: func () void = outb_cmos+0 (used reg = )
33778 9143           E8         73E8            call	_outb_cmos
33779 9146           83C4                   04  add	sp,*4
33780                                           !BCC_EOS
33781                                           ! 5663           _write_byte(_read_byte(offset, segment) | 0x80, offset, segment);
33782                                           ! Debug: list unsigned short segment = [S+$10-$E] (used reg = )
33783 9149           FF76         F4            push	-$C[bp]
33784                                           ! Debug: list unsigned short offset = [S+$12-$10] (used reg = )
33785 914C           FF76         F2            push	-$E[bp]
33786                                           ! Debug: list unsigned short segment = [S+$14-$E] (used reg = )
33787 914F           FF76         F4            push	-$C[bp]
33788                                           ! Debug: list unsigned short offset = [S+$16-$10] (used reg = )
33789 9152           FF76         F2            push	-$E[bp]
33790                                           ! Debug: func () unsigned char = _read_byte+0 (used reg = )
33791 9155           E8         748C            call	__read_byte
33792 9158           83C4                   04  add	sp,*4
33793                                           ! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
33794 915B           0C                     80  or	al,#$80
33795                                           ! Debug: list unsigned char = al+0 (used reg = )
33796 915D           30E4                       xor	ah,ah
33797 915F           50                         push	ax
33798                                           ! Debug: func () void = _write_byte+0 (used reg = )
33799 9160           E8         749D            call	__write_byte
33800 9163           83C4                   06  add	sp,*6
33801                                           !BCC_EOS
33802                                           ! 5664         } else {
33803 9166           83C4                   04  add	sp,*4
33804 9169           EB           29            jmp .809
33805                       0000916B            .807:
33806                                           ! 5665           time -= 0x3D1;
33807                                           ! Debug: subab unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
33808 916B           B8                   03D1  mov	ax,#$3D1
33809 916E           31DB                       xor	bx,bx
33810 9170           53                         push	bx
33811 9171           50                         push	ax
33812 9172           8B46         FA            mov	ax,-6[bp]
33813 9175           8B5E         FC            mov	bx,-4[bp]
33814 9178           8D7E         F2            lea	di,-$E[bp]
33815 917B           E8         6F34            call	lsubul
33816 917E           8946         FA            mov	-6[bp],ax
33817 9181           895E         FC            mov	-4[bp],bx
33818 9184           83C4                   04  add	sp,*4
33819                                           !BCC_EOS
33820                                           ! 5666           *((Bit32u *)(0x49C)) = (time);
33821                                           ! Debug: eq unsigned long time = [S+$C-8] to unsigned long = [+$49C] (used reg = )
33822 9187           8B46         FA            mov	ax,-6[bp]
33823 918A           8B5E         FC            mov	bx,-4[bp]
33824 918D           A3         049C            mov	[$49C],ax
33825 9190           891E       049E            mov	[$49E],bx
33826                                           !BCC_EOS
33827                                           ! 5667         }
33828                                           ! 5668       }
33829                       00009194            .809:
33830 9194           83C4                   08  add	sp,*8
33831                                           ! 5669     }
33832                       00009197            .805:
33833                                           ! 5670   }
33834                       00009197            .803:
33835                                           ! 5671 #asm
33836                       00009197            .7FF:
33837                                           !BCC_EOS
33838                                           !BCC_ASM
33839                       00000000            _int70_function.registerC	set	0
33840                       FFFFFFFE            .int70_function.registerC	set	-2
33841                       00000016            _int70_function.ds	set	$16
33842                       00000014            .int70_function.ds	set	$14
33843                       00000001            _int70_function.registerB	set	1
33844                       FFFFFFFF            .int70_function.registerB	set	-1
33845                       00000018            _int70_function.iret_addr	set	$18
33846                       00000016            .int70_function.iret_addr	set	$16
33847                       00000006            _int70_function.regs	set	6
33848                       00000004            .int70_function.regs	set	4
33849 9197           E8         042A              call eoi_both_pics
33850                                           ! 5673 endasm
33851                                           !BCC_ENDASM
33852                                           !BCC_EOS
33853                                           ! 5674 }
33854 919A           89EC                       mov	sp,bp
33855 919C           5D                         pop	bp
33856 919D           C3                         ret
33857                                           ! 5675 #asm
33858                                           !BCC_ASM
33859                       00000012            _int70_function.ds	set	$12
33860                       00000014            _int70_function.iret_addr	set	$14
33861                       00000002            _int70_function.regs	set	2
33862                                           ;------------------------------------------
33863                                           ;- INT74h : PS/2 mouse hardware interrupt -
33864                                           ;------------------------------------------
33865                       0000919E            int74_handler:
33866 919E           FB                           sti
33867 919F           60                           pusha
33868 91A0           1E                           push ds ;; save DS
33869 91A1           6A                     00    push #0x00
33870 91A3           1F                           pop ds
33871 91A4           FF36       040E              push 0x040E ;; push 0000:040E (opcodes 0xff, 0x36, 0x0E, 0x04)
33872 91A8           1F                           pop ds
33873 91A9           6A                     00    push #0x00 ;; placeholder for status
33874 91AB           6A                     00    push #0x00 ;; placeholder for X
33875 91AD           6A                     00    push #0x00 ;; placeholder for Y
33876 91AF           6A                     00    push #0x00 ;; placeholder for Z
33877 91B1           6A                     00    push #0x00 ;; placeholder for make_far_call boolean
33878 91B3           E8         C842              call _int74_function
33879 91B6           59                           pop cx ;; remove make_far_call from stack
33880 91B7           E3           04              jcxz int74_done
33881                                             ;; make far call to EBDA:0022
33882 91B9           FF1E       0022              call far ptr[0x22]
33883                       000091BD            int74_done:
33884 91BD           FA                           cli
33885 91BE           E8         0403              call eoi_both_pics
33886 91C1           83C4                   08    add sp, #8 ;; pop status, x, y, z
33887 91C4           1F                           pop ds ;; restore DS
33888 91C5           61                           popa
33889 91C6           CF                           iret
33890                                           ;; This will perform an IRET, but will retain value of current CF
33891                                           ;; by altering flags on stack. Better than RETF #02.
33892                       000091C7            iret_modify_cf:
33893 91C7           72           09              jc carry_set
33894 91C9           55                           push bp
33895 91CA           89E5                         mov bp, sp
33896 91CC           8066         06        FE    and BYTE [bp + 0x06], #0xfe
33897 91D0           5D                           pop bp
33898 91D1           CF                           iret
33899                       000091D2            carry_set:
33900 91D2           55                           push bp
33901 91D3           89E5                         mov bp, sp
33902 91D5           804E         06        01    or BYTE [bp + 0x06], #0x01
33903 91D9           5D                           pop bp
33904 91DA           CF                           iret
33905                                           ;----------------------
33906                                           ;- INT13h (relocated) -
33907                                           ;----------------------
33908                                           ;
33909                                           ; int13_relocated is a little bit messed up since I played with it
33910                                           ; I have to rewrite it:
33911                                           ; - call a function that detect which function to call
33912                                           ; - make all called C function get the same parameters list
33913                                           ;
33914                       000091DB            int13_relocated:
33915                                             ;; check for an eltorito function
33916 91DB           80FC                   4A    cmp ah,#0x4a
33917 91DE           72           0E              jb int13_not_eltorito
33918 91E0           80FC                   4D    cmp ah,#0x4d
33919 91E3           77           09              ja int13_not_eltorito
33920 91E5           60                           pusha
33921 91E6           06                           push es
33922 91E7           1E                           push ds
33923 91E8           68                   926C    push #int13_out
33924 91EB           E9         DC00              jmp _int13_eltorito ;; ELDX not used
33925                       000091EE            int13_not_eltorito:
33926 91EE           50                           push ax
33927 91EF           53                           push bx
33928 91F0           51                           push cx
33929 91F1           52                           push dx
33930                                             ;; check if emulation active
33931 91F2           E8         A36D              call _cdemu_isactive
33932 91F5           3C                     00    cmp al,#0x00
33933 91F7           74           31              je int13_cdemu_inactive
33934                                             ;; check if access to the emulated drive
33935 91F9           E8         A382              call _cdemu_emulated_drive
33936 91FC           5A                           pop dx
33937 91FD           52                           push dx
33938 91FE           38D0                         cmp al,dl ;; int13 on emulated drive
33939 9200           75           15              jne int13_nocdemu
33940 9202           5A                           pop dx
33941 9203           59                           pop cx
33942 9204           5B                           pop bx
33943 9205           58                           pop ax
33944 9206           60                           pusha
33945 9207           06                           push es
33946 9208           1E                           push ds
33947 9209           6A                     40    push #0x40
33948 920B           1F                           pop ds
33949 920C           FF36       000E              push 0x000E
33950 9210           1F                           pop ds ;; Set DS to EBDA segment
33951 9211           68                   926C    push #int13_out
33952 9214           E9         DDDA              jmp _int13_cdemu ;; ELDX not used
33953                       00009217            int13_nocdemu:
33954 9217           80E2                   E0    and dl,#0xE0 ;; mask to get device class, including cdroms
33955 921A           38D0                         cmp al,dl ;; al is 0x00 or 0x80
33956 921C           75           0C              jne int13_cdemu_inactive ;; inactive for device class
33957 921E           5A                           pop dx
33958 921F           59                           pop cx
33959 9220           5B                           pop bx
33960 9221           58                           pop ax
33961 9222           50                           push ax
33962 9223           51                           push cx
33963 9224           52                           push dx
33964 9225           53                           push bx
33965 9226           FECA                         dec dl ;; real drive is dl - 1
33966 9228           EB           08              jmp int13_legacy
33967                       0000922A            int13_cdemu_inactive:
33968 922A           5A                           pop dx
33969 922B           59                           pop cx
33970 922C           5B                           pop bx
33971 922D           58                           pop ax
33972                       0000922E            int13_noeltorito:
33973 922E           50                           push ax
33974 922F           51                           push cx
33975 9230           52                           push dx
33976 9231           53                           push bx
33977                       00009232            int13_legacy:
33978 9232           52                           push dx ;; push eltorito value of dx instead of sp
33979 9233           55                           push bp
33980 9234           56                           push si
33981 9235           57                           push di
33982 9236           06                           push es
33983 9237           1E                           push ds
33984 9238           6A                     40    push #0x40
33985 923A           1F                           pop ds ;; Set DS to 0x40
33986                                             ;; now the 16-bit registers can be restored with:
33987                                             ;; pop ds; pop es; popa; iret
33988                                             ;; arguments passed to functions should be
33989                                             ;; DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS
33990 923B           F6C2                   80    test dl, #0x80
33991 923E           75           06              jnz int13_notfloppy
33992 9240           68                   926C    push #int13_out
33993 9243           E9         E538              jmp _int13_diskette_function
33994                       00009246            int13_notfloppy:
33995 9246           FF36       000E              push 0x000E
33996 924A           1F                           pop ds ;; Set DS to EBDA segment
33997 924B           80FA                   E0    cmp dl, #0xE0
33998 924E           72           0F              jb int13_notcdrom
33999 9250     66    C1EB                   10    shr ebx, #16
34000 9254           53                           push bx
34001 9255           E8         D6A1              call _int13_cdrom
34002 9258           5B                           pop bx
34003 9259     66    C1E3                   10    shl ebx, #16
34004 925D           EB           0D              jmp int13_out
34005                       0000925F            int13_notcdrom:
34006                       0000925F            int13_disk:
34007                                             ;; int13_harddisk modifies high word of EAX
34008 925F     66    C1E8                   10    shr eax, #16
34009 9263           50                           push ax
34010 9264           E8         CEDF              call _int13_harddisk
34011 9267           58                           pop ax
34012 9268     66    C1E0                   10    shl eax, #16
34013                       0000926C            int13_out:
34014 926C           1F                           pop ds
34015 926D           07                           pop es
34016 926E           61                           popa
34017 926F           CF                           iret
34018                                           ;----------
34019                                           ;- INT18h -
34020                                           ;----------
34021                       00009270            int18_handler: ;; Boot Failure recovery: try the next device.
34022                                             ;; Reset SP and SS
34023 9270           B8                   FFFE    mov ax, #0xfffe
34024 9273           89C4                         mov sp, ax
34025 9275           31C0                         xor ax, ax
34026 9277           8ED0                         mov ss, ax
34027                                             ;; Get the boot sequence number out of the IPL memory
34028 9279           BB                   9FF0    mov bx, #0x9ff0
34029 927C           8EDB                         mov ds, bx ;; Set segment
34030 927E           8B1E       0082              mov bx, 0x0082 ;; BX is now the sequence number
34031 9282           43                           inc bx ;; ++
34032 9283           891E       0082              mov 0x0082, bx ;; Write it back
34033 9287           8ED8                         mov ds, ax ;; and reset the segment to zero.
34034                                             ;; Carry on in the INT 19h handler, using the new sequence number
34035 9289           53                           push bx
34036 928A           EB           17              jmp int19_next_boot
34037                                           ;----------
34038                                           ;- INT19h -
34039                                           ;----------
34040                       0000928C            int19_relocated: ;; Boot function, relocated
34041                                             ;; int19 was beginning to be really complex, so now it
34042                                             ;; just calls a C function that does the work
34043 928C           55                           push bp
34044 928D           89E5                         mov bp, sp
34045                                             ;; Reset SS and SP
34046 928F           B8                   FFFE    mov ax, #0xfffe
34047 9292           89C4                         mov sp, ax
34048 9294           31C0                         xor ax, ax
34049 9296           8ED0                         mov ss, ax
34050                                             ;; Start from the first boot device (0, in AX)
34051 9298           BB                   9FF0    mov bx, #0x9ff0
34052 929B           8EDB                         mov ds, bx ;; Set segment to write to the IPL memory
34053 929D           A3         0082              mov 0x0082, ax ;; Save the sequence number
34054 92A0           8ED8                         mov ds, ax ;; and reset the segment.
34055 92A2           50                           push ax
34056                       000092A3            int19_next_boot:
34057                                             ;; Call the C code for the next boot device
34058 92A3           E8         F4FA              call _int19_function
34059                                             ;; Boot failed: invoke the boot recovery function
34060 92A6           CD                     18    int #0x18
34061                                           ;----------------------
34062                                           ;- POST: Floppy Drive -
34063                                           ;----------------------
34064                       000092A8            floppy_drive_post:
34065 92A8           31C0                         xor ax, ax
34066 92AA           8ED8                         mov ds, ax
34067 92AC           B0                     00    mov al, #0x00
34068 92AE           A2         043E              mov 0x043e, al ;; drive 0 & 1 uncalibrated, no interrupt has occurred
34069 92B1           A2         043F              mov 0x043f, al ;; diskette motor status: read op, drive0, motors off
34070 92B4           A2         0440              mov 0x0440, al ;; diskette motor timeout counter: not active
34071 92B7           A2         0441              mov 0x0441, al ;; diskette controller status return code
34072 92BA           A2         0442              mov 0x0442, al ;; disk & diskette controller status register 0
34073 92BD           A2         0443              mov 0x0443, al ;; diskette controller status register 1
34074 92C0           A2         0444              mov 0x0444, al ;; diskette controller status register 2
34075 92C3           A2         0445              mov 0x0445, al ;; diskette controller cylinder number
34076 92C6           A2         0446              mov 0x0446, al ;; diskette controller head number
34077 92C9           A2         0447              mov 0x0447, al ;; diskette controller sector number
34078 92CC           A2         0448              mov 0x0448, al ;; diskette controller bytes written
34079 92CF           A2         048B              mov 0x048b, al ;; diskette configuration data
34080                                             ;; -----------------------------------------------------------------
34081                                             ;; (048F) diskette controller information
34082                                             ;;
34083 92D2           B0                     10    mov al, #0x10 ;; get CMOS diskette drive type
34084 92D4           E6                     70    out 0x0070, AL
34085 92D6           E4                     71    in AL, 0x0071
34086 92D8           88C4                         mov ah, al ;; save byte to AH
34087                       000092DA            look_drive0:
34088 92DA           C0E8                   04    shr al, #4 ;; look at top 4 bits for drive 0
34089 92DD           74           04              jz f0_missing ;; jump if no drive0
34090 92DF           B3                     07    mov bl, #0x07 ;; drive0 determined, multi-rate, has changed line
34091 92E1           EB           02              jmp look_drive1
34092                       000092E3            f0_missing:
34093 92E3           B3                     00    mov bl, #0x00 ;; no drive0
34094                       000092E5            look_drive1:
34095 92E5           88E0                         mov al, ah ;; restore from AH
34096 92E7           24                     0F    and al, #0x0f ;; look at bottom 4 bits for drive 1
34097 92E9           74           03              jz f1_missing ;; jump if no drive1
34098 92EB           80CB                   70    or bl, #0x70 ;; drive1 determined, multi-rate, has changed line
34099                       000092EE            f1_missing:
34100                                                              ;; leave high bits in BL zerod
34101 92EE           881E       048F              mov 0x048f, bl ;; put new val in BDA (diskette controller information)
34102                                             ;; -----------------------------------------------------------------
34103 92F2           B0                     00    mov al, #0x00
34104 92F4           A2         0490              mov 0x0490, al ;; diskette 0 media state
34105 92F7           A2         0491              mov 0x0491, al ;; diskette 1 media state
34106                                                              ;; diskette 0,1 operational starting state
34107                                                              ;; drive type has not been determined,
34108                                                              ;; has no changed detection line
34109 92FA           A2         0492              mov 0x0492, al
34110 92FD           A2         0493              mov 0x0493, al
34111 9300           A2         0494              mov 0x0494, al ;; diskette 0 current cylinder
34112 9303           A2         0495              mov 0x0495, al ;; diskette 1 current cylinder
34113 9306           B0                     02    mov al, #0x02
34114 9308           E6                     0A    out 0x000a, al ;; clear DMA-1 channel 2 mask bit
34115                                             SET_INT_VECTOR(0x1E, #0xF000, #diskette_param_table2)
 +a   930A           B8                   EFDE    mov ax,  #diskette_param_table2
 +a   930D           A3         0078              mov 0x1E*4, ax
 +a   9310           B8                   F000    mov ax,  #0xF000
 +a   9313           A3         007A              mov 0x1E*4+2, ax
34116                                             SET_INT_VECTOR(0x40, #0xF000, #int13_diskette)
 +a   9316           B8                   EC59    mov ax,  #int13_diskette
 +a   9319           A3         0100              mov 0x40*4, ax
 +a   931C           B8                   F000    mov ax,  #0xF000
 +a   931F           A3         0102              mov 0x40*4+2, ax
34117                                             SET_INT_VECTOR(0x0E, #0xF000, #int0e_handler) ;; IRQ 6
 +a   9322           B8                   EF57    mov ax,  #int0e_handler
 +a   9325           A3         0038              mov 0x0E*4, ax
 +a   9328           B8                   F000    mov ax,  #0xF000
 +a   932B           A3         003A              mov 0x0E*4+2, ax
34118 932E           C3                           ret
34119                                           ;--------------------
34120                                           ;- POST: HARD DRIVE -
34121                                           ;--------------------
34122                                           ; relocated here because the primary POST area isnt big enough.
34123                       0000932F            hard_drive_post:
34124 932F           B0                     0A    mov al, #0x0a ; 0000 1010 = reserved, disable IRQ 14
34125 9331           BA                   03F6    mov dx, #0x03f6
34126 9334           EE                           out dx, al
34127 9335           31C0                         xor ax, ax
34128 9337           8ED8                         mov ds, ax
34129 9339           A2         0474              mov 0x0474, al
34130 933C           A2         0477              mov 0x0477, al
34131 933F           A2         048C              mov 0x048c, al
34132 9342           A2         048D              mov 0x048d, al
34133 9345           A2         048E              mov 0x048e, al
34134 9348           B0                     01    mov al, #0x01
34135 934A           A2         0475              mov 0x0475, al
34136 934D           B0                     C0    mov al, #0xc0
34137 934F           A2         0476              mov 0x0476, al
34138                                             SET_INT_VECTOR(0x13, #0xF000, #int13_handler)
 +a   9352           B8                   E3FE    mov ax,  #int13_handler
 +a   9355           A3         004C              mov 0x13*4, ax
 +a   9358           B8                   F000    mov ax,  #0xF000
 +a   935B           A3         004E              mov 0x13*4+2, ax
34139                                             SET_INT_VECTOR(0x76, #0xF000, #int76_handler)
 +a   935E           B8                   9632    mov ax,  #int76_handler
 +a   9361           A3         01D8              mov 0x76*4, ax
 +a   9364           B8                   F000    mov ax,  #0xF000
 +a   9367           A3         01DA              mov 0x76*4+2, ax
34140                                             ;; INT 41h: hard disk 0 configuration pointer
34141                                             ;; INT 46h: hard disk 1 configuration pointer
34142                                             SET_INT_VECTOR(0x41, #0x9FC0, #0x003D)
 +a   936A           B8                   003D    mov ax,  #0x003D
 +a   936D           A3         0104              mov 0x41*4, ax
 +a   9370           B8                   9FC0    mov ax,  #0x9FC0
 +a   9373           A3         0106              mov 0x41*4+2, ax
34143                                             SET_INT_VECTOR(0x46, #0x9FC0, #0x004D)
 +a   9376           B8                   004D    mov ax,  #0x004D
 +a   9379           A3         0118              mov 0x46*4, ax
 +a   937C           B8                   9FC0    mov ax,  #0x9FC0
 +a   937F           A3         011A              mov 0x46*4+2, ax
34144                                             ;; move disk geometry data from CMOS to EBDA disk parameter table(s)
34145 9382           B0                     12    mov al, #0x12
34146 9384           E6                     70    out 0x0070, al
34147 9386           E4                     71    in al, 0x0071
34148 9388           24                     F0    and al, #0xf0
34149 938A           3C                     F0    cmp al, #0xf0
34150 938C           74           03              je post_d0_extended
34151 938E           E9         00D4              jmp check_for_hd1
34152                       00009391            post_d0_extended:
34153 9391           B0                     19    mov al, #0x19
34154 9393           E6                     70    out 0x0070, al
34155 9395           E4                     71    in al, 0x0071
34156 9397           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
34157 9399           74           07              je post_d0_type47
34158                                             HALT(9217)
 +a   939B           BA                   0400    mov dx,#0x400
 +a   939E           B8                   2401    mov ax,#9217
 +a   93A1           EF                           out dx,ax
34159                       000093A2            post_d0_type47:
34160                                             ;; CMOS purpose param table offset
34161                                             ;; 1b cylinders low 0
34162                                             ;; 1c cylinders high 1
34163                                             ;; 1d heads 2
34164                                             ;; 1e write pre-comp low 5
34165                                             ;; 1f write pre-comp high 6
34166                                             ;; 20 retries/bad map/heads>8 8
34167                                             ;; 21 landing zone low C
34168                                             ;; 22 landing zone high D
34169                                             ;; 23 sectors/track E
34170 93A2           B8                   9FC0    mov ax, #0x9FC0
34171 93A5           8ED8                         mov ds, ax
34172                                             ;;; Filling EBDA table for hard disk 0.
34173 93A7           B0                     1F    mov al, #0x1f
34174 93A9           E6                     70    out 0x0070, al
34175 93AB           E4                     71    in al, 0x0071
34176 93AD           88C4                         mov ah, al
34177 93AF           B0                     1E    mov al, #0x1e
34178 93B1           E6                     70    out 0x0070, al
34179 93B3           E4                     71    in al, 0x0071
34180 93B5           A3         0042              mov (0x003d + 0x05), ax ;; write precomp word
34181 93B8           B0                     20    mov al, #0x20
34182 93BA           E6                     70    out 0x0070, al
34183 93BC           E4                     71    in al, 0x0071
34184 93BE           A2         0045              mov (0x003d + 0x08), al ;; drive control byte
34185 93C1           B0                     22    mov al, #0x22
34186 93C3           E6                     70    out 0x0070, al
34187 93C5           E4                     71    in al, 0x0071
34188 93C7           88C4                         mov ah, al
34189 93C9           B0                     21    mov al, #0x21
34190 93CB           E6                     70    out 0x0070, al
34191 93CD           E4                     71    in al, 0x0071
34192 93CF           A3         0049              mov (0x003d + 0x0C), ax ;; landing zone word
34193 93D2           B0                     1C    mov al, #0x1c ;; get cylinders word in AX
34194 93D4           E6                     70    out 0x0070, al
34195 93D6           E4                     71    in al, 0x0071 ;; high byte
34196 93D8           88C4                         mov ah, al
34197 93DA           B0                     1B    mov al, #0x1b
34198 93DC           E6                     70    out 0x0070, al
34199 93DE           E4                     71    in al, 0x0071 ;; low byte
34200 93E0           89C3                         mov bx, ax ;; BX = cylinders
34201 93E2           B0                     1D    mov al, #0x1d
34202 93E4           E6                     70    out 0x0070, al
34203 93E6           E4                     71    in al, 0x0071
34204 93E8           88C1                         mov cl, al ;; CL = heads
34205 93EA           B0                     23    mov al, #0x23
34206 93EC           E6                     70    out 0x0070, al
34207 93EE           E4                     71    in al, 0x0071
34208 93F0           88C2                         mov dl, al ;; DL = sectors
34209 93F2           81FB                 0400    cmp bx, #1024
34210 93F6           77           0E              jnbe hd0_post_logical_chs ;; if cylinders > 1024, use translated style CHS
34211                       000093F8            hd0_post_physical_chs:
34212                                             ;; no logical CHS mapping used, just physical CHS
34213                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
34214 93F8           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
34215 93FC           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
34216 9400           8816       004B              mov (0x003d + 0x0E), dl ;; number of physical sectors
34217 9404           EB           5F              jmp check_for_hd1
34218                       00009406            hd0_post_logical_chs:
34219                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
34220 9406           891E       0046              mov (0x003d + 0x09), bx ;; number of physical cylinders
34221 940A           880E       0048              mov (0x003d + 0x0b), cl ;; number of physical heads
34222 940E           8816       0041              mov (0x003d + 0x04), dl ;; number of physical sectors
34223 9412           8816       004B              mov (0x003d + 0x0e), dl ;; number of logical sectors (same)
34224 9416           B0                     A0    mov al, #0xa0
34225 9418           A2         0040              mov (0x003d + 0x03), al ;; A0h signature, indicates translated table
34226 941B           81FB                 0800    cmp bx, #2048
34227 941F           77           06              jnbe hd0_post_above_2048
34228                                             ;; 1024 < c <= 2048 cylinders
34229 9421           D1EB                         shr bx, #0x01
34230 9423           D0E1                         shl cl, #0x01
34231 9425           EB           22              jmp hd0_post_store_logical
34232                       00009427            hd0_post_above_2048:
34233 9427           81FB                 1000    cmp bx, #4096
34234 942B           77           08              jnbe hd0_post_above_4096
34235                                             ;; 2048 < c <= 4096 cylinders
34236 942D           C1EB                   02    shr bx, #0x02
34237 9430           C0E1                   02    shl cl, #0x02
34238 9433           EB           14              jmp hd0_post_store_logical
34239                       00009435            hd0_post_above_4096:
34240 9435           81FB                 2000    cmp bx, #8192
34241 9439           77           08              jnbe hd0_post_above_8192
34242                                             ;; 4096 < c <= 8192 cylinders
34243 943B           C1EB                   03    shr bx, #0x03
34244 943E           C0E1                   03    shl cl, #0x03
34245 9441           EB           06              jmp hd0_post_store_logical
34246                       00009443            hd0_post_above_8192:
34247                                             ;; 8192 < c <= 16384 cylinders
34248 9443           C1EB                   04    shr bx, #0x04
34249 9446           C0E1                   04    shl cl, #0x04
34250                       00009449            hd0_post_store_logical:
34251 9449           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
34252 944D           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
34253                                             ;; checksum
34254 9451           B1                     0F    mov cl, #0x0f ;; repeat count
34255 9453           BE                   003D    mov si, #0x003d ;; offset to disk0 FDPT
34256 9456           B0                     00    mov al, #0x00 ;; sum
34257                       00009458            hd0_post_checksum_loop:
34258 9458           0204                         add al, [si]
34259 945A           46                           inc si
34260 945B           FEC9                         dec cl
34261 945D           75           F9              jnz hd0_post_checksum_loop
34262 945F           F6D0                         not al ;; now take 2s complement
34263 9461           FEC0                         inc al
34264 9463           8804                         mov [si], al
34265                                           ;;; Done filling EBDA table for hard disk 0.
34266                       00009465            check_for_hd1:
34267                                             ;; is there really a second hard disk? if not, return now
34268 9465           B0                     12    mov al, #0x12
34269 9467           E6                     70    out 0x0070, al
34270 9469           E4                     71    in al, 0x0071
34271 946B           24                     0F    and al, #0x0f
34272 946D           75           01              jnz post_d1_exists
34273 946F           C3                           ret
34274                       00009470            post_d1_exists:
34275                                             ;; check that the hd type is really 0x0f.
34276 9470           3C                     0F    cmp al, #0x0f
34277 9472           74           07              jz post_d1_extended
34278                                             HALT(9354)
 +a   9474           BA                   0400    mov dx,#0x400
 +a   9477           B8                   248A    mov ax,#9354
 +a   947A           EF                           out dx,ax
34279                       0000947B            post_d1_extended:
34280                                             ;; check that the extended type is 47 - user definable
34281 947B           B0                     1A    mov al, #0x1a
34282 947D           E6                     70    out 0x0070, al
34283 947F           E4                     71    in al, 0x0071
34284 9481           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
34285 9483           74           07              je post_d1_type47
34286                                             HALT(9362)
 +a   9485           BA                   0400    mov dx,#0x400
 +a   9488           B8                   2492    mov ax,#9362
 +a   948B           EF                           out dx,ax
34287                       0000948C            post_d1_type47:
34288                                             ;; Table for disk1.
34289                                             ;; CMOS purpose param table offset
34290                                             ;; 0x24 cylinders low 0
34291                                             ;; 0x25 cylinders high 1
34292                                             ;; 0x26 heads 2
34293                                             ;; 0x27 write pre-comp low 5
34294                                             ;; 0x28 write pre-comp high 6
34295                                             ;; 0x29 heads>8 8
34296                                             ;; 0x2a landing zone low C
34297                                             ;; 0x2b landing zone high D
34298                                             ;; 0x2c sectors/track E
34299                                           ;;; Fill EBDA table for hard disk 1.
34300 948C           B8                   9FC0    mov ax, #0x9FC0
34301 948F           8ED8                         mov ds, ax
34302 9491           B0                     28    mov al, #0x28
34303 9493           E6                     70    out 0x0070, al
34304 9495           E4                     71    in al, 0x0071
34305 9497           88C4                         mov ah, al
34306 9499           B0                     27    mov al, #0x27
34307 949B           E6                     70    out 0x0070, al
34308 949D           E4                     71    in al, 0x0071
34309 949F           A3         0052              mov (0x004d + 0x05), ax ;; write precomp word
34310 94A2           B0                     29    mov al, #0x29
34311 94A4           E6                     70    out 0x0070, al
34312 94A6           E4                     71    in al, 0x0071
34313 94A8           A2         0055              mov (0x004d + 0x08), al ;; drive control byte
34314 94AB           B0                     2B    mov al, #0x2b
34315 94AD           E6                     70    out 0x0070, al
34316 94AF           E4                     71    in al, 0x0071
34317 94B1           88C4                         mov ah, al
34318 94B3           B0                     2A    mov al, #0x2a
34319 94B5           E6                     70    out 0x0070, al
34320 94B7           E4                     71    in al, 0x0071
34321 94B9           A3         0059              mov (0x004d + 0x0C), ax ;; landing zone word
34322 94BC           B0                     25    mov al, #0x25 ;; get cylinders word in AX
34323 94BE           E6                     70    out 0x0070, al
34324 94C0           E4                     71    in al, 0x0071 ;; high byte
34325 94C2           88C4                         mov ah, al
34326 94C4           B0                     24    mov al, #0x24
34327 94C6           E6                     70    out 0x0070, al
34328 94C8           E4                     71    in al, 0x0071 ;; low byte
34329 94CA           89C3                         mov bx, ax ;; BX = cylinders
34330 94CC           B0                     26    mov al, #0x26
34331 94CE           E6                     70    out 0x0070, al
34332 94D0           E4                     71    in al, 0x0071
34333 94D2           88C1                         mov cl, al ;; CL = heads
34334 94D4           B0                     2C    mov al, #0x2c
34335 94D6           E6                     70    out 0x0070, al
34336 94D8           E4                     71    in al, 0x0071
34337 94DA           88C2                         mov dl, al ;; DL = sectors
34338 94DC           81FB                 0400    cmp bx, #1024
34339 94E0           77           0D              jnbe hd1_post_logical_chs ;; if cylinders > 1024, use translated style CHS
34340                       000094E2            hd1_post_physical_chs:
34341                                             ;; no logical CHS mapping used, just physical CHS
34342                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
34343 94E2           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
34344 94E6           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
34345 94EA           8816       005B              mov (0x004d + 0x0E), dl ;; number of physical sectors
34346 94EE           C3                           ret
34347                       000094EF            hd1_post_logical_chs:
34348                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
34349 94EF           891E       0056              mov (0x004d + 0x09), bx ;; number of physical cylinders
34350 94F3           880E       0058              mov (0x004d + 0x0b), cl ;; number of physical heads
34351 94F7           8816       0051              mov (0x004d + 0x04), dl ;; number of physical sectors
34352 94FB           8816       005B              mov (0x004d + 0x0e), dl ;; number of logical sectors (same)
34353 94FF           B0                     A0    mov al, #0xa0
34354 9501           A2         0050              mov (0x004d + 0x03), al ;; A0h signature, indicates translated table
34355 9504           81FB                 0800    cmp bx, #2048
34356 9508           77           06              jnbe hd1_post_above_2048
34357                                             ;; 1024 < c <= 2048 cylinders
34358 950A           D1EB                         shr bx, #0x01
34359 950C           D0E1                         shl cl, #0x01
34360 950E           EB           22              jmp hd1_post_store_logical
34361                       00009510            hd1_post_above_2048:
34362 9510           81FB                 1000    cmp bx, #4096
34363 9514           77           08              jnbe hd1_post_above_4096
34364                                             ;; 2048 < c <= 4096 cylinders
34365 9516           C1EB                   02    shr bx, #0x02
34366 9519           C0E1                   02    shl cl, #0x02
34367 951C           EB           14              jmp hd1_post_store_logical
34368                       0000951E            hd1_post_above_4096:
34369 951E           81FB                 2000    cmp bx, #8192
34370 9522           77           08              jnbe hd1_post_above_8192
34371                                             ;; 4096 < c <= 8192 cylinders
34372 9524           C1EB                   03    shr bx, #0x03
34373 9527           C0E1                   03    shl cl, #0x03
34374 952A           EB           06              jmp hd1_post_store_logical
34375                       0000952C            hd1_post_above_8192:
34376                                             ;; 8192 < c <= 16384 cylinders
34377 952C           C1EB                   04    shr bx, #0x04
34378 952F           C0E1                   04    shl cl, #0x04
34379                       00009532            hd1_post_store_logical:
34380 9532           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
34381 9536           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
34382                                             ;; checksum
34383 953A           B1                     0F    mov cl, #0x0f ;; repeat count
34384 953C           BE                   004D    mov si, #0x004d ;; offset to disk0 FDPT
34385 953F           B0                     00    mov al, #0x00 ;; sum
34386                       00009541            hd1_post_checksum_loop:
34387 9541           0204                         add al, [si]
34388 9543           46                           inc si
34389 9544           FEC9                         dec cl
34390 9546           75           F9              jnz hd1_post_checksum_loop
34391 9548           F6D0                         not al ;; now take 2s complement
34392 954A           FEC0                         inc al
34393 954C           8804                         mov [si], al
34394                                           ;;; Done filling EBDA table for hard disk 1.
34395 954E           C3                           ret
34396                                           ;--------------------
34397                                           ;- POST: EBDA segment
34398                                           ;--------------------
34399                                           ; relocated here because the primary POST area isnt big enough.
34400                       0000954F            ebda_post:
34401 954F           B8                   9FC0    mov ax, #0x9FC0
34402 9552           8ED8                         mov ds, ax
34403 9554           C606       0000        01    mov byte ptr [0x0], #1
34404 9559           31C0                         xor ax, ax ; mov EBDA seg into 0x40E
34405 955B           8ED8                         mov ds, ax
34406 955D           C706       040E      9FC0    mov word ptr [0x40E], #0x9FC0
34407 9563           C3                           ret;;
34408                                           ;--------------------
34409                                           ;- POST: EOI + jmp via [0x40:67)
34410                                           ;--------------------
34411                                           ; relocated here because the primary POST area isnt big enough.
34412                       00009564            eoi_jmp_post:
34413 9564           B0                     11    mov al, #0x11 ; send initialisation commands
34414 9566           E6                     20    out 0x0020, al
34415 9568           E6                     A0    out 0x00a0, al
34416 956A           B0                     08    mov al, #0x08
34417 956C           E6                     21    out 0x0021, al
34418 956E           B0                     70    mov al, #0x70
34419 9570           E6                     A1    out 0x00a1, al
34420 9572           B0                     04    mov al, #0x04
34421 9574           E6                     21    out 0x0021, al
34422 9576           B0                     02    mov al, #0x02
34423 9578           E6                     A1    out 0x00a1, al
34424 957A           B0                     01    mov al, #0x01
34425 957C           E6                     21    out 0x0021, al
34426 957E           E6                     A1    out 0x00a1, al
34427 9580           B0                     B8    mov al, #0xb8
34428 9582           E6                     21    out 0x0021, AL ;master pic: unmask IRQ 0, 1, 2, 6
34429 9584           B0                     8F    mov al, #0x8f
34430 9586           E6                     A1    out 0x00a1, AL ;slave pic: unmask IRQ 12, 13, 14
34431 9588           B0                     20    mov al, #0x20
34432 958A           E6                     A0    out 0x00a0, al ;; slave PIC EOI
34433 958C           B0                     20    mov al, #0x20
34434 958E           E6                     20    out 0x0020, al ;; master PIC EOI
34435                       00009590            jmp_post_0x467:
34436 9590           31C0                         xor ax, ax
34437 9592           8ED8                         mov ds, ax
34438 9594           FF2E       0467              jmp far ptr [0x467]
34439                       00009598            iret_post_0x467:
34440 9598           31C0                         xor ax, ax
34441 959A           8ED8                         mov ds, ax
34442 959C           8B26       0467              mov sp, [0x467]
34443 95A0           8E16       0469              mov ss, [0x469]
34444 95A4           CF                           iret
34445                       000095A5            retf_post_0x467:
34446 95A5           31C0                         xor ax, ax
34447 95A7           8ED8                         mov ds, ax
34448 95A9           8B26       0467              mov sp, [0x467]
34449 95AD           8E16       0469              mov ss, [0x469]
34450 95B1           CB                           retf
34451                       000095B2            s3_post:
34452 95B2           BC                   0FFE    mov sp, #0xffe
34453 95B5           E8         81F4              call _s3_resume
34454 95B8           B3                     00    mov bl, #0x00
34455 95BA           21C0                         and ax, ax
34456 95BC   7503    E9         4AE2              jz normal_post
34457 95C1           E8         7C10              call _s3_resume_panic
34458                                           ;--------------------
34459                       000095C4            eoi_both_pics:
34460 95C4           B0                     20    mov al, #0x20
34461 95C6           E6                     A0    out 0x00a0, al ;; slave PIC EOI
34462                       000095C8            eoi_master_pic:
34463 95C8           B0                     20    mov al, #0x20
34464 95CA           E6                     20    out 0x0020, al ;; master PIC EOI
34465 95CC           C3                           ret
34466                                           ;--------------------
34467                       000095CD            BcdToBin:
34468                                             ;; in: AL in BCD format
34469                                             ;; out: AL in binary format, AH will always be 0
34470                                             ;; trashes BX
34471 95CD           88C3                         mov bl, al
34472 95CF           80E3                   0F    and bl, #0x0f ;; bl has low digit
34473 95D2           C0E8                   04    shr al, #4 ;; al has high digit
34474 95D5           B7                     0A    mov bh, #10
34475 95D7           F6E7                         mul al, bh ;; multiply high digit by 10 (result in AX)
34476 95D9           00D8                         add al, bl ;; then add low digit
34477 95DB           C3                           ret
34478                                           ;--------------------
34479                       000095DC            timer_tick_post:
34480                                             ;; Setup the Timer Ticks Count (0x46C:dword) and
34481                                             ;; Timer Ticks Roller Flag (0x470:byte)
34482                                             ;; The Timer Ticks Count needs to be set according to
34483                                             ;; the current CMOS time, as if ticks have been occurring
34484                                             ;; at 18.2hz since midnight up to this point. Calculating
34485                                             ;; this is a little complicated. Here are the factors I gather
34486                                             ;; regarding this. 14,318,180 hz was the original clock speed,
34487                                             ;; chosen so it could be divided by either 3 to drive the 5Mhz CPU
34488                                             ;; at the time, or 4 to drive the CGA video adapter. The div3
34489                                             ;; source was divided again by 4 to feed a 1.193Mhz signal to
34490                                             ;; the timer. With a maximum 16bit timer count, this is again
34491                                             ;; divided down by 65536 to 18.2hz.
34492                                             ;;
34493                                             ;; 14,318,180 Hz clock
34494                                             ;; /3 = 4,772,726 Hz fed to original 5Mhz CPU
34495                                             ;; /4 = 1,193,181 Hz fed to timer
34496                                             ;; /65536 (maximum timer count) = 18.20650736 ticks/second
34497                                             ;; 1 second = 18.20650736 ticks
34498                                             ;; 1 minute = 1092.390442 ticks
34499                                             ;; 1 hour = 65543.42651 ticks
34500                                             ;;
34501                                             ;; Given the values in the CMOS clock, one could calculate
34502                                             ;; the number of ticks by the following:
34503                                             ;; ticks = (BcdToBin(seconds) * 18.206507) +
34504                                             ;; (BcdToBin(minutes) * 1092.3904)
34505                                             ;; (BcdToBin(hours) * 65543.427)
34506                                             ;; To get a little more accuracy, since Im using integer
34507                                             ;; arithmetic, I use:
34508                                             ;; ticks = (((BcdToBin(hours) * 60 + BcdToBin(minutes)) * 60 + BcdToBin(seconds)) * (18 * 4294967296 + 886942379)) / 4294967296
34509                                             ;; assuming DS=0000
34510                                             ;; get CMOS hours
34511 95DC     66    31C0                         xor eax, eax ;; clear EAX
34512 95DF           B0                     04    mov al, #0x04
34513 95E1           E6                     70    out 0x0070, al
34514 95E3           E4                     71    in al, 0x0071 ;; AL has CMOS hours in BCD
34515 95E5           E8         FFE5              call BcdToBin ;; EAX now has hours in binary
34516 95E8     66    6BC0                   3C    imul eax, #60
34517 95EC     66    89C2                         mov edx, eax
34518                                             ;; get CMOS minutes
34519 95EF     66    31C0                         xor eax, eax ;; clear EAX
34520 95F2           B0                     02    mov al, #0x02
34521 95F4           E6                     70    out 0x0070, al
34522 95F6           E4                     71    in al, 0x0071 ;; AL has CMOS minutes in BCD
34523 95F8           E8         FFD2              call BcdToBin ;; EAX now has minutes in binary
34524 95FB     66    01D0                         add eax, edx
34525 95FE     66    6BC0                   3C    imul eax, #60
34526 9602     66    89C2                         mov edx, eax
34527                                             ;; get CMOS seconds
34528 9605     66    31C0                         xor eax, eax ;; clear EAX
34529 9608           B0                     00    mov al, #0x00
34530 960A           E6                     70    out 0x0070, al
34531 960C           E4                     71    in al, 0x0071 ;; AL has CMOS seconds in BCD
34532 960E           E8         FFBC              call BcdToBin ;; EAX now has seconds in binary
34533 9611     66    01D0                         add eax, edx
34534                                             ;; multiplying 18.2065073649
34535 9614     66    89C1                         mov ecx, eax
34536 9617     66    6BC9                   12    imul ecx, #18
34537 961B     66    BA               34DDAAAB    mov edx, #886942379
34538 9621     66    F7E2                         mul edx
34539 9624     66    01D1                         add ecx, edx
34540 9627     66    890E       046C              mov 0x46C, ecx ;; Timer Ticks Count
34541 962C           30C0                         xor al, al
34542 962E           A2         0470              mov 0x470, al ;; Timer Ticks Rollover Flag
34543 9631           C3                           ret
34544                                           ;--------------------
34545                       00009632            int76_handler:
34546                                             ;; record completion in BIOS task complete flag
34547 9632           50                           push ax
34548 9633           1E                           push ds
34549 9634           B8                   0040    mov ax, #0x0040
34550 9637           8ED8                         mov ds, ax
34551 9639           C606       008E        FF    mov BYTE 0x008E, #0xff
34552 963E           E8         FF83              call eoi_both_pics
34553                                             ;; Notify fixed disk interrupt complete w/ int 15h, function AX=9100
34554 9641           B8                   9100    mov ax, #0x9100
34555 9644           CD                     15    int 0x15
34556 9646           1F                           pop ds
34557 9647           58                           pop ax
34558 9648           CF                           iret
34559                                           ;--------------------
34560                                           use32 386
34561                       00009649            apm32_out_str:
34562 9649           50                           push eax
34563 964A           53                           push ebx
34564 964B           89C3                         mov ebx, eax
34565                       0000964D            apm32_out_str1:
34566 964D           2E                           SEG CS
34567 964E   67      8A07                         mov al, byte ptr [bx]
34568 9651           3C                     00    cmp al, #0
34569 9653           74           04              je apm32_out_str2
34570 9655           EE                           outb dx, al
34571 9656           43                           inc ebx
34572 9657           EB           F4              jmp apm32_out_str1
34573                       00009659            apm32_out_str2:
34574 9659           5B                           pop ebx
34575 965A           58                           pop eax
34576 965B           C3                           ret
34577                       0000965C            apm32_07_poweroff_str:
34578 965C                        53              .ascii "Shutdown"
34579 9664                        00              db 0
34580                       00009665            apm32_07_suspend_str:
34581 9665                        53              .ascii "Suspend"
34582 966C                        00              db 0
34583                       0000966D            apm32_07_standby_str:
34584 966D                        53              .ascii "Standby"
34585 9674                        00              db 0
34586                       00009675            _apm32_entry:
34587 9675     66    9C                           pushf
34588                                           ;-----------------
34589                                           ; APM interface disconnect
34590                       00009677            apm32_04:
34591 9677           3C                     04    cmp al, #0x04
34592 9679           75           05              jne apm32_05
34593 967B           E9     000000A1              jmp apm32_ok
34594                                           ;-----------------
34595                                           ; APM cpu idle
34596                       00009680            apm32_05:
34597 9680           3C                     05    cmp al, #0x05
34598 9682           75           07              jne apm32_07
34599 9684           FB                           sti
34600 9685           F4                           hlt
34601 9686           E9     00000096              jmp apm32_ok
34602                                           ;-----------------
34603                                           ; APM Set Power State
34604                       0000968B            apm32_07:
34605 968B           3C                     07    cmp al, #0x07
34606 968D           75           52              jne apm32_08
34607 968F     66    83FB                   01    cmp bx, #1
34608 9693   7405    E9     00000087              jne apm32_ok
34609 969A     66    83F9                   03    cmp cx, #3
34610 969E           74           0E              je apm32_07_poweroff
34611 96A0     66    83F9                   02    cmp cx, #2
34612 96A4           74           19              je apm32_07_suspend
34613 96A6     66    83F9                   01    cmp cx, #1
34614 96AA           74           24              je apm32_07_standby
34615 96AC           75           73              jne apm32_ok
34616                       000096AE            apm32_07_poweroff:
34617 96AE           FA                           cli
34618 96AF     66    BA                   8900    mov dx, #0x8900
34619 96B3     66    B8                   965C    mov ax, #apm32_07_poweroff_str
34620 96B7           E8     FFFFFF8D              call apm32_out_str
34621                       000096BC            apm32_07_1:
34622 96BC           F4                           hlt
34623 96BD           EB           FD              jmp apm32_07_1
34624                       000096BF            apm32_07_suspend:
34625 96BF           52                           push edx
34626 96C0     66    BA                   8900    mov dx, #0x8900
34627 96C4     66    B8                   9665    mov ax, #apm32_07_suspend_str
34628 96C8           E8     FFFFFF7C              call apm32_out_str
34629 96CD           5A                           pop edx
34630 96CE           EB           51              jmp apm32_ok
34631                       000096D0            apm32_07_standby:
34632 96D0           52                           push edx
34633 96D1     66    BA                   8900    mov dx, #0x8900
34634 96D5     66    B8                   966D    mov ax, #apm32_07_standby_str
34635 96D9           E8     FFFFFF6B              call apm32_out_str
34636 96DE           5A                           pop edx
34637 96DF           EB           40              jmp apm32_ok
34638                                           ;-----------------
34639                                           ; APM Enable / Disable
34640                       000096E1            apm32_08:
34641 96E1           3C                     08    cmp al, #0x08
34642 96E3           75           02              jne apm32_0a
34643 96E5           EB           3A              jmp apm32_ok
34644                                           ;-----------------
34645                                           ; Get Power Status
34646                       000096E7            apm32_0a:
34647 96E7           3C                     0A    cmp al, #0x0a
34648 96E9           75           12              jne apm32_0b
34649 96EB           B7                     01    mov bh, #0x01
34650 96ED           B3                     FF    mov bl, #0xff
34651 96EF           B5                     80    mov ch, #0x80
34652 96F1           B1                     FF    mov cl, #0xff
34653 96F3     66    BA                   FFFF    mov dx, #0xffff
34654 96F7     66    BE                   0000    mov si, #0
34655 96FB           EB           24              jmp apm32_ok
34656                                           ;-----------------
34657                                           ; Get PM Event
34658                       000096FD            apm32_0b:
34659 96FD           3C                     0B    cmp al, #0x0b
34660 96FF           75           04              jne apm32_0e
34661 9701           B4                     80    mov ah, #0x80
34662 9703           EB           20              jmp apm32_error
34663                                           ;-----------------
34664                                           ; APM Driver Version
34665                       00009705            apm32_0e:
34666 9705           3C                     0E    cmp al, #0x0e
34667 9707           75           06              jne apm32_0f
34668 9709           B4                     01    mov ah, #1
34669 970B           B0                     02    mov al, #2
34670 970D           EB           12              jmp apm32_ok
34671                                           ;-----------------
34672                                           ; APM Engage / Disengage
34673                       0000970F            apm32_0f:
34674 970F           3C                     0F    cmp al, #0x0f
34675 9711           75           02              jne apm32_10
34676 9713           EB           0C              jmp apm32_ok
34677                                           ;-----------------
34678                                           ; APM Get Capabilities
34679                       00009715            apm32_10:
34680 9715           3C                     10    cmp al, #0x10
34681 9717           75           0C              jne apm32_unimplemented
34682 9719           B3                     00    mov bl, #0
34683 971B     66    B9                   0000    mov cx, #0
34684 971F           EB           00              jmp apm32_ok
34685                                           ;-----------------
34686                       00009721            apm32_ok:
34687 9721     66    9D                           popf
34688 9723           F8                           clc
34689 9724           CB                           retf
34690                       00009725            apm32_unimplemented:
34691                       00009725            apm32_error:
34692 9725     66    9D                           popf
34693 9727           F9                           stc
34694 9728           CB                           retf
34695                                           use16 386
34696                       00009729            apm16_out_str:
34697 9729     66    50                           push eax
34698 972B     66    53                           push ebx
34699 972D     66    89C3                         mov ebx, eax
34700                       00009730            apm16_out_str1:
34701 9730           2E                           SEG CS
34702 9731           8A07                         mov al, byte ptr [bx]
34703 9733           3C                     00    cmp al, #0
34704 9735           74           05              je apm16_out_str2
34705 9737           EE                           outb dx, al
34706 9738     66    43                           inc ebx
34707 973A           EB           F4              jmp apm16_out_str1
34708                       0000973C            apm16_out_str2:
34709 973C     66    5B                           pop ebx
34710 973E     66    58                           pop eax
34711 9740           C3                           ret
34712                       00009741            apm16_07_poweroff_str:
34713 9741                        53              .ascii "Shutdown"
34714 9749                        00              db 0
34715                       0000974A            apm16_07_suspend_str:
34716 974A                        53              .ascii "Suspend"
34717 9751                        00              db 0
34718                       00009752            apm16_07_standby_str:
34719 9752                        53              .ascii "Standby"
34720 9759                        00              db 0
34721                       0000975A            _apm16_entry:
34722 975A           9C                           pushf
34723                                           ;-----------------
34724                                           ; APM interface disconnect
34725                       0000975B            apm16_04:
34726 975B           3C                     04    cmp al, #0x04
34727 975D           75           03              jne apm16_05
34728 975F           E9         008B              jmp apm16_ok
34729                                           ;-----------------
34730                                           ; APM cpu idle
34731                       00009762            apm16_05:
34732 9762           3C                     05    cmp al, #0x05
34733 9764           75           05              jne apm16_07
34734 9766           FB                           sti
34735 9767           F4                           hlt
34736 9768           E9         0082              jmp apm16_ok
34737                                           ;-----------------
34738                                           ; APM Set Power State
34739                       0000976B            apm16_07:
34740 976B           3C                     07    cmp al, #0x07
34741 976D           75           41              jne apm16_08
34742 976F           83FB                   01    cmp bx, #1
34743 9772           75           79              jne apm16_ok
34744 9774           83F9                   03    cmp cx, #3
34745 9777           74           0C              je apm16_07_poweroff
34746 9779           83F9                   02    cmp cx, #2
34747 977C           74           14              je apm16_07_suspend
34748 977E           83F9                   01    cmp cx, #1
34749 9781           74           1E              je apm16_07_standby
34750 9783           75           68              jne apm16_ok
34751                       00009785            apm16_07_poweroff:
34752 9785           FA                           cli
34753 9786           BA                   8900    mov dx, #0x8900
34754 9789           B8                   9741    mov ax, #apm16_07_poweroff_str
34755 978C           E8         FF9A              call apm16_out_str
34756                       0000978F            apm16_07_1:
34757 978F           F4                           hlt
34758 9790           EB           FD              jmp apm16_07_1
34759                       00009792            apm16_07_suspend:
34760 9792     66    52                           push edx
34761 9794           BA                   8900    mov dx, #0x8900
34762 9797           B8                   974A    mov ax, #apm16_07_suspend_str
34763 979A           E8         FF8C              call apm16_out_str
34764 979D     66    5A                           pop edx
34765 979F           EB           4C              jmp apm16_ok
34766                       000097A1            apm16_07_standby:
34767 97A1     66    52                           push edx
34768 97A3           BA                   8900    mov dx, #0x8900
34769 97A6           B8                   9752    mov ax, #apm16_07_standby_str
34770 97A9           E8         FF7D              call apm16_out_str
34771 97AC     66    5A                           pop edx
34772 97AE           EB           3D              jmp apm16_ok
34773                                           ;-----------------
34774                                           ; APM Enable / Disable
34775                       000097B0            apm16_08:
34776 97B0           3C                     08    cmp al, #0x08
34777 97B2           75           02              jne apm16_0a
34778 97B4           EB           37              jmp apm16_ok
34779                                           ;-----------------
34780                                           ; Get Power Status
34781                       000097B6            apm16_0a:
34782 97B6           3C                     0A    cmp al, #0x0a
34783 97B8           75           10              jne apm16_0b
34784 97BA           B7                     01    mov bh, #0x01
34785 97BC           B3                     FF    mov bl, #0xff
34786 97BE           B5                     80    mov ch, #0x80
34787 97C0           B1                     FF    mov cl, #0xff
34788 97C2           BA                   FFFF    mov dx, #0xffff
34789 97C5           BE                   0000    mov si, #0
34790 97C8           EB           23              jmp apm16_ok
34791                                           ;-----------------
34792                                           ; Get PM Event
34793                       000097CA            apm16_0b:
34794 97CA           3C                     0B    cmp al, #0x0b
34795 97CC           75           04              jne apm16_0e
34796 97CE           B4                     80    mov ah, #0x80
34797 97D0           EB           1E              jmp apm16_error
34798                                           ;-----------------
34799                                           ; APM Driver Version
34800                       000097D2            apm16_0e:
34801 97D2           3C                     0E    cmp al, #0x0e
34802 97D4           75           06              jne apm16_0f
34803 97D6           B4                     01    mov ah, #1
34804 97D8           B0                     02    mov al, #2
34805 97DA           EB           11              jmp apm16_ok
34806                                           ;-----------------
34807                                           ; APM Engage / Disengage
34808                       000097DC            apm16_0f:
34809 97DC           3C                     0F    cmp al, #0x0f
34810 97DE           75           02              jne apm16_10
34811 97E0           EB           0B              jmp apm16_ok
34812                                           ;-----------------
34813                                           ; APM Get Capabilities
34814                       000097E2            apm16_10:
34815 97E2           3C                     10    cmp al, #0x10
34816 97E4           75           0A              jne apm16_unimplemented
34817 97E6           B3                     00    mov bl, #0
34818 97E8           B9                   0000    mov cx, #0
34819 97EB           EB           00              jmp apm16_ok
34820                                           ;-----------------
34821                       000097ED            apm16_ok:
34822 97ED           9D                           popf
34823 97EE           F8                           clc
34824 97EF           CB                           retf
34825                       000097F0            apm16_unimplemented:
34826                       000097F0            apm16_error:
34827 97F0           9D                           popf
34828 97F1           F9                           stc
34829 97F2           CB                           retf
34830                       000097F3            apmreal_out_str:
34831 97F3     66    50                           push eax
34832 97F5     66    53                           push ebx
34833 97F7     66    89C3                         mov ebx, eax
34834                       000097FA            apmreal_out_str1:
34835 97FA           2E                           SEG CS
34836 97FB           8A07                         mov al, byte ptr [bx]
34837 97FD           3C                     00    cmp al, #0
34838 97FF           74           05              je apmreal_out_str2
34839 9801           EE                           outb dx, al
34840 9802     66    43                           inc ebx
34841 9804           EB           F4              jmp apmreal_out_str1
34842                       00009806            apmreal_out_str2:
34843 9806     66    5B                           pop ebx
34844 9808     66    58                           pop eax
34845 980A           C3                           ret
34846                       0000980B            apmreal_07_poweroff_str:
34847 980B                        53              .ascii "Shutdown"
34848 9813                        00              db 0
34849                       00009814            apmreal_07_suspend_str:
34850 9814                        53              .ascii "Suspend"
34851 981B                        00              db 0
34852                       0000981C            apmreal_07_standby_str:
34853 981C                        53              .ascii "Standby"
34854 9823                        00              db 0
34855 9824           9C                           pushf
34856                       00009825            _apmreal_entry:
34857                                           ;-----------------
34858                                           ; APM installation check
34859                       00009825            apmreal_00:
34860 9825           3C                     00    cmp al, #0x00
34861 9827           75           0E              jne apmreal_01
34862 9829           B4                     01    mov ah, #1
34863 982B           B0                     02    mov al, #2
34864 982D           B7                     50    mov bh, #0x50
34865 982F           B3                     4D    mov bl, #0x4d
34866 9831           B9                   0003    mov cx, #0x3
34867 9834           E9         00CE              jmp apmreal_ok
34868                                           ;-----------------
34869                                           ; APM real mode interface connect
34870                       00009837            apmreal_01:
34871 9837           3C                     01    cmp al, #0x01
34872 9839           75           03              jne apmreal_02
34873 983B           E9         00C7              jmp apmreal_ok
34874                                           ;-----------------
34875                                           ; APM 16 bit protected mode interface connect
34876                       0000983E            apmreal_02:
34877 983E           3C                     02    cmp al, #0x02
34878 9840           75           12              jne apmreal_03
34879 9842           BB                   975A    mov bx, #_apm16_entry
34880 9845           B8                   F000    mov ax, #0xf000
34881 9848           BE                   FFF0    mov si, #0xfff0
34882 984B           B9                   F000    mov cx, #0xf000
34883 984E           BF                   FFF0    mov di, #0xfff0
34884 9851           E9         00B1              jmp apmreal_ok
34885                                           ;-----------------
34886                                           ; APM 32 bit protected mode interface connect
34887                       00009854            apmreal_03:
34888 9854           3C                     03    cmp al, #0x03
34889 9856           75           1B              jne apmreal_04
34890 9858           B8                   F000    mov ax, #0xf000
34891 985B     66    BB               00009675    mov ebx, #_apm32_entry
34892 9861           B9                   F000    mov cx, #0xf000
34893 9864     66    BE               FFF0FFF0    mov esi, #0xfff0fff0
34894 986A           BA                   F000    mov dx, #0xf000
34895 986D           BF                   FFF0    mov di, #0xfff0
34896 9870           E9         0092              jmp apmreal_ok
34897                                           ;-----------------
34898                                           ; APM interface disconnect
34899                       00009873            apmreal_04:
34900 9873           3C                     04    cmp al, #0x04
34901 9875           75           03              jne apmreal_05
34902 9877           E9         008B              jmp apmreal_ok
34903                                           ;-----------------
34904                                           ; APM cpu idle
34905                       0000987A            apmreal_05:
34906 987A           3C                     05    cmp al, #0x05
34907 987C           75           05              jne apmreal_07
34908 987E           FB                           sti
34909 987F           F4                           hlt
34910 9880           E9         0082              jmp apmreal_ok
34911                                           ;-----------------
34912                                           ; APM Set Power State
34913                       00009883            apmreal_07:
34914 9883           3C                     07    cmp al, #0x07
34915 9885           75           41              jne apmreal_08
34916 9887           83FB                   01    cmp bx, #1
34917 988A           75           79              jne apmreal_ok
34918 988C           83F9                   03    cmp cx, #3
34919 988F           74           0C              je apmreal_07_poweroff
34920 9891           83F9                   02    cmp cx, #2
34921 9894           74           14              je apmreal_07_suspend
34922 9896           83F9                   01    cmp cx, #1
34923 9899           74           1E              je apmreal_07_standby
34924 989B           75           68              jne apmreal_ok
34925                       0000989D            apmreal_07_poweroff:
34926 989D           FA                           cli
34927 989E           BA                   8900    mov dx, #0x8900
34928 98A1           B8                   980B    mov ax, #apmreal_07_poweroff_str
34929 98A4           E8         FF4C              call apmreal_out_str
34930                       000098A7            apmreal_07_1:
34931 98A7           F4                           hlt
34932 98A8           EB           FD              jmp apmreal_07_1
34933                       000098AA            apmreal_07_suspend:
34934 98AA     66    52                           push edx
34935 98AC           BA                   8900    mov dx, #0x8900
34936 98AF           B8                   9814    mov ax, #apmreal_07_suspend_str
34937 98B2           E8         FF3E              call apmreal_out_str
34938 98B5     66    5A                           pop edx
34939 98B7           EB           4C              jmp apmreal_ok
34940                       000098B9            apmreal_07_standby:
34941 98B9     66    52                           push edx
34942 98BB           BA                   8900    mov dx, #0x8900
34943 98BE           B8                   981C    mov ax, #apmreal_07_standby_str
34944 98C1           E8         FF2F              call apmreal_out_str
34945 98C4     66    5A                           pop edx
34946 98C6           EB           3D              jmp apmreal_ok
34947                                           ;-----------------
34948                                           ; APM Enable / Disable
34949                       000098C8            apmreal_08:
34950 98C8           3C                     08    cmp al, #0x08
34951 98CA           75           02              jne apmreal_0a
34952 98CC           EB           37              jmp apmreal_ok
34953                                           ;-----------------
34954                                           ; Get Power Status
34955                       000098CE            apmreal_0a:
34956 98CE           3C                     0A    cmp al, #0x0a
34957 98D0           75           10              jne apmreal_0b
34958 98D2           B7                     01    mov bh, #0x01
34959 98D4           B3                     FF    mov bl, #0xff
34960 98D6           B5                     80    mov ch, #0x80
34961 98D8           B1                     FF    mov cl, #0xff
34962 98DA           BA                   FFFF    mov dx, #0xffff
34963 98DD           BE                   0000    mov si, #0
34964 98E0           EB           23              jmp apmreal_ok
34965                                           ;-----------------
34966                                           ; Get PM Event
34967                       000098E2            apmreal_0b:
34968 98E2           3C                     0B    cmp al, #0x0b
34969 98E4           75           04              jne apmreal_0e
34970 98E6           B4                     80    mov ah, #0x80
34971 98E8           EB           20              jmp apmreal_error
34972                                           ;-----------------
34973                                           ; APM Driver Version
34974                       000098EA            apmreal_0e:
34975 98EA           3C                     0E    cmp al, #0x0e
34976 98EC           75           06              jne apmreal_0f
34977 98EE           B4                     01    mov ah, #1
34978 98F0           B0                     02    mov al, #2
34979 98F2           EB           11              jmp apmreal_ok
34980                                           ;-----------------
34981                                           ; APM Engage / Disengage
34982                       000098F4            apmreal_0f:
34983 98F4           3C                     0F    cmp al, #0x0f
34984 98F6           75           02              jne apmreal_10
34985 98F8           EB           0B              jmp apmreal_ok
34986                                           ;-----------------
34987                                           ; APM Get Capabilities
34988                       000098FA            apmreal_10:
34989 98FA           3C                     10    cmp al, #0x10
34990 98FC           75           0C              jne apmreal_unimplemented
34991 98FE           B3                     00    mov bl, #0
34992 9900           B9                   0000    mov cx, #0
34993 9903           EB           00              jmp apmreal_ok
34994                                           ;-----------------
34995                       00009905            apmreal_ok:
34996 9905           9D                           popf
34997 9906           F8                           clc
34998 9907           E9         F8BD              jmp iret_modify_cf
34999                       0000990A            apmreal_unimplemented:
35000                       0000990A            apmreal_error:
35001 990A           9D                           popf
35002 990B           F9                           stc
35003 990C           E9         F8B8              jmp iret_modify_cf
35004                                           ;--------------------
35005                                           use32 386
35006 990F                  00000010            .align 16
35007                       00009910            bios32_structure:
35008 9910                        5F              db 0x5f, 0x33, 0x32, 0x5f ;; "_32_" signature
35009 9914                      9920              dw bios32_entry_point, 0xf ;; 32 bit physical address
35010 9918                        00              db 0 ;; revision level
35011                                             ;; length in paragraphs and checksum stored in a word to prevent errors
35012 9919                      1401              dw (~(((bios32_entry_point >> 8) + (bios32_entry_point & 0xff) + 0x32) & 0xff) << 8) + 0x01
35013 991B                        00              db 0,0,0,0,0 ;; reserved
35014 9920                  00000010            .align 16
35015                       00009920            bios32_entry_point:
35016 9920           9C                           pushfd
35017 9921           3D               49435024    cmp eax, #0x49435024 ;; "$PCI"
35018 9926           75           3E              jne unknown_service
35019 9928           B8               80000000    mov eax, #0x80000000
35020 992D     66    BA                   0CF8    mov dx, #0x0cf8
35021 9931           EF                           out dx, eax
35022 9932     66    BA                   0CFC    mov dx, #0x0cfc
35023 9936           ED                           in eax, dx
35024 9937           3D               12378086    cmp eax, #0x12378086 ;; i440FX PCI bridge
35025 993C           74           15              je pci_found
35026 993E           3D               01228086    cmp eax, #0x01228086 ;; i430FX PCI bridge
35027 9943           74           0E              je pci_found
35028 9945           3D               71908086    cmp eax, #0x71908086 ;; i440BX PCI bridge
35029 994A           74           07              je pci_found
35030                                             ;; say ok if a device is present
35031 994C           3D               FFFFFFFF    cmp eax, #0xffffffff
35032 9951           74           13              je unknown_service
35033                       00009953            pci_found:
35034 9953           BB               000F0000    mov ebx, #0x000f0000
35035 9958           B9               00010000    mov ecx, #0x10000
35036 995D           BA               00009970    mov edx, #pcibios_protected
35037 9962           30C0                         xor al, al
35038 9964           EB           02              jmp bios32_end
35039                       00009966            unknown_service:
35040 9966           B0                     80    mov al, #0x80
35041                       00009968            bios32_end:
35042 9968           9D                           popfd
35043 9969           CB                           retf
35044 996A                  00000010            .align 16
35045                       00009970            pcibios_protected:
35046 9970           9C                           pushfd
35047 9971           FA                           cli
35048 9972           56                           push esi
35049 9973           57                           push edi
35050 9974           3C                     01    cmp al, #0x01 ;; installation check
35051 9976           75           15              jne pci_pro_f02
35052 9978     66    BB                   0210    mov bx, #0x0210
35053 997C           E8     0000012E              call pci_pro_get_max_bus ;; sets CX
35054 9981           BA               20494350    mov edx, #0x20494350 ;; "PCI "
35055 9986           B0                     01    mov al, #0x01
35056 9988           E9     0000011B              jmp pci_pro_ok
35057                       0000998D            pci_pro_f02: ;; find pci device
35058 998D           3C                     02    cmp al, #0x02
35059 998F           75           38              jne pci_pro_f03
35060 9991           C1E1                   10    shl ecx, #16
35061 9994     66    89D1                         mov cx, dx
35062 9997     66    31DB                         xor bx, bx
35063 999A     66    BF                   0000    mov di, #0x00
35064                       0000999E            pci_pro_devloop:
35065 999E           E8     0000012D              call pci_pro_select_reg
35066 99A3     66    BA                   0CFC    mov dx, #0x0cfc
35067 99A7           ED                           in eax, dx
35068 99A8           39C8                         cmp eax, ecx
35069 99AA           75           0D              jne pci_pro_nextdev
35070 99AC     66    83FE                   00    cmp si, #0
35071 99B0   7505    E9     000000F1              je pci_pro_ok
35072 99B7     66    4E                           dec si
35073                       000099B9            pci_pro_nextdev:
35074 99B9     66    43                           inc bx
35075 99BB     66    81FB                 0200    cmp bx, #0x0200
35076 99C0           75           DC              jne pci_pro_devloop
35077 99C2           B4                     86    mov ah, #0x86
35078 99C4           E9     000000DA              jmp pci_pro_fail
35079                       000099C9            pci_pro_f03: ;; find class code
35080 99C9           3C                     03    cmp al, #0x03
35081 99CB           75           35              jne pci_pro_f08
35082 99CD     66    31DB                         xor bx, bx
35083 99D0     66    BF                   0008    mov di, #0x08
35084                       000099D4            pci_pro_devloop2:
35085 99D4           E8     000000F7              call pci_pro_select_reg
35086 99D9     66    BA                   0CFC    mov dx, #0x0cfc
35087 99DD           ED                           in eax, dx
35088 99DE           C1E8                   08    shr eax, #8
35089 99E1           39C8                         cmp eax, ecx
35090 99E3           75           0D              jne pci_pro_nextdev2
35091 99E5     66    83FE                   00    cmp si, #0
35092 99E9   7505    E9     000000B8              je pci_pro_ok
35093 99F0     66    4E                           dec si
35094                       000099F2            pci_pro_nextdev2:
35095 99F2     66    43                           inc bx
35096 99F4     66    81FB                 0200    cmp bx, #0x0200
35097 99F9           75           D9              jne pci_pro_devloop2
35098 99FB           B4                     86    mov ah, #0x86
35099 99FD           E9     000000A1              jmp pci_pro_fail
35100                       00009A02            pci_pro_f08: ;; read configuration byte
35101 9A02           3C                     08    cmp al, #0x08
35102 9A04           75           1B              jne pci_pro_f09
35103 9A06           E8     000000C5              call pci_pro_select_reg
35104 9A0B           52                           push edx
35105 9A0C     66    89FA                         mov dx, di
35106 9A0F     66    83E2                   03    and dx, #0x03
35107 9A13     66    81C2                 0CFC    add dx, #0x0cfc
35108 9A18           EC                           in al, dx
35109 9A19           5A                           pop edx
35110 9A1A           88C1                         mov cl, al
35111 9A1C           E9     00000087              jmp pci_pro_ok
35112                       00009A21            pci_pro_f09: ;; read configuration word
35113 9A21           3C                     09    cmp al, #0x09
35114 9A23           75           1A              jne pci_pro_f0a
35115 9A25           E8     000000A6              call pci_pro_select_reg
35116 9A2A           52                           push edx
35117 9A2B     66    89FA                         mov dx, di
35118 9A2E     66    83E2                   02    and dx, #0x02
35119 9A32     66    81C2                 0CFC    add dx, #0x0cfc
35120 9A37     66    ED                           in ax, dx
35121 9A39           5A                           pop edx
35122 9A3A     66    89C1                         mov cx, ax
35123 9A3D           EB           69              jmp pci_pro_ok
35124                       00009A3F            pci_pro_f0a: ;; read configuration dword
35125 9A3F           3C                     0A    cmp al, #0x0a
35126 9A41           75           10              jne pci_pro_f0b
35127 9A43           E8     00000088              call pci_pro_select_reg
35128 9A48           52                           push edx
35129 9A49     66    BA                   0CFC    mov dx, #0x0cfc
35130 9A4D           ED                           in eax, dx
35131 9A4E           5A                           pop edx
35132 9A4F           89C1                         mov ecx, eax
35133 9A51           EB           55              jmp pci_pro_ok
35134                       00009A53            pci_pro_f0b: ;; write configuration byte
35135 9A53           3C                     0B    cmp al, #0x0b
35136 9A55           75           18              jne pci_pro_f0c
35137 9A57           E8     00000074              call pci_pro_select_reg
35138 9A5C           52                           push edx
35139 9A5D     66    89FA                         mov dx, di
35140 9A60     66    83E2                   03    and dx, #0x03
35141 9A64     66    81C2                 0CFC    add dx, #0x0cfc
35142 9A69           88C8                         mov al, cl
35143 9A6B           EE                           out dx, al
35144 9A6C           5A                           pop edx
35145 9A6D           EB           39              jmp pci_pro_ok
35146                       00009A6F            pci_pro_f0c: ;; write configuration word
35147 9A6F           3C                     0C    cmp al, #0x0c
35148 9A71           75           1A              jne pci_pro_f0d
35149 9A73           E8     00000058              call pci_pro_select_reg
35150 9A78           52                           push edx
35151 9A79     66    89FA                         mov dx, di
35152 9A7C     66    83E2                   02    and dx, #0x02
35153 9A80     66    81C2                 0CFC    add dx, #0x0cfc
35154 9A85     66    89C8                         mov ax, cx
35155 9A88     66    EF                           out dx, ax
35156 9A8A           5A                           pop edx
35157 9A8B           EB           1B              jmp pci_pro_ok
35158                       00009A8D            pci_pro_f0d: ;; write configuration dword
35159 9A8D           3C                     0D    cmp al, #0x0d
35160 9A8F           75           10              jne pci_pro_unknown
35161 9A91           E8     0000003A              call pci_pro_select_reg
35162 9A96           52                           push edx
35163 9A97     66    BA                   0CFC    mov dx, #0x0cfc
35164 9A9B           89C8                         mov eax, ecx
35165 9A9D           EF                           out dx, eax
35166 9A9E           5A                           pop edx
35167 9A9F           EB           07              jmp pci_pro_ok
35168                       00009AA1            pci_pro_unknown:
35169 9AA1           B4                     81    mov ah, #0x81
35170                       00009AA3            pci_pro_fail:
35171 9AA3           5F                           pop edi
35172 9AA4           5E                           pop esi
35173 9AA5           9D                           popfd
35174 9AA6           F9                           stc
35175 9AA7           CB                           retf
35176                       00009AA8            pci_pro_ok:
35177 9AA8           30E4                         xor ah, ah
35178 9AAA           5F                           pop edi
35179 9AAB           5E                           pop esi
35180 9AAC           9D                           popfd
35181 9AAD           F8                           clc
35182 9AAE           CB                           retf
35183                       00009AAF            pci_pro_get_max_bus:
35184 9AAF           50                           push eax
35185 9AB0           B8               80000000    mov eax, #0x80000000
35186 9AB5     66    BA                   0CF8    mov dx, #0x0cf8
35187 9AB9           EF                           out dx, eax
35188 9ABA     66    BA                   0CFC    mov dx, #0x0cfc
35189 9ABE           ED                           in eax, dx
35190 9ABF     66    B9                   0000    mov cx, #0
35191 9AC3           3D               71908086    cmp eax, #0x71908086 ;; i440BX PCI bridge
35192 9AC8           75           04              jne pci_pro_no_i440bx
35193 9ACA     66    B9                   0001    mov cx, #0x0001
35194                       00009ACE            pci_pro_no_i440bx:
35195 9ACE           58                           pop eax
35196 9ACF           C3                           ret
35197                       00009AD0            pci_pro_select_reg:
35198 9AD0           52                           push edx
35199 9AD1           B8               00800000    mov eax, #0x800000
35200 9AD6     66    89D8                         mov ax, bx
35201 9AD9           C1E0                   08    shl eax, #8
35202 9ADC     66    81E7                 00FF    and di, #0xff
35203 9AE1     66    09F8                         or ax, di
35204 9AE4           24                     FC    and al, #0xfc
35205 9AE6     66    BA                   0CF8    mov dx, #0x0cf8
35206 9AEA           EF                           out dx, eax
35207 9AEB           5A                           pop edx
35208 9AEC           C3                           ret
35209                                           use16 386
35210                       00009AED            pcibios_real:
35211 9AED     66    50                           push eax
35212 9AEF           52                           push dx
35213 9AF0     66    B8               80000000    mov eax, #0x80000000
35214 9AF6           BA                   0CF8    mov dx, #0x0cf8
35215 9AF9     66    EF                           out dx, eax
35216 9AFB           BA                   0CFC    mov dx, #0x0cfc
35217 9AFE     66    ED                           in eax, dx
35218 9B00     66    3D               12378086    cmp eax, #0x12378086 ;; i440FX PCI bridge
35219 9B06           74           1F              je pci_present
35220 9B08     66    3D               01228086    cmp eax, #0x01228086 ;; i430FX PCI bridge
35221 9B0E           74           17              je pci_present
35222 9B10     66    3D               71908086    cmp eax, #0x71908086 ;; i440BX PCI bridge
35223 9B16           74           0F              je pci_present
35224                                             ;; say ok if a device is present
35225 9B18     66    3D               FFFFFFFF    cmp eax, #0xffffffff
35226 9B1E           75           07              jne pci_present
35227 9B20           5A                           pop dx
35228 9B21     66    58                           pop eax
35229 9B23           B4                     FF    mov ah, #0xff
35230 9B25           F9                           stc
35231 9B26           C3                           ret
35232                       00009B27            pci_present:
35233 9B27           5A                           pop dx
35234 9B28     66    58                           pop eax
35235 9B2A           3C                     01    cmp al, #0x01 ;; installation check
35236 9B2C           75           1A              jne pci_real_f02
35237 9B2E           B8                   0001    mov ax, #0x0001
35238 9B31           BB                   0210    mov bx, #0x0210
35239 9B34           E8         0145              call pci_real_get_max_bus ;; sets CX
35240 9B37     66    BA               20494350    mov edx, #0x20494350 ;; "PCI "
35241 9B3D     66    BF               000F0000    mov edi, #0xf0000
35242 9B43           BF                   9970    mov di, #pcibios_protected
35243 9B46           F8                           clc
35244 9B47           C3                           ret
35245                       00009B48            pci_real_f02: ;; find pci device
35246 9B48     66    56                           push esi
35247 9B4A     66    57                           push edi
35248 9B4C           3C                     02    cmp al, #0x02
35249 9B4E           75           34              jne pci_real_f03
35250 9B50     66    C1E1                   10    shl ecx, #16
35251 9B54           89D1                         mov cx, dx
35252 9B56           31DB                         xor bx, bx
35253 9B58           BF                   0000    mov di, #0x00
35254                       00009B5B            pci_real_devloop:
35255 9B5B           E8         0141              call pci_real_select_reg
35256 9B5E           BA                   0CFC    mov dx, #0x0cfc
35257 9B61     66    ED                           in eax, dx
35258 9B63     66    39C8                         cmp eax, ecx
35259 9B66           75           09              jne pci_real_nextdev
35260 9B68           83FE                   00    cmp si, #0
35261 9B6B   7503    E9         0104              je pci_real_ok
35262 9B70           4E                           dec si
35263                       00009B71            pci_real_nextdev:
35264 9B71           43                           inc bx
35265 9B72           81FB                 0200    cmp bx, #0x0200
35266 9B76           75           E3              jne pci_real_devloop
35267 9B78           89CA                         mov dx, cx
35268 9B7A     66    C1E9                   10    shr ecx, #16
35269 9B7E           B8                   8602    mov ax, #0x8602
35270 9B81           E9         00EA              jmp pci_real_fail
35271                       00009B84            pci_real_f03: ;; find class code
35272 9B84           3C                     03    cmp al, #0x03
35273 9B86           75           32              jne pci_real_f08
35274 9B88           31DB                         xor bx, bx
35275 9B8A           BF                   0008    mov di, #0x08
35276                       00009B8D            pci_real_devloop2:
35277 9B8D           E8         010F              call pci_real_select_reg
35278 9B90           BA                   0CFC    mov dx, #0x0cfc
35279 9B93     66    ED                           in eax, dx
35280 9B95     66    C1E8                   08    shr eax, #8
35281 9B99     66    39C8                         cmp eax, ecx
35282 9B9C           75           09              jne pci_real_nextdev2
35283 9B9E           83FE                   00    cmp si, #0
35284 9BA1   7503    E9         00CE              je pci_real_ok
35285 9BA6           4E                           dec si
35286                       00009BA7            pci_real_nextdev2:
35287 9BA7           43                           inc bx
35288 9BA8           81FB                 0200    cmp bx, #0x0200
35289 9BAC           75           DF              jne pci_real_devloop2
35290 9BAE           89CA                         mov dx, cx
35291 9BB0     66    C1E9                   10    shr ecx, #16
35292 9BB4           B8                   8603    mov ax, #0x8603
35293 9BB7           E9         00B4              jmp pci_real_fail
35294                       00009BBA            pci_real_f08: ;; read configuration byte
35295 9BBA           3C                     08    cmp al, #0x08
35296 9BBC           75           14              jne pci_real_f09
35297 9BBE           E8         00DE              call pci_real_select_reg
35298 9BC1           52                           push dx
35299 9BC2           89FA                         mov dx, di
35300 9BC4           83E2                   03    and dx, #0x03
35301 9BC7           81C2                 0CFC    add dx, #0x0cfc
35302 9BCB           EC                           in al, dx
35303 9BCC           5A                           pop dx
35304 9BCD           88C1                         mov cl, al
35305 9BCF           E9         00A2              jmp pci_real_ok
35306                       00009BD2            pci_real_f09: ;; read configuration word
35307 9BD2           3C                     09    cmp al, #0x09
35308 9BD4           75           14              jne pci_real_f0a
35309 9BD6           E8         00C6              call pci_real_select_reg
35310 9BD9           52                           push dx
35311 9BDA           89FA                         mov dx, di
35312 9BDC           83E2                   02    and dx, #0x02
35313 9BDF           81C2                 0CFC    add dx, #0x0cfc
35314 9BE3           ED                           in ax, dx
35315 9BE4           5A                           pop dx
35316 9BE5           89C1                         mov cx, ax
35317 9BE7           E9         008A              jmp pci_real_ok
35318                       00009BEA            pci_real_f0a: ;; read configuration dword
35319 9BEA           3C                     0A    cmp al, #0x0a
35320 9BEC           75           0F              jne pci_real_f0b
35321 9BEE           E8         00AE              call pci_real_select_reg
35322 9BF1           52                           push dx
35323 9BF2           BA                   0CFC    mov dx, #0x0cfc
35324 9BF5     66    ED                           in eax, dx
35325 9BF7           5A                           pop dx
35326 9BF8     66    89C1                         mov ecx, eax
35327 9BFB           EB           77              jmp pci_real_ok
35328                       00009BFD            pci_real_f0b: ;; write configuration byte
35329 9BFD           3C                     0B    cmp al, #0x0b
35330 9BFF           75           13              jne pci_real_f0c
35331 9C01           E8         009B              call pci_real_select_reg
35332 9C04           52                           push dx
35333 9C05           89FA                         mov dx, di
35334 9C07           83E2                   03    and dx, #0x03
35335 9C0A           81C2                 0CFC    add dx, #0x0cfc
35336 9C0E           88C8                         mov al, cl
35337 9C10           EE                           out dx, al
35338 9C11           5A                           pop dx
35339 9C12           EB           60              jmp pci_real_ok
35340                       00009C14            pci_real_f0c: ;; write configuration word
35341 9C14           3C                     0C    cmp al, #0x0c
35342 9C16           75           13              jne pci_real_f0d
35343 9C18           E8         0084              call pci_real_select_reg
35344 9C1B           52                           push dx
35345 9C1C           89FA                         mov dx, di
35346 9C1E           83E2                   02    and dx, #0x02
35347 9C21           81C2                 0CFC    add dx, #0x0cfc
35348 9C25           89C8                         mov ax, cx
35349 9C27           EF                           out dx, ax
35350 9C28           5A                           pop dx
35351 9C29           EB           49              jmp pci_real_ok
35352                       00009C2B            pci_real_f0d: ;; write configuration dword
35353 9C2B           3C                     0D    cmp al, #0x0d
35354 9C2D           75           0F              jne pci_real_f0e
35355 9C2F           E8         006D              call pci_real_select_reg
35356 9C32           52                           push dx
35357 9C33           BA                   0CFC    mov dx, #0x0cfc
35358 9C36     66    89C8                         mov eax, ecx
35359 9C39     66    EF                           out dx, eax
35360 9C3B           5A                           pop dx
35361 9C3C           EB           36              jmp pci_real_ok
35362                       00009C3E            pci_real_f0e: ;; get irq routing options
35363 9C3E           3C                     0E    cmp al, #0x0e
35364 9C40           75           2A              jne pci_real_unknown
35365 9C42           50                           push ax
35366 9C43           B8                   0060    mov ax, #pci_routing_table_structure_end - pci_routing_table_structure_start
35367 9C46           26                           SEG ES
35368 9C47           3905                         cmp word ptr [di], ax
35369 9C49           72           1B              jb pci_real_too_small
35370 9C4B           AB                           stosw
35371 9C4C           9C                           pushf
35372 9C4D           06                           push es
35373 9C4E           51                           push cx
35374 9C4F           FC                           cld
35375 9C50           BE                   9CE0    mov si, #pci_routing_table_structure_start
35376 9C53           0E                           push cs
35377 9C54           1F                           pop ds
35378 9C55           26                           SEG ES
35379 9C56           C47D         02              les di, [di+2]
35380 9C59           89C1                         mov cx, ax
35381 9C5B           F3                           rep
35382 9C5C           A4                               movsb
35383 9C5D           59                           pop cx
35384 9C5E           07                           pop es
35385 9C5F           9D                           popf
35386 9C60           58                           pop ax
35387 9C61           BB                   0A00    mov bx, #(1 << 9) | (1 << 11) ;; irq 9 and 11 are used
35388 9C64           EB           0E              jmp pci_real_ok
35389                       00009C66            pci_real_too_small:
35390 9C66           AB                           stosw
35391 9C67           58                           pop ax
35392 9C68           B4                     89    mov ah, #0x89
35393 9C6A           EB           02              jmp pci_real_fail
35394                       00009C6C            pci_real_unknown:
35395 9C6C           B4                     81    mov ah, #0x81
35396                       00009C6E            pci_real_fail:
35397 9C6E     66    5F                           pop edi
35398 9C70     66    5E                           pop esi
35399 9C72           F9                           stc
35400 9C73           C3                           ret
35401                       00009C74            pci_real_ok:
35402 9C74           30E4                         xor ah, ah
35403 9C76     66    5F                           pop edi
35404 9C78     66    5E                           pop esi
35405 9C7A           F8                           clc
35406 9C7B           C3                           ret
35407                       00009C7C            pci_real_get_max_bus:
35408 9C7C     66    50                           push eax
35409 9C7E     66    B8               80000000    mov eax, #0x80000000
35410 9C84           BA                   0CF8    mov dx, #0x0cf8
35411 9C87     66    EF                           out dx, eax
35412 9C89           BA                   0CFC    mov dx, #0x0cfc
35413 9C8C     66    ED                           in eax, dx
35414 9C8E           B9                   0000    mov cx, #0
35415 9C91     66    3D               71908086    cmp eax, #0x71908086 ;; i440BX PCI bridge
35416 9C97           75           03              jne pci_real_no_i440bx
35417 9C99           B9                   0001    mov cx, #0x0001
35418                       00009C9C            pci_real_no_i440bx:
35419 9C9C     66    58                           pop eax
35420 9C9E           C3                           ret
35421                       00009C9F            pci_real_select_reg:
35422 9C9F           52                           push dx
35423 9CA0     66    B8               00800000    mov eax, #0x800000
35424 9CA6           89D8                         mov ax, bx
35425 9CA8     66    C1E0                   08    shl eax, #8
35426 9CAC           81E7                 00FF    and di, #0xff
35427 9CB0           09F8                         or ax, di
35428 9CB2           24                     FC    and al, #0xfc
35429 9CB4           BA                   0CF8    mov dx, #0x0cf8
35430 9CB7     66    EF                           out dx, eax
35431 9CB9           5A                           pop dx
35432 9CBA           C3                           ret
35433 9CBB                  00000010            .align 16
35434                       00009CC0            pci_routing_table_structure:
35435 9CC0                        24              db 0x24, 0x50, 0x49, 0x52 ;; "$PIR" signature
35436 9CC4                        00              db 0, 1 ;; version
35437 9CC6                      0080              dw 32 + (6 * 16) ;; table size
35438 9CC8                        00              db 0 ;; PCI interrupt router bus
35439 9CC9                        08              db 0x08 ;; PCI interrupt router DevFunc
35440 9CCA                      0000              dw 0x0000 ;; PCI exclusive IRQs
35441 9CCC                      8086              dw 0x8086 ;; compatible PCI interrupt router vendor ID
35442 9CCE                      122E              dw 0x122e ;; compatible PCI interrupt router device ID
35443 9CD0                      0000              dw 0,0 ;; Miniport data
35444 9CD4                        00              db 0,0,0,0,0,0,0,0,0,0,0 ;; reserved
35445 9CDF                        37              db 0x37 ;; checksum
35446                       00009CE0            pci_routing_table_structure_start:
35447                                             ;; first slot entry PCI-to-ISA (embedded)
35448 9CE0                        00              db 0 ;; pci bus number
35449 9CE1                        08              db 0x08 ;; pci device number (bit 7-3)
35450 9CE2                        60              db 0x60 ;; link value INTA#: pointer into PCI2ISA config space
35451 9CE3                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
35452 9CE5                        61              db 0x61 ;; link value INTB#
35453 9CE6                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
35454 9CE8                        62              db 0x62 ;; link value INTC#
35455 9CE9                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
35456 9CEB                        63              db 0x63 ;; link value INTD#
35457 9CEC                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
35458 9CEE                        00              db 0 ;; physical slot (0 = embedded)
35459 9CEF                        00              db 0 ;; reserved
35460                                             ;; second slot entry: 1st PCI slot
35461 9CF0                        00              db 0 ;; pci bus number
35462 9CF1                        10              db 0x10 ;; pci device number (bit 7-3)
35463 9CF2                        61              db 0x61 ;; link value INTA#
35464 9CF3                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
35465 9CF5                        62              db 0x62 ;; link value INTB#
35466 9CF6                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
35467 9CF8                        63              db 0x63 ;; link value INTC#
35468 9CF9                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
35469 9CFB                        60              db 0x60 ;; link value INTD#
35470 9CFC                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
35471 9CFE                        01              db 1 ;; physical slot (0 = embedded)
35472 9CFF                        00              db 0 ;; reserved
35473                                             ;; third slot entry: 2nd PCI slot
35474 9D00                        00              db 0 ;; pci bus number
35475 9D01                        18              db 0x18 ;; pci device number (bit 7-3)
35476 9D02                        62              db 0x62 ;; link value INTA#
35477 9D03                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
35478 9D05                        63              db 0x63 ;; link value INTB#
35479 9D06                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
35480 9D08                        60              db 0x60 ;; link value INTC#
35481 9D09                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
35482 9D0B                        61              db 0x61 ;; link value INTD#
35483 9D0C                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
35484 9D0E                        02              db 2 ;; physical slot (0 = embedded)
35485 9D0F                        00              db 0 ;; reserved
35486                                             ;; 4th slot entry: 3rd PCI slot
35487 9D10                        00              db 0 ;; pci bus number
35488 9D11                        20              db 0x20 ;; pci device number (bit 7-3)
35489 9D12                        63              db 0x63 ;; link value INTA#
35490 9D13                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
35491 9D15                        60              db 0x60 ;; link value INTB#
35492 9D16                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
35493 9D18                        61              db 0x61 ;; link value INTC#
35494 9D19                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
35495 9D1B                        62              db 0x62 ;; link value INTD#
35496 9D1C                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
35497 9D1E                        03              db 3 ;; physical slot (0 = embedded)
35498 9D1F                        00              db 0 ;; reserved
35499                                             ;; 5th slot entry: 4th PCI slot
35500 9D20                        00              db 0 ;; pci bus number
35501 9D21                        28              db 0x28 ;; pci device number (bit 7-3)
35502 9D22                        60              db 0x60 ;; link value INTA#
35503 9D23                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
35504 9D25                        61              db 0x61 ;; link value INTB#
35505 9D26                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
35506 9D28                        62              db 0x62 ;; link value INTC#
35507 9D29                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
35508 9D2B                        63              db 0x63 ;; link value INTD#
35509 9D2C                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
35510 9D2E                        04              db 4 ;; physical slot (0 = embedded)
35511 9D2F                        00              db 0 ;; reserved
35512                                             ;; 6th slot entry: 5th PCI slot
35513 9D30                        00              db 0 ;; pci bus number
35514 9D31                        30              db 0x30 ;; pci device number (bit 7-3)
35515 9D32                        61              db 0x61 ;; link value INTA#
35516 9D33                      DEF8              dw 0xdef8 ;; IRQ bitmap INTA#
35517 9D35                        62              db 0x62 ;; link value INTB#
35518 9D36                      DEF8              dw 0xdef8 ;; IRQ bitmap INTB#
35519 9D38                        63              db 0x63 ;; link value INTC#
35520 9D39                      DEF8              dw 0xdef8 ;; IRQ bitmap INTC#
35521 9D3B                        60              db 0x60 ;; link value INTD#
35522 9D3C                      DEF8              dw 0xdef8 ;; IRQ bitmap INTD#
35523 9D3E                        05              db 5 ;; physical slot (0 = embedded)
35524 9D3F                        00              db 0 ;; reserved
35525                       00009D40            pci_routing_table_structure_end:
35526                       00009D40            pci_irq_list:
35527 9D40                        0B              db 11, 10, 9, 5;
35528                       00009D44            pcibios_init_sel_reg:
35529 9D44     66    50                           push eax
35530 9D46     66    B8               00800000    mov eax, #0x800000
35531 9D4C           89D8                         mov ax, bx
35532 9D4E     66    C1E0                   08    shl eax, #8
35533 9D52           80E2                   FC    and dl, #0xfc
35534 9D55           08D0                         or al, dl
35535 9D57           BA                   0CF8    mov dx, #0x0cf8
35536 9D5A     66    EF                           out dx, eax
35537 9D5C     66    58                           pop eax
35538 9D5E           C3                           ret
35539                       00009D5F            pcibios_init_iomem_bases:
35540 9D5F           55                           push bp
35541 9D60           89E5                         mov bp, sp
35542 9D62     66    B8               C0000000    mov eax, #0xc0000000 ;; base for memory init
35543 9D68     66    50                           push eax
35544 9D6A           B8                   C000    mov ax, #0xc000 ;; base for i/o init
35545 9D6D           50                           push ax
35546 9D6E           B8                   0010    mov ax, #0x0010 ;; start at base address #0
35547 9D71           50                           push ax
35548 9D72           BB                   0008    mov bx, #0x0008
35549                       00009D75            pci_init_io_loop1:
35550 9D75           B2                     00    mov dl, #0x00
35551 9D77           E8         FFCA              call pcibios_init_sel_reg
35552 9D7A           BA                   0CFC    mov dx, #0x0cfc
35553 9D7D           ED                           in ax, dx
35554 9D7E           3D                   FFFF    cmp ax, #0xffff
35555 9D81   7503    E9         0087              jz next_pci_dev
35556 9D86           B2                     04    mov dl, #0x04 ;; disable i/o and memory space access
35557 9D88           E8         FFB9              call pcibios_init_sel_reg
35558 9D8B           BA                   0CFC    mov dx, #0x0cfc
35559 9D8E           EC                           in al, dx
35560 9D8F           24                     FC    and al, #0xfc
35561 9D91           EE                           out dx, al
35562                       00009D92            pci_init_io_loop2:
35563 9D92           8A56         F8              mov dl, [bp-8]
35564 9D95           E8         FFAC              call pcibios_init_sel_reg
35565 9D98           BA                   0CFC    mov dx, #0x0cfc
35566 9D9B     66    ED                           in eax, dx
35567 9D9D           A8                     01    test al, #0x01
35568 9D9F           75           33              jnz init_io_base
35569 9DA1     66    89C1                         mov ecx, eax
35570 9DA4     66    B8               FFFFFFFF    mov eax, #0xffffffff
35571 9DAA     66    EF                           out dx, eax
35572 9DAC     66    ED                           in eax, dx
35573 9DAE     66    39C8                         cmp eax, ecx
35574 9DB1           74           40              je next_pci_base
35575 9DB3     66    F7D0                         not eax
35576 9DB6     66    89C1                         mov ecx, eax
35577 9DB9     66    8B46         FC              mov eax, [bp-4]
35578 9DBD     66    EF                           out dx, eax
35579 9DBF     66    01C8                         add eax, ecx ;; calculate next free mem base
35580 9DC2     66    05               01000000    add eax, #0x01000000
35581 9DC8     66    25               FF000000    and eax, #0xff000000
35582 9DCE     66    8946         FC              mov [bp-4], eax
35583 9DD2           EB           1F              jmp next_pci_base
35584                       00009DD4            init_io_base:
35585 9DD4           89C1                         mov cx, ax
35586 9DD6           B8                   FFFF    mov ax, #0xffff
35587 9DD9           EF                           out dx, ax
35588 9DDA           ED                           in ax, dx
35589 9DDB           39C8                         cmp ax, cx
35590 9DDD           74           14              je next_pci_base
35591 9DDF           35                   FFFE    xor ax, #0xfffe
35592 9DE2           89C1                         mov cx, ax
35593 9DE4           8B46         FA              mov ax, [bp-6]
35594 9DE7           EF                           out dx, ax
35595 9DE8           01C8                         add ax, cx ;; calculate next free i/o base
35596 9DEA           05                   0100    add ax, #0x0100
35597 9DED           25                   FF00    and ax, #0xff00
35598 9DF0           8946         FA              mov [bp-6], ax
35599                       00009DF3            next_pci_base:
35600 9DF3           8A46         F8              mov al, [bp-8]
35601 9DF6           04                     04    add al, #0x04
35602 9DF8           3C                     28    cmp al, #0x28
35603 9DFA           74           05              je enable_iomem_space
35604 9DFC           8846         F8              mov byte ptr[bp-8], al
35605 9DFF           EB           91              jmp pci_init_io_loop2
35606                       00009E01            enable_iomem_space:
35607 9E01           B2                     04    mov dl, #0x04 ;; enable i/o and memory space access if available
35608 9E03           E8         FF3E              call pcibios_init_sel_reg
35609 9E06           BA                   0CFC    mov dx, #0x0cfc
35610 9E09           EC                           in al, dx
35611 9E0A           0C                     03    or al, #0x03
35612 9E0C           EE                           out dx, al
35613                       00009E0D            next_pci_dev:
35614 9E0D           C646         F8        10    mov byte ptr[bp-8], #0x10
35615 9E11           43                           inc bx
35616 9E12           81FB                 0100    cmp bx, #0x0100
35617 9E16   7403    E9         FF5A              jne pci_init_io_loop1
35618 9E1B           C9                           leave
35619 9E1C           C3                           ret
35620                       00009E1D            pcibios_init_set_elcr:
35621 9E1D           50                           push ax
35622 9E1E           51                           push cx
35623 9E1F           BA                   04D0    mov dx, #0x04d0
35624 9E22           A8                     08    test al, #0x08
35625 9E24           74           03              jz is_master_pic
35626 9E26           42                           inc dx
35627 9E27           24                     07    and al, #0x07
35628                       00009E29            is_master_pic:
35629 9E29           88C1                         mov cl, al
35630 9E2B           B3                     01    mov bl, #0x01
35631 9E2D           D2E3                         shl bl, cl
35632 9E2F           EC                           in al, dx
35633 9E30           08D8                         or al, bl
35634 9E32           EE                           out dx, al
35635 9E33           59                           pop cx
35636 9E34           58                           pop ax
35637 9E35           C3                           ret
35638                       00009E36            pcibios_init_irqs:
35639 9E36           1E                           push ds
35640 9E37           55                           push bp
35641 9E38           0E                           push cs
35642 9E39           1F                           pop ds
35643 9E3A           BA                   04D0    mov dx, #0x04d0 ;; reset ELCR1 + ELCR2
35644 9E3D           B0                     00    mov al, #0x00
35645 9E3F           EE                           out dx, al
35646 9E40           42                           inc dx
35647 9E41           EE                           out dx, al
35648 9E42           BE                   9CC0    mov si, #pci_routing_table_structure
35649 9E45           8A7C         08              mov bh, [si+8]
35650 9E48           8A5C         09              mov bl, [si+9]
35651 9E4B           B2                     00    mov dl, #0x00
35652 9E4D           E8         FEF4              call pcibios_init_sel_reg
35653 9E50           BA                   0CFC    mov dx, #0x0cfc
35654 9E53           ED                           in ax, dx
35655 9E54           3B44         0C              cmp ax, [si+12] ;; check irq router
35656 9E57   7403    E9         00A4              jne pci_init_end
35657 9E5C           8A54         22              mov dl, [si+34]
35658 9E5F           E8         FEE2              call pcibios_init_sel_reg
35659 9E62           53                           push bx ;; save irq router bus + devfunc
35660 9E63           BA                   0CFC    mov dx, #0x0cfc
35661 9E66           B8                   8080    mov ax, #0x8080
35662 9E69           EF                           out dx, ax ;; reset PIRQ route control
35663 9E6A           83C2                   02    add dx, #2
35664 9E6D           EF                           out dx, ax
35665 9E6E           8B44         06              mov ax, [si+6]
35666 9E71           2D                   0020    sub ax, #0x20
35667 9E74           C1E8                   04    shr ax, #4
35668 9E77           89C1                         mov cx, ax
35669 9E79           83C6                   20    add si, #0x20 ;; set pointer to 1st entry
35670 9E7C           89E5                         mov bp, sp
35671 9E7E           68                   9D40    push #pci_irq_list
35672 9E81           6A                     00    push #0x00
35673                       00009E83            pci_init_irq_loop1:
35674 9E83           8A3C                         mov bh, [si]
35675 9E85           8A5C         01              mov bl, [si+1]
35676                       00009E88            pci_init_irq_loop2:
35677 9E88           B2                     00    mov dl, #0x00
35678 9E8A           E8         FEB7              call pcibios_init_sel_reg
35679 9E8D           BA                   0CFC    mov dx, #0x0cfc
35680 9E90           ED                           in ax, dx
35681 9E91           3D                   FFFF    cmp ax, #0xffff
35682 9E94           75           07              jnz pci_test_int_pin
35683 9E96           F6C3                   07    test bl, #0x07
35684 9E99           74           59              jz next_pir_entry
35685 9E9B           EB           4D              jmp next_pci_func
35686                       00009E9D            pci_test_int_pin:
35687 9E9D           B2                     3C    mov dl, #0x3c
35688 9E9F           E8         FEA2              call pcibios_init_sel_reg
35689 9EA2           BA                   0CFD    mov dx, #0x0cfd
35690 9EA5           EC                           in al, dx
35691 9EA6           24                     07    and al, #0x07
35692 9EA8           74           40              jz next_pci_func
35693 9EAA           FEC8                         dec al ;; determine pirq reg
35694 9EAC           B2                     03    mov dl, #0x03
35695 9EAE           F6E2                         mul al, dl
35696 9EB0           04                     02    add al, #0x02
35697 9EB2           30E4                         xor ah, ah
35698 9EB4           89C3                         mov bx, ax
35699 9EB6           8A           00              mov al, [si+bx]
35700 9EB8           88C2                         mov dl, al
35701 9EBA           8B5E         00              mov bx, [bp]
35702 9EBD           E8         FE84              call pcibios_init_sel_reg
35703 9EC0           BA                   0CFC    mov dx, #0x0cfc
35704 9EC3           24                     03    and al, #0x03
35705 9EC5           00C2                         add dl, al
35706 9EC7           EC                           in al, dx
35707 9EC8           3C                     80    cmp al, #0x80
35708 9ECA           72           0D              jb pirq_found
35709 9ECC           8B5E         FE              mov bx, [bp-2] ;; pci irq list pointer
35710 9ECF           8A07                         mov al, [bx]
35711 9ED1           EE                           out dx, al
35712 9ED2           43                           inc bx
35713 9ED3           895E         FE              mov [bp-2], bx
35714 9ED6           E8         FF44              call pcibios_init_set_elcr
35715                       00009ED9            pirq_found:
35716 9ED9           8A3C                         mov bh, [si]
35717 9EDB           8A5C         01              mov bl, [si+1]
35718 9EDE           025E         FD              add bl, [bp-3] ;; pci function number
35719 9EE1           B2                     3C    mov dl, #0x3c
35720 9EE3           E8         FE5E              call pcibios_init_sel_reg
35721 9EE6           BA                   0CFC    mov dx, #0x0cfc
35722 9EE9           EE                           out dx, al
35723                       00009EEA            next_pci_func:
35724 9EEA           FE46         FD              inc byte ptr[bp-3]
35725 9EED           FEC3                         inc bl
35726 9EEF           F6C3                   07    test bl, #0x07
35727 9EF2           75           94              jnz pci_init_irq_loop2
35728                       00009EF4            next_pir_entry:
35729 9EF4           83C6                   10    add si, #0x10
35730 9EF7           C646         FD        00    mov byte ptr[bp-3], #0x00
35731 9EFB           E2           86              loop pci_init_irq_loop1
35732 9EFD           89EC                         mov sp, bp
35733 9EFF           5B                           pop bx
35734                       00009F00            pci_init_end:
35735 9F00           5D                           pop bp
35736 9F01           1F                           pop ds
35737 9F02           C3                           ret
35738                                           ; parallel port detection: base address in DX, index in BX, timeout in CL
35739                       00009F03            detect_parport:
35740 9F03           52                           push dx
35741 9F04           83C2                   02    add dx, #2
35742 9F07           EC                           in al, dx
35743 9F08           24                     DF    and al, #0xdf ; clear input mode
35744 9F0A           EE                           out dx, al
35745 9F0B           5A                           pop dx
35746 9F0C           B0                     AA    mov al, #0xaa
35747 9F0E           EE                           out dx, al
35748 9F0F           EC                           in al, dx
35749 9F10           3C                     AA    cmp al, #0xaa
35750 9F12           75           0D              jne no_parport
35751 9F14           53                           push bx
35752 9F15           D1E3                         shl bx, #1
35753 9F17           8997       0408              mov [bx+0x408], dx ; Parallel I/O address
35754 9F1B           5B                           pop bx
35755 9F1C           888F       0478              mov [bx+0x478], cl ; Parallel printer timeout
35756 9F20           43                           inc bx
35757                       00009F21            no_parport:
35758 9F21           C3                           ret
35759                                           ; serial port detection: base address in DX, index in BX, timeout in CL
35760                       00009F22            detect_serial:
35761 9F22           52                           push dx
35762 9F23           42                           inc dx
35763 9F24           B0                     02    mov al, #0x02
35764 9F26           EE                           out dx, al
35765 9F27           EC                           in al, dx
35766 9F28           3C                     02    cmp al, #0x02
35767 9F2A           75           19              jne no_serial
35768 9F2C           42                           inc dx
35769 9F2D           EC                           in al, dx
35770 9F2E           3C                     02    cmp al, #0x02
35771 9F30           75           13              jne no_serial
35772 9F32           4A                           dec dx
35773 9F33           30C0                         xor al, al
35774 9F35           EE                           out dx, al
35775 9F36           5A                           pop dx
35776 9F37           53                           push bx
35777 9F38           D1E3                         shl bx, #1
35778 9F3A           8997       0400              mov [bx+0x400], dx ; Serial I/O address
35779 9F3E           5B                           pop bx
35780 9F3F           888F       047C              mov [bx+0x47c], cl ; Serial timeout
35781 9F43           43                           inc bx
35782 9F44           C3                           ret
35783                       00009F45            no_serial:
35784 9F45           5A                           pop dx
35785 9F46           C3                           ret
35786                       00009F47            rom_checksum:
35787 9F47           60                           pusha
35788 9F48           1E                           push ds
35789 9F49           31C0                         xor ax, ax
35790 9F4B           31DB                         xor bx, bx
35791 9F4D           31C9                         xor cx, cx
35792 9F4F           31D2                         xor dx, dx
35793 9F51           8A2E       0002              mov ch, [2]
35794 9F55           D1E1                         shl cx, #1
35795 9F57           73           05              jnc checksum_loop
35796 9F59           74           03              jz checksum_loop
35797 9F5B           87CA                         xchg dx, cx
35798 9F5D           49                           dec cx
35799                       00009F5E            checksum_loop:
35800 9F5E           0207                         add al, [bx]
35801 9F60           43                           inc bx
35802 9F61           E2           FB              loop checksum_loop
35803 9F63           85D2                         test dx, dx
35804 9F65           74           11              je checksum_out
35805 9F67           0207                         add al, [bx]
35806 9F69           89D1                         mov cx, dx
35807 9F6B           8CDA                         mov dx, ds
35808 9F6D           80C6                   10    add dh, #0x10
35809 9F70           8EDA                         mov ds, dx
35810 9F72           31D2                         xor dx, dx
35811 9F74           31DB                         xor bx, bx
35812 9F76           EB           E6              jmp checksum_loop
35813                       00009F78            checksum_out:
35814 9F78           24                     FF    and al, #0xff
35815 9F7A           1F                           pop ds
35816 9F7B           61                           popa
35817 9F7C           C3                           ret
35818 9F7D                  00000010            .align 16
35819                       00009F80            pnpbios_structure:
35820 9F80                        24              .ascii "$PnP"
35821 9F84                        10              db 0x10 ;; version
35822 9F85                        21              db 0x21 ;; length
35823 9F86                      0000              dw 0x0 ;; control field
35824 9F88                        D1              db 0xd1 ;; checksum
35825 9F89                  000F0000              dd 0xf0000 ;; event notification flag address
35826 9F8D                      9FA8              dw pnpbios_real ;; real mode 16 bit offset
35827 9F8F                      F000              dw 0xf000 ;; real mode 16 bit segment
35828 9F91                      9FA1              dw pnpbios_prot ;; 16 bit protected mode offset
35829 9F93                  000F0000              dd 0xf0000 ;; 16 bit protected mode segment base
35830 9F97                  00000000              dd 0x0 ;; OEM device identifier
35831 9F9B                      F000              dw 0xf000 ;; real mode 16 bit data segment
35832 9F9D                  000F0000              dd 0xf0000 ;; 16 bit protected mode segment base
35833                       00009FA1            pnpbios_prot:
35834 9FA1     66    55                           push ebp
35835 9FA3     66    89E5                         mov ebp, esp
35836 9FA6           EB           06              jmp pnpbios_code
35837                       00009FA8            pnpbios_real:
35838 9FA8     66    55                           push ebp
35839 9FAA     66  0FB7EC                         movzx ebp, sp
35840                       00009FAE            pnpbios_code:
35841 9FAE   67      8B45         08              mov ax, 8[ebp]
35842 9FB2           3D                   0060    cmp ax, #0x60 ;; Get Version and Installation Check
35843 9FB5           75           10              jnz pnpbios_00
35844 9FB7           06                           push es
35845 9FB8           57                           push di
35846 9FB9   67      C47D         0A              les di, 10[ebp]
35847 9FBD           B8                   0101    mov ax, #0x0101
35848 9FC0           AB                           stosw
35849 9FC1           5F                           pop di
35850 9FC2           07                           pop es
35851 9FC3           31C0                         xor ax, ax ;; SUCCESS
35852 9FC5           EB           1F              jmp pnpbios_exit
35853                       00009FC7            pnpbios_00:
35854 9FC7           3D                   0000    cmp ax, #0x00 ;; Get Number of System Device Nodes
35855 9FCA           75           17              jnz pnpbios_fail
35856 9FCC           06                           push es
35857 9FCD           57                           push di
35858 9FCE   67      C47D         0A              les di, 10[ebp]
35859 9FD2           B0                     00    mov al, #0x00
35860 9FD4           AA                           stosb
35861 9FD5   67      C47D         0E              les di, 14[ebp]
35862 9FD9           B8                   0000    mov ax, #0x0000
35863 9FDC           AB                           stosw
35864 9FDD           5F                           pop di
35865 9FDE           07                           pop es
35866 9FDF           31C0                         xor ax, ax ;; SUCCESS
35867 9FE1           EB           03              jmp pnpbios_exit
35868                       00009FE3            pnpbios_fail:
35869 9FE3           B8                   0082    mov ax, #0x82 ;; FUNCTION_NOT_SUPPORTED
35870                       00009FE6            pnpbios_exit:
35871 9FE6     66    5D                           pop ebp
35872 9FE8           CB                           retf
35873                       00009FE9            rom_scan:
35874                                             ;; Scan for existence of valid expansion ROMS.
35875                                             ;; Video ROM: from 0xC0000..0xC7FFF in 2k increments
35876                                             ;; General ROM: from 0xC8000..0xDFFFF in 2k increments
35877                                             ;; System ROM: only 0xE0000
35878                                             ;;
35879                                             ;; Header:
35880                                             ;; Offset Value
35881                                             ;; 0 0x55
35882                                             ;; 1 0xAA
35883                                             ;; 2 ROM length in 512-byte blocks
35884                                             ;; 3 ROM initialization entry point (FAR CALL)
35885                       00009FE9            rom_scan_loop:
35886 9FE9           50                           push ax ;; Save AX
35887 9FEA           8ED9                         mov ds, cx
35888 9FEC           B8                   0004    mov ax, #0x0004 ;; start with increment of 4 (512-byte) blocks = 2k
35889 9FEF           813E       0000      AA55    cmp [0], #0xAA55 ;; look for signature
35890 9FF5   7403    E9         009E              jne rom_scan_increment
35891 9FFA           E8         FF4A              call rom_checksum
35892 9FFD   7403    E9         0096              jnz rom_scan_increment
35893 A002           A0         0002              mov al, [2] ;; change increment to ROM length in 512-byte blocks
35894                                             ;; We want our increment in 512-byte quantities, rounded to
35895                                             ;; the nearest 2k quantity, since we only scan at 2k intervals.
35896 A005           A8                     03    test al, #0x03
35897 A007           74           04              jz block_count_rounded
35898 A009           24                     FC    and al, #0xfc ;; needs rounding up
35899 A00B           04                     04    add al, #0x04
35900                       0000A00D            block_count_rounded:
35901 A00D           31DB                         xor bx, bx ;; Restore DS back to 0000:
35902 A00F           8EDB                         mov ds, bx
35903 A011           50                           push ax ;; Save AX
35904 A012           57                           push di ;; Save DI
35905                                             ;; Push addr of ROM entry point
35906 A013           51                           push cx ;; Push seg
35907 A014           6A                     03    push #0x0003 ;; Push offset
35908                                             ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
35909                                             ;; That should stop it grabbing INT 19h; we will use its BEV instead.
35910 A016           B8                   F000    mov ax, #0xf000
35911 A019           8EC0                         mov es, ax
35912 A01B           8D3E       9F80              lea di, pnpbios_structure
35913 A01F           89E5                         mov bp, sp ;; Call ROM init routine using seg:off on stack
35914 A021                        FF              db 0xff ;; call_far ss:[bp+0]
35915 A022                        5E              db 0x5e
35916 A023                        00              db 0
35917 A024           FA                           cli ;; In case expansion ROM BIOS turns IF on
35918 A025           83C4                   02    add sp, #2 ;; Pop offset value
35919 A028           59                           pop cx ;; Pop seg value (restore CX)
35920                                             ;; Look at the ROM's PnP Expansion header.  Properly, we're supposed
35921                                             ;; to init all the ROMs and then go back and build an IPL table of
35922                                             ;; all the bootable devices, but we can get away with one pass.
35923 A029           8ED9                         mov ds, cx ;; ROM base
35924 A02B           8B1E       001A              mov bx, 0x001a ;; 0x1A is the offset into ROM header that contains...
35925 A02F           8B07                         mov ax, [bx] ;; the offset of PnP expansion header, where...
35926 A031           3D                   5024    cmp ax, #0x5024 ;; we look for signature "$PnP"
35927 A034           75           60              jne no_bev
35928 A036           8B47         02              mov ax, 2[bx]
35929 A039           3D                   506E    cmp ax, #0x506e
35930 A03C           75           58              jne no_bev
35931 A03E           8B47         16              mov ax, 0x16[bx] ;; 0x16 is the offset of Boot Connection Vector
35932 A041           3D                   0000    cmp ax, #0x0000
35933 A044           74           17              je no_bcv
35934                                             ;; Option ROM has BCV. Run it now.
35935 A046           51                           push cx ;; Push seg
35936 A047           50                           push ax ;; Push offset
35937                                             ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
35938 A048           BB                   F000    mov bx, #0xf000
35939 A04B           8EC3                         mov es, bx
35940 A04D           8D3E       9F80              lea di, pnpbios_structure
35941 A051           89E5                         mov bp, sp ;; Call ROM BCV routine using seg:off on stack
35942 A053                        FF              db 0xff ;; call_far ss:[bp+0]
35943 A054                        5E              db 0x5e
35944 A055                        00              db 0
35945 A056           FA                           cli ;; In case expansion ROM BIOS turns IF on
35946 A057           83C4                   02    add sp, #2 ;; Pop offset value
35947 A05A           59                           pop cx ;; Pop seg value (restore CX)
35948 A05B           EB           39              jmp no_bev
35949                       0000A05D            no_bcv:
35950 A05D           8B47         1A              mov ax, 0x1a[bx] ;; 0x1A is also the offset into the expansion header of...
35951 A060           3D                   0000    cmp ax, #0x0000 ;; the Bootstrap Entry Vector, or zero if there is 0 .
35952 A063           74           31              je no_bev
35953                                             ;; Found a device that thinks it can boot the system. Record its BEV and product name string.
35954 A065           8B7F         10              mov di, 0x10[bx] ;; Pointer to the product name string or zero if 0
35955 A068           BB                   9FF0    mov bx, #0x9ff0 ;; Go to the segment where the IPL table lives
35956 A06B           8EDB                         mov ds, bx
35957 A06D           8B1E       0080              mov bx, 0x0080 ;; Read the number of entries so far
35958 A071           83FB                   08    cmp bx, #8
35959 A074           74           20              je no_bev ;; Get out if the table is full
35960 A076           C1E3                   04    shl bx, #0x4 ;; Turn count into offset (entries are 16 bytes)
35961 A079           C707                 0080    mov 0[bx], #0x80 ;; This entry is a BEV device
35962 A07D           894F         06              mov 6[bx], cx ;; Build a far pointer from the segment...
35963 A080           8947         04              mov 4[bx], ax ;; and the offset
35964 A083           83FF                   00    cmp di, #0x0000
35965 A086           74           06              je no_prod_str
35966 A088           894F         0A              mov 0xA[bx], cx ;; Build a far pointer from the segment...
35967 A08B           897F         08              mov 8[bx], di ;; and the offset
35968                       0000A08E            no_prod_str:
35969 A08E           C1EB                   04    shr bx, #0x4 ;; Turn the offset back into a count
35970 A091           43                           inc bx ;; We have one more entry now
35971 A092           891E       0080              mov 0x0080, bx ;; Remember that.
35972                       0000A096            no_bev:
35973 A096           5F                           pop di ;; Restore DI
35974 A097           58                           pop ax ;; Restore AX
35975                       0000A098            rom_scan_increment:
35976 A098           C1E0                   05    shl ax, #5 ;; convert 512-bytes blocks to 16-byte increments
35977                                                           ;; because the segment selector is shifted left 4 bits.
35978 A09B           01C1                         add cx, ax
35979 A09D           58                           pop ax ;; Restore AX
35980 A09E           39C1                         cmp cx, ax
35981 A0A0   7703    E9         FF44              jbe rom_scan_loop
35982 A0A5           31C0                         xor ax, ax ;; Restore DS back to 0000:
35983 A0A7           8ED8                         mov ds, ax
35984 A0A9           C3                           ret
35985                       0000A0AA            post_init_pic:
35986 A0AA           B0                     11    mov al, #0x11 ; send initialisation commands
35987 A0AC           E6                     20    out 0x0020, al
35988 A0AE           E6                     A0    out 0x00a0, al
35989 A0B0           B0                     08    mov al, #0x08
35990 A0B2           E6                     21    out 0x0021, al
35991 A0B4           B0                     70    mov al, #0x70
35992 A0B6           E6                     A1    out 0x00a1, al
35993 A0B8           B0                     04    mov al, #0x04
35994 A0BA           E6                     21    out 0x0021, al
35995 A0BC           B0                     02    mov al, #0x02
35996 A0BE           E6                     A1    out 0x00a1, al
35997 A0C0           B0                     01    mov al, #0x01
35998 A0C2           E6                     21    out 0x0021, al
35999 A0C4           E6                     A1    out 0x00a1, al
36000 A0C6           B0                     B8    mov al, #0xb8
36001 A0C8           E6                     21    out 0x0021, AL ;master pic: unmask IRQ 0, 1, 2, 6
36002 A0CA           B0                     8F    mov al, #0x8f
36003 A0CC           E6                     A1    out 0x00a1, AL ;slave pic: unmask IRQ 12, 13, 14
36004 A0CE           C3                           ret
36005                       0000A0CF            post_init_ivt:
36006                                             ;; set first 120 interrupts to default handler
36007 A0CF           31FF                         xor di, di ;; offset index
36008 A0D1           B9                   0078    mov cx, #0x0078 ;; counter (120 interrupts)
36009 A0D4           B8                   F000    mov ax, #0xF000
36010 A0D7     66    C1E0                   10    shl eax, #16
36011 A0DB           B8                   FF53    mov ax, #dummy_iret_handler
36012 A0DE           FC                           cld
36013 A0DF           F3                           rep
36014 A0E0     66    AB                             stosd
36015                                             ;; Master PIC vector
36016 A0E2           BB                   0020    mov bx, #0x0020
36017 A0E5           B1                     08    mov cl, #0x08
36018 A0E7           B8                   E9E6    mov ax, #dummy_master_pic_irq_handler
36019                       0000A0EA            post_default_master_pic_ints:
36020 A0EA           8907                         mov [bx], ax
36021 A0EC           83C3                   04    add bx, #4
36022 A0EF           E2           F9              loop post_default_master_pic_ints
36023                                             ;; Slave PIC vector
36024 A0F1           81C3                 0180    add bx, #0x0180
36025 A0F5           B1                     08    mov cl, #0x08
36026 A0F7           B8                   E9EC    mov ax, #dummy_slave_pic_irq_handler
36027                       0000A0FA            post_default_slave_pic_ints:
36028 A0FA           8907                         mov [bx], ax
36029 A0FC           83C3                   04    add bx, #4
36030 A0FF           E2           F9              loop post_default_slave_pic_ints
36031                                             ;; Printer Services vector
36032                                             SET_INT_VECTOR(0x17, #0xF000, #int17_handler)
 +a   A101           B8                   EFD2    mov ax,  #int17_handler
 +a   A104           A3         005C              mov 0x17*4, ax
 +a   A107           B8                   F000    mov ax,  #0xF000
 +a   A10A           A3         005E              mov 0x17*4+2, ax
36033                                             ;; Bootstrap failure vector
36034                                             SET_INT_VECTOR(0x18, #0xF000, #int18_handler)
 +a   A10D           B8                   9270    mov ax,  #int18_handler
 +a   A110           A3         0060              mov 0x18*4, ax
 +a   A113           B8                   F000    mov ax,  #0xF000
 +a   A116           A3         0062              mov 0x18*4+2, ax
36035                                             ;; Bootstrap Loader vector
36036                                             SET_INT_VECTOR(0x19, #0xF000, #int19_handler)
 +a   A119           B8                   E6F2    mov ax,  #int19_handler
 +a   A11C           A3         0064              mov 0x19*4, ax
 +a   A11F           B8                   F000    mov ax,  #0xF000
 +a   A122           A3         0066              mov 0x19*4+2, ax
36037                                             ;; Memory Size Check vector
36038                                             SET_INT_VECTOR(0x12, #0xF000, #int12_handler)
 +a   A125           B8                   F841    mov ax,  #int12_handler
 +a   A128           A3         0048              mov 0x12*4, ax
 +a   A12B           B8                   F000    mov ax,  #0xF000
 +a   A12E           A3         004A              mov 0x12*4+2, ax
36039                                             ;; Equipment Configuration Check vector
36040                                             SET_INT_VECTOR(0x11, #0xF000, #int11_handler)
 +a   A131           B8                   F84D    mov ax,  #int11_handler
 +a   A134           A3         0044              mov 0x11*4, ax
 +a   A137           B8                   F000    mov ax,  #0xF000
 +a   A13A           A3         0046              mov 0x11*4+2, ax
36041                                             ;; System Services
36042                                             SET_INT_VECTOR(0x15, #0xF000, #int15_handler)
 +a   A13D           B8                   F859    mov ax,  #int15_handler
 +a   A140           A3         0054              mov 0x15*4, ax
 +a   A143           B8                   F000    mov ax,  #0xF000
 +a   A146           A3         0056              mov 0x15*4+2, ax
36043                                             ;; MDA/CGA Video Parameter Table is not available
36044                                             SET_INT_VECTOR(0x1D, #0, #0)
 +a   A149           B8                   0000    mov ax,  #0
 +a   A14C           A3         0074              mov 0x1D*4, ax
 +a   A14F           B8                   0000    mov ax,  #0
 +a   A152           A3         0076              mov 0x1D*4+2, ax
36045                                             ;; Character Font for upper 128 characters is not available
36046                                             SET_INT_VECTOR(0x1F, #0, #0)
 +a   A155           B8                   0000    mov ax,  #0
 +a   A158           A3         007C              mov 0x1F*4, ax
 +a   A15B           B8                   0000    mov ax,  #0
 +a   A15E           A3         007E              mov 0x1F*4+2, ax
36047                                             ;; set vectors 0x60 - 0x67h to zero (0:180..0:19f)
36048 A161           31C0                         xor ax, ax
36049 A163           B9                   0010    mov cx, #0x0010 ;; 16 words
36050 A166           BF                   0180    mov di, #0x0180
36051 A169           FC                           cld
36052 A16A           F3                           rep
36053 A16B           AB                             stosw
36054                                             ;; set vector 0x78 and above to zero
36055 A16C     66    31C0                         xor eax, eax
36056 A16F           B1                     88    mov cl, #0x88 ;; 136 dwords
36057 A171           BF                   01E0    mov di, #0x1e0
36058 A174           F3                           rep
36059 A175     66    AB                             stosd
36060 A177           C3                           ret
36061                                           ;; the following area can be used to write dynamically generated tables
36062 A178                  00000010              .align 16
36063                       0000A180            bios_table_area_start:
36064 A180                  AAFB4442              dd 0xaafb4442
36065 A184                  00002A78              dd bios_table_area_end - bios_table_area_start - 8;
36066                                           ;--------
36067                                           ;- POST -
36068                                           ;--------
36069 E05B                                      .org 0xe05b ; POST Entry Point
36070                       0000E05B            post:
36071 E05B           31C0                         xor ax, ax
36072                                             ;; first reset the DMA controllers
36073 E05D           E6                     0D    out 0x000d,al
36074 E05F           E6                     DA    out 0x00da,al
36075                                             ;; then initialize the DMA controllers
36076 E061           B0                     C0    mov al, #0xC0
36077 E063           E6                     D6    out 0x00d6, al ; cascade mode of channel 4 enabled
36078 E065           B0                     00    mov al, #0x00
36079 E067           E6                     D4    out 0x00d4, al ; unmask channel 4
36080                                             ;; Examine CMOS shutdown status.
36081 E069           B0                     0F    mov AL, #0x0f
36082 E06B           E6                     70    out 0x0070, AL
36083 E06D           E4                     71    in AL, 0x0071
36084                                             ;; backup status
36085 E06F           88C3                         mov bl, al
36086                                             ;; Reset CMOS shutdown status.
36087 E071           B0                     0F    mov AL, #0x0f
36088 E073           E6                     70    out 0x0070, AL ; select CMOS register Fh
36089 E075           B0                     00    mov AL, #0x00
36090 E077           E6                     71    out 0x0071, AL ; set shutdown action to normal
36091                                             ;; Examine CMOS shutdown status.
36092 E079           88D8                         mov al, bl
36093                                             ;; 0x00, 0x0D+ = normal startup
36094 E07B           3C                     00    cmp AL, #0x00
36095 E07D           74           24              jz normal_post
36096 E07F           3C                     0D    cmp AL, #0x0d
36097 E081           73           20              jae normal_post
36098                                             ;; 0x05 = eoi + jmp via [0x40:0x67] jump
36099 E083           3C                     05    cmp al, #0x05
36100 E085   7503    E9         B4DA              je eoi_jmp_post
36101                                             ;; 0x0A = jmp via [0x40:0x67] jump
36102 E08A           3C                     0A    cmp al, #0x0a
36103 E08C   7503    E9         B4FF              je jmp_post_0x467
36104                                             ;; 0x0B = iret via [0x40:0x67]
36105 E091           3C                     0B    cmp al, #0x0b
36106 E093   7503    E9         B500              je iret_post_0x467
36107                                             ;; 0x0C = retf via [0x40:0x67]
36108 E098           3C                     0C    cmp al, #0x0c
36109 E09A   7503    E9         B506              je retf_post_0x467
36110                                             ;; Examine CMOS shutdown status.
36111                                             ;; 0x01,0x02,0x03,0x04,0x06,0x07,0x08,0x09 = Unimplemented shutdown status.
36112 E09F           53                           push bx
36113 E0A0           E8         3119              call _shutdown_status_panic
36114                       0000E0A3            normal_post:
36115                                             ; case 0: normal startup
36116 E0A3           FA                           cli
36117 E0A4           B8                   FFFE    mov ax, #0xfffe
36118 E0A7           89C4                         mov sp, ax
36119 E0A9           31C0                         xor ax, ax
36120 E0AB           8ED8                         mov ds, ax
36121 E0AD           8ED0                         mov ss, ax
36122                                             ;; Save shutdown status
36123 E0AF           881E       04B0              mov 0x04b0, bl
36124 E0B3           80FB                   FE    cmp bl, #0xfe
36125 E0B6   7503    E9         B4F7              jz s3_post
36126                                             ;; zero out BIOS data area (40:00..40:ff)
36127 E0BB           8EC0                         mov es, ax
36128 E0BD           B9                   0080    mov cx, #0x0080 ;; 128 words
36129 E0C0           BF                   0400    mov di, #0x0400
36130 E0C3           FC                           cld
36131 E0C4           F3                           rep
36132 E0C5           AB                             stosw
36133 E0C6           E8         3657              call _log_bios_start
36134 E0C9           E8         C003              call post_init_ivt
36135                                             ;; base memory in K 40:13 (word)
36136 E0CC           B8                   027F    mov ax, #(640 - 1)
36137 E0CF           A3         0413              mov 0x0413, ax
36138                                             ;; Manufacturing Test 40:12
36139                                             ;; zerod out above
36140                                             ;; Warm Boot Flag 0040:0072
36141                                             ;; value of 1234h = skip memory checks
36142                                             ;; zerod out above
36143                                             ;; EBDA setup
36144 E0D2           E8         B47A              call ebda_post
36145                                             ;; PIT setup
36146                                             SET_INT_VECTOR(0x08, #0xF000, #int08_handler)
 +a   E0D5           B8                   FEA5    mov ax,  #int08_handler
 +a   E0D8           A3         0020              mov 0x08*4, ax
 +a   E0DB           B8                   F000    mov ax,  #0xF000
 +a   E0DE           A3         0022              mov 0x08*4+2, ax
36147                                             ;; int 1C already points at dummy_iret_handler (above)
36148 E0E1           B0                     34    mov al, #0x34 ; timer0: binary count, 16bit count, mode 2
36149 E0E3           E6                     43    out 0x0043, al
36150 E0E5           B0                     00    mov al, #0x00 ; maximum count of 0000H = 18.2Hz
36151 E0E7           E6                     40    out 0x0040, al
36152 E0E9           E6                     40    out 0x0040, al
36153                                             ;; Keyboard
36154                                             SET_INT_VECTOR(0x09, #0xF000, #int09_handler)
 +a   E0EB           B8                   E987    mov ax,  #int09_handler
 +a   E0EE           A3         0024              mov 0x09*4, ax
 +a   E0F1           B8                   F000    mov ax,  #0xF000
 +a   E0F4           A3         0026              mov 0x09*4+2, ax
36155                                             SET_INT_VECTOR(0x16, #0xF000, #int16_handler)
 +a   E0F7           B8                   E82E    mov ax,  #int16_handler
 +a   E0FA           A3         0058              mov 0x16*4, ax
 +a   E0FD           B8                   F000    mov ax,  #0xF000
 +a   E100           A3         005A              mov 0x16*4+2, ax
36156 E103           31C0                         xor ax, ax
36157 E105           8ED8                         mov ds, ax
36158 E107           A2         0417              mov 0x0417, al
36159 E10A           A2         0418              mov 0x0418, al
36160 E10D           A2         0419              mov 0x0419, al
36161 E110           A2         0471              mov 0x0471, al
36162 E113           A2         0497              mov 0x0497, al
36163 E116           B0                     10    mov al, #0x10
36164 E118           A2         0496              mov 0x0496, al
36165 E11B           BB                   001E    mov bx, #0x001E
36166 E11E           891E       041A              mov 0x041A, bx
36167 E122           891E       041C              mov 0x041C, bx
36168 E126           BB                   001E    mov bx, #0x001E
36169 E129           891E       0480              mov 0x0480, bx
36170 E12D           BB                   003E    mov bx, #0x003E
36171 E130           891E       0482              mov 0x0482, bx
36172 E134           E8         2B2C              call _keyboard_init
36173                                             ;; mov CMOS Equipment Byte to BDA Equipment Word
36174 E137           A1         0410              mov ax, 0x0410
36175 E13A           B0                     14    mov al, #0x14
36176 E13C           E6                     70    out 0x0070, al
36177 E13E           E4                     71    in al, 0x0071
36178 E140           A3         0410              mov 0x0410, ax
36179                                             ;; Parallel setup
36180 E143           31C0                         xor ax, ax
36181 E145           8ED8                         mov ds, ax
36182 E147           31DB                         xor bx, bx
36183 E149           B1                     14    mov cl, #0x14 ; timeout value
36184 E14B           BA                   0378    mov dx, #0x378 ; Parallel I/O address, port 1
36185 E14E           E8         BDB2              call detect_parport
36186 E151           BA                   0278    mov dx, #0x278 ; Parallel I/O address, port 2
36187 E154           E8         BDAC              call detect_parport
36188 E157           C1E3                   0E    shl bx, #0x0e
36189 E15A           A1         0410              mov ax, 0x410 ; Equipment word bits 14..15 determine # parallel ports
36190 E15D           25                   3FFF    and ax, #0x3fff
36191 E160           09D8                         or ax, bx ; set number of parallel ports
36192 E162           A3         0410              mov 0x410, ax
36193                                             ;; Serial setup
36194                                             SET_INT_VECTOR(0x14, #0xF000, #int14_handler)
 +a   E165           B8                   E739    mov ax,  #int14_handler
 +a   E168           A3         0050              mov 0x14*4, ax
 +a   E16B           B8                   F000    mov ax,  #0xF000
 +a   E16E           A3         0052              mov 0x14*4+2, ax
36195 E171           31DB                         xor bx, bx
36196 E173           B1                     0A    mov cl, #0x0a ; timeout value
36197 E175           BA                   03F8    mov dx, #0x03f8 ; Serial I/O address, port 1
36198 E178           E8         BDA7              call detect_serial
36199 E17B           BA                   02F8    mov dx, #0x02f8 ; Serial I/O address, port 2
36200 E17E           E8         BDA1              call detect_serial
36201 E181           BA                   03E8    mov dx, #0x03e8 ; Serial I/O address, port 3
36202 E184           E8         BD9B              call detect_serial
36203 E187           BA                   02E8    mov dx, #0x02e8 ; Serial I/O address, port 4
36204 E18A           E8         BD95              call detect_serial
36205 E18D           C1E3                   09    shl bx, #0x09
36206 E190           A1         0410              mov ax, 0x410 ; Equipment word bits 9..11 determine # serial ports
36207 E193           25                   F1FF    and ax, #0xf1ff
36208 E196           09D8                         or ax, bx ; set number of serial port
36209 E198           A3         0410              mov 0x410, ax
36210                                             ;; CMOS RTC
36211                                             SET_INT_VECTOR(0x1A, #0xF000, #int1a_handler)
 +a   E19B           B8                   FE6E    mov ax,  #int1a_handler
 +a   E19E           A3         0068              mov 0x1A*4, ax
 +a   E1A1           B8                   F000    mov ax,  #0xF000
 +a   E1A4           A3         006A              mov 0x1A*4+2, ax
36212                                             SET_INT_VECTOR(0x4A, #0xF000, #dummy_iret_handler)
 +a   E1A7           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E1AA           A3         0128              mov 0x4A*4, ax
 +a   E1AD           B8                   F000    mov ax,  #0xF000
 +a   E1B0           A3         012A              mov 0x4A*4+2, ax
36213                                             SET_INT_VECTOR(0x70, #0xF000, #int70_handler)
 +a   E1B3           B8                   FE93    mov ax,  #int70_handler
 +a   E1B6           A3         01C0              mov 0x70*4, ax
 +a   E1B9           B8                   F000    mov ax,  #0xF000
 +a   E1BC           A3         01C2              mov 0x70*4+2, ax
36214                                             ;; BIOS DATA AREA 0x4CE ???
36215 E1BF           E8         B41A              call timer_tick_post
36216                                             ;; IRQ9 (IRQ2 redirect) setup
36217                                             SET_INT_VECTOR(0x71, #0xF000, #int71_handler)
 +a   E1C2           B8                   E9DD    mov ax,  #int71_handler
 +a   E1C5           A3         01C4              mov 0x71*4, ax
 +a   E1C8           B8                   F000    mov ax,  #0xF000
 +a   E1CB           A3         01C6              mov 0x71*4+2, ax
36218                                             ;; PS/2 mouse setup
36219                                             SET_INT_VECTOR(0x74, #0xF000, #int74_handler)
 +a   E1CE           B8                   919E    mov ax,  #int74_handler
 +a   E1D1           A3         01D0              mov 0x74*4, ax
 +a   E1D4           B8                   F000    mov ax,  #0xF000
 +a   E1D7           A3         01D2              mov 0x74*4+2, ax
36220                                             ;; IRQ13 (FPU exception) setup
36221                                             SET_INT_VECTOR(0x75, #0xF000, #int75_handler)
 +a   E1DA           B8                   E2C7    mov ax,  #int75_handler
 +a   E1DD           A3         01D4              mov 0x75*4, ax
 +a   E1E0           B8                   F000    mov ax,  #0xF000
 +a   E1E3           A3         01D6              mov 0x75*4+2, ax
36222                                             ;; Video setup
36223                                             SET_INT_VECTOR(0x10, #0xF000, #int10_handler)
 +a   E1E6           B8                   F065    mov ax,  #int10_handler
 +a   E1E9           A3         0040              mov 0x10*4, ax
 +a   E1EC           B8                   F000    mov ax,  #0xF000
 +a   E1EF           A3         0042              mov 0x10*4+2, ax
36224                                             ;; PIC
36225 E1F2           E8         BEB5              call post_init_pic
36226 E1F5           E8         BB67              call pcibios_init_iomem_bases
36227 E1F8           E8         BC3B              call pcibios_init_irqs
36228 E1FB           B9                   C000    mov cx, #0xc000 ;; init vga bios
36229 E1FE           B8                   C780    mov ax, #0xc780
36230 E201           E8         BDE5              call rom_scan
36231                                             ;; Hack fix: SeaVGABIOS does not setup a video mode
36232 E204           BA                   03D4    mov dx, #0x03d4
36233 E207           B0                     00    mov al, #0x00
36234 E209           EE                           out dx, al
36235 E20A           42                           inc dx
36236 E20B           EC                           in al, dx
36237 E20C           84C0                         test al, al
36238 E20E           75           05              jnz vga_init_ok
36239 E210           B8                   0003    mov ax, #0x0003
36240 E213           CD                     10    int #0x10
36241                       0000E215            vga_init_ok:
36242 E215           E8         2FCE              call _print_bios_banner
36243                                             ;;
36244                                             ;; Floppy setup
36245                                             ;;
36246 E218           E8         B08D              call floppy_drive_post
36247                                             ;;
36248                                             ;; Hard Drive setup
36249                                             ;;
36250 E21B           E8         B111              call hard_drive_post
36251                                             ;;
36252                                             ;; ATA/ATAPI driver setup
36253                                             ;;
36254 E21E           E8         362C              call _ata_init
36255 E221           E8         396B              call _ata_detect
36256                                             ;;
36257                                             ;;
36258                                             ;; eltorito floppy/harddisk emulation from cd
36259                                             ;;
36260 E224           E8         531C              call _cdemu_init
36261                                             ;;
36262 E227           E8         3015              call _init_boot_vectors
36263 E22A           B9                   C800    mov cx, #0xc800 ;; init option roms
36264 E22D           B8                   E000    mov ax, #0xe000
36265 E230           E8         BDB6              call rom_scan
36266 E233           E8         3185              call _interactive_bootkey
36267 E236           FB                           sti ;; enable interrupts
36268 E237           CD                     19    int #0x19
36269 E2C3                                      .org 0xe2c3 ; NMI Handler Entry Point
36270                       0000E2C3            nmi:
36271                                             ;; FIXME the NMI handler should not panic
36272                                             ;; but iret when called from int75 (fpu exception)
36273 E2C3           E8         3436              call _nmi_handler_msg
36274 E2C6           CF                           iret
36275                       0000E2C7            int75_handler:
36276 E2C7           E6                     F0    out 0xf0, al
36277 E2C9           E8         B2F8              call eoi_both_pics
36278 E2CC           CD                     02    int 2
36279 E2CE           CF                           iret
36280                                           ;-------------------------------------------
36281                                           ;- INT 13h Fixed Disk Services Entry Point -
36282                                           ;-------------------------------------------
36283 E3FE                                      .org 0xe3fe ; INT 13h Fixed Disk Services Entry Point
36284                       0000E3FE            int13_handler:
36285 E3FE           E9         ADDA              jmp int13_relocated
36286 E401                                      .org 0xe401 ; Fixed Disk Parameter Table
36287                                           ;----------
36288                                           ;- INT19h -
36289                                           ;----------
36290 E6F2                                      .org 0xe6f2 ; INT 19h Boot Load Service Entry Point
36291                       0000E6F2            int19_handler:
36292 E6F2           E9         AB97              jmp int19_relocated
36293                                           ;-------------------------------------------
36294                                           ;- System BIOS Configuration Data Table
36295                                           ;-------------------------------------------
36296 E6F5                                      .org 0xe6f5
36297 E6F5                        08            db 0x08 ; Table size (bytes) -Lo
36298 E6F6                        00            db 0x00 ; Table size (bytes) -Hi
36299 E6F7                        FC            db 0xFC
36300 E6F8                        00            db 0x00
36301 E6F9                        01            db 1
36302                                           ; Feature byte 1
36303                                           ; b7: 1=DMA channel 3 used by hard disk
36304                                           ; b6: 1=2 interrupt controllers present
36305                                           ; b5: 1=RTC present
36306                                           ; b4: 1=BIOS calls int 15h/4Fh every key
36307                                           ; b3: 1=wait for extern event supported (Int 15h/41h)
36308                                           ; b2: 1=extended BIOS data area used
36309                                           ; b1: 0=AT or ESDI bus, 1=MicroChannel
36310                                           ; b0: 1=Dual bus (MicroChannel + ISA)
36311 E6FA                        74            db (0 << 7) | (1 << 6) | (1 << 5) | (1 << 4) | (0 << 3) | (1 << 2) | (0 << 1) | (0 << 0)
36312                                           ; Feature byte 2
36313                                           ; b7: 1=32-bit DMA supported
36314                                           ; b6: 1=int16h, function 9 supported
36315                                           ; b5: 1=int15h/C6h (get POS data) supported
36316                                           ; b4: 1=int15h/C7h (get mem map info) supported
36317                                           ; b3: 1=int15h/C8h (en/dis CPU) supported
36318                                           ; b2: 1=non-8042 kb controller
36319                                           ; b1: 1=data streaming supported
36320                                           ; b0: reserved
36321 E6FB                        40            db (0 << 7) | (1 << 6) | (0 << 5) | (0 << 4) | (0 << 3) | (0 << 2) | (0 << 1) | (0 << 0)
36322                                           ; Feature byte 3
36323                                           ; b7: not used
36324                                           ; b6: reserved
36325                                           ; b5: reserved
36326                                           ; b4: POST supports ROM-to-RAM enable/disable
36327                                           ; b3: SCSI on system board
36328                                           ; b2: info panel installed
36329                                           ; b1: Initial Machine Load (IML) system - BIOS on disk
36330                                           ; b0: SCSI supported in IML
36331 E6FC                        00            db 0x00
36332                                           ; Feature byte 4
36333                                           ; b7: IBM private
36334                                           ; b6: EEPROM present
36335                                           ; b5-3: ABIOS presence (011 = not supported)
36336                                           ; b2: private
36337                                           ; b1: memory split above 16Mb supported
36338                                           ; b0: POSTEXT directly supported by POST
36339 E6FD                        00            db 0x00
36340                                           ; Feature byte 5 (IBM)
36341                                           ; b1: enhanced mouse
36342                                           ; b0: flash EPROM
36343 E6FE                        00            db 0x00
36344 E729                                      .org 0xe729 ; Baud Rate Generator Table
36345                                           ;----------
36346                                           ;- INT14h -
36347                                           ;----------
36348 E739                                      .org 0xe739 ; INT 14h Serial Communications Service Entry Point
36349                       0000E739            int14_handler:
36350 E739           1E                           push ds
36351 E73A           60                           pusha
36352 E73B           31C0                         xor ax, ax
36353 E73D           8ED8                         mov ds, ax
36354 E73F           E8         5355              call _int14_function
36355 E742           61                           popa
36356 E743           1F                           pop ds
36357 E744           CF                           iret
36358                                           ;----------------------------------------
36359                                           ;- INT 16h Keyboard Service Entry Point -
36360                                           ;----------------------------------------
36361 E82E                                      .org 0xe82e
36362                       0000E82E            int16_handler:
36363 E82E           FB                           sti
36364 E82F           1E                           push ds
36365 E830           9C                           pushf
36366 E831           60                           pusha
36367 E832           6A                     40    push #0x40
36368 E834           1F                           pop ds
36369 E835           80FC                   00    cmp ah, #0x00
36370 E838           74           1F              je int16_F00
36371 E83A           80FC                   10    cmp ah, #0x10
36372 E83D           74           1A              je int16_F00
36373 E83F           E8         6543              call _int16_function
36374 E842           61                           popa
36375 E843           9D                           popf
36376 E844           1F                           pop ds
36377 E845           74           09              jz int16_zero_set
36378                       0000E847            int16_zero_clear:
36379 E847           55                           push bp
36380 E848           89E5                         mov bp, sp
36381 E84A           8066         06        BF    and BYTE [bp + 0x06], #0xbf
36382 E84E           5D                           pop bp
36383 E84F           CF                           iret
36384                       0000E850            int16_zero_set:
36385 E850           55                           push bp
36386 E851           89E5                         mov bp, sp
36387 E853           804E         06        40    or BYTE [bp + 0x06], #0x40
36388 E857           5D                           pop bp
36389 E858           CF                           iret
36390                       0000E859            int16_F00:
36391 E859           FA                           cli
36392 E85A           A1         001A              mov ax, 0x001a
36393 E85D           3B06       001C              cmp ax, 0x001c
36394 E861           75           13              jne int16_key_found
36395 E863           FB                           sti
36396                                             ;; no key yet, call int 15h, function AX=9002
36397 E864           B8                   9002    mov ax, #0x9002
36398 E867           CD                     15    int #0x15
36399                       0000E869            int16_wait_for_key:
36400 E869           FA                           cli
36401 E86A           A1         001A              mov ax, 0x001a
36402 E86D           3B06       001C              cmp ax, 0x001c
36403 E871           75           03              jne int16_key_found
36404 E873           FB                           sti
36405 E874           EB           F3              jmp int16_wait_for_key
36406                       0000E876            int16_key_found:
36407 E876           E8         650C              call _int16_function
36408 E879           61                           popa
36409 E87A           9D                           popf
36410 E87B           1F                           pop ds
36411 E87C           CF                           iret
36412                                           ;-------------------------------------------------
36413                                           ;- INT09h : Keyboard Hardware Service Entry Point -
36414                                           ;-------------------------------------------------
36415 E987                                      .org 0xe987
36416                       0000E987            int09_handler:
36417 E987           FA                           cli
36418 E988           50                           push ax
36419 E989           B0                     AD    mov al, #0xAD ;;disable keyboard
36420 E98B           E6                     64    out 0x0064, al
36421 E98D           B0                     0B    mov al, #0x0B
36422 E98F           E6                     20    out 0x0020, al
36423 E991           E4                     20    in al, 0x0020
36424 E993           24                     02    and al, #0x02
36425 E995           74           40              jz int09_finish
36426 E997           E4                     60    in al, 0x0060 ;;read key from keyboard controller
36427 E999           FB                           sti
36428 E99A           1E                           push ds
36429 E99B           60                           pusha
36430 E99C           B4                     4F    mov ah, #0x4f ;; allow for keyboard intercept
36431 E99E           F9                           stc
36432 E99F           CD                     15    int #0x15
36433 E9A1           55                           push bp
36434 E9A2           89E5                         mov bp, sp
36435 E9A4           8846         10              mov [bp + 0x10], al
36436 E9A7           5D                           pop bp
36437 E9A8           73           22              jnc int09_done
36438                                             ;; check for extended key
36439 E9AA           6A                     40    push #0x40
36440 E9AC           1F                           pop ds
36441 E9AD           3C                     E0    cmp al, #0xe0
36442 E9AF           75           0A              jne int09_check_pause
36443 E9B1           A0         0096              mov al, BYTE [0x96] ;; mf2_state |= 0x02
36444 E9B4           0C                     02    or al, #0x02
36445 E9B6           A2         0096              mov BYTE [0x96], al
36446 E9B9           EB           11              jmp int09_done
36447                       0000E9BB            int09_check_pause: ;; check for pause key
36448 E9BB           3C                     E1    cmp al, #0xe1
36449 E9BD           75           0A              jne int09_process_key
36450 E9BF           A0         0096              mov al, BYTE [0x96] ;; mf2_state |= 0x01
36451 E9C2           0C                     01    or al, #0x01
36452 E9C4           A2         0096              mov BYTE [0x96], al
36453 E9C7           EB           03              jmp int09_done
36454                       0000E9C9            int09_process_key:
36455 E9C9           E8         6A36              call _int09_function
36456                       0000E9CC            int09_done:
36457 E9CC           61                           popa
36458 E9CD           1F                           pop ds
36459 E9CE           FA                           cli
36460 E9CF           E8         ABF6              call eoi_master_pic
36461                                             ;; Notify keyboard interrupt complete w/ int 15h, function AX=9102
36462 E9D2           B8                   9102    mov ax, #0x9102
36463 E9D5           CD                     15    int #0x15
36464                       0000E9D7            int09_finish:
36465 E9D7           B0                     AE    mov al, #0xAE ;;enable keyboard
36466 E9D9           E6                     64    out 0x0064, al
36467 E9DB           58                           pop ax
36468 E9DC           CF                           iret
36469                                           ; IRQ9 handler(Redirect to IRQ2)
36470                                           ;--------------------
36471                       0000E9DD            int71_handler:
36472 E9DD           50                           push ax
36473 E9DE           B0                     20    mov al, #0x20
36474 E9E0           E6                     A0    out 0x00a0, al ;; slave PIC EOI
36475 E9E2           58                           pop ax
36476 E9E3           CD                     0A    int #0x0A
36477 E9E5           CF                           iret
36478                                           ;--------------------
36479                       0000E9E6            dummy_master_pic_irq_handler:
36480 E9E6           50                           push ax
36481 E9E7           E8         ABDE              call eoi_master_pic
36482 E9EA           58                           pop ax
36483 E9EB           CF                           iret
36484                                           ;--------------------
36485                       0000E9EC            dummy_slave_pic_irq_handler:
36486 E9EC           50                           push ax
36487 E9ED           E8         ABD4              call eoi_both_pics
36488 E9F0           58                           pop ax
36489 E9F1           CF                           iret
36490                                           ;----------------------------------------
36491                                           ;- INT 13h Diskette Service Entry Point -
36492                                           ;----------------------------------------
36493 EC59                                      .org 0xec59
36494                       0000EC59            int13_diskette:
36495 EC59           E9         A5D2              jmp int13_noeltorito
36496                                           ;---------------------------------------------
36497                                           ;- INT 0Eh Diskette Hardware ISR Entry Point -
36498                                           ;---------------------------------------------
36499 EF57                                      .org 0xef57 ; INT 0Eh Diskette Hardware ISR Entry Point
36500                       0000EF57            int0e_handler:
36501 EF57           50                           push ax
36502 EF58           52                           push dx
36503 EF59           BA                   03F4    mov dx, #0x03f4
36504 EF5C           EC                           in al, dx
36505 EF5D           24                     C0    and al, #0xc0
36506 EF5F           3C                     C0    cmp al, #0xc0
36507 EF61           74           1E              je int0e_normal
36508 EF63           BA                   03F5    mov dx, #0x03f5
36509 EF66           B0                     08    mov al, #0x08 ; sense interrupt status
36510 EF68           EE                           out dx, al
36511                       0000EF69            int0e_loop1:
36512 EF69           BA                   03F4    mov dx, #0x03f4
36513 EF6C           EC                           in al, dx
36514 EF6D           24                     C0    and al, #0xc0
36515 EF6F           3C                     C0    cmp al, #0xc0
36516 EF71           75           F6              jne int0e_loop1
36517                       0000EF73            int0e_loop2:
36518 EF73           BA                   03F5    mov dx, #0x03f5
36519 EF76           EC                           in al, dx
36520 EF77           BA                   03F4    mov dx, #0x03f4
36521 EF7A           EC                           in al, dx
36522 EF7B           24                     C0    and al, #0xc0
36523 EF7D           3C                     C0    cmp al, #0xc0
36524 EF7F           74           F2              je int0e_loop2
36525                       0000EF81            int0e_normal:
36526 EF81           1E                           push ds
36527 EF82           31C0                         xor ax, ax ;; segment 0000
36528 EF84           8ED8                         mov ds, ax
36529 EF86           E8         A63F              call eoi_master_pic
36530 EF89           A0         043E              mov al, 0x043e
36531 EF8C           0C                     80    or al, #0x80 ;; diskette interrupt has occurred
36532 EF8E           A2         043E              mov 0x043e, al
36533 EF91           1F                           pop ds
36534                                             ;; Notify diskette interrupt complete w/ int 15h, function AX=9101
36535 EF92           B8                   9101    mov ax, #0x9101
36536 EF95           CD                     15    int #0x15
36537 EF97           5A                           pop dx
36538 EF98           58                           pop ax
36539 EF99           CF                           iret
36540 EFC7                                      .org 0xefc7 ; Diskette Controller Parameter Table
36541                       0000EFC7            diskette_param_table:
36542                                           ;; Since no provisions are made for multiple drive types, most
36543                                           ;; values in this table are ignored. I set parameters for 1.44M
36544                                           ;; floppy here
36545 EFC7                        AF            db 0xAF
36546 EFC8                        02            db 0x02 ;; head load time 0000001, DMA used
36547 EFC9                        25            db 0x25
36548 EFCA                        02            db 0x02
36549 EFCB                        12            db 18
36550 EFCC                        1B            db 0x1B
36551 EFCD                        FF            db 0xFF
36552 EFCE                        6C            db 0x6C
36553 EFCF                        F6            db 0xF6
36554 EFD0                        0F            db 0x0F
36555 EFD1                        08            db 0x08
36556                                           ;----------------------------------------
36557                                           ;- INT17h : Printer Service Entry Point -
36558                                           ;----------------------------------------
36559 EFD2                                      .org 0xefd2
36560                       0000EFD2            int17_handler:
36561 EFD2           1E                           push ds
36562 EFD3           60                           pusha
36563 EFD4           31C0                         xor ax, ax
36564 EFD6           8ED8                         mov ds, ax
36565 EFD8           E8         969E              call _int17_function
36566 EFDB           61                           popa
36567 EFDC           1F                           pop ds
36568 EFDD           CF                           iret
36569                       0000EFDE            diskette_param_table2:
36570                                           ;; New diskette parameter table adding 3 parameters from IBM
36571                                           ;; Since no provisions are made for multiple drive types, most
36572                                           ;; values in this table are ignored. I set parameters for 1.44M
36573                                           ;; floppy here
36574 EFDE                        AF            db 0xAF
36575 EFDF                        02            db 0x02 ;; head load time 0000001, DMA used
36576 EFE0                        25            db 0x25
36577 EFE1                        02            db 0x02
36578 EFE2                        12            db 18
36579 EFE3                        1B            db 0x1B
36580 EFE4                        FF            db 0xFF
36581 EFE5                        6C            db 0x6C
36582 EFE6                        F6            db 0xF6
36583 EFE7                        0F            db 0x0F
36584 EFE8                        08            db 0x08
36585 EFE9                        4F            db 79 ;; maximum track
36586 EFEA                        00            db 0 ;; data transfer rate
36587 EFEB                        04            db 4 ;; drive type in cmos
36588 F045                                      .org 0xf045 ; INT 10 Functions 0-Fh Entry Point
36589                                             HALT(11645)
 +a   F045           BA                   0400    mov dx,#0x400
 +a   F048           B8                   2D7D    mov ax,#11645
 +a   F04B           EF                           out dx,ax
36590 F04C           CF                           iret
36591                                           ;----------
36592                                           ;- INT10h -
36593                                           ;----------
36594 F065                                      .org 0xf065 ; INT 10h Video Support Service Entry Point
36595                       0000F065            int10_handler:
36596                                             ;; dont do anything, since the VGA BIOS handles int10h requests
36597 F065           CF                           iret
36598 F0A4                                      .org 0xf0a4 ; MDA/CGA Video Parameter Table (INT 1Dh)
36599                                           ;----------
36600                                           ;- INT12h -
36601                                           ;----------
36602 F841                                      .org 0xf841 ; INT 12h Memory Size Service Entry Point
36603                                           ; ??? different for Pentium (machine check)?
36604                       0000F841            int12_handler:
36605 F841           1E                           push ds
36606 F842           B8                   0040    mov ax, #0x0040
36607 F845           8ED8                         mov ds, ax
36608 F847           A1         0013              mov ax, 0x0013
36609 F84A           1F                           pop ds
36610 F84B           CF                           iret
36611                                           ;----------
36612                                           ;- INT11h -
36613                                           ;----------
36614 F84D                                      .org 0xf84d ; INT 11h Equipment List Service Entry Point
36615                       0000F84D            int11_handler:
36616 F84D           1E                           push ds
36617 F84E           B8                   0040    mov ax, #0x0040
36618 F851           8ED8                         mov ds, ax
36619 F853           A1         0010              mov ax, 0x0010
36620 F856           1F                           pop ds
36621 F857           CF                           iret
36622                                           ;----------
36623                                           ;- INT15h -
36624                                           ;----------
36625 F859                                      .org 0xf859 ; INT 15h System Services Entry Point
36626                       0000F859            int15_handler:
36627 F859           80FC                   80    cmp ah, #0x80 ; Device open
36628 F85C           74           39              je int15_stub
36629 F85E           80FC                   81    cmp ah, #0x81 ; Device close
36630 F861           74           34              je int15_stub
36631 F863           80FC                   82    cmp ah, #0x82 ; Program termination
36632 F866           74           2F              je int15_stub
36633 F868           80FC                   90    cmp ah, #0x90 ; Device busy interrupt. Called by Int 16h when no key available
36634 F86B           74           2A              je int15_stub
36635 F86D           80FC                   91    cmp ah, #0x91 ; Interrupt complete. Called by IRQ handlers
36636 F870           74           25              je int15_stub
36637 F872           9C                           pushf
36638 F873           80FC                   53    cmp ah, #0x53
36639 F876           74           1C              je apm_call
36640 F878           1E                           push ds
36641 F879           06                           push es
36642 F87A           80FC                   86    cmp ah, #0x86
36643 F87D           74           23              je int15_handler32
36644 F87F           80FC                   E8    cmp ah, #0xE8
36645 F882           74           1E              je int15_handler32
36646 F884           60                           pusha
36647 F885           80FC                   C2    cmp ah, #0xC2
36648 F888           74           13              je int15_handler_mouse
36649 F88A           E8         4437              call _int15_function
36650                       0000F88D            int15_handler_mouse_ret:
36651 F88D           61                           popa
36652                       0000F88E            int15_handler32_ret:
36653 F88E           07                           pop es
36654 F88F           1F                           pop ds
36655 F890           9D                           popf
36656 F891           E9         9933              jmp iret_modify_cf
36657                       0000F894            apm_call:
36658 F894           E9         9F8E              jmp _apmreal_entry
36659                       0000F897            int15_stub:
36660 F897           30E4                         xor ah, ah ; "operation success"
36661 F899           F8                           clc
36662 F89A           E9         992A              jmp iret_modify_cf
36663                       0000F89D            int15_handler_mouse:
36664 F89D           E8         490E              call _int15_function_mouse
36665 F8A0           EB           EB              jmp int15_handler_mouse_ret
36666                       0000F8A2            int15_handler32:
36667 F8A2     66    60                           pushad
36668 F8A4           E8         5029              call _int15_function32
36669 F8A7     66    61                           popad
36670 F8A9           EB           E3              jmp int15_handler32_ret
36671                                           ;; Protected mode IDT descriptor
36672                                           ;;
36673                                           ;; I just make the limit 0, so the machine will shutdown
36674                                           ;; if an exception occurs during protected mode memory
36675                                           ;; transfers.
36676                                           ;;
36677                                           ;; Set base to f0000 to correspond to beginning of BIOS,
36678                                           ;; in case I actually define an IDT later
36679                                           ;; Set limit to 0
36680                       0000F8AB            pmode_IDT_info:
36681 F8AB                      0000            dw 0x0000 ;; limit 15:00
36682 F8AD                      0000            dw 0x0000 ;; base 15:00
36683 F8AF                        0F            db 0x0f ;; base 23:16
36684 F8B0                        00            db 0x00 ;; base 31:24
36685                                           ;; Real mode IDT descriptor
36686                                           ;;
36687                                           ;; Set to typical real-mode values.
36688                                           ;; base = 000000
36689                                           ;; limit = 03ff
36690                       0000F8B1            rmode_IDT_info:
36691 F8B1                      03FF            dw 0x03ff ;; limit 15:00
36692 F8B3                      0000            dw 0x0000 ;; base 15:00
36693 F8B5                        00            db 0x00 ;; base 23:16
36694 F8B6                        00            db 0x00 ;; base 31:24
36695                                           ;----------
36696                                           ;- INT1Ah -
36697                                           ;----------
36698 FE6E                                      .org 0xfe6e ; INT 1Ah Time-of-day Service Entry Point
36699                       0000FE6E            int1a_handler:
36700 FE6E           80FC                   B1    cmp ah, #0xb1
36701 FE71           75           14              jne int1a_normal
36702 FE73           E8         9C77              call pcibios_real
36703 FE76           72           03              jc pcibios_error
36704 FE78           CA                   0002    retf 2
36705                       0000FE7B            pcibios_error:
36706 FE7B           88E3                         mov bl, ah
36707 FE7D           B4                     B1    mov ah, #0xb1
36708 FE7F           1E                           push ds
36709 FE80           60                           pusha
36710 FE81           8CD0                         mov ax, ss ; set readable descriptor to ds, for calling pcibios
36711 FE83           8ED8                         mov ds, ax ; on 16bit protected mode.
36712 FE85           EB           06              jmp int1a_callfunction
36713                       0000FE87            int1a_normal:
36714 FE87           1E                           push ds
36715 FE88           60                           pusha
36716 FE89           31C0                         xor ax, ax
36717 FE8B           8ED8                         mov ds, ax
36718                       0000FE8D            int1a_callfunction:
36719 FE8D           E8         8B4C              call _int1a_function
36720 FE90           61                           popa
36721 FE91           1F                           pop ds
36722 FE92           CF                           iret
36723                                           ;;
36724                                           ;; int70h: IRQ8 - CMOS RTC
36725                                           ;;
36726                       0000FE93            int70_handler:
36727 FE93           1E                           push ds
36728 FE94     66    60                           pushad
36729 FE96           31C0                         xor ax, ax
36730 FE98           8ED8                         mov ds, ax
36731 FE9A           E8         9216              call _int70_function
36732 FE9D     66    61                           popad
36733 FE9F           1F                           pop ds
36734 FEA0           CF                           iret
36735                                           ;---------
36736                                           ;- INT08 -
36737                                           ;---------
36738 FEA5                                      .org 0xfea5 ; INT 08h System Timer ISR Entry Point
36739                       0000FEA5            int08_handler:
36740 FEA5           FB                           sti
36741 FEA6     66    50                           push eax
36742 FEA8           1E                           push ds
36743 FEA9           31C0                         xor ax, ax
36744 FEAB           8ED8                         mov ds, ax
36745                                             ;; time to turn off drive(s)?
36746 FEAD           A0         0440              mov al,0x0440
36747 FEB0           08C0                         or al,al
36748 FEB2           74           10              jz int08_floppy_off
36749 FEB4           FEC8                         dec al
36750 FEB6           A2         0440              mov 0x0440,al
36751 FEB9           75           09              jnz int08_floppy_off
36752                                             ;; turn motor(s) off
36753 FEBB           52                           push dx
36754 FEBC           BA                   03F2    mov dx,#0x03f2
36755 FEBF           EC                           in al,dx
36756 FEC0           24                     CF    and al,#0xcf
36757 FEC2           EE                           out dx,al
36758 FEC3           5A                           pop dx
36759                       0000FEC4            int08_floppy_off:
36760 FEC4     66    A1         046C              mov eax, 0x046c ;; get ticks dword
36761 FEC8     66    40                           inc eax
36762                                             ;; compare eax to one days worth of timer ticks at 18.2 hz
36763 FECA     66    3D               001800B0    cmp eax, #0x001800B0
36764 FED0           72           07              jb int08_store_ticks
36765                                             ;; there has been a midnight rollover at this point
36766 FED2     66    31C0                         xor eax, eax ;; zero out counter
36767 FED5           FE06       0470              inc BYTE 0x0470 ;; increment rollover flag
36768                       0000FED9            int08_store_ticks:
36769 FED9     66    A3         046C              mov 0x046c, eax ;; store new ticks dword
36770                                             ;; chain to user timer tick INT #0x1c
36771 FEDD           CD                     1C    int #0x1c
36772 FEDF           FA                           cli
36773 FEE0           E8         96E5              call eoi_master_pic
36774 FEE3           1F                           pop ds
36775 FEE4     66    58                           pop eax
36776 FEE6           CF                           iret
36777 FEF3                                      .org 0xfef3 ; Initial Interrupt Vector Offsets Loaded by POST
36778                       0000FEF3            initial_int_vector_offset_08_1f:
36779 FEF3                      FEA5              dw int08_handler
36780 FEF5                      E987              dw int09_handler
36781 FEF7                      E9E6              dw dummy_master_pic_irq_handler
36782 FEF9                      E9E6              dw dummy_master_pic_irq_handler
36783 FEFB                      E9E6              dw dummy_master_pic_irq_handler
36784 FEFD                      E9E6              dw dummy_master_pic_irq_handler
36785 FEFF                      EF57              dw int0e_handler
36786 FF01                      E9E6              dw dummy_master_pic_irq_handler
36787 FF03                      F065              dw int10_handler
36788 FF05                      F84D              dw int11_handler
36789 FF07                      F841              dw int12_handler
36790 FF09                      E3FE              dw int13_handler
36791 FF0B                      E739              dw int14_handler
36792 FF0D                      F859              dw int15_handler
36793 FF0F                      E82E              dw int16_handler
36794 FF11                      EFD2              dw int17_handler
36795 FF13                      9270              dw int18_handler
36796 FF15                      E6F2              dw int19_handler
36797 FF17                      FE6E              dw int1a_handler
36798 FF19                      FF53              dw dummy_iret_handler
36799 FF1B                      FF53              dw dummy_iret_handler
36800 FF1D                      0000              dw 0
36801 FF1F                      EFDE              dw diskette_param_table2
36802 FF21                      0000              dw 0
36803                                           ;------------------------------------------------
36804                                           ;- IRET Instruction for Dummy Interrupt Handler -
36805                                           ;------------------------------------------------
36806 FF53                                      .org 0xff53 ; IRET Instruction for Dummy Interrupt Handler
36807                       0000FF53            dummy_iret_handler:
36808 FF53           CF                           iret
36809 FF54                                      .org 0xff54 ; INT 05h Print Screen Service Entry Point
36810                                             HALT(11900)
 +a   FF54           BA                   0400    mov dx,#0x400
 +a   FF57           B8                   2E7C    mov ax,#11900
 +a   FF5A           EF                           out dx,ax
36811 FF5B           CF                           iret
36812 FFF0                                      .org 0xfff0 ; Power-up Entry Point
36813 FFF0           EA         E05B      F000    jmp 0xf000:post
36814 FFF5                                      .org 0xfff5 ; ASCII Date ROM was built - 8 characters in MM/DD/YY
36815 FFF5                        30            .ascii "08/01/21"
36816 FFFE                                      .org 0xfffe ; System Model ID
36817 FFFE                        FC            db 0xFC
36818 FFFF                        00            db 0x00 ; filler
36819 FA6E                                      .org 0xfa6e ;; Character Font for 320x200 & 640x200 Graphics (lower 128 characters)
36820                                           ! 8634 endasm
36821                                           !BCC_ENDASM
36822                                           ! 8635 static Bit8u vgafont8[128*8]=
36823                                           ! Register BX used in function int70_function
36824                                           ! 8636 {
36825                                           
36826                       0000FA6E            _vgafont8:
36827                                           ! 8637  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
36828 FA6E                        00            .byte	0
36829 FA6F                        00            .byte	0
36830 FA70                        00            .byte	0
36831 FA71                        00            .byte	0
36832 FA72                        00            .byte	0
36833 FA73                        00            .byte	0
36834 FA74                        00            .byte	0
36835 FA75                        00            .byte	0
36836                                           ! 8638  0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,
36837 FA76                        7E            .byte	$7E
36838 FA77                        81            .byte	$81
36839 FA78                        A5            .byte	$A5
36840 FA79                        81            .byte	$81
36841 FA7A                        BD            .byte	$BD
36842 FA7B                        99            .byte	$99
36843 FA7C                        81            .byte	$81
36844 FA7D                        7E            .byte	$7E
36845                                           ! 8639  0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,
36846 FA7E                        7E            .byte	$7E
36847 FA7F                        FF            .byte	$FF
36848 FA80                        DB            .byte	$DB
36849 FA81                        FF            .byte	$FF
36850 FA82                        C3            .byte	$C3
36851 FA83                        E7            .byte	$E7
36852 FA84                        FF            .byte	$FF
36853 FA85                        7E            .byte	$7E
36854                                           ! 8640  0x6c, 0xfe
36855 FA86                        6C            .byte	$6C
36856                                           ! 8640 , 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
36857 FA87                        FE            .byte	$FE
36858 FA88                        FE            .byte	$FE
36859 FA89                        FE            .byte	$FE
36860 FA8A                        7C            .byte	$7C
36861 FA8B                        38            .byte	$38
36862 FA8C                        10            .byte	$10
36863 FA8D                        00            .byte	0
36864                                           ! 8641  0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
36865 FA8E                        10            .byte	$10
36866 FA8F                        38            .byte	$38
36867 FA90                        7C            .byte	$7C
36868 FA91                        FE            .byte	$FE
36869 FA92                        7C            .byte	$7C
36870 FA93                        38            .byte	$38
36871 FA94                        10            .byte	$10
36872 FA95                        00            .byte	0
36873                                           ! 8642  0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,
36874 FA96                        38            .byte	$38
36875 FA97                        7C            .byte	$7C
36876 FA98                        38            .byte	$38
36877 FA99                        FE            .byte	$FE
36878 FA9A                        FE            .byte	$FE
36879 FA9B                        7C            .byte	$7C
36880 FA9C                        38            .byte	$38
36881 FA9D                        7C            .byte	$7C
36882                                           ! 8643  0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,
36883 FA9E                        10            .byte	$10
36884 FA9F                        10            .byte	$10
36885 FAA0                        38            .byte	$38
36886 FAA1                        7C            .byte	$7C
36887 FAA2                        FE            .byte	$FE
36888 FAA3                        7C            .byte	$7C
36889 FAA4                        38            .byte	$38
36890 FAA5                        7C            .byte	$7C
36891                                           ! 8644  0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,
36892 FAA6                        00            .byte	0
36893 FAA7                        00            .byte	0
36894 FAA8                        18            .byte	$18
36895 FAA9                        3C            .byte	$3C
36896 FAAA                        3C            .byte	$3C
36897 FAAB                        18            .byte	$18
36898 FAAC                        00            .byte	0
36899 FAAD                        00            .byte	0
36900                                           ! 8645  0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,
36901 FAAE                        FF            .byte	$FF
36902 FAAF                        FF            .byte	$FF
36903 FAB0                        E7            .byte	$E7
36904 FAB1                        C3            .byte	$C3
36905 FAB2                        C3            .byte	$C3
36906 FAB3                        E7            .byte	$E7
36907 FAB4                        FF            .byte	$FF
36908 FAB5                        FF            .byte	$FF
36909                                           ! 8646  0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,
36910 FAB6                        00            .byte	0
36911 FAB7                        3C            .byte	$3C
36912 FAB8                        66            .byte	$66
36913 FAB9                        42            .byte	$42
36914 FABA                        42            .byte	$42
36915 FABB                        66            .byte	$66
36916 FABC                        3C            .byte	$3C
36917 FABD                        00            .byte	0
36918                                           ! 8647  0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,
36919 FABE                        FF            .byte	$FF
36920 FABF                        C3            .byte	$C3
36921 FAC0                        99            .byte	$99
36922 FAC1                        BD            .byte	$BD
36923 FAC2                        BD            .byte	$BD
36924 FAC3                        99            .byte	$99
36925 FAC4                        C3            .byte	$C3
36926 FAC5                        FF            .byte	$FF
36927                                           ! 8648  0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,
36928 FAC6                        0F            .byte	$F
36929 FAC7                        07            .byte	7
36930 FAC8                        0F            .byte	$F
36931 FAC9                        7D            .byte	$7D
36932 FACA                        CC            .byte	$CC
36933 FACB                        CC            .byte	$CC
36934 FACC                        CC            .byte	$CC
36935 FACD                        78            .byte	$78
36936                                           ! 8649  0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,
36937 FACE                        3C            .byte	$3C
36938 FACF                        66            .byte	$66
36939 FAD0                        66            .byte	$66
36940 FAD1                        66            .byte	$66
36941 FAD2                        3C            .byte	$3C
36942 FAD3                        18            .byte	$18
36943 FAD4                        7E            .byte	$7E
36944 FAD5                        18            .byte	$18
36945                                           ! 8650  0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,
36946 FAD6                        3F            .byte	$3F
36947 FAD7                        33            .byte	$33
36948 FAD8                        3F            .byte	$3F
36949 FAD9                        30            .byte	$30
36950 FADA                        30            .byte	$30
36951 FADB                        70            .byte	$70
36952 FADC                        F0            .byte	$F0
36953 FADD                        E0            .byte	$E0
36954                                           ! 8651  0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,
36955 FADE                        7F            .byte	$7F
36956 FADF                        63            .byte	$63
36957 FAE0                        7F            .byte	$7F
36958 FAE1                        63            .byte	$63
36959 FAE2                        63            .byte	$63
36960 FAE3                        67            .byte	$67
36961 FAE4                        E6            .byte	$E6
36962 FAE5                        C0            .byte	$C0
36963                                           ! 8652  0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,
36964 FAE6                        99            .byte	$99
36965 FAE7                        5A            .byte	$5A
36966 FAE8                        3C            .byte	$3C
36967 FAE9                        E7            .byte	$E7
36968 FAEA                        E7            .byte	$E7
36969 FAEB                        3C            .byte	$3C
36970 FAEC                        5A            .byte	$5A
36971 FAED                        99            .byte	$99
36972                                           ! 8653  0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00,
36973 FAEE                        80            .byte	$80
36974 FAEF                        E0            .byte	$E0
36975 FAF0                        F8            .byte	$F8
36976 FAF1                        FE            .byte	$FE
36977 FAF2                        F8            .byte	$F8
36978 FAF3                        E0            .byte	$E0
36979 FAF4                        80            .byte	$80
36980 FAF5                        00            .byte	0
36981                                           ! 8654  0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,
36982 FAF6                        02            .byte	2
36983 FAF7                        0E            .byte	$E
36984 FAF8                        3E            .byte	$3E
36985 FAF9                        FE            .byte	$FE
36986 FAFA                        3E            .byte	$3E
36987 FAFB                        0E            .byte	$E
36988 FAFC                        02            .byte	2
36989 FAFD                        00            .byte	0
36990                                           ! 8655  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,
36991 FAFE                        18            .byte	$18
36992 FAFF                        3C            .byte	$3C
36993 FB00                        7E            .byte	$7E
36994 FB01                        18            .byte	$18
36995 FB02                        18            .byte	$18
36996 FB03                        7E            .byte	$7E
36997 FB04                        3C            .byte	$3C
36998 FB05                        18            .byte	$18
36999                                           ! 8656  0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
37000 FB06                        66            .byte	$66
37001 FB07                        66            .byte	$66
37002 FB08                        66            .byte	$66
37003 FB09                        66            .byte	$66
37004 FB0A                        66            .byte	$66
37005 FB0B                        00            .byte	0
37006 FB0C                        66            .byte	$66
37007 FB0D                        00            .byte	0
37008                                           ! 8657  0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,
37009 FB0E                        7F            .byte	$7F
37010 FB0F                        DB            .byte	$DB
37011 FB10                        DB            .byte	$DB
37012 FB11                        7B            .byte	$7B
37013 FB12                        1B            .byte	$1B
37014 FB13                        1B            .byte	$1B
37015 FB14                        1B            .byte	$1B
37016 FB15                        00            .byte	0
37017                                           ! 8658  0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,
37018 FB16                        3E            .byte	$3E
37019 FB17                        63            .byte	$63
37020 FB18                        38            .byte	$38
37021 FB19                        6C            .byte	$6C
37022 FB1A                        6C            .byte	$6C
37023 FB1B                        38            .byte	$38
37024 FB1C                        CC            .byte	$CC
37025 FB1D                        78            .byte	$78
37026                                           ! 8659  0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,
37027 FB1E                        00            .byte	0
37028 FB1F                        00            .byte	0
37029 FB20                        00            .byte	0
37030 FB21                        00            .byte	0
37031 FB22                        7E            .byte	$7E
37032 FB23                        7E            .byte	$7E
37033 FB24                        7E            .byte	$7E
37034 FB25                        00            .byte	0
37035                                           ! 8660  0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,
37036 FB26                        18            .byte	$18
37037 FB27                        3C            .byte	$3C
37038 FB28                        7E            .byte	$7E
37039 FB29                        18            .byte	$18
37040 FB2A                        7E            .byte	$7E
37041 FB2B                        3C            .byte	$3C
37042 FB2C                        18            .byte	$18
37043 FB2D                        FF            .byte	$FF
37044                                           ! 8661  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,
37045 FB2E                        18            .byte	$18
37046 FB2F                        3C            .byte	$3C
37047 FB30                        7E            .byte	$7E
37048 FB31                        18            .byte	$18
37049 FB32                        18            .byte	$18
37050 FB33                        18            .byte	$18
37051 FB34                        18            .byte	$18
37052 FB35                        00            .byte	0
37053                                           ! 8662  0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
37054 FB36                        18            .byte	$18
37055 FB37                        18            .byte	$18
37056 FB38                        18            .byte	$18
37057 FB39                        18            .byte	$18
37058 FB3A                        7E            .byte	$7E
37059 FB3B                        3C            .byte	$3C
37060 FB3C                        18            .byte	$18
37061 FB3D                        00            .byte	0
37062                                           ! 8663  0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,
37063 FB3E                        00            .byte	0
37064 FB3F                        18            .byte	$18
37065 FB40                        0C            .byte	$C
37066 FB41                        FE            .byte	$FE
37067 FB42                        0C            .byte	$C
37068 FB43                        18            .byte	$18
37069 FB44                        00            .byte	0
37070 FB45                        00            .byte	0
37071                                           ! 8664  0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,
37072 FB46                        00            .byte	0
37073 FB47                        30            .byte	$30
37074 FB48                        60            .byte	$60
37075 FB49                        FE            .byte	$FE
37076 FB4A                        60            .byte	$60
37077 FB4B                        30            .byte	$30
37078 FB4C                        00            .byte	0
37079 FB4D                        00            .byte	0
37080                                           ! 8665  0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,
37081 FB4E                        00            .byte	0
37082 FB4F                        00            .byte	0
37083 FB50                        C0            .byte	$C0
37084 FB51                        C0            .byte	$C0
37085 FB52                        C0            .byte	$C0
37086 FB53                        FE            .byte	$FE
37087 FB54                        00            .byte	0
37088 FB55                        00            .byte	0
37089                                           ! 8666  0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,
37090 FB56                        00            .byte	0
37091 FB57                        24            .byte	$24
37092 FB58                        66            .byte	$66
37093 FB59                        FF            .byte	$FF
37094 FB5A                        66            .byte	$66
37095 FB5B                        24            .byte	$24
37096 FB5C                        00            .byte	0
37097 FB5D                        00            .byte	0
37098                                           ! 8667  0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,
37099 FB5E                        00            .byte	0
37100 FB5F                        18            .byte	$18
37101 FB60                        3C            .byte	$3C
37102 FB61                        7E            .byte	$7E
37103 FB62                        FF            .byte	$FF
37104 FB63                        FF            .byte	$FF
37105 FB64                        00            .byte	0
37106 FB65                        00            .byte	0
37107                                           ! 8668  0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,
37108 FB66                        00            .byte	0
37109 FB67                        FF            .byte	$FF
37110 FB68                        FF            .byte	$FF
37111 FB69                        7E            .byte	$7E
37112 FB6A                        3C            .byte	$3C
37113 FB6B                        18            .byte	$18
37114 FB6C                        00            .byte	0
37115 FB6D                        00            .byte	0
37116                                           ! 8669  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
37117 FB6E                        00            .byte	0
37118 FB6F                        00            .byte	0
37119 FB70                        00            .byte	0
37120 FB71                        00            .byte	0
37121 FB72                        00            .byte	0
37122 FB73                        00            .byte	0
37123 FB74                        00            .byte	0
37124 FB75                        00            .byte	0
37125                                           ! 8670  0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
37126 FB76                        30            .byte	$30
37127 FB77                        78            .byte	$78
37128 FB78                        78            .byte	$78
37129 FB79                        30            .byte	$30
37130 FB7A                        30            .byte	$30
37131 FB7B                        00            .byte	0
37132 FB7C                        30            .byte	$30
37133 FB7D                        00            .byte	0
37134                                           ! 8671  0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
37135 FB7E                        6C            .byte	$6C
37136 FB7F                        6C            .byte	$6C
37137 FB80                        6C            .byte	$6C
37138 FB81                        00            .byte	0
37139 FB82                        00            .byte	0
37140 FB83                        00            .byte	0
37141 FB84                        00            .byte	0
37142 FB85                        00            .byte	0
37143                                           ! 8672  0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
37144 FB86                        6C            .byte	$6C
37145 FB87                        6C            .byte	$6C
37146 FB88                        FE            .byte	$FE
37147 FB89                        6C            .byte	$6C
37148 FB8A                        FE            .byte	$FE
37149 FB8B                        6C            .byte	$6C
37150 FB8C                        6C            .byte	$6C
37151 FB8D                        00            .byte	0
37152                                           ! 8673  0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,
37153 FB8E                        30            .byte	$30
37154 FB8F                        7C            .byte	$7C
37155 FB90                        C0            .byte	$C0
37156 FB91                        78            .byte	$78
37157 FB92                        0C            .byte	$C
37158 FB93                        F8            .byte	$F8
37159 FB94                        30            .byte	$30
37160 FB95                        00            .byte	0
37161                                           ! 8674  0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,
37162 FB96                        00            .byte	0
37163 FB97                        C6            .byte	$C6
37164 FB98                        CC            .byte	$CC
37165 FB99                        18            .byte	$18
37166 FB9A                        30            .byte	$30
37167 FB9B                        66            .byte	$66
37168 FB9C                        C6            .byte	$C6
37169 FB9D                        00            .byte	0
37170                                           ! 8675  0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,
37171 FB9E                        38            .byte	$38
37172 FB9F                        6C            .byte	$6C
37173 FBA0                        38            .byte	$38
37174 FBA1                        76            .byte	$76
37175 FBA2                        DC            .byte	$DC
37176 FBA3                        CC            .byte	$CC
37177 FBA4                        76            .byte	$76
37178 FBA5                        00            .byte	0
37179                                           ! 8676  0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
37180 FBA6                        60            .byte	$60
37181 FBA7                        60            .byte	$60
37182 FBA8                        C0            .byte	$C0
37183 FBA9                        00            .byte	0
37184 FBAA                        00            .byte	0
37185 FBAB                        00            .byte	0
37186 FBAC                        00            .byte	0
37187 FBAD                        00            .byte	0
37188                                           ! 8677  0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
37189 FBAE                        18            .byte	$18
37190 FBAF                        30            .byte	$30
37191 FBB0                        60            .byte	$60
37192 FBB1                        60            .byte	$60
37193 FBB2                        60            .byte	$60
37194 FBB3                        30            .byte	$30
37195 FBB4                        18            .byte	$18
37196 FBB5                        00            .byte	0
37197                                           ! 8678  0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
37198 FBB6                        60            .byte	$60
37199 FBB7                        30            .byte	$30
37200 FBB8                        18            .byte	$18
37201 FBB9                        18            .byte	$18
37202 FBBA                        18            .byte	$18
37203 FBBB                        30            .byte	$30
37204 FBBC                        60            .byte	$60
37205 FBBD                        00            .byte	0
37206                                           ! 8679  0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
37207 FBBE                        00            .byte	0
37208 FBBF                        66            .byte	$66
37209 FBC0                        3C            .byte	$3C
37210 FBC1                        FF            .byte	$FF
37211 FBC2                        3C            .byte	$3C
37212 FBC3                        66            .byte	$66
37213 FBC4                        00            .byte	0
37214 FBC5                        00            .byte	0
37215                                           ! 8680  0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,
37216 FBC6                        00            .byte	0
37217 FBC7                        30            .byte	$30
37218 FBC8                        30            .byte	$30
37219 FBC9                        FC            .byte	$FC
37220 FBCA                        30            .byte	$30
37221 FBCB                        30            .byte	$30
37222 FBCC                        00            .byte	0
37223 FBCD                        00            .byte	0
37224                                           ! 8681  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
37225 FBCE                        00            .byte	0
37226 FBCF                        00            .byte	0
37227 FBD0                        00            .byte	0
37228 FBD1                        00            .byte	0
37229 FBD2                        00            .byte	0
37230 FBD3                        30            .byte	$30
37231 FBD4                        30            .byte	$30
37232 FBD5                        60            .byte	$60
37233                                           ! 8682  
37234                                           ! 8682 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
37235 FBD6                        00            .byte	0
37236 FBD7                        00            .byte	0
37237 FBD8                        00            .byte	0
37238 FBD9                        FC            .byte	$FC
37239 FBDA                        00            .byte	0
37240 FBDB                        00            .byte	0
37241 FBDC                        00            .byte	0
37242 FBDD                        00            .byte	0
37243                                           ! 8683  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
37244 FBDE                        00            .byte	0
37245 FBDF                        00            .byte	0
37246 FBE0                        00            .byte	0
37247 FBE1                        00            .byte	0
37248 FBE2                        00            .byte	0
37249 FBE3                        30            .byte	$30
37250 FBE4                        30            .byte	$30
37251 FBE5                        00            .byte	0
37252                                           ! 8684  0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,
37253 FBE6                        06            .byte	6
37254 FBE7                        0C            .byte	$C
37255 FBE8                        18            .byte	$18
37256 FBE9                        30            .byte	$30
37257 FBEA                        60            .byte	$60
37258 FBEB                        C0            .byte	$C0
37259 FBEC                        80            .byte	$80
37260 FBED                        00            .byte	0
37261                                           ! 8685  0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,
37262 FBEE                        7C            .byte	$7C
37263 FBEF                        C6            .byte	$C6
37264 FBF0                        CE            .byte	$CE
37265 FBF1                        DE            .byte	$DE
37266 FBF2                        F6            .byte	$F6
37267 FBF3                        E6            .byte	$E6
37268 FBF4                        7C            .byte	$7C
37269 FBF5                        00            .byte	0
37270                                           ! 8686  0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,
37271 FBF6                        30            .byte	$30
37272 FBF7                        70            .byte	$70
37273 FBF8                        30            .byte	$30
37274 FBF9                        30            .byte	$30
37275 FBFA                        30            .byte	$30
37276 FBFB                        30            .byte	$30
37277 FBFC                        FC            .byte	$FC
37278 FBFD                        00            .byte	0
37279                                           ! 8687  0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,
37280 FBFE                        78            .byte	$78
37281 FBFF                        CC            .byte	$CC
37282 FC00                        0C            .byte	$C
37283 FC01                        38            .byte	$38
37284 FC02                        60            .byte	$60
37285 FC03                        CC            .byte	$CC
37286 FC04                        FC            .byte	$FC
37287 FC05                        00            .byte	0
37288                                           ! 8688  0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,
37289 FC06                        78            .byte	$78
37290 FC07                        CC            .byte	$CC
37291 FC08                        0C            .byte	$C
37292 FC09                        38            .byte	$38
37293 FC0A                        0C            .byte	$C
37294 FC0B                        CC            .byte	$CC
37295 FC0C                        78            .byte	$78
37296 FC0D                        00            .byte	0
37297                                           ! 8689  0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,
37298 FC0E                        1C            .byte	$1C
37299 FC0F                        3C            .byte	$3C
37300 FC10                        6C            .byte	$6C
37301 FC11                        CC            .byte	$CC
37302 FC12                        FE            .byte	$FE
37303 FC13                        0C            .byte	$C
37304 FC14                        1E            .byte	$1E
37305 FC15                        00            .byte	0
37306                                           ! 8690  0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,
37307 FC16                        FC            .byte	$FC
37308 FC17                        C0            .byte	$C0
37309 FC18                        F8            .byte	$F8
37310 FC19                        0C            .byte	$C
37311 FC1A                        0C            .byte	$C
37312 FC1B                        CC            .byte	$CC
37313 FC1C                        78            .byte	$78
37314 FC1D                        00            .byte	0
37315                                           ! 8691  0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,
37316 FC1E                        38            .byte	$38
37317 FC1F                        60            .byte	$60
37318 FC20                        C0            .byte	$C0
37319 FC21                        F8            .byte	$F8
37320 FC22                        CC            .byte	$CC
37321 FC23                        CC            .byte	$CC
37322 FC24                        78            .byte	$78
37323 FC25                        00            .byte	0
37324                                           ! 8692  0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,
37325 FC26                        FC            .byte	$FC
37326 FC27                        CC            .byte	$CC
37327 FC28                        0C            .byte	$C
37328 FC29                        18            .byte	$18
37329 FC2A                        30            .byte	$30
37330 FC2B                        30            .byte	$30
37331 FC2C                        30            .byte	$30
37332 FC2D                        00            .byte	0
37333                                           ! 8693  0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00,
37334 FC2E                        78            .byte	$78
37335 FC2F                        CC            .byte	$CC
37336 FC30                        CC            .byte	$CC
37337 FC31                        78            .byte	$78
37338 FC32                        CC            .byte	$CC
37339 FC33                        CC            .byte	$CC
37340 FC34                        78            .byte	$78
37341 FC35                        00            .byte	0
37342                                           ! 8694  0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,
37343 FC36                        78            .byte	$78
37344 FC37                        CC            .byte	$CC
37345 FC38                        CC            .byte	$CC
37346 FC39                        7C            .byte	$7C
37347 FC3A                        0C            .byte	$C
37348 FC3B                        18            .byte	$18
37349 FC3C                        70            .byte	$70
37350 FC3D                        00            .byte	0
37351                                           ! 8695  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00,
37352 FC3E                        00            .byte	0
37353 FC3F                        30            .byte	$30
37354 FC40                        30            .byte	$30
37355 FC41                        00            .byte	0
37356 FC42                        00            .byte	0
37357 FC43                        30            .byte	$30
37358 FC44                        30            .byte	$30
37359 FC45                        00            .byte	0
37360                                           ! 8696  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
37361 FC46                        00            .byte	0
37362 FC47                        30            .byte	$30
37363 FC48                        30            .byte	$30
37364 FC49                        00            .byte	0
37365 FC4A                        00            .byte	0
37366 FC4B                        30            .byte	$30
37367 FC4C                        30            .byte	$30
37368 FC4D                        60            .byte	$60
37369                                           ! 8697  0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,
37370 FC4E                        18            .byte	$18
37371 FC4F                        30            .byte	$30
37372 FC50                        60            .byte	$60
37373 FC51                        C0            .byte	$C0
37374 FC52                        60            .byte	$60
37375 FC53                        30            .byte	$30
37376 FC54                        18            .byte	$18
37377 FC55                        00            .byte	0
37378                                           ! 8698  0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,
37379 FC56                        00            .byte	0
37380 FC57                        00            .byte	0
37381 FC58                        FC            .byte	$FC
37382 FC59                        00            .byte	0
37383 FC5A                        00            .byte	0
37384 FC5B                        FC            .byte	$FC
37385 FC5C                        00            .byte	0
37386 FC5D                        00            .byte	0
37387                                           ! 8699  0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
37388 FC5E                        60            .byte	$60
37389 FC5F                        30            .byte	$30
37390 FC60                        18            .byte	$18
37391 FC61                        0C            .byte	$C
37392 FC62                        18            .byte	$18
37393 FC63                        30            .byte	$30
37394 FC64                        60            .byte	$60
37395 FC65                        00            .byte	0
37396                                           ! 8700  0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,
37397 FC66                        78            .byte	$78
37398 FC67                        CC            .byte	$CC
37399 FC68                        0C            .byte	$C
37400 FC69                        18            .byte	$18
37401 FC6A                        30            .byte	$30
37402 FC6B                        00            .byte	0
37403 FC6C                        30            .byte	$30
37404 FC6D                        00            .byte	0
37405                                           ! 8701  0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,
37406 FC6E                        7C            .byte	$7C
37407 FC6F                        C6            .byte	$C6
37408 FC70                        DE            .byte	$DE
37409 FC71                        DE            .byte	$DE
37410 FC72                        DE            .byte	$DE
37411 FC73                        C0            .byte	$C0
37412 FC74                        78            .byte	$78
37413 FC75                        00            .byte	0
37414                                           ! 8702  0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,
37415 FC76                        30            .byte	$30
37416 FC77                        78            .byte	$78
37417 FC78                        CC            .byte	$CC
37418 FC79                        CC            .byte	$CC
37419 FC7A                        FC            .byte	$FC
37420 FC7B                        CC            .byte	$CC
37421 FC7C                        CC            .byte	$CC
37422 FC7D                        00            .byte	0
37423                                           ! 8703  0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,
37424 FC7E                        FC            .byte	$FC
37425 FC7F                        66            .byte	$66
37426 FC80                        66            .byte	$66
37427 FC81                        7C            .byte	$7C
37428 FC82                        66            .byte	$66
37429 FC83                        66            .byte	$66
37430 FC84                        FC            .byte	$FC
37431 FC85                        00            .byte	0
37432                                           ! 8704  0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,
37433 FC86                        3C            .byte	$3C
37434 FC87                        66            .byte	$66
37435 FC88                        C0            .byte	$C0
37436 FC89                        C0            .byte	$C0
37437 FC8A                        C0            .byte	$C0
37438 FC8B                        66            .byte	$66
37439 FC8C                        3C            .byte	$3C
37440 FC8D                        00            .byte	0
37441                                           ! 8705  0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
37442 FC8E                        F8            .byte	$F8
37443 FC8F                        6C            .byte	$6C
37444 FC90                        66            .byte	$66
37445 FC91                        66            .byte	$66
37446 FC92                        66            .byte	$66
37447 FC93                        6C            .byte	$6C
37448 FC94                        F8            .byte	$F8
37449 FC95                        00            .byte	0
37450                                           ! 8706  0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,
37451 FC96                        FE            .byte	$FE
37452 FC97                        62            .byte	$62
37453 FC98                        68            .byte	$68
37454 FC99                        78            .byte	$78
37455 FC9A                        68            .byte	$68
37456 FC9B                        62            .byte	$62
37457 FC9C                        FE            .byte	$FE
37458 FC9D                        00            .byte	0
37459                                           ! 8707  0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,
37460 FC9E                        FE            .byte	$FE
37461 FC9F                        62            .byte	$62
37462 FCA0                        68            .byte	$68
37463 FCA1                        78            .byte	$78
37464 FCA2                        68            .byte	$68
37465 FCA3                        60            .byte	$60
37466 FCA4                        F0            .byte	$F0
37467 FCA5                        00            .byte	0
37468                                           ! 8708  0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,
37469 FCA6                        3C            .byte	$3C
37470 FCA7                        66            .byte	$66
37471 FCA8                        C0            .byte	$C0
37472 FCA9                        C0            .byte	$C0
37473 FCAA                        CE            .byte	$CE
37474 FCAB                        66            .byte	$66
37475 FCAC                        3E            .byte	$3E
37476 FCAD                        00            .byte	0
37477                                           ! 8709  0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,
37478 FCAE                        CC            .byte	$CC
37479 FCAF                        CC            .byte	$CC
37480 FCB0                        CC            .byte	$CC
37481 FCB1                        FC            .byte	$FC
37482 FCB2                        CC            .byte	$CC
37483 FCB3                        CC            .byte	$CC
37484 FCB4                        CC            .byte	$CC
37485 FCB5                        00            .byte	0
37486                                           ! 8710  0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
37487 FCB6                        78            .byte	$78
37488 FCB7                        30            .byte	$30
37489 FCB8                        30            .byte	$30
37490 FCB9                        30            .byte	$30
37491 FCBA                        30            .byte	$30
37492 FCBB                        30            .byte	$30
37493 FCBC                        78            .byte	$78
37494 FCBD                        00            .byte	0
37495                                           ! 8711  0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
37496 FCBE                        1E            .byte	$1E
37497 FCBF                        0C            .byte	$C
37498 FCC0                        0C            .byte	$C
37499 FCC1                        0C            .byte	$C
37500 FCC2                        CC            .byte	$CC
37501 FCC3                        CC            .byte	$CC
37502 FCC4                        78            .byte	$78
37503 FCC5                        00            .byte	0
37504                                           ! 8712  0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
37505 FCC6                        E6            .byte	$E6
37506 FCC7                        66            .byte	$66
37507 FCC8                        6C            .byte	$6C
37508 FCC9                        78            .byte	$78
37509 FCCA                        6C            .byte	$6C
37510 FCCB                        66            .byte	$66
37511 FCCC                        E6            .byte	$E6
37512 FCCD                        00            .byte	0
37513                                           ! 8713  0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
37514 FCCE                        F0            .byte	$F0
37515 FCCF                        60            .byte	$60
37516 FCD0                        60            .byte	$60
37517 FCD1                        60            .byte	$60
37518 FCD2                        62            .byte	$62
37519 FCD3                        66            .byte	$66
37520 FCD4                        FE            .byte	$FE
37521 FCD5                        00            .byte	0
37522                                           ! 8714  0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
37523 FCD6                        C6            .byte	$C6
37524 FCD7                        EE            .byte	$EE
37525 FCD8                        FE            .byte	$FE
37526 FCD9                        FE            .byte	$FE
37527 FCDA                        D6            .byte	$D6
37528 FCDB                        C6            .byte	$C6
37529 FCDC                        C6            .byte	$C6
37530 FCDD                        00            .byte	0
37531                                           ! 8715  0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
37532 FCDE                        C6            .byte	$C6
37533 FCDF                        E6            .byte	$E6
37534 FCE0                        F6            .byte	$F6
37535 FCE1                        DE            .byte	$DE
37536 FCE2                        CE            .byte	$CE
37537 FCE3                        C6            .byte	$C6
37538 FCE4                        C6            .byte	$C6
37539 FCE5                        00            .byte	0
37540                                           ! 8716  0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
37541 FCE6                        38            .byte	$38
37542 FCE7                        6C            .byte	$6C
37543 FCE8                        C6            .byte	$C6
37544 FCE9                        C6            .byte	$C6
37545 FCEA                        C6            .byte	$C6
37546 FCEB                        6C            .byte	$6C
37547 FCEC                        38            .byte	$38
37548 FCED                        00            .byte	0
37549                                           ! 8717  0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
37550 FCEE                        FC            .byte	$FC
37551 FCEF                        66            .byte	$66
37552 FCF0                        66            .byte	$66
37553 FCF1                        7C            .byte	$7C
37554 FCF2                        60            .byte	$60
37555 FCF3                        60            .byte	$60
37556 FCF4                        F0            .byte	$F0
37557 FCF5                        00            .byte	0
37558                                           ! 8718  0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,
37559 FCF6                        78            .byte	$78
37560 FCF7                        CC            .byte	$CC
37561 FCF8                        CC            .byte	$CC
37562 FCF9                        CC            .byte	$CC
37563 FCFA                        DC            .byte	$DC
37564 FCFB                        78            .byte	$78
37565 FCFC                        1C            .byte	$1C
37566 FCFD                        00            .byte	0
37567                                           ! 8719  0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,
37568 FCFE                        FC            .byte	$FC
37569 FCFF                        66            .byte	$66
37570 FD00                        66            .byte	$66
37571 FD01                        7C            .byte	$7C
37572 FD02                        6C            .byte	$6C
37573 FD03                        66            .byte	$66
37574 FD04                        E6            .byte	$E6
37575 FD05                        00            .byte	0
37576                                           ! 8720  0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,
37577 FD06                        78            .byte	$78
37578 FD07                        CC            .byte	$CC
37579 FD08                        E0            .byte	$E0
37580 FD09                        70            .byte	$70
37581 FD0A                        1C            .byte	$1C
37582 FD0B                        CC            .byte	$CC
37583 FD0C                        78            .byte	$78
37584 FD0D                        00            .byte	0
37585                                           ! 8721  0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
37586 FD0E                        FC            .byte	$FC
37587 FD0F                        B4            .byte	$B4
37588 FD10                        30            .byte	$30
37589 FD11                        30            .byte	$30
37590 FD12                        30            .byte	$30
37591 FD13                        30            .byte	$30
37592 FD14                        78            .byte	$78
37593 FD15                        00            .byte	0
37594                                           ! 8722  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,
37595 FD16                        CC            .byte	$CC
37596 FD17                        CC            .byte	$CC
37597 FD18                        CC            .byte	$CC
37598 FD19                        CC            .byte	$CC
37599 FD1A                        CC            .byte	$CC
37600 FD1B                        CC            .byte	$CC
37601 FD1C                        FC            .byte	$FC
37602 FD1D                        00            .byte	0
37603                                           ! 8723  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x3
37604 FD1E                        CC            .byte	$CC
37605 FD1F                        CC            .byte	$CC
37606 FD20                        CC            .byte	$CC
37607 FD21                        CC            .byte	$CC
37608 FD22                        CC            .byte	$CC
37609 FD23                        78            .byte	$78
37610                                           ! 8723 0, 0x00,
37611 FD24                        30            .byte	$30
37612 FD25                        00            .byte	0
37613                                           ! 8724  0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
37614 FD26                        C6            .byte	$C6
37615 FD27                        C6            .byte	$C6
37616 FD28                        C6            .byte	$C6
37617 FD29                        D6            .byte	$D6
37618 FD2A                        FE            .byte	$FE
37619 FD2B                        EE            .byte	$EE
37620 FD2C                        C6            .byte	$C6
37621 FD2D                        00            .byte	0
37622                                           ! 8725  0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
37623 FD2E                        C6            .byte	$C6
37624 FD2F                        C6            .byte	$C6
37625 FD30                        6C            .byte	$6C
37626 FD31                        38            .byte	$38
37627 FD32                        38            .byte	$38
37628 FD33                        6C            .byte	$6C
37629 FD34                        C6            .byte	$C6
37630 FD35                        00            .byte	0
37631                                           ! 8726  0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,
37632 FD36                        CC            .byte	$CC
37633 FD37                        CC            .byte	$CC
37634 FD38                        CC            .byte	$CC
37635 FD39                        78            .byte	$78
37636 FD3A                        30            .byte	$30
37637 FD3B                        30            .byte	$30
37638 FD3C                        78            .byte	$78
37639 FD3D                        00            .byte	0
37640                                           ! 8727  0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,
37641 FD3E                        FE            .byte	$FE
37642 FD3F                        C6            .byte	$C6
37643 FD40                        8C            .byte	$8C
37644 FD41                        18            .byte	$18
37645 FD42                        32            .byte	$32
37646 FD43                        66            .byte	$66
37647 FD44                        FE            .byte	$FE
37648 FD45                        00            .byte	0
37649                                           ! 8728  0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
37650 FD46                        78            .byte	$78
37651 FD47                        60            .byte	$60
37652 FD48                        60            .byte	$60
37653 FD49                        60            .byte	$60
37654 FD4A                        60            .byte	$60
37655 FD4B                        60            .byte	$60
37656 FD4C                        78            .byte	$78
37657 FD4D                        00            .byte	0
37658                                           ! 8729  0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,
37659 FD4E                        C0            .byte	$C0
37660 FD4F                        60            .byte	$60
37661 FD50                        30            .byte	$30
37662 FD51                        18            .byte	$18
37663 FD52                        0C            .byte	$C
37664 FD53                        06            .byte	6
37665 FD54                        02            .byte	2
37666 FD55                        00            .byte	0
37667                                           ! 8730  0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
37668 FD56                        78            .byte	$78
37669 FD57                        18            .byte	$18
37670 FD58                        18            .byte	$18
37671 FD59                        18            .byte	$18
37672 FD5A                        18            .byte	$18
37673 FD5B                        18            .byte	$18
37674 FD5C                        78            .byte	$78
37675 FD5D                        00            .byte	0
37676                                           ! 8731  0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
37677 FD5E                        10            .byte	$10
37678 FD5F                        38            .byte	$38
37679 FD60                        6C            .byte	$6C
37680 FD61                        C6            .byte	$C6
37681 FD62                        00            .byte	0
37682 FD63                        00            .byte	0
37683 FD64                        00            .byte	0
37684 FD65                        00            .byte	0
37685                                           ! 8732  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
37686 FD66                        00            .byte	0
37687 FD67                        00            .byte	0
37688 FD68                        00            .byte	0
37689 FD69                        00            .byte	0
37690 FD6A                        00            .byte	0
37691 FD6B                        00            .byte	0
37692 FD6C                        00            .byte	0
37693 FD6D                        FF            .byte	$FF
37694                                           ! 8733  0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
37695 FD6E                        30            .byte	$30
37696 FD6F                        30            .byte	$30
37697 FD70                        18            .byte	$18
37698 FD71                        00            .byte	0
37699 FD72                        00            .byte	0
37700 FD73                        00            .byte	0
37701 FD74                        00            .byte	0
37702 FD75                        00            .byte	0
37703                                           ! 8734  0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,
37704 FD76                        00            .byte	0
37705 FD77                        00            .byte	0
37706 FD78                        78            .byte	$78
37707 FD79                        0C            .byte	$C
37708 FD7A                        7C            .byte	$7C
37709 FD7B                        CC            .byte	$CC
37710 FD7C                        76            .byte	$76
37711 FD7D                        00            .byte	0
37712                                           ! 8735  0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00,
37713 FD7E                        E0            .byte	$E0
37714 FD7F                        60            .byte	$60
37715 FD80                        60            .byte	$60
37716 FD81                        7C            .byte	$7C
37717 FD82                        66            .byte	$66
37718 FD83                        66            .byte	$66
37719 FD84                        DC            .byte	$DC
37720 FD85                        00            .byte	0
37721                                           ! 8736  0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,
37722 FD86                        00            .byte	0
37723 FD87                        00            .byte	0
37724 FD88                        78            .byte	$78
37725 FD89                        CC            .byte	$CC
37726 FD8A                        C0            .byte	$C0
37727 FD8B                        CC            .byte	$CC
37728 FD8C                        78            .byte	$78
37729 FD8D                        00            .byte	0
37730                                           ! 8737  0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
37731 FD8E                        1C            .byte	$1C
37732 FD8F                        0C            .byte	$C
37733 FD90                        0C            .byte	$C
37734 FD91                        7C            .byte	$7C
37735 FD92                        CC            .byte	$CC
37736 FD93                        CC            .byte	$CC
37737 FD94                        76            .byte	$76
37738 FD95                        00            .byte	0
37739                                           ! 8738  0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
37740 FD96                        00            .byte	0
37741 FD97                        00            .byte	0
37742 FD98                        78            .byte	$78
37743 FD99                        CC            .byte	$CC
37744 FD9A                        FC            .byte	$FC
37745 FD9B                        C0            .byte	$C0
37746 FD9C                        78            .byte	$78
37747 FD9D                        00            .byte	0
37748                                           ! 8739  0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,
37749 FD9E                        38            .byte	$38
37750 FD9F                        6C            .byte	$6C
37751 FDA0                        60            .byte	$60
37752 FDA1                        F0            .byte	$F0
37753 FDA2                        60            .byte	$60
37754 FDA3                        60            .byte	$60
37755 FDA4                        F0            .byte	$F0
37756 FDA5                        00            .byte	0
37757                                           ! 8740  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
37758 FDA6                        00            .byte	0
37759 FDA7                        00            .byte	0
37760 FDA8                        76            .byte	$76
37761 FDA9                        CC            .byte	$CC
37762 FDAA                        CC            .byte	$CC
37763 FDAB                        7C            .byte	$7C
37764 FDAC                        0C            .byte	$C
37765 FDAD                        F8            .byte	$F8
37766                                           ! 8741  0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,
37767 FDAE                        E0            .byte	$E0
37768 FDAF                        60            .byte	$60
37769 FDB0                        6C            .byte	$6C
37770 FDB1                        76            .byte	$76
37771 FDB2                        66            .byte	$66
37772 FDB3                        66            .byte	$66
37773 FDB4                        E6            .byte	$E6
37774 FDB5                        00            .byte	0
37775                                           ! 8742  0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
37776 FDB6                        30            .byte	$30
37777 FDB7                        00            .byte	0
37778 FDB8                        70            .byte	$70
37779 FDB9                        30            .byte	$30
37780 FDBA                        30            .byte	$30
37781 FDBB                        30            .byte	$30
37782 FDBC                        78            .byte	$78
37783 FDBD                        00            .byte	0
37784                                           ! 8743  0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
37785 FDBE                        0C            .byte	$C
37786 FDBF                        00            .byte	0
37787 FDC0                        0C            .byte	$C
37788 FDC1                        0C            .byte	$C
37789 FDC2                        0C            .byte	$C
37790 FDC3                        CC            .byte	$CC
37791 FDC4                        CC            .byte	$CC
37792 FDC5                        78            .byte	$78
37793                                           ! 8744  0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,
37794 FDC6                        E0            .byte	$E0
37795 FDC7                        60            .byte	$60
37796 FDC8                        66            .byte	$66
37797 FDC9                        6C            .byte	$6C
37798 FDCA                        78            .byte	$78
37799 FDCB                        6C            .byte	$6C
37800 FDCC                        E6            .byte	$E6
37801 FDCD                        00            .byte	0
37802                                           ! 8745  0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
37803 FDCE                        70            .byte	$70
37804 FDCF                        30            .byte	$30
37805 FDD0                        30            .byte	$30
37806 FDD1                        30            .byte	$30
37807 FDD2                        30            .byte	$30
37808 FDD3                        30            .byte	$30
37809 FDD4                        78            .byte	$78
37810 FDD5                        00            .byte	0
37811                                           ! 8746  0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,
37812 FDD6                        00            .byte	0
37813 FDD7                        00            .byte	0
37814 FDD8                        CC            .byte	$CC
37815 FDD9                        FE            .byte	$FE
37816 FDDA                        FE            .byte	$FE
37817 FDDB                        D6            .byte	$D6
37818 FDDC                        C6            .byte	$C6
37819 FDDD                        00            .byte	0
37820                                           ! 8747  0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
37821 FDDE                        00            .byte	0
37822 FDDF                        00            .byte	0
37823 FDE0                        F8            .byte	$F8
37824 FDE1                        CC            .byte	$CC
37825 FDE2                        CC            .byte	$CC
37826 FDE3                        CC            .byte	$CC
37827 FDE4                        CC            .byte	$CC
37828 FDE5                        00            .byte	0
37829                                           ! 8748  0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
37830 FDE6                        00            .byte	0
37831 FDE7                        00            .byte	0
37832 FDE8                        78            .byte	$78
37833 FDE9                        CC            .byte	$CC
37834 FDEA                        CC            .byte	$CC
37835 FDEB                        CC            .byte	$CC
37836 FDEC                        78            .byte	$78
37837 FDED                        00            .byte	0
37838                                           ! 8749  0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,
37839 FDEE                        00            .byte	0
37840 FDEF                        00            .byte	0
37841 FDF0                        DC            .byte	$DC
37842 FDF1                        66            .byte	$66
37843 FDF2                        66            .byte	$66
37844 FDF3                        7C            .byte	$7C
37845 FDF4                        60            .byte	$60
37846 FDF5                        F0            .byte	$F0
37847                                           ! 8750  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,
37848 FDF6                        00            .byte	0
37849 FDF7                        00            .byte	0
37850 FDF8                        76            .byte	$76
37851 FDF9                        CC            .byte	$CC
37852 FDFA                        CC            .byte	$CC
37853 FDFB                        7C            .byte	$7C
37854 FDFC                        0C            .byte	$C
37855 FDFD                        1E            .byte	$1E
37856                                           ! 8751  0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,
37857 FDFE                        00            .byte	0
37858 FDFF                        00            .byte	0
37859 FE00                        DC            .byte	$DC
37860 FE01                        76            .byte	$76
37861 FE02                        66            .byte	$66
37862 FE03                        60            .byte	$60
37863 FE04                        F0            .byte	$F0
37864 FE05                        00            .byte	0
37865                                           ! 8752  0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,
37866 FE06                        00            .byte	0
37867 FE07                        00            .byte	0
37868 FE08                        7C            .byte	$7C
37869 FE09                        C0            .byte	$C0
37870 FE0A                        78            .byte	$78
37871 FE0B                        0C            .byte	$C
37872 FE0C                        F8            .byte	$F8
37873 FE0D                        00            .byte	0
37874                                           ! 8753  0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,
37875 FE0E                        10            .byte	$10
37876 FE0F                        30            .byte	$30
37877 FE10                        7C            .byte	$7C
37878 FE11                        30            .byte	$30
37879 FE12                        30            .byte	$30
37880 FE13                        34            .byte	$34
37881 FE14                        18            .byte	$18
37882 FE15                        00            .byte	0
37883                                           ! 8754  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
37884 FE16                        00            .byte	0
37885 FE17                        00            .byte	0
37886 FE18                        CC            .byte	$CC
37887 FE19                        CC            .byte	$CC
37888 FE1A                        CC            .byte	$CC
37889 FE1B                        CC            .byte	$CC
37890 FE1C                        76            .byte	$76
37891 FE1D                        00            .byte	0
37892                                           ! 8755  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
37893 FE1E                        00            .byte	0
37894 FE1F                        00            .byte	0
37895 FE20                        CC            .byte	$CC
37896 FE21                        CC            .byte	$CC
37897 FE22                        CC            .byte	$CC
37898 FE23                        78            .byte	$78
37899 FE24                        30            .byte	$30
37900 FE25                        00            .byte	0
37901                                           ! 8756  0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,
37902 FE26                        00            .byte	0
37903 FE27                        00            .byte	0
37904 FE28                        C6            .byte	$C6
37905 FE29                        D6            .byte	$D6
37906 FE2A                        FE            .byte	$FE
37907 FE2B                        FE            .byte	$FE
37908 FE2C                        6C            .byte	$6C
37909 FE2D                        00            .byte	0
37910                                           ! 8757  0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
37911 FE2E                        00            .byte	0
37912 FE2F                        00            .byte	0
37913 FE30                        C6            .byte	$C6
37914 FE31                        6C            .byte	$6C
37915 FE32                        38            .byte	$38
37916 FE33                        6C            .byte	$6C
37917 FE34                        C6            .byte	$C6
37918 FE35                        00            .byte	0
37919                                           ! 8758  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
37920 FE36                        00            .byte	0
37921 FE37                        00            .byte	0
37922 FE38                        CC            .byte	$CC
37923 FE39                        CC            .byte	$CC
37924 FE3A                        CC            .byte	$CC
37925 FE3B                        7C            .byte	$7C
37926 FE3C                        0C            .byte	$C
37927 FE3D                        F8            .byte	$F8
37928                                           ! 8759  0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,
37929 FE3E                        00            .byte	0
37930 FE3F                        00            .byte	0
37931 FE40                        FC            .byte	$FC
37932 FE41                        98            .byte	$98
37933 FE42                        30            .byte	$30
37934 FE43                        64            .byte	$64
37935 FE44                        FC            .byte	$FC
37936 FE45                        00            .byte	0
37937                                           ! 8760  0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,
37938 FE46                        1C            .byte	$1C
37939 FE47                        30            .byte	$30
37940 FE48                        30            .byte	$30
37941 FE49                        E0            .byte	$E0
37942 FE4A                        30            .byte	$30
37943 FE4B                        30            .byte	$30
37944 FE4C                        1C            .byte	$1C
37945 FE4D                        00            .byte	0
37946                                           ! 8761  0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
37947 FE4E                        18            .byte	$18
37948 FE4F                        18            .byte	$18
37949 FE50                        18            .byte	$18
37950 FE51                        00            .byte	0
37951 FE52                        18            .byte	$18
37952 FE53                        18            .byte	$18
37953 FE54                        18            .byte	$18
37954 FE55                        00            .byte	0
37955                                           ! 8762  0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,
37956 FE56                        E0            .byte	$E0
37957 FE57                        30            .byte	$30
37958 FE58                        30            .byte	$30
37959 FE59                        1C            .byte	$1C
37960 FE5A                        30            .byte	$30
37961 FE5B                        30            .byte	$30
37962 FE5C                        E0            .byte	$E0
37963 FE5D                        00            .byte	0
37964                                           ! 8763  0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
37965 FE5E                        76            .byte	$76
37966 FE5F                        DC            .byte	$DC
37967 FE60                        00            .byte	0
37968 FE61                        00            .byte	0
37969 FE62                        00            .byte	0
37970 FE63                        00            .byte	0
37971 FE64                        00            .byte	0
37972 FE65                        00            .byte	0
37973                                           ! 8764  0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,
37974 FE66                        00            .byte	0
37975 FE67                        10            .byte	$10
37976 FE68                        38            .byte	$38
37977 FE69                        6C            .byte	$6C
37978 FE6A                        C6            .byte	$C6
37979 FE6B                        C6            .byte	$C6
37980 FE6C                        FE            .byte	$FE
37981 FE6D                        00            .byte	0
37982                                           ! 8765 };
37983                                           !BCC_EOS
37984                                           ! 8766 #asm
37985                                           !BCC_ASM
37986 CC00                                      .org 0xcc00
37987                       0000CC00            bios_table_area_end:
37988 CC00                        28            .ascii "(c) 2001-2021  The Bochs Project"
37989                                           ! 8770 endasm
37990                                           !BCC_ENDASM
37991                                           ! 8771 
37992                       0000CC20            .7FB:
37993                       0000CC20            .80A:
37994 CC20                        6E            .ascii	"no PCI device with class code 0x%02x%04x"
37995 CC48                        20            .ascii	" found at index %d"
37996 CC5A                        0A            .byte	$A
37997 CC5B                        00            .byte	0
37998                       0000CC5C            .7F9:
37999                       0000CC5C            .80B:
38000 CC5C                        50            .ascii	"PCI device %04x:%04x not found at index "
38001 CC84                        25            .ascii	"%d"
38002 CC86                        0A            .byte	$A
38003 CC87                        00            .byte	0
38004                       0000CC88            .7F3:
38005                       0000CC88            .80C:
38006 CC88                        62            .ascii	"bad PCI vendor ID %04x"
38007 CC9E                        0A            .byte	$A
38008 CC9F                        00            .byte	0
38009                       0000CCA0            .7EF:
38010                       0000CCA0            .80D:
38011 CCA0                        75            .ascii	"unsupported PCI BIOS function 0x%02x"
38012 CCC4                        0A            .byte	$A
38013 CCC5                        00            .byte	0
38014                       0000CCC6            .7EB:
38015                       0000CCC6            .80E:
38016 CCC6                        50            .ascii	"PCI BIOS: PCI not present"
38017 CCDF                        0A            .byte	$A
38018 CCE0                        00            .byte	0
38019                       0000CCE1            .79D:
38020                       0000CCE1            .80F:
38021 CCE1                        42            .ascii	"Booting from %x:%x"
38022 CCF3                        0A            .byte	$A
38023 CCF4                        00            .byte	0
38024                       0000CCF5            .788:
38025                       0000CCF5            .810:
38026 CCF5                        49            .ascii	"Invalid boot device (0x%x)"
38027 CD0F                        0A            .byte	$A
38028 CD10                        00            .byte	0
38029                       0000CD11            .785:
38030                       0000CD11            .811:
38031 CD11                        4E            .ascii	"No bootable device."
38032 CD24                        0A            .byte	$A
38033 CD25                        00            .byte	0
38034                       0000CD26            .76F:
38035                       0000CD26            .812:
38036 CD26                        73            .ascii	"set_diskette_current_cyl(): drive > 1"
38037 CD4B                        0A            .byte	$A
38038 CD4C                        00            .byte	0
38039                       0000CD4D            .76A:
38040                       0000CD4D            .813:
38041 CD4D                        69            .ascii	"int13_diskette: unsupported AH=%02x"
38042 CD70                        0A            .byte	$A
38043 CD71                        00            .byte	0
38044                       0000CD72            .706:
38045                       0000CD72            .814:
38046 CD72                        66            .ascii	"floppy: int13: bad floppy type"
38047 CD90                        0A            .byte	$A
38048 CD91                        00            .byte	0
38049                       0000CD92            .6EE:
38050                       0000CD92            .815:
38051 CD92                        69            .ascii	"int13_diskette_function: write error"
38052 CDB6                        0A            .byte	$A
38053 CDB7                        00            .byte	0
38054                       0000CDB8            .6E8:
38055                       0000CDB8            .816:
38056 CDB8                        69            .ascii	"int13_diskette: ctrl not ready"
38057 CDD6                        0A            .byte	$A
38058 CDD7                        00            .byte	0
38059                       0000CDD8            .6CE:
38060                       0000CDD8            .817:
38061 CDD8                        69            .ascii	"int13_diskette_function: write error"
38062 CDFC                        0A            .byte	$A
38063 CDFD                        00            .byte	0
38064                       0000CDFE            .6C5:
38065                       0000CDFE            .818:
38066 CDFE                        69            .ascii	"int13_diskette: ctrl not ready"
38067 CE1C                        0A            .byte	$A
38068 CE1D                        00            .byte	0
38069                       0000CE1E            .6AD:
38070                       0000CE1E            .819:
38071 CE1E                        69            .ascii	"int13_diskette: read/write/verify: param"
38072 CE46                        65            .ascii	"eter out of range"
38073 CE57                        0A            .byte	$A
38074 CE58                        00            .byte	0
38075                       0000CE59            .655:
38076                       0000CE59            .81A:
38077 CE59                        69            .ascii	"int13_cdemu function AH=%02x unsupported"
38078 CE81                        2C            .ascii	", returns fail"
38079 CE8F                        0A            .byte	$A
38080 CE90                        00            .byte	0
38081                       0000CE91            .63D:
38082                       0000CE91            .81B:
38083 CE91                        69            .ascii	"int13_cdemu: function %02x, error %02x !"
38084 CEB9                        0A            .byte	$A
38085 CEBA                        00            .byte	0
38086                       0000CEBB            .61F:
38087                       0000CEBB            .81C:
38088 CEBB                        69            .ascii	"int13_cdemu: function %02x, emulation no"
38089 CEE3                        74            .ascii	"t active for DL= %02x"
38090 CEF8                        0A            .byte	$A
38091 CEF9                        00            .byte	0
38092                       0000CEFA            .61B:
38093                       0000CEFA            .81D:
38094 CEFA                        69            .ascii	"int13_eltorito: unsupported AH=%02x"
38095 CF1D                        0A            .byte	$A
38096 CF1E                        00            .byte	0
38097                       0000CF1F            .616:
38098                       0000CF1F            .81E:
38099 CF1F                        49            .ascii	"Int13 eltorito call with AX=%04x. Please"
38100 CF47                        20            .ascii	" report"
38101 CF4E                        0A            .byte	$A
38102 CF4F                        00            .byte	0
38103                       0000CF50            .60B:
38104                       0000CF50            .81F:
38105 CF50                        69            .ascii	"int13_cdrom: unsupported AH=%02x"
38106 CF70                        0A            .byte	$A
38107 CF71                        00            .byte	0
38108                       0000CF72            .5DD:
38109                       0000CF72            .820:
38110 CF72                        69            .ascii	"int13_cdrom: function %02x, status %02x "
38111 CF9A                        21            .ascii	"!"
38112 CF9B                        0A            .byte	$A
38113 CF9C                        00            .byte	0
38114                       0000CF9D            .5D7:
38115                       0000CF9D            .821:
38116 CF9D                        69            .ascii	"int13_cdrom: function %02x. Can't use 64"
38117 CFC5                        62            .ascii	"bits lba"
38118 CFCD                        0A            .byte	$A
38119 CFCE                        00            .byte	0
38120                       0000CFCF            .5BD:
38121                       0000CFCF            .822:
38122 CFCF                        69            .ascii	"int13_cdrom: function %02x, unmapped dev"
38123 CFF7                        69            .ascii	"ice for ELDL=%02x"
38124 D008                        0A            .byte	$A
38125 D009                        00            .byte	0
38126                       0000D00A            .5BA:
38127                       0000D00A            .823:
38128 D00A                        69            .ascii	"int13_cdrom: function %02x, ELDL out of "
38129 D032                        72            .ascii	"range %02x"
38130 D03C                        0A            .byte	$A
38131 D03D                        00            .byte	0
38132                       0000D03E            .5B2:
38133                       0000D03E            .824:
38134 D03E                        69            .ascii	"int13_harddisk: function %02xh unsupport"
38135 D066                        65            .ascii	"ed, returns fail"
38136 D076                        0A            .byte	$A
38137 D077                        00            .byte	0
38138                       0000D078            .5AC:
38139                       0000D078            .825:
38140 D078                        69            .ascii	"int13_harddisk: function %02xh unimpleme"
38141 D0A0                        6E            .ascii	"nted, returns success"
38142 D0B5                        0A            .byte	$A
38143 D0B6                        00            .byte	0
38144                       0000D0B7            .597:
38145                       0000D0B7            .826:
38146 D0B7                        69            .ascii	"int13_harddisk: function %02x, error %02"
38147 D0DF                        78            .ascii	"x !"
38148 D0E2                        0A            .byte	$A
38149 D0E3                        00            .byte	0
38150                       0000D0E4            .58E:
38151                       0000D0E4            .827:
38152 D0E4                        69            .ascii	"int13_harddisk: function %02x. LBA out o"
38153 D10C                        66            .ascii	"f range"
38154 D113                        0A            .byte	$A
38155 D114                        00            .byte	0
38156                       0000D115            .58A:
38157                       0000D115            .828:
38158 D115                        69            .ascii	"int13_harddisk: function %02x. LBA out o"
38159 D13D                        66            .ascii	"f range"
38160 D144                        0A            .byte	$A
38161 D145                        00            .byte	0
38162                       0000D146            .57C:
38163                       0000D146            .829:
38164 D146                        66            .ascii	"format disk track called"
38165 D15E                        0A            .byte	$A
38166 D15F                        00            .byte	0
38167                       0000D160            .57A:
38168                       0000D160            .82A:
38169 D160                        69            .ascii	"int13_harddisk: function %02x, error %02"
38170 D188                        78            .ascii	"x !"
38171 D18B                        0A            .byte	$A
38172 D18C                        00            .byte	0
38173                       0000D18D            .56F:
38174                       0000D18D            .82B:
38175 D18D                        69            .ascii	"int13_harddisk: function %02x, parameter"
38176 D1B5                        73            .ascii	"s out of range %04x/%04x/%04x!"
38177 D1D3                        0A            .byte	$A
38178 D1D4                        00            .byte	0
38179                       0000D1D5            .56A:
38180                       0000D1D5            .82C:
38181 D1D5                        69            .ascii	"int13_harddisk: function %02x, parameter"
38182 D1FD                        20            .ascii	" out of range!"
38183 D20B                        0A            .byte	$A
38184 D20C                        00            .byte	0
38185                       0000D20D            .55A:
38186                       0000D20D            .82D:
38187 D20D                        69            .ascii	"int13_harddisk: function %02x, unmapped "
38188 D235                        64            .ascii	"device for ELDL=%02x"
38189 D249                        0A            .byte	$A
38190 D24A                        00            .byte	0
38191                       0000D24B            .557:
38192                       0000D24B            .82E:
38193 D24B                        69            .ascii	"int13_harddisk: function %02x, ELDL out "
38194 D273                        6F            .ascii	"of range %02x"
38195 D280                        0A            .byte	$A
38196 D281                        00            .byte	0
38197                       0000D282            .4F9:
38198                       0000D282            .82F:
38199 D282                        4B            .ascii	"KBD: int09h_handler(): scancode & asciic"
38200 D2AA                        6F            .ascii	"ode are zero?"
38201 D2B7                        0A            .byte	$A
38202 D2B8                        00            .byte	0
38203                       0000D2B9            .4DD:
38204                       0000D2B9            .830:
38205 D2B9                        4B            .ascii	"KBD: int09h_handler(): unknown scancode "
38206 D2E1                        72            .ascii	"read: 0x%02x!"
38207 D2EE                        0A            .byte	$A
38208 D2EF                        00            .byte	0
38209                       0000D2F0            .4A8:
38210                       0000D2F0            .831:
38211 D2F0                        4B            .ascii	"KBD: int09 handler: AL=0"
38212 D308                        0A            .byte	$A
38213 D309                        00            .byte	0
38214                       0000D30A            .4A5:
38215                       0000D30A            .832:
38216 D30A                        73            .ascii	"setkbdcomm"
38217 D314                        00            .byte	0
38218                       0000D315            .49E:
38219                       0000D315            .833:
38220 D315                        73            .ascii	"sendmouse"
38221 D31E                        00            .byte	0
38222                       0000D31F            .49B:
38223                       0000D31F            .834:
38224 D31F                        65            .ascii	"enabmouse"
38225 D328                        00            .byte	0
38226                       0000D329            .494:
38227                       0000D329            .835:
38228 D329                        65            .ascii	"enabmouse"
38229 D332                        00            .byte	0
38230                       0000D333            .491:
38231                       0000D333            .836:
38232 D333                        69            .ascii	"inhibmouse"
38233 D33D                        00            .byte	0
38234                       0000D33E            .48A:
38235                       0000D33E            .837:
38236 D33E                        69            .ascii	"inhibmouse"
38237 D348                        00            .byte	0
38238                       0000D349            .47D:
38239                       0000D349            .838:
38240 D349                        4B            .ascii	"KBD: unsupported int 16h function %02x"
38241 D36F                        0A            .byte	$A
38242 D370                        00            .byte	0
38243                       0000D371            .46C:
38244                       0000D371            .839:
38245 D371                        4B            .ascii	"KBD: int16h: out of keyboard input"
38246 D393                        0A            .byte	$A
38247 D394                        00            .byte	0
38248                       0000D395            .43E:
38249                       0000D395            .83A:
38250 D395                        4B            .ascii	"KBD: int16h: out of keyboard input"
38251 D3B7                        0A            .byte	$A
38252 D3B8                        00            .byte	0
38253                       0000D3B9            .42B:
38254                       0000D3B9            .83B:
38255 D3B9                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
38256 D3E1                        74            .ascii	"t yet supported!"
38257 D3F1                        0A            .byte	$A
38258 D3F2                        00            .byte	0
38259                       0000D3F3            .400:
38260                       0000D3F3            .83C:
38261 D3F3                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
38262 D41B                        74            .ascii	"t yet supported!"
38263 D42B                        0A            .byte	$A
38264 D42C                        00            .byte	0
38265                       0000D42D            .3F4:
38266                       0000D42D            .83D:
38267 D42D                        49            .ascii	"INT 15h C2 AL=6, BH=%02x"
38268 D445                        0A            .byte	$A
38269 D446                        00            .byte	0
38270                       0000D447            .3DE:
38271                       0000D447            .83E:
38272 D447                        4D            .ascii	"Mouse status returned %02x (should be ac"
38273 D46F                        6B            .ascii	"k)"
38274 D471                        0A            .byte	$A
38275 D472                        00            .byte	0
38276                       0000D473            .3CE:
38277                       0000D473            .83F:
38278 D473                        4D            .ascii	"Mouse status returned %02x (should be ac"
38279 D49B                        6B            .ascii	"k)"
38280 D49D                        0A            .byte	$A
38281 D49E                        00            .byte	0
38282                       0000D49F            .3CB:
38283                       0000D49F            .840:
38284 D49F                        4D            .ascii	"Mouse status returned %02x (should be ac"
38285 D4C7                        6B            .ascii	"k)"
38286 D4C9                        0A            .byte	$A
38287 D4CA                        00            .byte	0
38288                       0000D4CB            .3A9:
38289                       0000D4CB            .841:
38290 D4CB                        4D            .ascii	"Mouse reset returned %02x (should be ack"
38291 D4F3                        29            .ascii	")"
38292 D4F4                        0A            .byte	$A
38293 D4F5                        00            .byte	0
38294                       0000D4F6            .381:
38295                       0000D4F6            .842:
38296 D4F6                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
38297 D51E                        74            .ascii	"t yet supported!"
38298 D52E                        0A            .byte	$A
38299 D52F                        00            .byte	0
38300                       0000D530            .37F:
38301                       0000D530            .843:
38302 D530                        45            .ascii	"EISA BIOS not present"
38303 D545                        0A            .byte	$A
38304 D546                        00            .byte	0
38305                       0000D547            .37B:
38306                       0000D547            .844:
38307 D547                        2A            .ascii	"*** int 15h function AH=bf not yet suppo"
38308 D56F                        72            .ascii	"rted!"
38309 D574                        0A            .byte	$A
38310 D575                        00            .byte	0
38311                       0000D576            .365:
38312                       0000D576            .845:
38313 D576                        69            .ascii	"int15: Func 24h, subfunc %02xh, A20 gate"
38314 D59E                        20            .ascii	" control not supported"
38315 D5B4                        0A            .byte	$A
38316 D5B5                        00            .byte	0
38317                       0000D5B6            .2FF:
38318                       0000D5B6            .846:
38319 D5B6                        61            .ascii	"ata_is_ready returned %d"
38320 D5CE                        0A            .byte	$A
38321 D5CF                        00            .byte	0
38322                       0000D5D0            .2E9:
38323                       0000D5D0            .847:
38324 D5D0                        25            .ascii	"%dMB medium detected"
38325 D5E4                        0A            .byte	$A
38326 D5E5                        00            .byte	0
38327                       0000D5E6            .2E4:
38328                       0000D5E6            .848:
38329 D5E6                        55            .ascii	"Unsupported sector size %u"
38330 D600                        0A            .byte	$A
38331 D601                        00            .byte	0
38332                       0000D602            .2DF:
38333                       0000D602            .849:
38334 D602                        57            .ascii	"Waiting for device to detect medium... "
38335 D629                        00            .byte	0
38336                       0000D62A            .2D1:
38337                       0000D62A            .84A:
38338 D62A                        6E            .ascii	"not implemented for non-ATAPI device"
38339 D64E                        0A            .byte	$A
38340 D64F                        00            .byte	0
38341                       0000D650            .297:
38342                       0000D650            .84B:
38343 D650                        61            .ascii	"ata_cmd_packet: DATA_OUT not supported y"
38344 D678                        65            .ascii	"et"
38345 D67A                        0A            .byte	$A
38346 D67B                        00            .byte	0
38347                       0000D67C            .255:
38348                       0000D67C            .84C:
38349 D67C                        0A            .byte	$A
38350 D67D                        00            .byte	0
38351                       0000D67E            .250:
38352                       0000D67E            .84D:
38353 D67E                        6D            .ascii	"master"
38354 D684                        00            .byte	0
38355                       0000D685            .24F:
38356                       0000D685            .84E:
38357 D685                        20            .ascii	" slave"
38358 D68B                        00            .byte	0
38359                       0000D68C            .24E:
38360                       0000D68C            .84F:
38361 D68C                        61            .ascii	"ata%d %s: Unknown device"
38362 D6A4                        0A            .byte	$A
38363 D6A5                        00            .byte	0
38364                       0000D6A6            .24C:
38365                       0000D6A6            .850:
38366 D6A6                        20            .ascii	" ATAPI-%d Device"
38367 D6B6                        0A            .byte	$A
38368 D6B7                        00            .byte	0
38369                       0000D6B8            .24A:
38370                       0000D6B8            .851:
38371 D6B8                        20            .ascii	" ATAPI-%d CD-Rom/DVD-Rom"
38372 D6D0                        0A            .byte	$A
38373 D6D1                        00            .byte	0
38374                       0000D6D2            .246:
38375                       0000D6D2            .852:
38376 D6D2                        25            .ascii	"%c"
38377 D6D4                        00            .byte	0
38378                       0000D6D5            .23F:
38379                       0000D6D5            .853:
38380 D6D5                        6D            .ascii	"master"
38381 D6DB                        00            .byte	0
38382                       0000D6DC            .23E:
38383                       0000D6DC            .854:
38384 D6DC                        20            .ascii	" slave"
38385 D6E2                        00            .byte	0
38386                       0000D6E3            .23D:
38387                       0000D6E3            .855:
38388 D6E3                        61            .ascii	"ata%d %s: "
38389 D6ED                        00            .byte	0
38390                       0000D6EE            .23B:
38391                       0000D6EE            .856:
38392 D6EE                        20            .ascii	" ATA-%d Hard-Disk (%4u GBytes)"
38393 D70C                        0A            .byte	$A
38394 D70D                        00            .byte	0
38395                       0000D70E            .239:
38396                       0000D70E            .857:
38397 D70E                        20            .ascii	" ATA-%d Hard-Disk (%4u MBytes)"
38398 D72C                        0A            .byte	$A
38399 D72D                        00            .byte	0
38400                       0000D72E            .235:
38401                       0000D72E            .858:
38402 D72E                        25            .ascii	"%c"
38403 D730                        00            .byte	0
38404                       0000D731            .22E:
38405                       0000D731            .859:
38406 D731                        6D            .ascii	"master"
38407 D737                        00            .byte	0
38408                       0000D738            .22D:
38409                       0000D738            .85A:
38410 D738                        20            .ascii	" slave"
38411 D73E                        00            .byte	0
38412                       0000D73F            .22C:
38413                       0000D73F            .85B:
38414 D73F                        61            .ascii	"ata%d %s: "
38415 D749                        00            .byte	0
38416                       0000D74A            .1FB:
38417                       0000D74A            .85C:
38418 D74A                        61            .ascii	"ata-detect: Failed to detect ATAPI devic"
38419 D772                        65            .ascii	"e"
38420 D773                        0A            .byte	$A
38421 D774                        00            .byte	0
38422                       0000D775            .1F6:
38423                       0000D775            .85D:
38424 D775                        20            .ascii	" LCHS=%d/%d/%d"
38425 D783                        0A            .byte	$A
38426 D784                        00            .byte	0
38427                       0000D785            .1D6:
38428                       0000D785            .85E:
38429 D785                        72            .ascii	"r-echs"
38430 D78B                        00            .byte	0
38431                       0000D78C            .1D4:
38432                       0000D78C            .85F:
38433 D78C                        6C            .ascii	"large"
38434 D791                        00            .byte	0
38435                       0000D792            .1D2:
38436                       0000D792            .860:
38437 D792                        6C            .ascii	"lba"
38438 D795                        00            .byte	0
38439                       0000D796            .1D0:
38440                       0000D796            .861:
38441 D796                        6E            .ascii	"none"
38442 D79A                        00            .byte	0
38443                       0000D79B            .1C6:
38444                       0000D79B            .862:
38445 D79B                        61            .ascii	"ata%d-%d: PCHS=%u/%d/%d translation="
38446 D7BF                        00            .byte	0
38447                       0000D7C0            .1BF:
38448                       0000D7C0            .863:
38449 D7C0                        61            .ascii	"ata-detect: Failed to detect ATA device"
38450 D7E7                        0A            .byte	$A
38451 D7E8                        00            .byte	0
38452                       0000D7E9            .19E:
38453                       0000D7E9            .864:
38454 D7E9                        49            .ascii	"IDE time out"
38455 D7F5                        0A            .byte	$A
38456 D7F6                        00            .byte	0
38457                       0000D7F7            .162:
38458                       0000D7F7            .865:
38459 D7F7                        53            .ascii	"S3 resume jump to %x:%x"
38460 D80E                        0A            .byte	$A
38461 D80F                        00            .byte	0
38462                       0000D810            .15E:
38463                       0000D810            .866:
38464 D810                        53            .ascii	"S3 resume called %x 0x%lx"
38465 D829                        0A            .byte	$A
38466 D82A                        00            .byte	0
38467                       0000D82B            .158:
38468                       0000D82B            .867:
38469 D82B                        25            .ascii	"%s"
38470 D82D                        0A            .byte	$A
38471 D82E                        00            .byte	0
38472                       0000D82F            .157:
38473                       0000D82F            .868:
38474 D82F                        49            .ascii	"INT18: BOOT FAILURE"
38475 D842                        0A            .byte	$A
38476 D843                        00            .byte	0
38477                       0000D844            .156:
38478                       0000D844            .869:
38479 D844                        4E            .ascii	"NMI Handler called"
38480 D856                        0A            .byte	$A
38481 D857                        00            .byte	0
38482                       0000D858            .155:
38483                       0000D858            .86A:
38484 D858                        43            .ascii	"CDROM boot failure code : %04x"
38485 D876                        0A            .byte	$A
38486 D877                        00            .byte	0
38487                       0000D878            .154:
38488                       0000D878            .86B:
38489 D878                        0A            .byte	$A,$A
38490 D87A                        00            .byte	0
38491                       0000D87B            .153:
38492                       0000D87B            .86C:
38493 D87B                        3A            .ascii	": could not read the boot disk"
38494 D899                        00            .byte	0
38495                       0000D89A            .151:
38496                       0000D89A            .86D:
38497 D89A                        3A            .ascii	": not a bootable disk"
38498 D8AF                        00            .byte	0
38499                       0000D8B0            .14C:
38500                       0000D8B0            .86E:
38501 D8B0                        42            .ascii	"Boot failed"
38502 D8BB                        00            .byte	0
38503                       0000D8BC            .14B:
38504                       0000D8BC            .86F:
38505 D8BC                        42            .ascii	"Bad drive type"
38506 D8CA                        0A            .byte	$A
38507 D8CB                        00            .byte	0
38508                       0000D8CC            .147:
38509                       0000D8CC            .870:
38510 D8CC                        2E            .ascii	"..."
38511 D8CF                        0A            .byte	$A
38512 D8D0                        00            .byte	0
38513                       0000D8D1            .146:
38514                       0000D8D1            .871:
38515 D8D1                        20            .ascii	" [%S]"
38516 D8D6                        00            .byte	0
38517                       0000D8D7            .142:
38518                       0000D8D7            .872:
38519 D8D7                        42            .ascii	"Booting from %s"
38520 D8E6                        00            .byte	0
38521                       0000D8E7            .141:
38522                       0000D8E7            .873:
38523 D8E7                        42            .ascii	"Bad drive type"
38524 D8F5                        0A            .byte	$A
38525 D8F6                        00            .byte	0
38526                       0000D8F7            .13B:
38527                       0000D8F7            .874:
38528 D8F7                        0A            .byte	$A
38529 D8F8                        00            .byte	0
38530                       0000D8F9            .12F:
38531                       0000D8F9            .875:
38532 D8F9                        0A            .byte	$A
38533 D8FA                        00            .byte	0
38534                       0000D8FB            .12E:
38535                       0000D8FB            .876:
38536 D8FB                        20            .ascii	" [%S]"
38537 D900                        00            .byte	0
38538                       0000D901            .12B:
38539                       0000D901            .877:
38540 D901                        25            .ascii	"%s"
38541 D903                        00            .byte	0
38542                       0000D904            .129:
38543                       0000D904            .878:
38544 D904                        25            .ascii	"%s"
38545 D906                        0A            .byte	$A
38546 D907                        00            .byte	0
38547                       0000D908            .122:
38548                       0000D908            .879:
38549 D908                        25            .ascii	"%d. "
38550 D90C                        00            .byte	0
38551                       0000D90D            .11D:
38552                       0000D90D            .87A:
38553 D90D                        53            .ascii	"Select boot device:"
38554 D920                        0A            .byte	$A,$A
38555 D922                        00            .byte	0
38556                       0000D923            .114:
38557                       0000D923            .87B:
38558 D923                        50            .ascii	"Press F12 for boot menu."
38559 D93B                        0A            .byte	$A,$A
38560 D93D                        00            .byte	0
38561                       0000D93E            .106:
38562                       0000D93E            .87C:
38563 D93E                        61            .ascii	"apmbios pcibios pnpbios eltorito "
38564 D95F                        0A            .byte	$A,$A
38565 D961                        00            .byte	0
38566                       0000D962            .105:
38567                       0000D962            .87D:
38568 D962                        30            .ascii	"08/01/21"
38569 D96A                        00            .byte	0
38570                       0000D96B            .104:
38571                       0000D96B            .87E:
38572 D96B                        42            .ascii	"Bochs 2.7.svn BIOS - build: %s"
38573 D989                        0A            .byte	$A
38574 D98A                        25            .ascii	"%s"
38575 D98C                        0A            .byte	$A
38576 D98D                        4F            .ascii	"Options: "
38577 D996                        00            .byte	0
38578                       0000D997            .103:
38579                       0000D997            .87F:
38580 D997                        52            .ascii	"Returned from s3_resume."
38581 D9AF                        0A            .byte	$A
38582 D9B0                        00            .byte	0
38583                       0000D9B1            .102:
38584                       0000D9B1            .880:
38585 D9B1                        55            .ascii	"Unimplemented shutdown status: %02x"
38586 D9D4                        0A            .byte	$A
38587 D9D5                        00            .byte	0
38588                       0000D9D6            .101:
38589                       0000D9D6            .881:
38590 D9D6                        4B            .ascii	"Keyboard error:%u"
38591 D9E7                        0A            .byte	$A
38592 D9E8                        00            .byte	0
38593                       0000D9E9            .7C:
38594                       0000D9E9            .882:
38595 D9E9                        62            .ascii	"bios_printf: unknown format"
38596 DA04                        0A            .byte	$A
38597 DA05                        00            .byte	0
38598                       0000DA06            .38:
38599                       0000DA06            .883:
38600 DA06                        46            .ascii	"FATAL: "
38601 DA0D                        00            .byte	0
38602 DA0E                                      .bss
38603                                           
38604                                           ! 0 errors detected

Symbols:
..FFD8                       0 FFFC A   
..FFD9                       0 FFE0 A   
..FFDA                       0 FFDC A   
..FFDB                       0 FFDC A   
..FFDC                       0 FFF6 A   
..FFDD                       0 FFC6 A   
..FFDE                       0 FFC6 A   
..FFDF                       0 FFC6 A   
..FFE0                       0 FFC6 A   
..FFE1                       0 FFC6 A   
..FFE2                       0 FFC6 A   
..FFE3                       0 FFFC A   
..FFE4                       0 FFFC A   
..FFE5                       0 FFFC A   
..FFE6                       0 FFE0 A   
..FFE7                       0 FFE0 A   
..FFE8                       0 FFE0 A   
..FFE9                       0 FFE0 A   
..FFEA                       0 FFE0 A   
..FFEB                       0 FFE0 A   
..FFEC                       0 FFDA A   
..FFED                       0 FFDA A   
..FFEE                       0 FFDA A   
..FFEF                       0 FFDA A   
..FFF0                       0 FFDA A   
..FFF1                       0 FFDA A   
..FFF2                       0 FFF8 A   
..FFF3                       0 FFF4 A   
..FFF4                       0 FFF0 A   
..FFF5                       0 FFF0 A   
..FFF6                       0 FFF0 A   
..FFF7                       0 FFEA A   
..FFF8                       0 FFF6 A   
..FFF9                       0 F7E0 A   
..FFFA                       0 FFD4 A   
..FFFB                       0 FDB6 A   
..FFFC                       0 FDB6 A   
..FFFD                       0 FDD8 A   
..FFFE                       0 FDD8 A   
..FFFF                       0 FFC4 A   
.1                           0 016C A   
.10                          0 0712 A   
.100                         0 118C A   
.101                         0 D9D6 A   
.102                         0 D9B1 A   
.103                         0 D997 A   
.104                         0 D96B A   
.105                         0 D962 A   
.106                         0 D93E A   
.107                         0 120D A   
.108                         0 1217 A   
.109                         0 1221 A   
.10A                         0 122B A   
.10B                         0 1235 A   
.10C                         0 1399 A   
.10D                         0 1393 A   
.10E                         0 13DA A   
.10F                         0 13D3 A   
.11                          0 06FC A   
.110                         0 13D0 A   
.111                         0 13DA A   
.112                         0 13ED A   
.113                         0 13E9 A   
.114                         0 D923 A   
.115                         0 15B3 A   
.116                         0 1412 A   
.117                         0 15B3 A   
.118                         0 1421 A   
.119                         0 142D A   
.11A                         0 1426 A   
.11B                         0 1423 A   
.11C                         0 142D A   
.11D                         0 D90D A   
.11E                         0 154C A   
.11F                         0 1539 A   
.12                          0 0740 A   
.120                         0 1540 A   
.121                         0 1454 A   
.122                         0 D908 A   
.123                         0 1539 A   
.125                         0 151D A   
.126                         0 148E A   
.127                         0 148E A   
.128                         0 148E A   
.129                         0 D904 A   
.12A                         0 14B1 A   
.12B                         0 D901 A   
.12C                         0 150B A   
.12D                         0 14DA A   
.12E                         0 D8FB A   
.12F                         0 D8F9 A   
.13                          0 072C A   
.130                         0 154C A   
.131                         0 15A5 A   
.132                         0 159E A   
.133                         0 1555 A   
.134                         0 1571 A   
.135                         0 1569 A   
.136                         0 1562 A   
.137                         0 159E A   
.138                         0 159E A   
.139                         0 157B A   
.13A                         0 15A5 A   
.13B                         0 D8F7 A   
.13C                         0 15D9 A   
.13D                         0 15D3 A   
.13E                         0 15F6 A   
.13F                         0 15E8 A   
.14                          0 0721 A   
.140                         0 15E0 A   
.141                         0 D8E7 A   
.142                         0 D8D7 A   
.143                         0 166F A   
.144                         0 1638 A   
.145                         0 161E A   
.146                         0 D8D1 A   
.147                         0 D8CC A   
.148                         0 16A0 A   
.149                         0 1693 A   
.14A                         0 168B A   
.14B                         0 D8BC A   
.14C                         0 D8B0 A   
.14D                         0 16D8 A   
.14E                         0 16B5 A   
.14F                         0 16CB A   
.15                          0 0714 A   
.150                         0 16BC A   
.151                         0 D89A A   
.152                         0 16D8 A   
.153                         0 D87B A   
.154                         0 D878 A   
.155                         0 D858 A   
.156                         0 D844 A   
.157                         0 D82F A   
.158                         0 D82B A   
.159                         0 1762 A   
.15A                         0 174E A   
.15B                         0 1774 A   
.15C                         0 1781 A   
.15D                         0 1783 A   
.15E                         0 D810 A   
.15F                         0 17F7 A   
.16                          0 072C A   
.160                         0 17F1 A   
.161                         0 17E6 A   
.162                         0 D7F7 A   
.163                         0 18B8 A   
.164                         0 18AA A   
.165                         0 18B1 A   
.166                         0 1866 A   
.167                         0 18B8 A   
.168                         0 19EA A   
.169                         0 19DA A   
.16A                         0 19E1 A   
.16B                         0 18C0 A   
.16C                         0 19EA A   
.16D                         0 1A19 A   
.16E                         0 1A0B A   
.16F                         0 1A12 A   
.17                          0 0740 A   
.170                         0 19F1 A   
.171                         0 1A19 A   
.172                         0 1B7A A   
.173                         0 1B77 A   
.174                         0 1A5A A   
.175                         0 1A89 A   
.176                         0 1A7E A   
.177                         0 1B1D A   
.178                         0 1AA5 A   
.179                         0 1A90 A   
.17A                         0 1A9D A   
.17B                         0 1A99 A   
.17C                         0 1A9F A   
.17D                         0 1B1D A   
.17E                         0 1AC9 A   
.17F                         0 1AAC A   
.18                          0 0733 A   
.180                         0 1AC2 A   
.181                         0 1ABE A   
.182                         0 1AB5 A   
.183                         0 1AC4 A   
.184                         0 1B1D A   
.185                         0 1AED A   
.186                         0 1AD0 A   
.187                         0 1AE6 A   
.188                         0 1AE2 A   
.189                         0 1AD9 A   
.18A                         0 1AE8 A   
.18B                         0 1B1D A   
.18C                         0 1B11 A   
.18D                         0 1AF4 A   
.18E                         0 1B0A A   
.18F                         0 1B06 A   
.19                          0 07AD A   
.190                         0 1AFD A   
.191                         0 1B0C A   
.192                         0 1B1D A   
.193                         0 1B1D A   
.194                         0 1B18 A   
.195                         0 1B2A A   
.196                         0 1B24 A   
.197                         0 1B38 A   
.198                         0 1B32 A   
.199                         0 1B48 A   
.19A                         0 1B41 A   
.19B                         0 1B77 A   
.19C                         0 1B75 A   
.19D                         0 1B4F A   
.19E                         0 D7E9 A   
.19F                         0 2823 A   
.1A                          0 0794 A   
.1A0                         0 2813 A   
.1A1                         0 281A A   
.1A2                         0 1C0B A   
.1A3                         0 1C6A A   
.1A4                         0 1C66 A   
.1A5                         0 1C6C A   
.1A6                         0 1E31 A   
.1A7                         0 1D1B A   
.1A8                         0 1D11 A   
.1A9                         0 1D44 A   
.1AA                         0 1D40 A   
.1AB                         0 1D46 A   
.1AC                         0 1E31 A   
.1AD                         0 1D8C A   
.1AE                         0 1D82 A   
.1AF                         0 1DE3 A   
.1B                          0 07DB A   
.1B0                         0 1DCF A   
.1B1                         0 1DC7 A   
.1B2                         0 1E31 A   
.1B3                         0 1E0F A   
.1B4                         0 1DFB A   
.1B5                         0 1DF3 A   
.1B6                         0 1DEB A   
.1B7                         0 1E31 A   
.1B8                         0 1E31 A   
.1B9                         0 1E1F A   
.1BA                         0 1E17 A   
.1BB                         0 2319 A   
.1BC                         0 1E4D A   
.1BD                         0 1EBB A   
.1BE                         0 1EAD A   
.1BF                         0 D7C0 A   
.1C                          0 07C7 A   
.1C0                         0 1EE3 A   
.1C1                         0 1EDF A   
.1C2                         0 1EE5 A   
.1C3                         0 1F5C A   
.1C4                         0 1F32 A   
.1C5                         0 1F7C A   
.1C6                         0 D79B A   
.1C7                         0 20A7 A   
.1C8                         0 2096 A   
.1C9                         0 209F A   
.1CA                         0 2088 A   
.1CB                         0 20A7 A   
.1CC                         0 211D A   
.1CE                         0 210D A   
.1CF                         0 20CB A   
.1D                          0 07BC A   
.1D0                         0 D796 A   
.1D1                         0 20DB A   
.1D2                         0 D792 A   
.1D3                         0 20EB A   
.1D4                         0 D78C A   
.1D5                         0 20FB A   
.1D6                         0 D785 A   
.1D7                         0 229B A   
.1D9                         0 2285 A   
.1DA                         0 2124 A   
.1DB                         0 2127 A   
.1DC                         0 217E A   
.1DD                         0 2175 A   
.1DE                         0 21BB A   
.1DF                         0 2190 A   
.1E                          0 07AF A   
.1E0                         0 2187 A   
.1E1                         0 21BB A   
.1E2                         0 21A2 A   
.1E3                         0 2199 A   
.1E4                         0 21BB A   
.1E5                         0 21B4 A   
.1E6                         0 21AB A   
.1E7                         0 21BB A   
.1E8                         0 21DC A   
.1E9                         0 2257 A   
.1EA                         0 21E5 A   
.1EB                         0 2210 A   
.1EC                         0 2209 A   
.1ED                         0 2257 A   
.1EE                         0 2281 A   
.1EF                         0 2278 A   
.1F                          0 07C7 A   
.1F0                         0 2259 A   
.1F1                         0 2278 A   
.1F2                         0 2276 A   
.1F3                         0 2281 A   
.1F4                         0 22AB A   
.1F5                         0 22A4 A   
.1F6                         0 D775 A   
.1F7                         0 2441 A   
.1F8                         0 2322 A   
.1F9                         0 2390 A   
.1FA                         0 2382 A   
.1FB                         0 D74A A   
.1FC                         0 23B4 A   
.1FD                         0 23B0 A   
.1FE                         0 23B6 A   
.1FF                         0 23CC A   
.2                           0 05A7 A   
.20                          0 07DB A   
.200                         0 23C8 A   
.201                         0 23CE A   
.202                         0 2669 A   
.204                         0 265D A   
.205                         0 244A A   
.206                         0 2486 A   
.208                         0 247A A   
.209                         0 2450 A   
.20A                         0 245E A   
.20B                         0 246C A   
.20C                         0 24E6 A   
.20D                         0 253D A   
.20E                         0 252C A   
.20F                         0 2535 A   
.21                          0 07CE A   
.210                         0 2513 A   
.211                         0 252C A   
.212                         0 252A A   
.213                         0 253D A   
.214                         0 25B6 A   
.215                         0 25A5 A   
.216                         0 25AE A   
.217                         0 2545 A   
.218                         0 25B6 A   
.219                         0 2611 A   
.21A                         0 2600 A   
.21B                         0 2609 A   
.21C                         0 25CC A   
.21D                         0 25FE A   
.21E                         0 25E4 A   
.21F                         0 2600 A   
.22                          0 084E A   
.220                         0 2611 A   
.221                         0 2659 A   
.222                         0 2619 A   
.223                         0 2659 A   
.224                         0 2648 A   
.225                         0 2651 A   
.226                         0 262F A   
.227                         0 2659 A   
.228                         0 280D A   
.22A                         0 27FD A   
.22B                         0 266F A   
.22C                         0 D73F A   
.22D                         0 D738 A   
.22E                         0 D731 A   
.22F                         0 267C A   
.23                          0 083B A   
.230                         0 2677 A   
.231                         0 267F A   
.232                         0 26D4 A   
.233                         0 26B2 A   
.234                         0 269D A   
.235                         0 D72E A   
.236                         0 26D4 A   
.237                         0 26FD A   
.238                         0 26E2 A   
.239                         0 D70E A   
.23A                         0 2729 A   
.23B                         0 D6EE A   
.23C                         0 272C A   
.23D                         0 D6E3 A   
.23E                         0 D6DC A   
.23F                         0 D6D5 A   
.24                          0 0825 A   
.240                         0 2739 A   
.241                         0 2734 A   
.242                         0 273C A   
.243                         0 2791 A   
.244                         0 276F A   
.245                         0 275A A   
.246                         0 D6D2 A   
.247                         0 2791 A   
.248                         0 27BC A   
.249                         0 27A5 A   
.24A                         0 D6B8 A   
.24B                         0 27D1 A   
.24C                         0 D6A6 A   
.24D                         0 27D3 A   
.24E                         0 D68C A   
.24F                         0 D685 A   
.25                          0 084E A   
.250                         0 D67E A   
.251                         0 27E0 A   
.252                         0 27DB A   
.253                         0 27E3 A   
.254                         0 2823 A   
.255                         0 D67C A   
.256                         0 2969 A   
.257                         0 28E5 A   
.258                         0 28F0 A   
.259                         0 28EC A   
.25A                         0 28F2 A   
.25B                         0 2958 A   
.25C                         0 292D A   
.25D                         0 2926 A   
.25E                         0 2947 A   
.25F                         0 2934 A   
.26                          0 08F0 A   
.260                         0 2958 A   
.261                         0 29E8 A   
.262                         0 29E0 A   
.263                         0 29D8 A   
.264                         0 29F9 A   
.265                         0 2A0C A   
.266                         0 2A00 A   
.267                         0 2A14 A   
.268                         0 2A48 A   
.269                         0 2A41 A   
.26A                         0 2B57 A   
.26B                         0 2A62 A   
.26C                         0 2B29 A   
.26D                         0 2AA3 A   
.26E                         0 2A84 A   
.26F                         0 2A79 A   
.27                          0 08E4 A   
.270                         0 2A6D A   
.271                         0 2A6F A   
.273                         0 2BB5 A   
.274                         0 2BB1 A   
.275                         0 2BB7 A   
.276                         0 2C0C A   
.277                         0 2C03 A   
.278                         0 2C1C A   
.279                         0 2C1C A   
.27A                         0 2C15 A   
.27B                         0 2D33 A   
.27C                         0 2D30 A   
.27D                         0 2C1D A   
.27E                         0 2C5A A   
.27F                         0 2C24 A   
.28                          0 0876 A   
.280                         0 2C90 A   
.281                         0 2CBE A   
.282                         0 2CAD A   
.283                         0 2D03 A   
.284                         0 2CD4 A   
.285                         0 2CEF A   
.286                         0 2CDB A   
.287                         0 2CEB A   
.288                         0 2CE4 A   
.289                         0 2D01 A   
.28A                         0 2CFF A   
.28B                         0 2CF8 A   
.28C                         0 2D30 A   
.28D                         0 2D1E A   
.28E                         0 2D0A A   
.28F                         0 2D1A A   
.29                          0 08B8 A   
.290                         0 2D13 A   
.291                         0 2D30 A   
.292                         0 2D2E A   
.293                         0 2D27 A   
.294                         0 2D33 A   
.295                         0 2D84 A   
.296                         0 2D6F A   
.297                         0 D650 A   
.298                         0 2D94 A   
.299                         0 2D8D A   
.29A                         0 2DEA A   
.29B                         0 2DE5 A   
.29C                         0 2DF6 A   
.29D                         0 2DF1 A   
.29E                         0 2E37 A   
.29F                         0 2E30 A   
.2A                          0 0892 A   
.2A0                         0 2EA2 A   
.2A1                         0 2E9E A   
.2A2                         0 2EA4 A   
.2A3                         0 2EF7 A   
.2A4                         0 2EEE A   
.2A5                         0 2F07 A   
.2A6                         0 2F07 A   
.2A7                         0 2F00 A   
.2A8                         0 2F5E A   
.2A9                         0 2F3B A   
.2AA                         0 31CD A   
.2AB                         0 31CA A   
.2AC                         0 31C7 A   
.2AD                         0 2F67 A   
.2AE                         0 2F90 A   
.2AF                         0 2F6E A   
.2B                          0 08D8 A   
.2B0                         0 2FA1 A   
.2B1                         0 2FE2 A   
.2B2                         0 2FDF A   
.2B3                         0 2FD6 A   
.2B4                         0 2FF2 A   
.2B5                         0 2FEB A   
.2B6                         0 3045 A   
.2B7                         0 302F A   
.2B8                         0 3059 A   
.2B9                         0 3086 A   
.2BA                         0 3066 A   
.2BB                         0 30A7 A   
.2BC                         0 30C1 A   
.2BD                         0 30BC A   
.2BE                         0 30CF A   
.2BF                         0 30CA A   
.2C                          0 08D8 A   
.2C0                         0 30DD A   
.2C1                         0 30D8 A   
.2C2                         0 3104 A   
.2C3                         0 30E6 A   
.2C4                         0 3104 A   
.2C5                         0 30FD A   
.2C6                         0 30F4 A   
.2C7                         0 312B A   
.2C8                         0 310B A   
.2C9                         0 3143 A   
.2CA                         0 31CA A   
.2CB                         0 31DD A   
.2CC                         0 31D6 A   
.2CD                         0 324F A   
.2CE                         0 3248 A   
.2CF                         0 32B6 A   
.2D                          0 08C6 A   
.2D0                         0 32A1 A   
.2D1                         0 D62A A   
.2D2                         0 33A8 A   
.2D3                         0 3398 A   
.2D4                         0 32ED A   
.2D5                         0 3322 A   
.2D6                         0 331C A   
.2D7                         0 337C A   
.2D8                         0 333B A   
.2D9                         0 3349 A   
.2DA                         0 3342 A   
.2DB                         0 337C A   
.2DC                         0 335E A   
.2DD                         0 3357 A   
.2DE                         0 3350 A   
.2DF                         0 D602 A   
.2E                          0 08F0 A   
.2E0                         0 33A8 A   
.2E1                         0 3412 A   
.2E2                         0 33F7 A   
.2E3                         0 33DF A   
.2E4                         0 D5E6 A   
.2E5                         0 3472 A   
.2E6                         0 3460 A   
.2E7                         0 34B8 A   
.2E8                         0 3494 A   
.2E9                         0 D5D0 A   
.2EA                         0 34F4 A   
.2EB                         0 34EE A   
.2EC                         0 3518 A   
.2ED                         0 3512 A   
.2EE                         0 353C A   
.2EF                         0 3536 A   
.2F                          0 093A A   
.2F0                         0 359A A   
.2F1                         0 35A0 A   
.2F2                         0 35F2 A   
.2F3                         0 35E1 A   
.2F4                         0 35EA A   
.2F5                         0 35CF A   
.2F6                         0 35E1 A   
.2F7                         0 35DF A   
.2F8                         0 35F2 A   
.2F9                         0 3601 A   
.2FA                         0 35FA A   
.2FB                         0 3633 A   
.2FC                         0 3621 A   
.2FD                         0 3615 A   
.2FE                         0 3617 A   
.2FF                         0 D5B6 A   
.3                           0 059C A   
.30                          0 092B A   
.300                         0 36AA A   
.301                         0 36A3 A   
.302                         0 36B9 A   
.303                         0 36B2 A   
.304                         0 3705 A   
.305                         0 36F3 A   
.306                         0 36FC A   
.307                         0 36C1 A   
.308                         0 36F3 A   
.309                         0 36EC A   
.30A                         0 3705 A   
.30B                         0 3753 A   
.30C                         0 3741 A   
.30D                         0 374A A   
.30E                         0 370D A   
.30F                         0 3741 A   
.31                          0 0932 A   
.310                         0 373A A   
.311                         0 3753 A   
.312                         0 37E2 A   
.313                         0 37DB A   
.314                         0 37F1 A   
.315                         0 37EA A   
.316                         0 3800 A   
.317                         0 37F9 A   
.318                         0 380F A   
.319                         0 3808 A   
.31A                         0 381E A   
.31B                         0 3817 A   
.31C                         0 382D A   
.31D                         0 3826 A   
.31E                         0 384E A   
.31F                         0 3847 A   
.32                          0 091A A   
.320                         0 3862 A   
.321                         0 385D A   
.322                         0 3856 A   
.323                         0 3862 A   
.324                         0 388F A   
.325                         0 3888 A   
.326                         0 397C A   
.327                         0 396D A   
.328                         0 3A33 A   
.32A                         0 3A1D A   
.32B                         0 3982 A   
.32C                         0 3997 A   
.32D                         0 39AC A   
.32E                         0 39C0 A   
.32F                         0 3A6D A   
.33                          0 092B A   
.330                         0 3A3A A   
.331                         0 3A64 A   
.332                         0 3A41 A   
.333                         0 3A6D A   
.334                         0 3A79 A   
.335                         0 3A74 A   
.336                         0 3CB8 A   
.337                         0 3ACB A   
.338                         0 3AC2 A   
.339                         0 3CB6 A   
.33B                         0 3C9E A   
.33C                         0 3AD1 A   
.33D                         0 3B16 A   
.33E                         0 3AF8 A   
.33F                         0 3B4D A   
.34                          0 0929 A   
.340                         0 3B8B A   
.341                         0 3BC7 A   
.342                         0 3BAE A   
.343                         0 3B93 A   
.344                         0 3BAE A   
.345                         0 3BA1 A   
.346                         0 3BC7 A   
.347                         0 3BC0 A   
.348                         0 3BEE A   
.349                         0 3BCE A   
.34A                         0 3BF3 A   
.34B                         0 3BFE A   
.34C                         0 3C3A A   
.34D                         0 3C21 A   
.34E                         0 3C06 A   
.34F                         0 3C21 A   
.35                          0 093A A   
.350                         0 3C14 A   
.351                         0 3C3A A   
.352                         0 3C33 A   
.353                         0 3C5D A   
.354                         0 3C41 A   
.355                         0 3C62 A   
.356                         0 3C6C A   
.357                         0 3C94 A   
.358                         0 3CC0 A   
.359                         0 41AA A   
.35B                         0 4160 A   
.35C                         0 3CD8 A   
.35D                         0 3D64 A   
.35F                         0 3D52 A   
.36                          0 0987 A   
.360                         0 3CDE A   
.361                         0 3CDE A   
.362                         0 3CF9 A   
.363                         0 3D1A A   
.364                         0 3D2F A   
.365                         0 D576 A   
.366                         0 3D67 A   
.367                         0 3D77 A   
.368                         0 3D82 A   
.369                         0 3D92 A   
.36A                         0 3E21 A   
.36B                         0 3DA4 A   
.36C                         0 3E12 A   
.36D                         0 3DAF A   
.36E                         0 3E1F A   
.36F                         0 3E69 A   
.37                          0 096C A   
.370                         0 3E55 A   
.371                         0 3E28 A   
.372                         0 3E69 A   
.373                         0 3E6C A   
.374                         0 3EA7 A   
.375                         0 3EA0 A   
.376                         0 3FF4 A   
.377                         0 401A A   
.378                         0 4014 A   
.379                         0 4025 A   
.37A                         0 40D3 A   
.37B                         0 D547 A   
.37C                         0 40F1 A   
.37D                         0 410D A   
.37E                         0 411E A   
.37F                         0 D530 A   
.38                          0 DA06 A   
.380                         0 413B A   
.381                         0 D4F6 A   
.382                         0 482E A   
.384                         0 4826 A   
.385                         0 41C2 A   
.386                         0 47FF A   
.388                         0 47DA A   
.389                         0 41C8 A   
.38A                         0 42C5 A   
.38C                         0 42B7 A   
.38D                         0 41CE A   
.38E                         0 420F A   
.38F                         0 41E4 A   
.39                          0 0C4A A   
.390                         0 420F A   
.391                         0 41FE A   
.392                         0 41F7 A   
.393                         0 4224 A   
.394                         0 424E A   
.395                         0 423D A   
.396                         0 4292 A   
.397                         0 4264 A   
.398                         0 4292 A   
.399                         0 427E A   
.39A                         0 4277 A   
.39B                         0 42A4 A   
.39C                         0 42C8 A   
.39D                         0 42C8 A   
.39E                         0 4341 A   
.39F                         0 42D1 A   
.3A                          0 0C3C A   
.3A0                         0 42F0 A   
.3A1                         0 42DF A   
.3A2                         0 42D8 A   
.3A3                         0 43E0 A   
.3A4                         0 4359 A   
.3A5                         0 4378 A   
.3A6                         0 436C A   
.3A7                         0 4393 A   
.3A8                         0 437F A   
.3A9                         0 D4CB A   
.3AA                         0 43E0 A   
.3AB                         0 439A A   
.3AC                         0 43E0 A   
.3AD                         0 43AD A   
.3AE                         0 43E0 A   
.3AF                         0 43C0 A   
.3B                          0 098A A   
.3B0                         0 43F2 A   
.3B1                         0 4452 A   
.3B3                         0 442F A   
.3B4                         0 43F7 A   
.3B5                         0 43FE A   
.3B6                         0 4405 A   
.3B7                         0 440C A   
.3B8                         0 4413 A   
.3B9                         0 441A A   
.3BA                         0 4421 A   
.3BB                         0 4428 A   
.3BC                         0 4450 A   
.3BD                         0 4442 A   
.3BE                         0 44B0 A   
.3BF                         0 4459 A   
.3C                          0 099F A   
.3C0                         0 44A1 A   
.3C1                         0 446C A   
.3C2                         0 44AE A   
.3C3                         0 44BD A   
.3C4                         0 44C0 A   
.3C5                         0 455C A   
.3C6                         0 44CF A   
.3C7                         0 454D A   
.3C8                         0 44E2 A   
.3C9                         0 4509 A   
.3CA                         0 44F5 A   
.3CB                         0 D49F A   
.3CC                         0 453E A   
.3CD                         0 452A A   
.3CE                         0 D473 A   
.3CF                         0 455A A   
.3D                          0 0991 A   
.3D0                         0 4569 A   
.3D1                         0 4577 A   
.3D2                         0 45BA A   
.3D3                         0 458D A   
.3D4                         0 45C7 A   
.3D5                         0 45CA A   
.3D6                         0 473E A   
.3D8                         0 472A A   
.3D9                         0 45D0 A   
.3DA                         0 4680 A   
.3DB                         0 45EB A   
.3DC                         0 4612 A   
.3DD                         0 45FE A   
.3DE                         0 D447 A   
.3DF                         0 4680 A   
.3E                          0 0C35 A   
.3E0                         0 4619 A   
.3E1                         0 4680 A   
.3E2                         0 462C A   
.3E3                         0 4680 A   
.3E4                         0 463F A   
.3E5                         0 4680 A   
.3E6                         0 4652 A   
.3E7                         0 469D A   
.3E8                         0 469D A   
.3E9                         0 46B8 A   
.3EA                         0 46AA A   
.3EB                         0 46C4 A   
.3EC                         0 46E4 A   
.3ED                         0 46CB A   
.3EE                         0 46DF A   
.3EF                         0 46E1 A   
.3F                          0 0C26 A   
.3F0                         0 46FA A   
.3F1                         0 46EB A   
.3F2                         0 4707 A   
.3F3                         0 4714 A   
.3F4                         0 D42D A   
.3F5                         0 4741 A   
.3F6                         0 47A1 A   
.3F7                         0 478B A   
.3F8                         0 4784 A   
.3F9                         0 479F A   
.3FA                         0 4794 A   
.3FB                         0 47A9 A   
.3FC                         0 47CB A   
.3FD                         0 47FD A   
.3FE                         0 47ED A   
.3FF                         0 4801 A   
.4                           0 0587 A   
.40                          0 09A8 A   
.400                         0 D3F3 A   
.401                         0 4D81 A   
.403                         0 4D73 A   
.404                         0 48FC A   
.405                         0 4942 A   
.406                         0 4D4C A   
.408                         0 4D40 A   
.409                         0 4948 A   
.40A                         0 4CDC A   
.40B                         0 4963 A   
.40C                         0 49B1 A   
.40D                         0 49A5 A   
.40E                         0 4A46 A   
.40F                         0 49F6 A   
.41                          0 09D7 A   
.410                         0 4CBB A   
.412                         0 4C96 A   
.413                         0 4A75 A   
.414                         0 4AA7 A   
.415                         0 4ADA A   
.416                         0 4B19 A   
.417                         0 4B0C A   
.418                         0 4B24 A   
.419                         0 4B27 A   
.41A                         0 4B58 A   
.41B                         0 4BC4 A   
.41C                         0 4C06 A   
.41D                         0 4C4D A   
.41E                         0 4C40 A   
.41F                         0 4C35 A   
.42                          0 09B6 A   
.420                         0 4C57 A   
.421                         0 4C59 A   
.422                         0 4C8C A   
.423                         0 4CB9 A   
.424                         0 4CA9 A   
.425                         0 4CE2 A   
.426                         0 4CE5 A   
.427                         0 4D13 A   
.428                         0 4D0D A   
.429                         0 4D39 A   
.42A                         0 4D4E A   
.42B                         0 D3B9 A   
.42C                         0 4E48 A   
.42D                         0 4DB3 A   
.42E                         0 4DE1 A   
.42F                         0 4DD2 A   
.43                          0 09AF A   
.430                         0 4DC4 A   
.431                         0 4DE1 A   
.432                         0 4E47 A   
.433                         0 4DEE A   
.434                         0 4E38 A   
.435                         0 4E29 A   
.436                         0 4E1B A   
.437                         0 4E38 A   
.438                         0 5131 A   
.43A                         0 50EA A   
.43B                         0 4E4E A   
.43C                         0 4E72 A   
.43D                         0 4E64 A   
.43E                         0 D395 A   
.43F                         0 4E87 A   
.44                          0 0C24 A   
.440                         0 4E80 A   
.441                         0 4E79 A   
.442                         0 4E93 A   
.443                         0 4E93 A   
.444                         0 4E8E A   
.445                         0 4EA5 A   
.446                         0 4EC6 A   
.447                         0 4EBA A   
.448                         0 4EDB A   
.449                         0 4ED4 A   
.44A                         0 4ECD A   
.44B                         0 4EE7 A   
.44C                         0 4EE7 A   
.44D                         0 4EE2 A   
.44E                         0 4F01 A   
.44F                         0 4F10 A   
.45                          0 0A57 A   
.450                         0 4F2D A   
.451                         0 4F26 A   
.452                         0 4F32 A   
.453                         0 4F35 A   
.454                         0 4F3D A   
.455                         0 4F84 A   
.456                         0 4F6A A   
.457                         0 4F5D A   
.458                         0 4F84 A   
.459                         0 4F79 A   
.45A                         0 4FF8 A   
.45B                         0 4F8B A   
.45C                         0 4FF8 A   
.45D                         0 4F98 A   
.45E                         0 4FF8 A   
.45F                         0 4FED A   
.46                          0 09F3 A   
.460                         0 4F98 A   
.461                         0 4FC7 A   
.462                         0 4FAD A   
.463                         0 4FA0 A   
.464                         0 4FC7 A   
.465                         0 4FBC A   
.466                         0 4FED A   
.467                         0 4FCE A   
.468                         0 4FF8 A   
.469                         0 5001 A   
.46A                         0 5025 A   
.46B                         0 5017 A   
.46C                         0 D371 A   
.46D                         0 5038 A   
.46E                         0 5033 A   
.46F                         0 502C A   
.47                          0 0A00 A   
.470                         0 504A A   
.471                         0 506B A   
.472                         0 505F A   
.473                         0 507E A   
.474                         0 5079 A   
.475                         0 5072 A   
.476                         0 5098 A   
.477                         0 50BF A   
.478                         0 50C6 A   
.479                         0 50C8 A   
.47A                         0 50D4 A   
.47B                         0 50CF A   
.47C                         0 50D4 A   
.47D                         0 D349 A   
.47E                         0 5123 A   
.47F                         0 50FD A   
.48                          0 09FA A   
.480                         0 51B8 A   
.481                         0 515B A   
.482                         0 51AF A   
.483                         0 5193 A   
.484                         0 51A9 A   
.485                         0 51A3 A   
.486                         0 51BE A   
.487                         0 51C2 A   
.488                         0 5208 A   
.489                         0 51F6 A   
.48A                         0 D33E A   
.48B                         0 5227 A   
.48C                         0 5218 A   
.48D                         0 5218 A   
.48E                         0 5227 A   
.48F                         0 525A A   
.49                          0 0A54 A   
.490                         0 5248 A   
.491                         0 D333 A   
.492                         0 52B5 A   
.493                         0 52A3 A   
.494                         0 D329 A   
.495                         0 52D4 A   
.496                         0 52C5 A   
.497                         0 52C5 A   
.498                         0 52D4 A   
.499                         0 5301 A   
.49A                         0 52EF A   
.49B                         0 D31F A   
.49C                         0 5359 A   
.49D                         0 5347 A   
.49E                         0 D315 A   
.49F                         0 5393 A   
.4A                          0 0A46 A   
.4A0                         0 5384 A   
.4A1                         0 5384 A   
.4A2                         0 5393 A   
.4A3                         0 53D7 A   
.4A4                         0 53C6 A   
.4A5                         0 D30A A   
.4A6                         0 5427 A   
.4A7                         0 5415 A   
.4A8                         0 D2F0 A   
.4A9                         0 5951 A   
.4AB                         0 58FA A   
.4AC                         0 5444 A   
.4AD                         0 5463 A   
.4AE                         0 5474 A   
.4AF                         0 5485 A   
.4B                          0 0A4D A   
.4B0                         0 5496 A   
.4B1                         0 54A7 A   
.4B2                         0 54B8 A   
.4B3                         0 54F6 A   
.4B4                         0 54C1 A   
.4B5                         0 54E8 A   
.4B6                         0 54D8 A   
.4B7                         0 54F6 A   
.4B8                         0 54F9 A   
.4B9                         0 5537 A   
.4BA                         0 5502 A   
.4BB                         0 5529 A   
.4BC                         0 5519 A   
.4BD                         0 5537 A   
.4BE                         0 553A A   
.4BF                         0 5561 A   
.4C                          0 0A09 A   
.4C0                         0 5551 A   
.4C1                         0 556F A   
.4C2                         0 5572 A   
.4C3                         0 5599 A   
.4C4                         0 5589 A   
.4C5                         0 55A7 A   
.4C6                         0 55AA A   
.4C7                         0 55CF A   
.4C8                         0 55B3 A   
.4C9                         0 55D2 A   
.4CA                         0 55E9 A   
.4CB                         0 55DB A   
.4CC                         0 55EC A   
.4CD                         0 5630 A   
.4CE                         0 5607 A   
.4CF                         0 55F5 A   
.4D                          0 0A30 A   
.4D0                         0 55FE A   
.4D1                         0 564C A   
.4D2                         0 564F A   
.4D3                         0 566C A   
.4D4                         0 566A A   
.4D5                         0 5658 A   
.4D6                         0 5661 A   
.4D7                         0 567A A   
.4D8                         0 567D A   
.4D9                         0 5689 A   
.4DA                         0 5686 A   
.4DB                         0 56A8 A   
.4DC                         0 5690 A   
.4DD                         0 D2B9 A   
.4DE                         0 56C3 A   
.4DF                         0 56AF A   
.4E                          0 0A28 A   
.4E0                         0 56C3 A   
.4E1                         0 56B8 A   
.4E2                         0 5712 A   
.4E3                         0 56D5 A   
.4E4                         0 58BF A   
.4E5                         0 5758 A   
.4E6                         0 571B A   
.4E7                         0 58BF A   
.4E8                         0 5793 A   
.4E9                         0 576F A   
.4EA                         0 5761 A   
.4EB                         0 5768 A   
.4EC                         0 58BF A   
.4ED                         0 5830 A   
.4EE                         0 579E A   
.4EF                         0 57F3 A   
.4F                          0 0A3C A   
.4F0                         0 57BD A   
.4F1                         0 582D A   
.4F2                         0 58BF A   
.4F3                         0 588B A   
.4F4                         0 584F A   
.4F5                         0 58BF A   
.4F6                         0 58E4 A   
.4F7                         0 58D6 A   
.4F8                         0 58CF A   
.4F9                         0 D282 A   
.4FA                         0 5962 A   
.4FB                         0 595A A   
.4FC                         0 59BA A   
.4FD                         0 59B4 A   
.4FE                         0 59D0 A   
.4FF                         0 59C2 A   
.5                           0 059C A   
.50                          0 0A54 A   
.500                         0 5A1C A   
.501                         0 5A18 A   
.502                         0 5A41 A   
.503                         0 5A3D A   
.504                         0 5AC0 A   
.505                         0 5A66 A   
.506                         0 5A8D A   
.507                         0 5A6D A   
.508                         0 5AA5 A   
.509                         0 5ABE A   
.50A                         0 5AB8 A   
.50B                         0 5AC7 A   
.50C                         0 5B0E A   
.50D                         0 5B10 A   
.50E                         0 5B24 A   
.50F                         0 5B1D A   
.51                          0 0C1F A   
.510                         0 5D09 A   
.511                         0 5B2E A   
.512                         0 5C39 A   
.513                         0 5B5E A   
.514                         0 5C33 A   
.515                         0 5C26 A   
.516                         0 5BD6 A   
.517                         0 5C17 A   
.518                         0 5C19 A   
.51A                         0 5C39 A   
.51B                         0 5C70 A   
.51C                         0 5C40 A   
.51D                         0 5ECF A   
.51E                         0 5D13 A   
.51F                         0 5DC5 A   
.52                          0 0A73 A   
.520                         0 5DC1 A   
.521                         0 5DC7 A   
.522                         0 5E29 A   
.523                         0 5DDA A   
.524                         0 5DE5 A   
.525                         0 5DE1 A   
.526                         0 5DE7 A   
.527                         0 5DFE A   
.528                         0 5DFA A   
.529                         0 5E00 A   
.52A                         0 5E19 A   
.52B                         0 5E15 A   
.52C                         0 5E1B A   
.52D                         0 5E40 A   
.52E                         0 5E30 A   
.52F                         0 5EBB A   
.53                          0 0A5E A   
.530                         0 5EAD A   
.531                         0 5EB4 A   
.532                         0 5E97 A   
.533                         0 5EBB A   
.534                         0 6140 A   
.535                         0 5ED9 A   
.536                         0 5F28 A   
.537                         0 5F24 A   
.538                         0 5F2A A   
.539                         0 5F7D A   
.53A                         0 5F53 A   
.53B                         0 5F7D A   
.53C                         0 5FD8 A   
.53D                         0 5F86 A   
.53E                         0 602F A   
.53F                         0 602F A   
.54                          0 0C1F A   
.540                         0 5FDF A   
.541                         0 605C A   
.542                         0 6036 A   
.543                         0 605C A   
.544                         0 60B9 A   
.545                         0 609B A   
.546                         0 60CC A   
.547                         0 60C0 A   
.548                         0 60D6 A   
.549                         0 6113 A   
.54A                         0 60FA A   
.54B                         0 6101 A   
.54C                         0 60E2 A   
.54D                         0 6113 A   
.54E                         0 610C A   
.54F                         0 6108 A   
.55                          0 0B7E A   
.550                         0 610E A   
.551                         0 6132 A   
.552                         0 6125 A   
.553                         0 613D A   
.554                         0 618B A   
.555                         0 616B A   
.556                         0 6164 A   
.557                         0 D24B A   
.558                         0 61C3 A   
.559                         0 61A3 A   
.55A                         0 D20D A   
.55B                         0 68B2 A   
.55D                         0 6837 A   
.55E                         0 61C9 A   
.55F                         0 61DD A   
.56                          0 0A7C A   
.560                         0 6214 A   
.561                         0 620C A   
.562                         0 621A A   
.563                         0 621D A   
.564                         0 621D A   
.565                         0 621D A   
.566                         0 628D A   
.567                         0 6273 A   
.568                         0 626C A   
.569                         0 6265 A   
.56A                         0 D1D5 A   
.56B                         0 6301 A   
.56C                         0 62DE A   
.56D                         0 62D6 A   
.56E                         0 62CE A   
.56F                         0 D18D A   
.57                          0 0AED A   
.570                         0 630E A   
.571                         0 6308 A   
.572                         0 63B6 A   
.573                         0 6344 A   
.574                         0 633C A   
.575                         0 63F3 A   
.576                         0 63BD A   
.577                         0 6428 A   
.578                         0 645A A   
.579                         0 6435 A   
.57A                         0 D160 A   
.57B                         0 6463 A   
.57C                         0 D146 A   
.57D                         0 647E A   
.57E                         0 64FE A   
.57F                         0 652C A   
.58                          0 0AAB A   
.580                         0 6524 A   
.581                         0 6537 A   
.582                         0 653A A   
.583                         0 65B9 A   
.584                         0 65D3 A   
.585                         0 65D3 A   
.586                         0 65D3 A   
.587                         0 65D3 A   
.588                         0 6659 A   
.589                         0 663F A   
.58A                         0 D115 A   
.58B                         0 66C3 A   
.58C                         0 66A9 A   
.58D                         0 668D A   
.58E                         0 D0E4 A   
.58F                         0 66D7 A   
.59                          0 0AD5 A   
.590                         0 66D1 A   
.591                         0 66CA A   
.592                         0 6714 A   
.593                         0 66DE A   
.594                         0 6749 A   
.595                         0 678D A   
.596                         0 6768 A   
.597                         0 D0B7 A   
.598                         0 6796 A   
.599                         0 6796 A   
.59A                         0 679F A   
.59B                         0 67AD A   
.59C                         0 67C9 A   
.59D                         0 67C3 A   
.59E                         0 67D2 A   
.59F                         0 67F9 A   
.5A                          0 0AB5 A   
.5A1                         0 67E7 A   
.5A2                         0 67D7 A   
.5A3                         0 67D7 A   
.5A4                         0 67D7 A   
.5A5                         0 67D7 A   
.5A6                         0 67DF A   
.5A7                         0 67FC A   
.5A8                         0 67FC A   
.5A9                         0 67FC A   
.5AA                         0 67FC A   
.5AB                         0 67FC A   
.5AC                         0 D078 A   
.5AD                         0 6819 A   
.5AE                         0 6819 A   
.5AF                         0 6819 A   
.5B                          0 0AEA A   
.5B0                         0 6819 A   
.5B1                         0 6819 A   
.5B2                         0 D03E A   
.5B3                         0 687C A   
.5B4                         0 684A A   
.5B5                         0 68AF A   
.5B6                         0 688F A   
.5B7                         0 693E A   
.5B8                         0 691E A   
.5B9                         0 6917 A   
.5BA                         0 D00A A   
.5BB                         0 6976 A   
.5BC                         0 6956 A   
.5BD                         0 CFCF A   
.5BE                         0 6DA7 A   
.5C                          0 0B7B A   
.5C0                         0 6D2C A   
.5C1                         0 697C A   
.5C2                         0 697C A   
.5C3                         0 697C A   
.5C4                         0 697C A   
.5C5                         0 697C A   
.5C6                         0 697C A   
.5C7                         0 697C A   
.5C8                         0 697C A   
.5C9                         0 6985 A   
.5CA                         0 6985 A   
.5CB                         0 6985 A   
.5CC                         0 6993 A   
.5CD                         0 69CA A   
.5CE                         0 69C2 A   
.5CF                         0 69D0 A   
.5D                          0 0B0B A   
.5D0                         0 69D3 A   
.5D1                         0 69E1 A   
.5D2                         0 69FB A   
.5D3                         0 69FB A   
.5D4                         0 69FB A   
.5D5                         0 6A7C A   
.5D6                         0 6A62 A   
.5D7                         0 CF9D A   
.5D8                         0 6AA8 A   
.5D9                         0 6AA2 A   
.5DA                         0 6A9B A   
.5DB                         0 6B83 A   
.5DC                         0 6B5E A   
.5DD                         0 CF72 A   
.5DE                         0 6B8C A   
.5DF                         0 6B99 A   
.5E                          0 0AF4 A   
.5E0                         0 6B93 A   
.5E1                         0 6C55 A   
.5E3                         0 6C47 A   
.5E4                         0 6BB2 A   
.5E5                         0 6BC9 A   
.5E6                         0 6BB9 A   
.5E7                         0 6BED A   
.5E8                         0 6C04 A   
.5E9                         0 6BF4 A   
.5EA                         0 6C2C A   
.5EB                         0 6C28 A   
.5EC                         0 6C2E A   
.5ED                         0 6C33 A   
.5EE                         0 6C3E A   
.5EF                         0 6C3A A   
.5F                          0 0B7B A   
.5F0                         0 6C40 A   
.5F1                         0 6C5E A   
.5F2                         0 6C83 A   
.5F3                         0 6C78 A   
.5F4                         0 6CA8 A   
.5F5                         0 6C9D A   
.5F6                         0 6CB1 A   
.5F7                         0 6CCD A   
.5F8                         0 6CC7 A   
.5F9                         0 6CD6 A   
.5FA                         0 6CE4 A   
.5FB                         0 6D0B A   
.5FD                         0 6CF9 A   
.5FE                         0 6CE9 A   
.5FF                         0 6CE9 A   
.6                           0 0596 A   
.60                          0 0B7B A   
.600                         0 6CE9 A   
.601                         0 6CE9 A   
.602                         0 6CF1 A   
.603                         0 6D0E A   
.604                         0 6D0E A   
.605                         0 6D0E A   
.606                         0 6D0E A   
.607                         0 6D0E A   
.608                         0 6D0E A   
.609                         0 6D0E A   
.60A                         0 6D0E A   
.60B                         0 CF50 A   
.60C                         0 6D71 A   
.60D                         0 6D3F A   
.60E                         0 6DA4 A   
.60F                         0 6D84 A   
.61                          0 0B14 A   
.610                         0 6FAA A   
.612                         0 6F90 A   
.613                         0 6DFF A   
.614                         0 6DFF A   
.615                         0 6DFF A   
.616                         0 CF1F A   
.617                         0 6E19 A   
.618                         0 6F6C A   
.619                         0 6F5C A   
.61A                         0 6F73 A   
.61B                         0 CEFA A   
.61C                         0 7051 A   
.61D                         0 7031 A   
.61E                         0 7028 A   
.61F                         0 CEBB A   
.62                          0 0B21 A   
.620                         0 741B A   
.622                         0 73A0 A   
.623                         0 7057 A   
.624                         0 7057 A   
.625                         0 7057 A   
.626                         0 7057 A   
.627                         0 7057 A   
.628                         0 7057 A   
.629                         0 7057 A   
.62A                         0 7057 A   
.62B                         0 7060 A   
.62C                         0 7060 A   
.62D                         0 706E A   
.62E                         0 70A5 A   
.62F                         0 709D A   
.63                          0 0B1B A   
.630                         0 70AB A   
.631                         0 70AE A   
.632                         0 70AE A   
.633                         0 7111 A   
.634                         0 710B A   
.635                         0 712F A   
.636                         0 7129 A   
.637                         0 7121 A   
.638                         0 7119 A   
.639                         0 713C A   
.63A                         0 7136 A   
.63B                         0 72E7 A   
.63C                         0 72BD A   
.63D                         0 CE91 A   
.63E                         0 72F0 A   
.63F                         0 735E A   
.64                          0 0B7B A   
.641                         0 7352 A   
.642                         0 733B A   
.643                         0 7342 A   
.644                         0 7349 A   
.645                         0 7374 A   
.646                         0 7382 A   
.647                         0 7382 A   
.648                         0 7382 A   
.649                         0 7382 A   
.64A                         0 7382 A   
.64B                         0 7382 A   
.64C                         0 7382 A   
.64D                         0 7382 A   
.64E                         0 7382 A   
.64F                         0 7382 A   
.65                          0 0B6D A   
.650                         0 7382 A   
.651                         0 7382 A   
.652                         0 7382 A   
.653                         0 7382 A   
.654                         0 7382 A   
.655                         0 CE59 A   
.656                         0 73E5 A   
.657                         0 73B3 A   
.658                         0 7418 A   
.659                         0 73F8 A   
.65A                         0 74AC A   
.65B                         0 74A3 A   
.65C                         0 7497 A   
.65D                         0 74AC A   
.65E                         0 74E6 A   
.65F                         0 74DF A   
.66                          0 0B74 A   
.660                         0 74EB A   
.661                         0 7526 A   
.662                         0 751D A   
.663                         0 7511 A   
.664                         0 7526 A   
.665                         0 754C A   
.666                         0 752D A   
.667                         0 753D A   
.668                         0 7534 A   
.669                         0 752E A   
.66A                         0 753D A   
.66B                         0 756D A   
.66C                         0 7563 A   
.66D                         0 7582 A   
.66E                         0 757C A   
.66F                         0 7596 A   
.67                          0 0B2A A   
.670                         0 758F A   
.671                         0 75B9 A   
.672                         0 75B3 A   
.673                         0 75D8 A   
.674                         0 75D2 A   
.675                         0 75F9 A   
.676                         0 75EB A   
.677                         0 7601 A   
.678                         0 7686 A   
.67A                         0 7661 A   
.67B                         0 7606 A   
.67C                         0 7606 A   
.67D                         0 7618 A   
.67E                         0 7618 A   
.67F                         0 762A A   
.68                          0 0B57 A   
.680                         0 763C A   
.681                         0 763C A   
.682                         0 763C A   
.683                         0 764E A   
.684                         0 7684 A   
.685                         0 7674 A   
.686                         0 7695 A   
.687                         0 768D A   
.688                         0 769B A   
.689                         0 76E9 A   
.68A                         0 76E2 A   
.68B                         0 76DA A   
.68C                         0 76E9 A   
.68D                         0 7714 A   
.68E                         0 7704 A   
.68F                         0 7722 A   
.69                          0 0B4F A   
.690                         0 775C A   
.691                         0 774E A   
.692                         0 7764 A   
.693                         0 7773 A   
.694                         0 776B A   
.695                         0 777A A   
.696                         0 862B A   
.698                         0 85EC A   
.699                         0 7790 A   
.69A                         0 77B7 A   
.69B                         0 779D A   
.69C                         0 77D8 A   
.69D                         0 77CA A   
.69E                         0 77E0 A   
.69F                         0 7801 A   
.6A                          0 0B63 A   
.6A0                         0 77E7 A   
.6A1                         0 7829 A   
.6A2                         0 784C A   
.6A3                         0 7844 A   
.6A4                         0 7850 A   
.6A5                         0 7850 A   
.6A6                         0 7850 A   
.6A7                         0 78C0 A   
.6A8                         0 7893 A   
.6A9                         0 788C A   
.6AA                         0 7885 A   
.6AB                         0 787E A   
.6AC                         0 7877 A   
.6AD                         0 CE1E A   
.6AE                         0 78EE A   
.6AF                         0 78CF A   
.6B                          0 0B7B A   
.6B0                         0 792B A   
.6B1                         0 78FD A   
.6B2                         0 792B A   
.6B3                         0 790C A   
.6B4                         0 7938 A   
.6B5                         0 7932 A   
.6B6                         0 7968 A   
.6B7                         0 7961 A   
.6B8                         0 79A6 A   
.6B9                         0 7987 A   
.6BA                         0 7A6B A   
.6BB                         0 7A0F A   
.6BC                         0 7AB7 A   
.6BD                         0 7B7D A   
.6BE                         0 7B76 A   
.6BF                         0 7B3F A   
.6C                          0 0C1F A   
.6C0                         0 7B6E A   
.6C1                         0 7B4C A   
.6C2                         0 7B7D A   
.6C3                         0 7BBA A   
.6C4                         0 7BAC A   
.6C5                         0 CDFE A   
.6C6                         0 7C84 A   
.6C7                         0 7C31 A   
.6C8                         0 7C59 A   
.6C9                         0 7C38 A   
.6CA                         0 7C84 A   
.6CB                         0 7C76 A   
.6CC                         0 7C62 A   
.6CD                         0 7C84 A   
.6CE                         0 CDD8 A   
.6CF                         0 7CA6 A   
.6D                          0 0BBD A   
.6D0                         0 7CF7 A   
.6D1                         0 7CE1 A   
.6D2                         0 7CDA A   
.6D3                         0 7CD3 A   
.6D4                         0 7CCC A   
.6D5                         0 7CC5 A   
.6D6                         0 7D20 A   
.6D7                         0 7D06 A   
.6D8                         0 7D5D A   
.6D9                         0 7D2F A   
.6DA                         0 7D5D A   
.6DB                         0 7D3E A   
.6DC                         0 7D8D A   
.6DD                         0 7D86 A   
.6DE                         0 7DCA A   
.6DF                         0 7DAB A   
.6E                          0 0B85 A   
.6E0                         0 7F02 A   
.6E1                         0 7EFB A   
.6E2                         0 7EC9 A   
.6E3                         0 7EF3 A   
.6E4                         0 7ED6 A   
.6E5                         0 7F02 A   
.6E6                         0 7F3F A   
.6E7                         0 7F31 A   
.6E8                         0 CDB8 A   
.6E9                         0 7FE2 A   
.6EA                         0 7FB6 A   
.6EB                         0 7FD4 A   
.6EC                         0 7FBF A   
.6ED                         0 7FE2 A   
.6EE                         0 CD92 A   
.6EF                         0 800A A   
.6F                          0 0BA9 A   
.6F0                         0 8047 A   
.6F1                         0 8017 A   
.6F2                         0 8068 A   
.6F3                         0 8061 A   
.6F4                         0 8078 A   
.6F5                         0 8071 A   
.6F6                         0 808D A   
.6F7                         0 807F A   
.6F8                         0 8095 A   
.6F9                         0 8164 A   
.6FB                         0 813D A   
.6FC                         0 80B6 A   
.6FD                         0 80C3 A   
.6FE                         0 80D1 A   
.6FF                         0 80DF A   
.7                           0 05A7 A   
.70                          0 0B8F A   
.700                         0 80EC A   
.701                         0 80F9 A   
.702                         0 8106 A   
.703                         0 8113 A   
.704                         0 8120 A   
.705                         0 812D A   
.706                         0 CD72 A   
.707                         0 8162 A   
.708                         0 8150 A   
.709                         0 817D A   
.70A                         0 819B A   
.70B                         0 818A A   
.70C                         0 81BC A   
.70D                         0 81AE A   
.70E                         0 81C4 A   
.70F                         0 81DA A   
.71                          0 0BBB A   
.710                         0 81D3 A   
.711                         0 81DF A   
.712                         0 81E3 A   
.713                         0 820A A   
.714                         0 81F0 A   
.715                         0 8224 A   
.716                         0 8251 A   
.717                         0 8237 A   
.718                         0 827A A   
.719                         0 8260 A   
.71A                         0 8285 A   
.71B                         0 8281 A   
.71C                         0 8287 A   
.71D                         0 831D A   
.71F                         0 830B A   
.72                          0 0C1F A   
.720                         0 82A1 A   
.721                         0 82AB A   
.722                         0 82B5 A   
.723                         0 82BF A   
.724                         0 82E5 A   
.725                         0 82DB A   
.726                         0 82CE A   
.727                         0 82ED A   
.728                         0 82EF A   
.729                         0 833E A   
.72A                         0 8389 A   
.72B                         0 836F A   
.72C                         0 83B2 A   
.72D                         0 8398 A   
.72E                         0 83EA A   
.72F                         0 83C1 A   
.73                          0 0BD6 A   
.730                         0 83EA A   
.731                         0 83D0 A   
.732                         0 840B A   
.733                         0 83FD A   
.734                         0 8413 A   
.735                         0 841E A   
.736                         0 841A A   
.737                         0 8420 A   
.738                         0 8575 A   
.73A                         0 854E A   
.73B                         0 8440 A   
.73C                         0 8443 A   
.73D                         0 8443 A   
.73E                         0 8443 A   
.73F                         0 8443 A   
.74                          0 0BC4 A   
.740                         0 8466 A   
.741                         0 8459 A   
.742                         0 844B A   
.743                         0 8452 A   
.744                         0 8469 A   
.745                         0 848E A   
.746                         0 847F A   
.747                         0 8471 A   
.748                         0 8478 A   
.749                         0 84AA A   
.74A                         0 84AA A   
.74B                         0 849D A   
.74C                         0 8496 A   
.74D                         0 84AD A   
.74E                         0 84C9 A   
.74F                         0 84BC A   
.75                          0 0C1F A   
.750                         0 84B5 A   
.751                         0 84CC A   
.752                         0 84FE A   
.753                         0 84D4 A   
.754                         0 84EA A   
.755                         0 84DB A   
.756                         0 84FE A   
.757                         0 84FE A   
.758                         0 84F1 A   
.759                         0 8500 A   
.75A                         0 8548 A   
.75B                         0 8508 A   
.75C                         0 851E A   
.75D                         0 850F A   
.75E                         0 8548 A   
.75F                         0 8534 A   
.76                          0 0BFC A   
.760                         0 8525 A   
.761                         0 8548 A   
.762                         0 8548 A   
.763                         0 853B A   
.764                         0 854A A   
.765                         0 8573 A   
.766                         0 8561 A   
.767                         0 8593 A   
.768                         0 857C A   
.769                         0 85BC A   
.76A                         0 CD4D A   
.76B                         0 8611 A   
.76C                         0 85FF A   
.76D                         0 865E A   
.76E                         0 8651 A   
.76F                         0 CD26 A   
.77                          0 0BDD A   
.770                         0 8794 A   
.771                         0 86AA A   
.772                         0 86A1 A   
.773                         0 8697 A   
.774                         0 8728 A   
.775                         0 86C2 A   
.776                         0 8728 A   
.777                         0 8711 A   
.778                         0 870A A   
.779                         0 8728 A   
.77A                         0 8721 A   
.77B                         0 8766 A   
.77C                         0 872F A   
.77D                         0 878A A   
.77E                         0 8782 A   
.77F                         0 879C A   
.78                          0 0C1F A   
.780                         0 8835 A   
.781                         0 8809 A   
.782                         0 884A A   
.783                         0 884A A   
.784                         0 883C A   
.785                         0 CD11 A   
.786                         0 8877 A   
.787                         0 8862 A   
.788                         0 CCF5 A   
.789                         0 89A6 A   
.78B                         0 898C A   
.78C                         0 8886 A   
.78D                         0 8886 A   
.78E                         0 8892 A   
.78F                         0 888E A   
.79                          0 0C11 A   
.790                         0 8894 A   
.791                         0 88E4 A   
.792                         0 88D3 A   
.793                         0 891D A   
.794                         0 88FB A   
.795                         0 88EC A   
.796                         0 891D A   
.797                         0 890D A   
.798                         0 8935 A   
.799                         0 895B A   
.79A                         0 8942 A   
.79B                         0 8978 A   
.79C                         0 8986 A   
.79D                         0 CCE1 A   
.79E                         0 90AF A   
.7A                          0 0C03 A   
.7A0                         0 9084 A   
.7A1                         0 89E8 A   
.7A2                         0 8A0C A   
.7A3                         0 8A2F A   
.7A4                         0 8A41 A   
.7A5                         0 8A36 A   
.7A6                         0 8ADD A   
.7A7                         0 8A58 A   
.7A8                         0 8AAA A   
.7A9                         0 8A9D A   
.7AA                         0 8A94 A   
.7AB                         0 8ACD A   
.7AC                         0 8AC2 A   
.7AD                         0 8AB3 A   
.7AE                         0 8B48 A   
.7AF                         0 8B1F A   
.7B                          0 0C1F A   
.7B0                         0 8B12 A   
.7B1                         0 8B09 A   
.7B2                         0 8B42 A   
.7B3                         0 8B37 A   
.7B4                         0 8B28 A   
.7B5                         0 8B66 A   
.7B6                         0 8B70 A   
.7B7                         0 8B6D A   
.7B8                         0 8C01 A   
.7B9                         0 8B85 A   
.7BA                         0 8BAB A   
.7BB                         0 8BA3 A   
.7BC                         0 8B9C A   
.7BD                         0 8BC0 A   
.7BE                         0 8BBB A   
.7BF                         0 8BB4 A   
.7C                          0 D9E9 A   
.7C0                         0 8C63 A   
.7C1                         0 8C1F A   
.7C2                         0 8C17 A   
.7C3                         0 8C10 A   
.7C4                         0 8C34 A   
.7C5                         0 8C2F A   
.7C6                         0 8C28 A   
.7C7                         0 8C9C A   
.7C8                         0 8CB3 A   
.7C9                         0 8CA8 A   
.7CA                         0 8D1A A   
.7CB                         0 8CC8 A   
.7CC                         0 8D4A A   
.7CD                         0 8D5B A   
.7CE                         0 8D70 A   
.7CF                         0 8D62 A   
.7D                          0 0C35 A   
.7D0                         0 8DE7 A   
.7D1                         0 8D85 A   
.7D2                         0 8E27 A   
.7D3                         0 8E55 A   
.7D4                         0 8E7A A   
.7D5                         0 8E6F A   
.7D6                         0 8E84 A   
.7D7                         0 8E81 A   
.7D8                         0 8F0D A   
.7D9                         0 8E90 A   
.7DA                         0 8EE6 A   
.7DB                         0 8EDE A   
.7DC                         0 8ED7 A   
.7DD                         0 8EFB A   
.7DE                         0 8EF6 A   
.7DF                         0 8EEF A   
.7E                          0 0C4A A   
.7E0                         0 8F70 A   
.7E1                         0 8F4B A   
.7E2                         0 8F43 A   
.7E3                         0 8F3C A   
.7E4                         0 8F60 A   
.7E5                         0 8F5B A   
.7E6                         0 8F54 A   
.7E7                         0 8FA7 A   
.7E8                         0 8FDB A   
.7E9                         0 8FF2 A   
.7EA                         0 8FE2 A   
.7EB                         0 CCC6 A   
.7EC                         0 906A A   
.7ED                         0 900F A   
.7EE                         0 8FF9 A   
.7EF                         0 CCA0 A   
.7F                          0 0C57 A   
.7F0                         0 906A A   
.7F1                         0 9029 A   
.7F2                         0 9016 A   
.7F3                         0 CC88 A   
.7F4                         0 906A A   
.7F5                         0 906A A   
.7F6                         0 9030 A   
.7F7                         0 9050 A   
.7F8                         0 9037 A   
.7F9                         0 CC5C A   
.7FA                         0 906A A   
.7FB                         0 CC20 A   
.7FC                         0 907A A   
.7FD                         0 90A7 A   
.7FE                         0 9097 A   
.7FF                         0 9197 A   
.8                           0 06A6 A   
.80                          0 0C53 A   
.800                         0 90E5 A   
.801                         0 90F2 A   
.802                         0 90EE A   
.803                         0 9197 A   
.804                         0 90FD A   
.805                         0 9197 A   
.806                         0 9106 A   
.807                         0 916B A   
.808                         0 9123 A   
.809                         0 9194 A   
.80A                         0 CC20 A   
.80B                         0 CC5C A   
.80C                         0 CC88 A   
.80D                         0 CCA0 A   
.80E                         0 CCC6 A   
.80F                         0 CCE1 A   
.81                          0 0C97 A   
.810                         0 CCF5 A   
.811                         0 CD11 A   
.812                         0 CD26 A   
.813                         0 CD4D A   
.814                         0 CD72 A   
.815                         0 CD92 A   
.816                         0 CDB8 A   
.817                         0 CDD8 A   
.818                         0 CDFE A   
.819                         0 CE1E A   
.81A                         0 CE59 A   
.81B                         0 CE91 A   
.81C                         0 CEBB A   
.81D                         0 CEFA A   
.81E                         0 CF1F A   
.81F                         0 CF50 A   
.82                          0 0C7D A   
.820                         0 CF72 A   
.821                         0 CF9D A   
.822                         0 CFCF A   
.823                         0 D00A A   
.824                         0 D03E A   
.825                         0 D078 A   
.826                         0 D0B7 A   
.827                         0 D0E4 A   
.828                         0 D115 A   
.829                         0 D146 A   
.82A                         0 D160 A   
.82B                         0 D18D A   
.82C                         0 D1D5 A   
.82D                         0 D20D A   
.82E                         0 D24B A   
.82F                         0 D282 A   
.83                          0 0C70 A   
.830                         0 D2B9 A   
.831                         0 D2F0 A   
.832                         0 D30A A   
.833                         0 D315 A   
.834                         0 D31F A   
.835                         0 D329 A   
.836                         0 D333 A   
.837                         0 D33E A   
.838                         0 D349 A   
.839                         0 D371 A   
.83A                         0 D395 A   
.83B                         0 D3B9 A   
.83C                         0 D3F3 A   
.83D                         0 D42D A   
.83E                         0 D447 A   
.83F                         0 D473 A   
.84                          0 0C97 A   
.840                         0 D49F A   
.841                         0 D4CB A   
.842                         0 D4F6 A   
.843                         0 D530 A   
.844                         0 D547 A   
.845                         0 D576 A   
.846                         0 D5B6 A   
.847                         0 D5D0 A   
.848                         0 D5E6 A   
.849                         0 D602 A   
.84A                         0 D62A A   
.84B                         0 D650 A   
.84C                         0 D67C A   
.84D                         0 D67E A   
.84E                         0 D685 A   
.84F                         0 D68C A   
.85                          0 0C8C A   
.850                         0 D6A6 A   
.851                         0 D6B8 A   
.852                         0 D6D2 A   
.853                         0 D6D5 A   
.854                         0 D6DC A   
.855                         0 D6E3 A   
.856                         0 D6EE A   
.857                         0 D70E A   
.858                         0 D72E A   
.859                         0 D731 A   
.85A                         0 D738 A   
.85B                         0 D73F A   
.85C                         0 D74A A   
.85D                         0 D775 A   
.85E                         0 D785 A   
.85F                         0 D78C A   
.86                          0 0CD5 A   
.860                         0 D792 A   
.861                         0 D796 A   
.862                         0 D79B A   
.863                         0 D7C0 A   
.864                         0 D7E9 A   
.865                         0 D7F7 A   
.866                         0 D810 A   
.867                         0 D82B A   
.868                         0 D82F A   
.869                         0 D844 A   
.86A                         0 D858 A   
.86B                         0 D878 A   
.86C                         0 D87B A   
.86D                         0 D89A A   
.86E                         0 D8B0 A   
.86F                         0 D8BC A   
.87                          0 0CCA A   
.870                         0 D8CC A   
.871                         0 D8D1 A   
.872                         0 D8D7 A   
.873                         0 D8E7 A   
.874                         0 D8F7 A   
.875                         0 D8F9 A   
.876                         0 D8FB A   
.877                         0 D901 A   
.878                         0 D904 A   
.879                         0 D908 A   
.87A                         0 D90D A   
.87B                         0 D923 A   
.87C                         0 D93E A   
.87D                         0 D962 A   
.87E                         0 D96B A   
.87F                         0 D997 A   
.88                          0 0C9F A   
.880                         0 D9B1 A   
.881                         0 D9D6 A   
.882                         0 D9E9 A   
.883                         0 DA06 A   
.89                          0 0CCA A   
.8A                          0 0CBB A   
.8B                          0 0CD5 A   
.8C                          0 0D12 A   
.8D                          0 0CF8 A   
.8E                          0 0CEB A   
.8F                          0 0D12 A   
.9                           0 0697 A   
.90                          0 0D07 A   
.91                          0 0D21 A   
.92                          0 0D19 A   
.93                          0 0D51 A   
.94                          0 0D37 A   
.95                          0 0D29 A   
.96                          0 0D51 A   
.97                          0 0D46 A   
.98                          0 0D61 A   
.99                          0 0D58 A   
.9A                          0 0D77 A   
.9B                          0 0D6E A   
.9C                          0 0DB5 A   
.9D                          0 0D9B A   
.9E                          0 0D8D A   
.9F                          0 0DB5 A   
.A                           0 06BE A   
.A0                          0 0DAA A   
.A1                          0 0DC5 A   
.A2                          0 0DBC A   
.A3                          0 0DF5 A   
.A4                          0 0DDB A   
.A5                          0 0DCD A   
.A6                          0 0DF5 A   
.A7                          0 0DEA A   
.A8                          0 0E05 A   
.A9                          0 0DFC A   
.AA                          0 0E1B A   
.AB                          0 0E12 A   
.AC                          0 0E59 A   
.AD                          0 0E3F A   
.AE                          0 0E31 A   
.AF                          0 0E59 A   
.B                           0 06AF A   
.B0                          0 0E4E A   
.B1                          0 0E69 A   
.B2                          0 0E60 A   
.B3                          0 0EA7 A   
.B4                          0 0E8D A   
.B5                          0 0E7F A   
.B6                          0 0EA7 A   
.B7                          0 0E9C A   
.B8                          0 0EB7 A   
.B9                          0 0EAE A   
.BA                          0 0EF5 A   
.BB                          0 0EDB A   
.BC                          0 0ECD A   
.BD                          0 0EF5 A   
.BE                          0 0EEA A   
.BF                          0 0F05 A   
.C                           0 06E2 A   
.C0                          0 0EFC A   
.C1                          0 0F35 A   
.C2                          0 0F1B A   
.C3                          0 0F0D A   
.C4                          0 0F35 A   
.C5                          0 0F2A A   
.C6                          0 0F45 A   
.C7                          0 0F3C A   
.C8                          0 0F5B A   
.C9                          0 0F52 A   
.CA                          0 0F8B A   
.CB                          0 0F71 A   
.CC                          0 0F63 A   
.CD                          0 0F8B A   
.CE                          0 0F80 A   
.CF                          0 0F9B A   
.D                           0 06C7 A   
.D0                          0 0F92 A   
.D1                          0 0FB1 A   
.D2                          0 0FA8 A   
.D3                          0 0FEF A   
.D4                          0 0FD5 A   
.D5                          0 0FC7 A   
.D6                          0 0FEF A   
.D7                          0 0FE4 A   
.D8                          0 0FFF A   
.D9                          0 0FF6 A   
.DA                          0 102F A   
.DB                          0 1015 A   
.DC                          0 1007 A   
.DD                          0 102F A   
.DE                          0 1024 A   
.DF                          0 103F A   
.E                           0 06D7 A   
.E0                          0 1036 A   
.E1                          0 1055 A   
.E2                          0 104C A   
.E3                          0 1093 A   
.E4                          0 1079 A   
.E5                          0 106B A   
.E6                          0 1093 A   
.E7                          0 1088 A   
.E8                          0 10A3 A   
.E9                          0 109A A   
.EA                          0 10E1 A   
.EB                          0 10C7 A   
.EC                          0 10B9 A   
.ED                          0 10E1 A   
.EE                          0 10D6 A   
.EF                          0 10F1 A   
.F                           0 06CE A   
.F0                          0 10E8 A   
.F1                          0 112F A   
.F2                          0 1115 A   
.F3                          0 1107 A   
.F4                          0 112F A   
.F5                          0 1124 A   
.F6                          0 113F A   
.F7                          0 1136 A   
.F8                          0 116F A   
.F9                          0 1155 A   
.FA                          0 1147 A   
.FB                          0 116F A   
.FC                          0 1164 A   
.FD                          0 117F A   
.FE                          0 1176 A   
.FF                          0 1195 A   
.FFDA                        0 7C84 A   
.FFDD                        0 7445 A   
.FFDE                        0 7434 A   
.FFDF                        0 7420 A   
.FFE0                        0 7440 A   
.FFE2                        0 741B A   
.FFE3                        0 6FCF A   
.FFE4                        0 6FAA A   
.FFE6                        0 6DD1 A   
.FFE7                        0 6DC0 A   
.FFE8                        0 6DAC A   
.FFE9                        0 6DCC A   
.FFEB                        0 6DA7 A   
.FFEC                        0 68B7 A   
.FFED                        0 68DC A   
.FFEE                        0 68CB A   
.FFEF                        0 68D7 A   
.FFF1                        0 68B2 A   
.FFF4                        0 4D4E A   
.FFFA                        0 33AF A   
BcdToBin                     0 95CD A   
__memcpyb                    0 001B A E 
__memcpyd                    0 0038 A E 
__memsetb                    0 0000 A E 
__read_byte                  0 05E4 A E 
__read_dword                 0 0056 A E 
__read_word                  0 05F2 A E 
__write_byte                 0 0600 A E 
__write_byte_SS              0 063C A E 
__write_dword                0 0067 A E 
__write_word                 0 0613 A E 
__write_word_SS              0 064C A E 
_apm16_entry                 0 975A A   
_apm32_entry                 0 9675 A   
_apmreal_entry               0 9825 A   
_ata_cmd_data_io             0 2985 A E 
_ata_cmd_non_data            0 297E A E 
_ata_cmd_packet              0 2D4A A E 
_ata_detect                  0 1B8F A E 
_ata_init                    0 184D A E 
_ata_reset                   0 285E A E 
_atapi_get_sense             0 31F4 A E 
_atapi_is_cdrom              0 34DC A E 
_atapi_is_ready              0 3279 A E 
_await_ide                   0 1A2F A   
_bcd2bin                     0 05CB A E 
_bin2bcd                     0 05AE A E 
_bios_printf                 0 093E A E 
_bios_svn_version_string     0 016C A   
_cdemu_emulated_drive        0 357E A E 
_cdemu_init                  0 3543 A E 
_cdemu_isactive              0 3562 A E 
_cdrom_boot                  0 35B8 A E 
_check_for_keystroke         0 08F7 A E 
_debugger_off                0 179B A E 
_debugger_on                 0 1789 A E 
_delay_ticks                 0 0852 A E 
_delay_ticks_and_check_for+  0 090D A E 
_dequeue_key                 0 5135 A E 
_determine_floppy_media      0 8678 A E 
_drivetypes                  0 120D A   
_eltorito                    0 35A0 A   
_enable_mouse_int_and_even+  0 528F A E 
_enqueue_key                 0 5974 A E 
_floppy_drive_exists         0 7736 A E 
_floppy_drive_recal          0 76B0 A E 
_floppy_media_known          0 7550 A E 
_floppy_media_sense          0 75C0 A E 
_floppy_prepare_controller   0 74B0 A E 
_floppy_reset_controller     0 7462 A E 
_get_CS                      0 065C A E 
_get_SS                      0 065F A E 
_get_boot_vector             0 136E A   
_get_ebda_seg                0 066C A E 
_get_keystroke               0 0905 A E 
_get_mouse_data              0 537D A E 
_inb                         0 04F8 A E 
_inb_cmos                    0 053D A E 
_inhibit_mouse_int_and_eve+  0 51E2 A E 
_init_boot_vectors           0 123F A   
_init_rtc                    0 0549 A E 
_int09_function              0 5402 A E 
_int13_cdemu                 0 6FF1 A E 
_int13_cdrom                 0 68F9 A E 
_int13_diskette_function     0 777E A E 
_int13_edd                   0 5AD1 A E 
_int13_eltorito              0 6DEE A E 
_int13_harddisk              0 6146 A E 
_int14_function              0 3A97 A E 
_int15_function              0 3CC4 A E 
_int15_function32            0 48D0 A E 
_int15_function_mouse        0 41AE A E 
_int16_function              0 4D85 A E 
_int17_function              0 8679 A E 
_int18_panic_msg             0 170E A E 
_int19_function              0 87A0 A E 
_int1a_function              0 89DC A E 
_int70_function              0 90B3 A E 
_int74_function              0 59F8 A E 
_interactive_bootkey         0 13BB A E 
_inw                         0 0503 A E 
_isotag                      0 359A A   
_keyboard_init               0 0C63 A E 
_keyboard_panic              0 11A7 A E 
_log_bios_start              0 1720 A E 
_nmi_handler_msg             0 16FC A E 
_outb                        0 050E A E 
_outb_cmos                   0 052E A E 
_outw                        0 051E A E 
_panic_msg_keyb_buffer_ful+  0 51C2 A   
_print_bios_banner           0 11E6 A E 
_print_boot_device           0 15B7 A E 
_print_boot_failure          0 1681 A E 
_print_cdromboot_failure     0 16E7 A E 
_put_luint                   0 0767 A E 
_put_str                     0 081E A E 
_put_uint                    0 06E4 A E 
_read_byte_SS                0 0626 A E 
_read_dword_SS               0 007E A E 
_read_word_SS                0 0631 A E 
_rtc_updating                0 057A A E 
_s3_resume                   0 17AC A E 
_s3_resume_panic             0 11D4 A E 
_scan_to_scanascii           0 017E A   
_send                        0 068B A E 
_send_to_mouse_ctrl          0 5333 A E 
_set_DS                      0 0662 A E 
_set_diskette_current_cyl    0 8647 A E 
_set_diskette_ret_status     0 862F A E 
_set_e820_range              0 4832 A E 
_set_enable_a20              0 1736 A E 
_set_kbd_command_byte        0 53B4 A E 
_shutdown_status_panic       0 11BC A E 
_vgafont8                    0 FA6E A   
_wrch                        0 067B A E 
apm16_04                     0 975B A   
apm16_05                     0 9762 A   
apm16_07                     0 976B A   
apm16_07_1                   0 978F A   
apm16_07_poweroff            0 9785 A   
apm16_07_poweroff_str        0 9741 A   
apm16_07_standby             0 97A1 A   
apm16_07_standby_str         0 9752 A   
apm16_07_suspend             0 9792 A   
apm16_07_suspend_str         0 974A A   
apm16_08                     0 97B0 A   
apm16_0a                     0 97B6 A   
apm16_0b                     0 97CA A   
apm16_0e                     0 97D2 A   
apm16_0f                     0 97DC A   
apm16_10                     0 97E2 A   
apm16_error                  0 97F0 A   
apm16_ok                     0 97ED A   
apm16_out_str                0 9729 A   
apm16_out_str1               0 9730 A   
apm16_out_str2               0 973C A   
apm16_unimplemented          0 97F0 A   
apm32_04                     0 9677 A   
apm32_05                     0 9680 A   
apm32_07                     0 968B A   
apm32_07_1                   0 96BC A   
apm32_07_poweroff            0 96AE A   
apm32_07_poweroff_str        0 965C A   
apm32_07_standby             0 96D0 A   
apm32_07_standby_str         0 966D A   
apm32_07_suspend             0 96BF A   
apm32_07_suspend_str         0 9665 A   
apm32_08                     0 96E1 A   
apm32_0a                     0 96E7 A   
apm32_0b                     0 96FD A   
apm32_0e                     0 9705 A   
apm32_0f                     0 970F A   
apm32_10                     0 9715 A   
apm32_error                  0 9725 A   
apm32_ok                     0 9721 A   
apm32_out_str                0 9649 A   
apm32_out_str1               0 964D A   
apm32_out_str2               0 9659 A   
apm32_unimplemented          0 9725 A   
apm_call                     0 F894 A   
apmreal_00                   0 9825 A   
apmreal_01                   0 9837 A   
apmreal_02                   0 983E A   
apmreal_03                   0 9854 A   
apmreal_04                   0 9873 A   
apmreal_05                   0 987A A   
apmreal_07                   0 9883 A   
apmreal_07_1                 0 98A7 A   
apmreal_07_poweroff          0 989D A   
apmreal_07_poweroff_str      0 980B A   
apmreal_07_standby           0 98B9 A   
apmreal_07_standby_str       0 981C A   
apmreal_07_suspend           0 98AA A   
apmreal_07_suspend_str       0 9814 A   
apmreal_08                   0 98C8 A   
apmreal_0a                   0 98CE A   
apmreal_0b                   0 98E2 A   
apmreal_0e                   0 98EA A   
apmreal_0f                   0 98F4 A   
apmreal_10                   0 98FA A   
apmreal_error                0 990A A   
apmreal_ok                   0 9905 A   
apmreal_out_str              0 97F3 A   
apmreal_out_str1             0 97FA A   
apmreal_out_str2             0 9806 A   
apmreal_unimplemented        0 990A A   
ata_in_16                    0 2C4A A   
ata_in_32                    0 2C4E A   
ata_in_adjust                0 2C36 A   
ata_in_done                  0 2C51 A   
ata_in_no_adjust             0 2C3D A   
ata_out_16                   0 2C80 A   
ata_out_32                   0 2C85 A   
ata_out_adjust               0 2C6C A   
ata_out_done                 0 2C89 A   
ata_out_no_adjust            0 2C73 A   
ata_packet_after             0 317F A   
ata_packet_done              0 3199 A   
ata_packet_in_16             0 3178 A   
ata_packet_in_32             0 317C A   
ata_packet_in_after_16       0 318C A   
ata_packet_in_after_32       0 3191 A   
ata_packet_in_after_32_loo+  0 3193 A   
ata_packet_in_before_16      0 3156 A   
ata_packet_in_before_32      0 315B A   
ata_packet_in_before_32_lo+  0 315D A   
ata_packet_no_before         0 3163 A   
bios32_end                   0 9968 A   
bios32_entry_point           0 9920 A   
bios32_structure             0 9910 A   
bios_table_area_end          0 CC00 A   
bios_table_area_start        0 A180 A   
block_count_rounded          0 A00D A   
carry_set                    0 91D2 A   
check_for_hd1                0 9465 A   
checksum_loop                0 9F5E A   
checksum_out                 0 9F78 A   
detect_parport               0 9F03 A   
detect_serial                0 9F22 A   
diskette_param_table         0 EFC7 A   
diskette_param_table2        0 EFDE A   
done                         0 0904 A   
dummy_iret_handler           0 FF53 A   
dummy_master_pic_irq_handl+  0 E9E6 A   
dummy_slave_pic_irq_handle+  0 E9EC A   
ebda_post                    0 954F A   
enable_iomem_space           0 9E01 A   
eoi_both_pics                0 95C4 A   
eoi_jmp_post                 0 9564 A   
eoi_master_pic               0 95C8 A   
f0_missing                   0 92E3 A   
f1_missing                   0 92EE A   
floppy_drive_post            0 92A8 A   
halt2_loop                   0 0C54 A   
hard_drive_post              0 932F A   
hd0_post_above_2048          0 9427 A   
hd0_post_above_4096          0 9435 A   
hd0_post_above_8192          0 9443 A   
hd0_post_checksum_loop       0 9458 A   
hd0_post_logical_chs         0 9406 A   
hd0_post_physical_chs        0 93F8 A   
hd0_post_store_logical       0 9449 A   
hd1_post_above_2048          0 9510 A   
hd1_post_above_4096          0 951E A   
hd1_post_above_8192          0 952C A   
hd1_post_checksum_loop       0 9541 A   
hd1_post_logical_chs         0 94EF A   
hd1_post_physical_chs        0 94E2 A   
hd1_post_store_logical       0 9532 A   
idiv_                        0 0136 A   
idiv_u                       0 013A A   
imodu                        0 0165 A   
init_io_base                 0 9DD4 A   
initial_int_vector_offset_+  0 FEF3 A   
int08_floppy_off             0 FEC4 A   
int08_handler                0 FEA5 A   
int08_store_ticks            0 FED9 A   
int09_check_pause            0 E9BB A   
int09_done                   0 E9CC A   
int09_finish                 0 E9D7 A   
int09_handler                0 E987 A   
int09_process_key            0 E9C9 A   
int0e_handler                0 EF57 A   
int0e_loop1                  0 EF69 A   
int0e_loop2                  0 EF73 A   
int0e_normal                 0 EF81 A   
int10_handler                0 F065 A   
int11_handler                0 F84D A   
int12_handler                0 F841 A   
int13_cdemu_inactive         0 922A A   
int13_cdrom_rme_end          0 6C95 A   
int13_disk                   0 925F A   
int13_diskette               0 EC59 A   
int13_handler                0 E3FE A   
int13_legacy                 0 9232 A   
int13_nocdemu                0 9217 A   
int13_noeltorito             0 922E A   
int13_not_eltorito           0 91EE A   
int13_notcdrom               0 925F A   
int13_notfloppy              0 9246 A   
int13_out                    0 926C A   
int13_relocated              0 91DB A   
int14_handler                0 E739 A   
int1586_tick                 0 4931 A   
int1586_tick_end             0 493F A   
int15_handler                0 F859 A   
int15_handler32              0 F8A2 A   
int15_handler32_ret          0 F88E A   
int15_handler_mouse          0 F89D A   
int15_handler_mouse_ret      0 F88D A   
int15_stub                   0 F897 A   
int16_F00                    0 E859 A   
int16_handler                0 E82E A   
int16_key_found              0 E876 A   
int16_wait_for_key           0 E869 A   
int16_zero_clear             0 E847 A   
int16_zero_set               0 E850 A   
int17_handler                0 EFD2 A   
int18_handler                0 9270 A   
int19_handler                0 E6F2 A   
int19_load_done              0 88C7 A   
int19_next_boot              0 92A3 A   
int19_relocated              0 928C A   
int1a_callfunction           0 FE8D A   
int1a_handler                0 FE6E A   
int1a_normal                 0 FE87 A   
int70_handler                0 FE93 A   
int71_handler                0 E9DD A   
int74_done                   0 91BD A   
int74_handler                0 919E A   
int75_handler                0 E2C7 A   
int76_handler                0 9632 A   
iret_modify_cf               0 91C7 A   
iret_post_0x467              0 9598 A   
is_master_pic                0 9E29 A   
jmp_post_0x467               0 9590 A   
laddl                        0 0094 A   
laddul                       0 0094 A   
landl                        0 008C A   
landul                       0 008C A   
lcmpl                        0 009C A   
lcmpul                       0 009C A   
ldecl                        0 00D3 A   
ldecul                       0 00D3 A   
ldivul                       0 013F A   
lincl                        0 00E0 A   
lincul                       0 00E0 A   
lmull                        0 00BA A   
lmulul                       0 00BA A   
look_drive0                  0 92DA A   
look_drive1                  0 92E5 A   
lorl                         0 00D8 A   
lorul                        0 00D8 A   
lsl_exit                     0 0135 A   
lsl_loop                     0 0129 A   
lsll                         0 0118 A   
lslul                        0 0118 A   
lsr_exit                     0 0117 A   
lsr_loop                     0 010B A   
lsrul                        0 00FA A   
lsubl                        0 00B2 A   
lsubul                       0 00B2 A   
ltstl                        0 00E5 A   
ltstul                       0 00E5 A   
memcpyb_end                  0 0031 A   
memcpyd_end                  0 004F A   
memsetb_end                  0 0015 A   
next_pci_base                0 9DF3 A   
next_pci_dev                 0 9E0D A   
next_pci_func                0 9EEA A   
next_pir_entry               0 9EF4 A   
nmi                          0 E2C3 A   
no_bcv                       0 A05D A   
no_bev                       0 A096 A   
no_key                       0 0902 A   
no_parport                   0 9F21 A   
no_prod_str                  0 A08E A   
no_serial                    0 9F45 A   
normal_post                  0 E0A3 A   
pci_found                    0 9953 A   
pci_init_end                 0 9F00 A   
pci_init_io_loop1            0 9D75 A   
pci_init_io_loop2            0 9D92 A   
pci_init_irq_loop1           0 9E83 A   
pci_init_irq_loop2           0 9E88 A   
pci_irq_list                 0 9D40 A   
pci_present                  0 9B27 A   
pci_pro_devloop              0 999E A   
pci_pro_devloop2             0 99D4 A   
pci_pro_f02                  0 998D A   
pci_pro_f03                  0 99C9 A   
pci_pro_f08                  0 9A02 A   
pci_pro_f09                  0 9A21 A   
pci_pro_f0a                  0 9A3F A   
pci_pro_f0b                  0 9A53 A   
pci_pro_f0c                  0 9A6F A   
pci_pro_f0d                  0 9A8D A   
pci_pro_fail                 0 9AA3 A   
pci_pro_get_max_bus          0 9AAF A   
pci_pro_nextdev              0 99B9 A   
pci_pro_nextdev2             0 99F2 A   
pci_pro_no_i440bx            0 9ACE A   
pci_pro_ok                   0 9AA8 A   
pci_pro_select_reg           0 9AD0 A   
pci_pro_unknown              0 9AA1 A   
pci_real_devloop             0 9B5B A   
pci_real_devloop2            0 9B8D A   
pci_real_f02                 0 9B48 A   
pci_real_f03                 0 9B84 A   
pci_real_f08                 0 9BBA A   
pci_real_f09                 0 9BD2 A   
pci_real_f0a                 0 9BEA A   
pci_real_f0b                 0 9BFD A   
pci_real_f0c                 0 9C14 A   
pci_real_f0d                 0 9C2B A   
pci_real_f0e                 0 9C3E A   
pci_real_fail                0 9C6E A   
pci_real_get_max_bus         0 9C7C A   
pci_real_nextdev             0 9B71 A   
pci_real_nextdev2            0 9BA7 A   
pci_real_no_i440bx           0 9C9C A   
pci_real_ok                  0 9C74 A   
pci_real_select_reg          0 9C9F A   
pci_real_too_small           0 9C66 A   
pci_real_unknown             0 9C6C A   
pci_routing_table_structur+  0 9CC0 A   
pci_routing_table_structur+  0 9D40 A   
pci_routing_table_structur+  0 9CE0 A   
pci_test_int_pin             0 9E9D A   
pcibios_error                0 FE7B A   
pcibios_init_iomem_bases     0 9D5F A   
pcibios_init_irqs            0 9E36 A   
pcibios_init_sel_reg         0 9D44 A   
pcibios_init_set_elcr        0 9E1D A   
pcibios_protected            0 9970 A   
pcibios_real                 0 9AED A   
pirq_found                   0 9ED9 A   
pmode_IDT_info               0 F8AB A   
pnpbios_00                   0 9FC7 A   
pnpbios_code                 0 9FAE A   
pnpbios_exit                 0 9FE6 A   
pnpbios_fail                 0 9FE3 A   
pnpbios_prot                 0 9FA1 A   
pnpbios_real                 0 9FA8 A   
pnpbios_structure            0 9F80 A   
post                         0 E05B A   
post_d0_extended             0 9391 A   
post_d0_type47               0 93A2 A   
post_d1_exists               0 9470 A   
post_d1_extended             0 947B A   
post_d1_type47               0 948C A   
post_default_master_pic_in+  0 A0EA A   
post_default_slave_pic_int+  0 A0FA A   
post_init_ivt                0 A0CF A   
post_init_pic                0 A0AA A   
protected_mode               0 3F9D A   
protmode_switch              0 40AF A   
real_mode                    0 3FC7 A   
retf_post_0x467              0 95A5 A   
rmode_IDT_info               0 F8B1 A   
rom_checksum                 0 9F47 A   
rom_scan                     0 9FE9 A   
rom_scan_increment           0 A098 A   
rom_scan_loop                0 9FE9 A   
s3_post                      0 95B2 A   
timer_tick_post              0 95DC A   
unknown_service              0 9966 A   
vga_init_ok                  0 E215 A   

00000 errors
00000 warnings
